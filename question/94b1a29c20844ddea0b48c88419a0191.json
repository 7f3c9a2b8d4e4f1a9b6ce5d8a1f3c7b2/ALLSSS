[
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Authorization Bypass] Can an attacker specify a malicious manager address in input.Manager to create schemes they don't control, then manipulate beneficiaries and profit distributions through the manager role, violating the invariant that scheme creators control their schemes? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Collision Attack] Can an attacker craft CreateSchemeInput parameters to generate a schemeId collision with an existing scheme via GenerateSchemeId(), bypassing the 'Already exists' assertion at line 59 through hash manipulation or transaction ordering? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [DoS] Can an attacker create unlimited schemes for a manager address, causing the ManagingSchemeIds list to grow unbounded (lines 62-71), leading to gas exhaustion when iterating schemes or DoS on manager operations? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Validation Bypass] Can ProfitReceivingDuePeriodCount be set to exactly MaximumProfitReceivingDuePeriodCount (1024) at line 53, but later operations assume values strictly less than the maximum, causing integer overflow or unexpected behavior in profit claiming logic? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [State Corruption] If input.Manager is null and Context.Sender is a contract address at line 57, can the scheme become unmanageable if that contract is later destroyed or upgraded, permanently locking scheme management functions? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Circular Reference] Can an attacker create a circular profit scheme hierarchy (A->B->C->A) by adding schemes as sub-schemes of each other, causing infinite loops or stack overflow during DistributeProfits when traversing the scheme tree? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Authorization Bypass] At line 99, only scheme.Manager can add sub-schemes, but can TokenHolder contract exploit this by adding arbitrary sub-schemes if it becomes a manager through ResetManager, draining profits to malicious schemes? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Accounting Error] When AddBeneficiary is called at line 109-118 with EndPeriod=long.MaxValue, does this permanently increase TotalShares without a corresponding removal mechanism, causing profit dilution attacks where shares never expire? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Duplicate Entry] The check at line 100-101 uses All() to verify sub-scheme uniqueness, but can concurrent transactions add the same SubSchemeId twice before state commits, causing duplicate entries and double-allocation of profits? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Share Manipulation] Can SubSchemeShares be set to long.MaxValue at line 94 check (>0), causing integer overflow when added to scheme.TotalShares in AddBeneficiary at line 182, leading to share accounting corruption? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [State Inconsistency] Lines 121-126 add to scheme.SubSchemes after calling AddBeneficiary, but if AddBeneficiary reverts, is there a state where ProfitDetailsMap is updated but SubSchemes list is not, causing profit calculation mismatches? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Profit Theft] At line 150, ProfitDetails are zeroed out but not removed from state. Can an attacker re-add the same sub-scheme with different shares, then claim historical profits that should have been cleared? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Accounting Error] Line 152 subtracts shares.Shares from TotalShares, but if the sub-scheme has unclaimed profits in DistributedProfitsMap, does removing it cause those tokens to become permanently locked in virtual addresses? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Authorization Bypass] Can a malicious manager remove a sub-scheme immediately after DistributeProfits but before sub-scheme beneficiaries claim, effectively stealing profits intended for downstream beneficiaries? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Integer Underflow] If shares.Shares > scheme.TotalShares due to prior corruption, does line 152's Sub() operation cause underflow, wrapping TotalShares to a massive value and breaking all future profit calculations? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [DoS] Line 141 uses SingleOrDefault which iterates all SubSchemes. Can an attacker add thousands of sub-schemes then remove them one-by-one, causing gas exhaustion and preventing legitimate sub-scheme removal? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Authorization Bypass] Lines 171-174 allow TokenHolder contract to add beneficiaries. Can a compromised or malicious TokenHolder contract add itself or colluding addresses as beneficiaries with maximum shares to drain all profits? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Share Inflation] Line 182 adds shares to TotalShares without checking if TotalShares + Shares causes overflow. Can an attacker add beneficiaries with long.MaxValue shares repeatedly until TotalShares overflows, corrupting all profit calculations? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Timing Attack] If EndPeriod is set to exactly scheme.CurrentPeriod at line 179, does the beneficiary immediately become eligible for profit removal at line 206, allowing them to claim shares without ever receiving profits? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Period Manipulation] Line 161-163 defaults EndPeriod to long.MaxValue if 0. Can this cause issues in RemoveProfitDetails at line 206 where old details are filtered by EndPeriod + ProfitReceivingDuePeriodCount < CurrentPeriod, creating unkillable beneficiaries? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [State Bloat] Lines 204-207 remove old profit details, but the condition requires details.EndPeriod != long.MaxValue. Can permanent beneficiaries (EndPeriod=MaxValue) accumulate unlimited ProfitDetail entries, causing state bloat and gas exhaustion? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Delayed Distribution] Line 188 sets StartPeriod to CurrentPeriod + DelayDistributePeriodCount. If DelayDistributePeriodCount is very large, can beneficiaries be added but never receive profits due to expired EndPeriod before StartPeriod becomes active? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Duplicate Detail Accumulation] Lines 194-201 append new ProfitDetails without checking for duplicates by beneficiary+shares+period. Can the same beneficiary be added multiple times per period, multiplying their profit share unfairly? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Zero Share Bypass] Line 221 checks Shares >= 0, allowing zero-share beneficiaries. Can attackers add thousands of zero-share beneficiaries to bloat ProfitDetailsMap and cause DoS in profit claiming iterations? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveBeneficiary()] [Accounting Error] Line 260 subtracts removedDetails.Values.Sum() from TotalShares, but if RemoveProfitDetails fails to properly calculate removed shares due to IsWeightRemoved flag confusion, can TotalShares become incorrect? (High)"
]