[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Caller Validation] Is MinersCountOfConsent used in threshold checks without validation? If a caller assumes it's always > 0 but it could be 0 or negative in edge cases, could this bypass consensus requirements? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Return Value Handling] If callers assume the returned list always has MinersCountOfConsent elements to compute median/consensus but it returns fewer, could index-out-of-bounds or incorrect LIB calculation occur? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Caller Authorization] Is there any access control on who can call this method? If it's public, can external actors query miner heights to gain information for timing attacks on consensus? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [State Consistency] If this method is called mid-round while miners are updating ImpliedIrreversibleBlockHeight values, could a race condition produce inconsistent sorted lists across different nodes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Cache Invalidation] If MinersCountOfConsent is cached and RealTimeMinersInformation.Count changes, could stale cache values cause consensus calculations to use outdated thresholds? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Parameter Injection] If specificPublicKeys parameter comes from untrusted source without validation (e.g., user input or cross-chain message), could attacker inject malicious pubkeys or omit honest miners to manipulate consensus? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Type Safety] Do the Mul(), Div(), Add() extension methods handle integer type boundaries correctly? If Count is uint or long, could type mismatches cause incorrect conversions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Time-of-Check-Time-of-Use] Between filtering miners by specificPublicKeys and accessing their ImpliedIrreversibleBlockHeight, if a miner is removed from RealTimeMinersInformation, could this cause KeyNotFoundException? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Data Source Trust] Is RealTimeMinersInformation.Count validated elsewhere to ensure it represents actual active miners? If inactive/malicious miners are counted, does this inflate MinersCountOfConsent and make consensus harder to achieve? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Height Validation] Are ImpliedIrreversibleBlockHeight values validated when set? Could a malicious miner set an impossibly high value (e.g., future block) to manipulate the sorted list and consensus calculation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Pubkey Uniqueness] Does the code assume Pubkey values are unique in RealTimeMinersInformation? If duplicate pubkeys exist, could this cause double-counting in consensus calculations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Miner Set Changes] If RealTimeMinersInformation.Count changes between consensus rounds without proper synchronization, could MinersCountOfConsent be calculated with stale miner counts? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Historical Heights] If ImpliedIrreversibleBlockHeight values are from previous rounds and not cleared, could stale heights be included in current round's consensus calculation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Single Miner] If RealTimeMinersInformation.Count == 1, MinersCountOfConsent = 1*2/3+1 = 0+1 = 1, allowing a single miner to control consensus - is this intentional for single-node test environments or a security issue? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Two Miners] If RealTimeMinersInformation.Count == 2, MinersCountOfConsent = 2*2/3+1 = 1+1 = 2, requiring both miners - is this too strict, preventing any fault tolerance? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Single Height] If only one miner in specificPublicKeys has height > 0, the returned list has one element - do callers handle single-element lists correctly for consensus? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [All Same Heights] If all miners report identical ImpliedIrreversibleBlockHeight, the sorted list has all duplicates - does the consensus algorithm handle uniform agreement correctly? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Maximum Miners] If RealTimeMinersInformation.Count reaches system maximum (e.g., 1000+ miners), does MinersCountOfConsent calculation remain efficient and correct? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Max Height Value] If a miner reports ImpliedIrreversibleBlockHeight = Int64.MaxValue, does sorting handle it correctly without overflow in comparison operations? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [LIB Calculation] If this method is used to compute Last Irreversible Block by taking the (MinersCountOfConsent)th element from sorted list, but the list has fewer elements, does it cause array access violation? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Consensus Failure] If the returned list length < MinersCountOfConsent, does the consensus algorithm fail gracefully or enter an invalid state? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Quorum Calculation] If MinersCountOfConsent is used for quorum but doesn't account for offline/Byzantine miners, could consensus be blocked even when honest majority exists? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Median Selection] If the caller computes median from sorted list for LIB but doesn't validate list size first, could it access wrong index and use incorrect height? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Byzantine Tolerance] Is the formula Count*2/3+1 sufficient for Byzantine fault tolerance? BFT requires n >= 3f+1 where f is max faulty nodes, so MinersCountOfConsent should be 2f+1 = 2*(n-1)/3+1 = (2n-2+3)/3 = (2n+1)/3 - is the current calculation missing safety margin? (Critical)"
]