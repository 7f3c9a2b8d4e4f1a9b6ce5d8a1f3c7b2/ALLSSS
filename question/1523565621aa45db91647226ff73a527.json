[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Authorization Bypass] Can any account call ApplyNormalConsensusData() without authentication checks, allowing non-miners to submit consensus data for valid miner pubkeys, potentially corrupting round state by injecting malicious outValue/signature values? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Missing Signature Verification] The signature parameter is never cryptographically verified against the pubkey - can an attacker submit arbitrary signature values for any valid pubkey, manipulating supposedOrderOfNextRound calculation via controlled signature hash values? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Impersonation Attack] Since there's no check that msg.sender owns the provided pubkey, can attacker A call this function with victim miner B's pubkey and malicious consensus data, overwriting B's legitimate OutValue and Signature fields? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Replay Attack] No nonce or timestamp validation exists - can an attacker replay the same (pubkey, previousInValue, outValue, signature) tuple multiple times to repeatedly modify FinalOrderOfNextRound assignments? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Cross-Round Replay] Is there validation that the consensus data belongs to the current round? Can an attacker replay consensus data from previous rounds to corrupt current round state? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Null/Empty Hash Validation] Lines 12-13 accept any Hash values for outValue and signature without validation - can an attacker pass Hash.Empty or null to corrupt miner state or cause downstream calculation failures? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [PreviousInValue Validation] Line 16 accepts any previousInValue without verifying it matches expected VRF chain continuity - can an attacker break the VRF chain by submitting invalid previousInValue values? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Pubkey Format Validation] Line 10 only checks ContainsKey but doesn't validate pubkey string format - can malformed pubkeys cause downstream parsing errors or security bypasses? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Hash Collision Exploitation] If outValue or signature are crafted hash collisions, can an attacker manipulate the ToInt64() conversion on line 19 to predict and control the resulting supposedOrderOfNextRound value? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Unconditional Overwrite] Lines 12-13 unconditionally overwrite OutValue and Signature without checking if they were previously set - can the first attacker to call this function lock in malicious values before the legitimate miner? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Last-Write-Wins Race] Multiple calls for the same pubkey result in last-write-wins for OutValue/Signature - in a race condition between legitimate miner and attacker, how is the valid submission protected? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [PreviousInValue Immutability Bypass] Lines 14-16 only set PreviousInValue if it's Empty or null - can an attacker set it to a non-empty malicious value first to prevent legitimate updates, causing VRF chain breakage? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Partial State Corruption] If an attacker calls this function with only some fields valid, can they create inconsistent miner state where OutValue is attacker-controlled but other VRF fields are legitimate? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Order Reassignment Attack] Lines 42-44 set both SupposedOrderOfNextRound and FinalOrderOfNextRound - can an attacker trigger multiple reassignments by calling this repeatedly with different signature values to destabilize next round ordering? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Integer Overflow in ToInt64] Line 19 converts signature Hash to int64 - can a specially crafted signature hash cause overflow/underflow in sigNum that breaks the modulus calculation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [GetAbsModulus Edge Case] Line 21 calls GetAbsModulus(sigNum, minersCount) - what happens if minersCount is 0, 1, or negative? Can this cause division by zero or unexpected order values? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Order Calculation Predictability] Line 21 uses GetAbsModulus(sigNum, minersCount) + 1 - can an attacker brute-force signature values offline to generate a desired supposedOrderOfNextRound, manipulating their position in next round? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Order Range Violation] supposedOrderOfNextRound is calculated as GetAbsModulus(sigNum, minersCount) + 1 - is the result guaranteed to be in range [1, minersCount]? Can it exceed valid miner positions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Modulus Bias Attack] GetAbsModulus on line 21 may introduce modulo bias for non-power-of-2 minersCount - can an attacker exploit this bias to favor certain order positions statistically? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Negative sigNum Handling] Line 19 produces sigNum from ToInt64() which can be negative - does GetAbsModulus correctly handle negative inputs to prevent negative or out-of-range supposedOrderOfNextRound? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Conflict Detection Race] Lines 25-26 detect conflicts via LINQ query - if two miners simultaneously calculate the same supposedOrderOfNextRound, can the race condition in conflict detection leave both with the same FinalOrderOfNextRound? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Infinite Loop in Conflict Resolution] Lines 31-40 search for available order positions - if all positions are occupied, does the loop exit gracefully or continue indefinitely causing DOS? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Conflict Resolution Loop Bound] Line 31 iterates from supposedOrderOfNextRound + 1 to minersCount * 2 - can an attacker cause gas exhaustion by triggering conflicts that force iteration through all 2*minersCount positions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Unfair Order Assignment] Lines 31-40 assign conflicted miners to next available position - can early callers monopolize favorable order positions while late callers get pushed to unfavorable positions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Conflict Cascading] When line 36 reassigns a conflicted miner's FinalOrderOfNextRound, can this create a new conflict with another miner, causing cascading reassignments that aren't handled? (High)"
]