[
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Authorization] Can an attacker create schemes with arbitrary manager addresses by manipulating input.Manager to gain control over schemes they don't own, allowing unauthorized profit distribution and beneficiary management? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [State Collision] Can an attacker cause scheme ID collisions by manipulating the GenerateSchemeId() input parameters, potentially overwriting existing schemes or gaining unauthorized access to scheme virtual addresses? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Validation Bypass] If input.ProfitReceivingDuePeriodCount is set to exactly MaximumProfitReceivingDuePeriodCount (1024), can this cause integer overflow in subsequent period calculations when added to CurrentPeriod, leading to incorrect profit expiration logic? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [State Inconsistency] The assertion at line 59 checks if scheme already exists, but between the check and line 60 assignment, could a race condition allow duplicate scheme creation if multiple transactions target the same schemeId? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Default Value Risk] When input.ProfitReceivingDuePeriodCount is 0, it defaults to DefaultProfitReceivingDuePeriodCount (10). Can this cause unexpected profit expiration for schemes expecting longer retention periods, resulting in profit loss for beneficiaries? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Manager Tracking] At lines 62-71, if scheme.Manager is set to a specific address but ManagingSchemeIds tracks a different address due to race conditions, can this cause orphaned schemes that cannot be managed? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: CreateScheme()] [Virtual Address] Can an attacker create schemes with crafted tokens/parameters to generate predictable virtual addresses, allowing front-running attacks to drain profits before legitimate beneficiaries? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: GenerateSchemeId()] [ID Collision] At lines 964-971, when createSchemeInput.Token is null, schemeId is generated from createdSchemeCount. Can an attacker manipulate their scheme creation count to generate colliding IDs with other managers' schemes? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: GenerateSchemeId()] [Deterministic ID] Since GenerateSchemeId uses Context.GenerateId with predictable inputs (manager address and count), can attackers pre-compute scheme IDs to target specific virtual addresses for profit sniping? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Circular Dependency] The function only checks if schemeId != subSchemeId at line 93, but doesn't validate transitive circular dependencies (A->B->C->A). Can this create infinite loops during profit distribution causing DoS? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Share Accounting] When adding a sub-scheme, AddBeneficiary is called at line 109 with EndPeriod = long.MaxValue. Can this cause TotalShares to grow unboundedly, leading to incorrect profit calculations or integer overflow? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Authorization Bypass] At line 99, only scheme.Manager can add sub-schemes. However, can the TokenHolder contract (which has special privileges in AddBeneficiary) bypass this check to add unauthorized sub-schemes? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [State Inconsistency] Lines 121-126 add the sub-scheme to scheme.SubSchemes AFTER calling AddBeneficiary. If AddBeneficiary fails or reverts, could this leave TotalShares updated without the corresponding sub-scheme entry? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Duplicate Detection] Line 100 checks if sub-scheme already exists using LINQ All(). If SubSchemes list is large, can this cause excessive gas consumption, enabling DoS attacks by adding many sub-schemes first? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Shares Validation] Input.SubSchemeShares is validated to be > 0 at line 94, but there's no upper bound check. Can an attacker add a sub-scheme with extremely high shares (e.g., long.MaxValue) to monopolize all profits? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddSubScheme()] [Virtual Address Manipulation] The virtual address for sub-scheme is derived at line 107. Can an attacker create a regular beneficiary with the same address as a sub-scheme's virtual address to double-claim profits? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Share Accounting] At line 152, TotalShares is reduced by shares.Shares using Sub(). If this causes underflow (TotalShares < shares.Shares), does the Sub() extension handle this safely or can it cause state corruption? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Profit Loss] At line 150, ProfitDetails is set to empty, but any unclaimed profits in the sub-scheme's virtual address are not transferred out. Can this cause permanent profit loss for beneficiaries who haven't claimed yet? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Silent Failure] If shares is null at line 142, the function returns Empty() without error. Can this silent failure be exploited to make managers believe sub-schemes are removed when they're not? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [CachedDelayTotalShares] Unlike RemoveBeneficiary which updates CachedDelayTotalShares, RemoveSubScheme doesn't update this cache. Can this cause incorrect TotalShares calculations during delayed distribution periods? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: RemoveSubScheme()] [Orphaned Profits] After removing sub-scheme beneficiary details at line 150, the sub-scheme itself still exists and can receive profits. Can removed sub-schemes continue accumulating profits that become inaccessible? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Period Validation] At line 179, EndPeriod must be >= CurrentPeriod. But if EndPeriod equals CurrentPeriod and distribution happens immediately, can the beneficiary miss all profits from that period? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Share Overflow] Line 182 adds input shares to TotalShares without checking for overflow. Can an attacker add beneficiaries with large share values to overflow TotalShares to 0 or negative, breaking profit distribution? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Delayed Distribution] StartPeriod is set to CurrentPeriod + DelayDistributePeriodCount at line 188. If DelayDistributePeriodCount is large, can beneficiaries added just before distribution miss multiple periods of profits? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: AddBeneficiary()] [Authorization Bypass] Lines 171-174 allow either scheme.Manager OR TokenHolder contract. Can TokenHolder contract add beneficiaries with malicious parameters (huge shares, incorrect periods) without manager consent? (High)"
]