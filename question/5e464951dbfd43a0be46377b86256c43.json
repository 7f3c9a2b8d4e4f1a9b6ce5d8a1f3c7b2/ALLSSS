[
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: ValidateDescriptionUrlScheme()] [Empty String Bypass] Line 117-118 returns true for null or empty strings. Can proposals have no description URL at all, reducing transparency? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: ValidateDescriptionUrlScheme()] [Malicious URL] Lines 119-120 only validate HTTP/HTTPS schemes. Can attackers host phishing or malicious content on valid HTTP URLs? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: ValidateDescriptionUrlScheme()] [URL Length] There's no validation of URL length in this function. Can extremely long URLs cause DOS or storage issues? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: ValidateDescriptionUrlScheme()] [Relative URL] The check uses UriKind.Absolute on line 119. Can relative URLs bypass validation? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: ValidateDescriptionUrlScheme()] [Special Characters] URI.TryCreate on line 119 may accept encoded URLs with special characters. Can these be used for injection attacks in systems consuming this data? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetValidProposal()] [TOCTOU Race] Lines 126-128 validate the proposal, but can the proposal state be modified between retrieval and validation, causing inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetValidProposal()] [Null Proposal] Line 127 asserts proposal != null but doesn't prevent proposals from being deleted after validation. Can this cause null reference errors in calling code? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetValidProposal()] [Validation Bypass] If the Validate function on line 128 has bugs, can invalid proposals be retrieved and used? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetValidProposal()] [Expired Proposal Use] The Validate check on line 128 verifies expiration, but can an expired proposal still be valid for some operations after this returns? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetTokenInfo()] [External Call Failure] Line 135 makes an external call to TokenContract. Can this revert if the token contract is paused or upgraded, blocking all referendum operations? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetTokenInfo()] [Symbol Validation] There's no validation that the symbol parameter is non-empty before calling the token contract on lines 135-138. Can empty symbols cause unexpected behavior? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetTokenInfo()] [Return Value] The function returns TokenInfo but doesn't validate the returned data. Can a malicious or buggy token contract return invalid TokenInfo? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetTokenInfo()] [DOS via Gas] The external call on line 135 could consume unbounded gas if the token contract is malicious. Can this be used for DOS? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance()] [Allowance Check Timing] Line 150 asserts allowance > 0, but can the allowance be reduced or revoked between this check and actual usage in LockToken()? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance()] [Virtual Address Spender] Line 147 uses GetProposalVirtualAddress(proposalId) as the spender. Can this virtual address be manipulated to check allowance for unintended addresses? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance()] [Zero Allowance] Line 150 checks allowance > 0, but can an allowance of exactly 1 wei be set to pass the check while being insufficient for actual locking? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance()] [Owner Validation] There's no validation that the owner parameter on line 145 is the actual token holder. Can allowances be checked for arbitrary addresses? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance()] [External Call] The GetAllowance call on line 144 is an external call that could fail or be manipulated. Can this be exploited to DOS referendum operations? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance()] [Symbol Validation] No validation that tokenSymbol on line 148 matches the organization's required token. Can allowances for wrong tokens be checked? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GenerateProposalId()] [Token Manipulation] Line 156 uses input.Token if provided, otherwise computes from input. Can an attacker provide a custom Token value to generate predictable or colliding proposal IDs? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GenerateProposalId()] [ID Collision] If input.Token is null, line 156 computes hash from entire input. Can two different inputs generate the same proposal ID? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GenerateProposalId()] [Deterministic ID] The Context.GenerateId on line 156 might be deterministic. Can attackers predict proposal IDs and front-run proposal creation? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GenerateProposalId()] [Token Reuse] If an attacker reuses the same input.Token value across multiple calls, will they get the same proposalId, causing proposal overwrites? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CreateNewProposal()] [Proposal Overwrite] Line 163 checks if proposal already exists but the check is after ID generation on line 162. Can there be a race condition where two proposals get the same ID? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CreateNewProposal()] [Validation Bypass] CheckCreateProposalInput is called on line 161 before GenerateProposalId. Can an attacker modify input after validation but before ID generation? (Low)"
]