[
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Authorization Bypass] Lines 176-179 allow anyone to recharge any side chain without authorization check - can attacker drain their own tokens by recharging wrong chain or manipulate chain status? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Reentrancy] Lines 181-188 call TransferFrom before checking arrears and updating state at lines 191-213 - can attacker reenter during transfer to corrupt debt calculation? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Integer Overflow] Line 196 sums arrears with 'arrearsAmount += arrears.Value' without overflow check - can attacker cause overflow to bypass debt payment by accumulating massive arrears? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Accounting Error] Lines 197-203 transfer arrears to proposers inside loop but calculate total arrearsAmount separately - can mismatch between transferred and recorded amounts cause accounting discrepancy? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Reentrancy] Lines 197-203 call TransferDepositToken in loop for each arrears entry - can malicious proposer reenter during their payment to drain recharge amount? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Integer Overflow] Line 207 checks 'input.Amount + originBalance >= arrearsAmount + IndexingPrice' - can overflow in addition cause this check to pass when it should fail? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Validation Gap] Line 207 requires balance >= arrearsAmount + IndexingPrice but never checks for sufficient balance to pay NEXT block indexing - can chain run out of funds immediately after recharge? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [State Manipulation] Lines 211-213 clear ArrearsInfo and set status to Active before verification completes - if assertion at 207 fails after state modification, is side chain state corrupted? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [DoS Vector] Line 194 loops through all ArrearsInfo entries without gas limit check - can attacker grief by accumulating thousands of small arrears entries causing recharge to run out of gas? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Address Parsing Exploit] Line 199 parses address from ByteString.FromBase64(arrears.Key) without validation - can malicious arrears entry with invalid base64 cause recharge to fail permanently? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Authorization Bypass] Line 224 only checks AssertSideChainLifetimeControllerAuthority without verifying disposal proposal was properly approved - can controller dispose side chain without community approval? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Race Condition] Lines 231-232 TryGetIndexingProposal and ResetChainIndexingProposal have TOCTOU gap - can attacker submit new proposal between check and reset? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Reentrancy] Line 234 UnlockTokenAndResource performs external token transfers before updating status at line 235 - can proposer reenter to unlock tokens multiple times? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Token Loss] Line 234 unlocks tokens to proposer but if proposer address is malicious contract that reverts on receive, are tokens permanently locked? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [State Inconsistency] Lines 231-232 reset indexing proposal but never verify all pending cross-chain data for this chain is cleared - can orphaned proposals cause issues? (Low)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: AdjustIndexingFeePrice()] [Authorization Bypass] Line 251 checks Context.Sender == expectedOrganizationAddress but never validates organization still has members or valid thresholds - can empty organization adjust fees? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: AdjustIndexingFeePrice()] [Integer Overflow] Line 249 allows IndexingFee >= 0 including max int64 - can attacker set astronomical fee causing integer overflow in debt calculations? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: AdjustIndexingFeePrice()] [Economic Attack] Line 252 immediately applies new IndexingPrice without grace period - can malicious controller suddenly increase price 1000x to force side chain into debt status? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: AdjustIndexingFeePrice()] [Validation Gap] No check that new IndexingFee is within reasonable bounds relative to locked amount - can attacker set fee > locked amount causing immediate debt? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ChangeSideChainIndexingFeeController()] [Authorization Bypass] Line 261 only checks current controller is sender but never validates new controller has legitimate members - can controller transfer control to attacker-controlled organization? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ChangeSideChainIndexingFeeController()] [Validation Gap] Line 262 calls ValidateAuthorityInfoExists but never checks new controller's contract address matches expected authorization contract - can attacker set controller to malicious contract? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ProposeCrossChainIndexing()] [Replay Protection] Line 285 calls EnsureTransactionOnlyExecutedOnceInOneBlock using State.LatestExecutedHeight - can attacker exploit this by submitting identical transaction in next block to replay proposal? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ProposeCrossChainIndexing()] [Authorization Bypass] Line 286 AssertAddressIsCurrentMiner checks if sender is miner but never validates miner is authorized for specific chain ID being proposed - can miner propose data for chains they don't validate? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ProposeCrossChainIndexing()] [DoS Vector] Line 287 ClearCrossChainIndexingProposalIfExpired loops through all proposals without gas limit - can attacker create thousands of proposals to make this function run out of gas? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ProposeCrossChainIndexing()] [Validation Bypass] Line 288 ValidateCrossChainDataBeforeIndexing returns CrossChainDataDto but never verifies data size limits - can attacker submit gigabytes of cross-chain data causing state bloat? (Medium)"
]