[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [String Parsing] CheckSymbolIdentifier() splits symbol by NFTSymbolSeparator and checks if words[0] or words[1] equals allSymbolIdentifier - can crafted symbols with multiple separators cause array index out of bounds when accessing words[1]? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [Logic Bypass] The function returns true if words[1].Equals(allSymbolIdentifier) when words.Length > 1, but does not validate what words[0] contains - can an attacker prepend arbitrary prefixes to all-symbol identifiers to bypass intended restrictions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [Identifier Collision] If GetAllSymbolIdentifier() returns a common string that could naturally appear in legitimate token symbols, can CheckSymbolIdentifier() false-positive on regular tokens, causing them to be treated as all-symbol allowances? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: CheckSymbolIdentifier()] [Empty String Handling] If symbol is empty or null, does symbol.Split() throw exceptions or return unexpected arrays that cause CheckSymbolIdentifier() to return incorrect boolean values? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: IsInWhiteList()] [Default Value] IsInWhiteList() directly returns State.LockWhiteLists[input.Symbol][input.Address] - if this mapping is uninitialized for a symbol-address pair, does it return false (safe) or can uninitialized state cause undefined behavior? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: IsInWhiteList()] [Input Validation] Does IsInWhiteList() validate that input.Symbol exists and input.Address is valid before state lookup, or can querying non-existent symbols return misleading whitelist status? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: IsInWhiteList()] [Whitelist Purpose] The function checks LockWhiteLists but doesn't validate the purpose of whitelisting - can addresses be whitelisted for one lock type but the status misused for different lock operations? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Lock ID Null Check] GetLockedAmount() asserts input.LockId != null, but does it validate that LockId is non-empty or contains valid hash data before using it in GetVirtualAddressForLocking()? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Virtual Address Collision] GetLockedAmount() derives virtualAddress from Address and LockId, but if hash collisions occur in GetVirtualAddressForLocking(), can an attacker query locked amounts of different users by crafting colliding LockIds? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Symbol Validation] GetLockedAmount() queries balance using input.Symbol without resolving aliases via GetActualTokenSymbol() - can this cause locked amount queries to fail or return incorrect values for aliased tokens? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetLockedAmount()] [Balance Query] The function calls GetBalance(virtualAddress, input.Symbol) but doesn't verify the virtualAddress was properly computed - can failures in virtual address generation lead to querying wrong addresses and reporting incorrect locked amounts? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Hash Collision] GetVirtualAddressForLocking() uses HashHelper.ComputeFrom() to concatenate Context.Sender, input.Address, and input.LockId - can an attacker find different combinations that produce the same hash, allowing them to access another user's locked funds? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Context.Sender Dependency] The virtual address computation includes Context.Sender.Value - can different callers querying the same Address+LockId get different virtual addresses, breaking the invariant that locked amounts should be consistent regardless of querier? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Input Validation] Does GetVirtualAddressForLocking() validate that input.Address and input.LockId are non-null before concatenating, or can null values cause hash computation to produce predictable virtual addresses? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetVirtualAddressForLocking()] [Virtual Address Conversion] After computing fromVirtualAddress hash, the function calls Context.ConvertVirtualAddressToContractAddress() - can this conversion fail or return an already-used address causing locked fund confusion? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCrossChainTransferTokenContractAddress()] [Uninitialized State] GetCrossChainTransferTokenContractAddress() returns State.CrossChainTransferWhiteList[input.ChainId] directly - if a ChainId is not whitelisted, does it return null or zero address, and can this cause cross-chain transfers to be incorrectly validated? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCrossChainTransferTokenContractAddress()] [ChainId Validation] Does the function validate that input.ChainId is a valid chain ID before lookup, or can attackers query arbitrary ChainId values to enumerate whitelisted chains? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCrossChainTransferTokenContractAddress()] [Whitelist Bypass] If State.CrossChainTransferWhiteList mappings can be manipulated through governance, can an attacker register malicious contract addresses for valid ChainIds, causing GetCrossChainTransferTokenContractAddress() to return attacker-controlled addresses? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetPrimaryTokenSymbol()] [State Caching] GetPrimaryTokenSymbol() caches _primaryTokenSymbol and checks State.ChainPrimaryTokenSymbol.Value - if the primary token changes after caching, can stale cached values cause fee calculations or consensus operations to use the wrong token? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetPrimaryTokenSymbol()] [Fallback Logic] The function falls back to Context.Variables.NativeSymbol if both _primaryTokenSymbol and State.ChainPrimaryTokenSymbol.Value are null/empty - can this fallback be exploited if NativeSymbol is uninitialized or manipulated? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetPrimaryTokenSymbol()] [String.IsNullOrWhiteSpace Check] The check string.IsNullOrWhiteSpace(_primaryTokenSymbol) only updates the cache if true - can partial initialization where _primaryTokenSymbol is set to empty string cause the cache to never update? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [Fee Type Bypass] If input.Value equals FeeTypeEnum.Tx, GetCalculateFeeCoefficientsForContract() returns empty CalculateFeeCoefficients - can this bypass fee calculations by setting contracts to use Tx fee type incorrectly? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [Null Coefficients] The function uses FirstOrDefault() which can return null if no matching FeeTokenType exists - can null coefficients cause divide-by-zero or null reference exceptions in fee calculation logic? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [State.AllCalculateFeeCoefficients] Does the function validate that State.AllCalculateFeeCoefficients.Value is initialized before accessing .Value.FirstOrDefault(), or can uninitialized state cause exceptions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetCalculateFeeCoefficientsForContract()] [Fee Type Manipulation] Can an attacker manipulate input.Value to query coefficients for fee types that shouldn't be accessible, potentially discovering or exploiting unintended fee calculation paths? (Medium)"
]