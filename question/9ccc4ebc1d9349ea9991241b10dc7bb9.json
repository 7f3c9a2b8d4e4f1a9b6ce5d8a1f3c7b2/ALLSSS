[
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: RemoveOptions()] [Duplicate Removal] Can an attacker provide the same option multiple times in the input list, causing the second removal to fail with 'Option doesn't exist' at line 332, but the first removal succeeded? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidNewVotingItem()] [Hash Collision] At line 354, voting item ID is calculated as input.GetHash(Context.Sender) - if two different inputs produce the same hash, can the second registration overwrite the first since the check at line 356 only checks if it's null? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidNewVotingItem()] [Sender Manipulation] The voting item ID includes Context.Sender at line 354 - can an attacker create multiple voting items with identical parameters by sending from different addresses, flooding the system? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidNewVotingItem()] [Timestamp Ordering] At line 361, only checks EndTimestamp > StartTimestamp - can an attacker set both to the same value minus 1 nanosecond, creating effectively zero-duration voting periods? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidVoteInput()] [Snapshot Boundary] At line 382, voting is allowed if CurrentSnapshotNumber <= TotalSnapshotNumber - can an attacker vote when CurrentSnapshotNumber == TotalSnapshotNumber, causing votes to be recorded in the final snapshot which may not be properly closed? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidVoteInput()] [Delegated Vote Validation] At lines 384-389, for delegated voting (IsLockToken=false), Voter and VoteId must not be null - but can an attacker provide valid non-null values that are actually garbage, bypassing the null check but causing issues later? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidVoteInput()] [Vote ID Generation] At line 397, VoteId for locked token voting is generated as Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false)) - can two voters generate the same VoteId if they vote when VotesAmount is identical, causing vote collision? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidVoteInput()] [Voter Override] At line 395, input.Voter is set to Context.Sender for locked token voting - but if input.Voter was already set to a different address, can this cause confusion in event logs or external systems reading the Voted event? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: AssertValidVoteInput()] [Authorization Inversion] At line 386, for delegated voting the sender must be Sponsor - can the Sponsor vote unlimited times for the same Voter address, inflating that voter's voting power without their consent? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Multiple Functions] [Reentrancy] Can an attacker exploit reentrancy by calling back into Vote() from the TokenContract.Lock callback at line 124, voting again before the first vote's state is fully committed? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Multiple Functions] [Reentrancy] Can an attacker exploit reentrancy by calling back into Withdraw() from the TokenContract.Unlock callback at line 225, withdrawing again before the first withdrawal's state is fully committed? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Vote() and Withdraw()] [State Consistency] Between Vote() saving the record at line 117 and locking tokens at line 124, and Withdraw() checking authorization at line 197 and unlocking at line 225, can an attacker manipulate state to vote without locking or withdraw without authorization? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Vote() and UpdateVotingResult()] [Race Condition] Can concurrent calls to Vote() for the same voting item cause race conditions in UpdateVotingResult() at lines 176-179 where Results, VotersCount, and VotesAmount are updated separately, leading to inconsistent totals? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [TakeSnapshot() and Vote()] [Snapshot Race] Can an attacker vote exactly when TakeSnapshot() is incrementing CurrentSnapshotNumber at line 259, causing their vote to be counted in the wrong snapshot or lost entirely? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Register() and Vote()] [Token Whitelist Race] Can an attacker vote with a token that was whitelisted during Register() at line 29-34 but is removed from whitelist before Vote(), since Vote() doesn't recheck the whitelist? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Vote() and Withdraw()] [Quadratic Voting State] In quadratic voting, QuadraticVotesCountMap is incremented at line 100 during Vote() - but during Withdraw() at line 203, this map is not decremented, can this cause permanent inflation of vote costs for subsequent votes with the same VoteId? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [AddOption() and Vote()] [Option Race] Can an attacker vote for an option immediately after AddOption() at line 287 adds it, but before other voters are aware of the new option, gaining unfair advantage? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [RemoveOption() and Withdraw()] [Orphaned Withdrawals] If an option is removed at line 309 but votes for that option exist, when those votes are withdrawn at line 215-216, does the Results map still contain the removed option key, causing accounting errors? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Multiple Functions] [VotingItemId Manipulation] Across all functions, VotingItemId is used as a key - can an attacker cause hash collision by manipulating input to Register() at line 354, affecting subsequent Vote(), Withdraw(), TakeSnapshot() operations? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [State: VotingItems] [Missing Deletion] Voting items are created at line 54 but never deleted - can an attacker create unlimited voting items to bloat state storage and cause DOS? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [State: VotingResults] [Missing Cleanup] VotingResults are created at line 58 and 264 but never deleted - can an attacker create voting items with large TotalSnapshotNumber to create many result entries, bloating storage? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [State: VotingRecords] [Missing Cleanup] VotingRecords are created at line 117 but never deleted even after withdrawal at line 203 - can this cause unbounded storage growth? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [State: VotedItemsMap] [Memory Growth] VotedItems grow unbounded as votes are added at line 151 - can an attacker vote many times to inflate the ActiveVotes list and cause storage DOS? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [State: QuadraticVotesCountMap] [Permanent State] QuadraticVotesCountMap is incremented at line 100 but never decremented or cleared - can this cause VoteIds to permanently have inflated costs even after withdrawal? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [State: VotingResults.Results] [Map Growth] The Results map grows as new options are added at line 174 but entries are never removed even when RemoveOption() is called at line 309 - can this cause accounting errors? (Medium)"
]