[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Collection Allowance Bypass] If GetSymbolType returns Token for 'ABC-0', GetAvailableAllowance skips collection allowance check - can attacker approve collection as regular token, then use it to transfer all NFT items without individual approval? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [AllSymbolIdentifier Confusion] GetAllowance on line 103 checks if symbol is NFT type to include collection-level allowance - if GetSymbolType misclassifies, can attacker use '*' allowance meant for tokens on NFTs, bypassing approval requirements? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Spender Authorization] DoTransferFrom on line 78 uses GetAllowance which calls GetSymbolType - can symbol type confusion allow spender to transfer NFT items using token-level approvals, violating NFT ownership rules? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [State Path Generation] AddPathForAllowance on line 76 of TokenContract_ACS2_StatePathsProvider.cs uses GetSymbolType to add NFT collection paths - can misclassification cause parallel execution conflicts or missing state locks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Resource Path Missing] If GetSymbolType returns Token for NFT symbol, AddPathForAllowance skips collection path on line 79-81 - can this allow concurrent transactions to corrupt allowance state for NFT collections? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Write Path Collision] If two symbols classify differently but share state paths (e.g., 'ABC' token and 'ABC-0' collection), can race condition in parallel execution cause state corruption or double-spend? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [ACS2 Resource Discovery] GetResourceInfo relies on GetSymbolType for accurate path generation - can attacker craft symbols that miss critical paths, bypassing ACS2 parallel execution safety guarantees? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Length Validation Timing] GetSymbolType doesn't validate symbol length - CheckSymbolLength is called later in AssertValidCreateInput - can attacker use overly long symbol (>30 chars for NFT) that passes GetSymbolType but fails later, causing state inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [NFT Symbol Length] NFTSymbolMaxLength is 30 but GetSymbolType doesn't enforce this - can 'ABCDEFGHIJKLMNOPQRSTUVWXYZ-1' pass GetSymbolType then fail creation, wasting gas or causing DOS through repeated attempts? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Prefix Length Unchecked] GetSymbolType validates words[0] with IsValidCreateSymbol but not length - can 'ABCDEFGHIJKLMNOPQRSTUVWXYZ-0' exceed SymbolMaxLength (10) for collection prefix, causing validation failure only after type classification? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [ItemId Length Unlimited] IsValidItemId checks regex '^[0-9]+$' but not length - can attacker create 'ABC-' + 1000 digits, passing GetSymbolType but exceeding storage limits or causing integer overflow in later conversions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Case Sensitivity] GetSymbolType doesn't normalize case before classification - if 'ABC-0' and 'abc-0' are treated differently by IsValidCreateSymbol regex, can attacker create duplicate collections with different casing? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Uppercase Collision] State.InsensitiveTokenExisting uses ToUpper() on line 233 of TokenContract_Helper.cs, but GetSymbolType is case-sensitive - can 'ABC-0' and 'abc-0' both pass GetSymbolType as NftCollection but collide in storage? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Collection Suffix Case] CollectionSymbolSuffix is '0' (string) but comparison on line 13 is exact match - what if words[1] is 'O' (letter) instead of '0' (zero)? Does IsValidItemId catch this, or can attacker create lookalike collection symbols? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Mixed Case ItemId] IsValidItemId regex is '^[0-9]+$' which is case-insensitive for numbers - but can Unicode numerals (e.g., ⓪①②③) bypass regex and IsValidItemId, allowing creation of ambiguous NFT item IDs? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Cross-Chain Symbol Consistency] If GetSymbolType behavior differs across main chain and side chains due to different constant values or regex implementations, can attacker create symbol on one chain that's Token but NFT on another, breaking cross-chain transfers? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Side Chain Creation] CreateNFTInfo checks nftCreateChainId from external info on line 22-28 of TokenContract_NFT_Actions.cs - if GetSymbolType misclassifies symbol type, can attacker bypass chain ID validation and create NFTs on unauthorized chains? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [IssueChainId Confusion] CreateNFTInfo validates IssueChainId matches collection's on line 19-21 - if GetSymbolType returns wrong type, can attacker set mismatched IssueChainId and create NFTs mintable on multiple chains? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Parent-Child Chain Symbols] Can attacker create 'ABC-0' collection on main chain, then 'ABC-0' token on side chain? GetSymbolType would classify differently, causing cross-chain verification failures or allowance bypass? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [SEED Collection Detection] CreateNFTInfo checks if collection symbol equals 'SEED-0' on line 37 - if GetSymbolType misclassifies 'SEED-0', does this bypass SEED uniqueness checks (decimals==0, totalSupply==1)? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [SEED OwnedSymbol Type] Line 46 calls GetSymbolType(ownedSymbol) and asserts != SymbolType.Nft - if GetSymbolType misclassifies owned symbol, can attacker create SEED for individual NFT item instead of collection/token, bypassing symbol reservation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [SEED Expiration Check] CreateNFTInfo validates SEED expiration time on line 42-45 - if GetSymbolType classifies SEED item as Token instead of Nft, does this skip expiration validation and allow expired SEED usage? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [SymbolSeedMap Collision] CheckSymbolSeed uses ToUpper() on line 59 but GetSymbolType doesn't - can 'ABC' and 'abc' both have SEED entries but GetSymbolType treats them as different symbol types, causing SEED reuse? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Owner Validation Bypass] CreateNFTInfo asserts owner matches collection owner on line 36 - if GetSymbolType returns Token instead of Nft, does Create() skip this check and allow unauthorized NFT creation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Issuer vs Owner Confusion] Line 35 sets owner = issuer if null - if GetSymbolType misroutes to CreateToken instead of CreateNFTInfo, can attacker create NFT with different owner than collection, bypassing ownership invariant? (High)"
]