[
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Integer Overflow] Can an attacker cause integer overflow when adding proposal.RejectionCount + proposal.AbstentionCount + proposal.ApprovalCount on line 15, potentially bypassing the MinimalVoteThreshold check if vote counts are manipulated to wrap around? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Logic Error] If MinimalVoteThreshold is set to 0, will line 15-16 always return true for enoughVote check, allowing proposals to pass without any votes at all? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Threshold Bypass] Can an attacker set MaximalRejectionThreshold to exactly match expected rejection count on line 20, causing legitimate proposals to be rejected when RejectionCount equals (not exceeds) the threshold? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Threshold Bypass] Can an attacker set MaximalAbstentionThreshold to exactly match expected abstention count on line 24, causing legitimate proposals to fail when AbstentionCount equals (not exceeds) the threshold? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Logic Error] If MinimalApprovalThreshold is set higher than MinimalVoteThreshold on line 28, can a proposal with sufficient total votes but insufficient approvals still pass if rejection/abstention thresholds aren't exceeded? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Race Condition] Can vote counts be manipulated between the enoughVote check (line 15-18) and the final approval check (line 28), causing inconsistent state where thresholds are evaluated on stale data? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Accounting Error] If all three vote types (Approval, Rejection, Abstention) can be cast by the same voter, can the total vote count on line 15 be inflated beyond actual voter participation? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [DOS] Can an attacker set MinimalVoteThreshold to maximum long value, making it impossible for any proposal to reach enoughVote on line 15-16, permanently blocking all referendum proposals? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Logic Bypass] If MaximalRejectionThreshold and MaximalAbstentionThreshold are both set to 0, will lines 20-26 always fail proposals that have any rejection or abstention votes regardless of approval count? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: IsReleaseThresholdReached()] [Parameter Manipulation] Can organizationAddress be manipulated to retrieve a different Organization object with attacker-controlled ProposalReleaseThreshold values on line 14? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Reentrancy] Can an attacker exploit the TransferFrom call on lines 47-55 before State.LockedTokenAmount is set on line 56, allowing them to bypass the 'Already locked' check on line 42 and lock tokens multiple times for the same proposal? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Authorization Bypass] The function locks tokens from Context.Sender (line 50) but saves the receipt using lockedAddress parameter (line 56-61). Can an attacker provide different values for these, locking another user's tokens while claiming ownership of the receipt? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [State Inconsistency] Line 42 checks State.LockedTokenAmount[lockedAddress][proposalId] but line 56 sets State.LockedTokenAmount[Context.Sender][proposalId]. If lockedAddress != Context.Sender, can this create orphaned state entries? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Virtual Address Collision] Can an attacker manipulate the proposalId input on line 44-45 to generate a predictable lockId, potentially causing collisions with other locks or exploiting the virtual address generation? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Amount Validation] There is no validation that amount parameter is greater than 0. Can an attacker lock 0 tokens on line 53 and still receive a valid receipt, potentially manipulating vote counts without staking? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Symbol Validation] There is no validation that the symbol parameter exists or matches the organization's token. Can an attacker lock arbitrary tokens on line 52 that don't match the referendum's voting token? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Virtual Transfer] The TransferFrom on lines 47-55 transfers to GetProposalVirtualAddress(proposalId). If this virtual address calculation is predictable, can an attacker pre-fund it or drain it through other means? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Event Timing] The ReferendumReceiptCreated event is returned on lines 63-71 but the actual token lock happens before. Can the event be emitted even if the TransferFrom fails, creating phantom lock events? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Approval Bypass] The TransferFrom call on lines 47-55 requires prior approval. Can an attacker front-run or manipulate the approval to be revoked after the check but before execution? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken()] [Memo Manipulation] The memo is hardcoded to 'Referendum.' on line 54. Can this be exploited to bypass transfer restrictions or fee calculations that depend on memo content? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: UnlockToken()] [Authorization Bypass] Line 77 retrieves receipt using lockedAddress but line 87 removes using Context.Sender. If lockedAddress != Context.Sender, can an attacker unlock someone else's tokens while their own receipt remains intact? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: UnlockToken()] [Reentrancy] Can an attacker reenter UnlockToken() during the Transfer call on lines 79-86 before State.LockedTokenAmount is removed on line 87, allowing them to claim tokens multiple times? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: UnlockToken()] [State Inconsistency] The function checks receipt != null on line 78 using lockedAddress but removes the entry using Context.Sender on line 87. Can this leave orphaned receipt entries in state? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: UnlockToken()] [Missing Validation] There is no check that the proposal has expired or been finalized before unlocking on lines 74-88. Can voters unlock and re-vote indefinitely to manipulate outcomes? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: UnlockToken()] [Recipient Validation] Tokens are transferred to Context.Sender on line 83, not to the original locker (lockedAddress). Can an attacker call this with a different sender to steal locked tokens? (Critical)"
]