[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Hash Collision] Line 50 uses HashHelper.ComputeFrom on the decoded secret. If SecretSharingHelper.DecodeSecret returns predictable values, can an attacker pre-compute hash collisions to force specific PreviousInValue hashes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Revealed InValue Overwrite] Line 52 unconditionally sets PreviousInValue without checking if it's already set. Can multiple calls overwrite a correct value with an incorrect one, or allow replay attacks by revealing the same value multiple times? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Secret Leakage] The function reveals secrets from previousRound and stores them in currentRound. If currentRound data is publicly accessible, does this leak sensitive cryptographic material before it should be revealed? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Deterministic Secret Generation] If SecretSharingHelper.DecodeSecret produces deterministic outputs for given inputs, can miners predict future secrets by analyzing past DecryptedPieces patterns? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Unbounded Loop] Line 25 loops through all previousRound.RealTimeMinersInformation without a limit. If an attacker fills previousRound with thousands of miners, can this cause gas exhaustion and DoS? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Nested Iteration DoS] Lines 40-44 perform nested iterations (Select with First) for each miner. With n miners and m decrypted pieces, this is O(n*m*p) complexity. Can large values DoS the contract? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Early Return Exploitation] Lines 17, 19, 35, 36 have early returns. Can an attacker craft inputs to always trigger early returns, preventing legitimate secret reveals and stalling consensus? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [OrderBy Performance] Line 25 sorts miners by Order. For large miner sets, does OrderBy create performance bottlenecks or allow manipulation by controlling Order values? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Multiple Reveals] The function can be called multiple times for the same round. Does each call redo all computations, wasting gas? Can repeated calls cause state inconsistencies? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: IsSecretSharingEnabled()] [Null Contract Address] Lines 58-66 check if ConfigurationContract is null and attempt to set it. If GetContractAddressByName returns null at line 61, the function returns false at line 65. Can an attacker prevent deployment of ConfigurationContract to permanently disable secret sharing? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: IsSecretSharingEnabled()] [State Initialization Race] Lines 58-68 lazily initialize State.ConfigurationContract.Value. If multiple transactions call this concurrently, can race conditions cause the wrong contract address to be stored? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: IsSecretSharingEnabled()] [Configuration Manipulation] Lines 72-75 call GetConfiguration and merge the result into a BoolValue. If State.ConfigurationContract points to a malicious contract, can it return arbitrary values to enable/disable secret sharing at will? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: IsSecretSharingEnabled()] [MergeFrom Vulnerability] Line 72 uses MergeFrom to deserialize configuration data. If the returned Value contains malicious protobuf data, can this cause buffer overflows or inject unexpected values? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: IsSecretSharingEnabled()] [Constant Key Hardcoding] Line 74 uses hardcoded 'SecretSharingEnabledConfigurationKey'. If this key is publicly known, can an attacker pre-emptively set this configuration to disable secret sharing before contract deployment? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Threshold Collusion] With minimumCount = 2/3 * minersCount, if 1/3 + 1 miners collude, they can prevent secret reconstruction by withholding shares. Can this freeze consensus by always failing the line 35 check? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Selective Reveal Attack] The function reveals secrets for all miners in the loop (lines 25-53). If a colluding subset provides valid pieces while others don't, can this create information asymmetry favoring the colluders? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Encrypted vs Decrypted Mismatch] Line 35 checks EncryptedPieces.Count but line 36 checks DecryptedPieces.Count. If a miner provides many encrypted but few decrypted pieces, they pass line 35 but fail line 36. Can this be exploited to selectively block reveals? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Order Manipulation Attack] Lines 40-44 extract orders from previousRound miners. If colluding miners manipulate their Order values in previousRound, can they control the Lagrange interpolation to produce specific revealed secrets? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Free-Rider Problem] Miners who don't reveal secrets (fail checks at lines 35-36) still benefit from others' reveals. Can rational miners withhold decrypted pieces to save gas while still participating in consensus? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [InValue Prediction] If revealedInValue (line 49-50) is predictable based on public DecryptedPieces, can miners predict future consensus randomness and manipulate block production order? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [PreviousInValue Consistency] Line 52 sets PreviousInValue for another miner. If this doesn't match what that miner actually used in the previous round, can it break consensus validation causing chain splits? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Random Number Generation] The revealed InValues are likely used for randomness in consensus. If an attacker can control even one revealed InValue through manipulation of DecryptedPieces, can they bias the random number generation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Time-Based Attack] The function doesn't check the current block time or expected mining times. Can miners delay calling this function to reveal secrets at advantageous moments, manipulating consensus timing? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [Partial Reveal State] If the function partially completes (reveals some but not all secrets) due to gas limits or exceptions, does this create inconsistent consensus state? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs] [Function: RevealSharedInValues()] [No Round Number Check] The function doesn't verify currentRound.round_number or previousRound.round_number relationships. Can an attacker call this with mismatched rounds to corrupt state? (High)"
]