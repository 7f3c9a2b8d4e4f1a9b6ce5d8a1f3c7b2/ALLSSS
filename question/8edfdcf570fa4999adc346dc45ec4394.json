[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegator()] [Race Condition] If RemoveTransactionFeeDelegator and SetTransactionFeeDelegations are called concurrently for the same delegator-delegatee pair, can the state end up inconsistent with one operation partially overwriting the other? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegator()] [Gas Optimization] The function reads and writes TransactionFeeDelegateesMap twice (lines 111, 122-124). Could this be optimized to a single read-modify-write to save gas? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegator()] [Event Inconsistency] The TransactionFeeDelegationCancelled event at lines 126-131 is fired even when the delegatee was already removed (early return at 116-120 is silent). Should the event be consistent? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatee()] [Authorization Model] The delegator (Context.Sender) can remove any delegatee unilaterally at line 152, but should there be a notification mechanism or grace period for the delegatee before removal? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatee()] [Silent Failure] At lines 140-143 and 145-149, the function silently returns Empty when the delegator has no delegatees or the specific delegatee doesn't exist. Can this hide error conditions? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatee()] [State Leak] After removing the last delegatee at line 152, the TransactionFeeDelegateesMap[Context.Sender] entry still exists but with an empty Delegatees dictionary. Should this be cleaned up to prevent storage bloat? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatee()] [Input Validation] At line 138, only null check is performed on DelegateeAddress. Can invalid address formats or special addresses (zero address) cause issues? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatee()] [Race Condition] If a delegatee calls RemoveTransactionFeeDelegator while the delegator calls RemoveTransactionFeeDelegatee concurrently, can both operations succeed and fire duplicate events? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatee()] [Gas Cost] The function performs multiple state reads (lines 140, 145) before the actual removal. Can this be optimized for the common case? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: GetTransactionFeeDelegationsOfADelegatee()] [Data Exposure] The function returns all delegation amounts and configuration for any queried delegator-delegatee pair without access control. Could sensitive delegation limits be exploited by observers? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: GetTransactionFeeDelegationsOfADelegatee()] [Missing Validation] No null or validity checks on input.DelegatorAddress or input.DelegateeAddress. Can invalid inputs cause crashes or unexpected behavior? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: GetTransactionFeeDelegationsOfADelegatee()] [Return Semantics] At lines 170-173, the function returns an empty TransactionFeeDelegations object when allDelegatees is null. Is this distinguishable from a valid but empty delegation configuration? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: GetTransactionFeeDelegatees()] [Input Validation] At line 184, the assertion checks input, input.DelegatorAddress for null, but uses null-conditional operator `input!.DelegatorAddress`. Is this error handling pattern consistent and safe? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: GetTransactionFeeDelegatees()] [DoS via Large Response] At line 194, the function returns all delegatee addresses using Select. If a delegator has accumulated DELEGATEE_MAX_COUNT (or close to it) delegatees, can this cause excessive gas consumption or response size issues? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: GetTransactionFeeDelegatees()] [Address Conversion Risk] At line 194, Address.FromBase58(k) is called for each key. If any stored key is corrupted or invalid Base58, does this throw an exception and fail the entire query? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Authorization Bypass] Similar to SetTransactionFeeDelegations, any sender can set delegate info for an arbitrary DelegatorAddress without authorization from the delegator. Can malicious delegatees force delegation configurations? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Logic Error] At lines 208-210, if IsUnlimitedDelegate is false, it requires Delegations.Count > 0, but at lines 233-242, it removes a delegatee if both Delegations.Count == 0 AND !IsUnlimitedDelegate. Can this create an inconsistent state where empty non-unlimited delegations exist? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [State Complexity] The nested state map at line 215 (TransactionFeeDelegateInfoMap[delegator][contract][method]) creates complex state structure. Can this lead to storage collisions or unexpected interactions between different contracts/methods? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Race Condition] At lines 220-231, the function checks if delegatee exists and either updates or adds. If two transactions for the same delegator-contract-method but different delegatees execute concurrently, can the count check at line 226 be bypassed? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Event Ordering] At lines 233-242, if a delegatee is removed within the same transaction that updates it (lines 222), both toUpdateTransactionList and toCancelTransactionList will contain entries. Is this the intended behavior, and can it confuse event consumers? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Input Validation] At line 211, ContractAddress and MethodName are validated, but is there validation that ContractAddress is an actual deployed contract and MethodName exists? Can arbitrary values be set? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Batch Processing Risk] The function processes DelegateInfoList in a loop (line 206), but if one item fails assertion at lines 208-212, the entire transaction reverts. Can a malicious actor cause partial updates by crafting specific input? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Storage Bloat] Each delegator-contract-method combination creates a separate nested map entry at line 244-245. Can an attacker create excessive storage by registering delegations for many contract-method pairs? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [IsUnlimitedDelegate Flag] When IsUnlimitedDelegate is true, what prevents abuse? Can a delegatee set unlimited delegation for high-value contracts and drain a delegator's funds? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Event Aggregation] At line 248, FireLogEvent is called once for all delegateInfo items processed. If the transaction is very large, can this create gas issues or event size limits? (Medium)"
]