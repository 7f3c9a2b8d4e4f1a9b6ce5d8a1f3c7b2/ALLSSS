[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [Whitelist Race Condition] At line 78, IsInWhiteList is checked after GetAllowance at line 75. Can an attacker be added to whitelist between allowance check and whitelist check, causing inconsistent state where allowance is recorded but not decremented? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [DealWithExternalInfoDuringTransfer Duplication] DealWithExternalInfoDuringTransfer is called at lines 81-82 for whitelisted transfers and lines 92-93 for normal transfers. Can this double-handling cause state duplication or double-spending of external info? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [Allowance Deduction After Transfer] At line 94, State.Allowances is decremented AFTER DoTransfer at line 91. Can reentrancy during DoTransfer allow the same allowance to be used multiple times before deduction? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [AllowanceSymbol Confusion] At line 94, allowanceSymbol (from GetAllowance) is used, not sourceSymbol. If allowanceSymbol points to wildcard allowance but the transfer is for specific NFT, can this cause incorrect allowance deduction tracking? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [Negative Allowance via Sub()] At line 94, allowance.Sub(amount) is used. If allowance < amount (shouldn't happen due to earlier checks), can Sub cause underflow or exceptions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [Address Validation Timing] AssertValidInputAddress is called at lines 71-72 before allowance checks. Can an attacker pass invalid addresses that pass validation but become invalid by the time DoTransfer executes? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [GetAllowance Out Parameter Mutation] At line 75, GetAllowance has an out parameter allowanceSymbol. If GetAllowance throws after setting allowanceSymbol, can this leave inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [Memo Parameter Injection] The memo parameter is passed to DoTransfer and DealWithExternalInfoDuringTransfer but never validated. Can an attacker inject malicious data via memo to exploit downstream processing? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [Allowance Fallback Hierarchy Exploit] At lines 103-113, if sourceSymbol allowance is insufficient, the function falls back to collection allowance (NFT) or all-symbol allowance (Token). Can an attacker structure allowances to exploit this hierarchy and transfer more than intended? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [GetSymbolType Inconsistency] At line 103, GetSymbolType determines Token vs NFT handling. If GetSymbolType returns inconsistent results for the same symbol across calls, can this cause allowance confusion? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [NFT Collection Allowance Double Dip] At lines 110-112, for NFTs, both GetNftCollectionAllSymbolAllowance and GetAllSymbolAllowance are checked. Can an attacker consume collection allowance first, then fall back to all-symbol allowance, effectively double-spending? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [Out Parameter Overwrite] The allowanceSymbol out parameter is set multiple times (lines 100, 106, 110, 112). If intermediate values are used before final assignment, can this cause incorrect allowance deduction? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [Early Return Bypass] At line 102, if allowance >= amount, the function returns immediately. Can an attacker structure allowances such that specific-symbol allowance just meets the threshold, preventing fallback checks that would reveal unauthorized access? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [Token Type Default Behavior] At line 104-107, if tokenType == SymbolType.Token, only GetAllSymbolAllowance is checked. Can NFT collections masquerading as Tokens bypass collection-specific allowance checks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllowance()] [Allowance Comparison Race] At line 111, allowance >= amount is checked after calling GetNftCollectionAllSymbolAllowance. Can allowance value change between retrieval and comparison due to concurrent transactions? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllSymbolAllowance()] [Universal Wildcard Security] At line 121, GetAllSymbolIdentifier() returns '*'. If an attacker gains approval for '*', can they transfer ALL tokens from the owner, including newly created ones? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllSymbolAllowance()] [State Access Atomicity] At line 122, State.Allowances[from][spender][allowanceSymbol] is accessed. Can concurrent modifications to this state cause race conditions in allowance retrieval? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionAllSymbolAllowance()] [Collection Wildcard Scope] At line 128, GetNftCollectionAllSymbolIdentifier constructs 'AAA-*' pattern. Can this wildcard match unintended NFTs if collection prefix is too short or contains special characters? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionAllSymbolAllowance()] [SourceSymbol Parameter Trust] The sourceSymbol parameter is passed directly to GetNftCollectionAllSymbolIdentifier without validation. Can malformed sourceSymbol cause incorrect collection identifier construction? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionAllSymbolIdentifier()] [Symbol Split Vulnerability] At line 135, sourceSymbol.Split(NFTSymbolSeparator)[0] assumes the separator exists. Can an attacker provide a symbol without separator (e.g., 'TOKEN') causing IndexOutOfRangeException or returning the full symbol? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionAllSymbolIdentifier()] [Multiple Separator Handling] At line 135, Split returns an array. If sourceSymbol contains multiple separators (e.g., 'A-B-C-1'), does [0] correctly extract 'A' or does it return unexpected prefix? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionAllSymbolIdentifier()] [AllSymbolIdentifier Injection] At line 135, the result is constructed as {prefix}-{AllSymbolIdentifier}. Can an attacker craft sourceSymbol to inject additional wildcards or special characters? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetAllSymbolIdentifier()] [Constant Return Manipulation] At line 141, TokenContractConstants.AllSymbolIdentifier.ToString() is returned. If this constant is mutable or can be shadowed, can an attacker change the universal wildcard identifier? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionSymbol()] [Symbol Split Array Access] At line 156, words = symbol.Split(NFTSymbolSeparator). At line 159, Assert checks words.Length == 2, but at line 158, if words.Length == 1, null is returned. Can symbols with 3+ parts (e.g., 'A-B-C') bypass validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: GetNftCollectionSymbol()] [IsValidItemId Bypass] At line 159, IsValidItemId(words[1]) validates the item ID. Can an attacker provide symbols like 'NFT-' (empty item ID) that pass the length check but fail item ID validation after state modifications? (Medium)"
]