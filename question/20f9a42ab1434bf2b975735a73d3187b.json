[
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Re-initialization Vulnerability] Can an attacker front-run the initialization if State.Initialized.Value check at line 44 is bypassed through transaction ordering, allowing them to create malicious profit schemes with attacker-controlled parameters? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Profit Scheme Misconfiguration] The loop at lines 56-68 creates 7 schemes with hardcoded DelayDistributePeriodCount and CanRemoveBeneficiaryDirectly settings - can these immutable settings be exploited if scheme indices 2, 5, 6 (Subsidy, FlexibleReward, WelcomeReward) allow malicious direct beneficiary removal before legitimate distribution? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [State Consistency] If CreateScheme calls at line 60 fail silently or partially succeed, can the contract end up in an inconsistent state where State.Initialized.Value is true but fewer than 7 schemes exist, breaking InitialMiningRewardProfitItem's assertion at line 88? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Symbol List Manipulation] The SymbolList initialization at lines 72-75 only contains NativeSymbol - can this cause issues if SetSymbolList is never called and multi-token distributions are attempted, leading to missing token distributions? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Delay Period Exploit] The DelayDistributePeriodCount=1 for scheme index 3 (Welfare) at line 64 - can attackers exploit this one-period delay to frontrun welfare distributions and manipulate vote weights to maximize their share before distribution occurs? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Double Initialization] The assertion at line 82 only checks State.TreasuryHash.Value == null - if InitialTreasuryContract was called but this function wasn't, can subsequent calls with different managingSchemeIds overwrite critical scheme references? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Scheme Count Manipulation] Line 88 asserts managingSchemeIds.Count == 7, but if the ProfitContract was compromised or returned malicious data, could incorrect scheme IDs be assigned to State variables at lines 90-96, causing treasury funds to flow to attacker schemes? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Manager Reset Attack] The ResetManager calls at lines 102-111 transfer control of SubsidyHash and WelfareHash to electionContractAddress without verifying it's legitimate - if electionContractAddress is null or malicious, can this permanently lock these schemes or redirect funds? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Virtual Address Collision] The TreasuryVirtualAddress computed at lines 116-118 uses hash concatenation - can an attacker precompute collisions to predict this address and frontrun token transfers to drain treasury funds before distribution? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [BuildTreasury Reentrancy] BuildTreasury() called at line 114 makes external ProfitContract calls - can reentrancy during initialization corrupt the weight settings or scheme hierarchy before virtual address is set? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Authorization Bypass] Line 127 only checks Context.Sender == State.AEDPoSContract.Value - if AEDPoSContract.Value is never initialized or can be reset, can any address call Release and trigger unauthorized profit distributions? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Period Manipulation] Release uses input.PeriodNumber at line 132 and 138 without validation - can an attacker call with arbitrary future or past periods to skip distributions, double-distribute, or manipulate miner reward calculations? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Miner List Extraction] Lines 141-145 merge currentMinerList and previousTermInformation miners - if these lists contain duplicates, can a miner receive double shares in UpdateBasicMinerRewardWeights? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Replace Candidate State Pollution] Lines 146-153 check ReplaceCandidateMap and remove entries - if RecordMinerReplacement is called multiple times for the same term, can attacker-controlled pubkeys accumulate in the map and qualify as 'new miners' to claim welcome rewards? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Initial Miner Exclusion Bypass] Line 156 filters out initial miners using GetInitialMinerList() - if round 1 data is corrupted or AEDPoSContract returns empty, can initial miners falsely qualify for welcome rewards in every term? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [LatestMinedTerm Logic Error] Line 156 checks State.LatestMinedTerm[p] == 0 - but UpdateStateAfterDistribution at line 164 sets it to previousTermInformation.TermNumber - can miners who skip exactly one term re-qualify as 'new' and claim duplicate welcome rewards? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Distribution Order Dependency] UpdateStateBeforeDistribution (line 162) and UpdateStateAfterDistribution (line 164) modify beneficiary weights and LatestMinedTerm state - can the ordering be exploited if ReleaseTreasurySubProfitItems fails or reverts, leaving state inconsistent? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [AmountsMap Zero Injection] Line 133 creates AmountsMap with all values set to 0L - if ProfitContract uses this to determine distribution amounts instead of actual balances, can this cause all treasury funds to remain locked indefinitely? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Amount Validation Bypass] Line 176 only checks input.Amount > 0 but doesn't validate max bounds - can an attacker pass Amount = long.MaxValue to cause overflow in later calculations at lines 228-229 when adding to existing donations? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Token Availability Race] Lines 181-182 check IsTokenAvailableForMethodFee and return empty if false - can this allow worthless tokens to bypass validation if called before method fee whitelist is updated, locking them in treasury? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Symbol Conversion Ambiguity] Lines 188-192 determine conversion path based on isNativeSymbol and CanExchangeWithNativeSymbol - can an attacker donate a token that passes both checks, causing double-donation through the needToConvert logic at line 204? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Self-Donation Approval Bypass] Line 194 skips TransferFrom if Context.Sender == Context.Self - can a malicious internal function call Donate to approve and contribute funds from treasury's own balance to itself, inflating profit distributions artificially? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [TransferFrom Authorization] Lines 195-202 use TransferFrom without checking allowance first - if sender didn't approve treasury, will this silently fail or revert, and can partial failures corrupt DonatedDividends state at line 239? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [ConvertToNativeToken Slippage] Line 207 calls ConvertToNativeToken without slippage protection - can an attacker sandwich this transaction to extract value during token conversion, reducing donated amount to treasury? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Approval Race Condition] Lines 211-216 approve full amount to ProfitContract before contributing - can a compromised ProfitContract or reentering contract drain approved tokens beyond the ContributeProfits amount at line 222? (High)"
]