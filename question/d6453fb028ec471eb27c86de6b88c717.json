[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Allowance Overflow] Line 151 does addAmount += currentAllowance. If currentAllowance is large and addAmount is negative but small, can this overflow and set allowance to maximum value instead of decrementing? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Zero Allowance Skip] Line 149 skips if currentAllowance == 0, but what if allowance becomes 0 during iteration? Does loop continue with stale addAmount value, causing incorrect deductions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Early Break Exploit] Line 143 breaks if addAmount >= 0, but does this allow attacker to deliberately overpay in early allowances to avoid consuming later ones with longer expiration, gaming the system? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetSymbolListSortedByExpirationTime()] [Time Calculation Underflow] Line 161 computes RefreshSeconds - (CurrentBlockTime - LastRefreshTime).Seconds. If CurrentBlockTime < LastRefreshTime, can this underflow and sort allowances incorrectly? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetSymbolListSortedByExpirationTime()] [Sorting DoS] If transactionFeeFreeAllowancesMap contains thousands of symbols, can attacker add entries to make OrderBy operation extremely expensive, causing DoS on fee allowance checks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetFreeFeeAllowanceAmount()] [Overflow in Aggregation] Line 190 does allowance.Add(freeAllowance?.Amount ?? 0L). If map contains many large values, can sum overflow Int64.MaxValue, wrapping to negative and bypassing fee checks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetFreeFeeAllowanceAmount()] [Null Map DoS] Line 184 returns 0 if map is null, but what if map exists but all Values are null? Does foreach loop handle this gracefully or cause exception? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Symbol Alias Manipulation] GetActualTokenSymbol is called but not shown. If alias resolution has bugs, can attacker query balance of wrong token or bypass balance checks by using crafted aliases? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Address Validation Bypass] AssertValidInputAddress checks address not null/empty, but does it prevent zero address or system addresses from being queried, potentially leaking system balance information? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Uninitialized Balance] If State.Balances[address][symbol] was never set, does it return 0 or null? Can this cause type confusion or unexpected behavior in balance checks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [Whitelist Race Condition] Lines 198-199 check State.LockWhiteLists[symbol][Context.Sender]. Can whitelist be modified between check and actual lock operation, allowing unauthorized locks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [System Contract Impersonation] Line 200 gets system contract addresses. Can attacker deploy contract at predicted address before system contract is deployed, then get system privileges for locking? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [Whitelist Bypass via NULL Symbol] If symbolState is null (line 198), isInWhiteList becomes false. But can attacker pass empty/null symbol to bypass whitelist checks if system contract check also fails? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [OR Logic Exploitation] Line 202 uses OR operator. If system contract list is empty or corrupted, does this make isInWhiteList check the only gate, allowing whitelist manipulation to grant full access? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ExtractTokenContractAddress()] [Parser Vulnerability] Line 207 uses ValidateSystemContractAddressInput.Parser.ParseFrom(bytes). Can malformed protobuf cause exception that's not caught, DoS-ing cross-chain token operations? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ExtractTokenContractAddress()] [Hash Name Validation] Line 211 checks SystemContractHashName equals TokenContractSystemHashName. Can attacker find hash collision to make arbitrary contract address pass validation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ExtractTokenContractAddress()] [Address Validation Bypass] If validatedAddress is extracted but not verified to be non-null/non-zero, can attacker pass zero address to bypass cross-chain validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertCrossChainTransaction()] [Method Name Bypass] Line 219 checks if methodName is in validMethodNames array. If array is empty or contains wildcard, can attacker call any method and pass validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertCrossChainTransaction()] [Transaction Malleability] originalTransaction fields (MethodName, To) are checked but not Signature or other fields. Can attacker replay cross-chain transaction with modified signature/params? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertCrossChainTransaction()] [Multiple Valid Addresses] Function takes single validAddress but validMethodNames is array. Can attacker call valid method on wrong contract if only To address is checked, not method-address pairing? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [Merkle Path Manipulation] Lines 236-249 construct VerifyTransactionInput with merklePath. Can attacker provide valid merkle path for different transaction to pass verification? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [Chain ID Spoofing] verifiedChainId is passed as parameter. Can attacker provide chainId of trusted chain while actually submitting from untrusted chain? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [Parent Chain Height Rollback] parentChainHeight parameter is not validated against current height. Can attacker use old height with old merkle proof to replay expired cross-chain transactions? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [CrossChain Contract Call Failure] Line 247 calls VerifyTransaction but if it reverts, does error propagate correctly or can transaction continue with unverified cross-chain data? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [BoolValue Result Tampering] Line 248 checks verificationResult.Value, but can attacker manipulate Context.Call return value before check, or exploit proto deserialization to always return true? (Critical)"
]