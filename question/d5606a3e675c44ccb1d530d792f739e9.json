[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] If Pubkeys collection is null or empty, does the method fail safely or create an invalid Round with zero miners, potentially breaking consensus round progression? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] Can an attacker manipulate the Pubkeys collection to contain duplicate ByteString values, causing the ToDictionary() call to throw an exception and DoS the term transition? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] If Pubkeys contains ByteStrings of varying lengths (including zero-length), does accessing miner[0] throw an IndexOutOfRangeException, halting term generation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] Can Pubkeys contain malformed or invalid public keys that pass initial validation but cause cryptographic operations to fail later in the consensus flow? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] If miningInterval parameter is negative, does the ExpectedMiningTime calculation produce times in the past, violating the invariant that mining times must be in the future? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] If miningInterval is zero, does this create a Round where all miners have identical ExpectedMiningTime values, breaking the time-slot separation invariant? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] Can miningInterval be set to Int32.MaxValue causing the Mul() operation to overflow and wrap to negative values, corrupting expected mining times? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] If currentBlockTime is null, does the AddMilliseconds() method throw a NullReferenceException, halting consensus? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] Can currentBlockTime be set to Timestamp.MaxValue such that adding milliseconds causes overflow, wrapping mining times to year 1970 or causing exception? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Input Validation] If currentRoundNumber or currentTermNumber are negative, does incrementing them with Add(1) produce invalid round/term identifiers? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Sorting Logic] The sorting is based only on the first byte (miner[0]) of each pubkey. Can an attacker generate multiple pubkeys with the same first byte to create non-deterministic ordering due to sort stability issues? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Sorting Logic] Since only the first byte determines order, can an attacker control which miner becomes the IsExtraBlockProducer by manipulating pubkey generation to always have the highest first byte value? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Sorting Logic] If multiple miners have identical first bytes, does the orderby descending produce consistent ordering across different nodes, or can this cause consensus forks? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Sorting Logic] The sort uses 'orderby obj.Value descending' where Value is an int cast from a byte. Can byte values 0-255 cause collisions where 100+ miners would have non-unique first bytes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Sorting Logic] Is the ToHex() conversion in the dictionary creation deterministic? Could different hex encodings of the same bytes cause the same miner to appear multiple times? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Business Logic] Only the first miner (i==0) is assigned IsExtraBlockProducer=true. If this miner is offline or malicious, can they prevent term transitions by refusing to produce the extra block? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Business Logic] The IsExtraBlockProducer flag is assigned based on sort order. Can an attacker who controls miner registration manipulate the sort to always assign this critical role to themselves? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Business Logic] If the sorted list order changes between term transitions due to pubkey modifications, could a different miner unexpectedly become the extra block producer, breaking clients expecting consistent assignment? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Math Error] The ExpectedMiningTime formula is currentBlockTime + (i * miningInterval + miningInterval). Does i.Mul(miningInterval).Add(miningInterval) properly check for integer overflow when i is large? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Math Error] When i approaches Int32.MaxValue and miningInterval is positive, can the multiplication overflow and produce negative millisecond offsets, scheduling miners in the past? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Math Error] The formula adds miningInterval twice for each miner: (i * miningInterval) + miningInterval. Is this intentional or an off-by-one error that wastes the first time slot? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Math Error] For a list of N miners, the last miner gets time = currentBlockTime + (N-1)*interval + interval = currentBlockTime + N*interval. Could this exceed reasonable block time limits and cause the round to span multiple hours/days? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Math Error] If Pubkeys.Count is extremely large (1000+), does the time calculation for the last miner result in a timestamp so far in the future that it breaks consensus expectations? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Math Error] The AddMilliseconds() method on Timestamp - if the result exceeds Timestamp max value (year 9999), does it throw exception or silently wrap? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Business Logic] PreviousInValue is set to Hash.Empty for all miners. Does this break the VRF random value chain and allow miners to predict or manipulate the first InValue of the new term? (Critical)"
]