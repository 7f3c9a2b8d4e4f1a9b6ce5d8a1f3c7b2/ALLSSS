[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Input Validation Bypass] Can an attacker craft a symbol with multiple dashes (e.g., 'TOKEN-1-2') that passes regex '^[a-zA-Z0-9]+(-[0-9]+)?$' but causes downstream parsing failures in NFT operations, leading to locked funds or token creation bypass? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Symbol Collision] Can an attacker register both 'TOKEN' and 'TOKEN-0' since both pass the regex, creating two distinct tokens that collide when NFT itemId is '0', allowing double-spending or balance confusion? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidItemId()] [Integer Overflow] Does the regex '^[0-9]+$' allow extremely large item IDs (e.g., 10^100) that pass validation but cause integer overflow when parsed to long, enabling NFT ID collision or system crash? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidItemId()] [Leading Zeros Attack] Can an attacker create NFTs with leading zeros in itemId (e.g., '0001' vs '1') that are treated as different strings but resolve to same numeric value, allowing duplicate NFT minting or approval bypass? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidCreateSymbol()] [Case Sensitivity] Since IsValidCreateSymbol uses '^[a-zA-Z0-9]+$' while State.InsensitiveTokenExisting checks ToUpper(), can an attacker bypass collision checks by registering 'token' after 'TOKEN' is created? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidToken()] [Race Condition] If token is deleted between AssertValidSymbolAndAmount() and GetTokenInfo() calls, can operations proceed with null tokenInfo, causing state corruption or unexpected transfers? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidToken()] [Symbol Alias Attack] Does AssertValidToken properly validate symbol aliases, or can an attacker create circular alias mappings that cause infinite loops or bypass token existence checks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ValidTokenExists()] [TOCTOU Race] Between ValidTokenExists check and actual token operation, can token be deleted/modified by another transaction, causing assertion to pass but operation to fail with inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [NFT Symbol Manipulation] When splitting symbol by NFTSymbolSeparator, can attacker inject multiple separators (e.g., 'TOKEN-1-2') to bypass validation where words.Length == 2 check fails but still creates valid-looking NFT symbol? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [All Symbol Wildcard Bypass] If symbolPrefix equals allSymbolIdentifier, validation skips ValidTokenExists. Can attacker exploit this to approve transfers for non-existent tokens or bypass approval limits? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [Collection Symbol Forgery] When itemId equals allSymbolIdentifier, GetCollectionSymbol is called. Can attacker craft input to make this return a symbol they control, bypassing collection ownership checks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [NFT Symbol Confusion] Lines 69-73 check words.Length == 2 but what if itemId is empty string after split? Does 'TOKEN-' pass length check and cause ValidTokenExists to check wrong symbol? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetCollectionSymbol()] [Fixed Suffix Collision] Since collection symbols always use '-0' suffix, can attacker create regular NFT with itemId '0' that collides with collection symbol, allowing unauthorized collection operations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Integer Overflow] When computing target = before.Add(addAmount), if before is near Int64.MaxValue and addAmount is positive, does Add() properly handle overflow or wrap to negative, allowing balance inflation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Insufficient Balance Check Bypass] Lines 119-121 check 'before < -addAmount', but does this handle the case where addAmount is Int64.MinValue, causing -addAmount to overflow and bypass the check? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [State Race Condition] Between GetBalance() and State.Balances update, can another transaction modify the balance, causing the assertion to pass but final balance to be incorrect (TOCTOU)? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Negative Balance Attack] If balance check fails (line 120 Assert(false)), is transaction fully reverted or can partial state changes persist, allowing negative balances in some scenarios? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Blacklist Bypass via Proxy] IsInTransferBlackListInternal only checks 'from' address. Can blacklisted user transfer to intermediate address first, then that address transfers to final destination, bypassing blacklist? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Self-Transfer DoS] Line 102 prevents from == to, but what if attacker repeatedly calls transfer with from != to in a loop, can they drain gas/resources causing DoS on token operations? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Memo Overflow DoS] AssertValidMemo checks byte count <= MemoMaxLength, but can attacker craft UTF-8 sequences that expand dramatically when encoded, causing memory exhaustion or validation bypass? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Balance Update Ordering] ModifyBalance is called twice (lines 104-105). If first ModifyBalance succeeds but second fails due to overflow, is state fully reverted or can 'from' balance be decremented without 'to' receiving funds? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Event Frontrunning] Transferred event is fired after balance updates. Can attacker observe pending transfer, frontrun with their own transaction to manipulate balances before event is processed by external systems? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Memo Injection] Even though memo is validated for length, can attacker inject special characters or control sequences that break event parsing in external log processors? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Insufficient Allowance Check] Line 132 checks 'freeAllowanceAmount < -addAmount', but GetFreeFeeAllowanceAmount aggregates from multiple sources. Can race condition allow total to become negative if multiple transactions consume simultaneously? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Expiration Time Manipulation] GetSymbolListSortedByExpirationTime sorts by RefreshSeconds - (CurrentBlockTime - LastRefreshTime). Can attacker manipulate block time or refresh time to always prioritize their allowances, starving other users? (Medium)"
]