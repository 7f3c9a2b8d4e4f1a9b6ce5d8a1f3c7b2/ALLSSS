[
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetVotesWeight()] [Interest Tier Selection] At line 581, if lockDays > instMap.Day, continue. The loop finds the first tier where lockDays <= tier.Day. If tiers are not properly ordered despite line 203 sorting, could wrong interest rates apply? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetVotesWeight()] [Last Tier Application] At lines 588-591, if no tier matches, maxInterestInfo is used. If VoteWeightInterestList has only 1 tier, will all votes > that tier's Day use max interest, potentially over-rewarding long locks? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetVotesWeight()] [Type Cast Long Loss] At line 584, (long)(Pow(...) * votesAmount) casts decimal to long. Could precision loss or truncation cause weight to be less than it should be, shortchanging voters? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetVotesWeight()] [AmountProportion Division] At line 585, votesAmount.Mul(AmountProportion).Div(TimeProportion). If TimeProportion >> AmountProportion, integer division could result in 0 additional weight, making the amount-based component ineffective. (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetVotesWeight()] [Negative Weight Possible] If calculations at lines 584-585 somehow produce negative intermediate values (e.g., overflow wraparound), could final weight be negative, breaking invariants in ProfitContract? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetVotesWeight()] [VoteWeightInterestList Not Initialized] At lines 577-578, if State.VoteWeightInterestList.Value is null, it's set to GetDefaultVoteWeightInterest(). Could race conditions cause multiple initializations or could default values be used when updated values should apply? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Pow()] [Edge Case Y=1] At lines 596-597, if y==1, returns (long)x. But x is decimal. Could casting decimal to long lose precision or cause incorrect exponentiation results? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Pow()] [BitArray Conversion] At line 601, BitArray e = new BitArray(y.ToBytes(false)). If ToBytes has endianness issues or doesn't properly represent y as bits, could exponentiation be computed incorrectly? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Pow()] [Exponentiation Overflow] At line 605, a *= a repeatedly squares a. For large y values, could a overflow decimal bounds, causing exceptions or wraparound to incorrect values? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetEndPeriod()] [CurrentPeriod Retrieval] At line 614, treasury is fetched. If GetScheme call fails or returns null, could this cause null reference exception in period calculation? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetEndPeriod()] [Period Addition Overflow] At line 615, lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod). If both terms are large, could Add overflow long type? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Ector.cs] [Function: Withdraw()] [Time Manipulation] At line 633, actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds). Could miner timestamp manipulation allow premature withdrawals by making actualLockedTime appear larger? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Withdraw()] [Sender Authorization] The function doesn't explicitly check if Context.Sender is the voter who created the vote. At line 638, voterPublicKey is recovered, but is there a vulnerability if an attacker can provide a voteId belonging to another user? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Withdraw()] [VoterVotes Null Check] At line 642, Assert voterVotes != null. But GetElectorVote might return null for legitimate edge cases. Could this DOS legitimate withdrawals? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Withdraw()] [Remove Non-Existent VoteId] At line 644, ActiveVotingRecordIds.Remove(input) is called. If input doesn't exist in the list (due to prior corruption), does Remove fail silently, leaving vote counts inconsistent? (Medium)"
]