[
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: TokenContract] [Uninitialized State Reference] Can an attacker call contract methods before Initialize() is called, causing TokenContract.Value to be null and triggering failures in Buy/Sell operations that attempt to use State.TokenContract without null checks? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: TokenContract] [Malicious Contract Reference] If Initialize() allows setting TokenContract to an attacker-controlled contract address, can the attacker manipulate Transfer/TransferFrom/Burn operations in Buy/Sell/HandleFee to steal funds or mint unauthorized tokens? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: ParliamentContract] [Governance Bypass] Can an attacker exploit uninitialized ParliamentContract.Value in GetDefaultConnectorController() to bypass authorization checks in UpdateConnector/SetFeeRate/ChangeConnectorController methods? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: DividendPoolContract] [Lazy Initialization Exploit] Since DividendPoolContract.Value is lazily initialized in HandleFee(), can an attacker exploit the timing window where it's null to bypass fee donation to Treasury? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: BaseTokenSymbol] [Symbol Mutation] If BaseTokenSymbol.Value is modified after initialization through a vulnerability, can an attacker cause Buy/Sell to transfer wrong tokens, leading to fund loss or theft? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: BaseTokenSymbol] [Empty Symbol Attack] Can BaseTokenSymbol.Value be set to empty string during Initialize(), causing all TransferFrom/Transfer calls in Buy/Sell/HandleFee to fail and DOS the converter? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: FeeRate] [Invalid Decimal Format] Can FeeRate.Value be set to a non-parseable string (e.g., 'invalid', 'NaN', overflow value) that causes decimal.Parse() in GetFeeRate() to throw exceptions and DOS Buy/Sell operations? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: FeeRate] [Fee Rate Manipulation] Can an attacker with ConnectorController privileges call SetFeeRate() to set FeeRate.Value to '0.999999' (just under 1), causing 99.9999% fees that drain user funds in Buy/Sell? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: FeeRate] [Precision Loss Attack] Can FeeRate.Value be set to a value with extreme decimal precision (e.g., '0.123456789012345678901234567890') causing precision loss or overflow when multiplied with large amounts in Buy/Sell fee calculations? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [Connector Overwrite Attack] Can State.Connectors[symbol] be overwritten for an active connector through UpdateConnector or AddPairConnector, corrupting IsPurchaseEnabled, Weight, or RelatedSymbol and breaking Buy/Sell calculations? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [Missing Connector] If State.Connectors[symbol] returns null for a valid symbol in Buy/Sell, can the null check be bypassed causing null reference exceptions and transaction failures? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [Symbol Case Sensitivity] Are Connectors mapping keys case-sensitive, allowing an attacker to create duplicate connectors with 'ELF' vs 'elf' and exploit connector lookup mismatches in Buy/Sell? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [Connector Weight Manipulation] Can Connector.Weight be set to '0' or '1' (boundary values) through UpdateConnector, causing division by zero or formula breakdown in BancorHelper calculations during Buy/Sell? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [Virtual Balance Overflow] Can Connector.VirtualBalance be set to Int64.MaxValue through AddPairConnector/UpdateConnector, causing overflow when added to realBalance in GetSelfBalance() during Buy/Sell price calculations? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [IsPurchaseEnabled Race] Can an attacker exploit race conditions between EnableConnector setting IsPurchaseEnabled=true and Buy/Sell checking the flag to perform unauthorized trades? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [RelatedSymbol Corruption] If Connector.RelatedSymbol is set to point to a non-existent connector or creates circular reference, can this cause infinite loops or null derefs in Buy/Sell when resolving connector pairs? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: Connectors] [IsDepositAccount Flag Attack] Can toggling Connector.IsDepositAccount flag cause GetSelfBalance() to read from wrong source (TokenContract vs DepositBalance), enabling price manipulation in Buy/Sell? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: TransactionFees] [Unused State Vulnerability] Since TransactionFees MappedState is declared but never used in the contract code, can residual data or future upgrades exploit this dormant state to bypass fee controls? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: DepositBalance] [Balance Underflow] Can State.DepositBalance[symbol].Sub(amount) in Sell() underflow when amount > current balance, causing negative balance or wraparound to Int64.MaxValue? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: DepositBalance] [Balance Overflow] Can State.DepositBalance[symbol].Add(amount) in Buy() overflow when adding large amounts, wrapping to negative values and corrupting reserve accounting? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: DepositBalance] [Uninitialized Balance Read] If DepositBalance[symbol] is read before any deposits, does it return 0 by default or null/undefined, potentially causing incorrect Bancor calculations in Buy/Sell? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: DepositBalance] [Balance Inconsistency] Can DepositBalance[symbol] diverge from actual contract token holdings due to direct transfers bypassing Buy/Sell, enabling arbitrage or price manipulation? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: DepositBalance] [Symbol Mismatch] Can DepositBalance be indexed with wrong symbol (resource symbol instead of deposit symbol) causing balance updates to wrong connector in EnableConnector? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: ConnectorController] [Null Controller Bypass] If ConnectorController.Value is null and GetDefaultConnectorController() fails to initialize ParliamentContract, can all connector management functions become ungoverned? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs] [State: ConnectorController] [Authority Struct Manipulation] Can ConnectorController.Value.OwnerAddress be set to zero address or attacker address through ChangeConnectorController, granting unauthorized control over UpdateConnector/SetFeeRate? (Critical)"
]