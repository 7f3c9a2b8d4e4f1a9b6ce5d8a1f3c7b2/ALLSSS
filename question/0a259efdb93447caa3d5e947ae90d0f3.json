[
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Authorization Bypass] Can an attacker register a voting item with a whitelisted token symbol that was later removed from the whitelist, allowing votes with non-whitelisted tokens if the check at line 29-34 is only performed during registration but not during voting? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Input Validation] Can an attacker create a voting item with StartTimestamp equal to EndTimestamp by exploiting the comparison at line 361 which only checks 'greater than' but not 'greater than or equal to', enabling a zero-duration voting period that could freeze snapshot operations? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [State Consistency] Can an attacker register multiple voting items with identical parameters from the same sender address, causing voting item ID collision at line 354 since the hash calculation uses Context.Sender and input without options, potentially overwriting existing voting items? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Integer Overflow] Can an attacker register a voting item with TotalSnapshotNumber set to long.MaxValue at line 359, causing integer overflow when CurrentSnapshotNumber is incremented in TakeSnapshot() at line 259, breaking snapshot progression? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Default Value Manipulation] Can an attacker exploit the automatic assignment at line 359 where TotalSnapshotNumber is set to 1 if it's 0, to bypass intended snapshot limits by initially setting it to 0 and expecting different behavior? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Quadratic Voting] Can an attacker register a quadratic voting item with TicketCost set to 0 at line 51, causing all votes to be free at line 102 where amount = votingItem.TicketCost.Mul(currentVotesCount), enabling unlimited free voting power? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Quadratic Voting] Can an attacker register a quadratic voting item with TicketCost set to a very small value (e.g., 1 wei), causing the multiplication at line 102 to result in extremely cheap votes that could manipulate voting results with minimal cost? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [State Initialization] Can an attacker exploit the VotingResult initialization at lines 58-63 where only VotingItemId, SnapshotNumber, and SnapshotStartTimestamp are set, to manipulate voting if VotersCount and VotesAmount default to 0 is not properly handled in subsequent operations? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Token Contract Reference] Can an attacker front-run the token contract initialization at lines 24-26 to replace State.TokenContract.Value before the whitelist check, allowing registration with non-whitelisted tokens? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Options Validation] Can an attacker register a voting item with 0 options in the input.Options list at line 49, creating a voting item that cannot accept any votes since AssertValidVoteInput() at line 381 would fail for any option? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Options Validation] Can an attacker register a voting item with duplicate options in the input.Options list at line 49, causing vote result inconsistencies since the Results map at line 174 would map both to the same key? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Options Length] Can an attacker register a voting item with an option string exceeding VoteContractConstants.OptionLengthLimit (1024 chars) at line 49, bypassing the validation that only exists in AddOption() at line 294, causing storage bloat? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Options Count] Can an attacker register a voting item with more than VoteContractConstants.MaximumOptionsCount (64) options initially at line 49, bypassing the validation that only exists in AddOption() at line 285, causing DOS when iterating options? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Timestamp Manipulation] Can an attacker register a voting item with StartTimestamp set to far in the past (e.g., Unix epoch 0) at line 45, enabling immediate voting even though the voting should start at a future time? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Register()] [Timestamp Manipulation] Can an attacker register a voting item with EndTimestamp set to far in the future (e.g., timestamp overflow value) at line 47, creating a voting item that never expires and prevents resource cleanup? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Authorization Bypass] Can an attacker vote on behalf of another user by exploiting the delegated voting mode at lines 384-389 where if IsLockToken is false, the Sponsor can vote for any arbitrary Voter address without that voter's permission? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Quadratic Voting Integer Overflow] Can an attacker cause integer overflow in quadratic voting at line 102 by repeatedly voting to increment QuadraticVotesCountMap to a value where TicketCost.Mul(currentVotesCount) exceeds long.MaxValue, causing amount to wrap to negative or zero? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Quadratic Voting State Manipulation] Can an attacker vote multiple times on the same vote ID in quadratic voting mode, incrementing QuadraticVotesCountMap at line 100 each time and causing exponentially increasing costs, but only locking the final amount at line 124-130 while previous votes remain unlocked? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Vote Record Overwrite] Can an attacker overwrite existing voting records by using a predictable vote ID, exploiting that State.VotingRecords[input.VoteId] at line 117 unconditionally overwrites without checking if a record already exists? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Double Voting] In non-quadratic voting mode at lines 94-97, can an attacker vote multiple times with the same VoteId on delegated voting items (IsLockToken=false) since there's no check preventing duplicate VoteIds, allowing the same tokens to count multiple times? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Token Lock Bypass] Can an attacker vote without actually having tokens by exploiting that the token lock at lines 124-130 happens AFTER the voting record is saved and results are updated at lines 117-120, allowing reentrancy to read inflated vote counts before tokens are locked? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Snapshot Boundary] Can an attacker vote exactly when TakeSnapshot() is being called, causing votes to be counted in the wrong snapshot number at line 109 if CurrentSnapshotNumber is incremented mid-transaction? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Amount Validation] In non-quadratic mode at line 96, can an attacker vote with amount=0 or negative amount since there's no validation on input.Amount before it's used, allowing votes to be cast without locking any tokens? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Amount Validation] Can an attacker vote with amount exceeding their token balance in non-quadratic mode at line 96, since there's no balance check before the Lock call at line 124, causing the Lock to fail silently or revert without proper state cleanup? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Timestamp Validation] Can an attacker vote before the voting period starts or after it ends, since AssertValidVoteInput() at line 92 doesn't check if Context.CurrentBlockTime is within StartTimestamp and EndTimestamp boundaries? (High)"
]