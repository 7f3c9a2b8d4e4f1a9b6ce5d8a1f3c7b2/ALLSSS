[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Integer Underflow] At line 113, round.RoundNumber.Sub(1) is used to access previous round - if round.RoundNumber is 0, can this underflow causing access to round -1 or a wrapped-around large positive number? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Secret Sharing Leak] The SecretSharingInformation event at lines 110-115 fires whenever roundNumber > 1 and IsMinerListJustChanged is false - can attackers trigger this repeatedly to leak previous round secrets before they should be revealed? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [State Inconsistency] At lines 113-114, State.Rounds[round.RoundNumber.Sub(1)] is accessed multiple times - if another transaction modifies this round between accesses, could inconsistent round data be included in the SecretSharingInformation event? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [DOS via Memory] The comment at line 107 says 'No need to share secret pieces if miner list just changed', but the condition at line 107 only checks !round.IsMinerListJustChanged - can attackers set IsMinerListJustChanged=false on every round to force secret sharing events on every round, exhausting memory? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Round Removal Logic] At line 118, roundNumberToRemove = round.RoundNumber.Sub(KeepRounds) - if round.RoundNumber < KeepRounds, can this result in removing round 0 or negative rounds, or does .Sub() prevent underflow? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Conditional Removal] Lines 119-123 only remove old rounds when GetMaximumBlocksCount() == MaximumTinyBlocksCount - can attackers manipulate GetMaximumBlocksCount() to prevent round removal, causing unbounded state growth and eventual storage exhaustion? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Boundary Check] The check roundNumberToRemove > 1 at line 120 means round 1 is never removed, but what prevents attackers from adding duplicate round 1 data multiple times, corrupting the first round information? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Authorization Missing] This function has no access control - can unauthorized callers add arbitrary round information, injecting fake miner lists, time slots, or consensus data? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Event Replay] Can the SecretSharingInformation event at lines 110-115 be triggered multiple times for the same round by re-adding round information, allowing observers to collect duplicate secret shares? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: AddRoundInformation()] [Previous Round Access] At line 113, accessing State.Rounds[round.RoundNumber.Sub(1)] assumes the previous round exists - if it was already removed by the cleanup logic at line 123, will this return null/empty causing the event to contain invalid previous round data? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: TryToUpdateRoundInformation()] [Null Check Issue] At line 129, the function checks if ri == null and returns false, but State.Rounds.Set() at line 130 is called regardless - if ri is null, does this create a new round entry instead of updating an existing one? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: TryToUpdateRoundInformation()] [Silent Overwrite] If ri is not null but is different from the input round parameter, the function silently overwrites it without validation - can attackers replace legitimate round information with malicious data? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: TryToUpdateRoundInformation()] [Missing Authorization] Like AddRoundInformation, this function has no access control - can anyone update round information for any round number, corrupting consensus state? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: TryToUpdateRoundInformation()] [Return Value Ambiguity] The function returns false when ri is null, but what does true mean - that the round existed before or that the update succeeded? Can callers misinterpret this? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: TryToUpdateRoundInformation()] [Race Condition] Between reading ri at line 128 and setting the new round at line 130, could another transaction modify State.Rounds[round.RoundNumber], causing a lost update? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTransactionOnlyExecutedOnceInOneBlock()] [Block Height Collision] The assertion at line 136 prevents execution when LatestExecutedHeight equals CurrentHeight - but what if multiple independent methods call this helper in the same block? Will only the first method succeed, blocking legitimate operations? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTransactionOnlyExecutedOnceInOneBlock()] [Generic Error Message] The assertion message 'Cannot execute this tx.' at line 136 doesn't specify which transaction or method is affected - can this make debugging difficult and hide the actual cause of consensus failures? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTransactionOnlyExecutedOnceInOneBlock()] [State Update Timing] State.LatestExecutedHeight.Value is updated at line 137 after the assertion - if the assertion passes but the transaction reverts later, will LatestExecutedHeight still be updated, preventing retry in the same block? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTransactionOnlyExecutedOnceInOneBlock()] [DOS Attack] Can an attacker deliberately call methods using this helper to set LatestExecutedHeight, then causing all subsequent calls in the same block to fail, effectively blocking consensus operations for that block? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTransactionOnlyExecutedOnceInOneBlock()] [Initialization Issue] If LatestExecutedHeight is never initialized (defaults to 0), will the first call at block height 0 fail, or will it only activate after the first successful execution? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTransactionOnlyExecutedOnceInOneBlock()] [Cross-Method Coordination] If multiple different methods rely on this helper, does it enforce that only ONE method across the entire contract executes per block, or should it be per-method? If global, this creates severe DOS risks. (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTokenContractAddressSet()] [Contract Address Spoofing] At line 144, GetContractAddressByName is called with a string constant - can an attacker register a malicious contract with the same name before initialization, causing TokenContract.Value to point to an attacker-controlled contract? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTokenContractAddressSet()] [Lazy Initialization Race] The null check at line 142 and assignment at line 143-144 are not atomic - can multiple concurrent calls cause GetContractAddressByName to be invoked multiple times, potentially with different results? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTokenContractAddressSet()] [No Validation] After retrieving the contract address, there's no validation that it's a valid token contract - could GetContractAddressByName return null or an incorrect address, causing all token operations to fail silently? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs] [Function: EnsureTokenContractAddressSet()] [Immutability Issue] Once State.TokenContract.Value is set at line 143, it cannot be updated - if the token contract needs to be upgraded or migrated, will consensus be permanently stuck with the old contract address? (Medium)"
]