[
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Ln()] [Negative Result] When a > 1, x = 1 - a is negative - can the series Pow(x, iteration) with even iterations produce unexpected positive terms that cause incorrect logarithm calculation? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Ln()] [Division by Zero] At line 138, can iteration ever be 0, causing division by zero in Pow(x, iteration) / iteration? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Ln()] [Overflow in Series] Can Pow(x, iteration) overflow when x is close to -1 (a close to 2) and iteration is large, causing calculation failure? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Ln()] [Loop Termination] Does the while loop at line 136 correctly decrement and terminate, or can iteration wrapping cause infinite loop? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Factorial Overflow] At line 159, can Fact[iteration - 1] cause index out of bounds when iteration = 0, crashing the calculation? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Series Convergence] With only 20 iterations (line 154), can large positive or negative y values cause insufficient convergence, returning highly inaccurate exponentials? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Overflow] Can Pow(y, iteration) at line 160 overflow when y is large and iteration approaches 20, causing calculation crash? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Division Precision] Can division by very large factorials at line 160 cause precision loss that accumulates over iterations, producing inaccurate results? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Negative Input] When y is large and negative, can Exp return values very close to zero due to truncation, causing pricing formulas to fail? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Large Positive Input] When y is large and positive, can Exp overflow decimal max value, causing transaction revert and DOS? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: Exp()] [Loop Safety] Does the while loop at line 156 correctly decrement iteration from 20 to 1, or can it access iteration = 0 and cause Fact[-1] access? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: DynFact()] [Integer Overflow] Can factorial calculation at lines 18-19 overflow when number approaches 20, causing incorrect Fact array initialization? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: DynFact()] [Negative Input] If number is negative, does the loop at line 19 behave correctly, or can it cause unexpected results? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: DynFact()] [Zero Input] Line 18 handles number = 0 to return 1, but does the loop handle number = 1 correctly (should return 1)? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Static Constructor] [Initialization] At line 13, can the Fact array initialization fail due to DynFact overflow, causing all subsequent Exp() calls to use corrupted factorial values? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Static Constructor] [Array Bounds] Is the Fact array correctly sized for 20 elements (0-19), or can off-by-one errors cause index out of bounds in Exp()? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid() + GetAmountToPayFromReturn()] [Asymmetry] Can calling GetReturnFromPaid then GetAmountToPayFromReturn with the result produce different values due to rounding, enabling profit extraction through round-trip trades? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid() + GetAmountToPayFromReturn()] [Invariant Violation] Should GetAmountToPayFromReturn(GetReturnFromPaid(x)) â‰ˆ x hold, and if not, can attackers exploit the discrepancy for arbitrage? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid() + GetAmountToPayFromReturn()] [Reserve Consistency] Can alternating calls to both functions with edge-case weights cause reserve balances to drift from expected values, eventually draining pools? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid()] [Type Casting] At line 49, does (long) cast truncate or round the decimal, and can attackers exploit truncation to accumulate fractional token value over many transactions? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid()] [Type Casting] At line 53, if the decimal result is negative due to calculation error, does the long cast wrap to large positive, allowing massive token extraction? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetAmountToPayFromReturn()] [Type Casting] At line 84, can decimal-to-long casting lose significant precision when payment amounts are large, causing users to pay less than required? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetAmountToPayFromReturn()] [Type Casting] At line 93, can negative decimal results cast to large positive longs, allowing tokens to be sold for zero or negative payment? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid()] [Rounding Error] Can the simplified formula at line 49 produce different rounding than the full formula at line 53 when weights are nearly equal, enabling exploitation? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/BancorHelper.cs] [Function: GetReturnFromPaid()] [Precision Loss] In the calculation chain decimal conversions -> Ln -> Exp -> decimal multiplication -> long cast, can accumulated precision loss exceed 1%, enabling significant value extraction? (High)"
]