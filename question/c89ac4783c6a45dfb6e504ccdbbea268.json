[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ValidateTokenInfoExists()] [Early Throw] Throws at line 455 inside iteration - can this prevent proper validation of remaining keys? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ValidateTokenInfoExists()] [Owner Null Handling] Compares tokenInfo.Owner == input.Owner without null checks - can null vs empty address cause validation bypass? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Merkle Proof Bypass] CrossChainVerify at line 488 validates merkle path, but can attacker use old/replayed merkle proofs from previous blocks? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Transaction Replay] No check preventing same originalTransactionId from being used multiple times if merkle paths differ? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Token Overwrite] If State.TokenInfos[tokenInfo.Symbol] already exists at line 506, only ExternalInfo is updated at line 528 - can this cause inconsistent token state? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Issuer Mismatch] Token is created with Issuer from validateTokenInfoExistsInput, but can this differ from actual issuer on origin chain? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [NFT Collection Bypass] AssertNftCollectionExist at line 491 checks collection exists, but what if collection was created after transfer transaction? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainCreateToken()] [Alias Race Condition] SyncSymbolAliasFromTokenInfo at line 505 and ExternalInfo update at line 528 - can alias be set twice causing confusion? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: RegisterCrossChainTokenContractAddress()] [Controller Authorization Bypass] CheckCrossChainTokenContractRegistrationControllerAuthority at line 538 - can attacker gain control of controller to register malicious addresses? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: RegisterCrossChainTokenContractAddress()] [Address Extraction Manipulation] ExtractTokenContractAddress at line 544 parses from transaction params - can malformed params cause extraction of wrong address? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: RegisterCrossChainTokenContractAddress()] [Whitelist Overwrite] State.CrossChainTransferWhiteList[input.FromChainId] at line 549 overwrites existing value - can this deregister legitimate contract? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [Blacklist Check Position] IsInTransferBlackListInternal check at line 562 happens before burn, but can blacklisted address still burn tokens even if transfer fails? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [IssueChainId Mismatch] Requires issueChainId == input.IssueChainId at line 566, but can attacker specify wrong chainId to bypass cross-chain controls? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [Burn Without Verification] Tokens are burned at line 572 without verifying recipient exists on target chain - can tokens be permanently lost? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainTransfer()] [Event Replay] CrossChainTransferred event at line 573 can be replayed on receiving chain - are there replay protections? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Double Claim] State.VerifiedCrossChainTransferTransaction check at line 596, but can attacker claim tokens before this flag is set through reentrancy? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Supply Overflow] tokenInfo.Supply.Add(amount) at line 620 and check at line 621 - can multiple concurrent claims cause supply to exceed total supply? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Recipient Address Manipulation] receivingAddress from crossChainTransferInput at line 603 - can attacker modify transaction params to redirect tokens? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [ChainId Validation] targetChainId must equal Context.ChainId at line 610, but can attacker claim tokens on wrong chain by manipulating context? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [Merkle Proof Validation Window] CrossChainVerify at line 617 validates proof, but can old proofs from reorganized blocks still be valid? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: CrossChainReceiveToken()] [State Update Order] VerifiedCrossChainTransferTransaction set at line 619 after all validations but before supply update - can reentrancy bypass this? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Disabled State Race] Check State.TokenIssuerAndOwnerModificationDisabled.Value at line 644, but can value change between check and modification? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Owner Null Bypass] Requires tokenInfo.Owner == null at line 653, but can attacker set Owner to empty (non-null) address to bypass this? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Missing SetTokenInfo] After modifying issuer/owner at lines 655-656, SetTokenInfo is not called - do changes persist? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: ModifyTokenIssuerAndOwner()] [Issuer Authorization Bypass] Only checks tokenInfo.Issuer == Context.Sender at line 652, but can old issuer still issue after modification? (High)"
]