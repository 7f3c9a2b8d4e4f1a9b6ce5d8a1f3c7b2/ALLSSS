[
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [DonatedDividends Accumulation Logic] Lines 225-239 accumulate donations per block height - if multiple donors donate in same block, line 228 adds amounts, but line 231 creates new Dividends - can this cause accounting errors where only last donor's amount is recorded? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Block Height Key Collision] State.DonatedDividends uses Context.CurrentHeight as key at line 225 - can block reorganizations cause donations from orphaned blocks to be double-counted or lost? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Event Parameter Manipulation] DonationReceived event at lines 241-247 uses Context.Sender as 'From' even when Context.Sender == Context.Self - can this mislead external systems about donation sources during internal conversions? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: DonateAll()] [Balance Race Condition] Lines 259-263 query balance and then call Donate - can an attacker frontrun with TransferFrom to drain sender's balance between query and donation, causing Donate to fail and lock user funds? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: DonateAll()] [Zero Amount Donation] If GetBalance returns 0, line 265 passes Amount=0 to Donate, but Donate line 176 rejects Amount <= 0 - will this cause harmless revert or can it be used for DOS by forcing repeated failed transactions? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: DonateAll()] [Reentrancy in Donate] DonateAll calls Donate at line 265 which calls external contracts (TransferFrom, Approve, ContributeProfits) - can reentrancy during these calls manipulate balance queries to donate more than sender owns? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ChangeTreasuryController()] [Authority Validation Bypass] Line 277 calls CheckOrganizationExist(input) but the implementation is not shown - if this check is weak or missing, can an attacker set TreasuryController to address(0) or a non-existent organization to permanently lock treasury governance? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryController()] [Controller Authorization] Line 276 calls AssertPerformedByTreasuryController - if current controller is compromised, can they change controller to accomplice and drain treasury through SetSymbolList or weight setting manipulations? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ChangeTreasuryController()] [State Persistence] Line 278 directly overwrites State.TreasuryController.Value - if this transaction reverts after partial execution, can controller state become corrupted with input.ContractAddress != input.OwnerAddress consistency? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetSymbolList()] [Native Symbol Requirement] Line 285 asserts input.Value.Contains(NativeSymbol) - can an attacker satisfy this but include malicious duplicate native symbols to cause double-distributions in profit release at line 133? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetSymbolList()] [Whitelist Bypass] Lines 296-303 check IsTokenAvailableForMethodFee OR treasury in whitelist - can an attacker add a token that's in treasury's whitelist but not globally profitable, causing it to accumulate in treasury without distribution path? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetSymbolList()] [Converter Token Filter] Line 304 asserts !IsSymbolAbleToSell for non-native symbols - but if TokenConverter state changes after SetSymbolList, can previously non-convertible tokens become convertible, breaking the invariant and causing double-donations? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetSymbolList()] [Symbol List Replacement] Line 308 completely replaces State.SymbolList.Value - if a token was in old list but not new list, can accumulated treasury balance of that token become permanently locked? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetSymbolList()] [Empty Symbol List] If input.Value is empty except for NativeSymbol, does line 294 loop skip all validation, allowing a minimal symbol list that breaks multi-token distribution expectations? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetDividendPoolWeightSetting()] [Weight Validation Gaps] Lines 315-318 check all weights > 0 but don't validate maximum bounds - can an attacker set CitizenWelfareWeight=MaxInt causing integer overflow in proportion calculations at lines 439-440? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetDividendPoolWeightSetting()] [ResetSubSchemeToTreasury Atomicity] Line 319 calls ResetSubSchemeToTreasury which makes multiple ProfitContract calls - if one call fails mid-execution, can sub-schemes end up with inconsistent weights between treasury and state at line 320? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetDividendPoolWeightSetting()] [Weight Setting Timing] Can an attacker call this immediately before Release() to manipulate which scheme receives the largest share of current period's distribution, stealing rewards from legitimate beneficiaries? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetDividendPoolWeightSetting()] [Zero Weight Exclusion] The assertion requires all weights > 0 - but can setting very small weights (e.g. BackupSubsidyWeight=1) while others are massive cause rounding errors that eliminate backup subsidy distributions entirely? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetMinerRewardWeightSetting()] [Miner Reward Weight Overflow] Similar to dividend pool, lines 327-330 validate > 0 but not max bounds - can FlexibleRewardWeight=MaxInt cause overflow in proportion math at lines 410 and 422? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetMinerRewardWeightSetting()] [Sub-Scheme Reset Failure] ResetSubSchemeToMinerReward at line 331 modifies 3 sub-schemes - if one RemoveSubScheme call fails, will AddSubScheme still execute, creating duplicate beneficiary shares? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetMinerRewardWeightSetting()] [Welcome vs Basic Reward Manipulation] Can an attacker who controls treasury controller set WelcomeRewardWeight=MaxInt and BasicMinerRewardWeight=1 to redirect almost all miner rewards to new miners only, punishing established miners? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetWelfareRewardAmountSample()] [Period Underflow] Line 347 calls welfareScheme.CurrentPeriod.Sub(1) - if CurrentPeriod is 0 or 1, can this underflow and query invalid period data, returning manipulated reward samples? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetWelfareRewardAmountSample()] [Zero Total Shares] Line 350 returns empty output if totalShares == 0 - but this skips validation that period was actually distributed - can this mislead users about whether welfare rewards exist? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetWelfareRewardAmountSample()] [Decimal Overflow in Sample Calculation] Lines 357-360 use decimal arithmetic for (totalAmount * shares / totalShares) - can extremely large totalAmount values overflow decimal max value causing incorrect sample calculations? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetWelfareRewardAmountSample()] [Lock Time Weight Manipulation] Line 355 gets shares via GetVotesWeight(sampleAmount, lockTime) - if ElectionContract's weight calculation has bugs, can this return inflated samples that mislead voters into locking tokens based on false expectations? (High)"
]