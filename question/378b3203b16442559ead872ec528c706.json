[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [State Consistency] If TryToGetCurrentRoundInformation fails silently at line 225, could State.MinedMinerListMap.Set at line 227 record an empty or corrupted MinerList? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [Logic Error] Can currentRound.GetMinedMiners() return an inconsistent or manipulated list of miners at line 229, allowing fake miners to be recorded in MinedMinerListMap? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [Integer Underflow] Could currentRound.RoundNumber.Sub(3) at line 233 underflow when RoundNumber < 3, causing removeTargetRoundNumber to wrap to a huge value? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [DoS] If State.MinedMinerListMap grows unbounded and the cleanup at lines 233-235 fails to execute (removeTargetRoundNumber <= 0), can state size grow indefinitely? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [Logic Error] Is the cleanup logic at lines 233-235 race-condition safe? Can concurrent ProcessNextRound calls corrupt MinedMinerListMap by deleting the wrong entries? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Authorization] If _processingBlockMinerPubkey is manipulated or not in currentRound.RealTimeMinersInformation, can line 242 throw an exception or update the wrong miner's data? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [State Consistency] Can TryToGetCurrentRoundInformation fail at line 240, leaving minerInRound uninitialized but still modified at lines 243-248? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Input Validation] Are updateValueInput.ActualMiningTime, Signature, OutValue, SupposedOrderOfNextRound validated before being set at lines 243-248, or can miners inject arbitrary values? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Time Manipulation] Can a miner provide a fake ActualMiningTime at line 243 that is far in the future or past, breaking time slot calculations and round transitions? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] At line 247, FinalOrderOfNextRound is set equal to SupposedOrderOfNextRound - can this be overridden by TuneOrderInformation at line 260, creating order conflicts? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Integer Overflow] Can minerInRound.ProducedBlocks.Add(1) at line 251 overflow if a miner calls ProcessUpdateValue repeatedly to inflate their block count beyond max integer? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Integer Overflow] Can minerInRound.ProducedTinyBlocks.Add(1) at line 252 overflow, allowing miners to manipulate tiny block statistics? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] Are ProducedBlocks and ProducedTinyBlocks incremented correctly? Can calling ProcessUpdateValue add blocks that weren't actually produced, inflating miner statistics? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] Can IsSecretSharingEnabled() at line 254 be manipulated to skip secret sharing when it should be enabled, breaking random number generation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Re-entrancy] If PerformSecretSharing at line 256 modifies currentRound and another transaction reads it, can this create state inconsistency before TryToUpdateRoundInformation at line 284? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Authorization] Can updateValueInput.TuneOrderInformation at line 259 contain arbitrary key-value pairs that modify FinalOrderOfNextRound for miners who didn't authorize it? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [DoS] Can an attacker provide a very large TuneOrderInformation dictionary at line 259 to cause the foreach loop to consume excessive gas and revert? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] If TuneOrderInformation contains duplicate keys or keys not in currentRound.RealTimeMinersInformation, can line 260 throw exceptions or corrupt miner order? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Order Manipulation] Can miners collude to provide conflicting TuneOrderInformation values that manipulate FinalOrderOfNextRound to ensure specific miners get favorable time slots? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] If updateValueInput.PreviousInValue is not Hash.Empty (line 263), it's set at line 264 - but is there validation that this hash is correct and corresponds to the miner's actual previous in value? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Cryptographic Bypass] Can a miner provide a fake PreviousInValue at line 264 that doesn't match their actual secret, breaking the random number secret sharing chain? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] The comment at line 262 says 'It is permissible for miners not publish their in values' - can miners selectively skip publishing to manipulate consensus outcomes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [State Consistency] If TryToGetPreviousRoundInformation fails at line 266, the LIB calculation is skipped - can this cause LIB to lag indefinitely and block finality? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [LIB Manipulation] Can LastIrreversibleBlockHeightCalculator at lines 268-269 be manipulated by providing fake currentRound or previousRound data to set incorrect libHeight? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Logic Error] At line 272, LIB is only updated if currentRound.ConfirmedIrreversibleBlockHeight < libHeight - can this prevent LIB from ever advancing if the condition is never met? (High)"
]