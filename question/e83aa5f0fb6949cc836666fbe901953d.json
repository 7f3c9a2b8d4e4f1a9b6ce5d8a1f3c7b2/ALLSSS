[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Integer Division Rounding] Does the integer division in RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1) correctly implement the 2/3 majority consensus threshold, or could edge cases with specific miner counts (e.g., 1, 2, 4, 5) result in incorrect quorum calculations that allow consensus with insufficient miner participation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Arithmetic Overflow] Can RealTimeMinersInformation.Count.Mul(2) overflow if the miner count approaches int.MaxValue/2, causing MinersCountOfConsent to return a negative or incorrect value that breaks consensus validation logic? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Zero Miner Count] If RealTimeMinersInformation.Count is 0, does MinersCountOfConsent return 1 (via 0.Mul(2).Div(3).Add(1)), creating a scenario where consensus can be achieved with zero actual miners, potentially allowing invalid block finalization? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Single Miner Edge Case] With RealTimeMinersInformation.Count = 1, does MinersCountOfConsent compute to 1 (1*2/3+1 = 0+1 = 1), and does this correctly represent that a single miner can establish consensus alone, or should this case require special handling? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Two Miner Edge Case] With RealTimeMinersInformation.Count = 2, does MinersCountOfConsent return 2 (2*2/3+1 = 1+1 = 2), requiring both miners for consensus? Is this the intended Byzantine fault tolerance behavior or should 2 miners allow 1 to fail? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Negative Count Input] Can RealTimeMinersInformation.Count ever be negative due to bugs in upstream code, and if so, does the Mul(2).Div(3).Add(1) calculation produce undefined behavior or allow consensus bypass with a nonsensical negative quorum? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [BFT Threshold Correctness] Does the 2n/3+1 formula correctly implement Byzantine Fault Tolerance requiring >2/3 honest nodes, or does the integer division truncation create scenarios where exactly 2/3 (not >2/3) is accepted, violating BFT safety assumptions? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Race Condition] If RealTimeMinersInformation.Count changes between multiple reads of MinersCountOfConsent within the same transaction or block, could inconsistent quorum thresholds be used for different validation checks, allowing consensus manipulation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Caching Absence] Since MinersCountOfConsent is computed on every access without caching, could repeated access in hot code paths cause excessive gas consumption or performance degradation that leads to DOS conditions? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Property: MinersCountOfConsent] [Large Miner Count] For a network with 1000+ miners, does the computation RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1) remain accurate and efficient, or could integer overflow in Mul(2) or precision loss in Div(3) create consensus vulnerabilities? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Empty Input List] If specificPublicKeys is an empty list, does the method return an empty list, and could this empty result be misinterpreted by calling code as 'no irreversible height available' versus 'all heights should be considered', causing incorrect LIB calculation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Null Input] If specificPublicKeys is null, does the Contains() call throw a NullReferenceException that halts consensus processing and prevents new blocks from being finalized? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Invalid Public Key Format] If specificPublicKeys contains malformed public key strings, does the Contains() comparison fail silently or throw exceptions, and could an attacker inject invalid keys to exclude legitimate miners from LIB calculation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Duplicate Public Keys] If specificPublicKeys contains duplicate entries for the same public key, could the filtering logic include the same miner's ImpliedIrreversibleBlockHeight multiple times, skewing the sorted results and artificially advancing the LIB? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Case Sensitivity] Are public key comparisons in Contains() case-sensitive, and could an attacker provide public keys with different casing to bypass the filter and exclude certain miners from irreversible height consensus? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Zero Height Filtering] The method filters out miners where ImpliedIrreversibleBlockHeight <= 0. Could an attacker manipulate their own miner info to set ImpliedIrreversibleBlockHeight to 0, effectively excluding themselves from LIB consensus and preventing finalization? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Negative Height Values] If ImpliedIrreversibleBlockHeight can be negative due to bugs, does the filter 'i.ImpliedIrreversibleBlockHeight > 0' correctly exclude these, or could negative heights pass through and corrupt the sorted list used for LIB determination? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [All Miners Filtered Out] If all miners in RealTimeMinersInformation have ImpliedIrreversibleBlockHeight = 0, the method returns an empty list. Does the caller handle this gracefully, or does it cause the LIB to remain stuck at genesis, preventing any block finalization? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Sorting Stability] Does the List.Sort() method maintain stable ordering for miners with identical ImpliedIrreversibleBlockHeight values, and could non-deterministic sorting between nodes cause consensus disagreement on which height to use? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Large List DOS] If RealTimeMinersInformation contains thousands of miners and specificPublicKeys is also very large, could the O(n*m) complexity of the Contains() filter cause excessive gas consumption or timeout, halting consensus? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeights] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Public Key Not in Round] If specificPublicKeys contains public keys not present in RealTimeMinersInformation.Values, the Contains() filter simply excludes them. Could an attacker provide a list of non-existent keys to receive an empty result and manipulate LIB selection logic? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [LINQ Execution Timing] The method uses LINQ with ToList(), which forces immediate execution. If RealTimeMinersInformation is modified concurrently during LINQ evaluation, could the resulting list contain inconsistent data leading to incorrect LIB calculation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Integer Overflow in Heights] If ImpliedIrreversibleBlockHeight values approach long.MaxValue, could sorting these values cause overflow issues or incorrect ordering that places a lower height above a higher one, stalling finalization? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Memory Allocation Attack] Could an attacker cause RealTimeMinersInformation to grow unbounded, making the ToList() and Sort() operations consume excessive memory and crash the node during LIB calculation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs] [Function: GetSortedImpliedIrreversibleBlockHeights()] [Return Value Mutation] Since the method returns a List<long> (mutable), could calling code modify the returned list and cause unexpected behavior if this same list is cached or reused elsewhere in consensus logic? (Low)"
]