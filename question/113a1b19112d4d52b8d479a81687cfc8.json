[
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganization()] [Authorization Bypass] Can an attacker create multiple organizations with the same input parameters by exploiting the double-check pattern at lines 17-18 and 30-31, potentially causing race conditions or organization address collisions that could bypass governance controls? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganization()] [State Consistency] If Validate() passes at line 28 but State.Organizations[organizationAddress] is set by another transaction between lines 28-30, does the second check at line 30 prevent duplicate organization creation, or could this lead to lost organization events and inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganization()] [Input Validation] Can an attacker create an organization with ProposalReleaseThreshold values that pass Validate() but make it impossible to ever release proposals (e.g., MinimalApprovalThreshold > total token supply), effectively creating a permanent governance deadlock? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganization()] [Token Symbol Validation] At line 23, TokenSymbol is set without verifying token existence until Validate() is called. Could a front-running attacker create an organization with a token symbol before the token is created, then control governance once the token exists? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganization()] [Whitelist Manipulation] Can an attacker create an organization with an empty ProposerWhiteList that passes initial validation but later exploit ChangeOrganizationProposerWhiteList() to add unauthorized proposers? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganizationBySystemContract()] [Authorization Escalation] At line 44, the check only verifies Context.Sender is a system contract. Can a malicious system contract create organizations on behalf of arbitrary users by manipulating input.OrganizationCreationInput fields? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganizationBySystemContract()] [Callback Injection] At lines 47-48, Context.SendInline sends organizationAddress to an arbitrary method. Can an attacker specify a malicious OrganizationAddressFeedbackMethod that performs reentrancy or state manipulation attacks? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganizationBySystemContract()] [Reentrancy] Does the SendInline call at line 48 allow the receiving contract to re-enter CreateOrganizationBySystemContract or other Referendum methods before organization creation completes, potentially creating inconsistent state? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateProposal()] [Authorization Bypass] AssertIsAuthorizedProposer at line 55 checks Context.Sender against the whitelist. Can an attacker bypass this by creating a proposal through CreateProposalBySystemContract with a fake OriginProposer that's in the whitelist? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateProposal()] [Proposal ID Collision] If GenerateProposalId in Referendum_Helper.cs uses input.Token or HashHelper.ComputeFrom(input), can an attacker craft inputs to generate identical proposal IDs, overwriting existing proposals or causing assertion failures? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateProposalBySystemContract()] [Authority Confusion] At line 65, OriginProposer is checked against the whitelist, but Context.Sender (the system contract) creates the proposal. Could this allow system contracts to create proposals with arbitrary execution context? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateNewProposal() in Referendum_Helper.cs] [Timestamp Manipulation] Proposal validation checks Context.CurrentBlockTime < proposal.ExpiredTime. Can a miner manipulate block timestamps to immediately expire proposals or extend voting windows beyond intended limits? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateNewProposal() in Referendum_Helper.cs] [Input Validation] At line 172, Proposer is set to Context.Sender. In CreateProposalBySystemContract flow, does this mean the system contract becomes the Proposer, potentially blocking Release() calls at line 166? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CheckCreateProposalInput() in Referendum_Helper.cs] [DOS Attack] Title, Description, and ProposalDescriptionUrl have max length checks. Can an attacker spam CreateProposal with maximum-length strings to exhaust state storage or gas limits? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CheckCreateProposalInput() in Referendum_Helper.cs] [Injection Attack] ProposalDescriptionUrl is validated as HTTP/HTTPS at line 119-120, but can an attacker inject malicious URLs with encoded characters that bypass validation but execute attacks when accessed? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Approve()] [Double Voting] GetAllowance at line 74 checks current allowance, but can a user call Approve() multiple times with different allowance values between calls, effectively voting multiple times on the same proposal? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Approve()] [Integer Overflow] At line 76, proposal.ApprovalCount is incremented with Add(allowance). Could repeated Approve() calls cause integer overflow in ApprovalCount, wrapping to low values and invalidating the vote count? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Approve()] [Token Lock Failure] LockToken is called at line 78-79 but returns a ReferendumReceiptCreated event. If token transfer fails inside LockToken, does the transaction revert, or could ApprovalCount be incremented without actual token locking? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: LockToken() in Referendum_Helper.cs] [Reentrancy] At line 42, the assertion checks State.LockedTokenAmount[lockedAddress][proposalId] == null, but TransferFrom at lines 47-55 is a cross-contract call. Can an attacker re-enter Approve/Reject/Abstain during TransferFrom to lock tokens multiple times? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: LockToken() in Referendum_Helper.cs] [Allowance Manipulation] TransferFrom at line 48-55 transfers from Context.Sender to proposal virtual address. Can an attacker set high allowance, call Approve, then reduce allowance before TransferFrom executes, causing the vote to succeed without locking tokens? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: LockToken() in Referendum_Helper.cs] [State Inconsistency] Receipt is stored at line 56 using Context.Sender as key, but function parameter is lockedAddress. If these differ, could this create orphaned receipts or allow unauthorized token reclaim? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: LockToken() in Referendum_Helper.cs] [Virtual Address Collision] Lock ID is generated using proposalId and lockedAddress at line 44-45. Can an attacker create hash collisions to unlock other users' tokens by crafting specific proposalId/address combinations? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Approve()] [Race Condition] Between GetAllowance at line 74 and LockToken at line 78, can the user reduce their allowance, causing LockToken to fail but leaving ApprovalCount incremented from line 76? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Reject()] [Vote Manipulation] Identical logic to Approve() at lines 85-98. Can an attacker vote Approve and Reject simultaneously by calling both methods in separate transactions, locking tokens twice and manipulating vote counts? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Reject()] [Threshold Bypass] At line 91, RejectionCount is incremented. If MaximalRejectionThreshold in organization settings is very high, can an attacker spam Reject calls to inflate RejectionCount beyond realistic values, blocking proposal release? (Medium)"
]