[
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Dictionary Key Error] Line 162 uses nftTypes.Value.Remove(input.Value) - can this throw if key doesn't exist, despite line 157 assertion? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Create() DOS] After removal, Create() calling GetSymbol will fail at line 33 of Helpers if NFT type not found - can this permanently DOS protocol creation for that type? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Event Timing] NFTTypeRemoved event fires at line 164 after state changes - if event emission fails, are state changes still persisted? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: RemoveNFTType()] [Null Input] No validation that input or input.Value is not null before line 156 - can null inputs cause NullReferenceException? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AssertSenderIsParliamentDefaultAddress()] [Lazy Initialization Exploit] Lines 173-175 lazily initialize State.ParliamentContract.Value - can first caller manipulate SmartContractConstants to point to malicious contract? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AssertSenderIsParliamentDefaultAddress()] [Default Address Cache Poisoning] Lines 177-179 cache Parliament default address - if Parliament updates default address, cached value becomes stale, allowing old address to retain control? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AssertSenderIsParliamentDefaultAddress()] [External Call Trust] GetDefaultOrganizationAddress.Call at line 179 trusts Parliament contract - can compromised Parliament return attacker's address? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AssertSenderIsParliamentDefaultAddress()] [Reentrancy] GetDefaultOrganizationAddress.Call at line 179 is external - can reentrant calls manipulate Context.Sender before line 181 check? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AssertSenderIsParliamentDefaultAddress()] [Error Message] Line 181 returns generic 'No permission' - does this leak information about whether sender validation failed vs other issues? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: GetTokenExternalInfo()] [Metadata Validation Bypass] Line 186 only calls AssertMetadataKeysAreCorrect if input.Metadata != null - can attacker pass empty Metadata object to bypass validation? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: GetTokenExternalInfo()] [Reserved Key Injection] Lines 196-199 forcibly add three reserved keys - if input.Metadata already contains these, are they overwritten or does duplicate key exception occur? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: GetTokenExternalInfo()] [Metadata Key Validation] AssertMetadataKeysAreCorrect checks keys but not values - can malicious metadata values (e.g., extremely long strings) cause storage DOS? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: GetTokenExternalInfo()] [NftType Value Injection] Line 196 stores input.NftType without validation - can non-existent or malicious type strings corrupt ExternalInfo? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: GetTokenExternalInfo()] [Boolean String Conversion] Line 199 converts bool to string - can this create parsing issues in CrossChainCreate line 88 if ToString() format differs? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create() + CrossChainCreate()] [Mainchain-Sidechain Desync] Create() only works on mainchain (line 16) while CrossChainCreate() has no chain restriction - can this cause protocols to exist on sidechains but not mainchain? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create() + CrossChainCreate()] [Symbol Format Divergence] Create() generates 11-char symbols via GetSymbol(), CrossChainCreate() accepts arbitrary symbols - can sidechain protocols have invalid symbol formats? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create() + CrossChainCreate()] [Minter List Divergence] Create() allows custom minterList (line 36), CrossChainCreate() only sets issuer as minter (line 110) - can this cause minter privilege loss during cross-chain sync? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create() + CrossChainCreate()] [Protocol Override] CrossChainCreate checks protocol doesn't exist (line 79), but Create() doesn't - can Create() be called multiple times for same NFT type creating duplicate protocols? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType() + RemoveNFTType()] [Type Lifecycle Race] AddNFTType and RemoveNFTType modify same state - can concurrent calls cause type to be both added and removed, leaving corrupted state? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType() + Create()] [New Type Usage Race] If AddNFTType adds a type while Create() is executing GetSymbol(), can symbol generation fail due to race in InitialNFTTypeNameMap()? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create()] [MultiToken Contract Malicious Behavior] If TokenContract.Create at line 34 is malicious/compromised, can it return success but not actually create token, causing NFT protocol without underlying token? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create()] [Random Provider Failure] If RandomNumberProviderContract fails during GetSymbol(), does Create() properly handle errors or leave partial state? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Token Contract Data Injection] GetTokenInfo at line 80 returns tokenInfo controlled by TokenContract - can malicious TokenContract return fake data to corrupt NFT protocols? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AssertSenderIsParliamentDefaultAddress()] [Parliament Contract Replacement] If Parliament contract is upgraded/replaced after line 174 caches it, can old cached contract become invalid? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: Create()] [Gas Exhaustion] MinterList at line 36 is unbounded - can attacker pass massive minter list causing gas exhaustion and DOS? (Medium)"
]