[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Consensus Safety Violation] The index formula (Count-1)/3 at line 32 selects the height at roughly the 1/3 position of sorted heights, but Byzantine fault tolerance typically requires 2/3 agreement - if attackers control 1/3 of miners and can influence which heights are reported, they might be able to manipulate the selected LIB to a lower value than what 2/3 honest miners believe, compromising finality? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Threshold Calculation] The MinersCountOfConsent property used at line 26 is calculated as (totalMiners * 2 / 3) + 1, using integer division which rounds down - for totalMiners=4, this gives (4*2/3)+1 = (8/3)+1 = 2+1 = 3, but for totalMiners=5, it's (10/3)+1 = 3+1 = 4, and the threshold might not correctly represent 2/3 majority in all cases, affecting the LIB safety guarantee? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Miner Count Discrepancy] If _currentRound.RealTimeMinersInformation.Count (used to calculate MinersCountOfConsent) differs from the actual number of miners who participated in _previousRound, the threshold at line 26 could be based on current round's miner count while checking heights from previous round's different miner set, causing incorrect pass/fail of the consensus threshold? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Sybil Attack on LIB] An attacker controlling multiple miner identities could ensure all their nodes are included in GetMinedMiners() at line 24, then set their ImpliedIrreversibleBlockHeight values in _previousRound to the same malicious value, and if they constitute enough of the filtered heights to pass MinersCountOfConsent check at line 26, influence the LIB selection at line 32 to a height that benefits their attack (e.g., before a double-spend)? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Griefing Attack] Malicious miners could deliberately set their ImpliedIrreversibleBlockHeight to 0 or omit it in _previousRound, causing GetSortedImpliedIrreversibleBlockHeights at line 25 to return fewer heights, potentially keeping the count below MinersCountOfConsent at line 26 indefinitely and preventing any LIB from being established, halting finality? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Selective Participation] If attackers time their block production to be included in GetMinedMiners() only when it benefits them, they could selectively influence which previous round heights are considered at line 25, potentially causing the LIB calculation to skip certain heights or select heights that enable chain reorganization? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Network Partition] During a network partition where only a minority of miners can communicate, GetMinedMiners() at line 24 might return fewer pubkeys, causing GetSortedImpliedIrreversibleBlockHeights to include fewer heights, failing the MinersCountOfConsent check at line 26, and preventing LIB advancement even though the network is functioning on one partition? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [New Miner Onboarding] When new miners join and appear in currentRound but weren't in previousRound, they won't have ImpliedIrreversibleBlockHeight values in _previousRound, so even if they're in GetMinedMiners() at line 24, they contribute zero heights to the count, potentially causing the count to fall below MinersCountOfConsent and halting LIB progression during miner set changes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Single Miner Network] With only 1 miner, MinersCountOfConsent = (1*2/3)+1 = 0+1 = 1, and if GetSortedImpliedIrreversibleBlockHeights returns 1 height, the index calculation (1-1)/3 = 0 selects impliedIrreversibleHeights[0], which works, but this edge case lacks explicit validation and could fail if the single miner doesn't set ImpliedIrreversibleBlockHeight? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Two Miner Network] With 2 miners, MinersCountOfConsent = (2*2/3)+1 = 1+1 = 2, requiring both miners to participate, but if only one mined in currentRound, GetMinedMiners() returns 1 pubkey, GetSortedImpliedIrreversibleBlockHeights returns at most 1 height, failing the check at line 26, and preventing any LIB advancement in a 2-miner network unless both participate continuously? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Three Miner Network] With 3 miners, MinersCountOfConsent = (3*2/3)+1 = 2+1 = 3, requiring all three, and index = (3-1)/3 = 0, always selecting the minimum height among the three - but BFT consensus typically allows 1 fault in 3 nodes, so requiring all 3 heights seems overly strict and could cause liveness issues if one miner fails? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Round Transition Race] If Deconstruct is called during a round transition where _currentRound has just changed but _previousRound still references an older round (not the immediate previous), the mined miners from the current round won't match the miner set from the stale previous round, causing GetSortedImpliedIrreversibleBlockHeights to return fewer heights and failing consensus? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Concurrent Modifications] If _currentRound or _previousRound are modified by other threads/processes while Deconstruct executes (between lines 24-32), the GetMinedMiners, GetSortedImpliedIrreversibleBlockHeights, or MinersCountOfConsent values could change mid-calculation, leading to inconsistent state or incorrect LIB selection? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Missing Bounds Check] The array access impliedIrreversibleHeights[index] at line 32 doesn't validate that index < impliedIrreversibleHeights.Count, and while the check at line 26 ensures Count >= MinersCountOfConsent > 0, the index formula Count.Sub(1).Div(3) could theoretically produce an index >= Count in edge cases with arithmetic errors? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Negative Height] If GetSortedImpliedIrreversibleBlockHeights somehow returns negative height values that pass the > 0 filter, or if the selected height at line 32 is negative due to data corruption, the libHeight could be set to a negative value, causing issues in subsequent consensus logic that assumes non-negative block heights? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Unreasonably High Height] The code doesn't validate that the selected libHeight at line 32 is reasonable (e.g., not exceeding the current block height), allowing a malicious miner to set an extremely high ImpliedIrreversibleBlockHeight in _previousRound, which if selected, could claim future blocks as irreversible before they're produced? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Height Inflation] If miners can arbitrarily set their ImpliedIrreversibleBlockHeight values in _previousRound without proper validation, a coalition could set all their heights to an artificially high value, and if they constitute MinersCountOfConsent or more, the index selection at line 32 would pick this inflated height, potentially marking future blocks as irreversible prematurely? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Height Deflation] Conversely, if malicious miners set their ImpliedIrreversibleBlockHeight values to very low numbers in _previousRound, and they constitute enough of the filtered heights, the selection at line 32 could choose an outdated LIB height, preventing newer blocks from being finalized and potentially allowing long-range reorganization attacks? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Stale Previous Round] If _previousRound is not the immediate previous round of _currentRound but an older round (e.g., due to missing round data or skipped rounds), the minedMiners pubkeys from currentRound may not overlap well with previousRound's miner set, causing GetSortedImpliedIrreversibleBlockHeights to return insufficient heights and failing the check at line 26? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Future Previous Round] If due to a bug _previousRound actually has a higher RoundNumber than _currentRound (rounds passed in wrong order), the calculation would use future data to calculate past LIB, potentially selecting heights that haven't been properly validated yet and compromising consensus safety? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Pubkey Mismatch] If the pubkey strings in minedMiners from currentRound use different encoding/format than those in _previousRound.RealTimeMinersInformation, the Contains() check in GetSortedImpliedIrreversibleBlockHeights would fail to match, returning 0 heights and always failing the MinersCountOfConsent check at line 26? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Case Sensitivity] If pubkey comparisons in GetSortedImpliedIrreversibleBlockHeights are case-sensitive but miners' pubkeys are inconsistently cased between rounds, valid miners might not be matched when filtering heights at line 25, reducing the count below MinersCountOfConsent artificially? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Index Formula Intent] The index formula Count.Sub(1).Div(3) at line 32 appears intended to select the height at the 1/3 position, but typical BFT protocols select the f+1 position where f is max faults - if the intent is to ensure 2/3 miners have heights >= selected value, the formula should be Count.Div(3) or Count.Mul(1).Div(3), not (Count-1)/3 which biases toward lower indices? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Rounding Behavior] With Count=10, the index is (10-1)/3 = 9/3 = 3 (integer division), selecting the 4th height, but with Count=11, index = 10/3 = 3 (same), and Count=12, index = 11/3 = 3 (same), and Count=13, index = 12/3 = 4 - the discrete jumps in index due to integer division could cause LIB to advance in larger steps than expected? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs] [Function: Deconstruct()] [Count Range Analysis] For Count in range [MinersCountOfConsent, totalMiners], the index ranges from (MinersCountOfConsent-1)/3 to (totalMiners-1)/3, and if MinersCountOfConsent is close to totalMiners, the index is nearly constant, but this doesn't align with BFT principles where more confirmations should increase confidence, not just maintain the same index position? (Medium)"
]