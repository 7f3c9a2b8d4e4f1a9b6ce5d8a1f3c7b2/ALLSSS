[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Extension Method] If Milliseconds() extension method at line 29 rounds or truncates instead of using exact milliseconds, can this introduce cumulative timing errors over many rounds? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Type Safety] If the Duration subtraction at lines 28-29 returns null or invalid Duration, can Milliseconds() fail or return unexpected values? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Precision] At line 33, if (currentBlockTime - GetRoundStartTime()).Milliseconds() loses nanosecond precision, can this cause missedRoundsCount to be off by one in edge cases? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Overflow in Subtraction] If currentBlockTime at line 33 is Timestamp.MaxValue and GetRoundStartTime() is Timestamp.MinValue, can the subtraction overflow Duration's representation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Negative Duration] If GetRoundStartTime() > currentBlockTime at line 33, does Milliseconds() return a negative long causing division issues at line 34? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Division Safety] Does the Div() operation at line 34 handle division by zero internally, or will TotalMilliseconds() = 0 cause an exception? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Integer Division] Does Div() at line 34 perform integer division (truncating remainder) or floating-point division - if integer, can this cause nodes to skip time slots systematically? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: ArrangeAbnormalMiningTime()] [Multiplication Overflow] If minerInRound.Order is large and miningInterval is large at line 36, can Order.Mul(miningInterval) overflow long bounds causing wrapped negative offset? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: CalculateFutureRoundStartTime()] [Addition Overflow] If missedRoundsCount is near long.MaxValue at line 57, can missedRoundsCount.Add(1) overflow causing wrapped value? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs] [Function: CalculateFutureRoundStartTime()] [Multiplication Chain] At line 57, missedRoundsCount.Add(1).Mul(totalMilliseconds) - if both operands are large, can the multiplication overflow before AddMilliseconds() is called? (\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L1-74)\n```csharp\nusing System.Linq;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing Google.Protobuf.WellKnownTypes;\n\n// ReSharper disable once CheckNamespace\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\npublic partial class Round\n{\n    /// <summary>\n    ///     If one node produced block this round or missed his time slot,\n    ///     whatever how long he missed, we can give him a consensus command with new time slot\n    ///     to produce a block (for terminating current round and start new round).\n    ///     The schedule generated by this command will be cancelled\n    ///     if this node executed blocks from other nodes.\n    /// </summary>\n    /// <returns></returns>\n    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,\n        bool mustExceededCurrentRound = false)\n    {\n        var miningInterval = GetMiningInterval();\n\n        var minerInRound = RealTimeMinersInformation[pubkey];\n\n        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)\n        {\n            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)\n                .Milliseconds();\n            if (distance > 0) return GetExtraBlockMiningTime();\n        }\n\n        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();\n        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));\n        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);\n        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));\n    }\n\n    private MinerInRound GetExtraBlockProducerInformation()\n    {\n        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;\n    }\n\n    /// <summary>\n    ///     This method for now is able to handle the situation of a miner keeping offline so many rounds,\n    ///     by using missedRoundsCount.\n    /// </summary>\n    /// <param name="
]