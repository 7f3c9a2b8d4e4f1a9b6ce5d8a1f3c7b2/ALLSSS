[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: RoundId property] [Integer Overflow] If miners collude to set ExpectedMiningTime.Seconds to values near long.MaxValue, could the Sum() operation overflow, resulting in incorrect RoundId calculation and potential round validation bypass? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: RoundId property] [Logic Bypass] If all miners have null ExpectedMiningTime values, the property returns RoundIdForValidation directly without validation - can an attacker manipulate RoundIdForValidation to forge round identities and bypass consensus checks? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: RoundId property] [Inconsistent State] Can miners intentionally set some ExpectedMiningTime to null while others are non-null to force fallback to RoundIdForValidation, creating inconsistent round identification across nodes? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: RoundId property] [Determinism Break] If RealTimeMinersInformation dictionary ordering is non-deterministic across nodes, could the Sum() calculation produce different RoundId values on different nodes, breaking consensus? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: RoundId property] [Negative Values] Can malicious miners set negative ExpectedMiningTime.Seconds values to manipulate the sum calculation and produce artificially low or negative RoundId values? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Single Node Bypass] The function returns success without validation for single miner scenarios - can an attacker exploit single-node mode to bypass all time slot validation and mine blocks at arbitrary times? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Null Timestamp Injection] If miners can inject null ExpectedMiningTime after initial validation, can they cause the check to fail and halt consensus progress as a DoS attack? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Time Interval Manipulation] The function allows intervals up to 2x baseMiningInterval (Math.Abs check) - can miners collude to create highly unequal time slots while passing validation, enabling unfair mining advantages? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Integer Overflow in Milliseconds] Can extremely large timestamp differences cause Milliseconds() conversion to overflow when calculating baseMiningInterval, leading to incorrect validation results? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Order Manipulation] If miner Order values are manipulated to be non-sequential or duplicate, can this bypass the time slot equality checks by comparing wrong miner pairs? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Zero/Negative Interval] The function checks baseMiningInterval <= 0 but only for the first pair - can subsequent pairs have zero or negative intervals that pass validation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Last Miner Skip] The validation loop goes to miners.Count - 1, never validating the interval after the last miner - can the final time slot be arbitrarily manipulated without detection? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CheckRoundTimeSlots()] [Timestamp Wrap-Around] If ExpectedMiningTime values wrap around timestamp boundaries (e.g., year 2038 problem), can the subtraction produce incorrect negative intervals that pass validation? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Single Miner Hardcode] Single miner scenarios always return 4000ms regardless of actual configuration - can an attacker force single-miner mode to fix the interval and manipulate block timing? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Missing Order Validation] The function assumes miners with Order 1 and 2 exist but doesn't validate - can missing or duplicate orders cause LINQ query failures or return default(int) as interval? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Wrong Miner Selection] If the Where clause returns miners in non-deterministic order, could firstTwoMiners[0] and [1] be swapped, causing incorrect interval calculation and negative Math.Abs results? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Null ExpectedMiningTime] If miners with Order 1 or 2 have null ExpectedMiningTime, can the subtraction throw NullReferenceException or return incorrect zero interval? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Integer Truncation] The cast to (int) from Milliseconds() can truncate large intervals - can this cause loss of precision in mining schedule calculations? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Negative Interval Masking] Math.Abs always returns positive value even if miners are out of order - can this mask time-travel attacks where Order 2 mines before Order 1? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Missing Key Check Impact] If publicKey is not in RealTimeMinersInformation, function returns false - can unauthorized miners exploit this to bypass time slot validation by using unregistered keys? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Round 1 Special Case] Round 1 uses completely different logic based on FirstMiner().ActualMiningTimes - can an attacker manipulate ActualMiningTimes to control when other miners' slots are considered passed? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Integer Division Exploit] The expectedOrder calculation uses Div(miningInterval.Div(1000)) - can this double division cause precision loss that allows miners to mine in wrong time slots? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [ActualMiningTimes Manipulation] If FirstMiner().ActualMiningTimes list can be manipulated to be empty or contain multiple values, can this affect the time slot validation for all other miners in round 1? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Timestamp Overflow] When adding Duration to ExpectedMiningTime, can overflow cause wrap-around that makes future time slots appear as already passed? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Zero Mining Interval] If GetMiningInterval() returns 0, the Div(1000) and subsequent Div operations cause division by zero or infinite expectedOrder - can this crash consensus or allow arbitrary mining? (Critical)"
]