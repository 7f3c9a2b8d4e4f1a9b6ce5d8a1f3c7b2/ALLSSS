[
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Authorization Bypass] Can a malicious actor call CreateScheme multiple times with the same sender address to overwrite existing scheme configurations, potentially changing Symbol or MinimumLockMinutes after users have already locked tokens, breaking user expectations and lock agreements? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Accounting Error] Does the scheme creation at line 27 allow a scheme manager to set MinimumLockMinutes to 0 or negative values, enabling immediate withdrawals and breaking the locking mechanism's core invariant that tokens should be locked for a minimum period? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [DOS Attack] Can an attacker create unlimited schemes by repeatedly calling CreateScheme, consuming state storage and potentially causing gas exhaustion or state bloat that affects contract operations? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Input Validation] Does CreateScheme validate that input.Symbol is non-empty and corresponds to a valid token? Can setting an invalid or non-existent symbol cause failures in RegisterForProfits when it attempts to lock tokens? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [State Consistency] At line 20-25, CreateScheme calls ProfitContract.CreateScheme with IsReleaseAllBalanceEveryTimeByDefault=true and CanRemoveBeneficiaryDirectly=true. Can these settings be exploited to remove beneficiaries and drain profits before legitimate users can claim? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Integer Overflow] Can input.MinimumLockMinutes be set to Int64.MaxValue causing integer overflow when added to timestamps in Withdraw function at line 227, potentially allowing immediate withdrawals? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Logic Bug] Does line 31 properly validate AutoDistributeThreshold values? Can negative threshold amounts be set, causing auto-distribution logic to malfunction in RegisterForProfits? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Access Control] Is there any restriction preventing arbitrary addresses from becoming scheme managers? Can this lead to spam schemes or schemes created specifically for attack vectors? (Low)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [State Manipulation] After scheme creation, the SchemeId is not immediately set in TokenHolderProfitScheme (it's set later in UpdateTokenHolderProfitScheme). Can operations between CreateScheme and the first update exploit this null SchemeId state? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: CreateScheme()] [Cross-Contract Risk] Line 20 calls ProfitContract.CreateScheme without validating the return value. If ProfitContract is malicious or compromised, can it cause CreateScheme to succeed locally while failing to create the actual profit scheme? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Authorization Bypass] At line 39, GetValidScheme only checks that the scheme exists for Context.Sender, but doesn't verify Context.Sender is the actual scheme manager. Can any address with a scheme add beneficiaries to other schemes? (Critical)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Accounting Error] Lines 46-56 remove existing beneficiary and add back shares. Can the shares.Add(detail.Details.Single().Shares) at line 55 overflow when adding large share amounts, causing incorrect total shares? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Logic Bug] Line 48 comments 'Only keep one detail' and removes then re-adds beneficiary. Why is this pattern used instead of updating shares? Can this cause race conditions if called multiple times concurrently? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [DOS Attack] If detail.Details contains multiple entries despite comment saying 'Only keep one detail', line 55's Single() will throw. Can an attacker manipulate ProfitContract state to cause permanent DOS of AddBeneficiary? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Reentrancy] Between RemoveBeneficiary call at line 50 and AddBeneficiary call at line 58, can a malicious ProfitContract callback into TokenHolderContract and manipulate state before shares are re-added? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Input Validation] Does line 45 validate that input.Shares is positive? Can adding zero or negative shares cause accounting errors in profit distribution? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [State Consistency] If RemoveBeneficiary succeeds at line 50 but AddBeneficiary fails at line 58, the beneficiary loses their original shares permanently. Is there proper error handling or state rollback? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Authorization] Can the scheme manager add themselves as a beneficiary with arbitrary shares, potentially diluting other beneficiaries' profit shares unfairly? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Front-Running] Can a scheme manager front-run user RegisterForProfits transactions by calling AddBeneficiary to add themselves with massive shares right before profit distribution? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: AddBeneficiary()] [Logic Flaw] The function doesn't check if input.Beneficiary equals Context.Sender or the scheme manager. Can this create circular beneficiary relationships or unexpected behavior? (Low)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: RemoveBeneficiary()] [Authorization Bypass] Line 72 uses GetValidScheme(Context.Sender) but doesn't verify Context.Sender is the scheme manager. Can any address remove beneficiaries from schemes they don't manage? (Critical)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: RemoveBeneficiary()] [Logic Bug] Line 78's Single() call will throw if beneficiary has multiple profit details. Can this cause permanent DOS where legitimate beneficiaries can never be removed? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: RemoveBeneficiary()] [Accounting Error] Lines 85-95 use lockedAmount.Sub(input.Amount) without checking if input.Amount > lockedAmount. Can underflow occur if caller specifies amount larger than locked amount? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: RemoveBeneficiary()] [State Inconsistency] If input.Amount is 0, beneficiary is removed (line 86), but if input.Amount equals lockedAmount exactly, beneficiary is also removed. Is this inconsistent behavior intentional? Can it be exploited? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs] [Function: RemoveBeneficiary()] [DOS Attack] Can a scheme manager maliciously remove all beneficiaries right before DistributeProfits, causing profits to be unclaimable or redistributed incorrectly? (High)"
]