[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Corruption] Can an attacker pass mismatched currentRoundNumber and currentTermNumber where term transition hasn't occurred, violating the invariant that new terms start with incremented term numbers? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Integer Overflow] If the Pubkeys collection has Int32.MaxValue miners, can the order calculation i + 1 at line 31 overflow when i approaches Int32.MaxValue? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Business Logic] Can the order assignment starting from i + 1 (line 31) cause confusion if other code expects 0-indexed orders, leading to off-by-one errors in miner selection? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Corruption] Can an attacker manipulate the loop index to cause specific miners to receive predictable orders and gain scheduling advantages? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Integer Overflow] Can the i.Mul(miningInterval).Add(miningInterval) calculation at line 33 overflow when both i and miningInterval are large, causing incorrect ExpectedMiningTime assignments? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Corruption] Does the calculation i.Mul(miningInterval).Add(miningInterval) at line 33 correctly account for the first miner (i=0) getting an extra miningInterval delay before their slot? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Time Manipulation] Can an attacker exploit the fact that ExpectedMiningTime increments linearly by miningInterval to predict future mining slots and prepare front-running attacks? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Timestamp Overflow] Can the AddMilliseconds operation at line 33 cause Timestamp overflow if currentBlockTime is near the maximum timestamp value and large miningInterval * i is added? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Security] Does setting PreviousInValue to Hash.Empty for all miners at line 35 break the secret-sharing chain and allow miners to skip providing valid InValue for the first block of the new term? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Security] Can an attacker exploit the fact that PreviousInValue is Hash.Empty (line 35) to bypass InValue validation during the first round of a new term and manipulate random number generation? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Security] Does the comment 'Should be careful during validation' at line 34 indicate a known vulnerability where Hash.Empty PreviousInValue requires special handling that could be bypassed? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Corruption] Can miners collude by all submitting the same InValue in the first round since PreviousInValue is Hash.Empty, reducing randomness and enabling predictable outcomes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Fairness] Can an attacker with control over pubkey generation craft keys to always appear first in the sorted order (line 18) and consistently become the extra block producer (line 28)? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Fairness] Does assigning IsExtraBlockProducer to the first sorted miner (lines 27-28) create a centralization risk where the same miner repeatedly gains extra block production privileges? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Fairness] Can an attacker analyze the sorting algorithm (descending by first byte at line 18) to predict which pubkey will be the extra block producer and manipulate election results? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Business Logic] If only one miner exists in the Pubkeys list, does setting IsExtraBlockProducer = true at line 28 grant that miner both regular and extra block production rights unfairly? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [DoS] Can an attacker provide duplicate pubkeys in the MinerList causing the round.RealTimeMinersInformation.Add() at line 37 to throw ArgumentException and crash term generation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Data Integrity] If sortedMiners[i] at line 37 happens to be a duplicate due to sorting instability with identical first bytes, will the Add operation silently overwrite previous miner information? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [DoS] Can an attacker provide pubkeys that hash to the same hex string (via ToHex() at line 17), causing dictionary key collision in ToDictionary() and throwing exception? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Logic] Does hardcoding IsMinerListJustChanged = true at line 42 correctly reflect reality if the new miner list is identical to the previous term's list? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Logic] Can an attacker exploit the fact that IsMinerListJustChanged is always true (line 42) to trigger miner-change logic even when the list hasn't changed, causing unnecessary state resets? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm()] [Consensus Logic] Does setting IsMinerListJustChanged = true (line 42) without validating actual changes violate the semantic meaning of this flag and confuse downstream consensus logic? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm() overload] [Input Validation] Can an attacker pass a null currentRound object to the second overload at line 47, causing NullReferenceException when accessing currentRound.RoundNumber at line 49? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm() overload] [Input Validation] Can an attacker pass a currentRound with negative RoundNumber, causing the first overload call at line 49 to receive negative currentRoundNumber and generate corrupted rounds? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs] [Function: GenerateFirstRoundOfNewTerm() overload] [Input Validation] Can an attacker pass a currentRound with negative TermNumber, causing the first overload call at line 49 to receive negative currentTermNumber and corrupt term progression? (High)"
]