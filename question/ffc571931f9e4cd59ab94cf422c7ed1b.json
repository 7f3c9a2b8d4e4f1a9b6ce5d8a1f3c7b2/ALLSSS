[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetNextElectCountDown()] [Term 1 Special Case] Lines 419-425 handle term 1 differently. Can attacker manipulate BlockchainStartTimestamp in term 1 to extend or shorten first election period? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [LastRoundNumber Calculation] Line 442 calculates lastRoundNumber using Add(1).Sub(1). Can integer overflow in Add cause incorrect round lookup? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [Round Validation] Line 444 checks if round is null or RoundId==0. Can attacker setting RoundId to 0 bypass validation and return empty Round instead of failing? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [Selective Field Copy] Lines 449-454 only copy Pubkey and ProducedBlocks. Does omitting other fields like MissedTimeSlots hide punishment information and enable evil miner to rejoin? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousTermInformation()] [TermNumber Override] Line 447 sets result.TermNumber to input.Value. Can attacker requesting future term number cause confusion in term-dependent logic? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Term Number Fetch] Line 73 calls TryToGetTermNumber. If this fails, function returns default value. Can missing term number cause incorrect reward calculations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Sub(1) Underflow] Line 75 uses Sub(1) on FirstRoundNumberOfEachTerm. If termNumber is 1, can underflow cause lookup of round 0 or negative round? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [Round Lookup Failure] Line 76 tries to get round info for targetRound. If this round doesn't exist, does returning empty Int64Value cause reward distribution to skip previous term? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetMinedBlocksOfPreviousTerm()] [GetMinedBlocks Trust] Line 77 calls GetMinedBlocks() on round. Can corrupted round data with inflated block counts cause excessive reward minting? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [TermNumber Underflow] Line 85 checks termNumber > 1 before Sub(1). But can termNumber be 0, causing check to pass incorrectly? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [Null Miner List] Line 86 uses ?? operator returning empty list if MinerListMap entry is null. Can this hide missing historical data that should cause error? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetPreviousMinerList()] [Genesis Term Access] Line 88 returns empty list for term 1 or if fetch fails. Can code depending on this list crash or make incorrect authorization decisions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [Round Fetch Failure] Line 33 uses TryToGetCurrentRoundInformation. If this fails, returns empty MinerList. Can empty list cause consensus to freeze? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [ByteString Conversion] Line 38 converts hex string keys to ByteString. Can malformed hex in RealTimeMinersInformation.Keys cause conversion exceptions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerList()] [Select Chain] Line 38 uses Select with FromHexString. If any key conversion fails, does Select chain break or skip entries, reducing miner count? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerPubkeyList()] [ToHex Conversion] Line 48 converts Pubkeys to hex strings. Can non-standard ByteString formats cause ToHex to fail or produce inconsistent results? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerPubkeyList()] [Double Conversion] Function converts ByteString->Hex->ByteString->Hex in chain with GetCurrentMinerList. Can double conversion introduce inconsistencies? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerListWithRoundNumber()] [Atomicity] Lines 56-57 fetch MinerList and RoundNumber separately. Can state change between these calls cause miner list and round number to be from different rounds? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetCurrentMinerListWithRoundNumber()] [Empty Input Redundancy] Line 56 passes new Empty() instead of using input parameter. Is this intentional, or does it indicate misunderstanding of function contract? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GetRoundInformation()] [Arbitrary Round Access] Line 28 allows querying any round number via input.Value. Can querying very high round numbers cause resource exhaustion or return future round data?\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L1-474)\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing AElf.Contracts.Election;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\n// ReSharper disable once InconsistentNaming\npublic partial class AEDPoSContract\n{\n    public override Int64Value GetCurrentRoundNumber(Empty input)\n    {\n        return new() { Value = State.CurrentRoundNumber.Value };\n    }\n\n    public override Round GetCurrentRoundInformation(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();\n    }\n\n    public override Round GetRoundInformation(Int64Value input)\n    {\n        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();\n    }\n\n    public override MinerList GetCurrentMinerList(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var round)\n            ? new MinerList\n            {\n                Pubkeys =\n                {\n                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))\n                }\n            }\n            : new MinerList();\n    }\n\n    public override PubkeyList GetCurrentMinerPubkeyList(Empty input)\n    {\n        return new()\n        {\n            Pubkeys = { GetCurrentMinerList(input).Pubkeys.Select(p => p.ToHex()) }\n        };\n    }\n\n    public override MinerListWithRoundNumber GetCurrentMinerListWithRoundNumber(Empty input)\n    {\n        return new()\n        {\n            MinerList = GetCurrentMinerList(new Empty()),\n            RoundNumber = State.CurrentRoundNumber.Value\n        };\n    }\n\n    public override Round GetPreviousRoundInformation(Empty input)\n    {\n        return TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round();\n    }\n\n    public override MinerList GetMinerList(GetMinerListInput input)\n    {\n        return State.MinerListMap[input.TermNumber] ?? new MinerList();\n    }\n\n    public override Int64Value GetMinedBlocksOfPreviousTerm(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber))\n        {\n            var targetRound = State.FirstRoundNumberOfEachTerm[termNumber].Sub(1);\n            if (TryToGetRoundInformation(targetRound, out var round))\n                return new Int64Value { Value = round.GetMinedBlocks() };\n        }\n\n        return new Int64Value();\n    }\n\n    public override MinerList GetPreviousMinerList(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber) && termNumber > 1)\n            return State.MinerListMap[termNumber.Sub(1)] ?? new MinerList();\n\n        return new MinerList();\n    }\n\n    public override StringValue GetNextMinerPubkey(Empty input)\n    {\n        if (TryToGetCurrentRoundInformation(out var round))\n            return new StringValue\n            {\n                Value = round.RealTimeMinersInformation.Values\n                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??\n                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey\n            };\n\n        return new StringValue();\n    }\n\n    /// <summary>\n    ///     Current implementation can be incorrect if all nodes recovering from\n    ///     a strike more than the time of one round, because it's impossible to\n    ///     infer a time slot in this situation.\n    /// </summary>\n    /// <param name="
]