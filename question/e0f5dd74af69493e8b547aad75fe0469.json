[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Regex Bypass] Can an attacker create tokens with symbols like 'ABC-0' which passes the regex '^[a-zA-Z0-9]+(-[0-9]+)?$' but may conflict with NFT symbol format, leading to symbol collision and token confusion? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Input Validation] Does the regex '^[a-zA-Z0-9]+(-[0-9]+)?$' allow symbols with leading zeros like 'TOKEN-0001' which could cause duplicate symbol issues when normalized, enabling double-registration attacks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidSymbol()] [Length Validation Missing] The function only validates format but not length - can an attacker create extremely long symbols (1000+ chars) that pass regex but cause DoS in storage or processing operations? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidItemId()] [Regex Weakness] The regex '^[0-9]+$' allows unlimited leading zeros - can '00000001' and '1' be treated as different NFT IDs causing duplicate NFT creation for same logical item? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidItemId()] [Integer Overflow] Does IsValidItemId validate the numeric range? Can an attacker use '99999999999999999999999999999' exceeding long.MaxValue, causing parsing failures or integer overflow in downstream operations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidCreateSymbol()] [Symbol Collision] The regex '^[a-zA-Z0-9]+$' allows symbols without hyphens - can this create collision between base token 'ABC0' and NFT collection prefix 'ABC' when combined with '-0' suffix? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsValidCreateSymbol()] [Case Sensitivity] Does the validation allow both 'TOKEN' and 'token' as different symbols? Can attacker create phishing tokens exploiting case-insensitive user interfaces while being case-sensitive in contract? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidToken()] [TOCTOU Race] Between line 35 AssertValidSymbolAndAmount and line 36 GetTokenInfo, can token info be deleted by parallel transaction, causing assertion to pass but subsequent operations to fail with inconsistent state? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidToken()] [Null Symbol Check] Line 37 checks '!string.IsNullOrEmpty(tokenInfo.Symbol)' but tokenInfo itself could be non-null with empty Symbol field - can this bypass cause operations on invalid/deleted tokens? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [NFT Separator Injection] Line 57 splits by TokenContractConstants.NFTSymbolSeparator - can attacker inject multiple separators like 'ABC--123' to bypass validation or cause array index out of bounds? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [All Symbol Bypass] Lines 60, 72 check for 'allSymbolIdentifier' - can attacker exploit this wildcard to approve/manipulate all tokens at once if allSymbolIdentifier is predictable or leaked? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [Symbol Validation Inconsistency] Line 60 uses IsValidCreateSymbol for prefix validation but line 71 uses IsValidItemId - can mismatched validation allow malformed symbols through one path but not another? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertApproveToken()] [Collection Symbol Construction] Line 72 constructs nftSymbol conditionally - if itemId equals allSymbolIdentifier, it uses GetCollectionSymbol, otherwise uses original symbol. Can this logic be exploited to approve non-existent collections? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ValidTokenExists()] [State Access Without Lock] Lines 49-51 read State.TokenInfos without synchronization - can concurrent token deletion cause race condition where exists check passes but token is deleted before usage? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetCollectionSymbol()] [Hard-coded Suffix] Line 78 appends '-0' suffix - can attacker create token 'ABC-0' directly that collides with collection symbol for 'ABC', causing authorization or balance confusion? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Integer Overflow] Line 123 uses before.Add(addAmount) - if before + addAmount exceeds long.MaxValue, does Add() method throw or wrap around, potentially allowing balance inflation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Insufficient Balance Check] Lines 119-121 only check if 'before < -addAmount' when addAmount < 0, but what if before + addAmount causes overflow? Can attacker exploit this to bypass balance checks? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Negative Balance Possibility] If before.Add(addAmount) implementation doesn't prevent negative results in edge cases, can balance become negative breaking supply invariant? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Direct State Assignment] Line 124 directly assigns without emit event or additional validation - can this be exploited in reentrancy scenarios where balance is modified during callbacks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyBalance()] [Error Message Information Leak] Lines 120-121 expose exact balance 'Current balance: {before}' - can attackers use this to probe account balances through transaction failures? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Symbol Transformation] Line 169 calls GetActualTokenSymbol which may resolve aliases - can attacker exploit alias resolution to query balances of aliased tokens without authorization? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetBalance()] [Address Validation Timing] Line 168 validates address but line 169 gets symbol - can invalid symbol bypass address validation by throwing different exception? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Blacklist Check Before Balance] Line 101 checks blacklist but balance check is in ModifyBalance at line 104 - can attacker add addresses to blacklist mid-transfer to cause fund locking? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Self-Transfer Check] Line 102 prevents 'from == to' but doesn't prevent sending to contract addresses that immediately forward back - can circular transfers cause reentrancy or state corruption? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Balance Modification Order] Lines 104-105 modify sender balance first, then receiver - if line 105 fails after 104 succeeds, can this cause balance inconsistency without rollback? (Critical)"
]