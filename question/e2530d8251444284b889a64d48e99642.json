[
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseSideChainCreation()] [Double Release Attack] If TryClearExpiredSideChainCreationRequestProposal() returns false but CreateSideChainToken() fails, can the attacker retry to double-spend the locked tokens? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseSideChainCreation()] [Serial Number Race] Can concurrent calls increment State.SideChainSerialNumber.Value multiple times, causing chainId collisions or gaps in GetChainId()? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseSideChainCreation()] [Proposal Expiry Manipulation] Can an attacker extend proposal expiry by manipulating input.ProposalId to point to a different non-expired proposal? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseSideChainCreation()] [Token Creation Front-running] Can an attacker front-run CreateSideChainToken() to create a token with the same symbol, causing the legitimate creation to fail while still consuming the proposal? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Authorization Bypass] Can AssertSideChainLifetimeControllerAuthority() be bypassed if the controller contract has a vulnerability allowing unauthorized Context.Sender impersonation? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Proposal Reuse Attack] If State.ProposedSideChainCreationRequestState.Remove(input.Proposer) fails silently, can the same proposal be used to create multiple side chains? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Serial Number Overflow] If State.SideChainSerialNumber.Value.Add(1) overflows at maximum long value, will GetChainId() produce duplicate chainIds, allowing chainId collisions? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Indexing Fee Bypass] Can ChargeSideChainIndexingFee() be bypassed if LockedTokenAmount is set to exactly zero, allowing free side chain creation while still passing validation? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [ChainId Prediction] Since GetChainId() is deterministic based on serialNumber, can an attacker pre-compute future chainIds and squat on resources/addresses before side chain creation? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [State Race Condition] Can concurrent CreateSideChain calls with the same serialNumber create two side chains with identical chainIds, breaking uniqueness invariant? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Initialization Data Manipulation] Can GetChainInitializationData() return malicious consensus data that compromises the side chain's security from genesis? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Indexing Price Manipulation] Can sideChainInfo.IndexingPrice be set to MaxLong value, causing integer overflow when multiplied by block count during indexing fee calculation? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: CreateSideChain()] [Controller Organization DOS] If CreateDefaultOrganizationForIndexingFeePriceManagement() creates an organization with impossible approval thresholds, can this permanently freeze indexing fee adjustments? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Arrears Payment Bypass] If sideChainInfo.ArrearsInfo contains addresses with negative arrears, can an attacker drain tokens through TransferDepositToken() to these manipulated addresses? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Insufficient Recharge Check] The assertion at line 207 checks input.Amount + originBalance >= arrearsAmount + IndexingPrice, but can an attacker recharge just enough to pass while immediately incurring more debt? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Status Manipulation] Can sideChainInfo.SideChainStatus be changed to Active even if arrears are only partially paid, by manipulating the arrearsAmount calculation in the loop? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [ArrearsInfo Parsing Attack] If arrears.Key is a malicious Base64 string that doesn't parse to valid Address, will Address.Parser.ParseFrom() throw, allowing DOS of recharge functionality? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Integer Overflow] Can arrearsAmount += arrears.Value overflow if ArrearsInfo contains MaxLong values, causing incorrect arrears calculation? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [TransferFrom Front-running] Can an attacker front-run the recharge to revoke token allowance, causing TransferFrom to fail but sideChainInfo.ArrearsInfo.Clear() to execute, erasing debt records? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Terminated Chain Recharge] Since the assertion only checks SideChainStatus != Terminated, can an attacker recharge a Terminated chain if state is corrupted, locking tokens permanently? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: Recharge()] [Virtual Address Exploitation] Can ConvertVirtualAddressToContractAddress() be manipulated to send recharge funds to attacker-controlled address instead of side chain virtual address? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Authorization Bypass] Can AssertSideChainLifetimeControllerAuthority() be bypassed through a malicious controller contract that temporarily returns Context.Sender as owner? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Double Disposal Attack] If UnlockTokenAndResource() fails but info.SideChainStatus is set to Terminated, can an attacker call DisposeSideChain again to double-withdraw locked tokens? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Proposal Cleanup Race] If TryGetIndexingProposal() returns true but ResetChainIndexingProposal() is front-run, can this leave orphaned proposals that block future indexing? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: DisposeSideChain()] [Indexing Fee Theft] Can UnlockTokenAndResource() transfer tokens to the wrong address if info.Proposer has been corrupted or changed since creation? (High)"
]