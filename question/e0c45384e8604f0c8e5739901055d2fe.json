[
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Non-Burnable Protocol Bypass] At lines 87-88, can an attacker bypass the IsBurnable check by manipulating the NFTProtocolInfo state or calling Burn through a different path? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Balance Underflow Risk] At line 94, can burning more than available balance cause an underflow if the assertion at line 91 is bypassed or fails to catch edge cases? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Protocol Supply Corruption] If nftProtocolInfo.Supply becomes negative due to multiple concurrent burns or arithmetic errors at line 95, can it break protocol-level supply constraints and accounting? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Burn()] [Burned Token Resurrection] After IsBurned is set to true at line 99, can the token be reminted or transferred, violating the burned state invariant? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [NFT Theft via Assemble] At lines 124-131, when assembling NFTs, the function transfers them to Context.Self - can an attacker exploit this to lock victim's NFTs permanently if disassembly fails or is blocked? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [FT Allowance Front-running] Between checking allowance at line 148-154 and executing TransferFrom at line 155-161, can an attacker front-run to reduce allowance, causing the transaction to fail after NFTs are already locked? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Metadata Injection] At lines 122 and 136, assembled NFT/FT data is stored in metadata with keys AssembledNftsKey and AssembledFtsKey - can an attacker inject malicious data that overwrites these reserved keys via input.Metadata? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Insufficient Balance Check Bypass] At line 128, the balance check only verifies NFT balance - can an attacker exploit timing or state inconsistencies to assemble NFTs they don't actually own? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Hash Collision in Assembled NFTs] At line 126, Hash.LoadFromHex(pair.Key) converts string keys to hashes - can an attacker craft colliding hex strings to manipulate which NFTs get locked during assembly? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [FT Balance Check Race Condition] At lines 142-147, balance is checked before TransferFrom - can the balance change between check and transfer, causing the transfer to fail after NFTs are already locked in the contract? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Double Assembly Exploit] Can an attacker call Assemble twice with the same NFTs by exploiting timing windows, locking the same NFTs into multiple assembled tokens? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Assembled Token Mint Permission] At line 175, PerformMint is called with isTokenIdMustBeUnique=true - can an attacker bypass minter checks if the assembled token minting path doesn't properly validate minter permissions? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [State Corruption on Partial Failure] If TransferFrom at line 155 fails for some FTs after NFTs are already transferred at line 130, are the NFTs returned or permanently locked? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Assemble()] [Metadata Key Validation Bypass] At line 116, AssertMetadataKeysAreCorrect is called - but can reserved keys for assembled NFTs/FTs be overwritten if validation is incomplete? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Authorization Bypass] At lines 193-198, Burn is called without verifying that Context.Sender owns the assembled token - can any minter burn and disassemble someone else's token? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Receiver Manipulation] At line 200, receiver defaults to Context.Sender if input.Owner is null - can an attacker specify a different owner to redirect disassembled assets to arbitrary addresses? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [State Cleanup Failure] If AssembledNftsMap or AssembledFtsMap removal at lines 209 and 224 fails, can the same token be disassembled multiple times, duplicating the underlying assets? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Null Reference Crash] At line 203, if AssembledNftsMap[tokenHash] returns null and Clone() is called, does this cause a null reference exception that bricks the disassembly process? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Transfer Failure Handling] At lines 207 and 217-222, if DoTransfer or State.TokenContract.Transfer.Send fails for some assets, is the assembled token still burned, causing permanent asset loss? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Burn Amount Hardcoded] At line 197, the burn amount is hardcoded to 1 - can an attacker assemble multiple copies and only burn 1 to disassemble, potentially duplicating underlying assets? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [Clone Mutation Risk] At lines 203 and 212, Clone() is called on assembled assets - can mutations to the cloned data affect the original state, causing inconsistencies? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: Disassemble()] [DOS via Empty Assembly] If an assembled token has empty AssembledNfts and AssembledFts, can repeated disassemble calls be used to spam events and waste gas? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: ApproveProtocol()] [Protocol Existence Check Bypass] At line 240, if State.NftProtocolMap[input.Symbol] check can be bypassed or returns a non-null dummy value, can operators be added for non-existent protocols? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: ApproveProtocol()] [Operator List Pollution] At lines 244-245, operators are added without limit - can an attacker spam add operations to bloat the operator list, causing DOS or excessive gas costs for future operations? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_UseChain.cs] [Function: ApproveProtocol()] [Approval Revocation Race] At lines 247-248, operators are removed from the list - can concurrent approve/revoke calls cause race conditions that leave the operator list in an inconsistent state? (Low)"
]