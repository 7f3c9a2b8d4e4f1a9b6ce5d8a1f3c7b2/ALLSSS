[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [Emergency Response] If GetMaximumBlocksCount returns 1 during Severe status but ResetLatestProviderToTinyBlocksCount hasn't been called, does stale LatestPubkeyToTinyBlocksCount allow more than 1 block during emergency? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [Recovery Phase] After Severe status resolves and MaximumBlocksCount returns to 8, can a miner who had negative BlocksCount during Severe immediately produce 8 more blocks, or does the negative count persist? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [Miner Replacement] When RecordCandidateReplacement swaps miners mid-round, does LatestPubkeyToTinyBlocksCount correctly track the new miner's blocks, or can the replacement exploit fresh counter state? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [Tiny Block Spam] Can a miner produce maximum tiny blocks (8) then immediately produce UpdateValue blocks which may not decrement the counter, effectively producing more than 8 continuous blocks? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [NextRound Transition] During NextRound consensus behavior when RoundNumber increments, does LatestPubkeyToTinyBlocksCount reset or carry over, and can this transition be exploited for extra blocks? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [NextTerm Transition] During NextTerm when term number changes, does continuous block tracking persist or reset, and can term boundaries be exploited to bypass limits? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [IrreversibleBlockHeight] Does validation consider IrreversibleBlockHeight, and can a miner produce blocks after LIB updates that were invalid before LIB but pass validation after? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [Pubkey Encoding] SenderPubkey is converted ToHex() from bytes - can encoding differences or byte-order attacks cause pubkey mismatch on line 18 even when the same miner is producing blocks? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs] [Function: ValidateHeaderInformation()] [Validation Sequence] Is Continu\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L1-29)\n```csharp\nusing AElf.Standards.ACS4;\n\n// ReSharper disable once CheckNamespace\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\npublic class ContinuousBlocksValidationProvider : IHeaderInformationValidationProvider\n{\n    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)\n    {\n        // Is sender produce too many continuous blocks?\n        var validationResult = new ValidationResult();\n\n        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.\n            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)\n        {\n            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;\n            if (latestPubkeyToTinyBlocksCount != null &&\n                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&\n                latestPubkeyToTinyBlocksCount.BlocksCount < 0)\n            {\n                validationResult.Message ="
]