[
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CalculateVirtualHash()] [Null Token Handling] Line 223 checks if creationToken == null and returns organizationHash directly - can this create address collisions between organizations with and without creation tokens? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CalculateVirtualHash()] [Hash Concatenation] Line 225 uses HashHelper.ConcatAndCompute - can specific combinations of organizationHash and creationToken produce identical results as organizationHash alone? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CalculateVirtualHash()] [Token Reuse] If creationToken is reused across organizations, can this create predictable patterns in virtual hashes? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken() + UnlockToken()] [Lock-Unlock Race] Can an attacker call UnlockToken immediately after LockToken in the same block, bypassing intended vote locking period? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken() + IsReleaseThresholdReached()] [Vote Counting Integrity] If tokens are locked but vote counts aren't updated atomically, can voting thresholds be bypassed? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: CreateNewProposal() + GetValidProposal()] [Proposal Lifecycle] Can a proposal become invalid between creation and first retrieval, causing execution of invalid proposals? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: Validate(Organization) + CreateNewProposal()] [Organization-Proposal Consistency] Can proposals be created for organizations that fail validation, leading to unvotable proposals? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GetAllowance() + LockToken()] [Allowance-Lock Mismatch] If GetAllowance checks pass but subsequent LockToken fails, can this create inconsistent voting state? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: GenerateProposalId() + CreateNewProposal()] [ID Collision Attack] Can an attacker precompute proposal IDs and create proposals that collide with legitimate future proposals? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: AssertIsAuthorizedProposer() + CreateNewProposal()] [Authorization Timing] Is AssertIsAuthorizedProposer called before CreateNewProposal in all code paths? Can authorization be bypassed? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: RequireTokenContractStateSet() + GetTokenInfo()] [Token Contract Trust] All token operations trust the token contract - can a malicious or compromised token contract break referendum security? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: LockToken() + GetProposalVirtualAddress()] [Virtual Address Consistency] Are virtual addresses used consistently across lock/unlock operations, or can address mismatches cause token loss? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [Function: Validate(Proposal) + CheckCreateProposalInput()] [Validation Completeness] Do these two validation functions cover all security-critical proposal fields, or are some fields unvalidated? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: LockedTokenAmount] [Mapping Structure] State.LockedTokenAmount uses nested mapping [address][proposalId] - can this structure be exploited to lock tokens under multiple proposal IDs? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: LockedTokenAmount] [State Cleanup] UnlockToken removes state on line 87 but LockToken checks a different address on line 42 - can orphaned state entries accumulate? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: Proposals] [Proposal Storage] Proposals are stored but never explicitly deleted - can expired proposals cause storage bloat or be reused maliciously? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: Organizations] [Organization Immutability] Organizations retrieved from state can be modified - are they immutable once created or can parameters be changed post-creation? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [State: TokenContract] [Contract Address Caching] TokenContract address is cached in state - can this become stale if the token contract is upgraded or replaced? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [General: Virtual Addresses] [Virtual Address Security] Multiple functions use virtual addresses derived from proposal IDs - can these be predicted or manipulated for malicious purposes? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [General: Context.Sender] [Sender Authentication] Context.Sender is used throughout without additional authentication - can transaction origin be spoofed in the AElf context? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum_Helper.cs] [General: Context.CurrentBlockTime] [Time Manipulation] Multiple functions rely on Context.CurrentBlockTime - can miners manipulate block time to affect proposal\n\n### Citations\n\n**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L1-227)\n```csharp\nusing System;\nusing AElf.Contracts.MultiToken;\nusing AElf.CSharp.Core;\nusing AElf.Sdk.CSharp;\nusing AElf.Standards.ACS3;\nusing AElf.Types;\n\nnamespace AElf.Contracts.Referendum;\n\npublic partial class ReferendumContract\n{\n    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)\n    {\n        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;\n        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=\n                         proposalReleaseThreshold.MinimalVoteThreshold;\n        if (!enoughVote)\n            return false;\n\n        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;\n        if (isRejected)\n            return false;\n\n        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;\n        if (isAbstained)\n            return false;\n\n        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;\n    }\n\n    private void RequireTokenContractStateSet()\n    {\n        if (State.TokenContract.Value != null)\n            return;\n        State.TokenContract.Value =\n            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);\n    }\n\n    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,\n        Address organizationAddress)\n    {\n        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null,"
]