[
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Reentrancy] Can an attacker exploit the initialization flow by calling CreateScheme 7 times before State.Initialized is set to true, potentially creating duplicate profit schemes if called reentrantly? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [State Manipulation] If State.Initialized check fails after partial scheme creation, can the contract end up with fewer than 7 schemes, breaking subsequent operations that assume exactly 7 schemes exist? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Configuration Error] The DelayDistributePeriodCount is set to 1 only for index 3 (Welfare), but can this delay cause synchronization issues where welfare distribution is perpetually one period behind, leading to stale reward calculations? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Authorization] Since there's no explicit sender verification, can any account call InitialTreasuryContract before State.Initialized.Value is set to true, potentially front-running the legitimate initialization? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialTreasuryContract()] [Logic Error] The CanRemoveBeneficiaryDirectly flag is set for indices 2, 5, 6 (Subsidy, Flexible, Welcome), but what prevents an attacker from exploiting this to remove legitimate beneficiaries and redirect rewards? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [State Inconsistency] If GetManagingSchemeIds returns exactly 7 schemes but they're not in the expected order, will the wrong scheme IDs be assigned to TreasuryHash, RewardHash, etc., causing complete reward distribution failure? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Authorization Bypass] The function checks State.TreasuryHash.Value == null but doesn't verify the caller - can an attacker call this before legitimate initialization to set malicious scheme IDs? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Integration Risk] If electionContractAddress is null, managers for SubsidyHash and WelfareHash aren't reset - can this lead to the Treasury contract retaining unauthorized control over these schemes indefinitely? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [State Manipulation] BuildTreasury() is called which sets default weights - if an attacker can influence the timing of this call versus SetDividendPoolWeightSetting, can they lock in unfavorable default weights? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: InitialMiningRewardProfitItem()] [Address Collision] The TreasuryVirtualAddress is computed from ProfitContract address and scheme hash - can an attacker predict this address and pre-fund it or set up malicious state before initialization? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Authorization Bypass] Only AEDPoS contract can call Release, but if State.AEDPoSContract.Value is uninitialized or can be manipulated, can an attacker bypass this check and trigger unauthorized profit distributions? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Reentrancy] The function calls DistributeProfits, then retrieves previous term info, updates state, and distributes again - can an attacker exploit reentrancy during DistributeProfits to corrupt the state updates or double-claim rewards? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Integer Overflow] When combining currentMinerList, previousTermInformation miners, and replaceCandidates into maybeNewElectedMiners, can an extremely large combined list cause memory/gas exhaustion or overflow in subsequent processing? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [State Corruption] ReplaceCandidateMap is removed after reading - if Release is called twice for the same period (via reentrancy or race condition), will the second call miss the replace candidates, causing incorrect reward distribution? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Logic Error] maybeNewElectedMiners filters out miners with State.LatestMinedTerm[p] == 0 AND not in initial list - can a miner who mined in term 1, skipped terms, then returned be incorrectly treated as new, getting undeserved welcome rewards? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [DOS Attack] If previousTermInformation contains an enormous number of miners, will the filtering and processing of maybeNewElectedMiners cause gas exhaustion, preventing release and freezing all reward distributions? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Accounting Error] AmountsMap is initialized with all symbols set to 0L - does DistributeProfits actually distribute the accumulated balances in the virtual address, or does this zero map cause all rewards to be lost? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [State Inconsistency] UpdateStateBeforeDistribution is called before ReleaseTreasurySubProfitItems, but if the distribution fails, the state updates persist - can this cause permanent desynchronization between state and actual distributions? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Release()] [Race Condition] If multiple Release calls are queued for different periods, can out-of-order execution cause LatestMinedTerm updates to be applied incorrectly, breaking future reward calculations? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Authorization Bypass] When Context.Sender == Context.Self, TransferFrom is skipped - can an attacker call Donate through a delegatecall or inline call to donate without actually transferring tokens? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Reentrancy] The function calls TransferFrom, then potentially ConvertToNativeToken (which calls Sell and recursively calls DonateAll) - can an attacker exploit reentrancy to manipulate DonatedDividends state or double-contribute? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Token Validation Bypass] If IsTokenAvailableForMethodFee returns false, the function returns Empty without reverting - can an attacker donate worthless tokens that get accepted into the treasury without validation? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Accounting Error] When needToConvert is true, ConvertToNativeToken is called but DonatedDividends is NOT updated - does this mean converted donations aren't tracked, breaking dividend accounting? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [State Manipulation] DonatedDividends[Context.CurrentHeight] accumulates donations in the same block - if an attacker makes multiple donations in one block, can they manipulate the recorded amount to be higher or lower than actual? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: Donate()] [Logic Error] The code checks if donatesOfCurrentBlock != null AND symbol matches AND contains key, then adds - but if donatesOfCurrentBlock is null OR symbol doesn't match, it creates NEW Dividends - can this overwrite existing donations of other symbols in same block? (High)"
]