[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTCollection()] [Authorization Bypass] Can an attacker create multiple NFT collections with the same symbol prefix by calling CreateNFTCollection repeatedly before state updates are committed, potentially bypassing uniqueness constraints in the underlying CreateToken method? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTCollection()] [Symbol Collision] Does CreateNFTCollection validate that the collection symbol doesn't collide with existing NFT item symbols (e.g., creating 'NFT-0' when 'NFT-1' already exists), allowing confusion between collections and items? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTCollection()] [Input Validation] Can CreateNFTCollection accept malformed symbol inputs that pass validation but create unusable collections (e.g., symbols with special characters, excessive length, or reserved keywords)? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [IssueChainId Override] At line 18, when input.IssueChainId is 0, it's set to nftCollectionInfo.IssueChainId. Can an attacker specify a non-zero but invalid IssueChainId that differs from the collection's IssueChainId before the assertion at line 20-21 executes, bypassing chain validation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [ExternalInfo Key Extraction] At lines 22-24, the code extracts NftCreateChainIdExternalInfoKey from ExternalInfo. If an attacker provides a collection with maliciously crafted ExternalInfo containing non-numeric values for nftCreateChainId, can the long.TryParse fail silently and skip the chainId validation at line 26-27? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [SideChainCreator Race Condition] At lines 31-32, if State.SideChainCreator.Value is null, creation proceeds. Can an attacker exploit a race condition where SideChainCreator is set between the check and NFT creation, allowing creation on wrong chains? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [Owner Authorization Triple Check] At line 36, the assertion requires Context.Sender == owner && owner == input.Owner. If nftCollectionInfo.Owner is null but Issuer is set, can an attacker manipulate input.Owner to match the Issuer while sending from a different address, bypassing the triple equality check? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [SEED Collection Bypass] At line 37, special handling occurs for SeedCollectionSymbol. Can an attacker create a non-SEED collection with a symbol that partially matches SeedCollectionSymbol to bypass validation or gain SEED privileges? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [SEED Uniqueness Violation] At line 39, SEED must have decimals=0 and TotalSupply=1. Can an attacker race to create multiple SEED NFTs with the same ownedSymbol before the SymbolSeedMap is updated at line 51, violating uniqueness? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [OwnedSymbol Extraction Bypass] At lines 40-41, the code checks for SeedOwnedSymbolExternalInfoKey in ExternalInfo. If an attacker provides empty or whitespace-only ownedSymbol value, does the TryGetValue succeed but skip downstream validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [Expiration Time Manipulation] At lines 42-45, expirationTime is validated against Context.CurrentBlockTime. Can an attacker specify an expirationTime far in the future (e.g., year 9999) to indefinitely reserve an ownedSymbol, preventing others from claiming it? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [ExpirationTime Parsing Bypass] At line 44, if long.TryParse(expirationTime, out var expirationTimeLong) fails, the entire AND chain fails. Can an attacker provide non-numeric expirationTime to bypass time validation while still passing TryGetValue? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [SymbolType Validation Bypass] At lines 46-47, ownedSymbolType must not be SymbolType.Nft. Can an attacker specify an ownedSymbol formatted as an NFT (e.g., 'TOKEN-1') that GetSymbolType interprets as Token, bypassing the Nft check? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [CheckSymbolLength DOS] At line 48, CheckSymbolLength is called. Can an attacker provide extremely long ownedSymbol strings that pass TryGetValue but cause DOS during length validation? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [CheckTokenAndCollectionExists Race] At line 49, CheckTokenAndCollectionExists validates ownedSymbol. Can an attacker delete or modify the referenced token/collection between this check and SymbolSeedMap update at line 51, creating invalid mappings? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [CheckSymbolSeed Bypass] At line 50, CheckSymbolSeed is called. If this check fails but doesn't revert, can execution continue to line 51 where SymbolSeedMap is updated with invalid data? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [SymbolSeedMap Case Sensitivity] At line 51, ownedSymbol.ToUpper() is used as the key. Can an attacker create multiple SEED NFTs with different case variations (e.g., 'token', 'TOKEN', 'Token') that map to the same uppercase key, causing state overwrites? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CreateNFTInfo()] [CreateToken Return Bypass] At line 54, CreateToken returns Empty. If CreateToken internally reverts or returns error state without throwing, can CreateNFTInfo appear successful while leaving partial state updates? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CheckSymbolSeed()] [Case Sensitivity Bypass] At line 59, ownedSymbol.ToUpper() is used. If State.SymbolSeedMap was populated with mixed-case keys elsewhere, can an attacker bypass the oldSymbolSeed check by using different casing? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CheckSymbolSeed()] [GetTokenInfo Null Dereference] At lines 61-62, GetTokenInfo(oldSymbolSeed) is called. If oldSymbolSeed is not null but GetTokenInfo returns null, does the ExternalInfo.Value access cause null dereference instead of proper assertion? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CheckSymbolSeed()] [TryGetValue Boolean Confusion] At lines 62-63, !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value.TryGetValue(...) checks if the key doesn't exist. If TryGetValue returns false but the OR chain allows execution, can expired seeds be reused? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CheckSymbolSeed()] [Time Comparison Precision] At line 65, Context.CurrentBlockTime.Seconds > symbolSeedExpireTime. Can an attacker exploit sub-second timing to reuse seeds at exactly symbolSeedExpireTime seconds? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CheckSymbolSeed()] [Complex OR Logic Exploit] Lines 61-66 form a complex OR condition. If all sub-conditions pass individually but the assertion at line 66 fails to trigger, can an attacker bypass the 'OwnedSymbol has been created' check? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: CheckSymbolSeed()] [Long.TryParse DOS] At line 64, if oldSymbolSeedExpireTime contains malformed data (e.g., overflow values), can long.TryParse cause exceptions or unexpected behavior? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs] [Function: DoTransferFrom()] [Allowance Check Bypass via Whitelist] At lines 78-84, if IsInWhiteList returns true, DoTransfer executes without checking allowance. Can an attacker add themselves to the whitelist to transfer any NFT without approval? (Critical)"
]