[
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [ChangeMethodFeeController] [Controller Lock-Out] Can an attacker who temporarily gains controller access immediately change to a new organization controlled by themselves, permanently locking out the original Parliament governance from regaining control? (Critical)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [ChangeMethodFeeController] [Multi-Step Attack] Can an attacker first create a seemingly legitimate organization, wait for it to pass validation, change controller to it, then modify the organization's parameters in the authorization contract to gain unilateral control? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [SetMethodFee & ChangeMethodFeeController] [Governance Delay] Do method fee changes and controller changes take effect immediately without any timelock or delay, allowing malicious controllers to make sudden changes that harm users before they can react? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [RequiredMethodFeeControllerSet] [Default Organization Compromise] If Parliament's default organization is compromised before TokenHolderContract initialization, does the automatic defaultAuthority setting at lines 57-63 give attackers permanent control without any recovery mechanism? (Critical)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [All Authorization Checks] [Time-Of-Check-Time-Of-Use] Can authorization checks at lines 16 and 25 pass but the actual privileged operation execute later after the authorization state has changed, creating TOCTOU vulnerabilities? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [SetMethodFee] [State Overwrite Attack] Can an attacker repeatedly call SetMethodFee with the same method name but different fees, overwriting State.TransactionFees[input.MethodName] without any restriction on update frequency or versioning? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [SetMethodFee] [Orphaned State] If SetMethodFee is called for a method that gets removed from the contract in an upgrade, can orphaned fee configurations remain in State.TransactionFees consuming storage without being cleaned up? (Low)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [ChangeMethodFeeController] [Previous Controller Loss] When State.MethodFeeController.Value is overwritten at line 29, is there any mechanism to recover the previous controller if the new controller proves to be malicious or dysfunctional? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [All State Variables] [Storage Exhaustion] Can an attacker cause unbounded growth of State.TransactionFees by setting fees for arbitrarily many method names, exhausting contract storage and causing performance degradation? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [All State Variables] [State Corruption] If any state write operation (lines 17, 29, 55, 63, 82) fails partially due to transaction reversion, can the contract be left in an inconsistent state where some variables are updated but others are not? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [SetMethodFee] [Administrative DOS] Can an attacker who gains temporary controller access set fees for ChangeMethodFeeController itself so high that even Parliament cannot afford to remove the attacker, permanently locking in malicious control? (Critical)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [ChangeMethodFeeController] [Validation DOS] Can an attacker provide an authorityInfo.ContractAddress that always reverts or runs out of gas during ValidateOrganizationExist at line 73-75, preventing any legitimate controller changes? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [RequiredMethodFeeControllerSet] [Initialization DOS] If Context.GetContractAddressByName or GetDefaultOrganizationAddress calls fail during RequiredMethodFeeControllerSet, can the contract be permanently stuck in an uninitialized state where no methods requiring controller work? (Critical)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [AssertValidToken] [Token Validation DOS] Can an attacker set fees using a token symbol that causes IsTokenAvailableForMethodFee to consume excessive gas or revert, DOS'ing all future SetMethodFee operations for all tokens? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [All Functions] [Cross-Contract DOS] Can an attacker exploit the dependency on external contracts (Parliament, Token, Authorization) to DOS TokenHolderContract by making those contracts unavailable or expensive to call? (High)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs] [All Functions] [ACS1 Standard Compliance] Does the implementation fully comply with the ACS1 standard, or can deviations cause integration issues with other contracts expecting standard ACS1 behavior? (Medium)",
  "[File: contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_Transaction\n\n### Citations\n\n**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L1-90)\n```csharp\nusing AElf.Sdk.CSharp;\nusing AElf.Standards.ACS1;\nusing AElf.Standards.ACS3;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.TokenHolder;\n\npublic partial class TokenHolderContract\n{\n    public override Empty SetMethodFee(MethodFees input)\n    {\n        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);\n        RequiredMethodFeeControllerSet();\n\n        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress,"
]