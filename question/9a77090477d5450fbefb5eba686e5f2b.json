[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Issue()] [Supply Ceiling Bypass] After checking tokenInfo.Issued <= tokenInfo.TotalSupply at line 166, can Supply exceed TotalSupply through other operations before SetTokenInfo? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Issue()] [Memo Length DOS] If input.Memo is extremely long, can AssertValidMemo cause excessive gas consumption or storage bloat? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Transfer()] [Blacklist Bypass] Transfer doesn't check IsInTransferBlackListInternal for sender, can blacklisted addresses transfer tokens freely? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Transfer()] [Reentrancy in DealWithExternalInfoDuringTransfer] Can external contract called in DealWithExternalInfoDuringTransfer re-enter Transfer causing double-spending? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Transfer()] [Address Validation Missing] No validation on input.To - can tokens be burned by transferring to null or invalid address? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Transfer()] [Self-Transfer Exploit] Can attacker transfer to self repeatedly to manipulate event logs or trigger external info processing multiple times? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [Virtual Address Collision] Can attacker predict virtualAddress by controlling input.LockId to access other users' locked tokens? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [Allowance Bypass] If allowance check at line 204-206 passes with exact amount, can attacker lock more than approved by calling Lock multiple times? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [Authorization Confusion] Check at line 201 uses Context.Origin but virtual address computation uses input.Address - can this cause authorization bypass? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [Whitelist Bypass] IsInLockWhiteList check allows bypass if sender is in whitelist, but can malicious whitelist member lock anyone's tokens? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [LockId Reuse] If same LockId is used for multiple locks, can this overwrite existing locked balances causing fund loss? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [Zero Amount Lock] No minimum amount check - can attacker spam zero-amount locks to DOS the contract? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Lock()] [External Info Reentrancy] Can DealWithExternalInfoDuringLocking at line 213 re-enter Lock causing inconsistent locked state? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Unlock()] [Virtual Address Collision] Same virtualAddress computation as Lock - can attacker unlock others' funds by controlling LockId and sender combination? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Unlock()] [Double Unlock] If virtual address has exact balance, can attacker call Unlock multiple times in same transaction through reentrancy? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Unlock()] [Authorization Bypass] Same Context.Origin check issue - can contracts bypass the origin check to unlock user funds? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Unlock()] [SendVirtualInline Failure] If SendVirtualInline at line 236 fails but DealWithExternalInfoDuringUnlock succeeds, can this cause state inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Unlock()] [Amount Overflow] No check that unlock amount doesn't exceed locked amount - can this drain virtual address balance beyond user's locked funds? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: TransferFrom()] [Blacklist Bypass] No blacklist check for input.From - can blacklisted address funds be transferred via approved spender? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: TransferFrom()] [DealWithExternalInfo Missing] TransferFrom doesn't call DealWithExternalInfoDuringTransfer unlike Transfer - can this cause NFT metadata inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Approve()] [Allowance Overwrite] Approve directly sets allowance at line 273 without checking previous value - can this enable approval front-running attack? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Approve()] [Integer Overflow] No check on amount - can approving long.MaxValue cause overflow in allowance arithmetic? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: Approve()] [Zero Address Approval] AssertValidInputAddress checks spender but can approving zero address lock tokens? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: BatchApprove()] [DOS via Max Count] GetMaxBatchApproveCount check at line 286, but can attacker submit max count of approvals repeatedly to DOS contract? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs] [Function: BatchApprove()] [Last-Value-Wins Logic] GroupBy at line 293 takes Last() - can attacker manipulate ordering to override previous approvals in unexpected ways? (Low)"
]