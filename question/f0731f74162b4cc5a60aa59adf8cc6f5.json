[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [IsExtraBlockProducer Transfer] Can transferring IsExtraBlockProducer flag at line 334 allow evil miner's extra block privilege to be inherited without validation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [Dictionary Modification] Does Remove+Add pattern at lines 337-338 create race condition if another thread reads RealTimeMinersInformation simultaneously? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [IsMinerListJustChanged Flag] Does setting isMinerListChanged=true at line 341 propagate correctly to prevent stale miner checks? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs] [Function: GenerateNextRoundInformation()] [Round Generation Delegation] Can currentR\n\n### Citations\n\n**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L1-474)\n```csharp\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing AElf.Contracts.Election;\nusing AElf.CSharp.Core;\nusing AElf.CSharp.Core.Extension;\nusing AElf.Sdk.CSharp;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Consensus.AEDPoS;\n\n// ReSharper disable once InconsistentNaming\npublic partial class AEDPoSContract\n{\n    public override Int64Value GetCurrentRoundNumber(Empty input)\n    {\n        return new() { Value = State.CurrentRoundNumber.Value };\n    }\n\n    public override Round GetCurrentRoundInformation(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();\n    }\n\n    public override Round GetRoundInformation(Int64Value input)\n    {\n        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();\n    }\n\n    public override MinerList GetCurrentMinerList(Empty input)\n    {\n        return TryToGetCurrentRoundInformation(out var round)\n            ? new MinerList\n            {\n                Pubkeys =\n                {\n                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))\n                }\n            }\n            : new MinerList();\n    }\n\n    public override PubkeyList GetCurrentMinerPubkeyList(Empty input)\n    {\n        return new()\n        {\n            Pubkeys = { GetCurrentMinerList(input).Pubkeys.Select(p => p.ToHex()) }\n        };\n    }\n\n    public override MinerListWithRoundNumber GetCurrentMinerListWithRoundNumber(Empty input)\n    {\n        return new()\n        {\n            MinerList = GetCurrentMinerList(new Empty()),\n            RoundNumber = State.CurrentRoundNumber.Value\n        };\n    }\n\n    public override Round GetPreviousRoundInformation(Empty input)\n    {\n        return TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round();\n    }\n\n    public override MinerList GetMinerList(GetMinerListInput input)\n    {\n        return State.MinerListMap[input.TermNumber] ?? new MinerList();\n    }\n\n    public override Int64Value GetMinedBlocksOfPreviousTerm(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber))\n        {\n            var targetRound = State.FirstRoundNumberOfEachTerm[termNumber].Sub(1);\n            if (TryToGetRoundInformation(targetRound, out var round))\n                return new Int64Value { Value = round.GetMinedBlocks() };\n        }\n\n        return new Int64Value();\n    }\n\n    public override MinerList GetPreviousMinerList(Empty input)\n    {\n        if (TryToGetTermNumber(out var termNumber) && termNumber > 1)\n            return State.MinerListMap[termNumber.Sub(1)] ?? new MinerList();\n\n        return new MinerList();\n    }\n\n    public override StringValue GetNextMinerPubkey(Empty input)\n    {\n        if (TryToGetCurrentRoundInformation(out var round))\n            return new StringValue\n            {\n                Value = round.RealTimeMinersInformation.Values\n                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??\n                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey\n            };\n\n        return new StringValue();\n    }\n\n    /// <summary>\n    ///     Current implementation can be incorrect if all nodes recovering from\n    ///     a strike more than the time of one round, because it's impossible to\n    ///     infer a time slot in this situation.\n    /// </summary>\n    /// <param name="
]