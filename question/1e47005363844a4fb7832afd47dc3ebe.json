[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinedBlocks()] [Integer Overflow] Sum of ProducedBlocks across all miners could overflow long.MaxValue if attacker inflates individual miner counts - does overflow wrap to negative, breaking accounting? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinedBlocks()] [Negative Blocks] No validation that ProducedBlocks >= 0 for each miner - can attacker set negative values to deflate total count or underflow sum? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinedBlocks()] [DOS] Summing over thousands of miners without gas limit check - can attacker add excessive miners to make GetMinedBlocks() too expensive to call? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinerList()] [Invalid Hex] FromHexString() doesn't validate format - can attacker inject malformed hex string as pubkey, causing parsing exception when MinerList is used? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinerList()] [Duplicate Keys] RealTimeMinersInformation.Keys doesn't deduplicate - can attacker add same pubkey multiple times with different cases/formats to inflate miner list? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinerList()] [Empty Key] No validation that keys are non-empty - can empty string pubkeys corrupt MinerList? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMinerList()] [DOS] Converting all keys to ByteString without size limit - can attacker add millions of miners to exhaust memory/gas? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsInMinerList()] [Case Sensitivity] Dictionary.Keys.Contains() is case-sensitive for hex strings - can attacker bypass membership check using different casing of same pubkey? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsInMinerList()] [Null Input] No null check on pubkey parameter - does null input throw exception or return false, and can this be exploited? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstMiner()] [Multiple Order 1] FirstOrDefault() on m.Order == 1 returns arbitrary miner if multiple have Order 1 - can attacker inject duplicate Order 1 miners to cause non-deterministic selection? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstMiner()] [Empty Round] Returns new MinerInRound() if no Order 1 found - does empty miner with default values break callers expecting valid data? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstMiner()] [Unordered Dictionary] Values from Dictionary are unordered - if two miners have Order 1, FirstOrDefault() is non-deterministic across calls? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstActualMiner()] [Null Return] Returns null instead of empty MinerInRound like FirstMiner() - inconsistent null handling pattern could cause null reference errors? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstActualMiner()] [OutValue Manipulation] Filters on OutValue != null - can attacker submit invalid OutValue (non-null but garbage) to be selected as first actual miner, bypassing validation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstActualMiner()] [Multiple Actual Miners] FirstOrDefault() on unordered dictionary - if multiple miners have OutValue, selection is non-deterministic? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExpectedMiningTime()] [long.MaxValue Sentinel] Returns Timestamp with long.MaxValue seconds if publicKey not found - can callers safely handle this sentinel, or does it cause overflow in arithmetic? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExpectedMiningTime()] [Ambiguity] long.MaxValue is indistinguishable from legitimate far-future timestamp - can attacker set miner's ExpectedMiningTime to long.MaxValue to confuse not-found vs far-future? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExpectedMiningTime()] [Null Time] No check if ExpectedMiningTime is null for found miner - does returning null Timestamp crash callers? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningOrder()] [int.MaxValue Sentinel] Returns int.MaxValue if pubkey not in round - can callers distinguish this from legitimate Order = int.MaxValue set by attacker? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningOrder()] [Sentinel Overflow] If caller uses int.MaxValue order in arithmetic (e.g., order + 1), overflow wraps to int.MinValue - can this break order comparisons? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningOrder()] [Negative Orders] No validation that Order is positive - can attacker set negative Order to appear first while GetMiningOrder() returns it as-is? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Threshold Manipulation] Uses hardcoded AEDPoSContractConstants.TolerableMissedTimeSlotsCount - if attacker can manipulate MissedTimeSlots counter to stay just below threshold, can they avoid detection indefinitely? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Integer Overflow] MissedTimeSlots could overflow if incremented beyond long.MaxValue - does overflow reset count to negative, allowing evil miner to appear innocent? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Comparison Operator] Uses '>=' threshold - is boundary behavior correct? Can miner with exactly TolerableMissedTimeSlotsCount escapes be detected, or do they need TolerableMissedTimeSlotsCount+1? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Empty Pubkey] Filters by MissedTimeSlots but returns m.Pubkey without validation - can empty/null pubkey in result list cause issues in punishment logic? (Medium)"
]