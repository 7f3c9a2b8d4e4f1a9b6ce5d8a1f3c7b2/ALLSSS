[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [State Leak] The function modifies the Round object and returns 'this'. If the caller can access and further modify the returned Round object, can they bypass consensus rules by directly manipulating RealTimeMinersInformation after ApplyNormalConsensusData() returns? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [DoS] At lines 25-26, the LINQ query with Where() creates a list of all conflicts. If an attacker arranges for many miners to have the same FinalOrderOfNextRound, can this cause excessive memory allocation and performance degradation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [DoS] The nested loop at lines 28-40 iterates over conflicts (outer) and then searches from supposedOrderOfNextRound+1 to minersCount*2 (inner) while checking All() at line 34. If minersCount is large (e.g., 1000) and there are many conflicts, can this cause O(n^3) complexity and gas exhaustion? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [DoS] At line 34, RealTimeMinersInformation.Values.All() iterates through all miners for each maybeNewOrder candidate. If minersCount is 1000 and conflicts is 100, this could execute 100 * 1000 * 1000 = 100M iterations. Is there a gas limit check to prevent this attack? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Resource Exhaustion] If a malicious actor can add many entries to RealTimeMinersInformation before calling ApplyNormalConsensusData(), the LINQ operations at lines 25-26 and 34 could consume excessive gas. Is there a maximum miners count enforced? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Gas Griefing] Can a miner intentionally craft a signature value that produces a supposedOrderOfNextRound matching many existing FinalOrderOfNextRound values, forcing the conflict resolution to iterate through many miners and consuming excessive gas for subsequent callers? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Weak Randomness] At line 19, signature.ToInt64() converts the signature hash to a signed integer for order calculation. Can a miner grind signatures offline to find one that produces a favorable supposedOrderOfNextRound value, then submit only that signature? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Predictable Ordering] The supposedOrderOfNextRound calculation at line 21 is deterministic based on signature and minersCount. Can miners predict or manipulate their next-round position by choosing specific signature values during block production? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Front-Running] If the signature parameter at line 8 is publicly visible before ApplyNormalConsensusData() is called, can other miners see the resulting supposedOrderOfNextRound and delay their own submissions to avoid conflicts or gain better positions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Bias] The GetAbsModulus() call at line 21 uses absolute value of the modulus result. Does this introduce bias in the order distribution, making certain positions (e.g., order 1) more likely than others? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Signature Malleability] If the signature parameter can be crafted or manipulated by miners, can they repeatedly generate different valid signatures for the same block until one produces a desirable supposedOrderOfNextRound value? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Logic Error] At lines 28-40, the foreach loop processes conflicts sequentially. If the first conflict gets reassigned to order X, and the second conflict was already at order X, does the second conflict get properly reassigned or does it remain in conflict? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Edge Case] If all miners in RealTimeMinersInformation have the same FinalOrderOfNextRound value (massive conflict), the conflict resolution loop at lines 31-40 must find minersCount unique positions. If minersCount is large, can the algorithm fail to resolve all conflicts within the range [1, minersCount*2]? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Infinite Loop Risk] At lines 31-40, if the condition at line 34 never evaluates to true (all maybeNewOrder values are taken), does the loop exit gracefully without assigning a new order, and does this leave the conflicted miner in an invalid state? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Off-by-One] At line 31, the loop starts from supposedOrderOfNextRound + 1. If supposedOrderOfNextRound equals minersCount, then the first iteration checks minersCount + 1, which after the modulus at line 33 becomes 1. Is this intended, or does it skip checking some valid orders? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Corner Case] At line 33, when i equals minersCount exactly, the condition 'i > minersCount' is false, so maybeNewOrder = i = minersCount. But if miner orders should be in range [1, minersCount], this is valid. However, when i = minersCount + 1, maybeNewOrder = (minersCount+1) % minersCount. If minersCount = 5, this gives 1. Does this create overlap with order 1? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Transaction Ordering] If multiple miners call ApplyNormalConsensusData() in the same block with overlapping supposedOrderOfNextRound values, does the order of transaction execution affect the final FinalOrderOfNextRound assignments, potentially causing non-determinism? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Race Condition] If miner A calls ApplyNormalConsensusData() first and gets order 5, then miner B calls it and also calculates order 5, the conflict resolution moves A to order 6. If miner C then calls it and calculates order 6, does miner A get moved again, causing cascading reassignments? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Timing Attack] Can the last miner to call ApplyNormalConsensusData() in a round gain an advantage by seeing all other miners' FinalOrderOfNextRound values and choosing a signature that avoids conflicts? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Atomicity] Since the function modifies multiple fields (OutValue, Signature, PreviousInValue, SupposedOrderOfNextRound, FinalOrderOfNextRound) and performs conflict resolution that affects other miners, if an error occurs mid-execution, can partial state changes cause consensus corruption? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Signature Verification] Does the function verify that the signature parameter is a valid cryptographic signature created by the miner corresponding to pubkey, or can any arbitrary Hash value be passed as signature? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Hash Validation] At line 12, OutValue is directly assigned without verifying it's a valid hash or checking if it matches the expected cryptographic relationship with InValue. Can a miner submit an invalid OutValue to break the secret-sharing protocol? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [InValue Chain] At lines 14-16, PreviousInValue is accepted without validating it against the miner's OutValue from the previous round. Can a miner submit an incorrect PreviousInValue and break the verifiable delay function chain? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Replay Protection] Is there any check preventing a miner from replaying the same previousInValue, outValue, and signature from a previous round to manipulate the consensus state? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs] [Function: ApplyNormalConsensusData()] [Data Consistency] At line 36, FinalOrderOfNextRound is modified for a conflicted miner identified by orderConflictedMiner.Pubkey. If this pubkey is not properly validated or could be manipulated, can an attacker corrupt another miner's order assignment? (High)"
]