[
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Buy()] [Self-Transfer Check Missing] Can Context.Sender == Context.Self, allowing the contract to buy from itself and manipulate State.DepositBalance? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Buy()] [Virtual Balance Manipulation] After Buy() updates State.DepositBalance[fromConnector.Symbol], does this affect GetSelfBalance() calculations for future transactions? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Buy()] [Connector Purchase Check Timing] IsPurchaseEnabled is checked only for toConnector - if fromConnector is disabled after this check, can the transaction proceed? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Buy()] [Event Emission Race] TokenBought event is emitted after all state changes - can this cause indexers to miss transactions if they rely on event ordering? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Buy()] [Negative Amount Handling] Does BancorHelper.GetAmountToPayFromReturn() properly handle input.Amount that causes negative amountToPay due to precision errors? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Treasury Fee Bypass] When Context.Sender == TreasuryContract, fee is set to 0 - can an attacker route Sell() calls through Treasury to avoid fees? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Fee Subtraction Underflow] Can amountToReceive.Sub(fee) underflow if fee is calculated to be greater than amountToReceive due to rounding errors? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [ReceiveLimit Bypass] Similar to PayLimit in Buy(), can ReceiveLimit = 0 be exploited as 'no limit' check? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [DepositBalance Underflow] State.DepositBalance[toConnector.Symbol].Sub(amountToReceive) - can this underflow if DepositBalance is less than amountToReceive? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Transfer Before Balance Update] Token transfer to Context.Sender happens before State.DepositBalance is decremented - reentrancy risk? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Connector Relationship Mismatch] If fromConnector.RelatedSymbol doesn't match toConnector.Symbol, can mismatched connectors be used in Sell()? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Zero Fee Edge Case] When fee = 0 for Treasury, is HandleFee() still called? Does this waste gas or cause unexpected behavior? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Bancor Calculation Manipulation] Can GetReturnFromPaid() be manipulated by selling tiny amounts repeatedly to drain DepositBalance through rounding errors? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Double Connector Check] Both fromConnector.IsPurchaseEnabled and implicit toConnector existence are checked - can this create a state where only one direction works? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: Sell()] [Event Data Consistency] TokenSold event shows amountToReceive before fee deduction - can this mislead off-chain systems about actual received amounts? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Fee Division Rounding] fee.Div(2) for donateFee - does integer division always round down, causing burnFee to sometimes be 1 unit larger? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Odd Fee Amount] If fee is odd (e.g., 1), donateFee = 0 and burnFee = 1 - is this acceptable, or should minimum fee be 2? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [DividendPoolContract Initialization] State.DividendPoolContract.Value is initialized on first use - can this be exploited if TreasuryContract address changes? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Approval Race Condition] Approve() is called before Donate() - can another transaction consume the approval before Donate() executes? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [TransferFrom Triple Call] HandleFee() calls TransferFrom twice (for donate and burn) - can this lead to insufficient balance if the first transfer succeeds but second fails? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Burn After Transfer] Burn() is called on tokens already transferred to Context.Self - can this fail if contract balance is insufficient? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Donate Call Failure] If DividendPoolContract.Donate() fails, does the entire HandleFee() revert, or are tokens stuck in contract? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Approval Amount Not Reset] After Donate(), is the approval amount reset to 0? Leftover approvals could be exploited. (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: HandleFee()] [Fee Parameter Validation] HandleFee() doesn't validate that fee > 0 before proceeding - can fee = 0 cause unnecessary external calls? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs] [Function: SetFeeRate()] [Fee Rate Boundary] IsBetweenZeroAndOne() excludes 0 and 1 - but can '0.0000000001' or '0.9999999999' be exploited for near-zero or near-100% fees? (Medium)"
]