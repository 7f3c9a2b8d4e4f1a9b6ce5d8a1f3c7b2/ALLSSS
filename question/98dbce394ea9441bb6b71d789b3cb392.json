[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeUserFeeController()] [State Nullification Attack] At lines 75-76, the function sets State.UserFeeController.Value.ParliamentController and ReferendumController to null after setting RootController - can an attacker exploit this to bypass multi-signature requirements by changing to a controller they control and nullifying the multi-level approval structure? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeUserFeeController()] [Authorization Bypass] AssertUserFeeController() at line 72 checks that Context.Sender matches State.UserFeeController.Value.RootController.OwnerAddress - but after this function executes and nullifies ParliamentController/ReferendumController, can subsequent operations that rely on those controllers fail or be bypassed? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeUserFeeController()] [Multi-Level Governance Bypass] The default UserFeeController has a three-tier structure (Parliament->Referendum->Association) requiring unanimous approval, but this function allows replacing it with a single-tier controller by setting RootController directly - can governance requirements be circumvented? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeUserFeeController()] [Weak Validation] CheckOrganizationExist(input) at line 73 doesn't verify that the new RootController maintains the same security properties (threshold requirements, member composition) as the original multi-tier structure - can security be downgraded? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeUserFeeController()] [User Fee Manipulation] If an attacker successfully changes the UserFeeController to one they control, can they modify user fee parameters to extract value from all token transactions on the network? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeUserFeeController()] [State Consistency] After setting ParliamentController and ReferendumController to null, do other contract functions that read these values handle nulls correctly, or will they cause exceptions/reverts? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeDeveloperController()] [State Nullification Attack] Lines 85-86 set State.DeveloperFeeController.Value.ParliamentController and DeveloperController to null after changing RootController - can an attacker exploit this to eliminate the two-tier approval structure (Developer + Parliament) and gain unilateral control over developer fee collection? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeDeveloperController()] [Authorization Bypass] AssertDeveloperFeeController() at line 82 checks RootController ownership, but after nullifying ParliamentController and DeveloperController, can the attacker bypass checks that depend on those sub-controllers? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeDeveloperController()] [Developer Fee Extraction] If an attacker gains control of DeveloperFeeController, can they redirect all developer fees (typically paid by smart contract method callers) to their own addresses? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeDeveloperController()] [Governance Downgrade] The default structure requires both DeveloperController (association) and ParliamentController approval, but changing to a single RootController removes this dual-approval requirement - is this intentional or a security weakness? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeDeveloperController()] [Weak Validation] CheckOrganizationExist(input) at line 83 doesn't validate minimum security requirements for the new controller - can it be set to a trivial organization with MinimalApprovalThreshold = 1 and a single attacker-controlled member? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeTransferBlackListController()] [Centralized Authorization] Line 92 uses AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress), meaning only parliament can change this controller - but if parliament is compromised or colluding, can they set a blacklist controller that freezes arbitrary user accounts? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeTransferBlackListController()] [Weak Validation] CheckOrganizationExist(input) at line 93 doesn't validate that the new controller has appropriate checks and balances - can parliament set a single-address controller that can blacklist any user without oversight? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeTransferBlackListController()] [Censorship Attack] If an attacker compromises parliament and changes TransferBlackListController to themselves, can they blacklist all major token holders or specific users to manipulate token markets? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeTransferBlackListController()] [DOS Attack] Can an attacker use the blacklist functionality to freeze token transfers for critical system contracts (Treasury, Profit, Election), effectively halting the entire blockchain's economic operations? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: ChangeTransferBlackListController()] [No Event Emission] The function doesn't emit an event when changing the blacklist controller - can malicious changes go unnoticed until users start getting their transfers blocked? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetReferendumControllerCreateInputForUserFee()] [Weak Threshold] Lines 143-148 set MinimalApprovalThreshold and MinimalVoteThreshold to only 1, with MaximalRejectionThreshold and MaximalAbstentionThreshold at 0 - can a single referendum voter (parliament) approve any user fee change without broader community consensus? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetReferendumControllerCreateInputForUserFee()] [Whitelist Restriction] Lines 150-152 only allow parliamentAddress in the ProposerWhiteList - does this mean only parliament can create proposals for this referendum, effectively making it a parliament-controlled organization disguised as a referendum? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetReferendumControllerCreateInputForUserFee()] [Token Symbol Dependency] Line 137 gets the primary token symbol via GetPrimaryTokenSymbol() - if this returns an invalid or manipulated symbol, can the referendum organization be created with incorrect voting token requirements? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetReferendumControllerCreateInputForUserFee()] [Single Point of Failure] With ProposerWhiteList containing only parliamentAddress and thresholds at 1, this referendum organization provides no additional security beyond parliament - is this intentional centralization or a design flaw? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetReferendumControllerCreateInputForUserFee()] [Referendum Bypass] Since MinimalApprovalThreshold is only 1 and parliament is the only proposer, can parliament unilaterally change user fees without any actual referendum voting by other token holders? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForUserFee()] [Unanimous Approval Required] Lines 172-173 set MinimalApprovalThreshold and MinimalVoteThreshold to proposers.Count (2: referendum + parliament) - while this requires unanimous approval, if an attacker compromises referendum or parliament, can they block all user fee changes indefinitely? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForUserFee()] [DOS via Veto] With MaximalRejectionThreshold and MaximalAbstentionThreshold at 0, a single disapproval or abstention blocks the proposal - can one compromised organization DOS all user fee governance? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForUserFee()] [Member List Validation] Lines 167-169 set OrganizationMembers to referendumAddress and parliamentAddress, but doesn't validate these are actual organization addresses - can invalid addresses be added as members, breaking the approval logic? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForUserFee()] [Proposer Whitelist] Lines 178-181 restrict proposers to referendum and parliament only - if both are compromised, can they collude to rapidly approve malicious user fee changes? (High)"
]