[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [Merkle Path Manipulation] Line 243 accepts MerklePath without validation - can attacker supply empty or malformed path that passes verification due to CrossChain contract bug? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [Parent Chain Height] Line 240 accepts parentChainHeight - can attacker supply future height that hasn't been indexed yet, causing verification to fail or succeed incorrectly? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertCrossChainTransaction()] [Method Name Whitelist] Line 219 checks if methodName is in validMethodNames array - can attacker exploit case sensitivity or whitespace to call unauthorized methods? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertCrossChainTransaction()] [Transaction To Check] Line 220 validates originalTransaction.To == validAddress - can attacker create transaction with To = validAddress but different From to bypass authorization? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertCrossChainTransaction()] [Params Array Variadic] Line 217 accepts 'params string[] validMethodNames' - can empty array cause all transactions to fail validation, enabling DoS? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ExtractTokenContractAddress()] [Parser Exception Handling] Line 207 calls Parser.ParseFrom without try-catch - can malformed bytes cause unhandled exception that crashes contract or leaves it in inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ExtractTokenContractAddress()] [Hash Name Validation] Line 211 checks validatedContractHashName equals TokenContractSystemHashName - can attacker brute-force hash collision to validate arbitrary address as token contract? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ExtractTokenContractAddress()] [Address Trust] Line 208 extracts validatedAddress from input without additional verification - can this address be used in privileged operations without proper authorization? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: RegisterTokenInfo()] [Case Insensitive Duplicate Check] Line 233 stores State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] but line 226 validates IsValidSymbol(tokenInfo.Symbol) - can 'TOKEN' and 'token' both be registered as different tokens? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: RegisterTokenInfo()] [Total Supply Validation] Line 229 only checks 'TotalSupply > 0' - can attacker set TotalSupply to long.MaxValue causing overflow when tokens are minted? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: RegisterTokenInfo()] [Token Name Empty Check] Line 228 checks '!string.IsNullOrEmpty(tokenInfo.TokenName)' but doesn't validate length - can extremely long token name cause storage DoS? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: RegisterTokenInfo()] [Issuer vs Owner] Lines 230-231 check both Issuer and Owner are non-null but don't validate they're different - can same address be both, enabling single point of failure? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: RegisterTokenInfo()] [State Write Order] Line 232 writes TokenInfos before line 233 writes InsensitiveTokenExisting - can transaction fail between these causing inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidCreateInput()] [Decimals Range] Line 277 checks 'Decimals <= TokenContractConstants.MaxDecimals' - what is MaxDecimals value? Can extreme decimal values (e.g., 255) cause precision loss or overflow in amount calculations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidCreateInput()] [Symbol Length Check Call] Line 279 calls CheckSymbolLength with symbolType - can attacker pass wrong symbolType to bypass length restrictions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidCreateInput()] [Conditional Validation] Lines 280-282 skip checks for NFT symbolType - can attacker exploit this to create NFTs without token/collection existence validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidCreateInput()] [Whitelist Bypass] Line 282 only calls CheckSymbolSeed if sender is in CreateWhiteList - can non-whitelisted addresses create tokens with unseeded symbols? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckTokenAndCollectionExists()] [Split Without Validation] Line 287 splits symbol by NFTSymbolSeparator without checking split result length - can empty string splits cause index out of bounds? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckTokenAndCollectionExists()] [Collection Symbol Construction] Lines 290-291 construct collectionSymbol by appending '-0' - can this collide with existing token symbols? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckTokenExists()] [Empty Object Comparison] Line 298 compares 'existing == null || existing.Equals(empty)' where empty is new TokenInfo() - does Equals() properly handle all fields or can partial match bypass check? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckTokenExists()] [Case Sensitivity Mismatch] Line 302 checks 'InsensitiveTokenExisting[symbol.ToUpper()]' but existing token might be stored case-sensitive - can this allow duplicate tokens with different cases? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckSymbolLength()] [Conditional Length Check] Lines 307-310 check different lengths based on symbolType - can attacker supply wrong symbolType to bypass stricter length limit? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckCrossChainTokenContractRegistrationControllerAuthority()] [Lazy Controller Init] Lines 315-317 initialize controller if null - can race condition during initialization allow unauthorized modification? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CheckCrossChainTokenContractRegistrationControllerAuthority()] [OwnerAddress Check Only] Line 318 only checks OwnerAddress == Context.Sender - can attacker manipulate Context or controller OwnerAddress to bypass this? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DealWithExternalInfoDuringLocking()] [Reentrancy via SendInline] Line 331 calls Context.SendInline with callback address - can malicious token with callback reenter and modify state before lock completes? (Critical)"
]