[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayResourceTokens()] [Owning Debt Accumulation] At line 972-974, owned amount is calculated and added to existing owning - can this debt grow indefinitely without repayment mechanism, eventually exceeding long capacity? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayResourceTokens()] [Balance Check Bypass] At line 970, if amount > existingBalance, the amount is reduced to existingBalance at line 981 - can contracts exploit this to accumulate owing debt instead of maintaining sufficient balance? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayResourceTokens()] [Main vs Side Chain Logic] Lines 988-1006 have different logic for main chain (donate to dividend pool) vs side chain (transfer to consensus contract) - can chain type be manipulated to redirect funds? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Creator Null Check Missing] At line 1021-1022, function returns if creator is null - but should this be an assertion since rental system requires a creator? Can null creator cause side chain to skip rental forever? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Time Calculation Precision] At line 1031, duration is calculated as seconds / 60 to get minutes - does integer division truncate seconds, causing loss of rental charges over time? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Time Manipulation] Line 1038 updates LastPayRentTime by adding duration * 60 seconds - if Context.CurrentBlockTime is manipulated backwards, can this cause negative duration and rental refund? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Owning Rental Underflow] At line 1053-1057, if availableBalance > owningRental, donates is set to owningRental and owningRental is set to 0 - but if concurrent PayRental calls occur, can owningRental go negative? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Rental Calculation Overflow] At line 1061, rental = duration * ResourceAmount * Rental - if duration is very large (skipped blocks) or amounts are high, can this multiply operation overflow? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Balance Reset vs ModifyBalance] At line 1071, balance is directly set to 0 instead of using ModifyBalance - can this bypass balance modification hooks and cause accounting inconsistency? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Debt Accumulation Unbounded] At line 1075, new debt is added to existing OwningRental - is there a cap? Can this grow to MAX_LONG over time and cause future arithmetic overflow? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: UpdateRental()] [Zero/Negative Rental] Line 1107 only asserts pair.Value >= 0 - can rental be set to 0 to make side chain free, or does setting to 0 have special meaning that's not handled? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: UpdateRentedResources()] [Resource Amount Zero] Similar to rental at line 1122, can ResourceAmount be set to 0 and combined with non-zero Rental cause rental calculation at line 1061 to always be 0? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ClaimTransactionFees()] [Height Check Race] At line 872-873, checks claimTransactionExecuteHeight < Context.CurrentHeight - can two miners in consecutive blocks both pass this check and claim fees twice? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ClaimTransactionFees()] [Height Update Timing] Line 874 updates height to CurrentHeight before processing - if processing fails/reverts, is height still updated, preventing future claims? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ClaimTransactionFees()] [Hash Collision] At line 876, LatestTotalTransactionFeesMapHash is computed from input - can attacker craft two different inputs with same hash to bypass duplicate claim detection? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ClaimTransactionFees()] [Self-Transfer Logic] At line 881, ModifyBalance adds amount to Context.Self (token contract) - but then line 889 calls TransferTransactionFeesToFeeReceiver which may transfer/burn - is self-balance properly tracked? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TransferTransactionFeesToFeeReceiver()] [Burn Calculation] At line 1162, burnAmount = totalAmount / 10 using integer division - does this cause rounding loss? If totalAmount is 9, does burnAmount become 0 and all goes to transfer? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TransferTransactionFeesToFeeReceiver()] [Non-Burnable Token Bypass] Lines 1157-1160 return early if token is not burnable - does this mean non-burnable tokens skip fee distribution entirely and accumulate in contract? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TransferTransactionFeesToFeeReceiver()] [SendInline Reentrancy] At line 1164 and 1193, Context.SendInline is called to same contract (Context.Self) for Burn/Transfer - can this cause reentrancy if those methods call back to fee functions? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TransferTransactionFeesToFeeReceiver()] [Allowance Manipulation] At line 1181-1182, allowance is directly modified for dividend pool transfer - can this bypass normal approval mechanisms and violate token approval invariants? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TransferTransactionFeesToFeeReceiver()] [Side Chain Fee Receiver Null] At line 1191-1208, if FeeReceiver is null on side chain, all transfer amount is burned instead - can side chain creator intentionally keep FeeReceiver null to burn all fees instead of receiving them? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetSymbolsToPayTxSizeFee()] [Primary Token Weight Validation] Lines 630-632 assert primary token weight must be 1:1 - but if weight is validated before checking symbol is primary at line 627-632, can non-primary symbol with 1:1 weight pass? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetSymbolsToPayTxSizeFee()] [Weight Zero Check] Line 634-635 checks weights > 0 - but if weight is MAX_LONG, can arithmetic operations overflow when converting fees at line 403-404? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetSymbolsToPayTxSizeFee()] [Duplicate Detection Timing] Line 636-637 checks if symbol is already in symbolList - but list is built during loop, so first occurrence isn't detected as duplicate, only second+ occurrences? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetSymbolsToPayTxSizeFee()] [Symbol Validation Side Effects] Line 638 calls AssertSymbolToPayTxFeeIsValid with out parameter addedTokenTotalSupply but never uses it - is this parameter meant to enforce minimum supply requirements that's not implemented? (Low)"
]