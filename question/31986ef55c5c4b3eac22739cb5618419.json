[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Authorization Bypass] Can an attacker bypass the PreCheck() authorization if the function returns false but execution continues due to the Assert(false, 'No permission.') allowing transaction success with no state changes, enabling DoS through repeated failed transactions that consume gas and clog the mempool? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Race Condition] If EnsureTransactionOnlyExecutedOnceInOneBlock() fails to prevent double execution due to concurrent transactions in the same block, can multiple consensus updates corrupt round state by processing NextRoundInput and UpdateValueInput simultaneously? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [State Corruption] If State.RoundBeforeLatestExecution.Value is set to current round information before processing but processing fails midway, does this leave stale 'before' state that breaks future round comparisons and LIB calculations? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Random Number Manipulation] Can an attacker craft a malicious randomNumber ByteString that passes Context.ECVrfVerify() but creates a predictable or manipulable randomHash, allowing them to influence consensus outcomes or miner selection in future rounds? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Input Validation] Since the dynamic input parameter accepts NextRoundInput, NextTermInput, UpdateValueInput, or TinyBlockInput without type validation before the switch statement, can an attacker pass a crafted object of an unexpected type to bypass all case handlers and skip critical consensus processing? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [VRF Verification Bypass] If Context.ECVrfVerify() always returns true for certain edge case inputs (e.g., empty beta output), can an attacker submit consensus information with arbitrary randomNumber values that don't maintain cryptographic randomness, breaking consensus security? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Previous Random Hash Manipulation] Since previousRandomHash is retrieved from State.RandomHashes[Context.CurrentHeight.Sub(1)] and defaults to Hash.Empty if null, can the first block or blocks after state corruption use Hash.Empty as verification input, weakening random number verification? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Side Chain Release Attack] If !State.IsMainChain.Value is true and currentRound.RoundNumber > 1, Release() is called unconditionally. Can an attacker on a side chain trigger excessive Release() calls in every consensus transaction to drain side chain resources or manipulate release schedules? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Cache Poisoning] If _processingBlockMinerPubkey is set during PreCheck() but not cleared properly when an exception occurs before line 86, can stale miner pubkey data from a failed transaction affect the next transaction's authorization check? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Event Flooding] The MiningInformationUpdated event is fired on every consensus transaction. Can an attacker who is an authorized miner spam consensus transactions to flood event logs and cause DoS for event-listening applications or indexers? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Maximum Blocks Count Manipulation] Since GetMaximumBlocksCount() is called for every consensus behavior to reset tiny blocks count, can an attacker manipulate the returned value through external configuration changes to break the tiny block limiting mechanism? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation()] [Random Hash State Overflow] State.RandomHashes[Context.CurrentHeight] is set without bounds checking. Over many blocks, can this mapping grow unbounded and cause state bloat DoS, or can an attacker deliberately trigger round transitions at extreme heights to exhaust storage? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: GetLatestSignature()] [Null Signature Attack] If all miners in currentRound have null signatures and TryToGetPreviousRoundInformation() returns a previousRound where all miners also have null signatures, the function returns null. Can this null signature be used as previousRandomHash to weaken VRF verification? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: GetLatestSignature()] [Order Manipulation] The function uses OrderBy(m => m.Order).LastOrDefault() to get the latest signature. If an attacker manipulates miner order values during round generation, can they control which miner's signature is selected as the 'latest', potentially choosing a compromised or predictable signature? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: GetLatestSignature()] [Signature Selection Bias] Since the function prefers currentRound signatures over previousRound, can an attacker who controls the first miner in the current round always override the selection by providing their signature early, biasing random number generation toward their chosen values? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Evil Miner Detection Bypass] The function only detects evil miners on Main Chain (State.IsMainChain.Value). Can malicious miners on side chains freely skip time slots without punishment, corrupting side chain consensus and breaking cross-chain synchronization? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Blockchain Start Timestamp Manipulation] During the first round transition (currentRound.RoundNumber == 1), actualBlockchainStartTimestamp is set based on the first miner's ActualMiningTimes or Context.CurrentBlockTime. Can the first miner delay their mining to manipulate this timestamp and affect all future time-based consensus calculations? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Miners Count Zero Attack] If GetMinersCount(nextRound) returns 0 during first round setup, the UpdateMinersCount message is not sent to ElectionContract. Can this leave the election contract in an inconsistent state where miner count is never initialized, breaking election logic? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Evil Miner Marking DoS] For each detected evil miner, UpdateCandidateInformation is sent to ElectionContract with IsEvilNode = true. If an attacker causes many miners to appear evil (e.g., through network disruption), can the gas cost of these cross-contract calls cause the round transition to fail or become too expensive? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Round Number Update Failure] The function Asserts that TryToUpdateRoundNumber(nextRound.RoundNumber) succeeds. If this fails due to state corruption or race conditions, the entire transaction reverts but AddRoundInformation(nextRound) has already been called. Can this create orphaned round data that breaks future round lookups? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Mined Miner List Recording Race] RecordMinedMinerListOfCurrentRound() is called before processing nextRound. If currentRound state changes between recording and nextRound activation, can this create mismatches where recorded mined miners don't reflect actual block production? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound()] [Election Contract Null Pointer] The code checks State.ElectionContract.Value != null before calling UpdateMinersCount. But if ElectionContract becomes null between the check and the Send call due to concurrent state changes, can this cause an unhandled exception that breaks consensus? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Term Number Race Condition] TryToGetTermNumber() retrieves the current term number before any updates. If multiple ProcessNextTerm calls execute concurrently, can they all retrieve the same term number and cause Treasury release to be triggered multiple times for the same term, draining treasury funds? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Miners Count Update Bypass] UpdateMinersCountToElectionContract(nextRound) is called without checking if State.ElectionContract.Value is null. Can this cause an unhandled null reference exception during term transitions if the election contract is not initialized? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Missed Time Slots Reset Exploit] The function resets MissedTimeSlots and ProducedBlocks to 0 for all miners in the next term. Can malicious miners who accumulated many missed slots in the previous term avoid punishment by timing their term transition, effectively clearing their poor performance record? (High)"
]