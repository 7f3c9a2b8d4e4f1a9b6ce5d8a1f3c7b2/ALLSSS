[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation() + GetMinedMiners()] [Missing Miner Gap] If GetMinedMiners and GetNotMinedMiners together don't cover all RealTimeMinersInformation entries (miner missing from both), could that miner be excluded from nextRound, reducing miner count and breaking quorum assumptions? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation() + CalculateNextExtraBlockProducerOrder()] [Order Out of Bounds] If CalculateNextExtraBlockProducerOrder returns order > minersCount at line 59, line 61's FirstOrDefault returns null, causing line 63 to set .First() as extra block producer - could this skip intended random selection? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation() + BreakContinuousMining()] [State Inconsistency After Swap] If BreakContinuousMining swaps orders at line 67 but GenerateNextRoundInformation previously set ExpectedMiningTime based on original orders at lines 33/51, could timestamps become misaligned with final orders? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining() + GetExtraBlockProducerInformation()] [Undefined Extra Producer] If GetExtraBlockProducerInformation at lines 80 and 97 returns null or default MinerInRound, could Pubkey comparison at lines 81 and 98 always fail, never triggering swaps and allowing continuous mining? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: All Functions] [RealTimeMinersInformation Concurrent Modification] If RealTimeMinersInformation is modified externally while GenerateNextRoundInformation executes (lines 16-56), could GetMinedMiners/GetNotMinedMiners return stale data leading to inconsistent nextRound state? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Maximum Miners Scenario] If minersCount at line 18 is at maximum allowed value and all miners mined, could occupiedOrders at line 40 fill entire range [1, minersCount], leaving ableOrders empty at line 41 and causing line 44 to access out-of-bounds when minersNotMinedCurrentRound is non-empty? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Two Miners Only] With minersCount=2, if first miner is extra block producer of current round at line 81, swap makes second become first - but if second is also extra producer of next round at line 98, another swap occurs - could this create deadlock or circular dependency? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [All Miners Missed] If all miners have SupposedOrderOfNextRound == 0, minersMinedCurrentRound is empty at line 16, occupiedOrders is empty at line 40, and all miners get sequential ableOrders starting from 1 - could this reset mining order unfairly without considering previous performance? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Single Block Mining Interval] If GetMiningInterval returns 1 millisecond at line 20, all ExpectedMiningTime values at lines 33/51 would be within 1ms * minersCount - could this cause timestamp collisions or make it impossible for miners to meet their slots? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [All Miners Same Signature] If all miners produce identical signatures due to cryptographic collision or bug, GetAbsModulus would always return same value at line 121, always selecting same extra block producer - could this centralize rewards? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Three Miners Edge Case] With minersCount=3, if miner at order 1 is extra producer of current, swap makes order 2 become order 1 - but if order 3 is extra producer of next, swap makes order 2 (now at order 3) become order 2 again - could this create invalid state? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Negative MissedTimeSlots] If MissedTimeSlots at line 54 is negative before .Add(1), could it remain negative after increment, corrupting penalty calculations and allowing miners to bypass punishment? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Pubkey Null or Empty] If a miner's Pubkey at lines 29/46 is null or empty string, could dictionary assignment create invalid entries or overwrite legitimate miners, reducing effective miner count? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [FinalOrderOfNextRound Larger Than MinerCount] If FinalOrderOfNextRound at line 28 is 1000 but minersCount is 10, occupiedOrders would contain 1000, and ableOrders range [1,10] would exclude it - but this creates invalid order in nextRound at line 32, could this break order-based logic? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [RoundNumber Rollback] If RoundNumber at line 21 is less than previous rounds due to blockchain re-org, incrementing could create nextRound with RoundNumber that already exists, allowing replay attacks or state confusion? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [TermNumber Mismatch] Line 22 copies TermNumber without validating it matches current term - if TermNumber is from previous term, could nextRound have incorrect term assignment, breaking term-based rewards or governance? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [ExpectedMiningTime Past Value] If currentBlockTimestamp at line 11 is in past relative to system time, all ExpectedMiningTime values at lines 33/51 would be past timestamps - could this cause all miners to claim they missed their slots? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Signature Length Validation] Line 118 uses signature.ToInt64() without validating signature length - if signature is less than 8 bytes, could ToInt64() fail or produce unpredictable results, causing non-deterministic extra block producer? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Large Miner Count DOS] If minersCount at line 18 is extremely large (e.g., 10,000), loops at lines 26-36 and 42-56 could cause gas exhaustion or timeout, preventing round generation and halting consensus? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [OrderBy Performance] Line 26 sorts minersMinedCurrentRound by FinalOrderOfNextRound - if an attacker adds many miners with carefully crafted orders, could sorting complexity cause DOS during round generation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Where Filter Overhead] Line 41 filters entire range [1, minersCount] - if minersCount is 100,000 and occupiedOrders contains 99,999 elements, could Where operation cause significant computational overhead and DOS? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Multiple First() Calls] Lines 79, 84, 94, 101 each call First() which iterates through RealTimeMinersInformation.Values - with large miner count, could multiple iterations cause performance degradation and slow round generation? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [OrderBy Without Limit] Line 112-113 sorts all miners by order then filters - if RealTimeMinersInformation contains thousands of miners, could sorting overhead delay extra block producer selection? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Signature Predictability] Using first miner's signature at line 118 for randomness - if first miner can predict their signature (due to deterministic signing), could they choose when to mine based on desired extra block producer outcome? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Modulo Bias] Line 121 uses GetAbsModulus(sigNum, blockProducerCount) - if blockProducerCount doesn't evenly divide signature space, could certain orders be selected more frequently, creating unfair extra block producer distribution? (Medium)"
]