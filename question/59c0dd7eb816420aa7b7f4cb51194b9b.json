[
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightInterest()] [Day Overflow] At line 197, only checks info.Day > 0, with no upper bound. Could setting Day to max int32 cause overflow issues when calculating lockDays.Div(DaySec) or in comparison logic at line 581? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightInterest()] [Duplicate Day Check Bypass] At line 201, checks for duplicate Day values using GroupBy. However, if two VoteWeightInterest entries have Days that differ by 1 but both match the same vote duration due to rounding, could this cause ambiguous weight calculations? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightInterest()] [Retroactive Application] The function allows changing VoteWeightInterestList at any time, but existing votes use weights calculated at vote time. Could changing this retroactively benefit new voters over existing voters, violating fairness? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightInterest()] [OrderBy Manipulation] At line 203, orderList is sorted by Day. If the input already has specific ordering that affects business logic, could sorting break assumptions about interest tier precedence? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightProportion()] [Proportion Overflow] At line 213, only checks TimeProportion > 0 and AmountProportion > 0, but no upper bounds. At line 585, votesAmount.Mul(AmountProportion).Div(TimeProportion) is calculated. Could extreme proportions cause overflow? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightProportion()] [Zero Division Risk] If TimeProportion is set to a very small value like 1 while AmountProportion is max int32, the division at line 585 could cause dramatic weight inflation. Should there be ratio bounds? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVoteWeightInterestController()] [Controller Takeover] At line 220, AssertPerformedByVoteWeightInterestController checks current controller, then line 222 changes it. Could a malicious controller change to an address they control, then immediately set malicious VoteWeightInterest parameters? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVoteWeightInterestController()] [CheckOrganizationExist Validation] At line 221, CheckOrganizationExist validates the authority. But if this only checks contract existence without verifying it's a valid governance organization, could arbitrary addresses be set as controller? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: UnlockTokensOfVoter()] [Address Override Risk] At line 274, voterAddress ?? Context.Sender is used. If voterAddress is provided by a caller function incorrectly, could tokens be unlocked to the wrong address? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: UnlockTokensOfVoter()] [Lock ID Collision] At line 277, LockId = input (voteId). If voteId collides with another lock ID in the TokenContract, could unlocking affect unrelated locked tokens? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Ector.cs] [Function: RetrieveTokensFromVoter()] [Double Token Retrieval] At lines 284-293, both ShareSymbol and VoteSymbol tokens are transferred from voter. If the voter doesn't have sufficient balance of one symbol, does TransferFrom fail or partial succeed, leaving inconsistent token states? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: RetrieveTokensFromVoter()] [TransferFrom Allowance] TransferFrom at line 286 requires prior approval. If the voter never approved the ElectionContract to spend their SHARE/VOTE tokens, does this silently fail or revert the entire operation? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: RemoveBeneficiaryOfVoter()] [Beneficiary Not Found] If RemoveBeneficiary is called for a voter who was never added as beneficiary (e.g., due to prior error), does the ProfitContract silently ignore this or throw, potentially DOS'ing legitimate withdrawals? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: LockTokensOfVoter()] [Lock ID Reuse] At line 334, LockId is set to voteId. If voteId is reused (due to hash collision or GenerateVoteId logic flaw), could this cause lock state corruption in TokenContract? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: LockTokensOfVoter()] [Insufficient Balance] If Context.Sender doesn't have sufficient NativeSymbol balance (line 333), does the Lock operation fail gracefully or leave the vote in partially created state? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: TransferTokensToVoter()] [Election Contract Balance] At lines 346-354, SHARE and VOTE tokens are transferred from Context.Self (ElectionContract) to voter. If the ElectionContract doesn't have sufficient balance of these tokens, could vote creation fail after locks are already applied? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: TransferTokensToVoter()] [Token Symbol Hardcoding] ShareSymbol and VoteSymbol are hardcoded constants. If these tokens don't exist or have different symbols in deployment, does this cause all votes to fail? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: CallVoteContractVote()] [Vote Contract State] If VoteContract.Vote at line 359 fails after tokens are locked and transferred (in Vote function call flow), are tokens permanently locked without vote records? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: AddBeneficiaryToVoter()] [EndPeriod Calculation] At line 379, GetEndPeriod(lockSeconds) is called. If GetEndPeriod returns a period that's already past (e.g., due to CurrentPeriod overflow), could the beneficiary never receive welfare profits? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: AddBeneficiaryToVoter()] [Shares Overflow] At line 377, Shares = votesWeight. If votesWeight is calculated to be extremely large (via GetVotesWeight with malicious parameters), could this cause overflow in profit distribution calculations? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: AddBeneficiaryToVoter()] [Duplicate Beneficiary] If AddBeneficiary is called twice for the same voter with the same voteId, does ProfitContract properly handle duplicate additions or could shares be double-counted? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GenerateVoteId()] [Token Parameter Manipulation] At lines 404-405, if voteMinerInput.Token is not null, voteId is Context.GenerateId(Context.Self, voteMinerInput.Token). Could an attacker provide a malicious Token value to create predictable or colliding voteIds? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GenerateVoteId()] [Vote ID Collision] At lines 407-411, voteId is generated from CandidatePubkey and candidateVotesCount. If two voters vote for the same candidate at the exact same candidateVotesCount, could voteIds collide? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GenerateVoteId()] [Null Candidate Votes] At line 408, State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0. If CandidateVotes is null, candidateVotesCount is 0. Could this cause vote ID collisions for first votes to different candidates? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: Vote()] [Negative Lock Duration] At line 429, lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds. If input.EndTimestamp is in the past, lockSeconds could be negative. Does AssertValidLockSeconds at line 430 catch this? (High)"
]