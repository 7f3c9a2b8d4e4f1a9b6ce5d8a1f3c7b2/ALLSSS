[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Duplicate Detection] If input.DelegateInfoList contains duplicate contract-method pairs, how is this handled? Can it cause unexpected overwrites or state corruption? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: SetTransactionFeeDelegateInfos()] [Delegatee Count Limit] The check at line 226 enforces DELEGATEE_MAX_COUNT per contract-method combination, but is there a global limit per delegator across all contract-method pairs? Can this be exploited for storage DoS? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: AddDelegateInfo()] [Logic Inconsistency] At lines 255-262, when IsUnlimitedDelegate is false, delegations are added, but when true, no delegations are added. At line 264, IsUnlimitedDelegate flag is set. Can a delegatee toggle between limited and unlimited to bypass delegation tracking? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: AddDelegateInfo()] [Token Validation] AssertValidToken at line 259 is called for each delegation when !IsUnlimitedDelegate, but when IsUnlimitedDelegate is true, no token validation occurs. Can this be exploited to create unlimited delegations for non-existent tokens? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: AddDelegateInfo()] [BlockHeight Setting] At line 263, BlockHeight is always set to Context.CurrentHeight when adding. Is there any time-based restriction or cooldown for delegation changes? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: AddDelegateInfo()] [Direct Dictionary Mutation] At line 260, existDelegateeList.Delegations[symbol] = amount directly modifies the dictionary. If this is called multiple times in a loop with the same symbol, can amounts be overwritten unexpectedly? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: UpdateDelegateInfo()] [State Transition] At lines 275-278, when switching to IsUnlimitedDelegate=true, all existing delegations are cleared. Can a delegatee exploit this to reset delegation state and avoid tracking? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: UpdateDelegateInfo()] [Removal Logic] At lines 286-289, delegations are removed if amount <= 0, but at lines 291-294 they're updated if amount > 0. What if amount is exactly 0 but not negative? Is this handled correctly? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: UpdateDelegateInfo()] [Validation Inconsistency] At lines 292 and 298, AssertValidToken is called for positive amounts, but only when the symbol already exists (line 284) or doesn't exist (line 296). Is there a case where validation is skipped? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: UpdateDelegateInfo()] [BlockHeight Update] At line 304, BlockHeight is always updated to Context.CurrentHeight. Can rapid updates be used to manipulate or game time-based logic that depends on delegation BlockHeight? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: UpdateDelegateInfo()] [IsUnlimitedDelegate Toggle] At line 305, IsUnlimitedDelegate can be toggled in any update. Can a delegatee repeatedly flip this flag to bypass fee tracking or cause state confusion? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: UpdateDelegateInfo()] [Clear vs Remove] At line 277, existDelegation.Clear() removes all items but keeps the dictionary object. At line 288, individual items are removed. Is there a semantic difference that could cause issues? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: FireLogEvent()] [Event Spam] If toAddTransactionList, toUpdateTransactionList, and toCancelTransactionList all have entries, three separate events are fired (lines 317-348). Can this be exploited for event spam or gas attacks? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: FireLogEvent()] [Event Data Redundancy] In all three events (lines 319-347), both Caller and Delegatee are set to Context.Sender. Is this redundant, and does it waste event data space? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: FireLogEvent()] [Empty List Check] The checks at lines 317, 328, 339 ensure lists aren't empty before firing events. But what if a list contains invalid or duplicate transactions? Should additional validation be performed? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateeInfos()] [Authorization] The delegator (Context.Sender) removes delegatee info unilaterally at line 357. Should there be a mutual agreement mechanism or notification requirement? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateeInfos()] [Input Validation] At line 353, DelegateeAddress null check is performed, but at line 356, it's converted with null-conditional operator. Is this defensive programming or a potential null reference? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateeInfos()] [Batch Processing] The function accepts DelegateTransactionList and processes it in RemoveTransactionFeeDelegateInfo. If the list is very large, can this cause gas issues? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatorInfos()] [Authorization Bypass] Any delegatee (Context.Sender) can remove their delegation info for any delegator without the delegator's approval. Can this be exploited to prevent fee delegation when the delegator expects it? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegatorInfos()] [Symmetric Operations] This function (delegatee removes their info) is symmetric to RemoveTransactionFeeDelegateeInfos (delegator removes delegatee), but who should have ultimate control? Can conflicts arise? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateInfo()] [Duplicate Handling] At line 374, Distinct() is called on delegateTransactionList. If duplicates exist in input, does this silently de-duplicate, and could this hide bugs in calling code? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateInfo()] [Null Check Optimization] At line 382, both null check and ContainsKey check are performed with continue. Could a malicious actor provide many invalid entries to waste gas on these checks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateInfo()] [State Cleanup] At line 383, the delegatee is removed, but what if this leaves an empty Delegatees dictionary at the contract-method level? Should that map entry be cleaned up? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateInfo()] [Event Emission] At lines 389-398, TransactionFeeDelegateInfoCancelled is only fired if toCancelTransactionList has entries. If all inputs were invalid and skipped, is it correct to succeed silently? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs] [Function: RemoveTransactionFeeDelegateInfo()] [Address Conversion] At line 395, Address.FromBase58(delegateeAddress) is called. If delegateeAddress is corrupted in state, can this throw and revert the entire transaction? (Medium)"
]