[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Collection Owner Override] If GetSymbolType classifies 'ABC-1' as Token, CreateToken doesn't check collection existence - can attacker create token that collides with NFT namespace, later claiming ownership of entire collection? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Context.Sender Authorization] CreateNFTInfo requires Context.Sender == owner - if GetSymbolType misclassifies and routes to CreateToken, does different authorization apply, allowing unauthorized creation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [ExternalInfo Inheritance] CreateNFTInfo checks collection ExternalInfo for NftCreateChainIdExternalInfoKey - if GetSymbolType misclassifies symbol, can attacker create NFT without inheriting collection's external info constraints? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Callback Configuration] DealWithExternalInfoDuringTransfer on line 337 uses tokenInfo.ExternalInfo - if GetSymbolType misclassifies NFT type, can callbacks be triggered for wrong token type, causing reentrancy or unexpected state changes? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Lock/Unlock Callbacks] DealWithExternalInfoDuringLocking checks LockCallbackExternalInfoKey - if GetSymbolType confusion causes Token to be treated as NFT, can attacker lock fungible tokens using NFT callback logic, bypassing lock whitelist? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [LogEvent External Info] FireExternalLogEvent on line 367 uses tokenInfo.ExternalInfo - can GetSymbolType misclassification cause log events to fire with wrong symbol type metadata, breaking off-chain indexing? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Transfer Blacklist] DoTransfer checks IsInTransferBlackListInternal on line 101 - if GetSymbolType misclassifies NFT as Token, can blacklisted address transfer NFTs by exploiting type confusion in validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Lock Whitelist] AssertSystemContractOrLockWhiteListAddress checks State.LockWhiteLists[symbol] on line 198-202 - if GetSymbolType affects symbol key, can attacker bypass lock whitelist by using misclassified symbol variant? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Create Whitelist] CreateToken checks IsAddressInCreateWhiteList on line 56 - if GetSymbolType routes NFT creation through Token path, can non-whitelisted address create NFTs by exploiting misclassification? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [IsInWhiteList Check] DoTransferFrom checks IsInWhiteList on line 78 allowing whitelist bypass of allowance - if GetSymbolType misclassifies symbol, can attacker transfer NFTs using token whitelist entry? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [TotalSupply Validation] CreateNFTInfo from SEED requires totalSupply==1 on line 39 - if GetSymbolType misclassifies SEED item, can attacker create multiple copies violating NFT uniqueness? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Decimals Validation] CreateNFTInfo requires decimals==0 for SEED on line 39 - if GetSymbolType routes to CreateToken, can attacker create divisible SEED tokens instead of unique NFTs? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Balance Modification] ModifyBalance on line 116 uses symbol directly - if GetSymbolType misclassifies but balance key is different, can attacker create balance for wrong symbol type, causing accounting errors? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Mint/Burn Asymmetry] If symbol is classified as Token during mint but NFT during burn (due to state changes), can attacker exploit classification inconsistency to mint fungible then burn NFT, inflating supply? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Null Symbol Input] Line 9 calls symbol.Split() - if symbol is null, does this throw NullReferenceException before any validation, or is null caught by earlier checks? Can this be used for DOS? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Empty String Symbol] If symbol is empty string '', Split() returns array with one empty element - does words[0].Length > 0 catch this, or can empty symbol pass validation and be classified as Token? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Whitespace Only Symbol] Can symbol '   ' (spaces) pass IsValidCreateSymbol regex? If so, does GetSymbolType classify it as valid Token, allowing creation of whitespace-only token symbols? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Null After Split] If Split() returns array with null elements (edge case), does words[0].Length throw NullReferenceException before Assert on line 10? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Assert Message Clarity] Line 10 asserts with 'Invalid Symbol input' and line 12 with 'Invalid NFT Symbol input' - can attacker craft symbol that fails multiple validations but only shows first error, hiding true validation issue? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Assertion Gas Cost] If Assert fails on line 10 after expensive Split() and array allocation, can attacker spam failed GetSymbolType calls to waste gas without penalty? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Partial Validation] GetSymbolType only validates format, not existence - if symbol 'ABC-1' is valid format but 'ABC-0' collection doesn't exist, can this cause later failures after GetSymbolType succeeds, creating inconsistent state? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Validation Sequence] GetSymbolType is called before AssertValidCreateInput which has additional checks - can attacker exploit gap between format validation and business logic validation to create invalid tokens? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [ItemId Numeric Limits] IsValidItemId accepts any numeric string - can 'ABC-99999999999999999999999999999999' cause integer overflow when parsed to long in other functions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Negative Numbers] Can 'ABC--1' or 'ABC-(-1)' bypass IsValidItemId? If regex only checks positive, can attacker create negative item IDs causing confusion with collection suffix '0'? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Hexadecimal Numbers] Does IsValidItemId accept '0x123' or '0X123'? If so, can attacker create NFT items with hex notation that convert to different decimal values, causing ID collision? (Low)"
]