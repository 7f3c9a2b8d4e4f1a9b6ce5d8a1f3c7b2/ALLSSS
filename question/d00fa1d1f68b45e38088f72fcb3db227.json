[
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Authorization Bypass] Can an attacker front-run a legitimate voter's ChangeVotingOption call by transferring the voting record NFT to themselves, then changing the vote option since the check at line 28 only validates Context.Sender matches votingRecord.Voter at execution time? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [State Inconsistency] If the VoteContract.Withdraw call at line 46 succeeds but VoteContract.Vote at line 52 fails or reverts, will the old candidate's vote count remain decremented (lines 64-70) while the new candidate never receives votes, creating permanent vote count corruption? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Time Manipulation] At line 29, actualLockedSeconds is calculated as Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds). Can a miner manipulate block timestamp to make actualLockedSeconds artificially high, bypassing the check at line 31 and allowing premature vote changes? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Arithmetic Error] At line 42, State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds). If actualLockedSeconds is only slightly less than claimedLockingSeconds, could this result in a near-zero remaining lock time, allowing immediate withdrawal after vote change? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Double Spend] If IsResetVotingTime is false (line 39), the lock time is reduced at line 42, but if ExtendVoterWelfareProfits was previously called for this voteId, could the voter receive extended welfare benefits while having a reduced lock time, violating the time-to-reward invariant? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Data Center Manipulation] At lines 97-109, if a new candidate is added to DataCenters when count < GetValidationDataCenterCount(), but the candidate's CandidateVotes hasn't been properly initialized yet, could this cause a null reference or zero-vote candidate to enter the data center list? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Vote Count Inflation] At lines 76-82, if newCandidateVotes already exists, votes are added. But at lines 86-92, if null, a new CandidateVote is created. Could an attacker exploit race conditions to have both paths execute, doubling the vote count for the new candidate? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Candidate Information Bypass] At line 25-26, AssertValidCandidateInformation checks if candidate exists and IsCurrentCandidate is true. However, if a candidate quits between this check and the actual vote change execution, could the vote be transferred to an inactive candidate? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Profit Scheme Corruption] Lines 37-38 call ExtendVoterWelfareProfits which modifies profit details. If this call partially succeeds but ChangeVotingOption later reverts, could the voter's profit scheme be left in an inconsistent state with extended end period but old vote target? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Remove Without Validation] At line 65, oldCandidateVotes.ObtainedActiveVotingRecordIds.Remove(input.VoteId) is called. If this voteId doesn't exist in the list, does Remove silently fail, leaving vote counts inconsistent with the actual voting record list? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [Data Center Race] At lines 115-120, if oldVoteOptionPublicKey exists in DataCenters, votes are subtracted and UpdateDataCenterAfterMemberVoteAmountChanged is called. Could concurrent ChangeVotingOption calls from multiple voters for the same old candidate cause race conditions in data center ranking updates? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [IsChangeTarget Flag] At line 59, IsChangeTarget is set to true when calling VoteContract.Vote. If the VoteContract treats IsChangeTarget votes differently (e.g., bypassing certain validations), could this be exploited to create invalid voting states? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [GetNewestPubkey Manipulation] At line 63, oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option). If GetNewestPubkey returns a different pubkey than expected due to candidate re-registration, could votes be subtracted from the wrong candidate's total? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [AllObtainedVotedVotesAmount Underflow] At lines 68-69, AllObtainedVotedVotesAmount is decremented for old candidate and incremented at lines 79-80 for new candidate. If the old candidate's AllObtainedVotedVotesAmount is less than votingRecord.Amount due to prior corruption, could this cause an underflow? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ChangeVotingOption()] [CandidateReplaceMemberInDataCenter Logic] At line 112, CandidateReplaceMemberInDataCenter is called with voteAmountOfNewCandidate. If this function incorrectly calculates whether replacement should occur due to edge cases in vote amounts, could invalid candidates enter the data center? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ExtendVoterWelfareProfits()] [Infinite Extension] At lines 132-137, if lockTime is 0 or very small, lockPeriod could be 0, causing early return. But if called repeatedly with IsResetVotingTime=true in ChangeVotingOption, could a voter extend welfare indefinitely without actual time commitment? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ExtendVoterWelfareProfits()] [Division By Zero] At line 133, lockTime.Div(State.TimeEachTerm.Value) is calculated. If State.TimeEachTerm.Value is 0 or not initialized, could this cause a division by zero panic? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ExtendVoterWelfareProfits()] [Profit Detail Not Found] At lines 156-159, if extendingDetail is null, an AssertionException is thrown. However, could an attacker deliberately corrupt profit details to cause this assertion to fail, DOS'ing legitimate vote changes that use IsResetVotingTime=true? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ExtendVoterWelfareProfits()] [EndPeriod Overflow] At line 139, endPeriod = lockPeriod.Add(treasury.CurrentPeriod). If lockPeriod is extremely large (e.g., max int64) or CurrentPeriod is large, could this overflow and wrap to a small endPeriod, granting eternal profit shares? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ExtendVoterWelfareProfits()] [FixProfitDetail Authority] At line 144, State.ProfitContract.FixProfitDetail.Send is called. If the ProfitContract doesn't properly validate that only the scheme owner can fix profit details, could this be exploited to modify other voters' profit details? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: ExtendVoterWelfareProfits()] [StartPeriod Zero] At line 143, the comment says 'startPeriod is 0, others stay still' but StartPeriod is not explicitly set in the FixProfitDetailInput. Could this cause the ProfitContract to interpret profit periods incorrectly? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Ector.cs] [Function: GetProfitDetailByElectionVotingRecord()] [Ambiguous Profit Detail Match] At lines 177-182, profitDetail is matched first by Id equals voteId, then falls back to matching by Shares equals Weight. Could two different votes with identical weight cause incorrect profit detail retrieval? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: GetProfitDetailByElectionVotingRecord()] [LastOrDefault Risk] At line 181, LastOrDefault is used for old-style matching. If multiple profit details have the same Shares, this returns the last one. Could this cause misattribution of profit details in multi-vote scenarios? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightInterest()] [Interest Parameter Bounds] At line 198, only checks info.Interest > 0, but doesn't enforce an upper bound. Could an attacker (if they control the controller) set Interest to max int32, causing massive vote weight inflation in GetVotesWeight calculation? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Elector.cs] [Function: SetVoteWeightInterest()] [Capital Zero Edge Case] At line 196, only checks info.Capital > 0. If Capital is set to 1 while Interest is very large, could the ratio Interest/Capital at line 583 become huge, inflating vote weights exponentially? (High)"
]