[
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ProposeCrossChainIndexing()] [Race Condition] Lines 287-289 have TOCTOU gap: ClearCrossChainIndexingProposalIfExpired followed by ValidateCrossChainDataBeforeIndexing followed by ProposeCrossChainBlockData - can attacker manipulate state between these calls? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseCrossChainIndexingProposal()] [Replay Protection Bypass] Line 296 EnsureTransactionOnlyExecutedOnceInOneBlock prevents same-block execution but allows release of expired proposals - can attacker release stale data after proposal expired? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseCrossChainIndexingProposal()] [Authorization Bypass] Line 297 checks AssertAddressIsCurrentMiner but never validates miner releasing is same as miner who proposed - can malicious miner release another miner's proposal? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseCrossChainIndexingProposal()] [Validation Gap] Line 298 requires input.ChainIdList.Count > 0 but never checks if chain IDs actually have pending proposals - can attacker cause assertion failure in ReleaseIndexingProposal? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseCrossChainIndexingProposal()] [Ordering Issue] Lines 299-300 ReleaseIndexingProposal before RecordCrossChainData - if release fails, is data recorded causing inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: ReleaseCrossChainIndexingProposal()] [DoS Vector] Line 299 loops through all chainIdList entries calling HandleIndexingProposal which makes external calls - can attacker provide thousands of chain IDs causing gas exhaustion? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: AcceptCrossChainIndexingProposal()] [Authorization Bypass] Line 306 checks AssertCrossChainIndexingControllerAuthority but never validates proposal actually exists or is in correct state - can controller accept non-existent proposal? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract.cs] [Function: AcceptCrossChainIndexingProposal()] [State Manipulation] Lines 307-308 AssertIsCrossChainBlockDataAccepted then ResetChainIndexingProposal but never verify data was actually recorded - can this leave chain in inconsistent state? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: BindParentChainHeight()] [Integer Overflow] Line 29 asserts ChildHeightToParentChainHeight[childHeight] == 0 but never validates parentHeight > 0 - can attacker bind to zero or negative height? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: BindParentChainHeight()] [Replay Attack] Lines 29-31 only check if binding exists but never verify childHeight matches Context.CurrentHeight - can attacker create future bindings? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: ComputeRootWithTransactionStatusMerklePath()] [Hash Collision] Lines 36-39 compute hash by concatenating txId and hardcoded 'Mined' status - can attacker craft txId to create hash collision with different transaction? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AddIndexedTxRootMerklePathInParentChain()] [Race Condition] Lines 54-57 check existing path then set new path - can attacker exploit TOCTOU gap to overwrite path between check and set? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AddIndexedTxRootMerklePathInParentChain()] [Validation Gap] Line 55 asserts existing == null but never validates incoming 'path' is valid merkle path with correct length - can attacker store invalid path? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: ChargeSideChainIndexingFee()] [Integer Underflow] Lines 62-63 return early if amount <= 0 but never validate amount doesn't exceed allowance - can this cause transfer to fail silently? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: ChargeSideChainIndexingFee()] [Address Manipulation] Line 67 converts chainId to hash then to virtual address without validation - can attacker cause transfer to go to unintended address by manipulating chainId? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: UnlockTokenAndResource()] [Token Loss] Lines 77-85 get balance and transfer to proposer but if balance query fails or proposer is invalid contract, are tokens lost permanently? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: UnlockTokenAndResource()] [Integer Overflow] Line 77 GetSideChainIndexingFeeDeposit returns balance without overflow check - can this overflow when added to other amounts? (Low)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: UnlockTokenAndResource()] [Reentrancy] Lines 80-85 call TransferDepositToken without reentrancy guard - can malicious proposer reenter during token transfer to unlock multiple times? (Critical)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: GetSideChainIndexingFeeDeposit()] [External Call] Lines 91-95 call State.TokenContract.GetBalance without checking if TokenContract was initialized - can uninitialized state cause null reference? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AssertValidSideChainCreationRequest()] [TOCTOU Vulnerability] Lines 103-104 check if proposedRequest is null OR expired, then lines 108-117 check allowance - can attacker modify allowance between these checks? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AssertValidSideChainCreationRequest()] [Integer Overflow] Line 116 checks 'allowance >= LockedTokenAmount' but never validates LockedTokenAmount doesn't overflow - can attacker provide max int64 causing comparison to fail incorrectly? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AssertValidSideChainCreationRequest()] [Validation Gap] Lines 120-122 validate IndexingPrice >= 0 AND LockedTokenAmount >= IndexingPrice but never check upper bound - can attacker lock entire supply? (Low)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AssertValidSideChainCreationRequest()] [Logic Error] Lines 124-130 return early if !IsPrivilegePreserved skipping resource token and primary token checks - can attacker create non-exclusive side chain without proper resource allocation? (High)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AssertValidResourceTokenAmount()] [DoS Vector] Lines 142-144 loop through GetStringArray(PayRentalSymbolListName) without length check - can malicious config cause function to run out of gas? (Medium)",
  "[File: contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs] [Function: AssertValidResourceTokenAmount()] [Validation Gap] Line 143 checks resourceTokenMap.ContainsKey and value > 0 but never validates sum of all resources doesn't overflow - can attacker cause integer overflow? (Medium)"
]