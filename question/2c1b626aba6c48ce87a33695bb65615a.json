[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetTokenInfo()] [Input Validation] Can an attacker pass a null or empty Symbol in GetTokenInfoInput causing the internal GetTokenInfo(string) to return incorrect data or throw exceptions, potentially causing DOS in dependent contracts that rely on token metadata? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetTokenInfo()] [Logic Flaw] Does GetTokenInfo() validate that the requested symbol exists before returning TokenInfo, or can it return null/default values that downstream contracts misinterpret as valid token data, leading to incorrect balance calculations or transfer logic? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetTokenInfo()] [Information Disclosure] Can an attacker repeatedly query GetTokenInfo() for non-existent or sensitive token symbols to enumerate valid token symbols through timing attacks or error message differences, potentially revealing private token information? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetTokenInfo()] [State Consistency] If GetTokenInfo() retrieves cached token data from State.TokenInfos, can outdated information be returned after token properties are updated elsewhere, leading to stale metadata being used for critical operations like burn checks? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetNativeTokenInfo()] [State Dependency] If State.NativeTokenSymbol.Value is null or uninitialized, does GetNativeTokenInfo() handle this gracefully, or can it return null TokenInfo causing critical failures in contracts depending on native token data for fee calculations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetNativeTokenInfo()] [Logic Flaw] Can an attacker exploit a scenario where State.NativeTokenSymbol changes between initialization and runtime, causing GetNativeTokenInfo() to return inconsistent native token data used in consensus or fee calculations? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetResourceTokenInfo()] [DOS Vector] Can an attacker cause Context.Variables.GetStringArray() to return an extremely large list of PayTxFeeSymbolListName or PayRentalSymbolListName entries, causing GetResourceTokenInfo() to exhaust gas in the nested foreach loops and Where clauses? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetResourceTokenInfo()] [Duplicate Entries] If a symbol exists in both PayTxFeeSymbolListName and PayRentalSymbolListName arrays, GetResourceTokenInfo() adds it twice to tokenInfoList.Value, potentially causing downstream contracts to double-count resource tokens in fee calculations or rental deductions? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetResourceTokenInfo()] [Null Handling] The Where clause filters symbols where GetTokenInfo(symbol) != null, but can malformed symbol strings pass this check and still cause issues when the TokenInfo is actually used for resource calculations? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetResourceTokenInfo()] [State Manipulation] Can an attacker with governance access manipulate TokenContractConstants.PayTxFeeSymbolListName or PayRentalSymbolListName to inject non-resource tokens, causing GetResourceTokenInfo() to return invalid tokens that break resource accounting logic? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetBalance()] [Symbol Aliasing] GetBalance() calls GetActualTokenSymbol() to resolve aliases, but if alias mappings are manipulated, can an attacker query balances of unintended tokens by passing crafted alias strings, potentially revealing balances they shouldn't access? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetBalance()] [Address Validation] Does GetBalance() validate that input.Owner is a valid non-zero address before querying State.Balances, or can querying zero address or contract addresses reveal unexpected balance data? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetBalance()] [Return Value Manipulation] The function returns input.Symbol unchanged while using the actual symbol for balance lookup - can this discrepancy between displayed symbol and actual balance cause confusion in off-chain systems tracking token holdings? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetBalance()] [NFT Balance Query] When querying NFT balances where symbol contains NFTSymbolSeparator, does GetBalance() correctly resolve to collection or specific NFT balance, or can symbol ambiguity cause incorrect balance reporting for NFT holders? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAllowance()] [State Access] GetAllowance() directly reads State.Allowances[input.Owner][input.Spender][symbol] without validation - can uninitialized mappings return default values that off-chain systems interpret as zero allowance when actual allowance state is undefined? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAllowance()] [Symbol Resolution] GetAllowance() uses GetActualTokenSymbol() to resolve aliases, but returns the resolved symbol in the output - can this cause off-chain clients to lose track of which alias was used when multiple aliases point to the same token? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAllowance()] [Null Input] If input.Owner, input.Spender, or input.Symbol are null, does GetAllowance() throw exceptions or return misleading zero allowance values that could be misinterpreted by dependent contracts? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAllowance()] [Allowance Overflow] Does the allowance value from State.Allowances properly handle edge cases like maximum uint64 values, or can querying allowances near type limits cause overflow issues in calculations using this data? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [Logic Flaw] GetAvailableAllowance() uses Math.Max() to combine regular allowance with all-symbol allowance, but can this logic be exploited where a zero regular allowance combined with non-zero all-symbol allowance incorrectly grants spending rights? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [Symbol Type Detection] The function calls GetSymbolType() to check for NFT or NftCollection, but if GetSymbolType() returns incorrect types due to malformed symbols, can GetAvailableAllowance() return inflated allowance values? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [NFT Collection Allowance] When symbolType is Nft or NftCollection, GetAvailableAllowance() calls GetNftCollectionAllSymbolAllowance() and uses Math.Max() again - can nested Math.Max() operations with unvalidated out parameters cause allowance to be incorrectly elevated? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [CheckSymbolIdentifier Short-circuit] If CheckSymbolIdentifier() returns true, the function immediately returns without checking all-symbol or NFT collection allowances - can an attacker craft symbols matching the identifier pattern to bypass higher allowance checks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [Out Parameter Handling] GetAllSymbolAllowance() and GetNftCollectionAllSymbolAllowance() use 'out _' discarding output parameters - are these discarded values security-relevant flags that should be checked before using Math.Max()? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [Multiple Allowance Sources] The function combines up to three different allowance sources (regular, all-symbol, NFT collection all-symbol) - can inconsistent state across these sources be exploited to gain spending rights exceeding intended limits? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Views.cs] [Function: GetAvailableAllowance()] [Symbol Validation] Does GetAvailableAllowance() validate input.Symbol format before passing to GetSymbolType() and GetNftCollectionAllSymbolAllowance(), or can malformed symbols cause type confusion in allowance calculations? (High)"
]