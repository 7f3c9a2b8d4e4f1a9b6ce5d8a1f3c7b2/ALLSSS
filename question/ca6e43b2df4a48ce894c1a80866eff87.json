[
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [External Call] Lines 62-66: State.TokenContract.GetTokenInfo.Call() can fail if token doesn't exist - is this exception handled or does it revert entire transaction? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [External Call] Lines 67-72: State.TokenContract.GetBalance.Call() for Context.Self - if balance query fails or returns unexpected format, can this break calculation? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Math Error] Line 73: 'tokenInfo.TotalSupply - balance - input.AmountToTokenConvert' can underflow if (balance + input.AmountToTokenConvert) > TotalSupply - does C# handle negative long values correctly here? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Overflow] Line 73: if TotalSupply is very large (near Int64.MaxValue), subtracting balance and AmountToTokenConvert could still overflow in intermediate calculations - is this checked? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Logic Error] Line 73: amountOutOfTokenConvert = TotalSupply - balance - AmountToTokenConvert represents tokens not in contract after the planned conversion - but if this is negative, line 75 condition 'amountOutOfTokenConvert > 0' skips calculation - is negative value meaningful? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Business Logic] Lines 75-84: needDeposit is only calculated if amountOutOfTokenConvert > 0, but what if amountOutOfTokenConvert is exactly 0? Does this mean no deposit needed, or should there still be a minimum reserve requirement? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [State Access] Line 77: fromConnector.VirtualBalance is read directly - if fromConnector.IsVirtualBalanceEnabled is false, should this value be used or should actual balance be used instead? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Conditional Logic] Lines 78-80: if toConnector.IsVirtualBalanceEnabled is true, tb = VirtualBalance + TotalSupply; else tb = TotalSupply only - can this create inconsistent pricing when IsVirtualBalanceEnabled changes? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Math Error] Line 79: toConnector.VirtualBalance.Add(tokenInfo.TotalSupply) - if VirtualBalance is negative or TotalSupply causes overflow when added, does Add() throw or wrap around? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Bancor Formula] Lines 81-83: BancorHelper.GetAmountToPayFromReturn() can throw if connectors have zero/negative balances, or if amountOutOfTokenConvert >= tb (formula division by zero) - is this handled? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Weight Extraction] Line 82-83: GetWeight(fromConnector) and GetWeight(toConnector) - if weight strings are invalid (empty, negative, >1.0), can this cause Bancor formula to return incorrect/negative needDeposit? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Precision Loss] Lines 81-83: BancorHelper returns long but internally uses decimal - can precision loss in conversion cause needDeposit to be understated, requiring less deposit than actually needed? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Return Values] Lines 86-90: DepositInfo returns both NeedAmount and AmountOutOfTokenConvert - if AmountOutOfTokenConvert is negative but returned as-is, can callers misinterpret the result? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Zero Balance] Line 77: if fromConnector.VirtualBalance is 0, BancorHelper formula will throw 'Connector balance needs to be a positive number' - should this be validated before calling? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Zero Balance] Lines 78-80: if toConnector.IsVirtualBalanceEnabled=false and tokenInfo.TotalSupply=0 (new token), tb=0 and Bancor formula will fail - is zero supply a valid input? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Input Validation] Line 56: input.TokenSymbol is not validated for null/empty before line 58 lookup - can this cause unexpected behavior? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Input Validation] No validation on input.AmountToTokenConvert - can negative or zero values be passed, causing incorrect amountOutOfTokenConvert calculation on line 73? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Race Condition] Between GetTokenInfo call (line 62-66) and GetBalance call (lines 67-72), if token transfers occur, can TotalSupply and balance become inconsistent for calculation? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Balance Timing] Line 67-72: GetBalance for Context.Self at time of view call may differ from actual balance when EnableConnector is called - can this cause EnableConnector to fail if calculated needDeposit was based on stale balance? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetDepositConnectorBalance()] [Null Check] Line 95: if State.Connectors[symbolInput.Value] returns null, assertion on line 96 fails with 'token symbol is invalid' - but should this distinguish between null connector vs wrong account type? (Low)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetDepositConnectorBalance()] [Logic Error] Line 96: Assert checks '!connector.IsDepositAccount' meaning connector should NOT be deposit account, but function name is GetDepositConnectorBalance - isn't this backwards? Should it require IsDepositAccount=true? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetDepositConnectorBalance()] [Symbol Validation] Line 97: ntSymbol = connector.RelatedSymbol is extracted without null/empty validation - can this cause issues if RelatedSymbol is not set? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetDepositConnectorBalance()] [State Access] Line 100: State.Connectors[ntSymbol] is accessed without null check - if ntSymbol is invalid, can this return null connector causing NullReferenceException on VirtualBalance access? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetDepositConnectorBalance()] [Arithmetic] Line 100: VirtualBalance + State.DepositBalance[ntSymbol] - can this overflow if both values are large (near Int64.MaxValue/2)? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetDepositConnectorBalance()] [State Consistency] Line 100: State.DepositBalance[ntSymbol] may be 0/uninitialized if deposit was never made - is returning just VirtualBalance correct in this case? (Medium)"
]