[
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Option Validation] Can an attacker vote for an option that was removed after the voting item was created, since AssertValidVoteInput() at line 381 only checks if the option exists in votingItem.Options at voting time, potentially voting for deleted options if removal isn't retroactive? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [VoteId Generation] Can an attacker predict or manipulate the VoteId generation at line 397 where Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false)) is used, enabling VoteId collision if VotesAmount has predictable values? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [VoteId Collision] Can multiple voters generate identical VoteIds at line 397 if they vote when VotesAmount has the same value, causing vote record overwrites and loss of earlier votes? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [Delegated Voting Validation] In delegated voting mode at lines 386-388, can an attacker provide a null Voter address or VoteId that passes the null checks but causes issues in downstream operations like UpdateVotedItems() at line 120? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Vote()] [IsChangeTarget Field] The IsChangeTarget field is set at line 114 but never validated or used in the contract - can an attacker set this to true/false arbitrarily to manipulate external systems that rely on this field? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotingResult()] [Integer Overflow] Can an attacker cause integer overflow when adding votes at line 177 using currentVotes.Add(amount), especially in quadratic voting where amounts can grow quadratically, causing VotesAmount to wrap around to negative values? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotingResult()] [Integer Overflow] Can an attacker cause integer overflow in VotersCount at line 178 by voting with many small amounts, incrementing VotersCount past long.MaxValue and causing it to wrap to negative? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotingResult()] [Integer Overflow] Can an attacker cause integer overflow in VotesAmount at line 179 by accumulating votes across multiple transactions, causing total votes to exceed long.MaxValue and wrap around? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotingResult()] [Missing Option Initialization] If votingResult.Results doesn't contain the option at line 174, a new entry is added with value 0 - can an attacker exploit the race condition between check and set to cause duplicate additions if voting happens concurrently? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotingResult()] [State Consistency] The function updates Results, VotersCount, and VotesAmount at lines 177-179 but doesn't verify that VotesAmount equals the sum of all Results values - can this cause accounting inconsistencies if amounts are manipulated? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotedItems()] [State Initialization] At line 148, if VotedItemsMap[voter] is null, a new VotedItems is created - can an attacker vote, withdraw, and vote again to manipulate the withdrawn list since line 159 removes from WithdrawnVotes but this list persists across multiple votes? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotedItems()] [Key Collision] Using votingItem.VotingItemId.ToHex() as map key at line 149 - can two different voting items produce the same hex string if hash collision occurs, causing votes to be tracked under wrong voting items? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotedItems()] [List Manipulation] At line 151, voteId is added to ActiveVotes without checking if it already exists - can an attacker vote with the same VoteId multiple times to inflate the ActiveVotes list with duplicates? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: UpdateVotedItems()] [List Manipulation] At line 159, voteId is removed from WithdrawnVotes - can an attacker exploit this by voting with a VoteId that was previously withdrawn to remove it from the withdrawn list, manipulating historical voting records? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Authorization Bypass] At lines 197-200, authorization check differs based on IsLockToken - can an attacker withdraw votes from a locked token voting item if they can manipulate the votingItem.Sponsor address, or vice versa for delegated voting? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Double Withdrawal] Can an attacker withdraw the same vote multiple times since IsWithdrawn is checked at line 194 in the code reading but not in this function, allowing multiple withdrawals before the state is updated at line 203? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [State Consistency] The function updates IsWithdrawn at line 203 BEFORE updating VotingResults at lines 215-220 - can an attacker exploit reentrancy to withdraw the same tokens multiple times by calling Withdraw again before results are updated? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Integer Underflow] At line 216, votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount) can underflow if multiple withdrawals happen or if the amount was manipulated - can this cause the vote count to wrap around to a large positive number? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Integer Underflow] At line 218, VotersCount.Sub(1) can underflow if VotersCount is already 0 or if the condition at line 217 (no active votes) is manipulated - can this cause VotersCount to become long.MaxValue? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Integer Underflow] At line 220, VotesAmount.Sub(votingRecord.Amount) can underflow if the total votes recorded is less than the amount being withdrawn - can this cause VotesAmount to wrap to a huge positive number? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [VotersCount Logic Error] At lines 217-218, VotersCount is only decremented if there are no active votes remaining - can an attacker vote multiple times, withdraw one vote, and keep VotersCount inflated even though they should be counted as 0 voters? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Snapshot Mismatch] The withdrawal updates VotingResult for the snapshot number stored in votingRecord at line 207, but if the current snapshot has advanced, can withdrawals incorrectly modify historical snapshot results instead of current results? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Token Unlock Validation] At lines 224-231, tokens are unlocked AFTER all state changes - if the Unlock call fails, can the state remain inconsistent with IsWithdrawn=true but tokens still locked? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Token Unlock Amount] The Unlock call at line 229 uses votingRecord.Amount - can an attacker exploit quadratic voting where the locked amount may differ from the recorded amount if QuadraticVotesCountMap was manipulated, unlocking wrong amounts? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract.cs] [Function: Withdraw()] [Missing Null Check] At line 193, if votingRecord is null, an exception is thrown - but what if votingItem at line 195 is null because the voting item was deleted? Can this cause a null reference exception that leaves state inconsistent? (Medium)"
]