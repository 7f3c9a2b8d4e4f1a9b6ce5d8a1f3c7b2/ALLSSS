[
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: GetCurrentMinerList()] [State Validation] If State.ConsensusContract returns null or empty miner list after RequireConsensusContractStateSet(), can subsequent authorization checks be bypassed through empty parliament member validation? (Critical)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: GetCurrentMinerList()] [Data Integrity] Can an attacker manipulate the consensus contract to return malformed public keys that fail Address.FromPublicKey() conversion, causing DoS in all parliament operations dependent on miner list? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: GetCurrentMinerList()] [Race Condition] If miner list changes between GetCurrentMinerList() call and vote counting in IsReleaseThresholdReached(), can votes from removed miners still count toward approval thresholds? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: GetCurrentMinerList()] [DoS] If consensus contract returns an extremely large miner list (e.g., thousands of pubkeys), can the Address.FromPublicKey() conversion loop cause out-of-gas errors in all parliament operations? (Medium)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: GetCurrentMinerList()] [Authorization Bypass] If consensus contract is replaced or compromised, can it return an arbitrary miner list allowing unauthorized addresses to vote on and approve critical proposals? (Critical)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: AssertIsAuthorizedProposer()] [Authorization Bypass] If organization.ProposerAuthorityRequired is false, can any address create proposals without whitelist or parliament member checks, enabling spam attacks or malicious proposals? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: AssertIsAuthorizedProposer()] [Logic Error] The OR condition allows proposal creation if ValidateAddressInWhiteList(proposer) OR ValidateParliamentMemberAuthority(proposer) succeeds - can a non-whitelisted, non-parliament address exploit edge cases where both return true incorrectly? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: AssertIsAuthorizedProposer()] [State Manipulation] If organization is null (line 24 check fails after assertion), can the function continue with null reference, bypassing all authorization checks? (Critical)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: AssertIsAuthorizedProposer()] [Race Condition] If organization.ParliamentMemberProposingAllowed is changed from true to false after a proposer passes ValidateParliamentMemberAuthority() but before proposal creation, can unauthorized proposals be created? (Medium)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: AssertIsAuthorizedProposer()] [Whitelist Bypass] If State.ProposerWhiteList is cleared or modified between AssertIsAuthorizedProposer() check and actual proposal creation, can previously unauthorized addresses create proposals? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsReleaseThresholdReached()] [Logic Error] If both IsProposalRejected() and IsProposalAbstained() return false but CheckEnoughVoteAndApprovals() also returns false due to insufficient approvals, can proposals be released prematurely? (Critical)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsReleaseThresholdReached()] [Race Condition] If parliamentMembers list changes between GetCurrentMinerList() call and the three validation checks (rejected/abstained/approvals), can vote counts be miscalculated leading to incorrect release decisions? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsReleaseThresholdReached()] [State Inconsistency] If GetCurrentMinerList() is called fresh for each check instead of reusing parliamentMembers parameter, can different miner lists cause inconsistent threshold calculations within same transaction? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsReleaseThresholdReached()] [Threshold Bypass] Can an attacker time proposal releases to coincide with miner list changes, exploiting the gap between rejection/abstention checks and approval checks to bypass thresholds? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalStillPending()] [Logic Inversion] The function returns !CheckEnoughVoteAndApprovals() - if CheckEnoughVoteAndApprovals() has a bug returning false positives, can finalized proposals incorrectly appear as pending? (Medium)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalStillPending()] [State Inconsistency] If IsProposalRejected() or IsProposalAbstained() return true, the function returns false (not pending) - can this cause proposals to be incorrectly marked as finalized when they should remain pending? (Medium)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalRejected()] [Integer Overflow] The calculation 'rejectionMemberCount * AbstractVoteTotal' could overflow if rejectionMemberCount is large - can this cause incorrect rejection threshold comparisons? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalRejected()] [Integer Overflow] The calculation 'organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count' could overflow with large member counts - can this bypass rejection checks? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalRejected()] [Rounding Error] The comparison uses strict '>' instead of '>=' - can proposals with rejection count exactly at threshold be incorrectly marked as not rejected? (Medium)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalRejected()] [Division by Zero] If parliamentMembers.Count is zero (empty parliament), does the multiplication cause undefined behavior or allow all proposals to pass? (Critical)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalRejected()] [Vote Counting] The function counts proposal.Rejections.Count(parliamentMembers.Contains) - can non-parliament members in Rejections list inflate the count if Contains() check fails silently? (Medium)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalRejected()] [Duplicate Votes] If proposal.Rejections contains duplicate addresses, does Count(parliamentMembers.Contains) count them multiple times, inflating rejection count? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalAbstained()] [Integer Overflow] The calculation 'abstentionMemberCount * AbstractVoteTotal' could overflow - can this cause incorrect abstention threshold comparisons? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalAbstained()] [Integer Overflow] The calculation 'organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count' could overflow - can this bypass abstention checks? (High)",
  "[File: contract/AElf.Contracts.Parliament/Parliament_Helper.cs] [Function: IsProposalAbstained()] [Rounding Error] The comparison uses strict '>' instead of '>=' - can proposals with abstention count exactly at threshold be incorrectly marked as not abstained? (Medium)"
]