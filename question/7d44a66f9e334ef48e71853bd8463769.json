[
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: IsReleaseThresholdReached() in Referendum_Helper.cs] [Threshold Logic] At line 15-16, total votes must be >= MinimalVoteThreshold. Can an attacker stuff votes with Abstain to meet this threshold without meaningful approval? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: IsReleaseThresholdReached() in Referendum_Helper.cs] [Rejection Threshold] At line 20-22, isRejected uses > instead of >=. Can a proposal with RejectionCount == MaximalRejectionThreshold be released when it should be blocked? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: IsReleaseThresholdReached() in Referendum_Helper.cs] [Abstention Threshold] At line 24-26, isAbstained uses > instead of >=. Can a proposal with AbstentionCount == MaximalAbstentionThreshold be released when it should be blocked? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: IsReleaseThresholdReached() in Referendum_Helper.cs] [Approval Threshold] At line 28, approval check uses >=. Is this consistent with rejection/abstention logic? Can this asymmetry be exploited to release proposals with marginal approval? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: ClearProposal()] [Unauthorized Clearing] Comment at line 156 says 'anyone can clear proposal if it is expired'. Can an attacker clear expired but approved proposals before Release() is called, preventing legitimate execution? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: ClearProposal()] [Time Manipulation] ExpiredTime check at line 158 uses CurrentBlockTime. Can miners manipulate timestamps to prematurely expire and clear active proposals? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: ClearProposal()] [Locked Token Recovery] After ClearProposal at line 159, voters can ReclaimVoteToken, but does this affect vote counts for future IsReleaseThresholdReached checks? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: ClearProposal()] [Race Condition] Between checking proposal != null at line 158 and removing it at line 159, can another transaction Release() the proposal, causing double-execution? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: GetProposal()] [Information Leakage] ProposalOutput at lines 193-208 exposes all proposal details including Params. Can this leak sensitive transaction data before execution? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: GetProposal()] [ToBeReleased Calculation] At line 192, IsReleaseThresholdReached is called for view. If vote counts are changing, could this provide incorrect release status to front-ends? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: ValidateProposerInWhiteList()] [Access Control Leakage] Anyone can call this at lines 223-230 to enumerate valid proposers. Can attackers use this to identify high-value governance participants for social engineering? (Low)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: GetProposalVirtualAddress()] [Address Prediction] At line 234, virtual address is derived from proposalId. Can attackers predict virtual addresses to pre-fund them or perform front-running attacks? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: RequireTokenContractStateSet() in Referendum_Helper.cs] [Contract Substitution] At lines 33-36, TokenContract is set using GetContractAddressByName. Can a malicious contract register itself with SmartContractConstants.TokenContractSystemName to intercept token calls? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: GetTokenInfo() in Referendum_Helper.cs] [Oracle Manipulation] TokenContract.GetTokenInfo is called at line 135-138. Can an attacker manipulate token contract state to cause Validate() to fail for existing organizations? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: GetAllowance() in Referendum_Helper.cs] [Allowance Front-Running] GetAllowance is read from token contract at line 144-149. Can an attacker observe pending Approve/Reject transactions and reduce allowance to cause voting failures? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [State: LockedTokenAmount] [Memory Leakage] LockedTokenAmount mapping is never cleaned up except in UnlockToken. Can expired proposals with unclaimed votes cause unbounded state growth? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [State: Proposals] [State Bloat] Proposals are only removed in Release() and ClearProposal(). Can an attacker create many proposals that never reach threshold, causing permanent state bloat? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [State: Organizations] [Immutable Organizations] Organizations can only modify thresholds and whitelists through self-calls. Can organizations become permanently locked if they set invalid configurations? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Approve()] [Integer Overflow] ApprovalCount.Add(allowance) at line 76 uses Add() method. Is this safe from overflow? Can accumulated votes exceed Int64.MaxValue? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: IsReleaseThresholdReached() in Referendum_Helper.cs] [Integer Overflow] At line 15-16, three counts are added together. Can this overflow, causing threshold comparisons to fail incorrectly? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: LockToken() in Referendum_Helper.cs] [Amount Validation] No minimum or maximum amount validation exists. Can users vote with 1 wei to pass allowance > 0 check, making governance meaningless? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Approve()] [Reentrancy via Events] ReferendumReceiptCreated event is fired at line 81. If event handlers can trigger contract calls, could this enable reentrancy before state updates complete? (Medium)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Release()] [Reentrancy via SendVirtualInlineBySystemContract] Execution at line 169-171 happens before proposal removal at line 174. Can the called contract re-enter Release() to execute the proposal multiple times? (Critical)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: CreateOrganizationBySystemContract()] [Reentrancy via Callback] SendInline at line 48 executes before function returns. Can the callback contract re-enter to create duplicate organizations or manipulate state? (High)",
  "[File: contract/AElf.Contracts.Referendum/Referendum.cs] [Function: Validate() in Referendum_Helper.cs] [Timestamp Dependency] ExpiredTime validation at line 108 relies on Context.CurrentBlockTime. Can miners manipulate this to extend voting periods or prematurely expire proposals? (Medium)"
]