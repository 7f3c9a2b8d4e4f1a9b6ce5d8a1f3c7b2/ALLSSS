[
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Timing Manipulation] Can an attacker submit a malicious contract proposal and exploit the fixed 72-hour expiration period by timing block production delays or network congestion to ensure the proposal passes without sufficient review, violating the invariant that critical proposals must undergo thorough scrutiny before execution? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Governance Bypass] If the proposal expiration logic uses this hardcoded 259200-second value without checking for block timestamp manipulation, can an attacker with temporary consensus influence delay blocks to extend effective voting periods beyond intended 72 hours, allowing more time to gather malicious votes and violating time-bounded governance guarantees? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [DOS Attack] Can an attacker flood the governance system with contract proposals that each consume the full 72-hour expiration period, creating a backlog that delays legitimate urgent proposals (e.g., security patches) and effectively DoS'ing critical governance functions for extended periods? (Medium)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Race Condition] If consuming code checks proposal expiration using block.timestamp against creation_time + 259200, can an attacker submit transactions at the exact expiration boundary to race between proposal execution and expiration, potentially executing expired malicious proposals or blocking legitimate ones? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Integer Overflow] When consuming code adds ContractProposalExpirationTimePeriod (259200) to a proposal creation timestamp near max integer value, can this cause integer overflow resulting in immediate expiration or wrapping to a past timestamp, bypassing the 72-hour review period entirely? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Invariant Violation] Since this constant is public and immutable, if external contracts or cross-chain bridges reference it for time calculations, can discrepancies between chain timestamps cause proposals to expire prematurely or remain active indefinitely, violating cross-chain governance synchronization invariants? (Medium)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Economic Attack] Can an attacker with sufficient tokens create proposals with strategic timing (e.g., just before weekends or holidays) knowing the fixed 72-hour period will span low-activity times, reducing defender response and enabling malicious proposal passage through voter apathy? (Medium)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: ContractProposalExpirationTimePeriod] [Hardcoded Value Risk] Since this value is a compile-time constant rather than configurable parameter, if the network requires shorter expiration times during emergencies (e.g., to patch active exploit), is the governance system unable to adapt, forcing vulnerable windows to remain open for full 72 hours? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Time-Sensitive Attack] With only 900 seconds (15 minutes) for code check proposals, can an attacker submit malicious code proposals during known low-activity periods (e.g., 3 AM UTC) where defenders cannot review and reject within the extremely short window, enabling malicious contract deployment? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Insufficient Review Time] Does the 15-minute expiration period for code check proposals violate the security invariant that contract code must undergo thorough auditing, allowing attackers to deploy backdoored contracts that automatically pass after 900 seconds without adequate security review? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Block Manipulation] If code check proposal expiration relies on block timestamps, can validators/miners manipulate timestamps within the 900-second window to either force premature expiration of legitimate proposals or extend malicious proposal lifetimes beyond 15 minutes? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Race Condition] Can an attacker submit a code check proposal and immediately flood the network with transactions to delay block processing, ensuring defenders cannot submit rejection votes within the 900-second window, leading to automatic approval of malicious contract code? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [DOS Vector] Can an attacker spam multiple code check proposals with 900-second expiration each, forcing defenders to continuously monitor and respond every 15 minutes, creating defender fatigue and eventual security lapses where malicious proposals slip through? (Medium)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Integer Operations] When consuming code calculates expiration as creation_timestamp + 900, does it handle the case where creation_timestamp + 900 overflows or wraps, potentially causing code check proposals to expire immediately or become permanent, bypassing review entirely? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Cross-Contract Attack] If code check proposals reference external contracts and the 900-second window is too short to detect malicious interactions between contracts, can attackers deploy multi-contract exploits that only become apparent after the review period expires? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: DefaultCodeCheckProposalExpirationTimePeriod] [Automated Approval Risk] If the system auto-approves code check proposals after 900 seconds of no objections, can attackers exploit this by timing proposals when known objectors are offline, enabling malicious contract deployment without any actual approval votes? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Governance Bypass] If consuming code compares approval votes using the 6667 threshold but fails to enforce that abstentions + rejections respect complementary constraints, can an attacker pass a proposal with 66.67% approval even when 90% of participants abstained, violating the invariant that supermajority approval requires broad participation? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Precision Loss] When consuming code calculates (approval_votes * 10000) / total_votes >= 6667, can integer division truncation cause proposals with exactly 66.66% approval to incorrectly pass or fail, enabling threshold manipulation through strategic vote counts? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Rounding Attack] If the threshold calculation uses 6667 without proper rounding (representing 66.67%), can an attacker exploit the 0.01% discrepancy by submitting proposals with vote counts that pass at 66.665% instead of true 66.67%, accumulating advantage over multiple proposals? (Medium)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Zero-Denominator Attack] When calculating approval percentage using MinimalApprovalThreshold, if consuming code doesn't validate total_votes > 0, can an attacker create proposals with zero participation that incorrectly satisfy the 6667 threshold check through division-by-zero edge cases? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Integer Overflow] If consuming code multiplies approval_votes by 10000 before comparing to MinimalApprovalThreshold * total_votes, can extremely large vote counts cause overflow, resulting in incorrect threshold validation that allows minority-approved proposals to pass? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Threshold Boundary] With MinimalApprovalThreshold at exactly 6667, if consuming logic uses >= vs > comparison, can proposals with precisely 66.67% approval be accepted or rejected inconsistently across different validation points, creating exploitable edge cases? (Medium)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Basis Point Interpretation] If consuming contracts misinterpret 6667 as a percentage (66.67%) instead of basis points (0.6667), can this cause 100x threshold error enabling proposals with only 0.6667% approval to pass, completely bypassing governance security? (Critical)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MinimalApprovalThreshold] [Sybil Attack] With approval threshold at 6667 (66.67%), if the system doesn't enforce minimum participation requirements, can an attacker create proposals during low-activity periods where only 3 voters participate, requiring just 2 approval votes (66.67% of 3) to pass critical governance changes? (High)",
  "[File: contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs] [Constant: MaximalAbstentionThreshold] [Threshold Bypass] If consuming code only enforces MaximalAbstentionThreshold (10%) without coordinating with MinimalApprovalThreshold (66.67%), can a proposal pass with 67% approval and 11% abstention, violating the combined invariant that high abstention rates should trigger proposal rejection? (High)"
]