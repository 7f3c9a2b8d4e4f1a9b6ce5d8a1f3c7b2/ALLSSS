[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForUserFee()] [Threshold Immutability] The ProposalReleaseThreshold is set during organization creation and cannot be changed - if the initial threshold calculation is wrong or needs adjustment for security, is the organization permanently stuck with insecure parameters? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDeveloperControllerCreateInput()] [Single Member Organization] Lines 189 and 195-196 create an association with only parliamentAddress as member and proposer - can parliament unilaterally control developer fee decisions without developer input, despite the name 'DeveloperController'? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDeveloperControllerCreateInput()] [Threshold Manipulation] Lines 199-201 set MinimalApprovalThreshold and MinimalVoteThreshold to proposers.Count (1), meaning parliament can approve proposals with a single vote - is this sufficient security for developer fee governance? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDeveloperControllerCreateInput()] [Misleading Name] The organization is called 'DeveloperController' but only includes parliament - can this naming confusion lead to developers falsely believing they have control over their fee parameters? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDeveloperControllerCreateInput()] [No Developer Representation] Unlike the UserFeeController which has three-tier governance, DeveloperController is a single-tier parliament-only organization - is this fair to developers who have to pay these fees? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForDeveloperFee()] [Unanimous Approval] Lines 231-232 set thresholds to actualProposalCount (2: developer + parliament), requiring unanimous approval - if the DeveloperController organization is compromised, can it block or approve any developer fee proposal in collusion with parliament? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForDeveloperFee()] [Variable Naming] Line 220 uses 'actualProposalCount' but means 'actual member count' - can this variable naming confusion lead to threshold miscalculation if the code is modified? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForDeveloperFee()] [Member Validation] Lines 216-218 add developerAddress and parliamentAddress as members without validating they are legitimate organization addresses - can attacker-controlled addresses be injected during initialization? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetAssociationControllerCreateInputForDeveloperFee()] [DOS Attack] With unanimous approval required and zero rejection/abstention tolerance, can one compromised organization permanently block developer fee adjustments? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetControllerCreateInputForSideChainRental()] [Side Chain Creator Power] Lines 247 and 253-254 include sideChainCreator as a member and proposer with equal voting power to parliament - if the side chain creator is malicious, can they collude with themselves to set rental fees to zero or maximum? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetControllerCreateInputForSideChainRental()] [Unanimous Approval] Lines 257-259 require unanimous approval from both parliament and sideChainCreator - can either party DOS rental fee adjustments by refusing to approve, locking side chains into current (potentially incorrect) pricing? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetControllerCreateInputForSideChainRental()] [Creator Selection] The sideChainCreator address is passed as parameter without validation - if State.SideChainCreator.Value is set to an attacker's address before InitializeAuthorizedController(), can they gain permanent control over rental pricing? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetControllerCreateInputForSideChainRental()] [Economic Attack] If the side chain creator can influence rental pricing through this controller, can they set fees artificially low for their own side chains while blocking competitors, creating unfair market conditions? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultParliamentController()] [Test Environment Bypass] Lines 282-283 return an empty AuthorityInfo() if Parliament contract doesn't exist - can an attacker deploy the MultiToken contract in an environment without Parliament to bypass all controller authorization checks? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultParliamentController()] [Null State] If State.ParliamentContract.Value is null at line 277 and GetContractAddressByName() at line 279 returns null, the function returns an empty AuthorityInfo with null addresses - will other functions handle this gracefully or will null pointer exceptions occur? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultParliamentController()] [Default Organization Attack] Line 288 calls State.ParliamentContract.GetDefaultOrganizationAddress.Call() - if an attacker can manipulate the parliament contract's default organization (e.g., through a malicious upgrade), can they gain control over all MultiToken controllers? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultParliamentController()] [External Call Dependency] The function depends on an external call to GetDefaultOrganizationAddress() - if this call fails or returns an attacker-controlled address, does the entire controller initialization become compromised? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultParliamentController()] [State Caching] State.ParliamentContract.Value is cached at line 285 but never updated - if the Parliament contract is upgraded to a new address, will MultiToken continue using the old address indefinitely? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultDeveloperFeeController()] [Initialization Order] Lines 309-313 calculate DeveloperController.OwnerAddress using GetDeveloperControllerCreateInput(), but this calculation happens before the organization is actually created - can the calculated address mismatch the actual organization address if creation inputs are modified? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultDeveloperFeeController()] [State Initialization] Line 299-300 initialize State.AssociationContract.Value without checking if it's already set - can repeated calls cause inconsistency or gas wastage? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultDeveloperFeeController()] [Nested Calculation Dependency] Lines 315-320 calculate RootController address based on DeveloperController address calculated at lines 310-313 - if either CalculateOrganizationAddress() call returns wrong results, will the entire controller hierarchy be incorrect? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultDeveloperFeeController()] [Empty Object Creation] Lines 302-307 create a new DeveloperFeeController with empty AuthorityInfo objects that are immediately overwritten - is this inefficient coding or does it serve a purpose? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultDeveloperFeeController()] [Parameter Passing] The function receives defaultParliamentController as parameter but recalculates it in nested calls - if the parameter value differs from recalculated values, which one is used and can this cause inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultUserFeeController()] [Multi-Contract Dependency] Lines 326-332 initialize both State.AssociationContract.Value and State.ReferendumContract.Value - if either contract is malicious or compromised, can the entire UserFeeController be manipulated? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs] [Function: GetDefaultUserFeeController()] [Address Calculation Chain] Lines 342-350 calculate RootController address based on ReferendumController address (lines 342-345) which depends on ParliamentController - if any link in this chain is wrong, will all user fee operations fail? (High)"
]