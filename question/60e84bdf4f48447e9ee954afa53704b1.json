[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeSizeFee()] [Return Value Inconsistency] Line 417 calculates chargeResult but for delegations line 418-426 adds IsDelegationEnough check - if chargeResult is true but IsDelegationEnough is false, bill is still generated but returns false - state inconsistency? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GenerateBill()] [Insufficient Balance Edge Case] At line 525, if availableBalance + availableAllowance > txSizeFeeAmount but due to rounding both become 0, does bill show 0 fee while transaction succeeds? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GenerateBill()] [Bill Merging Bug] Lines 545-551 check if symbolChargedForBaseFee == symbolToPayTxFee to merge bills - if symbols are equal but bill already contains the symbol from previous operation, can amounts be incorrectly added twice? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetAvailableSymbolToPayTxFee()] [Delegation Check Bypass] At line 475-481, if delegation check fails, the loop breaks instead of continues - can this cause function to return null when valid non-delegate tokens exist later in list? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetAvailableSymbolToPayTxFee()] [Priority Logic Flaw] Lines 490-514 use complex priority: allowance >= fee > balance+allowance >= fee > anything > 0 - can attacker game this by setting allowances to exact fee amount to always get priority? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetAvailableSymbolToPayTxFee()] [Null Coalescing Chain] Line 513-514 uses ?? chain - if all symbols are null but allSymbolToTxFee list is not empty, does this return null when primary token should be fallback? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFirstSufficientToken()] [Delegation vs User Asymmetry] Lines 714-720 call TryToChargeDelegateBaseFee but lines 722-742 call TryToChargeUserBaseFee with additional primary token fallback - can this cause fees charged from different tokens for same transaction type? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFirstSufficientToken()] [Primary Token Fallback Override] At line 732-742, if charge fails for user, primary token is forced as fallback even if user has no balance - does this cause failed charge with primary token details in bill? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TryToChargeUserBaseFee()] [Priority Selection Inconsistency] Lines 772-776 return early if allowance covers full amount, but lines 786-795 continue checking balance+allowance - can this skip tokens with sufficient balance if earlier token has partial allowance? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TryToChargeUserBaseFee()] [Symbol Return on Failure] Lines 798-802 set symbolOfValidBalance to symbolWithAnything even when returning false - does this cause incorrect symbol info in bill on failed charges? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TryToChargeDelegateBaseFee()] [Delegation Key Existence] At line 830, delegations.Delegations.ContainsKey(symbol) is checked but delegations.Delegations[symbol] access at line 831 might still throw if map is modified concurrently - race condition? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetOrRefreshTransactionFeeFreeAllowances()] [Threshold Bypass] At line 309-310, allowance is only set if balance >= threshold - can user maintain balance just below threshold, then briefly increase it to get allowance, then decrease again before usage? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetOrRefreshTransactionFeeFreeAllowances()] [Time Manipulation] At line 313-314, refresh is based on (Context.CurrentBlockTime - lastRefreshTime).Seconds - can block time manipulation by miners cause premature refresh and unlimited allowances? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetOrRefreshTransactionFeeFreeAllowances()] [Clone Reference Issue] At line 318, FreeAllowances.Clone() is used - if Clone() is shallow copy, can modifications affect original config and cause allowance inflation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ConfigTransactionFeeFreeAllowances()] [Duplicate Symbol Handling] The function doesn't check for duplicate symbols in input.Value at line 1234 - can same symbol be added multiple times with different configs causing state inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ConfigTransactionFeeFreeAllowances()] [Negative Value Validation] Lines 1241-1242 check threshold >= 0 and refresh >= 0, but what about allowance amounts in TransactionFeeFreeAllowances.Value - can negative allowances cause underflow when deducted? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: RemoveTransactionFeeFreeAllowancesConfig()] [Partial Removal] At line 1285-1287, only symbols list is updated but TransactionFeeFreeAllowancesConfigMap state remains - can removed symbols still be accessed via direct map lookup? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: CalculateTransactionFeeFreeAllowances()] [Stale Allowance Return] Lines 1341-1343 return existing freeAllowances if lastRefreshTime is null - can this return very old allowances that should have been reset, causing fee evasion? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: CalculateTransactionFeeFreeAllowances()] [Refresh Time Comparison] At line 1348-1350, uses strict > instead of >= for refresh check - can this cause off-by-one error where allowances are refreshed one second late, affecting fee calculations? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeResourceToken()] [Empty Input Bypass] At line 570-573, if input equals new ChargeResourceTokenInput(), function returns without charging - can this be exploited to skip resource fees by sending default input? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeResourceToken()] [Balance Check Timing] Lines 579-581 check balance >= required, but if balance changes between check and event firing at line 587-592, can this cause event to report incorrect amounts? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeResourceToken()] [Zero Amount Warning] Lines 593-596 only log warning if charged amount is 0 - should this be an assertion to prevent zero-fee resource usage? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: CheckResourceToken()] [Owning Balance Validation] At line 609, assertion checks balance > owningBalance - if balance == owningBalance exactly, does this fail even though contract has no excess tokens? Should it be >= instead? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: DonateResourceToken()] [Height Initialization Race] Lines 917-920 initialize donateResourceTokenExecuteHeight to CurrentHeight on first call - if multiple miners call simultaneously in same block, can both pass the check and execute? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: DonateResourceToken()] [Height Increment Overflow] At line 924, executeHeight is incremented by 1 - after many blocks, can this overflow or desync from actual CurrentHeight? (Low)"
]