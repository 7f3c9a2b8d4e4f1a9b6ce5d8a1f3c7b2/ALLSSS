[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeTransactionFees()] [Authorization Bypass] Can an attacker bypass AssertTransactionGeneratedByPlugin() check by manipulating Context.TransactionId to equal Context.OriginTransactionId, allowing direct fee charging without plugin execution and enabling unauthorized fee collection? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: AssertPermissionAndInput()] [Input Validation] If input.MethodName or input.ContractAddress is set to empty string (not null), does the assertion at line 131 fail to catch it, allowing fee charging with invalid parameters and potential state corruption? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeTransactionFees()] [Early Return Bypass] When State.ChainPrimaryTokenSymbol.Value is null at line 29, the function returns success without charging fees - can this be exploited during chain initialization to execute transactions without payment? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeResourceToken()] [Authorization Bypass] The AssertTransactionGeneratedByPlugin check at line 568 can be bypassed if Context.TransactionId manipulation is possible - can attackers charge arbitrary resource tokens without proper plugin validation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetFeeReceiver()] [Authorization Escalation] Only State.SideChainCreator.Value can set fee receiver at line 1214, but if SideChainCreator is never set or set to zero address, does this permanently lock the fee receiver configuration? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFromDelegations()] [Block Height Manipulation] At line 186, delegation is only used if Context.Transaction.RefBlockNumber >= delegations.BlockHeight - can an attacker manipulate RefBlockNumber to use future delegations prematurely or bypass older delegations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFromDelegations()] [Delegation Double-Spend] If multiple transactions in the same block reference the same delegatee, can the delegation amount be consumed multiple times before ModifyDelegation at line 202 updates state, causing delegation overdraft? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyDelegation()] [Underflow Risk] At lines 221-222 and 232-233, delegation amounts are decremented with .Sub() without checking if delegations have already been fully consumed - can this cause integer underflow in delegation tracking? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFromDelegations()] [Unlimited Delegation Bypass] When delegations.IsUnlimitedDelegate is true at line 200, ModifyDelegation is skipped - can unlimited delegatees be exploited to charge infinite fees without balance checks? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFromDelegations()] [Delegation State Inconsistency] Lines 174-176 read from either TransactionFeeDelegateInfoMap or TransactionFeeDelegateesMap - if both exist with conflicting data, which takes precedence and can this cause delegation amount discrepancies? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TryToChargeDelegateBaseFee()] [Delegation Validation Race] At line 829-831, delegation sufficiency is checked but state is not locked - can concurrent transactions exploit the time gap between check and charge to overdraft delegations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyDelegation()] [State Path Confusion] Lines 218-220 and 229-231 use ?? operator to select delegation state path - if both paths exist with different delegatee addresses, can this cause deduction from wrong account? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFromDelegations()] [Foreach Loop Early Exit] The loop at line 183-207 breaks on first successful charge - can delegatees manipulate ordering to ensure their delegation is never consumed while others pay fees? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyBalance()] [Balance Underflow] At line 248, ModifyBalance(fromAddress, symbol, -amount) is called without explicit underflow check - can negative balance occur if GetBalance returns stale data or amount exceeds actual balance? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyBalance()] [Blacklist Check Bypass] The blacklist check at line 240 only validates fromAddress, but if fromAddress is a delegatee paying for delegator, does the delegator bypass blacklist restrictions? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyBalance()] [Allowance State Inconsistency] Lines 259-265 modify free fee allowance after balance is already deducted - can transaction revert after balance change but before allowance update, causing accounting mismatch? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetAvailableBalance()] [Balance Calculation Error] At line 454, available balance is calculated as GetBalance().Sub(amountChargedForBaseFee) when symbols match - if amountChargedForBaseFee > GetBalance(), does Sub() underflow or revert? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetAvailableBalance()] [Allowance Double-Count] Lines 456-459 calculate availableAllowance by subtracting amountChargedForBaseAllowance - can this allowance be counted twice if used for both base fee and size fee in same transaction? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetBalanceCalculatedBaseOnPrimaryToken()] [Division Precision Loss] At line 1365-1366, balance is multiplied then divided by weights - can this cause rounding errors that accumulate over multiple transactions, leading to fee leakage? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetBalanceCalculatedBaseOnPrimaryToken()] [Weight Manipulation] If tokenInfo.AddedTokenWeight is 0 at line 1366, does division by zero occur or can extremely high weights cause overflow in multiplication at line 1365? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeTransactionFeesToBill()] [Delegation Asymmetry] At line 286-289, if delegations != null and base fee fails, size fee is not charged - but for users (line 299), both must succeed - can this inconsistency be exploited? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeBaseFee()] [Partial Charge Exploit] At line 349-353, if charging fails but symbolToChargeBaseFee is not null, existing balance/allowance are added to bill - can this partial charge break fee atomicity requirements? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeBaseFee()] [Allowance Priority Vulnerability] Lines 359-369 prioritize free allowance over balance - can users manipulate allowance refresh timing to avoid paying from actual balance, getting perpetual free transactions? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeSizeFee()] [Symbol Selection Bypass] Lines 393-415 get available symbol from input.SymbolsToPayTxSizeFee - can attacker omit primary token from this list to force charging from token with manipulated balance? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeSizeFee()] [Weight Calculation Overflow] At line 403-404, txSizeFeeAmount is multiplied by AddedTokenWeight then divided by BaseTokenWeight - can this overflow if weights are set to MAX_LONG values? (High)"
]