[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetWriteFeeInitialCoefficient()] [Order of Terms] Line 232-236 lists terms as 'x/4 + x^2*25/16' but order in the Value array matters. If the code that evaluates coefficients processes terms in a different order, can this cause incorrect fee calculation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetWriteFeeInitialCoefficient()] [Overflow Risk] Line 236 with x^2*25/16 for x near int.MaxValue - does multiplying by 25 before dividing by 16 cause intermediate overflow even if the final result would fit? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetWriteFeeInitialCoefficient()] [Constant Term] Line 217-218 shows '1/10000' vs Read fee's '1/100000'. Why is Write fee constant 10x higher? Can attackers exploit the difference by converting Write operations to Read operations if possible? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTrafficFeeInitialCoefficient()] [Threshold Gaming] Line 255 sets threshold at 1,000,000 traffic units. Can an attacker batch multiple transactions to stay under the threshold and avoid quadratic fee scaling indefinitely? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTrafficFeeInitialCoefficient()] [Overflow Risk] Line 267 uses 'x^2/20000' with x up to int.MaxValue. Similar to Storage fees, can this overflow and wrap to negative, allowing attackers to generate massive traffic for negative fees (getting paid)? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTrafficFeeInitialCoefficient()] [Division Precision] Line 256 uses 'x/64 + 1/10000'. For x < 64, does x/64 truncate to 0, and is the constant 1/10000 also 0 due to integer division, making traffic essentially free? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTxFeeInitialCoefficient()] [Multi-Interval Complexity] Lines 286-309 define three intervals [0, 1M], (1M, 5M], and (5M, âˆž). Can attackers exploit the transition points to submit transactions with carefully chosen resource consumption that minimizes fees? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTxFeeInitialCoefficient()] [Economic Threshold] Line 287 and 296 show thresholds at 1M and 5M. Are these based on actual network capacity, or can attackers discover that these thresholds are too high and spam below 1M at minimal cost? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTxFeeInitialCoefficient()] [Overflow Risk] Line 307 uses 'x/80 + x^2/100000'. For x = int.MaxValue, does x^2/100000 overflow before division, and can this cause wrapping to negative fees? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTxFeeInitialCoefficient()] [Fee Manipulation] Line 288 shows 'x/800 + 1/10000'. Can an attacker calculate exact x values where integer division truncates favorably, paying significantly less than expected for specific transaction sizes? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: GetTxFeeInitialCoefficient()] [Constant Term Inconsistency] All intervals except the middle one (lines 297-298) have constant terms. Does this create a sudden fee drop at x=1M that attackers can exploit by targeting transactions just above 1M? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Cross-Function] [State Consistency] If UpdateCoefficients() is called while InitialCoefficients() is executing in another transaction, can race conditions corrupt State.AllCalculateFeeCoefficients.Value with partially initialized data? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Cross-Function] [Authorization Hierarchy] UpdateCoefficientsForContract() uses AssertDeveloperFeeController() while UpdateCoefficientsForSender() uses AssertUserFeeController(). Can an attacker exploit the hierarchy if user controller has higher privileges than developer controller due to misconfiguration? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Cross-Function] [Fee Type Confusion] UpdateCoefficientsForSender() forces FeeTokenType=Tx (line 29), but what if the underlying UpdateCoefficients() doesn't properly validate this override, allowing sender to affect non-Tx fee types? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Cross-Function] [Validation Bypass] AssertCoefficientsValid() validates structure but AssertPieceUpperBoundsIsInOrder() validates ordering. Can an attacker craft coefficients that pass AssertCoefficientsValid() but fail AssertPieceUpperBoundsIsInOrder(), causing state changes before the second check fails? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Cross-Function] [Event Consistency] Both UpdateCoefficients() (line 68-71) and InitialCoefficients() (line 124-127) fire CalculateFeeAlgorithmUpdated events. Can off-chain systems handle rapid event sequences correctly, or can attackers cause desynchronization? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [System-Level] [Gas Economics] If updating coefficients is cheap but calculating fees using complex formulas (x^2 terms) is expensive, can attackers set coefficients that make every transaction consume maximum gas, causing network-wide DoS? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [System-Level] [Integer Arithmetic] All initial coefficients use integer division (e.g., x/8, x^2/20000). If the fee calculation code doesn't account for truncation, can attackers exploit rounding to pay fractional fees or even 0 fees? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [System-Level] [Coefficient Consistency] The five fee types (Read, Storage, Write, Traffic, Tx) have different formulas and thresholds. Can attackers exploit relationships between types (e.g., converting Write to Read) to minimize total fees? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [System-Level] [Maximum Values] All intervals use int.MaxValue as infinity (lines 163, 194, 234, 265, 305). If resource consumption can actually reach int.MaxValue, do the x^2 terms in formulas cause guaranteed overflow? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: UpdateCoefficients()] [Duplicate PieceNumbers] Lines 48-50 validate that PieceNumbers count matches input list, but don't check for duplicate indices in PieceNumbers. Can an attacker pass [1, 1, 1] to overwrite the same coefficient three times, wasting gas and causing confusion? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: UpdateCoefficients()] [Partial State Rollback] If AssertPieceUpperBoundsIsInOrder() fails at line 64 after coefficients are updated at line 61, does the transaction revert cleanly, or can partial updates leak into state due to incorrect exception handling? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: AssertCoefficientsValid()] [Negative Power] Line 86 allows power >= 0, so power can be 0. In formula (B/C)*x^0, this equals B/C regardless of x. Can attackers set all terms to power=0 to create constant fees that don't scale with usage? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: AssertCoefficientsValid()] [Large Coefficients] No maximum bounds on divisor and dividend at line 86. Can an attacker set dividend=int.MaxValue, divisor=1, creating fees of (int.MaxValue)*x^power that always overflow? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs] [Function: AssertPieceUpperBoundsIsInOrder()] [Zero Upper Bound] The function doesn't validate that upper bounds are positive. Can an attacker set the first interval's upper bound to 0 or negative, creating an empty interval that breaks fee logic? (High)"
]