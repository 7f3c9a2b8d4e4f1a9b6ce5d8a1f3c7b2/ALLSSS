[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PerformSecretSharing()] [Static Method Side Effects] This is a static method that modifies minerInRound and round objects passed by reference. Can concurrent calls with the same round object cause race conditions where multiple miners' secret sharing data gets interleaved, corrupting the shared secret reconstruction? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PerformSecretSharing()] [Missing Decryption Verification] The function adds decrypted pieces without verifying that they were correctly decrypted or that they match expected encryption. Can a malicious miner submit arbitrary decrypted values that don't correspond to actual encrypted pieces, poisoning the secret sharing protocol? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessTinyBlock()] [Tiny Block Count Manipulation] ProducedTinyBlocks is incremented but ProducedBlocks is also incremented. Can this cause accounting inconsistencies where ProducedBlocks != ProducedTinyBlocks + ProducedNormalBlocks, breaking reward calculations or tiny block limiting logic? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessTinyBlock()] [Actual Mining Time Unchecked] tinyBlockInput.ActualMiningTime is added to ActualMiningTimes without validation. Can a miner submit tiny blocks with manipulated timestamps to game timing calculations or create timestamp ordering violations? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessTinyBlock()] [No Tiny Block Limit Enforcement] The function increments ProducedTinyBlocks but doesn't check against MaximumTinyBlocksCount within ProcessTinyBlock itself. Can a miner bypass tiny block limits by calling ProcessTinyBlock directly if the limit checking only happens in ResetLatestProviderToTinyBlocksCount? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PreCheck()] [Public Key Recovery Failure] Context.RecoverPublicKey() is called without error handling. If signature recovery fails or returns an invalid pubkey, can _processingBlockMinerPubkey be set to null or an incorrect value, bypassing authorization checks? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PreCheck()] [Previous Round Miner Privilege Escalation] The function allows previousRound miners to execute consensus transactions (comment: 'Case a failed miner performing NextTerm'). Can a miner who was removed from the current round due to poor performance exploit this to maintain consensus control indefinitely by repeatedly triggering term transitions? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PreCheck()] [Miner List Check Race Condition] TryToGetCurrentRoundInformation and TryToGetPreviousRoundInformation are called at the start. If round state changes between these calls and the actual IsInMinerList check, can an attacker exploit the timing window to bypass authorization? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PreCheck()] [Silent Failure Return] PreCheck returns false instead of throwing, and the caller Asserts. But the comment says 'The transaction can still executed successfully if the pre-check failed'. Can this create a scenario where failed authorization still modifies state through side effects before the Assert? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ResetLatestProviderToTinyBlocksCount()] [Tiny Block Count Underflow] When currentValue.Pubkey == _processingBlockMinerPubkey, BlocksCount is decremented by 1 using Sub(1). If BlocksCount is already 0, can this underflow cause BlocksCount to wrap to a very large value, allowing unlimited tiny block production? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ResetLatestProviderToTinyBlocksCount()] [Initial State Race Condition] If State.LatestPubkeyToTinyBlocksCount.Value is null, it's initialized with BlocksCount = MaximumTinyBlocksCount.Sub(1). Can concurrent transactions cause multiple initializations, or can the first miner exploit knowing they get maximum tiny blocks minus 1? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ResetLatestProviderToTinyBlocksCount()] [Miner Switching Exploit] When currentValue.Pubkey != _processingBlockMinerPubkey, the new miner gets minersCountInTheory.Sub(1) tiny blocks. Can a malicious miner coordinate with other miners to alternate block production, resetting their tiny block count to the maximum on every switch? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ResetLatestProviderToTinyBlocksCount()] [Miners Count Manipulation] The function uses minersCountInTheory from GetMaximumBlocksCount(). If this value can be manipulated externally (e.g., through configuration changes), can an attacker set it very high to gain excessive tiny block production allowance? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ResetLatestProviderToTinyBlocksCount()] [Maximum Tiny Blocks Constant Override] The code uses AEDPoSContractConstants.MaximumTinyBlocksCount for initialization. Can an attacker modify this constant through contract upgrades or configuration to change tiny block limits globally, breaking consensus timing assumptions? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation() + ProcessNextRound()] [Round Transition Atomicity] ProcessNextRound adds new round information via AddRoundInformation(nextRound) before updating the round number. If the round number update fails, can the added round data become orphaned, causing GetCurrentRoundInformation to return incorrect data? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation() + ProcessNextTerm()] [Treasury Release Timing Attack] ProcessNextTerm calls Treasury.Release with the OLD termNumber before the term transition completes. Can this create a timing window where treasury releases are double-claimed or missed if the term transition fails midway? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue() + PerformSecretSharing()] [Secret Sharing State Mutation] PerformSecretSharing modifies the round object in-place, then ProcessUpdateValue calls TryToUpdateRoundInformation. If the update fails, can the in-memory mutations to encrypted/decrypted pieces be lost, breaking secret sharing continuity? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PreCheck() + ProcessUpdateValue()] [Miner Authorization Desync] PreCheck sets _processingBlockMinerPubkey and validates them against current/previous rounds, but ProcessUpdateValue accesses currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey] directly. Can a miner who is only in previousRound cause a KeyNotFoundException in ProcessUpdateValue? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound() + RecordMinedMinerListOfCurrentRound()] [Round State Race Condition] RecordMinedMinerListOfCurrentRound is called before ProcessNextRound, using currentRound. If evil miner detection in ProcessNextRound modifies ElectionContract state that affects GetMinedMiners(), can the recorded list be inconsistent with final round state? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm() + ProcessUpdateValue()] [LIB Calculation Cross-Term] ProcessUpdateValue calculates LIB using currentRound and previousRound. During a term transition processed by ProcessNextTerm, if LIB calculation happens immediately after, can it use rounds from different terms, causing invalid LIB heights? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessTinyBlock() + ResetLatestProviderToTinyBlocksCount()] [Tiny Block Limit Bypass] ProcessTinyBlock increments ProducedTinyBlocks unconditionally, while ResetLatestProviderToTinyBlocksCount manages the limit. If ResetLatestProviderToTinyBlocksCount executes after ProcessTinyBlock in the same transaction, can the miner produce one extra tiny block beyond the limit? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation() VRF Verification] [Random Number Reuse] If multiple consensus transactions in consecutive blocks use the same previousRandomHash (due to failed VRF verification in prior blocks), can this allow miners to precompute valid randomNumber values and manipulate consensus outcomes? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextRound() + GetLatestSignature()] [Signature Initialization Attack] GetLatestSignature() may return null during the first rounds. If ProcessNextRound or other functions rely on non-null signatures for cryptographic operations, can the null signature cause verification bypasses or exceptions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm() + RecordMinedMinerListOfCurrentRound()] [Miner List Cleanup During Term Transition] RecordMinedMinerListOfCurrentRound removes round data for roundNumber - 3. During a term transition where round numbers reset or jump, can this cleanup logic delete the wrong round data or fail to clean up properly? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessConsensusInformation() + ProcessUpdateValue()] [Collusion Attack on LIB] If 51% of miners collude and provide coordinated ImpliedIrreversibleBlockHeight values in ProcessUpdateValue, can they force LastIrreversibleBlockHeightCalculator to confirm invalid blocks by manipulating the LIB calculation threshold? (Critical)"
]