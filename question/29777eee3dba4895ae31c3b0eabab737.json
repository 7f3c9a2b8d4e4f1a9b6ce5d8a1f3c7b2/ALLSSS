[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Integer Overflow] If currentBlockTimestamp is manipulated to be very large, could line 23 cause BlockchainAge overflow when calculating (currentBlockTimestamp - blockchainStartTimestamp).Seconds, leading to incorrect age tracking and consensus state corruption? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [State Inconsistency] If isMinerListChanged is set to true but the actual miner list remains the same, could line 14 create a round with IsMinerListJustChanged=true that triggers incorrect state transitions in dependent contracts expecting actual list changes? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Round Number Manipulation] If RoundNumber at line 21 approaches max integer value, could incrementing cause overflow leading to RoundNumber=0 in nextRound, breaking round progression invariants and allowing replay of round 0 logic? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Mining Interval Attack] If GetMiningInterval() at line 20 returns 0 or negative value, could lines 33 and 51 set all ExpectedMiningTime to currentBlockTimestamp, causing all miners to have identical time slots and breaking consensus ordering? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Order Collision] If multiple miners in minersMinedCurrentRound have the same FinalOrderOfNextRound value, could line 29 overwrite RealTimeMinersInformation entries, causing some miners to be excluded from the next round and breaking miner count invariants? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Invalid FinalOrderOfNextRound] If a miner's FinalOrderOfNextRound is 0 or exceeds minersCount at line 28, could this create invalid order assignments that are not caught in occupiedOrders filtering at line 40, leading to duplicate orders or missing miners? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Negative Order Assignment] If FinalOrderOfNextRound contains negative values, could lines 26-36 assign negative orders to miners, bypassing ableOrders range check (line 41) and corrupting the mining schedule? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Timestamp Multiplication Overflow] If miningInterval.Mul(order) at line 33 overflows when order is large, could ExpectedMiningTime wrap to a past timestamp, allowing miners to claim their slot has passed and skip mining without penalty? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Miner Count Mismatch] If minersMinedCurrentRound.Count + minersNotMinedCurrentRound.Count != minersCount at line 18, could ableOrders at line 41 have insufficient elements for line 44 assignment, causing index out of bounds or incomplete round generation? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [MissedTimeSlots Overflow] If minerInRound.MissedTimeSlots.Add(1) at line 54 causes integer overflow for miners who haven't mined for many consecutive rounds, could this wrap to 0 and reset penalty tracking, allowing malicious miners to avoid punishment? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [ProducedBlocks Manipulation] Lines 34 and 52 copy ProducedBlocks from current round without validation - if an attacker manipulates ProducedBlocks to max value, could overflow occur in future rounds when incrementing, breaking block production statistics? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [ableOrders Exhaustion] If occupiedOrders contains values outside [1, minersCount] range, could line 41's Where filter produce more ableOrders than needed, and if accessed at wrong index at line 44, assign incorrect orders to non-mining miners? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Extra Block Producer Null Assignment] If CalculateNextExtraBlockProducerOrder() at line 59 returns an order with no corresponding miner, lines 62-63 assign IsExtraBlockProducer to .First() miner - could this deterministically favor first miner and create unfair extra block rewards? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [IrreversibleBlock State Copying] Lines 69-70 copy ConfirmedIrreversibleBlockHeight/RoundNumber without validation - if current round has corrupted LIB values, could this propagate incorrect irreversibility to nextRound, breaking finality assumptions? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [BreakContinuousMining Side Effects] If BreakContinuousMining at line 67 throws exception or corrupts nextRound state, could the function return with partial round data since nextRound is passed by ref, leaving inconsistent mining schedule? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [TermNumber Increment Missing] Line 22 copies TermNumber without incrementing - if term transitions should occur based on miner list changes (isMinerListChanged=true), could keeping same TermNumber violate term boundary invariants? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Empty Miner List DOS] If RealTimeMinersInformation.Count is 0 at line 18, GetMiningInterval could fail, and lines 26-56 would not execute, producing an empty nextRound with only metadata - could this freeze consensus by creating unpopulated rounds? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Pubkey Collision] If two miners have identical Pubkey values, could dictionary assignment at lines 29 and 46 overwrite entries, reducing actual miner count in nextRound below expected minersCount and breaking consensus safety threshold? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Order Sorting Instability] If multiple miners have the same FinalOrderOfNextRound, could OrderBy at line 26 produce non-deterministic ordering across nodes, causing different nodes to generate different nextRound states and consensus fork? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [BlockchainAge Negative Value] If currentBlockTimestamp < blockchainStartTimestamp at line 23 due to clock skew or timestamp manipulation, could BlockchainAge become negative, violating non-decreasing time invariants and breaking time-based logic? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Single Miner Bypass] Line 76 returns early if minersCount <= 1 - could an attacker reduce miner count to 1 to bypass continuous mining checks, allowing single miner to produce all blocks including extra blocks without rotation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [First Miner Assumption] Line 79 uses First(i => i.Order == 1) assuming order 1 exists - if all miners have Order != 1 due to corruption, could this throw exception and prevent round generation, causing consensus halt? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Timestamp Swap Attack] Lines 87-89 swap ExpectedMiningTime between first and second miners - if an attacker manipulates timestamps before swap, could they control both positions and still mine consecutively? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Order Update Without Validation] Lines 85-86 directly modify Order values without checking if new orders already exist in other miners - could this create duplicate Order=1 or Order=2 assignments if state is corrupted? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Last Miner Null Check] Line 95 returns if lastMinerOfNextRound is null - could this occur if no miner has Order == minersCount, allowing continuous mining at round boundary when last position is undefined? (High)"
]