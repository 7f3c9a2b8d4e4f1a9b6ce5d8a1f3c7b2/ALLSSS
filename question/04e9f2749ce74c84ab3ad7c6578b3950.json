[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Negative Signature Handling] If sigNum at line 119 is negative (since ToInt64() returns signed), could GetAbsModulus at line 121 behave differently than expected, biasing extra block producer selection toward certain miners? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Signature Reuse Attack] If same signature value appears in multiple rounds, line 118 would produce same sigNum, potentially selecting same extra block producer repeatedly - could this be exploited by grinding signatures? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [IsMinerListJustChanged Flag Accuracy] Line 14 sets IsMinerListJustChanged based on parameter but doesn't validate actual list changes - could incorrect flag cause dependent contracts to process unchanged list as changed, triggering unnecessary state updates? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Partial Update Rollback] If exception occurs after lines 26-56 populate nextRound but before BreakContinuousMining at line 67, could partially constructed nextRound be persisted, creating inconsistent consensus state? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [RealTimeMinersInformation Mutation] Lines 29 and 46 add to nextRound.RealTimeMinersInformation dictionary - if concurrent access occurs, could race conditions create duplicate or missing entries? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Ref Parameter Side Effects] Passing nextRound by ref at line 67 means all modifications affect caller's object - if caller expects immutable nextRound, could unexpected mutations break assumptions? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [BlockchainAge Monotonicity] Line 23 calculates BlockchainAge as seconds since start - if currentBlockTimestamp is manipulated to decrease, could BlockchainAge go backwards, breaking monotonicity assumptions in dependent logic? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [MissedTimeSlots Penalty Avoidance] Line 54 increments MissedTimeSlots for non-mining miners - if a miner can manipulate their SupposedOrderOfNextRound to appear in minersMinedCurrentRound, could they avoid penalty accumulation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation()] [Order Advantage Exploitation] Lines 26-36 assign orders based on FinalOrderOfNextRound for miners who mined - if early orders have advantages (less competition, better rewards), could miners manipulate FinalOrderOfNextRound to consistently get favorable positions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Extra Block Producer Centralization] If first miner at line 113 is consistently same entity controlling multiple nodes, their signature always determines extra producer, could this centralize extra block rewards to colluding parties? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Swap Avoidance Strategy] Miners could analyze when they'd be swapped at lines 81 or 98 and intentionally skip blocks to avoid being in swap-triggering positions, could this game continuous mining prevention? (Medium)"
]