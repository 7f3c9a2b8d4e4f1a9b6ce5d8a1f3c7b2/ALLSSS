[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: GetTransactionFeeSymbols()] [Duplicate Symbol] The function checks !symbols.Contains(methodFee.Symbol) before adding, but if State.TransactionFees[methodName].Fees contains duplicates, does this create fee calculation inconsistencies? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: GetTransactionFeeSymbols()] [Early Return] If State.TransactionFees[methodName].IsSizeFeeFree is true, the function returns symbols early without adding size fee symbols - can this be exploited to avoid paying size fees for methods that should require them? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: GetTransactionFeeSymbols()] [Null Check] If State.SymbolListToPayTxSizeFee.Value is null, the function returns early - can this be triggered deliberately to avoid size fees for all transactions? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: GetTransactionFeeSymbols()] [Zero Fee Bypass] The condition methodFee.BasicFee > 0 excludes zero-fee tokens from the symbol list - can an attacker set BasicFee=0 to bypass fee charging while keeping the token in the fee configuration? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: GetTransactionFeeSymbols()] [List Manipulation] Can the symbols list grow unboundedly if SetMethodFee() is called repeatedly with different token symbols, causing DOS during fee collection? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: GetTransactionFeeSymbols()] [Size Fee Confusion] When merging method fees and size fees, if both contain the same symbol with different amounts, which amount is used for fee charging? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: RequiredMethodFeeControllerSet()] [Initialization Bypass] If State.MethodFeeController.Value is already set to a malicious value, the early return at line 93 prevents correction - can this lock in a bad controller permanently? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: RequiredMethodFeeControllerSet()] [Contract Resolution] Context.GetContractAddressByName() could return null or an incorrect address - is there validation that State.ParliamentContract.Value is actually the Parliament contract before using it? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: RequiredMethodFeeControllerSet()] [Default Authority Risk] If Parliament contract is not deployed (line 101), defaultAuthority is set with empty OwnerAddress and null ContractAddress - does this create an authorization bypass where any sender passes the owner check? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: RequiredMethodFeeControllerSet()] [External Call Trust] The call to State.ParliamentContract.GetDefaultOrganizationAddress could be manipulated if the Parliament contract is compromised - is there any validation of the returned address? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: RequiredMethodFeeControllerSet()] [State Consistency] After setting State.MethodFeeController.Value to defaultAuthority, are there any events emitted to track this critical governance change? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: RequiredMethodFeeControllerSet()] [Timing Issue] Can RequiredMethodFeeControllerSet() be called multiple times concurrently during initialization, creating race conditions in controller setup? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertSenderAddressWith()] [Null Address] If the input address parameter is null or zero address, does Context.Sender == address evaluate to true or false, and can this be exploited for authorization bypass? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertSenderAddressWith()] [Error Message] The generic error message 'Unauthorized behavior.' doesn't specify which operation failed - could this make debugging legitimate authorization issues more difficult? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: CheckOrganizationExist()] [Contract Call Trust] The function makes an external call to authorityInfo.ContractAddress - if this address is a malicious contract, can it return true for any organization address to bypass validation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: CheckOrganizationExist()] [Method Name String] The method name is passed as a string nameof(...) - can an attacker create a contract with this method name that always returns true to fake organization existence? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: CheckOrganizationExist()] [Re-entrancy] Can the Context.Call enable re-entrant calls back to the TokenContract during organization validation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: CheckOrganizationExist()] [Return Value Trust] Does the function validate that the BoolValue returned is actually a valid protobuf message, or can a malicious contract return corrupted data? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: CheckOrganizationExist()] [Error Handling] If Context.Call throws an exception, is it caught and handled, or does it cause the entire ChangeMethodFeeController() transaction to revert? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertValidFeeToken()] [Token Info Null] If GetTokenInfo(symbol) returns null, an AssertionException is thrown - can an attacker cause DOS by repeatedly attempting to set fees with non-existent tokens? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertValidFeeToken()] [IsBurnable Check] The function only checks tokenInfo.IsBurnable but not other critical properties - can an attacker set fees using a token that exists but has zero total supply or is disabled? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertValidFeeToken()] [Symbol Case Sensitivity] Is the symbol parameter case-sensitive, and can an attacker set fees using 'elf' vs 'ELF' to create confusion in fee charging? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertValidFeeToken()] [Amount Validation] The function calls AssertValidSymbolAndAmount(symbol, amount) first - if amount is negative or zero, is it caught, or can zero-fee tokens be set? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Function: AssertValidFeeToken()] [External Token] If the token is an external cross-chain token, does the IsBurnable check work correctly, or could this allow non-burnable external tokens to be set as fee tokens? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs] [Cross-Function] [State Manipulation] Can an attacker call SetMethodFee() to set fees for GetMethodFee() itself, creating a recursive fee structure that causes infinite loops during fee calculation? (High)"
]