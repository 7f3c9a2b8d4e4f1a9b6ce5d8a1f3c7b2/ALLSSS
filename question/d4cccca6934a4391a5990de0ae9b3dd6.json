[
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NumberMinLength] [Validation Bypass] Can the NumberMinLength value of 9 be bypassed during symbol generation in GetCurrentNumberLength(), allowing creation of protocols with shorter or longer symbol numbers than intended, potentially causing collision with existing symbols or breaking symbol format assumptions? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NumberMinLength] [Integer Overflow] In GetCurrentNumberLength() where NumberMinLength initializes CurrentSymbolNumberLength, can the multiplication logic (protocolNumber.Mul(10)) eventually overflow when symbol number length grows unbounded, causing symbol generation failures or collisions? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NumberMinLength] [DOS Attack] If NumberMinLength is too small (9 digits = 1B combinations), can an attacker exhaust the symbol space by creating protocols until GenerateSymbolNumber() enters infinite loop when all symbols are taken? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NumberMinLength] [State Inconsistency] Can mismatch between hardcoded NumberMinLength and actual CurrentSymbolNumberLength state cause symbol generation to produce invalid formats that break token creation or cross-chain verification? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTypeMetadataKey] [Metadata Injection] In GetTokenExternalInfo(), can an attacker provide input.Metadata containing 'aelf_nft_type' key that gets overwritten, but then manipulated in CrossChainCreate() where it's read from tokenInfo.ExternalInfo without proper validation? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTypeMetadataKey] [Type Confusion] Can an attacker create a protocol with invalid NftType in metadata, then in CrossChainCreate() the code reads nftTypeFullName from symbol prefix but trusts ExternalInfo values, causing type mismatch between protocol info and actual token type? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTypeMetadataKey] [Authorization Bypass] Since NftTypeMetadataKey is reserved in GetNftMetadataReservedKeys(), can an attacker bypass this check during Mint() or Recast() by providing metadata that overwrites protocol-level NFT type, changing token classification post-creation? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTypeMetadataKey] [Cross-Chain Inconsistency] In CrossChainCreate(), can NFT type metadata mismatch between mainchain and sidechain lead to protocol info corruption if tokenInfo.ExternalInfo[NftTypeMetadataKey] differs from actual protocol NFT type? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftBaseUriMetadataKey] [URI Manipulation] In GetTokenExternalInfo(), baseUri is stored in ExternalInfo, then in CrossChainCreate() it's read without validation - can attacker inject malicious URIs containing scripts, redirects, or data:// schemes that violate URI format assumptions? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftBaseUriMetadataKey] [Metadata Override] Can an attacker provide input.Metadata with 'aelf_nft_base_uri' key during Create() that gets overwritten by input.BaseUri, but then exploited in CrossChainCreate() where it's sourced from ExternalInfo without cross-validation? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftBaseUriMetadataKey] [Reserved Key Bypass] Is NftBaseUriMetadataKey properly checked in AssertMetadataKeysAreCorrect() during Mint(), Assemble(), and Recast() operations to prevent users from overriding protocol-level baseUri values with custom metadata? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftBaseUriMetadataKey] [State Desync] Can baseUri in ExternalInfo diverge from baseUri in NFTProtocolInfo state if CrossChainCreate() reads from token but doesn't validate consistency, causing GetNFTInfo() to return wrong URI values? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTokenIdReuseMetadataKey] [Boolean Parsing] In CrossChainCreate(), bool.Parse() is used without try-catch for NftTokenIdReuseMetadataKey - can an attacker provide non-boolean string values in ExternalInfo causing parse exception that breaks protocol creation? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTokenIdReuseMetadataKey] [Token ID Collision] If IsTokenIdReuse flag is incorrectly set or tampered in ExternalInfo, can PerformMint() logic fail to prevent token ID collisions when it should, or wrongly reject valid mints when ID reuse is allowed? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTokenIdReuseMetadataKey] [Burn Logic Bypass] In Burn(), the check 'if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true' relies on IsTokenIdReuse flag - can metadata manipulation cause burned tokens to be re-mintable when they shouldn't be? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTokenIdReuseMetadataKey] [Cross-Chain Desync] Can IsTokenIdReuse flag differ between mainchain ExternalInfo and sidechain protocol state after CrossChainCreate(), causing mint operations to behave inconsistently across chains? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTokenIdReuseMetadataKey] [Reserved Key Protection] Is NftTokenIdReuseMetadataKey properly blocked in metadata inputs during Mint() and Recast() to prevent users from changing token ID reuse policy after protocol creation? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledNftsKey] [Metadata Injection] In Assemble(), metadata.Value[AssembledNftsKey] is set from input.AssembledNfts.ToString() - can attacker provide custom metadata with this key that gets overwritten, then exploited in Disassemble() if parsing logic trusts metadata content? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledNftsKey] [State Inconsistency] Can AssembledNftsKey in NFTInfo.Metadata diverge from State.AssembledNftsMap[tokenHash] if Assemble() updates both but Recast() allows metadata modification, causing Disassemble() to return wrong NFTs? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledNftsKey] [Reserved Key Bypass] Is AssembledNftsKey properly validated in AssertMetadataKeysAreCorrect() during Mint() and Recast() to prevent users from manually adding assembled NFT data to non-assembled tokens? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledNftsKey] [Serialization Attack] When Assemble() stores input.AssembledNfts.ToString() in metadata, can attacker manipulate protobuf serialization to inject malicious data that causes Disassemble() to transfer wrong NFT amounts or addresses? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledFtsKey] [Metadata Tampering] Similar to AssembledNftsKey, can metadata.Value[AssembledFtsKey] be manipulated between Assemble() and Disassemble() operations if Recast() doesn't properly preserve reserved metadata keys? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledFtsKey] [Double Spend] If State.AssembledFtsMap[tokenHash] and metadata[AssembledFtsKey] become inconsistent, can Disassemble() transfer FTs while metadata claims different amounts, or can attacker disassemble twice? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledFtsKey] [Cross-Function Validation] Is AssembledFtsKey properly blocked in GetNftMetadataReservedKeys() to prevent Mint() from creating tokens with assembled FT metadata without actually locking those FTs? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: AssembledFtsKey] [Serialization Integrity] Can attacker provide malformed AssembledFts data that successfully stores in metadata but causes Disassemble() to fail or transfer incorrect token amounts? (Medium)"
]