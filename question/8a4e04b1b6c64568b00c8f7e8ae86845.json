[
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetWelfareRewardAmountSample()] [Native Symbol Hardcode] Line 357 only calculates for Context.Variables.NativeSymbol - if treasury holds multiple tokens per SymbolList, can this underreport total welfare value? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetUndistributedDividends()] [Virtual Address Balance Query] Lines 373-378 query balances of TreasuryVirtualAddress - if this address was computed incorrectly in InitialMiningRewardProfitItem or collides with another address, can this return attacker-controlled balances? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetUndistributedDividends()] [Symbol List Inconsistency] Uses State.SymbolList.Value which can be changed via SetSymbolList - can this cause undistributed balances of removed symbols to be hidden from users? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: RecordMinerReplacement()] [Authorization Check] Line 576 only verifies sender is ConsensusContract - if consensus contract address can be manipulated or is not set, can any address record fake replacements? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: RecordMinerReplacement()] [Evil Miner Flag Abuse] Lines 583-594 branch on IsOldPubkeyEvil - can an attacker trigger both branches by calling multiple times with same NewPubkey but different OldPubkey, accumulating in both LatestMinedTerm and ReplaceCandidateMap? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: RecordMinerReplacement()] [Latest Mined Term Transfer] Lines 585-587 transfer latestMinedTerm from old to new pubkey - if OldPubkey was never a miner (latestMinedTerm=0), does NewPubkey incorrectly qualify for welcome rewards? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: RecordMinerReplacement()] [Replace Candidate Accumulation] Lines 591-593 add NewPubkey to ReplaceCandidateMap without checking for duplicates - can multiple evil miner replacements in same term cause NewPubkey to appear multiple times, claiming multiple shares of welcome rewards? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: RecordMinerReplacement()] [IsReplacedEvilMiner Flag Persistence] Line 596 sets flag to true but only cleared in UpdateBasicMinerRewardWeights at line 807 - if UpdateBasicMinerRewardWeights is never called for that miner, can the flag persist and give preferential share calculations indefinitely? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetProfitsReceiver()] [Admin Authorization] Lines 608-609 check Context.Sender == admin from GetCandidateAdmin - if admin address is zero or corrupted, can anyone claim to be admin and set profits receiver to drain candidate rewards? (Critical)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetProfitsReceiver()] [Candidate Verification Timing] Lines 611-612 verify pubkey is in candidate list - can an attacker set profits receiver, then immediately quit as candidate, but continue receiving rewards through stale ProfitsReceiverMap entry? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetProfitsReceiver()] [Same Receiver Early Return] Lines 616-619 return early if receiver unchanged - but this skips the SetProfitsReceiver call to ElectionContract at line 621 - can this cause state desync between Treasury and Election contracts? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetProfitsReceiver()] [Previous Receiver Migration] Lines 614-625 pass previousProfitsReceiver to ElectionContract - if previousProfitsReceiver is null, line 625 passes new Address() - can this cause ElectionContract to fail to migrate beneficiary shares properly? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: SetProfitsReceiver()] [Pubkey to ByteString Conversion] Line 606 converts hex string to ByteString - if input.Pubkey is malformed or invalid hex, can this cause silent failures or incorrect candidate lookups? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ReplaceCandidateProfitsReceiver()] [Election Contract Only] Line 633 checks sender is ElectionContract - if ElectionContract address is not set or reset, can this function become uncallable, blocking miner replacements from updating profit receivers? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ReplaceCandidateProfitsReceiver()] [Receiver Transfer Without Validation] Lines 635-637 blindly transfer profitReceiver from OldPubkey to NewPubkey - if profitReceiver is null, does NewPubkey get null receiver causing future rewards to fail? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ReplaceCandidateProfitsReceiver()] [Old Pubkey State Cleanup] Line 636 removes OldPubkey entry - if OldPubkey was replaced multiple times, can removing too early cause loss of receiver mapping needed for pending reward claims? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: UpdateMiningReward()] [Consensus Authorization] Lines 544-546 check sender is ConsensusContract - if consensus contract address changes or is not initialized, can this block all mining reward updates, freezing GetDividends calculations? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: UpdateMiningReward()] [Mining Reward Value Validation] Line 547 sets State.MiningReward.Value = input.Value without any bounds checking - can ConsensusContract pass negative or MaxInt values to manipulate GetDividends calculations at line 558? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: UpdateMiningReward()] [Reward Overwrite] Each call overwrites previous MiningReward value - if ConsensusContract calls this multiple times per block, can only last value persist, losing track of total mining rewards for that block? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetDividends()] [Future Block Query] Line 553 asserts CurrentHeight > input.Value - but if input.Value == CurrentHeight, can this allow querying dividends of current block before UpdateMiningReward is called, returning stale data? (Low)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetDividends()] [Donation vs Mining Reward Addition] Lines 556-568 add MiningReward to donated dividends - if DonatedDividends already contains native symbol from Donate(), line 558 adds them, but what if Donate() called multiple times - is sum correct? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: GetDividends()] [Block Height Key Lookup] Uses input.Value as block height key - if block was orphaned/reorganized, can this return dividends from uncle block that were never actually contributed? (Medium)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ConvertToNativeToken()] [Approval Before Sell] Lines 669-674 approve TokenConverter for full amount - if Sell at line 676 fails or converts less than amount due to slippage, can approved but unconverted tokens be stolen by TokenConverter reentrancy? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ConvertToNativeToken()] [Inline DonateAll Call] Lines 682-685 call DonateAll inline using Context.Self as sender - can this bypass the Context.Sender check in Donate at line 194, causing recursive or unexpected behavior? (High)",
  "[File: contract/AElf.Contracts.Treasury/TreasuryContract.cs] [Function: ConvertToNativeToken()] [Sell Amount Validation] Line 676 calls Sell with full amount without checking TokenConverter reserves - can this revert due to insufficient liquidity, blocking donation of that token permanently? (Medium)"
]