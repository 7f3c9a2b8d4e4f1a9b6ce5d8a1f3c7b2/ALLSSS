[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Array Out of Bounds] Can an attacker pass an empty string symbol causing words array to have zero length, resulting in words[0] access throwing IndexOutOfRangeException before the Assert on line 10, leading to transaction reversion and potential DOS? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Array Access Before Validation] Line 10 accesses words[0] before validating words.Length - if Split() returns empty array for edge case inputs, can this cause uncaught exceptions bypassing the Assert statement and creating inconsistent error handling? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Missing Length Validation] Line 12 asserts words.Length == 2, but what if words.Length > 2 (e.g., 'ABC-1-2-3')? Can attacker create symbols with multiple separators that pass initial validation but fail later assertions, causing inconsistent state or transaction failures? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Array Indexing Logic] Line 13 accesses words[1] after asserting words.Length == 2 on line 12, but what if the assertion logic is modified or bypassed in future updates? Can this create a latent vulnerability in symbol type classification? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Split Edge Case] Line 9 splits by NFTSymbolSeparator ('-') - can an attacker craft a symbol starting with '-' (e.g., '-ABC') causing words[0] to be empty string, which passes Length > 0 check but fails IsValidCreateSymbol, leading to inconsistent validation? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Split Edge Case] Can symbol ending with separator (e.g., 'ABC-') create words array where words[1] is empty, bypassing length check on line 12 but failing IsValidItemId, causing validation inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Multiple Separators] Symbol 'ABC--1' with consecutive separators creates empty string in words array - does this bypass validation and allow creation of malformed NFT symbols that could break allowance or transfer logic? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Unicode Separator] Can attacker use Unicode lookalike characters for '-' separator (e.g., em-dash, en-dash, minus sign) to create symbols that appear valid but Split() doesn't recognize, causing type misclassification? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Collection Suffix Comparison] Line 13 compares words[1] with CollectionSymbolSuffix ('0') using == operator - can attacker exploit case sensitivity or whitespace (e.g., ' 0', '0 ', 'Ôºê' full-width) to bypass collection detection? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Leading Zeros] Symbol 'ABC-00' or 'ABC-000' has leading zeros - does IsValidItemId accept this? If so, are these treated as NFT items instead of collections, allowing duplicate collection creation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Numeric Collection Logic] Line 13 only checks exact match with '0' - what about 'ABC-0000000000000000000000000000'? Does IsValidItemId validate max length, or can attacker create collision between collection and NFT item IDs? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Type Confusion] Can attacker register 'ABC-0' as NftCollection, then create 'ABC-00' which GetSymbolType classifies as Nft, bypassing collection ownership checks and creating unauthorized NFT items? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [IsValidCreateSymbol Bypass] Line 10 calls IsValidCreateSymbol which uses regex '^[a-zA-Z0-9]+$' - can attacker include separator in symbol prefix (e.g., 'A-B-1') where 'A-B' fails regex, but error message is misleading about which validation failed? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [IsValidItemId Bypass] Line 12 calls IsValidItemId using regex '^[0-9]+$' - does this accept leading zeros like '007' or scientific notation '1e5', allowing attacker to create ambiguous NFT item identifiers? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Regex Consistency] GetSymbolType uses IsValidCreateSymbol for prefix and IsValidItemId for suffix, but AssertApproveToken on line 60 of TokenContract_Helper.cs uses IsValidCreateSymbol OR AllSymbolIdentifier - can this inconsistency allow approval of symbols that GetSymbolType would reject? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Validation Order] Line 10 validates words[0] with IsValidCreateSymbol before checking words.Length == 1 on line 11 - if symbol is 'ABC-xyz' where 'xyz' is non-numeric, does validation fail with confusing error about prefix instead of invalid NFT format? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Token Classification] Line 11 returns SymbolType.Token for single-word symbols - can attacker create regular token 'ABC' then later try to create 'ABC-0' collection, causing conflict in token registry or allowing collection to override existing token? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [NFT vs Collection Distinction] Line 13 distinguishes NftCollection (ends with '0') from Nft (any other number) - but CreateNFTInfo requires collection to exist first. Can attacker exploit timing to create 'ABC-1' before 'ABC-0', bypassing collection creation requirements? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Type Downgrade] If GetSymbolType returns NftCollection for 'ABC-0', but later code treats it as regular token, can attacker bypass NFT-specific validations like owner checks, minter restrictions, or external info requirements? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Type Upgrade] If symbol initially classified as Token, can attacker later append '-0' to upgrade it to NftCollection without proper validation, allowing creation of NFT collection from existing fungible token symbol? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Create Routing] TokenContract_Actions.cs line 35 uses GetSymbolType to route to CreateNFTCollection, CreateNFTInfo, or CreateToken - can attacker craft symbol that GetSymbolType misclassifies, routing to wrong creation function and bypassing validation? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Collection Creation Bypass] If GetSymbolType incorrectly returns SymbolType.Token for 'ABC-0', Create() routes to CreateToken instead of CreateNFTCollection - can this bypass collection-specific validations like NFT create chain ID checks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [NFT Creation Without Collection] If GetSymbolType returns SymbolType.Nft for 'ABC-1' but collection 'ABC-0' doesn't exist, CreateNFTInfo calls AssertNftCollectionExist - but can race condition allow NFT creation before collection, violating invariant? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [SEED Token Classification] CreateNFTInfo checks if collection is SEED-0 on line 37 - if GetSymbolType misclassifies SEED symbols, can attacker bypass owned symbol validation and create unlimited SEED NFTs? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Allowance Hierarchy] GetAvailableAllowance on line 79-86 of TokenContract_Views.cs uses GetSymbolType to check collection-level allowances for NFTs - can attacker exploit type misclassification to use token allowances for NFTs or vice versa? (High)"
]