[
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateCandidateInformation()] [Candidates List Corruption] Lines 108-110 remove from Candidates.Value without checking if pubkey exists - can removing non-existent entries corrupt the list structure? (Low)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateCandidateInformation()] [RemoveBeneficiary Failure] Line 111 calls RemoveBeneficiary(input.Pubkey) - if this external call fails, are the previous state updates (banned, removed from lists) still committed, creating inconsistent profit distribution state? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateCandidateInformation()] [IsEvilNode Without Proof] No validation of why input.IsEvilNode is true - can the consensus contract maliciously mark any node as evil without providing evidence of misbehavior? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: GetEmergencyResponseOrganizationAddress()] [Caching Attack] Lines 124-125 cache EmergencyResponseOrganizationAddress - if Parliament contract's emergency org changes, can the cached stale address be exploited to maintain unauthorized access? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: GetEmergencyResponseOrganizationAddress()] [Parliament Contract Null] Line 131 calls GetEmergencyResponseOrganizationAddress without validating Parliament contract is initialized - can this fail silently if called before Parliament deployment? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: GetEmergencyResponseOrganizationAddress()] [No Cache Invalidation] Once cached, EmergencyResponseOrganizationAddress never updates - can a compromised emergency org maintain permanent control even after governance revokes it? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMultipleCandidateInformation()] [Batch Processing DOS] Lines 143-144 iterate input.Value without limit - can an attacker pass millions of entries to exceed gas limits and prevent legitimate consensus updates? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMultipleCandidateInformation()] [Partial Update Failure] If UpdateCandidateInformation fails for entry N but succeeds for entries 1 to N-1, are the successful updates committed while later ones fail, creating inconsistent candidate states? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMultipleCandidateInformation()] [Authorization Only Consensus] Line 140 restricts to consensus contract only - but UpdateCandidateInformation allows EmergencyResponseOrganization too - can this create an authorization bypass path? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMultipleCandidateInformation()] [Duplicate Entries] No deduplication of input.Value - can passing the same UpdateCandidateInformationInput multiple times cause double-counting of ProducedBlocks/MissedTimeSlots? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMinersCount()] [Miners Count Decrease Attack] Line 158 calls SyncSubsidyInfoAfterReduceMiner which can remove DataCenters - can the consensus contract repeatedly decrease MinersCount to eliminate all backup subsidy receivers? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMinersCount()] [Zero Miners Count] No validation preventing input.MinersCount = 0 - can setting MinersCount to 0 halt the consensus system entirely? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMinersCount()] [MinersCount Overflow] No check on upper bound of input.MinersCount - can setting it to int.MaxValue cause resource exhaustion when iterating miners? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMinersCount()] [Authorization Only Consensus] Line 154-156 only allows consensus contract - but what if consensus contract is compromised and sets MinersCount to 1 to centralize the network? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: UpdateMinersCount()] [SyncSubsidyInfoAfterReduceMiner Failure] If SyncSubsidyInfoAfterReduceMiner fails after MinersCount is updated, does the count remain changed while subsidy state is inconsistent? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: SetTreasurySchemeIds()] [No Authorization Check] Function has no sender validation - can any address call this to set malicious Treasury/Welfare/Subsidy hashes after deployment? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: SetTreasurySchemeIds()] [One-Time Only] Line 164 checks TreasuryHash == null but once set, these cannot be changed - if wrong values are set, can treasury distributions be permanently broken? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: SetTreasurySchemeIds()] [Hash Collision] No validation that input hashes are unique - can attacker set all five hashes to the same value, causing multiple profit schemes to point to the same pool? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: SetTreasurySchemeIds()] [Invalid Hash] No validation that hashes correspond to actual profit schemes - can setting non-existent scheme IDs cause DistributeProfits calls to fail silently? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: SetTreasurySchemeIds()] [Front-Running] Since there's no auth check, can an attacker front-run the legitimate SetTreasurySchemeIds call to permanently set wrong scheme IDs? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: ReplaceCandidatePubkey()] [Admin Bypass] Line 181 checks Context.Sender == GetCandidateAdmin - if CandidateAdmin mapping can be manipulated or is uninitialized, can an attacker replace any candidate's pubkey? (Critical)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: ReplaceCandidatePubkey()] [Banned Pubkey Replacement] Lines 177-178 check both old and new pubkeys aren't banned, but line 246 bans old pubkey AFTER replacement - can the old pubkey be used again if it's already in BannedPubkeyMap? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: ReplaceCandidatePubkey()] [Candidates List Manipulation] Lines 192-197 remove old and add new pubkey to Candidates - if new pubkey already exists, the Assert fails, but can partially updated state from previous operations be exploited? (Medium)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: ReplaceCandidatePubkey()] [DataCentersRankingList State Inconsistency] Lines 199-218 update ranking list and beneficiaries only if old pubkey exists in DataCenters - if pubkey exists in Candidates but not DataCenters, are benefits leaked? (High)",
  "[File: contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs] [Function: ReplaceCandidatePubkey()] [RemoveBeneficiary Then AddBeneficiary Race] Lines 216-217 remove then add beneficiary - can a reentrant call during RemoveBeneficiary interfere with AddBeneficiary, causing lost profit shares? (High)"
]