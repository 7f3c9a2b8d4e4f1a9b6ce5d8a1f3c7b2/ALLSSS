[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Scientific Notation] Can 'ABC-1e10' pass IsValidItemId regex? If scientific notation is accepted, does later parsing convert to actual number, creating NFT item with ID 10000000000? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [AssertApproveToken Divergence] AssertApproveToken on line 54-74 of TokenContract_Helper.cs has different validation logic including AllSymbolIdentifier support - can this inconsistency allow approval of symbols that GetSymbolType would reject? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [IsValidSymbol vs GetSymbolType] IsValidSymbol on line 18-21 uses regex '^[a-zA-Z0-9]+(-[0-9]+)?$' allowing optional numeric suffix, but GetSymbolType enforces specific NFT format - can symbols pass IsValidSymbol but fail GetSymbolType, or vice versa? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [GetCollectionSymbol Logic] GetCollectionSymbol on line 76-79 constructs collection symbol by appending '-0', but GetSymbolType parses existing symbols - can mismatch between construction and parsing create duplicate or invalid collection symbols? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [GetNftCollectionSymbol Divergence] GetNftCollectionSymbol on line 153-161 of TokenContract_NFT_Actions.cs returns null for tokens but has different logic than GetSymbolType - can this inconsistency cause one function to classify as Token while other expects NFT? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Read-Only Function] GetSymbolType is read-only and stateless - but if called during state-modifying operations, can inconsistent state (mid-transaction) cause GetSymbolType to return different results for same symbol? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Callback Reentrancy] If GetSymbolType is called during external callback (DealWithExternalInfoDuringTransfer), can reentrant call see inconsistent symbol type due to partial state updates? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Cross-Contract Calls] GetSymbolType uses IsValidCreateSymbol and IsValidItemId which are pure functions - but if future modifications make them stateful, can reentrancy during GetSymbolType cause classification errors? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Classification Caching] GetSymbolType result is not cached - if called multiple times in same transaction, can state changes between calls cause different results, violating transaction atomicity? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [No Comments] Function has no documentation explaining classification logic - can future developers misunderstand behavior and introduce bugs in dependent code? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Magic Number] CollectionSymbolSuffix '0' is magic string without inline explanation - can this be confused with itemId '0', causing developers to create logic bugs in collection handling? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs] [Function: GetSymbolType()] [Separator Hardcoded] NFTSymbolSeparator is constant but used implicitly on line 9 - if constant value changes, does GetSymbolType need updates, or can stale separator cause parsing failures? (Low)"
]