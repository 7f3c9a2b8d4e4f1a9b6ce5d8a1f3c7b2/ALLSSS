[
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: BurnProfits()] [Negative Amount] Line 551 stores -amount in AmountsMap. Can negative values in DistributedProfitsInfo corrupt subsequent profit calculations that assume non-negative amounts? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: BurnProfits()] [Virtual Transfer] Lines 539-545 use SendVirtualInline to transfer from scheme virtual address. Can reentrancy during this call manipulate state before burn completes at line 546-550? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: UpdateDistributedProfits()] [Balance Accumulation] Line 579 adds current balance to amount for DistributedProfitsInfo. If tokens were contributed directly to period virtual address, can this double-count them with ContributeProfits amounts? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: UpdateDistributedProfits()] [TotalShares Override] Line 567 sets TotalShares to the passed value. If this differs from scheme.TotalShares due to delay cache, can it cause profit calculation mismatches where shares don't sum correctly? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: UpdateDistributedProfits()] [IsReleased Flag] Line 568 sets IsReleased=true unconditionally. Can this prevent future ContributeProfits to the same period (line 698-699 check), even if PerformDistributeProfits fails after UpdateDistributedProfits? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: PerformDistributeProfits()] [Rounding Error] Line 592 calls DistributeProfitsForSubSchemes which uses SafeCalculateProfits with decimal division. Can rounding errors accumulate across many sub-schemes, causing remainAmount at line 595 to differ significantly from expected individual allocations? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: PerformDistributeProfits()] [Zero Amount Transfer] Line 595-602 transfers remainAmount even if zero. Does this waste gas and potentially emit confusing events for zero-value transfers? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: PerformDistributeProfits()] [Virtual Inline] Lines 596-602 use SendVirtualInline for transfers. Can a malicious token contract exploit reentrancy during these calls to manipulate scheme state mid-distribution? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: DistributeProfitsForSubSchemes()] [Profit Calculation] Line 621 uses SafeCalculateProfits with decimal conversion. Can extreme share values (e.g., 1 share out of long.MaxValue total) result in zero allocation due to rounding, losing user funds? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: DistributeProfitsForSubSchemes()] [State Update] Lines 634-637 update LastProfitPeriod for all sub-scheme details. If a sub-scheme has multiple details, does updating all of them prevent proper profit calculation for different detail period ranges? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: DistributeProfitsForSubSchemes()] [Remain Calculation] Line 631 subtracts distributeAmount from remainAmount. If multiple sub-schemes cause remainAmount to go negative due to rounding accumulation, does this cause underflow or incorrect final transfer? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: DistributeProfitsForSubSchemes()] [Token Symbol Tracking] Lines 641-644 add symbol to ReceivedTokenSymbols if not present. Can this grow unbounded if schemes receive many different tokens, causing state bloat and iteration DoS? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: DistributeProfitsForSubSchemes()] [Iteration Complexity] Line 610 iterates all SubSchemes. Can an attacker add thousands of sub-schemes causing DistributeProfits to fail with out-of-gas errors? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ContributeProfits()] [Authorization] No authorization check exists - anyone can contribute to any scheme. Can an attacker contribute dust amounts to thousands of schemes to bloat ReceivedTokenSymbols lists (line 716) and cause DoS? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ContributeProfits()] [Period Validation] Line 684 checks Period >= CurrentPeriod, but what if Period is far in the future (e.g., long.MaxValue)? Can this create unreachable profit periods that lock tokens permanently? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ContributeProfits()] [Released Check] Lines 698-699 assert IsReleased is false for specific periods. Can an attacker contribute to period 0 (general ledger) then immediately call DistributeProfits for current period, front-running legitimate contributions? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ContributeProfits()] [Amount Validation] Line 657-660 only checks Amount > 0. Can Amount = long.MaxValue cause overflow when added to existing AmountsMap values at line 701? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ContributeProfits()] [TransferFrom] Lines 673-680 and 704-710 use TransferFrom without checking return value. Can a malicious token contract return success without actually transferring, leading to profit distribution of non-existent tokens? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ContributeProfits()] [State Creation] Lines 691-695 create new DistributedProfitsInfo if null. Can this be exploited to pre-create profit info for future periods with attacker-controlled AmountsMap values? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ResetManager()] [Authorization] Line 729 only checks Context.Sender == scheme.Manager. Can the current manager transfer to address(0) or a contract that will self-destruct, permanently locking scheme management? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ResetManager()] [State Consistency] Lines 733-738 modify ManagingSchemeIds for both old and new managers. If this operation fails partially, can schemes become orphaned or duplicated across manager lists? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ResetManager()] [Input Validation] Line 730 checks NewManager.Value.Any() but not if it's a valid address. Can setting manager to an invalid address brick the scheme permanently? (Low)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ClaimProfits()] [Beneficiary Spoofing] Line 754 defaults beneficiary to Context.Sender if null. Can a malicious contract call ClaimProfits with beneficiary set to a victim's address, claiming their profits if approval exists? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ClaimProfits()] [Detail Filtering] Lines 765-767 filter availableDetails with complex LastProfitPeriod logic. Can an attacker craft ProfitDetails where LastProfitPeriod is manipulated to bypass EndPeriod checks, claiming expired profits? (High)",
  "[File: contract/AElf.Contracts.Profit/ProfitContract.cs] [Function: ClaimProfits()] [Limit Bypass] Lines 772-774 limit to ProfitReceivingLimitForEachTime (10) details. Can an attacker create 1000 small-share details forcing victim to call ClaimProfits 100 times, wasting gas and potentially hitting per-block limits? (Medium)"
]