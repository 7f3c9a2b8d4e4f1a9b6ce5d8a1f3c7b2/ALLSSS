[
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Null Scheme Assertion] Line 106 asserts scheme != null. If this assertion fails in a view context, does it throw an exception that could be used to DoS queries? (Low)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Beneficiary Default] Line 107 sets 'beneficiary = beneficiary ?? Context.Sender'. In view methods, Context.Sender might be zero or undefined. Can this cause incorrect beneficiary resolution? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Early Return on Null] Line 110 returns empty GetAllProfitsMapOutput if profitDetails is null. Can this mask errors where profitDetails should exist but was corrupted? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Where Clause Logic] Lines 113-117: availableDetails filters for d.LastProfitPeriod < scheme.CurrentPeriod. Can an attacker manipulate CurrentPeriod in a related scheme to include/exclude specific periods? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [LastProfitPeriod == 0 Branch] Line 114-115: if LastProfitPeriod == 0, the condition is d.EndPeriod >= d.StartPeriod. Can negative or inverted periods bypass this check? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [LastProfitPeriod != 0 Branch] Line 116: else condition is d.EndPeriod >= d.LastProfitPeriod. If LastProfitPeriod > EndPeriod due to corruption, is this detail excluded or included incorrectly? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Math.Min Limit] Line 120: profitableDetailCount = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count). Can setting a low limit cause users to lose access to profits beyond the first N details? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Constant Manipulation] If ProfitContractConstants.ProfitReceivingLimitForEachTime is changed dynamically (not a true constant), can this alter which details are profitable mid-execution? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Period Count Calculation] Line 121: maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount). If this function is missing or returns invalid values, can profit calculations fail? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Dictionary Initialization] Lines 123-124 initialize allProfitsDict and claimableProfitsDict. If these dictionaries are not properly isolated, can they share state or references? (Low)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Loop Bounds] The for loop (lines 125-135) iterates availableDetails.Count times. If Count is very large, can this cause transaction timeout or DoS in view calls? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [LastProfitPeriod Reset] Line 128: if profitDetail.LastProfitPeriod == 0, it's set to profitDetail.StartPeriod. Does this mutate the profitDetail in State, causing unintended state changes in a view method? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [EndPeriod Subtraction] Line 130: profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod) calculates period count. If EndPeriod < LastProfitPeriod, does Sub handle it correctly or underflow? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [ProfitAllPeriods Call] Line 130 calls ProfitAllPeriods with endPeriod.Sub(lastProfitPeriod) as period count. If this is negative or zero, does ProfitAllPeriods return empty or throw? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Symbol Filtering] Line 130 passes 'symbol' parameter. If symbol is provided, ProfitAllPeriods might skip other symbols. Can this cause incomplete profit reporting? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [AddProfitToDict Overflow] Line 131 calls AddProfitToDict which uses .Add (line 148). Can repeatedly adding large profits cause integer overflow in allProfitsDict values? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Loop Continuation] Line 132: if i >= profitableDetailCount, continue. This skips claimable profit calculation. Can attackers manipulate profitableDetailCount to make all profits unclaimable? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Max Period Count] Line 133 uses maxProfitReceivingPeriodCount for claimable profits. If this is set too low, can users lose the ability to claim accumulated profits? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Claimable vs Total Mismatch] Lines 130 and 133 call ProfitAllPeriods with different period counts. Can this cause claimableProfitsDict > allProfitsDict for the same detail? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: GetAllProfitsMap() private] [Output Construction] Lines 137-141 construct GetAllProfitsMapOutput. If dictionaries contain inconsistent data, does this return exploitable profit information? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: AddProfitToDict()] [Dictionary Mutation] AddProfitToDict modifies profitsDict in-place (line 148). If profitsDict is shared or referenced elsewhere, can this cause unintended state changes? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: AddProfitToDict()] [Integer Overflow] Line 148: profitsDict[kv.Key].Add(kv.Value) uses the Add extension. If profitsDict[kv.Key] + kv.Value > Int64.MaxValue, does Add throw or silently overflow? (Critical)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: AddProfitToDict()] [Negative Values] If kv.Value or profitsDict[kv.Key] is negative, can Add produce unexpected results or enable profit manipulation? (High)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: AddProfitToDict()] [Key Injection] If profitsToAdd contains keys not in profitsDict, line 150 adds them. Can attackers inject arbitrary symbol keys to pollute the profit map? (Medium)",
  "[File: contract/AElf.Contracts.Profit/ViewMethods.cs] [Function: AddProfitToDict()] [Empty Dictionary] If profitsToAdd is empty, AddProfitToDict is a no-op. Can this mask bugs where profits should have been calculated? (Low)"
]