[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Miner List Update Failure Revert] If SetMinerList() returns false, the entire transaction reverts with Assert(false). But State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] and AddRoundInformation(nextRound) may have already been called. Can this create partial term transition state that corrupts consensus? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Treasury Release Manipulation] DonateMiningReward() determines if Treasury.Release should be called. If an attacker manipulates donation logic to always return true, can they trigger premature or excessive treasury releases, draining the treasury or breaking the release schedule? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Previous Round Retrieval Failure] TryToGetPreviousRoundInformation() is Asserted to succeed. If it fails (returning false), the transaction reverts but partial state updates may have occurred. Can this happen during the first term transition where there is no previous round, causing term transition DoS? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Election Snapshot Inconsistency] TakeElectionSnapshotInput uses previousRound.GetMinedBlocks(), termNumber from the old term, and previousRound.RoundNumber. If these values are inconsistent due to prior state corruption, can it create incorrect voting power snapshots that affect election outcomes? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Produced Blocks Number Update Timing] UpdateProducedBlocksNumberOfSender(nextRound) is called after resetting ProducedBlocks to 0. If this function relies on accurate produced blocks counts, can the reset cause incorrect updates that break producer statistics? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [Current Miner Information Update Race] UpdateCurrentMinerInformationToElectionContract(previousRound) uses previousRound data. If previousRound was manipulated in a prior attack, can this propagate corrupted miner performance data to the election contract, affecting future elections? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessNextTerm()] [First Round Number Mapping Overflow] State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] is set without bounds checking. Can an attacker force term numbers to grow extremely large through repeated term transitions, causing state storage overflow or making term number lookups prohibitively expensive? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [Cleanup Race Condition] The function removes round information for roundNumber - 3. If multiple round transitions happen rapidly and cleanup doesn't complete, can old miner list data accumulate and cause state bloat, or can premature cleanup remove data still needed for LIB calculations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [Negative Round Number Underflow] The cleanup checks if removeTargetRoundNumber > 0 after calling currentRound.RoundNumber.Sub(3). Can this underflow during the first three rounds cause unexpected behavior or bypass the cleanup null check? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: RecordMinedMinerListOfCurrentRound()] [Mined Miners Incomplete Data] GetMinedMiners() returns miners who actually produced blocks. If this list is incomplete due to prior state corruption or filtering logic errors, can the recorded miner list misrepresent actual block production, affecting reward distribution? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Miner Not In Round Attack] The function accesses currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey] without checking if the key exists. If PreCheck() allows a miner from previousRound but they're not in currentRound, can this cause a KeyNotFoundException that halts consensus processing? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Actual Mining Time Manipulation] ActualMiningTimes.Add(updateValueInput.ActualMiningTime) accepts any timestamp from the input. Can a malicious miner provide future or past timestamps to manipulate time slot calculations, affect LIB calculations via ImpliedIrreversibleBlockHeight, or break round timing invariants? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Produced Blocks Overflow] ProducedBlocks and ProducedTinyBlocks are incremented by 1 using Add(1) without overflow checking. Can a long-running miner cause integer overflow that wraps their production count back to zero, allowing them to mine infinitely while appearing to have low production? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Secret Sharing Bypass] IsSecretSharingEnabled() controls whether PerformSecretSharing() is called. Can an attacker manipulate this configuration check to disable secret sharing mid-consensus, breaking the random number generation protocol and making consensus predictable? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Tune Order Injection] The function iterates updateValueInput.TuneOrderInformation and sets FinalOrderOfNextRound for miners. Can an attacker include tuneOrder entries for miners not in the round or with invalid order values to corrupt next round's miner ordering, breaking time slot assignments? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Previous In Value Bypass] If updateValueInput.PreviousInValue == Hash.Empty, the minerInRound.PreviousInValue is not set. Can a malicious miner deliberately omit their previous in value to avoid random number verification in secret sharing, weakening randomness without detection? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [LIB Height Manipulation] The LastIrreversibleBlockHeightCalculator uses currentRound and previousRound to calculate libHeight. If either round contains manipulated ImpliedIrreversibleBlockHeight values from malicious miners, can this cause incorrect LIB calculations that confirm invalid blocks or delay finality? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [LIB Monotonicity Violation] The check 'currentRound.ConfirmedIrreversibleBlockHeight < libHeight' prevents LIB from going backward. But can an attacker with multiple colluding miners provide identical ImpliedIrreversibleBlockHeight values to freeze LIB at a low height, preventing finality and enabling long-range reorganization attacks? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [IrreversibleBlockFound Event Injection] The IrreversibleBlockFound event is fired when LIB increases. Can an attacker manipulate LIB calculations to fire this event with incorrect heights, causing listening contracts or cross-chain protocols to accept unconfirmed blocks as final? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Confirmed Round Number Desync] ConfirmedIrreversibleBlockRoundNumber is set to currentRound.RoundNumber.Sub(1). If currentRound.RoundNumber is 1 or 0, can this underflow cause ConfirmedIrreversibleBlockRoundNumber to wrap to a very large value, breaking round-based queries? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Round Information Update Failure] TryToUpdateRoundInformation(currentRound) is Asserted to succeed. If it fails after all in-memory modifications to currentRound, the transaction reverts but _processingBlockMinerPubkey remains set. Can this leave the contract in an inconsistent state for the next transaction? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: ProcessUpdateValue()] [Supposed Order Self-Assignment] FinalOrderOfNextRound is initially set to updateValueInput.SupposedOrderOfNextRound for the current miner. Can a miner assign themselves an order of 0 or an invalid value to break round generation, or claim first position every round to gain mining advantages? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PerformSecretSharing()] [Encrypted Pieces Overflow] EncryptedPieces.Add(input.EncryptedPieces) adds encrypted data without size limits. Can an attacker submit extremely large EncryptedPieces data structures to cause state bloat DoS, making block processing prohibitively expensive for validators? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PerformSecretSharing()] [Decrypted Pieces Injection] The function iterates input.DecryptedPieces and adds them to round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces[publicKey]. Can an attacker provide DecryptedPieces for miners not in the round to cause KeyNotFoundException, or inject fake decrypted values to corrupt secret sharing? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs] [Function: PerformSecretSharing()] [Miners Previous In Values Overwrite] The function sets round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue for each entry in input.MinersPreviousInValues. Can an attacker overwrite other miners' PreviousInValue with incorrect hashes, breaking random number verification for those miners in the next round? (Critical)"
]