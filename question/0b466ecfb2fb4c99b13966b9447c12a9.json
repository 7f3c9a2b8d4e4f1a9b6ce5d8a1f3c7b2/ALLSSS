[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: FirstActualMiner()] [Race Condition] If multiple miners set OutValue simultaneously, is FirstOrDefault deterministic, or can different nodes see different FirstActualMiner? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExpectedMiningTime()] [MaxValue Default] Returns long.MaxValue for unknown publicKey - can this cause overflow in timestamp comparisons or duration calculations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExpectedMiningTime()] [Silent Failure] Function silently returns max timestamp instead of throwing error for invalid keys - can this mask authorization failures and allow unauthorized mining attempts? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningOrder()] [MaxValue Default] Returns int.MaxValue for unknown pubkey - can this cause integer overflow in order comparison or arithmetic operations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningOrder()] [Authorization Bypass] Returning int.MaxValue for unknown miners might pass some checks (e.g., order > threshold) - can this bypass order-based access controls? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Threshold Bypass] The function checks MissedTimeSlots >= TolerableMissedTimeSlotsCount - can miners deliberately stay just below threshold (count-1) indefinitely to avoid punishment while still degrading network? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [MissedTimeSlots Manipulation] If MissedTimeSlots counter can be reset or decremented, can malicious miners evade evil miner detection despite repeated missed slots? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Constant Dependency] The function relies on external AEDPoSContractConstants.TolerableMissedTimeSlotsCount - if this constant can be manipulated, can it disable evil miner detection entirely? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [Integer Overflow] If MissedTimeSlots can overflow to negative values, can miners wrap around to appear as having zero missed slots? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: TryToDetectEvilMiners()] [List Return Manipulation] The function returns list of pubkeys but doesn't prevent duplicates - can duplicate entries in RealTimeMinersInformation cause duplicate punishments? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetCheckableRound()] [Clone Safety] The function uses Clone() on dictionaries and objects - if Clone is shallow, can modifications to original affect checkable round integrity? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetCheckableRound()] [Selective Clearing] Function clears EncryptedPieces, DecryptedPieces, ActualMiningTimes - can an attacker exploit the fact these aren't included in hash calculation to manipulate them without detection? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetCheckableRound()] [PreviousInValue Manipulation] When isContainPreviousInValue is false, PreviousInValue is set to Hash.Empty - can this allow miners to hide tampering with previous round values? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetCheckableRound()] [Dictionary Ordering] If dictionary enumeration order changes between calls, will GetCheckableRound produce different byte arrays for same logical round? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetCheckableRound()] [Missing Field Validation] The function doesn't validate that cleared fields (EncryptedPieces etc.) were actually populated - can empty fields be considered same as cleared fields, causing hash collisions? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: NeedToChangeTerm()] [Threshold Manipulation] The function checks >= MinersCountOfConsent - if this threshold can be manipulated or isn't properly validated, can term changes be forced or prevented? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: NeedToChangeTerm()] [ActualMiningTimes Attack] The function uses Last() of ActualMiningTimes - can miners add fake timestamps to their list to manipulate term change decisions? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: NeedToChangeTerm()] [Empty ActualMiningTimes] Miners without ActualMiningTimes are filtered out - can miners deliberately avoid mining to prevent reaching consent threshold and block term changes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: NeedToChangeTerm()] [Time Threshold Calculation] The IsTimeToChangeTerm check depends on periodSeconds - if this can be manipulated or set to 0, can term changes be forced at arbitrary times? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: NeedToChangeTerm()] [Timestamp Manipulation] If miners can set their last ActualMiningTime to future values, can they trigger premature term changes before legitimate time? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: NeedToChangeTerm()] [Integer Division] The Count(t => ...) comparison uses integer count - can off-by-one errors in MinersCountOfConsent cause premature or delayed term changes? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeToChangeTerm()] [Division by Zero] If periodSeconds is 0, the Div operation causes division by zero - can this crash term change checks or produce undefined behavior? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeToChangeTerm()] [Negative Period] If periodSeconds is negative, can the division produce incorrect term numbers that break term change logic? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeToChangeTerm()] [Timestamp Overflow] If blockProducedTimestamp - blockchainStartTimestamp overflows, can this produce incorrect period calculation? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeToChangeTerm()] [Term Number Manipulation] The check compares against termNumber - 1 - if termNumber can be manipulated to 0 or negative, can this break term change detection? (High)"
]