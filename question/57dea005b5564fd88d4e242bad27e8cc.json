[
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetFeeRate()] [State Consistency] If State.FeeRate.Value is null or empty, does the function return an empty StringValue that could break fee calculations in Buy/Sell operations, allowing fee-free transactions? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetFeeRate()] [Input Validation] Can malicious initialization or SetFeeRate calls set State.FeeRate to invalid decimal strings (e.g., 'abc', '1.2.3', '-0.5') that GetFeeRate returns without validation, causing parsing failures in downstream fee calculations? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetFeeRate()] [Race Condition] If SetFeeRate is called mid-transaction while Buy/Sell operations read GetFeeRate, can inconsistent fee rates be applied within the same block, enabling frontrunning attacks where attackers exploit old rates before updates? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetControllerForManageConnector()] [Authorization Bypass] If State.ConnectorController.Value is set to an invalid or non-existent organization address, does GetDefaultConnectorController get called repeatedly without caching, allowing potential DOS or unauthorized controller claims? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetControllerForManageConnector()] [State Manipulation] Can an attacker exploit the null check at line 19 by calling ChangeConnectorController to set State.ConnectorController.Value to a malicious AuthorityInfo, then immediately gaining full connector management privileges? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetControllerForManageConnector()] [Default Controller Risk] Does GetDefaultConnectorController always return the Parliament default organization without verifying it exists, potentially allowing operations to proceed with invalid controller addresses after Parliament contract upgrades? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetBaseTokenSymbol()] [State Consistency] If State.BaseTokenSymbol.Value is null, empty, or contains invalid characters not validated during Initialize, does GetBaseTokenSymbol return corrupted symbol data that breaks token operations in Buy/Sell/EnableConnector? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetBaseTokenSymbol()] [Symbol Validation] Can State.BaseTokenSymbol be changed post-initialization (e.g., via state migration or upgrade), causing GetBaseTokenSymbol to return a different symbol than expected, breaking all existing connector pair calculations? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetPairConnector()] [Null Reference] At line 39, if State.Connectors[input.Symbol] returns null for a non-existent token, targetConnector is null but no assertion is thrown—does this cause line 42's targetConnector.RelatedSymbol to throw NullReferenceException, creating DOS vector? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetPairConnector()] [Logic Error] If targetConnector exists but targetConnector.RelatedSymbol points to a non-existent connector (relatedConnector is null at line 42), and targetConnector.IsDepositAccount is false, does the function return PairConnector with null ResourceConnector at line 51, breaking Buy/Sell operations? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetPairConnector()] [Connector Swap Logic] At lines 43-48, if IsDepositAccount is true, the function returns DepositConnector as targetConnector and ResourceConnector as relatedConnector—can an attacker exploit this by creating connectors where IsDepositAccount flags are incorrectly set, swapping deposit/resource roles and breaking Bancor calculations? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetPairConnector()] [Inconsistent State] If targetConnector.RelatedSymbol points to a connector whose RelatedSymbol doesn't point back (broken bidirectional relationship), does GetPairConnector return mismatched pairs causing Buy to use wrong connectors for price calculation? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetPairConnector()] [Circular Reference] If two connectors have RelatedSymbol pointing to each other but both have IsDepositAccount=true or both false, does the function fail to identify the correct resource/deposit pair, returning invalid PairConnector data? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetPairConnector()] [Missing Validation] Does the function validate that exactly one of (targetConnector, relatedConnector) has IsDepositAccount=true? If both are deposit accounts, does it incorrectly return both as deposit, breaking the Bancor model assumptions? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Assertion Bypass] At line 59, the assertion requires toConnector is not null AND !toConnector.IsDepositAccount—can an attacker pass a symbol where toConnector.IsDepositAccount is true, bypassing the assertion and causing incorrect deposit calculations? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Null Connector] At line 60, if fromConnector (the related symbol connector) is null, the assertion at line 61 fails—but is this check performed AFTER State.Connectors lookup, meaning invalid connector pairs can DOS the function with failed assertions? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Supply Manipulation] At lines 62-66, GetTokenInfo is called to get TotalSupply—if an attacker inflates TotalSupply via mint operations immediately before EnableConnector, does this artificially increase amountOutOfTokenConvert at line 73, requiring excessive deposit amounts? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Balance Calculation] At lines 67-72, the contract balance is retrieved—if tokens are transferred to the contract address outside EnableConnector flow, does this reduce amountOutOfTokenConvert at line 73, allowing connector enablement with insufficient deposits? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Integer Underflow] At line 73, amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert—if (balance + input.AmountToTokenConvert) > TotalSupply, does this underflow to a large positive number due to unsigned arithmetic, causing massive needDeposit calculation? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Negative Amount Handling] At line 75, if amountOutOfTokenConvert <= 0 (all tokens already in contract), needDeposit remains 0—is this correct, or should the function validate that some minimum deposit is required to maintain Bancor price stability? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [VirtualBalance Flag] At lines 78-80, if toConnector.IsVirtualBalanceEnabled is true, tb = VirtualBalance + TotalSupply—but if IsVirtualBalanceEnabled is false, tb = TotalSupply only. Can attacker manipulate IsVirtualBalanceEnabled flag to drastically change deposit requirements? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Bancor Formula Vulnerability] At lines 81-83, BancorHelper.GetAmountToPayFromReturn is called—if fromConnector.VirtualBalance (fb) is 0 or very small, does the Bancor formula throw division-by-zero or return astronomically high needDeposit, DOS-ing connector enablement? (Critical)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Weight Manipulation] At lines 82-83, GetWeight(fromConnector) and GetWeight(toConnector) are passed to Bancor formula—if weights are set to extreme values (very close to 0 or 1) via UpdateConnector, does this cause needDeposit calculation to overflow or become irrational? (High)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Precision Loss] Does the Bancor calculation at lines 81-83 use decimal math that gets truncated to long, causing precision loss where small needDeposit amounts get rounded to 0, allowing free connector enablement? (Medium)",
  "[File: contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs] [Function: GetNeededDeposit()] [Return Value Overflow] At line 86-90, if needDeposit calculated by Bancor exceeds Int64.MaxValue due to extreme connector parameters, does the cast to long at line 82 overflow, returning negative needDeposit that passes EnableConnector validation? (Critical)"
]