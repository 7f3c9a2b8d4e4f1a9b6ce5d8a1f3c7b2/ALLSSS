[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Event Fire After State Change] Line 106 fires event after state modifications - can reentrancy attack through event observers modify state before event is fully processed? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Memo Size Validation] Line 103 validates memo but line 112 includes memo in event - can malicious memo cause event processing DoS or exceed block size limits? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: DoTransfer()] [Empty Memo Default] Line 112 defaults to empty string if memo is null - can this cause ambiguity between explicitly empty vs null memo in event processing? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertValidMemo()] [UTF8 Byte Count] Line 90 uses Encoding.UTF8.GetByteCount which can vary per character - can attacker craft memo with multi-byte UTF8 chars that appear short in length but exceed byte limit? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Insufficient Balance Check] Lines 132-136 check 'freeAllowanceAmount < -addAmount' but don't verify if final result after loop is non-negative - can this cause negative allowance? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Loop Variable Mutation] Lines 141-154 modify addAmount within loop and use it as loop exit condition - can attacker craft allowances to cause infinite loop or incorrect deduction? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Expiration Time Calculation] Line 161 calculates expiration as 'RefreshSeconds - (CurrentBlockTime - LastRefreshTime).Seconds' - can integer underflow occur if LastRefreshTime > CurrentBlockTime due to time manipulation? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Allowance Depletion Order] Lines 145-147 skip symbols not containing the target symbol - can attacker structure allowance map to prevent certain symbols from being depleted, causing fee bypass? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Zero Amount Continuation] Line 149 skips currentAllowance == 0 but continues loop - can attacker add many zero-allowance entries to cause gas exhaustion DoS? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Negative AddAmount Logic] Line 151 does 'addAmount += currentAllowance' when addAmount < 0 - if currentAllowance is large, can addAmount become positive, violating deduction invariant? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: ModifyFreeFeeAllowanceAmount()] [Conditional Assignment] Line 153 assigns 'addAmount >= 0 ? addAmount : 0' - if addAmount becomes positive in middle of loop, does this leave remaining allowances unprocessed? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetSymbolListSortedByExpirationTime()] [Timestamp Subtraction] Lines 161-163 compute 'RefreshSeconds - (CurrentBlockTime - LastRefreshTime).Seconds' - can this produce negative values if refresh is overdue, causing incorrect sort order? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetSymbolListSortedByExpirationTime()] [State Access in Lambda] Lines 161-162 access State within OrderBy lambda - can this cause performance issues or reentrancy if State access triggers external calls? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetFreeFeeAllowanceAmount()] [Map Null Check] Line 184 returns 0 if map is null, but line 186 iterates map.Values - can map be non-null but Values be null causing NullReferenceException? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetFreeFeeAllowanceAmount()] [TryGetValue Without Success Check] Line 188 uses TryGetValue but doesn't check success - can this include null values in allowance sum if symbol doesn't exist? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetFreeFeeAllowanceAmount()] [Accumulation Overflow] Line 190 does 'allowance.Add(freeAllowance?.Amount ?? 0L)' - can accumulated allowance overflow long.MaxValue if many large allowances exist? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [Race Condition] Lines 198-199 check whitelist and 200 gets system contracts separately - can attacker manipulate whitelist between these checks to bypass authorization? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [Context.Sender Trust] Line 199 checks Context.Sender which could be manipulated in delegatecall scenario - can attacker spoof sender to bypass whitelist check? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [System Contract Enumeration] Line 200 calls GetSystemContractNameToAddressMapping().Values - can attacker register fake system contracts to gain whitelist privileges? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: AssertSystemContractOrLockWhiteListAddress()] [OR Logic Vulnerability] Line 202 allows EITHER whitelist OR system contract - if whitelist is compromised but system contracts are secure, attacker can still bypass check. Should this be AND logic for critical operations? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: IsInLockWhiteList()] [Hard-coded Contracts] Lines 380-381 only check Election and Vote contracts - can new governance contracts added later be excluded from whitelist, breaking lock functionality? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetElectionContractAddress()] [Lazy Initialization Race] Lines 385-389 initialize State.ElectionContractAddress if null - can concurrent calls cause race condition where address is set twice to different values? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: GetVoteContractAddress()] [Contract Name Dependency] Line 398 uses SmartContractConstants.VoteContractSystemName - if this constant is changed or contract renamed, will lock operations fail permanently? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [No Return Value Check] Lines 247-249 call VerifyTransaction but only check .Value field - can malicious CrossChain contract return BoolValue with Value=true without actual verification? (Critical)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs] [Function: CrossChainVerify()] [Chain ID Validation Missing] Line 242 accepts chainId parameter without validation - can attacker supply invalid/negative chainId to bypass verification or cause integer overflow? (High)"
]