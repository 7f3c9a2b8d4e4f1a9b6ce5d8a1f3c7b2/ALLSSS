[
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Type Mismatch] If the first 2 characters of symbol don't match any NFT type, does this create orphaned protocols? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Cross-Chain Type Spoofing] Could an attacker create a token on mainchain with symbol 'XX123' (Any type) but claim it's 'AR123' (Art) on sidechain? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [AddNFTType Race] Between CrossChainCreate checking NFTTypeFullNameMap at line 90 and storing protocol at line 108, could AddNFTType modify the type mappings? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [TotalSupply Manipulation] At line 98, tokenInfo.TotalSupply is used directly - could mainchain have different supply than sidechain causing inconsistency? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Creator Spoofing] At line 100, tokenInfo.Issuer becomes the Creator - but what if TokenContract.GetTokenInfo returns a manipulated issuer address? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [IsBurnable Mismatch] If tokenInfo.IsBurnable at line 101 differs between chains, could this allow burning on one chain but not another? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [IssueChainId Validation] At line 102, is tokenInfo.IssueChainId validated to ensure it matches the chain where token was actually issued? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Metadata Deep Copy] At line 104, does copying tokenInfo.ExternalInfo.Value create a deep copy or shallow reference that could be modified? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [TokenName Override] If tokenInfo.TokenName at line 105 is empty or malicious, does this corrupt the ProtocolName field? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Protocol Overwrite] At line 108, State.NftProtocolMap[input.Symbol] is written - but line 79 only checks if it's null, not if it was deleted/reset (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [MinterList Single Address] At lines 110-113, only the creator is added to MinterList - is this intentional or should cross-chain maintain original minter list? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Creator Validation] At line 112, nftProtocolInfo.Creator is added to MinterList - but what if Creator address is zero or invalid? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Authorization Missing] CrossChainCreate() has no authorization checks - can anyone call it to create arbitrary protocols if they know a mainchain token symbol? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Cross-Chain Replay] Could an attacker replay CrossChainCreate() calls multiple times if the symbol check at line 79 is bypassed through state manipulation? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Event Accuracy] At lines 115-127, does the event accurately reflect the stored protocol, or could there be mismatches from tokenInfo? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [IsTokenIdReuse Event] At line 125, isTokenIdReuse is emitted, but is this from nftProtocolInfo.IsTokenIdReuse (line 103) for consistency? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: CrossChainCreate()] [Return Value] CrossChainCreate() returns Empty at line 128 - should it return the created symbol for consistency with Create()? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Authorization Bypass] At line 133, AssertSenderIsParliamentDefaultAddress() checks authorization - but if ParliamentContract is compromised, could this be bypassed? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Governance Attack] If Parliament default organization is controlled by an attacker, could they add malicious NFT types to enable symbol collisions? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Missing Multi-Sig] Does AssertSenderIsParliamentDefaultAddress() require multi-sig approval or just sender check, allowing single-point-of-failure? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Initialization Race] At line 134, InitialNFTTypeNameMap() is called - could concurrent AddNFTType calls cause race conditions in initialization? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [Initialization DOS] If InitialNFTTypeNameMap() at line 134 fails or reverts, does this permanently prevent adding new types? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [ShortName Validation] At line 136, only length == 2 is checked - are there restrictions on special characters, numbers, case sensitivity in ShortName? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [ShortName Collision] At line 137, if ShortName already exists, it asserts, but what if it was removed and re-added with different FullName? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_Create.cs] [Function: AddNFTType()] [FullName Validation] At line 138, fullName collision is checked, but is there validation on fullName content (length, characters, uniqueness)? (Medium)"
]