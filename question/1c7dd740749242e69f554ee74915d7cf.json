[
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Authorization Bypass] Can any arbitrary address call SetMethodFee() without authorization checks since the function returns Empty() without validating Context.Sender against MethodFeeController.Value.OwnerAddress, allowing unauthorized fee modifications? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Missing State Persistence] Does SetMethodFee() fail to persist input.Fees to any state variable (unlike State.TransactionFees[input.MethodName] pattern in other contracts), causing fee changes to be silently ignored and never take effect? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Governance Bypass] Can a malicious actor bypass Parliament governance by calling SetMethodFee() directly since there's no RequiredMethodFeeControllerSet() check or verification that the caller is the Parliament default organization? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Missing Validation] Does SetMethodFee() accept invalid fee tokens without calling AssertValidFeeToken() to verify the token exists, is burnable, and has valid symbol/amount, potentially causing runtime failures during fee collection? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Input Validation Bypass] Can SetMethodFee() accept negative BasicFee values in input.Fees since there's no validation logic, potentially causing integer underflow or incorrect fee calculations in the fee collection system? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Null Input Handling] Does SetMethodFee() fail to validate that input.MethodName is non-null/non-empty before the no-op return, potentially accepting invalid method fee configurations? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Symbol Validation Bypass] Can SetMethodFee() accept invalid token symbols (empty, null, or non-existent tokens) in input.Fees.Symbol without validation, causing downstream fee collection failures when the MultiToken contract attempts to charge these fees? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Excessive Fee Attack] Can an attacker with access to SetMethodFee() set arbitrarily high BasicFee values (e.g., Int64.MaxValue) for NFT methods like Create(), effectively DOS-ing the NFT contract by making all operations economically infeasible? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Fee Override Without Validation] Does the lack of any implementation in SetMethodFee() mean that even if State.TransactionFees existed, there would be no validation that the new fees don't completely override existing fee structures without governance approval? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: SetMethodFee()] [Contract State Inconsistency] Since SetMethodFee() returns Empty() without state changes, can this cause inconsistency where GetMethodFee() returns hardcoded values but SetMethodFee() calls appear to succeed, confusing governance tooling and audit trails? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Authorization Bypass] Can any address call ChangeMethodFeeController() and the function returns Empty() without checking if Context.Sender matches State.MethodFeeController.Value.OwnerAddress, allowing unauthorized controller changes? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Missing State Persistence] Does ChangeMethodFeeController() fail to persist input.OwnerAddress and input.ContractAddress to State.MethodFeeController.Value, causing controller changes to be silently ignored? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Organization Validation Bypass] Does ChangeMethodFeeController() skip the CheckOrganizationExist() call to validate that input.OwnerAddress is a valid Parliament/Association/Referendum organization, allowing invalid or non-existent addresses as controllers? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Null Address Attack] Can ChangeMethodFeeController() accept input.OwnerAddress as Address.Zero or null without validation, potentially locking the contract by setting an invalid controller that can never authorize fee changes? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Contract Address Validation] Does ChangeMethodFeeController() fail to verify that input.ContractAddress points to a valid authorization contract (Parliament/Association/Referendum) before accepting it, allowing arbitrary contract addresses that don't implement proper governance? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Self-Authorization Attack] Since there's no RequiredMethodFeeControllerSet() check, can a malicious actor call ChangeMethodFeeController() during contract initialization to set themselves as controller before Parliament is properly configured? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Controller Overwrite Without Validation] Does the empty implementation mean an attacker could repeatedly call ChangeMethodFeeController() with different addresses, and while changes aren't persisted, this creates false audit trails showing controller modifications? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Governance Takeover Vector] Can an attacker who gains temporary control call ChangeMethodFeeController() to point to a malicious authorization contract that always returns true for validation checks, bypassing proper governance? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Missing AssertSenderAddressWith] Does the absence of AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress) allow any caller to invoke this function, including external EOAs or unauthorized contracts? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: ChangeMethodFeeController()] [Circular Authority Risk] Can ChangeMethodFeeController() create circular authority loops by setting input.ContractAddress to the NFT contract itself without validation, causing infinite recursion during authorization checks? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: GetMethodFee()] [Hardcoded Fee Risk] Does GetMethodFee() return a hardcoded 100 ELF fee only for the Create method without reading from state, meaning fee changes via SetMethodFee() can never take effect and the fee is permanently fixed? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: GetMethodFee()] [Missing Fee Configuration] Does GetMethodFee() return empty MethodFees for all methods except Create (lines 22-36), meaning other NFT operations have no fee configuration and might bypass fee collection entirely? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: GetMethodFee()] [Symbol Hardcoding Risk] Does GetMethodFee() hardcode Context.Variables.NativeSymbol (line 30) without verifying it matches the chain's actual native token, potentially causing fee collection failures on chains with different native symbols? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: GetMethodFee()] [Fee Amount Inconsistency] Is the 100_00000000 BasicFee (100 ELF with 8 decimals) on line 31 economically reasonable, or could it be set too high/low compared to other AElf contracts, causing user friction or insufficient cost deterrence? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContract_ACS1.cs] [Function: GetMethodFee()] [Case Sensitivity Bug] Does GetMethodFee() use case-sensitive string comparison (input.Value == nameof(Create)) on line 22, potentially failing to match if callers use different casing like 'create' or 'CREATE'? (Low)"
]