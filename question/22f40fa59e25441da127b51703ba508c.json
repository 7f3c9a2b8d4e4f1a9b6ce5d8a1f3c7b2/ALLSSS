[
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: All Metadata Keys] [Reserved Key Enforcement] Does GetNftMetadataReservedKeys() return all 5 constants, and is this list exhaustively checked in ALL metadata input points (Create, Mint, Assemble, Recast) to prevent any reserved key bypass? (Critical)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: All Metadata Keys] [Key Name Collision] Can an attacker create custom metadata keys with similar names (e.g., 'aelf_nft_type_', 'AELF_NFT_TYPE') that bypass reserved key checks but still interfere with metadata parsing logic? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: NumberMinLength & Metadata Keys] [Symbol Generation] Can inconsistency between NumberMinLength-based symbol generation and NftTypeMetadataKey validation cause symbols to be created with types that don't match the expected 2-character prefix format? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: All] [Immutability Violation] Are these constants truly immutable at runtime, or can contract upgrade/migration patterns allow modification of constant values, breaking all dependent logic assumptions? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: Metadata Keys] [Protobuf Encoding] Do all metadata key constants properly handle UTF-8 encoding, or can international characters in custom metadata cause comparison failures with ASCII constant keys? (Low)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NumberMinLength] [Upgrade Path] If NumberMinLength needs to change in future contract versions (e.g., to support more protocols), will existing symbols remain valid, or will validation logic break backward compatibility? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: All Metadata Keys] [External Contract Interaction] Can malicious external contracts (TokenContract, Parliament) return ExternalInfo with reserved metadata keys that violate assumptions when NFTContract reads them in CrossChainCreate()? (High)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constant: NftTokenIdReuseMetadataKey] [Default Value Risk] If bool.Parse() fails in CrossChainCreate() and no exception handling exists, does the protocol default to allow or deny token ID reuse, and can this default be exploited? (Medium)",
  "[File: contract/AElf.Contracts.NFT/NFTContractConstants.cs] [Constants: AssembledNftsKey & AssembledFtsKey] [Recast Vulnerability] In Recast(), reserved keys are preserved from oldMetadata, but can attacker exploit timing between Assemble() and Recast() to modify assembled asset metadata before disassembly? (High)"
]