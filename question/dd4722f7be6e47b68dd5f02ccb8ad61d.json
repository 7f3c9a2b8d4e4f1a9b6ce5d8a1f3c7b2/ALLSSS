[
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [State Race] Can an attacker call SetMethodFee and ChangeMethodFeeController in rapid succession to exploit timing window where fee controller changes between RequiredMethodFeeControllerSet and authorization check? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [Initialization Attack] Can an attacker exploit that both SetMethodFee at line 14 and ChangeMethodFeeController at line 24 call RequiredMethodFeeControllerSet, racing to set State.MethodFeeController.Value to attacker-controlled address? (Critical)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [State Inconsistency] If SetMethodFee sets fees for method 'Register' at line 17, does this override the default 10 ELF fee returned by GetMethodFee at line 42-49, creating fee calculation inconsistency? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [External Call Chain] Can the call chain SetMethodFee->AssertValidToken->TokenContract->callback enable reentrancy that exploits ChangeMethodFeeController's lack of reentrancy guard? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [Atomic Operations] If transaction calls both ChangeMethodFeeController and SetMethodFee in single batch, can partial execution leave State.MethodFeeController.Value updated but State.TransactionFees unchanged? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [Concurrent Access] Can multiple threads calling GetMethodFee at line 37 while SetMethodFee updates State.TransactionFees at line 17 cause race condition returning corrupted MethodFees data? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [Controller Transition] After ChangeMethodFeeController updates State.MethodFeeController.Value at line 29, can old controller still call SetMethodFee if transaction was submitted before controller change but executes after? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: Multiple] [State Validation] Does any function validate that State.TransactionFees entries have corresponding valid methods in VoteContract, or can SetMethodFee create fees for non-existent methods bloating storage? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Fee Array Validation] Can an attacker pass input.Fees array with mixed valid/invalid tokens where AssertValidToken validates first few tokens at line 13 but transaction reverts on later invalid token, wasting caller gas without state change? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [State Overwrite] Does State.TransactionFees[input.MethodName] assignment at line 17 perform deep copy or reference assignment, potentially allowing external modification of stored MethodFees object? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Loop DOS] If input.Fees contains 10,000 entries, can the foreach loop at line 13 consume excessive gas causing SetMethodFee to always fail, permanently preventing fee updates? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Order Dependency] Does the order of operations (validate tokens first at line 13, then check authorization at line 14-16, then update state at line 17) create window where valid tokens are confirmed but unauthorized caller is discovered too late? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Fee Removal] Can controller set input.Fees to empty array to remove method fees, causing GetMethodFee to fall through to default case unexpectedly? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Symbol Collision] Can attacker set fees for symbol names that collide with Context.Variables.NativeSymbol used in GetMethodFee at lines 47 and 55, causing fee calculation confusion? (Low)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Multiple Tokens] If input.Fees contains multiple MethodFee entries with different symbols, does fee collection logic support multi-token fees or will it only charge first token? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [BasicFee Zero] Can controller set BasicFee to 0 for critical methods like ChangeMethodFeeController itself, enabling free governance attacks? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Method Name Injection] Can attacker use special characters or escape sequences in input.MethodName to bypass switch-case matching in GetMethodFee or inject into state storage? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: SetMethodFee()] [Fee Calculation Overflow] When stored fees are later used in fee calculation with multipliers/ratios, can BasicFee values near MAX_LONG cause integer overflow? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: ChangeMethodFeeController()] [Self-Reference] Can new controller set input.OwnerAddress to contract's own address, creating self-authorization loop where contract can call SetMethodFee without external control? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: ChangeMethodFeeController()] [Controller Removal] Can controller set input.OwnerAddress to address that's known to be compromised or lost keys, permanently locking fee configuration? (High)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: ChangeMethodFeeController()] [Contract Address Validation] Does ChangeMethodFeeController verify that input.ContractAddress is deployed contract before setting at line 29, or can it accept EOA addresses breaking CheckOrganizationExist? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: ChangeMethodFeeController()] [Organization Type] Can input.ContractAddress point to non-authorization contracts (Parliament/Association/Referendum), bypassing governance constraints? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: ChangeMethodFeeController()] [State Transition] If ChangeMethodFeeController is called while SetMethodFee transaction is pending, can race condition cause SetMethodFee to use old controller for authorization but new controller for subsequent operations? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs] [Function: ChangeMethodFeeController()] [Validation Timing] Does CheckOrganizationExist at line 26 validate organization exists at current block or can organization be dissolved immediately after validation but before State update at line 29? (Medium)",
  "[File: contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs]\n\n### Citations\n\n**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L1-111)\n```csharp\nusing AElf.Sdk.CSharp;\nusing AElf.Standards.ACS1;\nusing AElf.Standards.ACS3;\nusing AElf.Types;\nusing Google.Protobuf.WellKnownTypes;\n\nnamespace AElf.Contracts.Vote;\n\npublic partial class VoteContract\n{\n    public override Empty SetMethodFee(MethodFees input)\n    {\n        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);\n        RequiredMethodFeeControllerSet();\n\n        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress,"
]