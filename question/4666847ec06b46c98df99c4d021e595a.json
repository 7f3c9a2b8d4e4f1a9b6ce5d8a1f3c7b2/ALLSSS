[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Extra Block Producer Fetch Timing] Line 97 calls GetExtraBlockProducerInformation on nextRound - if IsExtraBlockProducer flag was set in previous step, could there be race condition if multiple miners have flag set, causing wrong comparison at line 98? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Order Arithmetic Underflow] Line 101 uses minersCount.Sub(1) and line 103 assigns this value - if minersCount is 0 or corrupted, could Sub(1) underflow to max integer, creating invalid order assignment? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Incomplete Swap Logic] Lines 102-106 swap last two miners but don't update other miners' orders - if another miner's FinalOrderOfNextRound pointed to swapped positions, could this create inconsistent state? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Double Swap Scenario] If both conditions at lines 81 and 98 are true (first==extra of current, last==extra of next), could sequential swaps at lines 85-89 and 102-106 interfere, possibly re-creating continuous mining pattern? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [GetExtraBlockProducerInformation Dependency] Line 80 calls GetExtraBlockProducerInformation on current round - if current round has no extra block producer set, could this return null/default and bypass check at line 81, failing to prevent continuous mining? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Ref Parameter Corruption] Since nextRound is passed by ref at line 73, if exception occurs during swap operations at lines 85-89 or 102-106, could nextRound be left in partially modified state visible to caller? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: BreakContinuousMining()] [Order 2 Missing] Line 84 uses First(i => i.Order == 2) - if no miner has Order==2 (gap in orders), could this throw exception and halt round generation even when continuous mining prevention is needed? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [No Signature Fallback] Lines 114-116 return 1 if no miner has signature - could malicious miners collude to not include signatures, forcing Order 1 to always be extra block producer and centralizing extra block rewards? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Signature Manipulation] Line 118 uses firstPlaceInfo.Signature directly - if a miner manipulates their signature value before this check, could they predictably control extra block producer selection by choosing specific signature values? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [ToInt64 Overflow] Line 119 converts signature to int64 - if signature bytes represent value > int64.MaxValue, could ToInt64() throw overflow exception or wrap, causing non-deterministic extra block producer selection? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [GetAbsModulus Division By Zero] Line 121 calls GetAbsModulus(sigNum, blockProducerCount) - if blockProducerCount is 0, could this cause division by zero exception and halt round generation? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Order Calculation Bias] Line 121 adds 1 to modulus result - if GetAbsModulus returns blockProducerCount-1, result is blockProducerCount, but valid orders are [1, blockProducerCount], could this create off-by-one allowing order > minersCount? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [FirstOrDefault Null Access] Line 113 uses FirstOrDefault which could return null - if it returns null but code continues, could line 118 access null.Signature and throw NullReferenceException? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [OrderBy Signature Exists Filter] Line 112-113 filters OrderBy(m.Order) then checks m.Signature != null - if earliest-order miner has no signature, could this skip them and use later miner's signature, creating unfair selection advantage for early positions? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Deterministic Randomness] Using first miner's signature as randomness source at line 118 - could first miner grind their signature by withholding blocks until signature produces favorable extra block producer, allowing them to manipulate selection? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [Signature Null After Filter] If filter at line 113 returns null because all miners have null signatures, line 114 checks this - but if only some signatures are null and FirstOrDefault returns miner with null signature, could line 118 crash? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: CalculateNextExtraBlockProducerOrder()] [BlockProducerCount Mismatch] Line 120 gets RealTimeMinersInformation.Count - if this differs from actual miners who can produce blocks, could GetAbsModulus at line 121 return order mapping to non-existent miner? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetMinedMiners()] [SupposedOrderOfNextRound Trust] Line 128 trusts SupposedOrderOfNextRound != 0 to identify miners who mined - could malicious miner set SupposedOrderOfNextRound = 0 after mining to be classified as non-mining and avoid order assignment logic? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetMinedMiners()] [Missing Validation] Line 128 filters only on SupposedOrderOfNextRound != 0 without checking actual block production - could miner set non-zero SupposedOrderOfNextRound without producing block to gain mined status and favorable next-round position? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetMinedMiners()] [Empty Result Impact] If all miners have SupposedOrderOfNextRound == 0, line 128 returns empty list - could this cause GenerateNextRoundInformation to create round with all miners treated as non-mining, incorrectly penalizing everyone? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetMinedMiners()] [Order Value Validation] Line 128 only checks != 0 but doesn't validate if SupposedOrderOfNextRound is within valid range [1, minersCount] - could out-of-range values cause issues in order collision detection? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetNotMinedMiners()] [Complementary Logic Assumption] Line 134 assumes SupposedOrderOfNextRound == 0 means didn't mine - if GetMinedMiners uses != 0 check but SupposedOrderOfNextRound could be null/undefined, could miners be excluded from both lists? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetNotMinedMiners()] [All Miners Missed] If all miners have SupposedOrderOfNextRound == 0, line 134 returns all miners - could this cause GenerateNextRoundInformation to assign all to ableOrders, and with no occupiedOrders, all get sequential positions without considering previous performance? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GetNotMinedMiners()] [Zero Value Ambiguity] Line 134 treats 0 as 'not mined' - could this conflict with initialization state where SupposedOrderOfNextRound defaults to 0, making it impossible to distinguish between 'not initialized' and 'didn't mine'? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs] [Function: GenerateNextRoundInformation() + GetMinedMiners()] [Partition Logic Completeness] If GetMinedMiners at line 16 and GetNotMinedMiners at line 17 have overlapping results due to SupposedOrderOfNextRound inconsistency, could a miner appear in both lists and be assigned two different orders in nextRound? (High)"
]