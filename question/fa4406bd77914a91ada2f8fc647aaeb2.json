[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [DOS] What if attacker adds 1000 miners with only two having Order 1 and 2? Where() must iterate all entries on every call - excessive gas consumption? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetMiningInterval()] [Inconsistency] GetMiningInterval() uses first two miners, but CheckRoundTimeSlots() validates all consecutive pairs - can intervals be valid per this function but invalid per CheckRoundTimeSlots()? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Round Number Bypass] Function has different logic for RoundNumber == 1 vs others - can attacker manipulate RoundNumber to 1 to bypass standard time slot validation and use weaker first-round logic? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Division Logic Error] For round 1, expectedOrder calculation uses runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1) - if miningInterval < 1000ms, Div(1000) returns 0, causing division by zero? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [FirstMiner Manipulation] Round 1 logic depends on FirstMiner().ActualMiningTimes - if attacker controls first miner and never produces block (empty ActualMiningTimes), all IsTimeSlotPassed() calls return false, freezing consensus? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Timestamp Overflow] expectedMiningTime + Duration can overflow if ExpectedMiningTime is near Timestamp max value - does overflow cause comparison to always fail, allowing expired slots to appear current? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Order Calculation] expectedOrder = runningTime.Seconds.Div(interval).Add(1) assumes linear time progression - can network delays or clock skew cause order to jump, incorrectly marking slots as passed? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Missing Validation] Function returns false if publicKey not in RealTimeMinersInformation, but doesn't distinguish 'not passed' from 'invalid miner' - can this ambiguity be exploited to bypass time checks? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [First() Risk] actualStartTime = actualStartTimes.First() - if ActualMiningTimes contains out-of-order timestamps, using First() instead of Min() could give wrong start time? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Integer Arithmetic] Multiple Div() and Add() operations without overflow checks - can attacker craft timestamps to cause arithmetic overflow in expectedOrder calculation? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: IsTimeSlotPassed()] [Comparison Edge Case] Uses '<' not '<=' for comparison - if currentBlockTime exactly equals threshold, is slot considered passed or not? Could cause one-block ambiguity window? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetRoundStartTime()] [Null Return] FirstMiner() can return empty MinerInRound with null ExpectedMiningTime - does GetRoundStartTime() return null, causing null reference exceptions in callers? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetRoundStartTime()] [Order Integrity] Depends on FirstMiner() finding Order 1 - what if multiple miners claim Order 1? FirstOrDefault() returns first in unordered dictionary, introducing non-determinism? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetRoundStartTime()] [Time Manipulation] No validation that returned timestamp is reasonable - can attacker set Order 1 miner's ExpectedMiningTime to far future/past to manipulate dependent calculations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CalculateSignature()] [XOR Weakness] Aggregates signatures using XOR - if attacker controls multiple miners, they can cancel out signatures (A XOR B XOR A = B), potentially forging aggregate signature? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CalculateSignature()] [Null Signature] No validation that minerInRound.Signature is non-null - XORing with null/empty hash could produce predictable result, enabling signature prediction? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CalculateSignature()] [Hash.Empty Seed] Aggregate starts with Hash.Empty - does this create bias in final signature? Could attacker exploit known seed to predict output before all signatures submitted? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CalculateSignature()] [Order Independence] XOR is commutative - signature doesn't depend on miner order, so attacker could submit miners in any sequence to find favorable signature? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CalculateSignature()] [Withholding Attack] If some miners haven't submitted signatures, does Aggregate still proceed with nulls, weakening final signature security? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: CalculateSignature()] [Race Condition] Reading RealTimeMinersInformation.Values during Aggregate without lock - can concurrent signature updates cause inconsistent aggregation? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExtraBlockMiningTime()] [Timestamp Overflow] AddMilliseconds() on Timestamp near max value could overflow - does overflow wrap to distant past, allowing extra block at invalid time? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExtraBlockMiningTime()] [Order Manipulation] Uses OrderBy().Last() to find last miner - if attacker adds miner with Order = int.MaxValue, would this become last regardless of expected time sequence? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExtraBlockMiningTime()] [Empty Collection] What if RealTimeMinersInformation is empty? OrderBy().Last() throws exception rather than returning graceful error? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExtraBlockMiningTime()] [Duplicate Orders] If multiple miners have same highest Order, Last() picks arbitrary one - can attacker exploit non-determinism to manipulate extra block timing? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs] [Function: GetExtraBlockMiningTime()] [Integer Conversion] GetMiningInterval() returns int, AddMilliseconds may expect long - does implicit conversion risk overflow or precision loss? (Low)"
]