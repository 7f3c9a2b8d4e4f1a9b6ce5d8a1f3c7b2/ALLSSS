[
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: AssertSymbolToPayTxFeeIsValid()] [Token Availability Check] At line 1420, IsTokenAvailableForMethodFee is called but its implementation is not in this file - can blacklisted or special tokens bypass this check through that function's logic? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeTransactionFees()] [Cross-Contract Call Trust] At line 38-39, GetMethodFee is called on input.ContractAddress - if that contract is malicious, can it return manipulated MethodFees to overcharge or undercharge? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeUserContractTransactionFees()] [Configuration Key Injection] At line 143, configuration key is built as 'UserContractMethod_{contractAddress}_{methodName}' - can attacker use contract/method names with '_' to inject wrong key and get different fees? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetActualFee()] [MergeFrom Validation] At line 148 and 163, fee.MergeFrom(spec.Value) is called - if spec.Value contains malicious protobuf data, can this cause deserialization vulnerability or state corruption? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetActualFee()] [Null vs Empty Differentiation] Lines 146-150 check IsNullOrEmpty and return early - but line 158-164 check IsNullOrEmpty and return empty object - inconsistent null handling can cause different behavior, exploitable? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetBaseFeeDictionary()] [Symbol Null/Empty Filter] At line 324, filters where symbol is not null or empty - but what if symbol is whitespace-only string? Can this cause fee charging with invalid symbol key? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetBaseFeeDictionary()] [Sum Overflow] At line 326, groups fees by symbol and sums BasicFee - if multiple fees for same symbol have values near MAX_LONG, can Sum() overflow? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetUserContractFeeDictionary()] [Identical Logic] Lines 329-333 are identical to GetBaseFeeDictionary - why separate function? Can inconsistency in future updates cause security issues? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TryToChargeTransactionFee()] [Bill Reference Mutation] At line 90 and 94, bill and allowanceBill are passed by ref - if ChargeTransactionFeesToBill or ChargeFromDelegations partially modify these then fail, are changes rolled back or persisted? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: TryToChargeTransactionFee()] [Delegation State Paths] Lines 100-102 use ?? operator between TransactionFeeDelegateInfoMap and TransactionFeeDelegateesMap - if contract-method-specific delegate exists but is empty, does it fallback to global or treat as no delegates? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeFromDelegations()] [Foreach Dictionary Mutation] Lines 183-207 iterate over delegationInfo.Delegatees dictionary, and line 196-199 assigns to bill/allowanceBill/fromAddress - if iteration continues after break, are modified variables safe from corruption? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyDelegation()] [Nested State Access] Lines 218-222 access State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName].Delegatees[delegateeAddress.ToBase58()].Delegations[symbol] - if any intermediate value is null, does this throw or create empty entries? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: SetOrRefreshTransactionFeeFreeAllowances()] [Loop State Modification] Lines 308-319 iterate and potentially modify State.TransactionFeeFreeAllowancesLastRefreshTimes and State.TransactionFeeFreeAllowances - can modifying state while iterating cause skipped or duplicate processing? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeBaseFee()] [Allowance Comparison Edge Case] At line 359, checks existingAllowance > amountToChargeBaseFee - if equal exactly, else branch at line 367 uses Sub() which would return 0, is this handled correctly downstream? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GenerateBill()] [Addition Before Comparison] At line 525, checks availableBalance.Add(availableAllowance) > txSizeFeeAmount - if Add causes overflow, comparison becomes invalid, can this bypass fee checks? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GenerateBill()] [Subtraction Chain] At line 536, chargeAmount = txSizeFeeAmount.Sub(chargeAllowanceAmount) - if txSizeFeeAmount < chargeAllowanceAmount due to calculation error, does Sub underflow? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: IsDelegationEnough()] [Ternary Overflow] At line 1405-1406, uses delegations.Delegations[txSymbol].Sub(cost) in ternary condition - if Sub underflows, does condition evaluate incorrectly? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: PayRental()] [Multiply Chain Overflow] At line 1061, duration.Mul(ResourceAmount).Mul(Rental) - two multiplications in chain, if any intermediate result overflows, final rental is wrong? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeTransactionFees()] [Multi-Delegatee Iteration] Lines 106-114 iterate through delegatees and break on first success - if first delegatee has insufficient balance but second would succeed, does order manipulation allow fee evasion? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyBalance()] [Event Before State] At line 249-254, TransactionFeeCharged event is fired but corresponding balance modifications happen before - if event handler triggers actions, do they see updated or stale balances? (Low)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyBalance()] [Multiple Symbol Processing] Lines 245-255 and 259-265 process fees and allowances in separate loops - if first loop succeeds but second fails, is transaction atomic or partially charged? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ClaimTransactionFees()] [Nested Inline Calls] At line 889, TransferTransactionFeesToFeeReceiver is called which itself calls Context.SendInline at lines 1164, 1193, 1204 - can nested inline calls cause gas exhaustion or unexpected execution order? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ChargeTransactionFees()] [Delegatee List DOS] Lines 106-114 iterate unlimited delegatees list - can attacker add thousands of delegatees to cause gas exhaustion and DOS transaction fee collection? (High)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: GetAvailableSymbolToPayTxFee()] [Symbol List Iteration] Lines 473-511 iterate over allSymbolToTxFee list without bounds check - can huge symbol list cause out-of-gas and prevent fee charging? (Medium)",
  "[File: contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs] [Function: ModifyBalance()] [Allowance Map Iteration] Lines 259-265 iterate freeAllowancesMap - if ConfigTransactionFeeFreeAllowances sets thousands of symbols, can this DOS fee collection? (Medium)"
]