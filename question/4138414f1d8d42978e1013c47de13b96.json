[
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [Treasury Release Incorrect Triggering] If cached _isMainChain causes Release() to be called on wrong chain at line 83, could this drain side-chain funds or fail to release main-chain treasury when required, breaking economic model? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [IsInMinerList False Negative] If PreCheck at lines 326-327 evaluates IsInMinerList with Context.RecoverPublicKey() but uses cached _processingBlockMinerPubkey for authorization decisions, could signature verification pass but wrong miner identity be authorized? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [MinerInRound Null Reference] At lines 242, 303 of ProcessConsensusInformation, if stale _processingBlockMinerPubkey doesn't exist in currentRound.RealTimeMinersInformation, could dictionary lookup throw KeyNotFoundException, causing DoS? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [Evil Miner Detection Bypass] At lines 139-154 of ProcessNextRound, if cached _isMainChain=false on main chain, could evil miners escape detection and punishment, allowing continuous malicious behavior without Election contract marking? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [Random Hash Verification with Wrong Key] At line 77 of ProcessConsensusInformation, if ECVrfVerify uses Context.RecoverPublicKey() but _processingBlockMinerPubkey is stale and used elsewhere, could verification succeed but event attribution fail, breaking random number audit trail? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [Cached vs State Value Desync] Since IsMainChain property at lines 12-20 of HelpMethods only sets _isMainChain from State if null, if State.IsMainChain.Value changes mid-execution, could cached value become stale within single complex transaction? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [Tiny Block Continuous Production Limit Bypass] If _processingBlockMinerPubkey is wrong in ResetLatestProviderToTinyBlocksCount, could attacker produce unlimited continuous tiny blocks by avoiding BlocksCount decrement for their actual pubkey? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [Period Seconds Configuration Error] In GetConsensusCommand at line 42, if cached _isMainChain is wrong, could MainChainConsensusBehaviourProvider receive/not receive State.PeriodSeconds.Value incorrectly, breaking time slot calculations? (Medium)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [TuneOrderInformation Misapplication] At lines 259-260 of ProcessUpdateValue, if wrong miner's FinalOrderOfNextRound is updated due to stale _processingBlockMinerPubkey in current context, could round ordering be corrupted for next term? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [ImpliedIrreversibleBlockHeight Misassignment] At line 248 of ProcessUpdateValue, if ImpliedIrreversibleBlockHeight is written to wrong miner due to cache pollution, could LIB calculation at line 268-282 produce incorrect height, breaking finality guarantees? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [Blockchain Start Timestamp Logic Skip] If cached _isMainChain is false during first round on main chain, could SetBlockchainStartTimestamp at line 123 be skipped or executed with wrong parameters, breaking all time-based consensus logic? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [Round.ToString Miner Highlight Error] When logging at line 73 with ToString(_processingBlockMinerPubkey), if cached pubkey is stale, could debug logs highlight wrong miner, severely complicating consensus debugging and incident response? (Low)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [UpdateMinersCount to Election Incorrect Call] At lines 126-135 of ProcessNextRound, if cached _isMainChain triggers Election contract call on side chain, could this create invalid cross-contract state or cause Election contract to reject transaction? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [EncryptedPieces Wrong Miner Storage] At line 290 of PerformSecretSharing, if _processingBlockMinerPubkey is stale, could EncryptedPieces be stored in wrong miner's record, causing secret sharing protocol to fail when pieces need to be decrypted later? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [PreviousInValue Overwrite Attack] At line 264 of ProcessUpdateValue, if cached pubkey causes PreviousInValue to be written to wrong miner, could attacker manipulate which miner's value is considered for random number generation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [DonateMiningReward Wrong Chain Execution] At line 203 of ProcessNextTerm, if cached _isMainChain affects DonateMiningReward logic, could rewards be donated/not donated incorrectly, breaking economic incentive model? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [Signature Field Corruption] At line 244 of ProcessUpdateValue, if Signature is assigned to wrong miner due to cache pollution, could subsequent signature verification or secret sharing fail, halting consensus progression? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [SecretSharingInformation Event Wrong Chain] If cached _isMainChain affects Context.Fire(SecretSharingInformation) at line 110-115, could side chains receive main chain secret sharing events or vice versa, corrupting random number generation? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [OutValue Assignment to Wrong Miner] At line 245 of ProcessUpdateValue, if OutValue is assigned to incorrect miner, could the consensus random hash chain be broken, allowing predictability or manipulation of future random numbers? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [SupposedOrderOfNextRound Manipulation] At lines 246-247 of ProcessUpdateValue, if wrong miner gets SupposedOrderOfNextRound and FinalOrderOfNextRound, could attacker control mining order in next round, enabling time slot manipulation or DoS? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [IrreversibleBlockFound Event Wrong Chain] At line 275-278 of ProcessUpdateValue, if cached _isMainChain causes IrreversibleBlockFound to fire on wrong chain, could cross-chain indexing or finality tracking be corrupted? (High)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _processingBlockMinerPubkey] [ProducedBlocks Increment Wrong Target] At lines 251-252 of ProcessUpdateValue, if ProducedBlocks/ProducedTinyBlocks are incremented for wrong miner, could reward distribution be completely inverted, enriching non-producers at expense of actual miners? (Critical)",
  "[File: contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_CacheFileds.cs] [Field: _isMainChain] [Cached Field Never Cleared Warning Ignored] The comment at lines 5-6 explicitly warns to clear cache after each transaction - if _isMainChain is never cleared anywhere in codebase, is this a systematic vulnerability affecting all chain-type-dependent logic? (Critical)"
]