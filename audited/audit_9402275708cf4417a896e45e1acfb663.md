### Title
Enum Corruption Allows Consensus Validation Bypass via Undefined Behaviour Values

### Summary
The `ValidateBeforeExecution` function's switch statement lacks cases for `TinyBlock`, `Nothing`, and undefined enum values, causing it to fall through without adding behavior-specific validators. An attacker can exploit Protobuf3's permissive deserialization to inject undefined `Behaviour` values (e.g., 5, 6, 7), bypassing critical validators like `LibInformationValidationProvider` and `RoundTerminateValidationProvider`, potentially enabling consensus stall attacks or acceptance of malformed blocks with manipulated LIB heights and round numbers.

### Finding Description
The root cause is in the switch statement that only handles three of the five defined enum values: [1](#0-0) 

The `AElfConsensusBehaviour` enum defines five values (UPDATE_VALUE=0, NEXT_ROUND=1, NEXT_TERM=2, NOTHING=3, TINY_BLOCK=4): [2](#0-1) 

However, the switch statement has no cases for `TinyBlock`, `Nothing`, or any undefined values. When these behaviors occur, no behavior-specific validators are added—only the three basic validators.

Protobuf3 accepts any integer value during deserialization, even undefined enum values. The deserialization entry point: [3](#0-2) 

When `extraData.Behaviour` contains an undefined value (5 or higher):
1. The switch falls through without matching any case
2. Only basic validators run (mining permission, time slot, continuous blocks)
3. Critical validators are skipped that would normally catch:
   - LIB height regression [4](#0-3) 
   - Invalid round/term transitions [5](#0-4) 
   - Missing consensus values [6](#0-5) 

4. Recovery methods don't trigger: [7](#0-6) 

5. Transaction generation returns empty list: [8](#0-7) 

### Impact Explanation
A malicious miner can craft blocks with undefined `Behaviour` values that:

1. **Bypass LIB protection:** Include decreased `ConfirmedIrreversibleBlockHeight` values that would normally be rejected, potentially causing last irreversible block heights to regress—violating consensus invariants

2. **Bypass round/term validation:** Include incorrect round or term numbers that skip proper transition checks, allowing invalid consensus state updates

3. **Consensus stall:** Blocks pass validation but generate no consensus transactions, causing consensus state to freeze and the chain to halt

4. **State inconsistency:** The blockchain accepts blocks that don't properly update consensus state, leading to divergent node states

**Severity: HIGH** - This enables consensus integrity violations and network-wide DoS attacks affecting all nodes and users.

### Likelihood Explanation
**Attacker Requirements:**
- Must be a valid miner (passes `MiningPermissionValidationProvider`)
- Must produce during their time slot (passes `TimeSlotValidationProvider`)
- Must craft a protobuf message with undefined `Behaviour` value

**Attack Complexity: LOW**
- Simply set the `Behaviour` field to value 5 or higher in the protobuf message
- Include malicious round information that would be rejected by behavior-specific validators
- No complex state manipulation or race conditions required

**Feasibility: HIGH** - Any malicious miner can execute this with basic protobuf knowledge. The attack is:
- **Reachable:** Public entry point via block production
- **Practical:** Executable under normal AElf semantics
- **Economically Rational:** Miner is already in the system; no additional costs beyond normal block production

**Detection: MEDIUM** - Undefined values might appear in logs but won't trigger automatic alerts unless specifically monitored.

### Recommendation
Add explicit enum validation and default case handling:

**1. Add enum range validation before the switch:**
```csharp
// After line 60, before switch statement
if (!Enum.IsDefined(typeof(AElfConsensusBehaviour), extraData.Behaviour))
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"Invalid consensus behaviour value: {(int)extraData.Behaviour}" 
    };
}
```

**2. Add missing cases to the switch statement:**
```csharp
case AElfConsensusBehaviour.TinyBlock:
    // TinyBlock intentionally uses only basic validators
    break;
case AElfConsensusBehaviour.Nothing:
    return new ValidationResult 
    { 
        Success = false, 
        Message = "Blocks should not be produced with Nothing behaviour" 
    };
default:
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"Unsupported consensus behaviour: {extraData.Behaviour}" 
    };
```

**3. Add regression test:**
- Test deserialization of protobuf with Behaviour=5
- Verify validation rejects undefined enum values
- Test that TinyBlock and Nothing behaviors are handled correctly

### Proof of Concept
**Initial State:** Miner M is in current round's miner list with valid time slot

**Attack Steps:**
1. Miner M waits for their designated time slot
2. Craft malicious `AElfConsensusHeaderInformation` protobuf:
   - `sender_pubkey` = M's public key
   - `behaviour` = 5 (undefined enum value)
   - `round.confirmed_irreversible_block_height` = (current LIB - 100)
   - `round.round_number` = (current round + 5) 
3. Serialize and submit block with this consensus header extra data
4. Validation flow executes `ValidateConsensusBeforeExecution`

**Expected Result:** Block rejected with "Incorrect lib information" error from `LibInformationValidationProvider`

**Actual Result:** 
- Switch statement falls through without adding `LibInformationValidationProvider`
- Only basic validators run (all pass for valid miner in time slot)
- Validation returns `Success=true`
- Block accepted but `GenerateConsensusTransactions` returns empty list
- Consensus state not updated; potential LIB regression recorded in block header

**Success Condition:** Block validation succeeds despite containing consensus data that would normally be rejected by behavior-specific validators

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** protobuf/aedpos_contract.proto (L321-327)
```text
enum AElfConsensusBehaviour {
    UPDATE_VALUE = 0;
    NEXT_ROUND = 1;
    NEXT_TERM = 2;
    NOTHING = 3;
    TINY_BLOCK = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L180-182)
```csharp
            default:
                return new TransactionList();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L28-46)
```csharp
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```
