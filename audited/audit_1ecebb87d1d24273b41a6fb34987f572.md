# Audit Report

## Title
Missing Validation of Decrypted Secret Shares Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract accepts decrypted secret shares from miners without cryptographic validation, allowing malicious miners to submit arbitrary fake shares. These fake shares are then used to reconstruct invalid `PreviousInValue` entries that corrupt signature calculations and mining order determination, breaking consensus integrity.

## Finding Description

The vulnerability exists in the secret sharing mechanism used for InValue recovery when miners fail to self-reveal. The system has two distinct paths for setting `PreviousInValue`:

**Path 1 (Self-Revelation - Protected):** When a miner provides their own `PreviousInValue` directly, it is validated against their previous `OutValue`. [1](#0-0) 

**Path 2 (Secret Sharing Reconstruction - Unprotected):** When other miners submit decrypted shares to reconstruct a miner's `PreviousInValue`, no validation occurs:

1. **Entry Point 1:** `UpdateLatestSecretPieces()` accepts and stores decrypted pieces without validation. [2](#0-1) 

2. **Entry Point 2:** `PerformSecretSharing()` also stores decrypted pieces without validation. [3](#0-2) 

3. **Reconstruction:** `RevealSharedInValues()` uses `SecretSharingHelper.DecodeSecret()` to reconstruct the InValue and directly stores it as `PreviousInValue` without checking if `Hash(revealedInValue) == OutValue` from the previous round. [4](#0-3) 

The `SecretSharingHelper.DecodeSecret()` function performs pure Lagrange interpolation and will always produce output regardless of whether the input shares are valid or fake. [5](#0-4) 

**Critical Impact Path:** The fake `PreviousInValue` is subsequently used in `SupplyCurrentRoundInformation()` to calculate signatures for miners who didn't produce blocks. [6](#0-5)  These signatures directly determine mining order in future rounds through the `ApplyNormalConsensusData` logic. [7](#0-6) 

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation**

This vulnerability breaks the core security guarantee of the consensus mechanism:

1. **Signature Corruption:** Fake `PreviousInValue` entries result in incorrect signature calculations for miners who fail to produce blocks. These corrupted signatures are stored in the consensus state and used to determine the mining order for subsequent rounds.

2. **Mining Order Manipulation:** Since mining order is derived from signatures, attackers can influence which miners produce blocks when, potentially enabling:
   - Coordinated attacks by controlling miner scheduling
   - Denial of service against specific honest miners
   - Manipulation of consensus timing and block production patterns

3. **Secret Sharing Mechanism Failure:** The entire purpose of Shamir's Secret Sharing is to enable trustless recovery of InValues. With unvalidated decrypted shares, the recovery mechanism becomes unreliable, forcing the system to depend solely on self-revelation and eliminating the fault-tolerance benefit.

4. **Persistent State Corruption:** Fake decrypted pieces are stored in contract state and persist across rounds, causing ongoing damage to consensus integrity.

## Likelihood Explanation

**HIGH Likelihood**

**Attacker Requirements:**
- Must be an active miner in the current round (normal consensus participant privilege)
- No special cryptographic capabilities needed beyond normal mining operations

**Attack Execution:**
1. During block production, attacker submits `UpdateValueInput` or produces a block with `triggerInformation` containing fake `decrypted_pieces` for target miners
2. The contract stores these fake pieces without validation
3. When `RevealSharedInValues()` executes during the next round transition, it reconstructs fake `PreviousInValue` entries
4. These fake values corrupt signature calculations in `SupplyCurrentRoundInformation()`

**No Barriers:**
- No validation checks exist to prevent the attack
- The attack triggers whenever secret sharing is enabled [8](#0-7) 
- Detection is difficult since fake shares appear as valid byte arrays on-chain
- Cost is only normal transaction fees

## Recommendation

Add cryptographic validation when reconstructing InValues from decrypted shares. After reconstruction in `RevealSharedInValues()`, verify that the reconstructed value matches the expected `OutValue`:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    var revealedInValue =
        HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
    
    // ADD VALIDATION: Verify reconstructed value matches previous OutValue
    if (!TryToGetPreviousRoundInformation(out var previousRoundForValidation)) return;
    
    if (previousRoundForValidation.RealTimeMinersInformation.ContainsKey(publicKeyOfAnotherMiner))
    {
        var expectedOutValue = previousRoundForValidation.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
        if (expectedOutValue != null && HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
        {
            Context.LogDebug(() => $"Reconstructed InValue validation failed for {publicKeyOfAnotherMiner}");
            continue; // Skip storing invalid reconstructed value
        }
    }
    
    currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
}
```

Additionally, consider adding validation when decrypted pieces are initially submitted by verifying they can be correctly decrypted from the corresponding encrypted pieces using the submitter's public key.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanCorruptConsensus_WithFakeDecryptedShares()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMiners(3);
    var maliciousMiner = miners[0];
    var targetMiner = miners[1];
    
    // Round N: Target miner produces block with OutValue
    var targetInValue = HashHelper.ComputeFrom("legitimate_secret");
    var targetOutValue = HashHelper.ComputeFrom(targetInValue);
    await targetMiner.ProduceBlock(targetInValue, targetOutValue);
    
    // Round N+1: Malicious miner submits FAKE decrypted pieces for target
    var fakeDecryptedPiece = ByteString.CopyFrom(new byte[32]); // Arbitrary garbage
    var updateInput = new UpdateValueInput
    {
        DecryptedPieces = { { targetMiner.PublicKey, fakeDecryptedPiece } }
    };
    
    await maliciousMiner.UpdateValue(updateInput);
    
    // Trigger round transition to invoke RevealSharedInValues
    await maliciousMiner.NextRound();
    
    // VERIFY: Target miner's PreviousInValue is now corrupted
    var currentRound = await GetCurrentRoundInformation();
    var storedPreviousInValue = currentRound.RealTimeMinersInformation[targetMiner.PublicKey].PreviousInValue;
    
    // The stored value should equal targetInValue, but instead it's corrupted
    Assert.NotEqual(targetInValue, storedPreviousInValue);
    
    // VERIFY: Corrupted value affects signature calculation
    var corruptedSignature = currentRound.RealTimeMinersInformation[targetMiner.PublicKey].Signature;
    var expectedSignature = CalculateExpectedSignature(targetInValue);
    Assert.NotEqual(expectedSignature, corruptedSignature);
    
    // Result: Mining order is now based on corrupted signatures
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
