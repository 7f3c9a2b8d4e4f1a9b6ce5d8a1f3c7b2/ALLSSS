### Title
Unvalidated DecryptedPieces Enable Consensus Randomness Manipulation via Corrupted Secret Reconstruction

### Summary
The `RevealSharedInValues()` function in the AEDPoS consensus contract only validates the count of `DecryptedPieces` but not their content validity. A malicious miner can provide garbage data instead of correctly decrypted pieces, corrupting the Shamir's Secret Sharing reconstruction of other miners' in-values and compromising consensus randomness for next-round mining order determination.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The validation only checks the quantity of pieces, not their cryptographic validity or correctness: [1](#0-0) 

The `DecryptedPieces` are provided by miners through trigger information without any integrity verification: [2](#0-1) 

When `RevealSharedInValues()` uses these pieces for secret reconstruction via Shamir's Secret Sharing, even one corrupted piece among the threshold selection will produce a completely incorrect result: [3](#0-2) 

The `DecodeSecret` function has no validation and accepts any byte array data: [4](#0-3) 

**Why Protections Fail:**
The reconstructed incorrect `PreviousInValue` is assigned without validation: [5](#0-4) 

When a miner misses their time slot, `SupplyCurrentRoundInformation` uses this corrupted value to calculate their signature, which directly affects next round mining order: [6](#0-5) 

The signature calculation uses the `PreviousInValue` and determines mining order through modulo operation: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Consensus Integrity Compromise:**
- A malicious miner provides garbage in `DecryptedPieces` for target miners
- When target miners miss their time slot (network issues, operational problems, or induced failures)
- Their signature is calculated using the corrupted `PreviousInValue`
- This manipulates the `supposedOrderOfNextRound` calculation, affecting who mines in advantageous positions
- Breaks the unpredictability guarantee of consensus randomness

**Who is Affected:**
- All miners whose in-values are reconstructed using the corrupted pieces
- The entire network's consensus fairness and security
- Mining reward distribution becomes manipulable

**Severity Justification:**
HIGH - This violates the critical consensus invariant that mining order must be deterministic and unpredictable based on cryptographically secure randomness. Compromising this enables strategic positioning attacks, block withholding, and unfair mining advantage.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus set (realistic for blockchain validators)
- Only needs to modify their own `triggerInformation.DecryptedPieces` when producing blocks
- No special privileges beyond normal miner operations required

**Attack Complexity:**
- LOW - Trivial to execute: simply provide arbitrary bytes instead of correctly decrypted pieces
- No cryptographic breaking required
- Can target specific miners by choosing which `DecryptedPieces` entries to corrupt

**Feasibility:**
- Probability of successful corruption: ~66% (minimumCount/minersCount ratio)
- Since `DecodeSecret` uses first `minimumCount` pieces from the dictionary, and the corrupted piece has a 2/3 chance of being selected
- Attack succeeds whenever target miner misses their time slot (common due to network latency, operational issues)
- Multiple miners colluding increases corruption probability to 100%

**Detection Constraints:**
- Extremely difficult to detect on-chain as garbage data looks like valid byte arrays
- No cryptographic signature or hash to verify correctness
- Appears as legitimate consensus operation

### Recommendation

**Immediate Mitigation:**
Add cryptographic validation of decrypted pieces before reconstruction:

1. Store the hash of each encrypted piece when published in `EncryptedPieces`
2. When decrypted pieces are provided, verify they decrypt correctly by re-encrypting and comparing hashes
3. Add zero-knowledge proof or commitment scheme to verify decryption correctness without revealing the private key
4. Implement cross-validation: require multiple miners to reveal the same piece and verify consistency

**Code-Level Fix:**
```plaintext
In RevealSharedInValues():
- Before line 50, add validation loop to verify each DecryptedPiece
- Check that DecryptedPieces from different miners for the same target are consistent
- Require consensus (e.g., majority agreement) on each piece value
- Skip pieces that don't match the majority
```

**Invariant Checks:**
- Assert that reconstructed `PreviousInValue` hashes to the recorded `OutValue` from previous round
- If validation fails, use fallback mechanism (fake in-value) instead of corrupted value
- Log validation failures for monitoring

**Test Cases:**
- Unit test: Provide garbage `DecryptedPieces` and verify reconstruction fails safely
- Integration test: Simulate miner providing corrupted pieces and verify it doesn't affect consensus
- Adversarial test: Multiple miners colluding with garbage data

### Proof of Concept

**Initial State:**
- Round N-1: Miner A publishes `EncryptedPieces` for all miners (valid shares of their in-value)
- Round N: Miners B, C, D decrypt their pieces correctly

**Attack Steps:**
1. Malicious Miner B produces a block in Round N
2. Instead of providing correct decrypted piece: `triggerInformation.DecryptedPieces[A] = GARBAGE_BYTES`
3. Contract executes `UpdateLatestSecretPieces()`, storing garbage in `MinerA.DecryptedPieces[B]`
4. Extra block producer triggers round N to N+1 transition
5. `RevealSharedInValues()` executes, using `MinerA.DecryptedPieces` (including garbage) for reconstruction
6. `DecodeSecret()` produces incorrect result due to corrupted share
7. Incorrect `PreviousInValue` assigned to Miner A in current round
8. If Miner A misses time slot, `SupplyCurrentRoundInformation()` uses corrupted value
9. Calculates wrong signature for Miner A
10. Next round mining order is manipulated

**Expected vs Actual:**
- **Expected:** Miner A's reconstructed in-value matches their actual in-value, signature is correct
- **Actual:** Reconstructed in-value is cryptographically incorrect, signature is wrong, mining order manipulated

**Success Condition:**
When `SupplyCurrentRoundInformation()` executes and Miner A has `OutValue == null`, their signature is calculated using the corrupted `PreviousInValue` instead of the correct value, resulting in manipulated mining order for the next round.

### Notes

This vulnerability exploits the trust assumption that miners will honestly provide correctly decrypted pieces. The secret sharing mechanism relies on cryptographic correctness of shares, but the on-chain validation only checks quantities, not cryptographic validity. Even a single corrupted piece among the reconstruction threshold completely breaks Shamir's Secret Sharing security guarantees.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-50)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
