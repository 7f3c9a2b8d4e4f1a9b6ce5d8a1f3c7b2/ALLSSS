# Audit Report

## Title
Unauthorized Extra Block Producer Privilege Escalation in Term Transition

## Summary
Any miner can claim the `ExtraBlockProducerOfPreviousRound` privilege by producing the block that triggers a term/round transition, even if they were not the designated extra block producer. This grants unauthorized mining privileges before the new round officially starts, resulting in unfair block reward allocation and violation of consensus protocol fairness guarantees.

## Finding Description

The vulnerability exists in two critical locations where `ExtraBlockProducerOfPreviousRound` is assigned without validation:

**Primary Location - NextTerm Transition**: The `GenerateFirstRoundOfNextTerm()` method unconditionally assigns the sender as the extra block producer of the previous round. [1](#0-0) 

**Secondary Location - NextRound Transition**: The `GetConsensusExtraDataForNextRound()` method performs the same unconditional assignment for NextRound transitions. [2](#0-1) 

**Root Cause**: The code does NOT verify that the sender was actually the designated extra block producer (marked with `IsExtraBlockProducer = true`) in the previous round. The protocol intentionally designates ONE specific miner as the extra block producer through deterministic calculation. [3](#0-2)  However, this designation is ignored when assigning the privilege for the next round.

**Why Existing Protections Fail**:

The `PreCheck()` method only validates miner list membership, not extra block producer status. [4](#0-3) 

The validation providers (`MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, `RoundTerminateValidationProvider`) similarly only check miner list membership, time slot correctness, and round/term numbers—NONE verify the extra block producer role. [5](#0-4) [6](#0-5) 

**Privilege Exploitation**: The `ExtraBlockProducerOfPreviousRound` field grants special mining privileges. The `IsCurrentMiner()` method explicitly allows this miner to produce blocks BEFORE the round officially starts (when `CurrentBlockTime <= GetRoundStartTime()`). [7](#0-6)  This enables the attacker to mine additional blocks beyond their normal time slot allocation.

## Impact Explanation

**Direct Harm - Unfair Block Reward Allocation**: The attacking miner produces extra blocks beyond their allocated time slot, directly increasing their `ProducedBlocks` count. [8](#0-7)  Block rewards are calculated as total mined blocks multiplied by reward per block, meaning extra blocks translate directly to extra rewards. [9](#0-8) [10](#0-9) 

**Consensus Fairness Violation**: The extra block producer role is deterministically assigned through `CalculateNextExtraBlockProducerOrder()` to ensure fair distribution. [11](#0-10)  Allowing any miner to claim this privilege undermines the consensus protocol's fairness guarantees and violates the intended miner schedule.

**Affected Parties**:
- Legitimate extra block producers lose their designated mining opportunity
- Other miners receive proportionally smaller reward shares
- Overall consensus protocol integrity is compromised

**Severity Justification**: HIGH - This directly violates a critical consensus invariant (miner schedule integrity), causes measurable reward misallocation, and can be exploited by any miner without detection.

## Likelihood Explanation

**Attacker Capabilities**: Any miner in the active miner list can execute this attack. No special privileges beyond normal mining rights are required.

**Attack Complexity**: LOW
- Simply produce a block when term/round transition conditions are met
- When `NeedToChangeTerm()` returns true (based on two-thirds of miners' mining times reaching the threshold), multiple miners may be in valid time slots. [12](#0-11) 
- The consensus behavior provider determines NextTerm/NextRound based on round state, not miner role. [13](#0-12) 

**Feasibility Conditions**: 
- Attack window opens whenever term change conditions are met (periodically, typically every 7 days)
- Multiple miners may be eligible to produce blocks when this occurs
- First miner to produce a NextTerm/NextRound block captures the privilege

**Detection Difficulty**: The attack is difficult to detect because it appears as legitimate consensus behavior—a valid NextTerm transaction from a legitimate miner. No transaction-level anomaly occurs; the issue is in the privilege assignment logic itself.

**Probability**: MEDIUM-HIGH - Every term transition presents an opportunity. Rational miners are economically incentivized to front-run term transitions to capture additional rewards.

## Recommendation

Add validation to verify that the sender was actually the designated extra block producer before assigning the `ExtraBlockProducerOfPreviousRound` privilege:

**For `GenerateFirstRoundOfNextTerm()`**:
```csharp
// After line 253, add validation before assignment:
var previousExtraBlockProducer = currentRound.GetExtraBlockProducerInformation();
if (previousExtraBlockProducer != null && previousExtraBlockProducer.Pubkey == senderPubkey)
{
    newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
}
else
{
    // Only set if sender was the actual extra block producer
    newRound.ExtraBlockProducerOfPreviousRound = string.Empty;
}
```

**For `GetConsensusExtraDataForNextRound()`**:
```csharp
// Replace line 178 with validation:
var previousExtraBlockProducer = currentRound.GetExtraBlockProducerInformation();
if (previousExtraBlockProducer != null && previousExtraBlockProducer.Pubkey == pubkey)
{
    nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
}
else
{
    nextRound.ExtraBlockProducerOfPreviousRound = string.Empty;
}
```

Alternatively, add a dedicated validation provider that checks the extra block producer role during `ValidateBeforeExecution` for NextTerm and NextRound behaviors.

## Proof of Concept

```csharp
[Fact]
public async Task ExtraBlockProducerPrivilegeEscalation_AnyMinerCanClaim()
{
    // Setup: Create initial miners and advance to near term end
    var initialMiners = GenerateMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Get current round and identify designated extra block producer
    var currentRound = await GetCurrentRound();
    var designatedExtraProducer = currentRound.RealTimeMinersInformation.Values
        .First(m => m.IsExtraBlockProducer);
    
    // Select different miner (attacker) to trigger NextTerm
    var attackerMiner = initialMiners.First(m => m != designatedExtraProducer.Pubkey);
    
    // Advance time to trigger term change condition
    await AdvanceToTermTransitionPoint();
    
    // Attacker produces NextTerm block
    var nextTermResult = await AttackerProducesNextTermBlock(attackerMiner);
    Assert.True(nextTermResult.Status == TransactionResultStatus.Mined);
    
    // Verify: Attacker now has ExtraBlockProducerOfPreviousRound privilege
    var newRound = await GetCurrentRound();
    Assert.Equal(attackerMiner, newRound.ExtraBlockProducerOfPreviousRound);
    Assert.NotEqual(designatedExtraProducer.Pubkey, newRound.ExtraBlockProducerOfPreviousRound);
    
    // Verify: Attacker can now mine before round starts
    await AdvanceTimeTo(newRound.GetRoundStartTime().AddMilliseconds(-1000));
    var canMine = await IsCurrentMiner(attackerMiner);
    Assert.True(canMine); // Attacker has unauthorized privilege
    
    // Verify: Attacker mines extra blocks and gains extra rewards
    var blocksBefore = newRound.RealTimeMinersInformation[attackerMiner].ProducedBlocks;
    await AttackerProducesExtraBlocks(attackerMiner, 3);
    var blocksAfter = (await GetCurrentRound()).RealTimeMinersInformation[attackerMiner].ProducedBlocks;
    
    Assert.True(blocksAfter > blocksBefore + 3); // Extra blocks produced
    // Rewards calculation will reflect these extra blocks
}
```

## Notes

This vulnerability represents a fundamental flaw in the consensus fairness mechanism. The `ExtraBlockProducerOfPreviousRound` privilege is designed to allow smooth transitions between rounds, but the lack of validation means this critical privilege can be hijacked by any miner who happens to produce the transition block. This not only results in unfair reward distribution but also undermines the deterministic and fair nature of the AEDPoS consensus protocol.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L395-399)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
            return new Int64Value
                { Value = currentRound.GetMinedBlocks().Mul(GetMiningRewardPerBlock()) };

        return new Int64Value { Value = 0 };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L191-196)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L28-28)
```csharp
            if (i == 0) minerInRound.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-120)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L30-35)
```csharp
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```
