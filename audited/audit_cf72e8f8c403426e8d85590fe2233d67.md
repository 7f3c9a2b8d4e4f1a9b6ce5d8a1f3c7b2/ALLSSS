# Audit Report

## Title
NextRound Mining Order Validation Checks Wrong Round Allowing Order Manipulation

## Summary
The `NextRoundMiningOrderValidationProvider` validates consensus data from the wrong round (ProvidedRound instead of BaseRound), causing validation to always pass with meaningless 0==0 checks. This allows the extra block producer to arbitrarily manipulate the `Order` field assignments in the next round, breaking the consensus fairness mechanism where mining order should be determined by cryptographic signature randomness.

## Finding Description
The AEDPoS consensus mechanism is designed to ensure fair mining order through cryptographic randomness. When miners produce blocks, they set their `FinalOrderOfNextRound` based on their signature values. [1](#0-0)  This value determines their position in the next round's mining schedule.

However, the validation logic for NextRound behavior contains a critical flaw. The `NextRoundMiningOrderValidationProvider` checks the ProvidedRound (the generated next round data): [2](#0-1) 

The ProvidedRound comes from `GetConsensusExtraDataForNextRound`, which calls `GenerateNextRoundInformation` to create fresh MinerInRound objects: [3](#0-2) 

These newly generated MinerInRound objects only contain basic fields (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots) and do NOT include `FinalOrderOfNextRound` or `OutValue`: [4](#0-3) 

Since both fields default to 0/null in the freshly generated next round, the validation check becomes `0 == 0`, which always passes. The validation should check BaseRound (current round from state) where miners who mined have both fields properly set.

More critically, the `Order` field itself is never validated. The NextRoundInput is directly converted and added to state without verifying that Order assignments match the FinalOrderOfNextRound values from the current round: [5](#0-4) 

The only other validation for NextRound behavior (`RoundTerminateValidationProvider`) only checks round number increment and null InValues, not Order correctness: [6](#0-5) 

The `Order` field directly determines `ExpectedMiningTime` in the mining schedule: [7](#0-6) 

**Attack Execution:**
1. Extra block producer obtains consensus extra data (legitimately generated next round)
2. Modifies Order values in RealTimeMinersInformation before creating NextRoundInput
3. Submits modified NextRoundInput via the public NextRound method: [8](#0-7) 
4. Validation passes (checks meaningless fields in wrong round)
5. Modified Order values are committed to state

## Impact Explanation
**Consensus Integrity Violation**: This vulnerability breaks the fundamental fairness mechanism of AEDPoS consensus. The protocol is designed so that miners who produce blocks earn their next round position deterministically through their signature randomness. An attacker can instead:

1. Assign favorable early positions (Order=1,2,3) to themselves or colluding parties
2. Push legitimate high-performing miners to disadvantaged later positions
3. Manipulate the entire mining schedule for the next round

**Secondary Effects**:
- Mining order affects block production timing and opportunities
- Early positions have advantage in producing blocks before others
- Order influences extra block producer selection for subsequent rounds (calculated from first miner's signature)
- Rewards and transaction fee collection opportunities are distributed unfairly

**Affected Parties**: All miners in the consensus system, as the manipulated schedule affects when each miner can produce blocks and their expected rewards.

## Likelihood Explanation
**Attacker Capabilities**: The extra block producer role is required to execute this attack. This is NOT a privileged or trusted role - it's a rotating position assigned to one miner each round based on deterministic calculation. Every miner eventually becomes the extra block producer.

**Attack Complexity**: Very low. The attacker:
1. Calls GetConsensusExtraData to obtain legitimately generated next round data
2. Modifies Order field values in the RealTimeMinersInformation dictionary
3. Submits the modified NextRoundInput to the public NextRound method

**Feasibility**: Extremely high. The validation flaw is structural - it checks fields that are always 0/null by design in the next round. There is no secondary validation of Order assignments. The attack works every time the attacker is the extra block producer.

**Detection Difficulty**: Hard to detect without off-chain monitoring that recomputes expected Order assignments and compares with submitted values. The manipulated round appears structurally valid (correct round number, null InValues, proper miner count).

**Economic Rationality**: Highly rational for any miner seeking competitive advantage. Better mining positions translate directly to more block production opportunities and rewards.

## Recommendation
Fix the validation to check the correct round data and validate Order assignments:

1. **Check BaseRound instead of ProvidedRound**: In `NextRoundMiningOrderValidationProvider`, validate that miners in BaseRound (current round) who have OutValue set also have FinalOrderOfNextRound set.

2. **Validate Order assignments**: Add a new validation step that verifies the Order values in ProvidedRound (next round) match the FinalOrderOfNextRound values from BaseRound (current round) for all miners who mined.

Example fix in NextRoundMiningOrderValidationProvider:
```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound;  // Check current round, not next round
    var providedRound = validationContext.ProvidedRound;
    
    // Validate that miners who mined have both OutValue and FinalOrderOfNextRound set
    var distinctCount = baseRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound in current round.";
        return validationResult;
    }
    
    // Validate that Order assignments in next round match FinalOrderOfNextRound from current round
    foreach (var minerInBase in baseRound.RealTimeMinersInformation.Values.Where(m => m.OutValue != null))
    {
        if (!providedRound.RealTimeMinersInformation.ContainsKey(minerInBase.Pubkey))
            continue;
            
        var minerInNext = providedRound.RealTimeMinersInformation[minerInBase.Pubkey];
        if (minerInNext.Order != minerInBase.FinalOrderOfNextRound)
        {
            validationResult.Message = $"Order mismatch for miner {minerInBase.Pubkey}";
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept
The vulnerability can be demonstrated by creating a test that:
1. Simulates a normal round where miners produce blocks and establish FinalOrderOfNextRound values
2. Has the extra block producer obtain the next round data
3. Modifies Order assignments to arbitrary values
4. Submits via NextRound and observes validation passes
5. Verifies the manipulated Order values are committed to state

The test would show that any Order assignments pass validation regardless of the legitimate FinalOrderOfNextRound values that miners earned through mining.

## Notes
This is a consensus-level vulnerability that violates the core fairness invariant of AEDPoS. The flaw is structural - the validation framework checks data from the wrong round where the validated fields are meaningless by design. The Order field, which controls the entire mining schedule, has no validation whatsoever against the deterministic FinalOrderOfNextRound values that miners earn through their cryptographic signatures.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
