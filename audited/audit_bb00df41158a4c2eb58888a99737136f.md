### Title
Decimal Overflow in Exponential Function Causes Transaction Failures and Pricing Errors in TokenConverter

### Summary
The `Exp` function in BancorHelper uses a 20-term Taylor series approximation that causes decimal arithmetic overflow when computing large negative exponents (≈ -100 or below). This vulnerability is triggered during TokenConverter Sell operations when production connector weight ratios (100x: 0.5 to 0.005) combine with moderate sell amounts (2-3x connector balance), causing either transaction failures or incorrect pricing calculations that could lead to fund losses.

### Finding Description

The vulnerability exists in the `Exp` function's power series implementation: [1](#0-0) 

The function computes exponential values using the Taylor series `exp(y) = 1 + y + y²/2! + y³/3! + ... + y²⁰/20!`. At line 160, it calculates `Pow(y, (uint)iteration) / fatorial` for each term. When `y` is a large negative number (e.g., -100 to -110), computing `Pow(y, 20)` results in values like `110^20 ≈ 1.97 × 10^41`, which exceeds `decimal.MaxValue ≈ 7.9 × 10^28`, causing arithmetic overflow.

This condition is reached through the `GetReturnFromPaid` function used in Sell operations: [2](#0-1) 

The formula computes `Exp(y * Ln(x))` where `y = fromConnectorWeight / toConnectorWeight` and `x = fromConnectorBalance / (fromConnectorBalance + paidAmount)`. 

**Production Weight Configuration Creates 100x Ratio:** [3](#0-2) 

Native token connectors use weight 0.5, while resource token connectors use weight 0.005, creating a weight ratio of `0.5 / 0.005 = 100`.

**Realistic Trigger Scenario:**
- User sells native tokens (weight 0.5) for resource tokens (weight 0.005)
- Connector balance: 1,000,000 tokens
- User sells: 2,000,000 tokens (2x balance)
- `x = 1,000,000 / (1,000,000 + 2,000,000) = 1/3 ≈ 0.333`
- `Ln(1/3) ≈ -1.099`
- `y * Ln(x) = 100 × (-1.099) = -109.9`
- Computing term 20: `(-109.9)^20 = 109.9^20 ≈ 1.97 × 10^41` → **OVERFLOW**

The Sell function calls this without upper-bound validation on input amounts: [4](#0-3) 

No checks prevent `input.Amount` from being significantly larger than connector balance, allowing the overflow condition to be triggered.

### Impact Explanation

**Operational Impact (High):**
- **Transaction Failures**: When connector liquidity is depleted (common during high trading volume or market stress), users attempting to sell 2-3x the remaining balance will trigger decimal overflow, causing transaction failures and DoS of the Sell functionality
- **Pricing Calculation Errors**: If overflow doesn't throw an exception but instead wraps/saturates to decimal.MaxValue or other undefined behavior, the `amountToReceive` calculation becomes incorrect, potentially allowing users to extract more funds than they should or receiving far less than deserved
- **Liquidity Lock**: As connector balance decreases, the threshold for triggering overflow decreases proportionally, making the system increasingly fragile

**Fund Impact (Medium to High):**
- If overflow behavior is undefined or returns incorrect values, users could exploit this to manipulate pricing calculations
- The formula `result = bt * (decimal.One - Exp(y * Ln(x)))` would produce dramatically wrong results if Exp returns an incorrect value
- Treasury and token holders could suffer losses if incorrect amounts are transferred

**Who is Affected:**
- Regular users trading tokens when liquidity is low
- The protocol's Treasury and token reserves
- Token converters with production weight configurations (0.5/0.005 ratio)

The vulnerability severity is **MEDIUM to HIGH** because while it requires specific conditions (depleted liquidity), those conditions occur naturally in production and the weight ratios that enable the vulnerability are hardcoded in the Economic contract initialization.

### Likelihood Explanation

**Highly Exploitable:**

1. **Reachable Entry Point**: The public `Sell()` method is directly accessible to any user without special permissions [5](#0-4) 

2. **Feasible Preconditions**: 
   - Production connector weights create 100x ratio (verified in EconomicContract initialization)
   - Users only need tokens to sell (acquired normally through trading)
   - No special permissions or governance actions required
   - Connector balance depletion happens naturally during normal trading

3. **Execution Practicality**:
   - Attack complexity: **LOW** - user simply calls Sell with amount 2-3x connector balance
   - No multi-step setup required
   - No timing dependencies or race conditions
   - Works within standard AElf contract execution model

4. **Economic Rationality**:
   - No significant cost to trigger (standard transaction fees)
   - Can occur accidentally during legitimate trading when liquidity is low
   - Attacker doesn't need large capital to attempt exploitation

5. **Detection/Operational Constraints**:
   - Difficult to detect before occurrence
   - Natural market conditions (liquidity depletion) create vulnerability window
   - No monitoring or alerting for dangerous ratio conditions

**Probability Assessment**: **HIGH** - This will occur naturally as connector balances fluctuate during normal operations. When native token connector balance drops below typical trade sizes, legitimate users will encounter this issue, causing operational disruption. The 100x weight ratio is hardcoded in production configuration, making this an inherent systemic risk rather than an edge case.

### Recommendation

**Immediate Mitigations:**

1. **Add Input Validation** in BancorHelper functions:
   ```csharp
   // In GetReturnFromPaid, before calling Exp
   var exponentValue = y * Ln(x);
   Assert(exponentValue > -30, "Exponent value too negative, risk of overflow");
   ```

2. **Implement Range Checks in Exp Function**: [1](#0-0) 
   
   Add validation at function entry:
   ```csharp
   private static decimal Exp(decimal y)
   {
       Assert(y > -30 && y < 100, "Exponent out of safe range for 20-term approximation");
       // ... existing implementation
   }
   ```

3. **Add Amount Ratio Checks in Sell Function**: [4](#0-3) 
   
   Add before calling GetReturnFromPaid:
   ```csharp
   var fromBalance = GetSelfBalance(fromConnector);
   Assert(input.Amount <= fromBalance * 2, "Sell amount too large relative to connector balance");
   ```

4. **Use Checked Arithmetic**: Wrap Pow calls in checked context to ensure overflow throws exception rather than producing undefined behavior

5. **Increase Taylor Series Terms**: Consider increasing `_LOOPS` from 20 to 40-50 terms for better convergence at moderate negative values, though this doesn't fully solve overflow for extreme values

6. **Alternative Implementation**: Consider using logarithm-based calculation or clamping strategies for extreme ratios

**Test Cases to Add:**
- Test Sell with amount = 2x, 5x, 10x connector balance
- Test with production weight ratios (0.5/0.005)
- Test Exp function with inputs from -30 to -100
- Verify overflow behavior and exception handling

### Proof of Concept

**Initial State:**
1. TokenConverter initialized with production weights
2. Native token connector: weight = 0.5, balance = 1,000,000 tokens (10^13 base units with 8 decimals)
3. Resource token connector: weight = 0.005, balance = 10,000,000 tokens
4. User has 2,000,000 native tokens to sell

**Exploitation Steps:**

1. User calls `Sell()`:
   - `input.Symbol` = Native token
   - `input.Amount` = 2,000,000 tokens (2 × 10^13 base units)
   - `input.ReceiveLimit` = 0 (no price limit)

2. Contract execution flow:
   - `fromConnector` = Native connector (weight 0.5, balance 10^13)
   - `toConnector` = Resource connector (weight 0.005)
   - Calls `BancorHelper.GetReturnFromPaid(10^13, 0.5, 10^14, 0.005, 2×10^13)`

3. BancorHelper computation:
   - `x = 10^13 / (10^13 + 2×10^13) = 10^13 / (3×10^13) = 0.333`
   - `y = 0.5 / 0.005 = 100`
   - `Ln(0.333) ≈ -1.099`
   - `y * Ln(x) = 100 × (-1.099) = -109.9`
   - Calls `Exp(-109.9)`

4. Exp function execution:
   - Loop iteration 20: attempts `Pow(-109.9, 20) / Fact[19]`
   - `Pow(-109.9, 20)` computes `109.9^20 ≈ 1.97 × 10^41`
   - **Decimal overflow occurs**: exceeds `decimal.MaxValue ≈ 7.9 × 10^28`

**Expected Result:** 
User receives proportional amount of resource tokens based on Bancor formula

**Actual Result:**
- Best case: `OverflowException` thrown, transaction fails with error
- Worst case: Overflow wraps/saturates, incorrect `amountToReceive` calculated, user receives wrong amount, potential fund loss

**Success Condition:** 
Transaction completes without overflow errors and returns mathematically correct conversion amount, even when sell amount significantly exceeds connector balance.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L222-235)
```csharp
                Weight = "0.5",
                VirtualBalance = EconomicContractConstants.NativeTokenConnectorInitialVirtualBalance
            }
        };
        foreach (var resourceTokenSymbol in Context.Variables
                     .GetStringArray(EconomicContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(EconomicContractConstants.PayRentalSymbolListName)))
        {
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```
