# Audit Report

## Title
Miner Order Manipulation via Brute-Force InValue Selection

## Summary
The AEDPoS consensus mechanism allows miners to manipulate their position in future mining rounds by brute-forcing InValue candidates offline. The on-chain validation only checks hash preimage correctness but does not verify that InValue was generated using the intended cryptographic signing method, enabling miners to select arbitrary values that optimize their mining schedule position.

## Finding Description

The vulnerability exists in the consensus order determination mechanism where mining position for round N+1 is calculated from a signature derived from the miner's InValue revealed in round N.

**Order Calculation:** The mining order is determined by converting the signature to an integer and computing its modulus with the miner count. [1](#0-0) 

**Signature Calculation:** The signature is computed by XORing the PreviousInValue with all signatures from the previous round. [2](#0-1) 

**Insufficient Validation:** The only on-chain validation checks that the hash of the revealed InValue matches the previously committed OutValue. [3](#0-2) 

**Intended but Unenforced Generation:** InValue should be generated by signing round information, making it deterministic and tied to the miner's private key. However, this generation method is implemented only client-side and not validated on-chain. [4](#0-3) 

**Attack Execution:**
When producing a block in round N-1, a malicious miner can:
1. Generate thousands of random hash values as candidate InValues offline
2. For each candidate, compute the resulting signature by XORing it with known signatures from round N-2  
3. Calculate the mining position in round N+1 using the modulus operation
4. Select the InValue producing the most favorable position (e.g., position 1 for earliest mining opportunity)
5. Commit by publishing OutValue = Hash(chosen_InValue)
6. Later reveal the chosen InValue, which passes validation since Hash(InValue) == OutValue

The signature calculation occurs during consensus extra data generation. [5](#0-4) 

## Impact Explanation

**Consensus Integrity Violation:**
This vulnerability breaks the fundamental security assumption that mining order is unpredictable and determined by cryptographically secure randomness. The AEDPoS consensus mechanism relies on fair, random miner scheduling to ensure decentralization and prevent manipulation.

**Concrete Harms:**
- **Unfair Economic Advantage:** Manipulating miners can consistently secure position 1, gaining first access to transaction fees and MEV opportunities in each round
- **Centralization Pressure:** Miners exploiting this gain cumulative advantages, forcing honest miners to either adopt the manipulation or become economically uncompetitive
- **Consensus Weakening:** Attackers optimizing for consecutive mining positions across round boundaries can attempt sophisticated attacks like selfish mining or chain reorganizations
- **Reward Manipulation:** Mining order affects reward distribution and extra block production rights, allowing attackers to maximize their share

**Affected Parties:**
- Honest miners suffer reduced mining opportunities and rewards
- Network security and decentralization are compromised  
- Users face reduced transaction finality guarantees

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the consensus set (achievable through normal election process)
- Requires only commodity hardware (modern CPU can hash millions of values per second)
- No special privileges beyond normal mining operations

**Attack Complexity:**
- **Simple Execution:** Generate random hashes, compute XOR operations, calculate modulus, select optimal value
- **Undetectable:** All brute-forcing occurs offline; on-chain behavior is indistinguishable from legitimate mining
- **Repeatable:** Can be executed every round indefinitely without detection
- **Scalable:** Miners producing blocks later in rounds (especially extra block producers) have more information to optimize with, but even early miners can bias outcomes

**No Barriers to Exploitation:**
- Zero additional capital cost beyond normal mining stake
- No risk of detection or penalty  
- Direct economic benefit with no downside
- Success appears as statistical "luck" in order assignment

**Probability: Very High**
Once this vulnerability is discovered, rational economic actors will adopt it as it provides guaranteed advantages with zero risk. The complete absence of validation makes exploitation trivial for any miner.

## Recommendation

Implement cryptographic verification of InValue generation to ensure it was properly derived from signing round information:

1. **Add Signature Verification:** During UpdateValue validation, verify that the InValue was generated by signing the expected message (round information hash) with the miner's private key. This requires miners to submit both the InValue and a proof that it was generated correctly.

2. **Alternative: Commit-Reveal with Signature:** Require miners to commit to both Hash(InValue) AND a signature over the round information. Verify during reveal that InValue is the correct signature output.

3. **Validation Enhancement:** Extend `UpdateValueValidationProvider` to verify cryptographic correctness:
```
// Verify InValue = Hash(Sign(Hash(RoundInfo)))
var roundHash = HashHelper.ComputeFrom(previousRound.ToByteArray());
var expectedInValue = VerifyAndRecoverInValue(previousInValue, roundHash, minerPublicKey);
if (!expectedInValue) 
    return new ValidationResult { Message = "InValue not properly generated" };
```

4. **Backward Compatibility:** Implement validation enhancement through a governance-approved protocol upgrade to avoid disrupting existing miners.

## Proof of Concept

A complete proof of concept would require implementing a modified miner client that:

```csharp
// Simplified PoC concept (not executable without full node context)
public Hash BruteForceOptimalInValue(Round previousRound, int desiredOrder, int minersCount)
{
    Hash bestInValue = null;
    int bestOrder = int.MaxValue;
    
    // Try multiple random candidates
    for (int i = 0; i < 1000000; i++)
    {
        var candidateInValue = GenerateRandomHash();
        
        // Calculate what signature this would produce
        var signature = previousRound.CalculateSignature(candidateInValue);
        
        // Calculate resulting order
        var sigNum = signature.ToInt64();
        var supposedOrder = Math.Abs(sigNum % minersCount) + 1;
        
        // Track if this is better than what we've found
        if (supposedOrder == desiredOrder)
        {
            return candidateInValue; // Found perfect match
        }
        if (Math.Abs(supposedOrder - desiredOrder) < Math.Abs(bestOrder - desiredOrder))
        {
            bestInValue = candidateInValue;
            bestOrder = supposedOrder;
        }
    }
    
    return bestInValue;
}
```

The attacker would use this offline, then commit Hash(bestInValue) as their OutValue, later revealing bestInValue to achieve favorable positioning. The on-chain validation in [6](#0-5)  only checks the hash preimage relationship, not the generation method, allowing the attack to succeed.

## Notes

- This vulnerability fundamentally undermines the consensus mechanism's fairness guarantees
- The attack is most effective for miners producing blocks late in rounds when more signature information is available
- Detection is practically impossible as manipulated InValues are cryptographically indistinguishable from legitimate ones on-chain
- The intended generation method exists in client code but lacks on-chain enforcement, creating a trust assumption that is violated

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```
