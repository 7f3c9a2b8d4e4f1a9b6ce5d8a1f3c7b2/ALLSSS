### Title
Cross-Snapshot Withdrawal Enables Retroactive Modification of Historical Voting Results

### Summary
The `Withdraw()` function allows voters to withdraw votes from previous snapshots after new snapshots have been finalized, directly modifying historical `VotingResult` data that should be immutable. This breaks the fundamental integrity of snapshot-based voting where past results must remain unchanged once a snapshot is taken.

### Finding Description

The vulnerability exists in the `Withdraw()` function's handling of voting records from finalized snapshots. [1](#0-0) 

When a voter calls `Withdraw()`, the function retrieves their voting record which contains the `SnapshotNumber` from when they originally voted: [2](#0-1) 

The `Withdraw()` function then calculates the voting result hash based on this historical snapshot number: [3](#0-2) 

It then **directly modifies** the historical snapshot's `VotingResult` by subtracting the withdrawn amount: [4](#0-3) 

The root cause is that `Withdraw()` contains **no validation** to check if the snapshot has been finalized. When `TakeSnapshot()` is called, it sets a `SnapshotEndTimestamp` to mark the snapshot as complete: [5](#0-4) 

However, this end timestamp is never checked in `Withdraw()`. The `TakeSnapshot()` function copies the current voter counts and vote amounts to initialize the next snapshot: [6](#0-5) 

This creates an inconsistency: the new snapshot retains the original counts from when it was created, while the old snapshot's data gets modified retroactively by withdrawals.

**Exploitation Path:**
1. Snapshot N: Alice votes 1000 tokens for Option A, results show `{A: 1500, B: 500}`
2. Sponsor calls `TakeSnapshot(N)` - Snapshot N is finalized with `SnapshotEndTimestamp`
3. Snapshot N+1 is created with copied counts: `{VotersCount: 3, VotesAmount: 2000}`
4. Alice calls `Withdraw()` on her vote from Snapshot N
5. Snapshot N's results are modified to `{A: 500, B: 500, VotesAmount: 1000}`
6. Historical data integrity is violated - Snapshot N no longer reflects its state at finalization time

### Impact Explanation

**Governance Integrity Impact:**
- Historical voting results that informed governance decisions can be retroactively altered
- Proposals approved/rejected based on snapshot results become inconsistent with current data
- Audit trails are corrupted as past snapshots no longer reflect their actual historical state
- Election outcomes and candidate rankings recorded in snapshots can be manipulated after the fact

**Data Consistency Impact:**
- Snapshot N shows modified results while Snapshot N+1 retains the original counts copied at creation time
- The `TakeSnapshot()` mechanism's purpose of preserving point-in-time state is completely undermined
- Multi-phase voting systems relying on snapshot immutability produce unreliable results

**Affected Parties:**
- Governance participants whose decisions were based on snapshot data
- Election candidates whose rankings can change retroactively
- Protocol auditors who cannot trust historical voting records
- Smart contracts that query historical snapshots expecting immutable data

**Severity Justification:**
HIGH - This violates a critical invariant (snapshot immutability) that is fundamental to voting system integrity. While it doesn't directly steal funds, it compromises governance decision-making and can invalidate past governance actions.

### Likelihood Explanation

**Attacker Capabilities:**
- Any voter who participated in a previous snapshot can exploit this
- No special privileges required beyond being a legitimate voter
- Attack works on both `IsLockToken` voting items and delegated voting

**Attack Complexity:**
- Trivial: Single transaction calling `Withdraw()` with a vote ID from an old snapshot
- No timing constraints or race conditions
- No need to coordinate with other attackers

**Feasibility Conditions:**
- Voting item must have `TotalSnapshotNumber > 1` to have multiple snapshots
- Attacker must have voted in a previous snapshot
- Lock time requirements (if any) must be satisfied

**Detection Constraints:**
- Withdrawal transactions appear legitimate and authorized
- No obvious on-chain indication that historical data is being modified
- Monitoring systems would need to track snapshot result changes over time

**Probability:**
HIGH - The vulnerability is easily exploitable by any voter who participated in earlier snapshots. The code shows active usage of multi-snapshot voting (as evidenced by test cases), making this a realistic attack vector in production. [7](#0-6) 

### Recommendation

**Code-Level Mitigation:**

Add a check in the `Withdraw()` function to prevent withdrawal from finalized snapshots:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    
    // NEW CHECK: Prevent withdrawal from finalized snapshots
    if (votingRecord.SnapshotNumber < votingItem.CurrentSnapshotNumber)
    {
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        Assert(votingResult.SnapshotEndTimestamp == null || votingResult.SnapshotEndTimestamp.Seconds == 0,
               "Cannot withdraw from a finalized snapshot. Withdrawals only allowed from current snapshot.");
    }
    
    // ... rest of existing withdrawal logic
}
```

**Invariant Checks:**
- Enforce that `VotingResult` data for snapshots with `SnapshotEndTimestamp != null` is immutable
- Add validation that only votes from the current snapshot (matching `CurrentSnapshotNumber`) can be withdrawn

**Test Cases:**
1. Test that withdrawal from current snapshot succeeds
2. Test that withdrawal from previous snapshot (after `TakeSnapshot` called) fails with appropriate error
3. Test that historical snapshot results remain unchanged after `TakeSnapshot` is called
4. Test that multiple snapshots maintain independent, immutable result sets

### Proof of Concept

**Initial State:**
- Register a voting item with `TotalSnapshotNumber = 3`
- Three voters participate in Snapshot 1:
  - Alice: 1000 tokens → Option A
  - Bob: 500 tokens → Option B  
  - Charlie: 500 tokens → Option A
- Snapshot 1 results: `{A: 1500, B: 500, VotersCount: 3, VotesAmount: 2000}`

**Transaction Steps:**

1. **Finalize Snapshot 1:**
   ```
   TakeSnapshot(votingItemId, snapshotNumber: 1)
   ```
   - Snapshot 1: `SnapshotEndTimestamp = T1`, results: `{A: 1500, B: 500}`
   - Snapshot 2: Created with `{VotersCount: 3, VotesAmount: 2000}`

2. **Query Snapshot 1 results:**
   ```
   GetVotingResult(votingItemId, snapshotNumber: 1)
   → Results: {A: 1500, B: 500, VotersCount: 3, VotesAmount: 2000}
   ```

3. **Alice withdraws from Snapshot 1:**
   ```
   Withdraw(AliceVoteId)  // AliceVoteId has SnapshotNumber = 1
   → Transaction succeeds
   ```

4. **Query Snapshot 1 results again:**
   ```
   GetVotingResult(votingItemId, snapshotNumber: 1)
   → Results: {A: 500, B: 500, VotersCount: 2, VotesAmount: 1000}
   ```

**Expected vs Actual Result:**

**Expected:** Withdrawal from finalized Snapshot 1 should fail with error "Cannot withdraw from finalized snapshot"

**Actual:** Withdrawal succeeds and retroactively modifies Snapshot 1's historical results:
- Option A votes changed from 1500 → 500
- VotesAmount changed from 2000 → 1000
- VotersCount changed from 3 → 2

**Success Condition for Exploit:**
The historical Snapshot 1 results are modified after the snapshot was finalized, violating snapshot immutability.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L193-193)
```csharp
        var votingRecord = State.VotingRecords[input.VoteId];
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-207)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-222)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L40-61)
```csharp
            //take snapshot
            var snapshotResult = await TakeSnapshot(registerItem.VotingItemId, 1);
            snapshotResult.Status.ShouldBe(TransactionResultStatus.Mined);

            //query vote ids
            var voteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            //query result
            var voteRecord = await GetVotingRecord(voteIds.ActiveVotes.First());
            voteRecord.Option.ShouldBe(registerItem.Options[0]);
            voteRecord.Amount.ShouldBe(100);

            //withdraw
            var beforeBalance = GetUserBalance(user1.Address);
            await Withdraw(user1.KeyPair, voteIds.ActiveVotes.First());
            var afterBalance = GetUserBalance(user1.Address);

            beforeBalance.ShouldBe(afterBalance - 100);

            voteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            voteIds.ActiveVotes.Count.ShouldBe(0);
            voteIds.WithdrawnVotes.Count.ShouldBe(1);
        }
```
