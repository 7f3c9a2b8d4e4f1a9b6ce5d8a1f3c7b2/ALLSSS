### Title
Missing Signature and Mining Order Validation Allows Manipulation of Consensus Schedule

### Summary
The AEDPoS consensus contract does not validate that the `Signature` field is correctly calculated or that `SupposedOrderOfNextRound` properly derives from the signature value. A malicious miner can provide arbitrary signature and order values to manipulate their position in the next round's mining schedule, potentially gaining unfair block production advantages.

### Finding Description

The mining order for the next round is calculated from a signature value using the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [1](#0-0) 

The signature is supposed to be calculated as `previousRound.CalculateSignature(previousInValue)`, which XORs the InValue with all previous round signatures. [2](#0-1) 

However, when `ProcessUpdateValue` executes, it blindly accepts the signature value from `UpdateValueInput` without validating that it was calculated correctly: [3](#0-2) 

Similarly, it accepts `SupposedOrderOfNextRound` without verifying it matches the signature-based calculation: [4](#0-3) 

The `TuneOrderInformation` field, which allows modification of other miners' `FinalOrderOfNextRound`, is also accepted without validation: [5](#0-4) 

The `UpdateValueValidationProvider` only validates that the signature field is non-empty and that `PreviousInValue` hashes to the previous `OutValue`, but does NOT validate the signature's correctness: [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` only checks that the number of distinct orders equals the number of miners who mined, not that each order was calculated correctly: [7](#0-6) 

### Impact Explanation

A malicious miner can manipulate their mining position to:

1. **Always mine first**: By setting `Signature.ToInt64() % minersCount == 0`, they guarantee order 1 in every round, allowing them to produce the first block and potentially gain MEV advantages or manipulate transaction ordering.

2. **Avoid penalty slots**: By choosing favorable positions, they can avoid mining at times when network conditions are poor or when they want to skip blocks without detection.

3. **Manipulate other miners' orders**: Through `TuneOrderInformation`, they can push competing miners to later or less favorable positions, disrupting fair scheduling.

4. **Consensus integrity breach**: The entire mining schedule becomes vulnerable to manipulation, undermining the fairness and unpredictability that the signature-based randomization is designed to provide.

This violates the critical invariant of "miner schedule integrity" and represents a fundamental consensus security failure.

### Likelihood Explanation

**Reachable Entry Point**: Any miner in the current miner list can call `UpdateValue` during their time slot. [8](#0-7) 

**Feasible Preconditions**: The attacker only needs to be a valid miner, which is a normal operational role. No additional privileges are required.

**Execution Practicality**: The attacker can modify their node's consensus data generation logic to:
1. Skip the legitimate signature calculation
2. Choose a signature value where `GetAbsModulus(signature.ToInt64(), minersCount) + 1` equals their desired position
3. Set `SupposedOrderOfNextRound` to match this desired position
4. Submit the transaction with these manipulated values

The contract will accept these values because no on-chain validation exists to verify correctness.

**Economic Rationality**: The attack cost is minimal (just the transaction fee), while the benefits include favorable mining positions, potential MEV extraction, and ability to manipulate the consensus schedule.

**Detection**: The attack is difficult to detect because the manipulated values are stored in the contract state as if they were legitimate. Only by re-computing the expected signature and comparing with the stored value could the manipulation be discovered.

### Recommendation

Add validation in `ProcessUpdateValue` to verify signature and order calculations:

```csharp
// After line 244, add signature validation:
if (TryToGetPreviousRoundInformation(out var previousRound))
{
    Hash expectedSignature;
    if (updateValueInput.PreviousInValue != Hash.Empty)
    {
        expectedSignature = previousRound.CalculateSignature(updateValueInput.PreviousInValue);
    }
    else
    {
        // Handle the case where PreviousInValue is empty
        var fakePreviousInValue = HashHelper.ComputeFrom(_processingBlockMinerPubkey.Append(Context.CurrentHeight.ToString()));
        expectedSignature = previousRound.CalculateSignature(fakePreviousInValue);
    }
    Assert(updateValueInput.Signature == expectedSignature, "Invalid signature provided.");
}

// After line 246, add order validation:
var minersCount = currentRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), minersCount) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, 
    "SupposedOrderOfNextRound does not match signature-based calculation.");

// For TuneOrderInformation (line 259), recalculate on-chain instead of accepting provided values:
// Remove the foreach loop and instead re-apply the conflict resolution logic from ApplyNormalConsensusData
```

Additionally, add a validation provider that verifies these calculations before execution.

### Proof of Concept

**Initial State**: 
- 5 miners (A, B, C, D, E) in the current round
- Attacker controls miner A
- Current round N has completed with all miners' signatures set

**Attack Steps**:

1. Attacker's node modifies consensus data generation to skip legitimate calculations
2. Attacker chooses `Signature` such that `Signature.ToInt64() % 5 == 0` (e.g., `Signature.ToInt64() = 0`)
3. Attacker constructs `UpdateValueInput` with:
   - `Signature` = chosen value
   - `SupposedOrderOfNextRound` = 1
   - `PreviousInValue` = legitimate value from previous round (to pass hash check)
   - `TuneOrderInformation` = empty or with manipulated values for other miners
4. Attacker submits `UpdateValue` transaction during their time slot
5. `ProcessUpdateValue` accepts all values without validation
6. State is updated with attacker's order set to 1 for next round
7. In round N+1, attacker mines first

**Expected Result**: Signature and order should be validated and transaction should fail.

**Actual Result**: Transaction succeeds, attacker gains position 1 in round N+1.

**Success Condition**: Attacker's `FinalOrderOfNextRound` in the state equals 1, while legitimate calculation would yield a different value.

### Notes

The vulnerability stems from the design decision to perform signature and order calculations off-chain (in `GetConsensusBlockExtraData`) with insufficient on-chain validation. While the `CalculateSignature` method [9](#0-8)  and `GetAbsModulus` helper [10](#0-9)  exist for computing these values, they are never invoked during validation to verify the submitted values are correct.

The `ValidateConsensusAfterExecution` method compares round hashes but only after `RecoverFromUpdateValue` copies the submitted values into the comparison baseline, making the check ineffective for detecting manipulated signatures or orders. [11](#0-10)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L45-47)
```csharp
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L245-248)
```csharp
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
