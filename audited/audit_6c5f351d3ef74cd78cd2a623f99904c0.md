# Audit Report

## Title
Missing Order Value Validation in NextTerm Allows Consensus DoS via Malformed Round Data

## Summary
The AEDPoS consensus contract lacks Order value validation for NextTerm behavior, creating a validation gap that allows a malicious block producer to inject Round data with zero or invalid Order values. This causes critical consensus methods to throw exceptions, immediately halting block production chain-wide.

## Finding Description

The vulnerability arises from an asymmetry in validation logic between NextRound and NextTerm consensus behaviors.

**Root Cause - Missing Validation:**

When NextTerm behavior is validated, only `RoundTerminateValidationProvider` is added to the validation chain, which exclusively checks round number and term number increments. [1](#0-0) 

The `RoundTerminateValidationProvider` implementation confirms it only validates round and term number progression, with no Order value checks. [2](#0-1) 

In contrast, NextRound behavior includes `NextRoundMiningOrderValidationProvider` which validates that `FinalOrderOfNextRound > 0`. [3](#0-2) [4](#0-3) 

**Data Flow Without Validation:**

The `NextTermInput.Create()` method directly copies RealTimeMinersInformation without any Order value validation. [5](#0-4) 

When consensus transactions are generated, the Round data from consensus extra data is used to create NextTermInput via the Create method. [6](#0-5) 

The NextTerm processing stores this Round data directly into state without additional validation. [7](#0-6) 

**Attack Vector:**

A malicious miner can modify their node software to bypass the normal `MinerList.GenerateFirstRoundOfNewTerm` method (which correctly assigns Order = i + 1) [8](#0-7)  and instead inject malformed consensus extra data with Order = 0 or negative values during NextTerm block production. This malformed data passes validation and gets stored in state.

**Immediate Failure Points:**

Multiple consensus-critical methods assume valid Order values and will throw exceptions:

1. **GetMiningInterval()** filters miners with `Order == 1 || Order == 2` and accesses array indices without bounds checking. With Order = 0, the filtered list is empty, causing `IndexOutOfRangeException` when accessing `firstTwoMiners[1]`. [9](#0-8) 

2. **BreakContinuousMining()** uses `.First(i => i.Order == 1)` which throws `InvalidOperationException` if no miner has Order 1. [10](#0-9) 

3. **TimeSlotValidationProvider** (used in every block validation) calls GetMiningInterval(), triggering the exception. [11](#0-10) 

4. **GenerateNextRoundInformation()** also calls GetMiningInterval() at the start of round generation. [12](#0-11) 

## Impact Explanation

**Severity: Critical - Complete Consensus Halt**

Once a malicious NextTerm block with Order = 0 is accepted:

1. The corrupted Round data is permanently stored in consensus state
2. The very next block's validation will call `TimeSlotValidationProvider.CheckMinerTimeSlot()`
3. This calls `GetMiningInterval()` on the corrupted Round
4. `GetMiningInterval()` throws `IndexOutOfRangeException`
5. Block validation fails for all subsequent blocks
6. **The entire blockchain stops producing blocks**

The impact affects all network participants immediately and requires manual intervention to recover (likely requiring a chain rollback or state migration). Normal operations including:
- Block production and validation
- Transaction processing
- Time slot calculation
- Miner scheduling
- Round transitions

All become impossible until the corrupted state is remediated.

This is a high-confidence availability attack (DoS) that breaks the fundamental consensus invariant that Order values must be sequential positive integers starting from 1.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Must be an active miner in the current term
- Must be scheduled to produce the NextTerm transition block
- Must modify node software to inject malformed consensus data

**Feasibility:**
The attack is technically straightforward - miners control the consensus extra data generation in their node software. The validation gap is exploitable with minimal code modification. Any miner will eventually be scheduled to produce a NextTerm block due to rotation.

**Realistic Scenarios:**
- Compromised miner node (malware/hacking)
- Malicious insider miner attempting ecosystem disruption
- Buggy node software update that inadvertently generates invalid Order values
- Competitor attempting to halt chain for market advantage

**Detection:**
The attack is immediately visible post-execution as exceptions appear in block validation logs, but by then the damage is done with corrupted state already persisted.

## Recommendation

Add Order value validation to NextTerm behavior by including an Order validation provider similar to NextRound's approach.

**Immediate Fix:**

Modify the NextTerm validation case to include Order validation:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider()); // ADD THIS
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

**Enhanced Protection:**

Alternatively, create a dedicated `NextTermOrderValidationProvider` that validates Order values are sequential positive integers (1, 2, 3, ..., N) for all miners in the new term's first round. This provides stronger guarantees than just checking `> 0`.

**Defense in Depth:**

Add Order value validation in `NextTermInput.Create()` or `ProcessNextTerm()` as a secondary check to catch any validation bypass attempts.

## Proof of Concept

A proof of concept would require:

1. Setting up a test AEDPoS consensus environment with multiple miner nodes
2. Modifying a miner node's `GetConsensusExtraDataForNextTerm` method to generate Round data with all Order values set to 0
3. Waiting for that miner to be scheduled for NextTerm block production
4. Observing the NextTerm block being accepted (passes validation due to missing Order checks)
5. Attempting to produce the next block, which fails with `IndexOutOfRangeException` in `GetMiningInterval()`
6. Confirming consensus is halted and no further blocks can be produced

The vulnerability is confirmed by code analysis showing the validation gap and exception paths. The exact PoC would require a full node test environment with consensus simulation.

**Notes:**

This vulnerability represents a critical asymmetry in the consensus validation logic where NextRound properly validates Order values but NextTerm does not. The normal code path through `MinerList.GenerateFirstRoundOfNewTerm` produces valid Order values, which explains why this hasn't been triggered in honest operation. However, the lack of validation creates an exploitable attack surface for malicious actors with miner privileges.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-22)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L31-31)
```csharp
            minerInRound.Order = i + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L44-45)
```csharp
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
```
