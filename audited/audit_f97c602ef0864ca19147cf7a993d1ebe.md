### Title
Governance Escape via Malicious Contract Address in Method Fee Controller Change

### Summary
The `ChangeMethodFeeController()` function accepts an arbitrary contract address in `AuthorityInfo.ContractAddress` without validating it is a legitimate governance contract (Parliament, Association, or Referendum). An attacker who temporarily controls the method fee controller can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist()`, bypassing the organization validation and permanently replacing the governance-controlled authority with an ungoverned address. This converts temporary governance compromise into permanent loss of oversight. [1](#0-0) 

### Finding Description

The `ChangeMethodFeeController()` function in `EconomicContract_ACS1_TransactionFeeProvider.cs` validates the new controller by calling `CheckOrganizationExist(input)`. [2](#0-1) 

The `CheckOrganizationExist()` helper performs a cross-contract call to `authorityInfo.ContractAddress` with the method `ValidateOrganizationExist`. Critically, there is **no validation** that `authorityInfo.ContractAddress` is one of the three legitimate governance contracts (Parliament, Association, or Referendum). The contract address comes directly from user input in the `AuthorityInfo` parameter.

Legitimate governance contracts implement `ValidateOrganizationExist` to check if an organization actually exists in their state: [3](#0-2) [4](#0-3) 

However, an attacker can deploy a malicious contract that always returns `true`:

```csharp
public override BoolValue ValidateOrganizationExist(Address input) {
    return new BoolValue { Value = true };
}
```

**Exploitation Path:**
1. Current controller (e.g., Parliament default org) is temporarily compromised via malicious proposal
2. Attacker deploys malicious validation contract
3. Attacker calls `ChangeMethodFeeController` with:
   - `ContractAddress` = malicious contract address  
   - `OwnerAddress` = attacker-controlled EOA or fake organization
4. `CheckOrganizationExist` calls the malicious contract, which returns `true`
5. Validation passes, controller is permanently changed to ungoverned address

This pattern exists across ALL system contracts implementing ACS1: [5](#0-4) [6](#0-5) [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
- Permanent loss of governance oversight over method fees for the Economic contract and ALL system contracts
- Attacker gains ability to call `SetMethodFee()` directly without proposals, approvals, or time delays
- Method fees can be set to 0, making any attack on the contract cost-free
- Method fees can be set to extreme values, causing DoS by making legitimate operations prohibitively expensive
- No recovery path exists without creating a proposal through the compromised controller (impossible if set to EOA) [8](#0-7) 

**Severity Justification:**
This violates the critical invariant that "method-fee provider authority" must be through legitimate governance. It enables **governance escape** - converting temporary compromise into permanent control. The impact spans the entire protocol as this vulnerability exists in 13+ system contracts.

### Likelihood Explanation

**Attacker Capabilities:**
- Must temporarily control the current method fee controller (typically Parliament default organization)
- Requires one malicious proposal to be approved and released
- Must deploy a malicious contract (straightforward technical operation)

**Feasibility:**
While governance compromise requires significant coordination (e.g., bribing/compromising miners to approve a proposal), such attacks are not theoretical - they have occurred in other blockchain governance systems. The key concern is that even a TEMPORARY compromise becomes PERMANENT through this vulnerability.

**Detection/Constraints:**
- Malicious proposal must pass approval thresholds and time delays
- Community monitoring may detect the malicious controller change
- However, once executed, damage cannot be reverted without the compromised controller's cooperation

**Probability Assessment:**
The precondition (governance compromise) has medium-low probability, but the consequence (permanent loss of oversight) has critical severity. The vulnerability represents a **privilege escalation** from temporary to permanent control, violating defense-in-depth principles.

### Recommendation

**Immediate Fix:**
Add validation that `authorityInfo.ContractAddress` is one of the known governance contract addresses:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var validGovernanceContracts = new[] {
        systemContracts[HashHelper.ComputeFrom(SmartContractConstants.ParliamentContractSystemName)],
        systemContracts[HashHelper.ComputeFrom(SmartContractConstants.AssociationContractSystemName)],
        systemContracts[HashHelper.ComputeFrom(SmartContractConstants.ReferendumContractSystemName)]
    };
    
    Assert(validGovernanceContracts.Contains(authorityInfo.ContractAddress), 
        "Contract address must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply Consistently:**
This fix must be applied to ALL contracts implementing ACS1 (Parliament, Association, Referendum, MultiToken, Economic, Treasury, Profit, TokenHolder, Election, Vote, Configuration, Genesis, Consensus, CrossChain, TokenConverter).

**Test Cases:**
1. Attempt to change controller with non-governance contract address (should fail)
2. Attempt to change controller with EOA address (should fail)  
3. Verify only Parliament/Association/Referendum contract addresses are accepted
4. Test controller change from Parliament to Association (should succeed)

### Proof of Concept

**Initial State:**
- Economic contract deployed with method fee controller = Parliament default organization
- Attacker has ability to create and pass one proposal through Parliament (via temporary compromise)

**Attack Steps:**

1. **Deploy Malicious Contract:**
```csharp
contract MaliciousValidator {
    public override BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true };
    }
}
```
Deployed at address: `0xMALICIOUS_CONTRACT`

2. **Create Malicious Proposal:**
Create proposal to Parliament default org to call `Economic.ChangeMethodFeeController` with:
```
AuthorityInfo {
    ContractAddress: 0xMALICIOUS_CONTRACT
    OwnerAddress: 0xATTACKER_EOA
}
```

3. **Approve and Release:**
Proposal gets approved by compromised miners and released

4. **Verification:**
    - `Economic.GetMethodFeeController()` returns `OwnerAddress = 0xATTACKER_EOA, ContractAddress = 0xMALICIOUS_CONTRACT`
    - Attacker can now call `Economic.SetMethodFee()` directly without proposals
    - Parliament regains honest control but cannot revert the change (requires proposal through 0xATTACKER_EOA)

**Expected vs Actual:**
- **Expected:** Controller change should fail with "Invalid authority input" because contract is not a legitimate governance contract
- **Actual:** Controller change succeeds, permanently removing governance oversight

**Success Condition:**
Method fee controller permanently changed to ungoverned address, allowing arbitrary fee manipulation without proposals.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```
