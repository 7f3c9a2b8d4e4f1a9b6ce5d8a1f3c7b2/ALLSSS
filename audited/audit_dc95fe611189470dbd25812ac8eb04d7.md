### Title
Cross-Chain Token Creation Bypasses Symbol Namespace Collision Protection

### Summary
The `CrossChainCreateToken` method allows an attacker to create both a token (e.g., "ABC") and its corresponding NFT collection (e.g., "ABC-0") on the same chain by creating them on different chains first and then syncing them. This bypasses the `CheckTokenAndCollectionExists` protection that prevents this collision in normal token creation, violating the design intent and SEED NFT system's exclusive symbol rights.

### Finding Description

The `GetSymbolType` function correctly distinguishes between tokens and NFT collections based on symbol format. [1](#0-0) 

Local token creation via the `Create` method is properly protected. When creating either a token or NFT collection, `AssertValidCreateInput` calls `CheckTokenAndCollectionExists` which validates that both the token symbol and its corresponding collection symbol don't already exist. [2](#0-1) 

This protection is confirmed by test cases showing that creating "XYZ" blocks creation of "XYZ-0", and vice versa. [3](#0-2) 

**Root Cause:** The `CrossChainCreateToken` method only calls `AssertNftCollectionExist` (which returns null for tokens and collections) and checks if the exact symbol exists via `State.TokenInfos[tokenInfo.Symbol] == null`. It does NOT call `CheckTokenAndCollectionExists` to verify the related symbol doesn't exist. [4](#0-3) 

The `AssertNftCollectionExist` method only validates NFT items (not tokens or collections), returning null without performing validation. [5](#0-4) 

### Impact Explanation

**Namespace Collision:** An attacker can cause both "ABC" and "ABC-0" to coexist on the same chain, violating the explicit design intent evidenced by `CheckTokenAndCollectionExists`.

**SEED NFT System Bypass:** The SEED NFT system grants exclusive rights to create specific symbols. [6](#0-5)  If a user owns SEED for "ABC" and creates token "ABC" on Chain A, an attacker can create collection "ABC-0" on Chain B and sync it to Chain A, polluting the namespace that should be exclusively controlled by the SEED owner.

**User Confusion:** The presence of both "ABC" and "ABC-0" creates ambiguity about their relationship, potentially misleading users into believing they're related when they're controlled by different entities.

**Severity:** Critical - violates a fundamental invariant (NFT uniqueness and ownership checks) and bypasses an access control mechanism (SEED NFT system).

### Likelihood Explanation

**Reachable Entry Point:** `CrossChainCreateToken` is a public method accessible after cross-chain token contract registration. [7](#0-6) 

**Feasible Preconditions:**
1. Attacker can create tokens on two different chains (feasible in multi-chain ecosystem)
2. Cross-chain verification must pass (attacker uses legitimate cross-chain proof for tokens they created)
3. No special privileges required beyond normal token creation rights

**Execution Steps:**
1. Chain A: Create token "ABC" via `Create()` (passes local validation)
2. Chain B: Create collection "ABC-0" via `Create()` (passes local validation on Chain B)
3. Chain A: Call `CrossChainCreateToken` to sync "ABC-0" from Chain B (bypasses `CheckTokenAndCollectionExists`)
4. Result: Both "ABC" and "ABC-0" exist on Chain A

**Economic Rationality:** Attack requires only gas fees for token creation and cross-chain transactions. The benefit includes namespace squatting and undermining SEED NFT value.

### Recommendation

Add `CheckTokenAndCollectionExists` validation to `CrossChainCreateToken` before registering the token:

```
At line 506 in TokenContract_Actions.cs, before the if statement, add:
CheckTokenAndCollectionExists(tokenInfo.Symbol);
```

This ensures cross-chain token creation follows the same namespace collision rules as local creation.

**Additional Test Case:** Add a test that verifies `CrossChainCreateToken` correctly rejects syncing "ABC-0" when "ABC" exists, and vice versa.

### Proof of Concept

**Initial State:**
- Chain A and Chain B both have MultiToken contracts deployed
- Cross-chain token contract addresses registered between chains
- User has SEED NFT for "ABC" on Chain A

**Attack Steps:**

1. **On Chain A:** User creates token "ABC" using their SEED NFT
   - Call: `Create({Symbol: "ABC", ...})`
   - Result: Token "ABC" exists on Chain A

2. **On Chain B:** Attacker creates NFT collection "ABC-0" using their own SEED
   - Call: `Create({Symbol: "ABC-0", ...})`
   - Result: Collection "ABC-0" exists on Chain B
   - Note: Chain B's local `CheckTokenAndCollectionExists` only checks Chain B state where "ABC" doesn't exist

3. **On Chain A:** Attacker syncs "ABC-0" from Chain B
   - Call: `CrossChainCreateToken({Symbol: "ABC-0", FromChainId: ChainB, ...})`
   - Line 491: `AssertNftCollectionExist("ABC-0")` returns null (no check)
   - Line 506: `State.TokenInfos["ABC-0"]` is null (doesn't exist yet on Chain A)
   - Line 508: `RegisterTokenInfo` creates "ABC-0" on Chain A
   - **Result: COLLISION - Both "ABC" and "ABC-0" now exist on Chain A**

**Expected vs Actual:**
- Expected: `CrossChainCreateToken` should reject "ABC-0" because "ABC" exists
- Actual: "ABC-0" is created successfully, causing namespace collision

**Success Condition:** Query `State.TokenInfos["ABC"]` and `State.TokenInfos["ABC-0"]` on Chain A - both return valid TokenInfo objects, confirming the collision.

### Notes

The vulnerability specifically affects cross-chain token synchronization and does not impact the correctness of `GetSymbolType()` itself, which properly distinguishes symbol types. The local `Create()` method's protection via `CheckTokenAndCollectionExists` works as intended - the issue is exclusively in the cross-chain creation path that bypasses this critical validation.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-293)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }

    private void CheckTokenAndCollectionExists(string symbol)
    {
        var symbols = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var tokenSymbol = symbols.First();
        CheckTokenExists(tokenSymbol);
        var collectionSymbol = symbols.First() + TokenContractConstants.NFTSymbolSeparator +
                               TokenContractConstants.CollectionSymbolSuffix;
        CheckTokenExists(collectionSymbol);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L745-781)
```csharp
        exceptionRes.TransactionResult.Error.ShouldContain("Token already exists");
        // check collection symbol prefix duplicated
        var failCollection = await CreateSeedNftWithExceptionAsync(TokenContractStub, new CreateInput
        {
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            IssueChainId = _chainId,
            Symbol = "XYZ-0"
        });
        failCollection.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        failCollection.TransactionResult.Error.ShouldContain("Token already exists.");

        var successCollection = await CreateMutiTokenAsync(TokenContractStub, new CreateInput
        {
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            Owner = DefaultAddress,
            IssueChainId = _chainId,
            Symbol = "GHJ-0"
        });
        successCollection.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        // check ft symbol prefix duplicated
        var fTokenAsync = await CreateSeedNftWithExceptionAsync(TokenContractStub, new CreateInput
        {
            TokenName = "Trump Digital Trading Cards #1155",
            TotalSupply = TotalSupply,
            Decimals = 0,
            Issuer = DefaultAddress,
            IssueChainId = _chainId,
            Symbol = "GHJ"
        });
        fTokenAsync.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        fTokenAsync.TransactionResult.Error.ShouldContain("Token already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L163-170)
```csharp
    private TokenInfo AssertNftCollectionExist(string symbol)
    {
        var collectionSymbol = GetNftCollectionSymbol(symbol);
        if (collectionSymbol == null) return null;
        var collectionInfo = GetTokenInfo(collectionSymbol);
        Assert(collectionInfo != null, "NFT collection not exist");
        return collectionInfo;
    }
```
