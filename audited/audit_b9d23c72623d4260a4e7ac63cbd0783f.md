# Audit Report

## Title
Unvalidated Secret Sharing Reveals Allow Consensus State Corruption and Mining Order Manipulation

## Summary
The `UpdateLatestSecretPieces()` function in the AEDPoS consensus contract accepts revealed InValues from trigger information without cryptographic verification, allowing malicious miners to inject arbitrary `PreviousInValue` data for other miners. This corrupts consensus state, manipulates mining order calculations, and pollutes the signature aggregation mechanism used across rounds.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where revealed InValues for other miners are accepted without validation. The `UpdateLatestSecretPieces()` function only checks if a miner's `PreviousInValue` is currently empty or null, but performs no cryptographic verification that the revealed value is legitimate: [1](#0-0) 

The revealed values originate from the miner's local node via `SecretSharingService.GetRevealedInValues()`: [2](#0-1) 

These values are included in trigger information provided by `AEDPoSTriggerInformationProvider`: [3](#0-2) 

A malicious miner can modify their local `SecretSharingService` implementation to return arbitrary fake values. These flow through the block production pipeline and are persisted to on-chain state via `PerformSecretSharing()`: [4](#0-3) 

In contrast, the legitimate `RevealSharedInValues()` function performs proper cryptographic reconstruction using Shamir's Secret Sharing with threshold validation: [5](#0-4) 

The off-chain `SecretSharingService.RevealPreviousInValues()` also validates minimum piece counts before revealing: [6](#0-5) 

However, the `UpdateValueValidationProvider` only validates the sender's own `PreviousInValue`, not the revealed values for other miners: [7](#0-6) 

When a victim miner fails to produce a block and the round transitions via `NextRound`, the `SupplyCurrentRoundInformation()` function uses the corrupted `PreviousInValue` to calculate their signature: [8](#0-7) 

This fake signature then determines the victim's mining order in the next round through the `SupposedOrderOfNextRound` calculation: [9](#0-8) 

The mining order is used during round generation to determine when each miner can produce blocks: [10](#0-9) 

Furthermore, the signature calculation aggregates all miners' signatures via XOR operations, meaning fake signatures pollute future calculations: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Violation**: The attack directly corrupts on-chain consensus state by setting incorrect `PreviousInValue`, `InValue`, and `Signature` fields for victim miners. This violates the fundamental consensus invariant that each miner's signature must be cryptographically derived from their genuine InValue through the VRF mechanism.

**Mining Order Manipulation**: The corrupted signature determines the victim's `SupposedOrderOfNextRound`, which directly controls when they can produce blocks in subsequent rounds. An attacker can systematically target specific miners to alter the mining schedule, potentially gaining unfair advantages or causing targeted miners to miss their time slots.

**Signature Chain Pollution**: Since signatures are aggregated via XOR operations when calculating new signatures, injecting fake signatures pollutes this cryptographic chain. All miners calculating their signatures in subsequent rounds will XOR with the fake signature, propagating the corruption forward.

**State Pollution Persistence**: Once a fake `PreviousInValue` is set through this mechanism, the victim cannot correct it until they successfully produce a block with their real value. During round transitions, the fake data generates incorrect derived values that persist and propagate through multiple rounds.

**Wide Attack Surface**: Any miner who misses their time slot becomes vulnerable. In distributed networks with unreliable connectivity or during high load conditions, missed slots occur naturally and frequently, making this vulnerability broadly exploitable.

## Likelihood Explanation

**Attacker Profile**: Any authorized miner in the consensus pool can execute this attack. The only requirement is the ability to modify their local node software to return fake values in `GetRevealedInValues()`.

**Attack Complexity**: Low. The attacker simply modifies their `SecretSharingService` implementation to return arbitrary values in the `_revealedInValues` dictionary. No complex cryptographic operations, precise timing requirements, or coordination with other parties is needed.

**Preconditions Met Naturally**:
1. Attacker is an active miner in the current round (inherent to consensus participation)
2. Target victim miner misses their time slot (common in distributed networks due to connectivity issues, load, or transient failures)
3. Attacker produces a block before victim in the same round (feasible given mining order rotation)

**Detection Difficulty**: The attack is difficult to detect because no on-chain validation flags fake revealed values, the corrupted state appears as legitimate consensus data in the contract state, and victims only discover issues when attempting to mine and finding their consensus information is incorrect.

**Economic Feasibility**: The attack cost is minimal—only the gas cost of producing a normal block. The potential gains include unfair mining advantages, ability to manipulate specific miners' schedules, and disruption of consensus randomness generation.

**Operational Constraints**: None. The attack can be executed repeatedly in every round where preconditions are met. Given that missed time slots occur regularly in distributed networks, attack opportunities are frequent.

## Recommendation

Implement cryptographic verification of revealed InValues in `UpdateLatestSecretPieces()` by reconstructing the value from encrypted pieces using Shamir's Secret Sharing, similar to how `RevealSharedInValues()` operates. The function should:

1. Verify that sufficient encrypted pieces exist (≥ 2/3 threshold) before accepting revealed values
2. Verify that sufficient decrypted pieces exist (≥ miner count) before accepting revealed values  
3. Use `SecretSharingHelper.DecodeSecret()` to cryptographically reconstruct the InValue from decrypted pieces
4. Only accept revealed values that match the reconstruction
5. Add validation in `PerformSecretSharing()` to apply the same checks

Additionally, extend `UpdateValueValidationProvider` to validate revealed InValues for all miners, not just the sender's own `PreviousInValue`.

## Proof of Concept

A proof of concept would involve:

1. Setting up a test AEDPoS network with multiple miners
2. Implementing a malicious `SecretSharingService` that returns fake `RevealedInValues`
3. Having the malicious miner produce a block while a victim miner has missed their slot
4. Observing that the victim's `PreviousInValue` is set to the fake value in on-chain state
5. Verifying during round transition that `SupplyCurrentRoundInformation()` uses the fake value to calculate an incorrect signature
6. Confirming the victim's mining order in the next round is manipulated based on the fake signature
7. Demonstrating that the fake signature persists and affects future signature calculations

The test would validate that no cryptographic verification occurs in `UpdateLatestSecretPieces()` or `PerformSecretSharing()`, allowing arbitrary values to corrupt consensus state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L84-93)
```csharp
    public Dictionary<string, Hash> GetRevealedInValues(long roundId)
    {
        _revealedInValues.TryGetValue(roundId, out var revealedInValues);
        Logger.LogDebug($"[GetRevealedInValues]Round id: {roundId}");
        if (revealedInValues != null)
            Logger.LogDebug($"Revealed {revealedInValues.Count} in values for round of id {roundId}");

        _revealedInValues.Remove(roundId);
        return revealedInValues ?? new Dictionary<string, Hash>();
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L161-176)
```csharp
            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-53)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-200)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-36)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
