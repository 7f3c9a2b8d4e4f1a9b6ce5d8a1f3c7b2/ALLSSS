### Title
Incorrect Backup Miner Limit Causes Consensus to Operate with Fewer Miners Than Configured

### Summary
The `GetVictories` function uses `Math.Min(diff, currentMiners.Count)` to limit backup miner selection, but this incorrectly caps the number of backups based on the current miner count rather than the available backup pool size. When there are insufficient valid candidates and `diff > currentMiners.Count`, the system returns fewer miners than `State.MinersCount.Value` requires, even when sufficient `InitialMiners` are available as backups, causing the consensus to operate with reduced validator count.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** 
The backup selection logic at line 72 uses `Math.Min(diff, currentMiners.Count)` as the upper bound for selecting backup miners. However, this is incorrect because:

1. `diff = State.MinersCount.Value - validCandidates.Count` represents how many additional miners are needed [2](#0-1) 

2. The `backups` list is constructed from both `currentMiners` (filtered) and `InitialMiners` (filtered), potentially containing many more entries than `currentMiners.Count` [3](#0-2) 

3. Using `currentMiners.Count` as a limit is semantically incorrect - it caps selection based on the size of the current miner set rather than the actual number of available backups or the number needed

**Why Protections Fail:**
- The consensus contract's `GenerateFirstRoundOfNewTerm` method accepts any number of miners in the `MinerList` without validating against an expected count [4](#0-3) 

- The `SetMinerList` method in the consensus contract stores the provided miner list without count validation [5](#0-4) 

- The consensus contract calls `GetVictories` during term transitions and uses whatever miner count is returned [6](#0-5) 

### Impact Explanation

**Concrete Harm:**
When `MinersCount` is increased through governance (e.g., from 5 to 7 miners), but only 2 candidates have votes and only 3 current miners remain, the system will:
- Calculate `diff = 7 - 2 = 5` (need 5 more miners)
- Have sufficient backups available (e.g., 3 current + 5 initial = 8 potential backups after filtering)
- But only select `Math.Min(5, 3) = 3` backups due to the bug
- Return only 5 total miners instead of the required 7

**Protocol Impact:**
1. **Consensus Security Degradation**: The network operates with fewer validators than configured, reducing Byzantine fault tolerance and decentralization
2. **Violation of Governance Decisions**: When governance increases `MinersCount`, the system silently fails to honor this configuration
3. **Network Instability Risk**: With fewer miners, the network is more vulnerable to validator outages and potential consensus failures
4. **Longer Block Times**: Fewer miners means longer time slots per miner, reducing transaction throughput

**Affected Parties:**
- All network participants suffer reduced security and performance
- The governance mechanism's authority is undermined
- The network's decentralization guarantees are violated

**Severity Justification:**
Medium severity - This is a consensus integrity issue that violates the configured miner count and reduces network security, but doesn't directly lead to fund theft or complete consensus failure.

### Likelihood Explanation

**Triggering Conditions:**
1. Network has grown and `MinersCount` has been increased through governance (natural progression)
2. Low valid candidate count: `validCandidates.Count < MinersCount` (can occur during low participation periods)
3. Current miner count is less than needed backups: `currentMiners.Count < diff` (some miners have left or been replaced)
4. Sufficient `InitialMiners` exist to fill the gap (always true since `InitialMiners` persist)

**Execution Path:**
- Entry point: Consensus contract calls `GetVictories` during term transitions via `GenerateFirstRoundOfNextTerm` [7](#0-6) 
- This occurs automatically during normal consensus operation, no attacker action required
- The bug manifests silently - the system continues operating with fewer miners

**Probability:**
Medium - As the network matures and `MinersCount` increases over time (via auto-increase or governance), while candidate participation fluctuates, these conditions become increasingly likely. The bug doesn't require any malicious behavior, just natural network dynamics.

### Recommendation

**Code Fix:**
Replace line 72 in `ViewMethods.cs`:
```csharp
// Current (incorrect):
.Take(Math.Min(diff, currentMiners.Count))

// Corrected:
.Take(diff)
```

The `diff` value already represents exactly how many more miners are needed. Since `backups` is constructed to contain only available backup miners, taking `diff` entries will select the correct number while naturally being bounded by `backups.Count`.

**Additional Validation:**
Add an assertion after line 76 to ensure the invariant holds:
```csharp
Assert(victories.Count == State.MinersCount.Value, 
    $"Failed to generate required miner count. Expected: {State.MinersCount.Value}, Got: {victories.Count}");
```

**Test Cases:**
Add test case covering:
1. `MinersCount = 7`, `validCandidates = 2`, `currentMiners = 3`, `InitialMiners = 5`
2. Verify `GetVictories()` returns exactly 7 miners
3. Verify all returned miners are unique (also catches potential duplicate issue)

### Proof of Concept

**Initial State:**
1. System configured with `MinersCount = 7` (increased via governance)
2. Only 2 candidates have votes: `validCandidates = ["A", "B"]`
3. Current miners: `currentMiners = ["A", "B", "C"]` (3 miners)
4. Initial miners: `InitialMiners = ["B", "C", "D", "E", "F"]` (5 miners)

**Execution Steps:**
1. Consensus contract calls `GetVictories()` during term transition
2. Line 60: Calculate `diff = 7 - 2 = 5` (need 5 more miners)
3. Line 66: Filter `currentMiners`: `backups = ["C"]` (1 miner not in validCandidates)
4. Lines 67-69: Add `InitialMiners`: `backups = ["C", "D", "E", "F"]` (4 additional, "B" filtered as duplicate)
5. Line 72: Select `Math.Min(5, 3) = 3` miners from backups
6. Return `victories = ["A", "B"] + 3 backups = 5 miners`

**Expected vs Actual:**
- **Expected:** 7 miners returned (as configured in `MinersCount`)
- **Actual:** 5 miners returned
- **Shortfall:** 2 miners missing

**Success Condition:**
The vulnerability is confirmed when `victories.Count < State.MinersCount.Value` despite sufficient backups being available in the `backups` list after line 69.

### Notes

The bug specifically manifests during network growth scenarios where governance has increased the miner count but validator participation hasn't kept pace. The `MinersCount` can be increased through governance proposals or auto-increase mechanisms [8](#0-7) , making this a realistic operational scenario rather than an edge case.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L60-60)
```csharp
        var diff = State.MinersCount.Value - validCandidates.Count;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L66-69)
```csharp
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L72-72)
```csharp
                .Take(Math.Min(diff, currentMiners.Count))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-232)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-280)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L42-42)
```csharp
    public Int32State MinersCount { get; set; }
```
