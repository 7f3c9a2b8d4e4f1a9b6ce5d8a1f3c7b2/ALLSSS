# Audit Report

## Title
Permanent DoS of NFT Cross-Chain Creation via Malformed Token Metadata

## Summary
The `CrossChainCreate()` function in NFTContract uses `bool.Parse()` on token metadata without validation or error handling. An attacker can bypass `NFTContract.Create()` and directly call `TokenContract.Create()` with malformed metadata (e.g., `"aelf_nft_token_id_reuse": "invalid"`), causing permanent denial-of-service for NFT protocol registration on side chains.

## Finding Description

The vulnerability exists in the NFT protocol's cross-chain registration flow. The `CrossChainCreate()` method directly parses the `NftTokenIdReuseMetadataKey` metadata value as a boolean without any validation: [1](#0-0) 

C#'s `bool.Parse()` throws `FormatException` if the input string is not exactly "True" or "False" (case-insensitive). An attacker can exploit this by:

1. **Bypassing NFTContract.Create()**: While `NFTContract.Create()` properly formats metadata using `bool.ToString()`: [2](#0-1) 
   
   Users can bypass this and call `TokenContract.Create()` directly, which accepts arbitrary `ExternalInfo`: [3](#0-2) 

2. **No Value Validation**: The `AssertMetadataKeysAreCorrect()` validation only prevents users from using reserved key names, not validating the values: [4](#0-3) 

3. **Metadata Propagation**: When tokens are validated for cross-chain creation, `ValidateTokenInfoExists()` only checks that metadata matches between input and stored token - it does not validate format: [5](#0-4) 

4. **Cross-Chain Transfer**: The `CrossChainCreateToken()` method directly copies malformed metadata to the side chain: [6](#0-5) 

5. **No Recovery Mechanism**: There is no method to update token `ExternalInfo` after creation. The system only has `ExtendSeedExpirationTime` for seed NFTs, which only modifies expiration time, not general metadata.

**Attack Steps:**
1. Attacker obtains a seed NFT for symbol "AR12345-0" (NFT collection)
2. Attacker calls `TokenContract.Create()` with malformed metadata: `ExternalInfo["aelf_nft_token_id_reuse"] = "invalid"`
3. Token is created on main chain with malformed metadata
4. When `NFTContract.CrossChainCreate()` is called on side chain, it throws `FormatException` at line 88
5. The NFT protocol can never be registered on the side chain because:
   - The protocol doesn't exist yet, so the assertion at line 79 passes
   - But line 88 always fails with `FormatException`
   - This repeats infinitely - permanent DoS [7](#0-6) 

## Impact Explanation

**HIGH Severity** - This vulnerability enables permanent denial-of-service of NFT protocol registration on side chains:

- **Permanent DoS**: Once a token with malformed metadata exists on the main chain and is validated for cross-chain use, `CrossChainCreate()` will permanently fail for that symbol on all side chains. There is no recovery mechanism.

- **Protocol-Level Impact**: The entire NFT collection becomes unusable on side chains - no minting, transferring, or burning of NFTs from that collection is possible on side chains.

- **Ecosystem Disruption**: Attackers can grief legitimate NFT projects by front-running their deployment with malformed metadata, blocking their cross-chain functionality indefinitely.

- **User Fund Impact**: Users expecting cross-chain NFT functionality are permanently blocked, affecting the utility and value of their holdings.

The impact is severe because:
1. It affects critical cross-chain functionality
2. It's irreversible (no update mechanism)
3. It blocks an entire NFT collection permanently
4. It requires only a seed NFT to execute

## Likelihood Explanation

**MEDIUM-to-HIGH Likelihood**:

**Attacker Requirements:**
- Obtain a seed NFT for the target symbol (costs resources but publicly available)
- Knowledge to call `TokenContract.Create()` instead of `NFTContract.Create()`
- Craft malformed `ExternalInfo` with invalid boolean string

**Attack Complexity:** LOW-to-MEDIUM
- Single transaction on main chain
- No special privileges required
- No timing constraints or race conditions
- Technically straightforward once understood

**Economic Rationality:**
- **Cost**: Price of seed NFT (variable but obtainable)
- **Gain**: Denial of competitor's cross-chain deployment, griefing, or blocking valuable symbols
- **Incentive**: Competitive advantage, extortion potential, or pure griefing

**Feasibility:** HIGH
- Seed NFTs are available for new symbols through standard mechanisms
- Attack can be executed before legitimate protocol creation
- No monitoring exists to detect malformed metadata before cross-chain usage

## Recommendation

Add validation before parsing boolean metadata values:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
    {
        Symbol = input.Symbol
    });
    if (string.IsNullOrEmpty(tokenInfo.Symbol))
        throw new AssertionException($"Token info {input.Symbol} not exists.");

    var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
    
    // ADD VALIDATION BEFORE PARSING
    Assert(tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var isTokenIdReuseStr),
        "NftTokenIdReuseMetadataKey not found in token metadata.");
    Assert(bool.TryParse(isTokenIdReuseStr, out var isTokenIdReuse),
        "Invalid boolean value for NftTokenIdReuseMetadataKey.");
    // Continue with validated value
    
    var nftTypeShortName = input.Symbol.Substring(0, 2);
    // ... rest of the method
}
```

Additionally, consider adding metadata format validation in `TokenContract.Create()` for NFT collection symbols, or enforcing that NFT collections can only be created through `NFTContract.Create()`.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task MalformedMetadata_CrossChainCreate_PermanentDoS()
{
    // 1. Setup: Create seed NFT on main chain
    var seedSymbol = await CreateSeedNFT("AR12345-0");
    
    // 2. Attacker bypasses NFTContract.Create and calls TokenContract.Create directly
    var malformedMetadata = new ExternalInfo();
    malformedMetadata.Value["aelf_nft_base_uri"] = "https://example.com";
    malformedMetadata.Value["aelf_nft_type"] = "Art";
    malformedMetadata.Value["aelf_nft_token_id_reuse"] = "invalid"; // MALFORMED - not "True" or "False"
    
    var createInput = new CreateInput
    {
        Symbol = "AR12345-0",
        TokenName = "Art Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        ExternalInfo = malformedMetadata
    };
    
    // This succeeds on main chain because TokenContract.Create accepts arbitrary ExternalInfo
    await TokenContractStub.Create.SendAsync(createInput);
    
    // 3. Validate token for cross-chain use
    var validateInput = new ValidateTokenInfoExistsInput
    {
        Symbol = "AR12345-0",
        TokenName = "Art Collection",
        TotalSupply = 10000,
        Decimals = 0,
        Issuer = DefaultSender,
        IsBurnable = true,
        ExternalInfo = malformedMetadata
    };
    await MainChainTokenContractStub.ValidateTokenInfoExists.SendAsync(validateInput);
    
    // 4. Cross-chain create token on side chain (succeeds)
    await CrossChainCreateTokenOnSideChain("AR12345-0");
    
    // 5. Attempt NFT protocol registration on side chain
    var crossChainInput = new CrossChainCreateInput { Symbol = "AR12345-0" };
    
    // This throws FormatException at line 88: bool.Parse("invalid")
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(crossChainInput);
    });
    
    Assert.Contains("FormatException", exception.Message);
    
    // 6. Verify permanent DoS - retry still fails
    var exception2 = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(crossChainInput);
    });
    
    Assert.Contains("FormatException", exception2.Message);
    // NFT protocol can NEVER be registered on side chain for this symbol
}
```

## Notes

The vulnerability stems from an architectural issue where the NFT contract assumes tokens are created through the proper `NFTContract.Create()` flow, but users can bypass this by calling `TokenContract.Create()` directly. The lack of value validation for metadata in the token creation and cross-chain flows allows malformed data to propagate, causing permanent DoS when parsed on side chains.

The severity is HIGH because:
1. **Permanent and irreversible** - no recovery mechanism exists
2. **Critical functionality** - blocks entire NFT collection on side chains
3. **Low attack barrier** - only requires a seed NFT
4. **Economic incentive** - enables griefing and competitive advantage

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L88-88)
```csharp
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L452-455)
```csharp
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```
