### Title
Retroactive Miner Count Calculation Causes Sudden Jumps When MinerIncreaseInterval is Modified

### Summary
The `SetMinerIncreaseInterval()` function allows governance to decrease the miner increase interval, but the `GetAutoIncreasedMinersCount()` calculation treats the entire blockchain history as if the NEW interval had always been in effect. This retroactive calculation causes an immediate, sudden jump in the miner count that violates the intended gradual increase mechanism and disrupts consensus by selecting more miners than should be eligible.

### Finding Description

The root cause lies in how the auto-increased miner count is calculated. The `SetMinerIncreaseInterval()` function updates the `State.MinerIncreaseInterval.Value` with a new (decreased) interval value [1](#0-0) , and this value is immediately used by `GetAutoIncreasedMinersCount()` in its retroactive calculation [2](#0-1) .

The calculation formula divides the total elapsed time since blockchain start by the CURRENT interval value, multiplies by 2, and adds it to the base count of 17 miners. When the interval is decreased (e.g., from 1 year to 6 months), the division suddenly produces a larger quotient, indicating more "elapsed intervals" than actually occurred historically.

This jumped value is then used by `GetMinersCount()` [3](#0-2)  and propagated to the Election Contract via `UpdateMinersCount()` during term transitions [4](#0-3)  or when `SetMaximumMinersCount()` is called [5](#0-4) .

The Election Contract stores this value [6](#0-5)  and uses it in `GetVictories()` to determine how many candidates should be selected as miners for the next term [7](#0-6) .

### Impact Explanation

**Concrete Harm:**
When the miner increase interval is decreased, the miner count jumps immediately rather than increasing gradually. For example:
- **Initial state:** 2 years elapsed, interval = 31,536,000 seconds (1 year), miner count = 17 + (63,072,000 / 31,536,000) × 2 = 21 miners
- **After interval change to 6 months (15,768,000 seconds):** miner count = 17 + (63,072,000 / 15,768,000) × 2 = 25 miners
- **Result:** Sudden jump of 4 miners

**Protocol Damage:**
1. **Consensus Disruption:** The sudden addition of 4+ miners changes the consensus participant set abruptly, violating the intended gradual decentralization mechanism that's supposed to add only 2 miners per interval [8](#0-7) 
2. **Reward Dilution:** Mining rewards are distributed among all miners, so existing miners suddenly receive proportionally less reward
3. **Security Model Violation:** AEDPoS uses a "2N+1" Byzantine fault tolerance model where the number of miners affects the security threshold
4. **Candidate Selection Error:** Less-qualified candidates who shouldn't be eligible yet become miners immediately

**Affected Parties:**
- Existing miners (reduced rewards)
- Network security (altered fault tolerance assumptions)
- Governance expectations (policy changes have retroactive effects)

**Severity:** MEDIUM - While this doesn't directly steal funds or break authorization, it violates critical consensus invariants and causes operational disruption with reward misallocation.

### Likelihood Explanation

**Attacker Capabilities:**
This requires authorized governance action through the `MaximumMinersCountController` (default: Parliament) [9](#0-8) . However, the governance body may legitimately want to adjust the interval for valid policy reasons (e.g., accelerating decentralization).

**Attack Complexity:**
The vulnerability triggers automatically once `SetMinerIncreaseInterval()` is called - no additional steps are needed. The retroactive calculation bug is deterministic.

**Feasibility Conditions:**
- Governance must approve an interval decrease (the validation only allows decreasing, not increasing) [10](#0-9) 
- The next call to `UpdateMinersCountToElectionContract()` will propagate the jumped value
- This can happen during the next term transition or when `SetMaximumMinersCount` is called

**Detection/Operational Constraints:**
The jump would be immediately visible in `GetMaximumMinersCount()` return value and in the next term's miner list size. However, governance may not realize the retroactive effect until after approval.

**Probability:** HIGH - If governance ever adjusts the interval for legitimate reasons (acceleration of decentralization, policy change), the bug will trigger with certainty.

### Recommendation

**Code-Level Mitigation:**

Replace the retroactive calculation with a tracking mechanism that records historical intervals and calculates the cumulative miner increase properly:

1. Add state variable to track interval change history:
```
State.MinerIncreaseHistory -> MappedState<long, MinerIncreaseIntervalRecord>
```

2. Modify `SetMinerIncreaseInterval()` to record the change:
    - Store current timestamp and old interval value
    - Calculate miners earned under old interval before change
    - Store as baseline for future calculations

3. Modify `GetAutoIncreasedMinersCount()` to:
    - Calculate miners earned during each historical interval period
    - Sum up the total without retroactive application

**Invariant Checks:**
- Add assertion: new miner count must not increase by more than 2 miners per actual interval elapsed since last update
- Log miner count changes to make sudden jumps visible

**Test Cases:**
1. Test that changing interval mid-chain doesn't cause sudden jumps
2. Test that miner count increases by exactly 2 per interval regardless of when interval changes occur
3. Test edge case: interval change at exactly the same time as term transition
4. Regression test: verify `GetAutoIncreasedMinersCount()` returns same value before/after interval change at same timestamp

### Proof of Concept

**Initial State:**
- Blockchain started 2 years (63,072,000 seconds) ago
- `State.MinerIncreaseInterval.Value = 31,536,000` (1 year)
- Current miner count from `GetAutoIncreasedMinersCount()`: 17 + (63,072,000 / 31,536,000) × 2 = 21 miners

**Transaction Steps:**

1. **Governance proposes and approves** `SetMinerIncreaseInterval(15,768,000)` (6 months)
   - Proposal passes through Parliament
   - `State.MinerIncreaseInterval.Value` updated to 15,768,000 seconds

2. **Query `GetMaximumMinersCount()`** immediately after:
   - Calls `GetAutoIncreasedMinersCount()`
   - Calculation: 17 + (63,072,000 / 15,768,000) × 2 = 17 + 8 = 25 miners
   - Returns 25 (or MaximumMinersCount if lower)

3. **Next term transition** calls `UpdateMinersCountToElectionContract()`:
   - Sends new miners count (25) to Election Contract
   - Election Contract updates `State.MinersCount.Value = 25`

4. **`GetVictories()` is called** for next term miner selection:
   - Takes top 25 candidates instead of 21
   - 4 additional, potentially less-qualified candidates become miners

**Expected Result:** Miner count should remain at 21 (or increase by at most 2 if a full interval elapsed)

**Actual Result:** Miner count jumps to 25, adding 4 miners instantly

**Success Condition:** The sudden jump from 21 to 25 miners demonstrates the retroactive calculation bug causing unintended consensus disruption.

---

### Notes

The validation at line 61 that only allows decreasing the interval (`input.Value <= State.MinerIncreaseInterval.Value`) was likely intended to prevent security issues from rapidly increasing miner counts, but it ironically enables this bug by allowing retroactive jumps when decreasing. The intended design appears to be a gradual increase of 2 miners per interval to slowly decentralize the network, but the retroactive calculation defeats this purpose whenever governance adjusts the interval for legitimate policy reasons.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L20-28)
```csharp
        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L118-118)
```csharp
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);
```
