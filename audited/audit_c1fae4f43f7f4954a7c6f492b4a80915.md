# Audit Report

## Title
Consensus Mining Order Manipulation via Unverified Signature Field

## Summary
The AEDPoS consensus contract accepts arbitrary signature and mining order values from miners without verification during the `UpdateValue` operation. This allows any authorized miner to deterministically control their mining position in subsequent rounds, violating consensus fairness and enabling continuous MEV extraction advantages.

## Finding Description

The AEDPoS consensus mechanism is designed to calculate mining orders deterministically from cryptographic signatures. When an honest miner produces a block, the system should calculate their signature by XORing their in-value with previous signatures [1](#0-0) , then derive the mining order from this signature value [2](#0-1) .

However, the validation provider only checks that the signature field is non-null and non-empty, not that it is correctly calculated [3](#0-2) . During block processing, the system directly copies the attacker-provided signature and order values without any verification or recalculation [4](#0-3) .

When the next round is generated, these manipulated order values directly determine mining time slots [5](#0-4) . A malicious miner can exploit this by:

1. Setting `SupposedOrderOfNextRound = 1` to always mine first
2. Providing arbitrary signature bytes (any non-empty value passes validation)
3. The manipulated values are stored and used to assign time slots in the next round
4. The attacker repeats this process every round to maintain mining priority

The honest behavior generates signatures correctly through `GetConsensusExtraDataToPublishOutValue` which calculates the signature and derives the order [6](#0-5) . But the validation path never verifies that submitted values match this calculation.

## Impact Explanation

**Critical Consensus Integrity Violation**: This breaks the core security guarantee that mining order is unpredictable and fairly determined. A malicious miner can deterministically control their position across all subsequent rounds, fundamentally compromising the consensus mechanism's fairness.

**Economic Advantages**: Earlier mining positions provide:
- Priority transaction selection for MEV (Maximal Extractable Value) capture
- Control over transaction ordering within blocks
- First access to profitable arbitrage opportunities
- Ability to front-run or sandwich other transactions

**Persistent Exploitation**: The attacker can maintain mining position control indefinitely with zero additional cost, as the manipulation occurs in every block they produce.

**Protocol-Wide Impact**: All other miners are disadvantaged as favorable time slots are monopolized, and users experience unfair transaction ordering that benefits the attacker.

## Likelihood Explanation

**High Likelihood**: Any authorized miner can execute this attack immediately with trivial effort:

**Attacker Requirements**: Only requires being an active miner in the current set - a realistic capability for the threat model.

**Technical Complexity**: Extremely low - the attacker simply provides manipulated values in their `UpdateValue` transaction. No sophisticated cryptographic attacks or complex state manipulation required.

**Detection Difficulty**: The signature field appears valid (non-empty bytes), making the attack difficult to detect without specifically comparing expected vs. actual signature values.

**Economic Incentive**: Strong - zero cost to execute (just data modification) with ongoing MEV benefits worth potentially significant value on an active blockchain.

**Execution Path**: Direct through the public `UpdateValue` method that all miners use for normal block production. No special conditions or race scenarios required.

## Recommendation

Add signature verification to `UpdateValueValidationProvider` or `ProcessUpdateValue`:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation or ProcessUpdateValue
var providedSignature = updateValueInput.Signature;
var providedOrder = updateValueInput.SupposedOrderOfNextRound;

// Recalculate expected signature
var expectedSignature = previousRound.CalculateSignature(updateValueInput.PreviousInValue);
Assert(providedSignature == expectedSignature, "Invalid signature value");

// Recalculate expected order from signature
var expectedOrder = GetAbsModulus(expectedSignature.ToInt64(), minersCount) + 1;
Assert(providedOrder == expectedOrder, "Mining order does not match signature");
```

Alternatively, remove these fields from user input and always calculate them server-side during `ProcessUpdateValue`, similar to how `ProducedBlocks` is incremented rather than accepted from input [7](#0-6) .

## Proof of Concept

```csharp
// Test demonstrating mining order manipulation
[Fact]
public async Task MaliciousMiner_CanManipulateMiningOrder()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensusRound(miners);
    
    // Malicious miner is miner[2] (normally would have random order)
    var maliciousMiner = miners[2];
    
    // Create UpdateValue input with manipulated values
    var maliciousInput = new UpdateValueInput
    {
        ActualMiningTime = Context.CurrentBlockTime,
        OutValue = Hash.FromString("fake_outvalue"),
        Signature = Hash.FromString("fake_signature"), // Arbitrary signature
        SupposedOrderOfNextRound = 1, // Force mining order to 1 (first position)
        PreviousInValue = Hash.FromString("fake_previous"),
        ImpliedIrreversibleBlockHeight = Context.CurrentHeight - 1
    };
    
    // Execute malicious UpdateValue - should fail but currently succeeds
    await maliciousMiner.UpdateValue(maliciousInput);
    
    // Verify next round was generated with manipulated order
    var nextRound = await GenerateNextRound();
    var maliciousMinerInNextRound = nextRound.RealTimeMinersInformation[maliciousMiner.PublicKey];
    
    // Assert: Malicious miner successfully set themselves as first miner
    Assert.Equal(1, maliciousMinerInNextRound.Order);
    
    // Assert: Their expected mining time is earliest in the round
    var allMiners = nextRound.RealTimeMinersInformation.Values.OrderBy(m => m.ExpectedMiningTime);
    Assert.Equal(maliciousMiner.PublicKey, allMiners.First().Pubkey);
}
```

## Notes

This vulnerability demonstrates a fundamental flaw in the validation architecture where cryptographically-derived values are accepted as user input without verification. The separation between honest generation (in `GetConsensusExtraDataToPublishOutValue`) and validation/processing creates an exploitable gap. The fix must ensure that all security-critical values are either recalculated from trusted inputs or cryptographically verified before use in consensus decisions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L250-252)
```csharp
        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-112)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
            }
        }

        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
