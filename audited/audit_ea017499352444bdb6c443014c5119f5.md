### Title
Creator Impersonation Vulnerability in NFT Protocol Creation

### Summary
The `Create()` method in NFTContract allows `input.Creator` to be set to an arbitrary address different from `Context.Sender`, enabling an attacker to gain exclusive control over an NFT protocol while the victim pays the seed NFT cost. This results in privilege escalation where the attacker becomes the protocol creator/issuer with sole authority to add/remove minters, while the actual transaction sender loses their valuable seed NFT without gaining any control.

### Finding Description

The vulnerability exists in the `Create()` method where the creator address is determined: [1](#0-0) 

This line allows `input.Creator` to be any address without validating it matches `Context.Sender`. This creator then becomes the token issuer in the underlying MultiToken contract: [2](#0-1) 

The authorization check for token creation happens in the MultiToken contract against `Context.Sender` (the transaction initiator), not against the `Issuer` field: [3](#0-2) 

This creates a dangerous disconnect: the MultiToken contract validates and burns the seed NFT from `Context.Sender`'s balance, but grants issuer privileges to the arbitrary `input.Creator` address. The creator is stored as the protocol owner with exclusive control: [4](#0-3) 

Only the creator can add or remove minters: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- Victim loses their seed NFT, which is a valuable and limited resource required for token creation
- Seed NFTs have real economic value as they enable protocol creation rights

**Authorization Impact:**
- Attacker gains exclusive creator privileges without authorization
- Only the creator (attacker) can add/remove minters for the protocol
- The creator becomes the token issuer in the MultiToken contract, granting exclusive `Issue()` rights: [7](#0-6) 

**Who is Affected:**
- Any user creating NFT protocols who can be manipulated to provide an incorrect `input.Creator` value
- Protocol creators interacting with malicious dApps or compromised frontends

**Severity Justification:**
Medium severity due to:
- Concrete financial loss (seed NFT)
- Complete loss of protocol control
- Privilege escalation to attacker
- However, requires victim cooperation/manipulation

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to influence victim's transaction input (via malicious dApp, compromised frontend, or social engineering)
- No special permissions or resources needed

**Attack Complexity:**
- Low complexity - single transaction with manipulated input
- Attack vectors include:
  1. Malicious dApp providing pre-filled forms with attacker's address as creator
  2. Compromised SDK/API that incorrectly populates `input.Creator`
  3. Social engineering to convince victim to use specific parameters
  4. Man-in-the-middle attacks modifying transaction parameters

**Feasibility Conditions:**
- Victim must be creating an NFT protocol (normal operation)
- Victim must either:
  - Use a malicious interface that sets wrong creator
  - Be socially engineered to provide wrong parameters
  - Use compromised tooling

**Detection Constraints:**
- Difficult to detect as the transaction appears valid
- No on-chain warning that creator differs from sender
- Victim may not notice until attempting to manage the protocol

**Probability Reasoning:**
- Medium probability due to reliance on victim cooperation
- Increasingly realistic as malicious dApps proliferate
- Higher risk for less technical users who trust frontend interfaces

### Recommendation

**Code-Level Mitigation:**
Add validation in the `Create()` method to ensure the creator matches the sender:

```csharp
public override StringValue Create(CreateInput input)
{
    Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
        "NFT Protocol can only be created at aelf mainchain.");
    MakeSureTokenContractAddressSet();
    MakeSureRandomNumberProviderContractAddressSet();
    var symbol = GetSymbol(input.NftType);
    var tokenExternalInfo = GetTokenExternalInfo(input);
    
    // FIX: Validate creator or default to sender
    var creator = input.Creator ?? Context.Sender;
    Assert(creator == Context.Sender, 
        "Creator must be the transaction sender.");
    
    // Rest of implementation...
}
```

**Alternative Approach:**
Remove the `Creator` field from `CreateInput` entirely and always use `Context.Sender`:

```csharp
var creator = Context.Sender;
```

This eliminates the attack surface completely.

**Invariant Checks:**
- `Assert(input.Creator == null || input.Creator == Context.Sender, "Invalid creator")`
- Document that the creator MUST be the transaction sender

**Test Cases:**
1. Test that `Create()` with `input.Creator != Context.Sender` fails with assertion
2. Test that `Create()` with `input.Creator == null` succeeds and uses `Context.Sender`
3. Test that `Create()` with `input.Creator == Context.Sender` succeeds
4. Test that attempting to create with different creator from a malicious contract fails

### Proof of Concept

**Initial State:**
- Alice has 1 seed NFT for creating protocols
- Bob (attacker) wants to control an NFT protocol without paying

**Attack Sequence:**

1. **Bob creates malicious dApp** that calls NFT contract with:
   ```
   CreateInput {
       NftType = "VirtualWorlds",
       ProtocolName = "STOLEN",
       TotalSupply = 1000000,
       Creator = Bob's Address,  // Attacker's address
       IsBurnable = true,
       ... other fields ...
   }
   ```

2. **Alice uses Bob's dApp** thinking she's creating her own protocol:
   - Transaction sender: Alice's address (Context.Sender = Alice)
   - CreateInput.Creator: Bob's address

3. **Contract execution:**
   - Line 22: `creator = Bob's address` (from input.Creator)
   - Line 34: Calls `State.TokenContract.Create.Send()` with Issuer = Bob
   - MultiToken contract (lines 56-65) checks Alice (Context.Sender) for authorization
   - Alice's seed NFT is burned
   - Token is created with Bob as issuer

4. **Result:**
   - Alice lost her seed NFT
   - Bob is the creator (line 45 in NFTProtocolInfo)
   - Bob is the token issuer
   - Only Bob can add/remove minters (lines 338, 358)
   - Only Bob can issue tokens (line 160 in MultiToken)
   - Alice has zero control despite paying the cost

**Expected vs Actual:**
- **Expected:** Alice pays seed NFT → Alice controls protocol
- **Actual:** Alice pays seed NFT → Bob controls protocol

**Success Condition:**
Query `GetNFTProtocolInfo` for the created symbol shows `Creator = Bob's address`, while Alice's seed NFT balance decreased by 1.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L160-161)
```csharp
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```
