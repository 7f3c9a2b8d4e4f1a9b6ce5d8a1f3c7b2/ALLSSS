### Title
NFT Contract Stub ACS1 Implementation Cannot Be Safely Upgraded Without Breaking Fee Configurations

### Summary
The NFT contract's stub ACS1 implementation has no-op `SetMethodFee` and `ChangeMethodFeeController` methods that silently ignore all inputs without storing any state. [1](#0-0)  The contract state lacks required `TransactionFees` and `MethodFeeController` storage variables needed for proper ACS1 functionality. [2](#0-1)  When upgraded to a proper ACS1 implementation, the fee behavior will break catastrophically: the hardcoded 100 ELF fee for `Create` method will become 0 ELF, and any governance-attempted fee configurations during the stub phase will be permanently lost.

### Finding Description

The NFT contract implements ACS1 as a non-functional stub with critical missing components:

**1. No-Op Mutation Methods:**
- `SetMethodFee` simply returns `new Empty()` without any storage or validation [3](#0-2) 
- `ChangeMethodFeeController` also returns `new Empty()` without storage [4](#0-3) 

**2. Hardcoded View Methods:**
- `GetMethodFee` returns hardcoded 100 ELF for "Create" method, empty `MethodFees` for all others [5](#0-4) 
- `GetMethodFeeController` returns empty `AuthorityInfo` [6](#0-5) 

**3. Missing State Storage:**
The contract state has no `TransactionFees` or `MethodFeeController` storage, which are essential for proper ACS1 implementations as seen in all other system contracts. [7](#0-6) 

**4. Fee Charging Dependency:**
The token contract's fee charging mechanism calls `GetMethodFee` and treats null/empty results as zero fees. [8](#0-7) 

**5. Upgrade Path Breaks:**
When upgraded to a proper ACS1 implementation following the standard pattern (like TokenConverter), the new `GetMethodFee` would return `State.TransactionFees[input.Value]`, which would be null since nothing was stored during the stub phase. [9](#0-8) 

### Impact Explanation

**Fee Configuration Loss:**
- Any governance attempts to configure fees via `SetMethodFee` during stub deployment are silently ignored, creating a false sense of successful configuration
- After upgrade, these "configured" fees are permanently lost

**Breaking Fee Behavior Change:**
- During stub: Create method costs 100 ELF (hardcoded)
- After TokenConverter-style upgrade: Create method costs 0 ELF (State.TransactionFees["Create"] returns null)
- This is a 100 ELF revenue loss per transaction

**Alternative Upgrade Still Problematic:**
Even if upgraded with Profit/Vote-style fallback defaults [10](#0-9) , any fees "set" during stub phase are still lost, requiring complete governance re-configuration.

**Governance Confusion:**
- Operators may believe SetMethodFee works during stub phase
- No error messages or indications that operations are no-ops
- Creates operational risk and configuration uncertainty

**Who Is Affected:**
- Protocol treasury: loses fee revenue
- Users: unpredictable fee behavior post-upgrade
- Governance: wasted proposals and confusion
- Contract operators: operational uncertainty

### Likelihood Explanation

**Highly Likely Under Normal Operations:**
- This scenario occurs during the standard contract upgrade process
- No attacker action required - happens automatically when upgrading from stub to proper implementation
- The stub pattern is unusual (only 2 contracts use it vs. all other system contracts using proper ACS1) [11](#0-10) 

**No Special Permissions Required:**
- Standard governance upgrade process triggers the issue
- Any governance calls to SetMethodFee during stub phase silently fail (no attacker needed)

**Feasible Preconditions:**
- Stub is deployed to mainnet (as indicated in the security question)
- Contract is later upgraded to proper ACS1 implementation
- Both are normal operational activities

**Detection Difficulty:**
- No warnings or errors when SetMethodFee is called on stub
- Fee behavior only breaks after upgrade completes
- Impact manifests gradually as transactions use the upgraded contract

### Recommendation

**Immediate Fix Before Mainnet Deployment:**
1. Add required state variables to NFTContractState.cs:
   - `public MappedState<string, MethodFees> TransactionFees { get; set; }`
   - `public SingletonState<AuthorityInfo> MethodFeeController { get; set; }`

2. Implement proper SetMethodFee with storage and validation (follow TokenConverter pattern)

3. Implement GetMethodFee with fallback defaults matching current stub values:
```
public override MethodFees GetMethodFee(StringValue input)
{
    var methodFees = State.TransactionFees[input.Value];
    if (methodFees != null) return methodFees;
    
    // Fallback defaults matching stub behavior
    if (input.Value == nameof(Create))
        return new MethodFees { 
            Fees = { new MethodFee { 
                Symbol = Context.Variables.NativeSymbol, 
                BasicFee = 100_00000000 
            }}
        };
    return new MethodFees();
}
```

4. Implement RequiredMethodFeeControllerSet() to initialize controller to Parliament [12](#0-11) 

5. Implement ChangeMethodFeeController with validation [13](#0-12) 

**Test Cases:**
- Verify SetMethodFee actually stores fees to state
- Verify GetMethodFee returns stored fees when set
- Verify GetMethodFee returns correct defaults when not set
- Verify ChangeMethodFeeController updates controller
- Verify fee charging works correctly with both stored and default fees

### Proof of Concept

**Step 1: Deploy Stub to Mainnet**
- NFT contract deployed with current stub ACS1 implementation
- GetMethodFee("Create") returns 100 ELF hardcoded
- Users pay 100 ELF per Create transaction

**Step 2: Governance Attempts Fee Configuration**
- Parliament proposes: SetMethodFee for Create method to 50 ELF
- Transaction succeeds (returns Empty)
- No error occurs, governance believes configuration succeeded
- Actual state: nothing stored (no-op)

**Step 3: Upgrade to Proper ACS1 (TokenConverter Pattern)**
- Contract upgraded with GetMethodFee returning State.TransactionFees[input.Value]
- No migration logic to populate State.TransactionFees

**Step 4: Fee Behavior Breaks**
- User calls Create method
- ChargeTransactionFees calls GetMethodFee("Create")
- Returns null (State.TransactionFees["Create"] never set)
- Fee charging treats null as zero fee
- User pays 0 ELF instead of 100 ELF

**Expected Result:**
- Create method should cost configured amount (50 ELF from Step 2, or 100 ELF default)

**Actual Result:**
- Create method costs 0 ELF
- Protocol loses 100 ELF revenue per transaction
- Fee configuration from Step 2 permanently lost

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
ï»¿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L35-38)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var methodFees = State.TransactionFees[input.Value];
        if (methodFees != null) return methodFees;

        switch (input.Value)
        {
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```
