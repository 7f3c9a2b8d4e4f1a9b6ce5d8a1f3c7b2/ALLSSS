# Audit Report

## Title
Missing Order Value Validation in Round Structure Enables Consensus DoS Attack

## Summary
The AEDPoS consensus contract fails to validate that miner Order values in Round structures start sequentially from 1. The `GetMiningInterval()` method assumes miners with Order 1 and 2 exist, while the validation in `CheckRoundTimeSlots()` only checks time interval consistency without verifying Order values. A malicious miner can exploit this gap by submitting a `NextRoundInput` with invalid Order values (e.g., starting from 10), causing all nodes to crash with an `ArgumentOutOfRangeException` when retrieving consensus commands.

## Finding Description

The vulnerability stems from a critical mismatch between validation logic and runtime assumptions in the consensus mechanism.

The `CommandStrategyBase` constructor accepts a Round parameter and exposes a `MiningInterval` property that calls `GetMiningInterval()` on the CurrentRound [1](#0-0) .

The `GetMiningInterval()` method specifically filters miners where `Order == 1` or `Order == 2` and directly accesses `firstTwoMiners[1]` without bounds checking [2](#0-1) . If no miners have Order 1 or 2, this causes an unhandled exception.

The validation logic in `CheckRoundTimeSlots()` orders miners by their Order field and validates time intervals, but crucially does NOT validate that Orders start from 1 or are sequential [3](#0-2) . It only checks that `ExpectedMiningTime` is not null and time slots are consistent.

This validation is invoked by `TimeSlotValidationProvider` when processing new round information [4](#0-3) .

When a malicious `NextRoundInput` is processed, it passes validation and gets stored without additional Order value checks [5](#0-4) . The Round is stored directly in contract state [6](#0-5) .

Subsequently, when any miner requests a consensus command, the malicious Round is retrieved and passed to strategy class constructors [7](#0-6) .

All strategy implementations access the `MiningInterval` property, triggering the crash: NormalBlockCommandStrategy [8](#0-7) , TinyBlockCommandStrategy [9](#0-8) , and TerminateRoundCommandStrategy [10](#0-9) .

The legitimate round generation process uses `Enumerable.Range(1, minersCount)` to assign sequential Orders starting from 1 [11](#0-10) , and the `BreakContinuousMining` method assumes Orders 1, 2, minersCount-1, and minersCount exist [12](#0-11) .

## Impact Explanation

**Operational Impact**: This vulnerability causes complete denial of service of the consensus mechanism. Once a malicious Round is stored in contract state, all nodes will crash with an unhandled `ArgumentOutOfRangeException` when any miner attempts to retrieve consensus commands. This halts block production entirely across the network.

**Severity: HIGH** - The entire blockchain stops producing blocks. All miners are affected regardless of their individual behavior. The attack requires only a single malicious block from any current miner. Recovery requires coordinated manual intervention across all nodes to reset contract state, which is operationally complex and time-consuming in a decentralized network.

**Affected Parties**: All network participants - miners cannot produce blocks, users cannot submit transactions, and the entire chain becomes frozen until manual intervention restores consensus state.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be an active miner (member of current or previous round's miner list), verified by the `PreCheck()` method [13](#0-12) . While this limits the attack surface, miners are not considered fully trusted in AElf's threat model.

**Attack Complexity: LOW** - The attacker simply needs to:
1. Craft a `NextRoundInput` with miners having Orders starting from 10 (or any value other than 1)
2. Set `ExpectedMiningTime` values correctly with consistent intervals to pass time validation
3. Submit a block containing this malicious NextRoundInput

**Feasibility**: High - No special economic cost beyond being a miner, single malicious block execution, validation passes because `CheckRoundTimeSlots()` doesn't check Order values, and impact is immediate and permanent on all nodes.

**Detection**: The attack is difficult to detect before execution because the malformed Round passes all validation checks. Once executed, the impact is immediate and catastrophic.

**Probability: MEDIUM-HIGH** - While limited to miners, the attack is trivial to execute with maximum impact and minimal cost.

## Recommendation

Add Order value validation to the `CheckRoundTimeSlots()` method to ensure Orders are sequential starting from 1:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // NEW: Validate Orders are sequential starting from 1
    for (var i = 0; i < miners.Count; i++)
    {
        if (miners[i].Order != i + 1)
            return new ValidationResult { Message = $"Invalid miner Order values. Expected sequential orders starting from 1.\n{this}" };
    }

    var baseMiningInterval =
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval =
            (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Alternatively, add bounds checking in `GetMiningInterval()` to handle malformed Rounds gracefully, though proper validation at the entry point is preferred.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousNextRound_WithInvalidOrders_CausesConsensusCrash()
{
    // Setup: Initialize consensus with legitimate first round
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Attack: Craft malicious NextRoundInput with Orders starting from 10
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        TermNumber = 1,
        RealTimeMinersInformation =
        {
            {
                initialMiners[0], new MinerInRound
                {
                    Pubkey = initialMiners[0],
                    Order = 10, // Invalid: should be 1
                    ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(10)
                }
            },
            {
                initialMiners[1], new MinerInRound
                {
                    Pubkey = initialMiners[1],
                    Order = 11, // Invalid: should be 2
                    ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(14)
                }
            },
            {
                initialMiners[2], new MinerInRound
                {
                    Pubkey = initialMiners[2],
                    Order = 12, // Invalid: should be 3
                    ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(18)
                }
            }
        }
    };
    
    // Malicious miner submits NextRoundInput - validation passes (incorrectly)
    var result = await ConsensusStub.NextRound.SendAsync(
        NextRoundInput.Create(maliciousRound, GenerateRandomNumber()));
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Trigger: Any miner tries to get consensus command
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await ConsensusStub.GetConsensusCommand.CallAsync(
            new BytesValue { Value = ByteString.CopyFrom(initialMiners[0].ToByteArray()) });
    });
    
    // Verify: ArgumentOutOfRangeException occurs when accessing firstTwoMiners[1]
    exception.InnerException.ShouldBeOfType<ArgumentOutOfRangeException>();
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L28-37)
```csharp
        protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;
            Pubkey = pubkey;
            CurrentBlockTime = currentBlockTime;
        }

        protected MinerInRound MinerInRound => CurrentRound.RealTimeMinersInformation[Pubkey];
        protected int Order => CurrentRound.GetMiningOrder(Pubkey);
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L20-56)
```csharp
    private ConsensusCommand GetConsensusCommand(AElfConsensusBehaviour behaviour, Round currentRound,
        string pubkey, Timestamp currentBlockTime = null)
    {
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        Context.LogDebug(() => $"Params to get command: {behaviour}, {pubkey}, {currentBlockTime}");

        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();

        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();

            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();

            case AElfConsensusBehaviour.TinyBlock:
            {
                var consensusCommand =
                    new ConsensusCommandProvider(new TinyBlockCommandStrategy(currentRound, pubkey,
                        currentBlockTime, GetMaximumBlocksCount())).GetConsensusCommand();
                return consensusCommand;
            }

            default:
                return ConsensusCommandProvider.InvalidConsensusCommand;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L38-38)
```csharp
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L34-38)
```csharp
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
                    ? MinerInRound.ActualMiningTimes.First()
                    : MinerInRound.ExpectedMiningTime;
            var currentTimeSlotEndTime = currentTimeSlotStartTime.AddMilliseconds(MiningInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L35-35)
```csharp
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L41-41)
```csharp
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-107)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```
