### Title
Organization State Manipulation Enables Retroactive Proposal Outcome Control

### Summary
The Association contract allows organization parameters (thresholds and member lists) to be modified while proposals are actively being voted on. When a proposal is released, threshold checks use the current organization state rather than the state at voting time, enabling retroactive manipulation of proposal outcomes through strategic threshold changes or member list modifications.

### Finding Description

The vulnerability exists in the interaction between proposal release logic and organization modification methods.

**Core Issue - No State Snapshotting**: When proposals are created and voted on, they store vote addresses but do not snapshot the organization's threshold parameters or member list. [1](#0-0) 

**Vulnerable Release Path**: When `Release()` is called, it fetches the current organization state and checks thresholds against this current state, not the state when voting occurred. [2](#0-1) 

**Threshold Checking Functions Use Current State**: All three threshold validation functions (`IsProposalRejected`, `IsProposalAbstained`, `CheckEnoughVoteAndApprovals`) receive the current organization object and compare votes against current thresholds. [3](#0-2) 

**Critical Vote Counting Issue**: Vote counting only counts votes from addresses currently in the organization member list using `.Count(organization.OrganizationMemberList.Contains)`. If a member is removed after voting, their vote is discarded. [4](#0-3) 

**Modification Methods Accessible During Voting**: The contract provides methods to modify organization state that can be called by the organization itself (via released proposals):
- `ChangeOrganizationThreshold` - modifies all threshold parameters [5](#0-4) 
- `AddMember`, `RemoveMember`, `ChangeMember` - modify member list [6](#0-5) 

**Explicit Acknowledgment**: The ACS3 standard explicitly documents this behavior: "All fields will be overwritten by the input value and this will affect all current proposals of the organization." [7](#0-6) 

### Impact Explanation

**Governance Integrity Violation**: Organizations can retroactively change the outcome of proposals after voting has occurred, fundamentally undermining the governance model's trustworthiness.

**Attack Scenario 1 - Blocking Valid Proposals**: 
- Proposal A receives 3/5 approvals (MinimalApprovalThreshold=3)
- Before release, another proposal changes threshold to 4
- Proposal A can no longer be released despite meeting original requirements

**Attack Scenario 2 - Vote Invalidation via Member Removal**:
- Proposal X receives approvals from members A, B, C (3 approvals, threshold=3)
- Before release, members A and B are removed
- Only C's vote counts (approvedMemberCount=1), proposal fails despite having sufficient votes

**Attack Scenario 3 - Enabling Invalid Proposals**:
- Proposal Y has 2 approvals (threshold=3)
- Another proposal lowers threshold to 2
- Proposal Y becomes releasable despite insufficient original support

**Severity Justification**: This is CRITICAL because it allows manipulation of any proposal outcome, enables censorship of valid proposals, and permits execution of proposals that should fail. The impact affects the entire governance layer which controls system upgrades, parameter changes, and fund movements.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must control enough organization members to pass an initial proposal that modifies organization parameters. In a 5-member organization with threshold=3, controlling 3 members is sufficient.

**Attack Complexity**: Low - requires only:
1. Creating and approving a proposal to modify organization parameters
2. Releasing that proposal while target proposals are pending
3. The timing window exists from when a proposal receives votes until it is released

**Feasibility Conditions**: 
- Multiple concurrent proposals (common in active governance)
- Ability to pass one proposal to modify organization state (realistic if attacker has governance influence)
- Target proposal not yet released (wide timing window)

**Detection Constraints**: The modification is legitimate contract functionality, making detection difficult. No on-chain protections exist to prevent this timing-based manipulation.

**Probability Assessment**: HIGH - This is practical in real-world governance scenarios where:
- Organizations have multiple active proposals
- Governance participants have sufficient influence to pass parameter changes
- The attack requires no special privileges beyond normal proposal creation/approval

### Recommendation

**Immediate Mitigation**: Implement proposal state snapshotting:

1. **Snapshot Organization State**: When a proposal is created, store a snapshot of the organization's thresholds and member list within the ProposalInfo structure.

2. **Use Snapshot for Validation**: Modify `IsReleaseThresholdReached` and its helper functions to use the snapshotted organization state instead of querying current state.

3. **Lock Critical Parameters**: Add a check to prevent organization parameter modifications when active proposals exist, or implement a time delay between parameter changes and when they take effect.

4. **Validation Changes**: Update the vote counting logic to either:
   - Use the snapshotted member list for vote validation
   - Store membership status at vote time
   - Prevent member removal if they have active votes

**Code-Level Changes**:
- Extend ProposalInfo to include `OrganizationSnapshot` field
- Modify `CreateNewProposal` to capture and store organization state
- Update threshold checking functions to accept and use snapshot data
- Add invariant: "Organization parameters used for proposal evaluation must match parameters at proposal creation time"

**Test Cases**:
- Verify proposals use snapshot thresholds, not current thresholds
- Verify removed members' votes still count if cast while they were members
- Verify threshold changes don't affect in-flight proposals
- Test concurrent proposal modification scenarios

### Proof of Concept

**Initial State**:
- Organization with 5 members: M1, M2, M3, M4, M5
- Thresholds: MinimalApprovalThreshold=3, MinimalVoteThreshold=3

**Exploit Sequence**:

1. **T0 - Create Proposal A**: M1 creates a proposal to execute action X
2. **T1 - Vote on Proposal A**: M1, M2, M3 approve (3 approvals, meets threshold)
3. **T2 - Create Proposal B**: M4 creates a proposal calling `ChangeOrganizationThreshold` to set MinimalApprovalThreshold=4
4. **T3 - Vote and Release Proposal B**: M1, M2, M3 approve Proposal B; M4 releases it
5. **T4 - Organization State Modified**: Threshold is now 4
6. **T5 - Attempt to Release Proposal A**: M1 calls `Release(proposalA)`

**Expected Result**: Proposal A should be released (had 3 votes when threshold was 3)

**Actual Result**: Release fails with "Not approved." assertion because:
- `IsReleaseThresholdReached` fetches current organization with threshold=4
- `CheckEnoughVoteAndApprovals` checks: 3 >= 4 â†’ false
- Proposal cannot be released despite meeting original threshold

**Success Condition**: The attacker successfully blocks Proposal A by manipulating organization parameters after votes were cast but before release, demonstrating retroactive governance manipulation.

### Citations

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-280)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }

    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }

    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-59)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }

    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** protobuf/acs3.proto (L42-46)
```text
    // Change the thresholds associated with proposals.
    // All fields will be overwritten by the input value and this will affect all current proposals of the organization. 
    // Note: only the organization can execute this through a proposal.
    rpc ChangeOrganizationThreshold(ProposalReleaseThreshold)returns(google.protobuf.Empty) {
    }
```
