### Title
Missing Threshold Sum Validation Allows Creation of Unreleasable Referendum Organizations

### Summary
The Referendum contract's `Validate(Organization)` function fails to validate that the sum of `MinimalApprovalThreshold`, `MaximalRejectionThreshold`, and `MaximalAbstentionThreshold` is greater than or equal to `MinimalVoteThreshold`. This allows creation of organizations where proposals can mathematically never reach the release threshold, causing permanent governance deadlock. Both Association and Parliament contracts have this validation, but Referendum omits it.

### Finding Description

The Referendum contract's validation function [1](#0-0)  only checks that `MinimalApprovalThreshold <= MinimalVoteThreshold` and that individual thresholds are non-negative, but does not validate the sum relationship.

The proposal release logic [2](#0-1)  requires ALL of these conditions:
1. Total votes (Approval + Rejection + Abstention) >= `MinimalVoteThreshold`
2. `RejectionCount` <= `MaximalRejectionThreshold`
3. `AbstentionCount` <= `MaximalAbstentionThreshold`  
4. `ApprovalCount` >= `MinimalApprovalThreshold`

If the maximum valid vote combination (at the threshold limits) totals less than `MinimalVoteThreshold`, no proposal can ever pass.

In contrast, both Association [3](#0-2)  and Parliament [4](#0-3)  contracts include additional checks preventing this mathematical impossibility.

The validation is called during organization creation [5](#0-4)  and threshold changes [6](#0-5) , both accepting the invalid configuration.

Existing tests [7](#0-6)  validate individual threshold constraints but do not test this sum relationship.

### Impact Explanation

**Governance Deadlock**: Any organization created with inconsistent thresholds becomes permanently unable to execute proposals, as demonstrated by the release method [8](#0-7)  which will always fail the threshold check.

**Permanent Lock**: Funds or permissions controlled by such organizations become irretrievable. Since `ChangeOrganizationThreshold` itself requires a passing proposal, the deadlock cannot be fixed.

**Affected Parties**: 
- Organization creators who misconfigure thresholds
- Token holders who lock tokens for voting (via Approve/Reject/Abstain methods [9](#0-8) )
- Any contracts/assets controlled by the organization

**Severity Justification**: Medium - causes operational DoS of governance but requires configuration error or malicious setup (not directly exploitable against existing organizations).

### Likelihood Explanation

**Reachable Entry Points**: `CreateOrganization` and `CreateOrganizationBySystemContract` [10](#0-9)  are public methods.

**Feasible Preconditions**: 
- No special privileges required to create organizations
- Simple arithmetic misconfiguration is realistic (e.g., setting `MinimalVoteThreshold=1000`, `MinimalApprovalThreshold=500`, `MaximalRejectionThreshold=200`, `MaximalAbstentionThreshold=200`)

**Execution Practicality**: Single transaction creates the broken organization. No complex state manipulation needed.

**Detection Constraints**: Users may not realize the configuration is impossible until after attempting to pass proposals and locking tokens.

### Recommendation

Add validation to the `Validate(Organization)` function ensuring the sum constraint:

```csharp
return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
       proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
       proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
       proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
       proposalReleaseThreshold.MinimalApprovalThreshold + 
       proposalReleaseThreshold.MaximalRejectionThreshold + 
       proposalReleaseThreshold.MaximalAbstentionThreshold >= proposalReleaseThreshold.MinimalVoteThreshold;
```

Add regression test case validating this constraint is enforced during organization creation and threshold changes.

### Proof of Concept

**Initial State**: Deploy Referendum contract with standard configuration.

**Transaction Steps**:
1. Call `CreateOrganization` with:
   - `MinimalVoteThreshold = 1000`
   - `MinimalApprovalThreshold = 500`  
   - `MaximalRejectionThreshold = 200`
   - `MaximalAbstentionThreshold = 200`
   - Valid token symbol and proposer whitelist

2. Create proposal for the organization

3. Attempt to vote with maximum valid amounts:
   - 500 tokens approval (meets minimum)
   - 200 tokens rejection (at maximum)
   - 200 tokens abstention (at maximum)
   - Total = 900 tokens

**Expected Result**: Organization creation should fail validation.

**Actual Result**: Organization is created successfully. Proposal can never reach 1000 total votes while satisfying all constraints, causing permanent deadlock as verified by `IsReleaseThresholdReached` returning false indefinitely.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-80)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L146-154)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-51)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }

    public override Address CreateOrganizationBySystemContract(CreateOrganizationBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
        var organizationAddress = CreateOrganization(input.OrganizationCreationInput);
        if (!string.IsNullOrEmpty(input.OrganizationAddressFeedbackMethod))
            Context.SendInline(Context.Sender, input.OrganizationAddressFeedbackMethod, organizationAddress);

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-113)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.RejectionCount = proposal.RejectionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Reject);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.AbstentionCount = proposal.AbstentionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Abstain);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L1126-1177)
```csharp
    [Fact]
    public async Task CreateOrganization_With_Invalid_Input_Test()
    {
        // token symbol is null or empty
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.TokenSymbol = string.Empty;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        // no proposer in proposeWhiteList
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposerWhiteList.Proposers.Clear();
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MinimalApprovalThreshold > MinimalVoteThreshold
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MinimalApprovalThreshold =
                validInput.ProposalReleaseThreshold.MinimalVoteThreshold + 1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MinimalApprovalThreshold == 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 0;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MaximalAbstentionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }

        //MaximalRejectionThreshold < 0
        {
            var validInput = GetValidCreateOrganizationInput();
            validInput.ProposalReleaseThreshold.MaximalRejectionThreshold = -1;
            var ret = await ReferendumContractStub.CreateOrganization.SendWithExceptionAsync(validInput);
            ret.TransactionResult.Error.ShouldContain("Invalid organization data");
        }
    }
```
