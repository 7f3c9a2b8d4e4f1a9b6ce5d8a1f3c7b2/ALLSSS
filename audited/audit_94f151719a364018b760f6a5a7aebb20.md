# Audit Report

## Title
Threshold Mismatch in Secret Sharing Reconstruction on Side Chains Leads to Consensus State Corruption

## Summary
The `RevealSharedInValues` function in the AEDPoS consensus contract incorrectly calculates the Shamir secret sharing threshold using the current round's miner count instead of the previous round's miner count. When side chains update their miner list from the main chain, this causes a threshold mismatch between secret encoding and decoding, resulting in incorrect secret reconstruction and corrupted consensus state.

## Finding Description

The vulnerability exists in the `RevealSharedInValues` function where the threshold calculation uses the wrong round's miner count. [1](#0-0) 

The function calculates `minimumCount` from `currentRound.RealTimeMinersInformation.Count`, but the secrets being decoded were originally encoded in the previous round. The function then iterates through `previousRound.RealTimeMinersInformation` and attempts to decode those secrets using the current round's threshold: [2](#0-1) 

This contrasts with the correct implementation in `SecretSharingService`, which uses the same round's miner count for both encoding and decoding: [3](#0-2) [4](#0-3) 

**Exploitation Path on Side Chains:**

Side chains update their miner list from the main chain via cross-chain updates: [5](#0-4) 

When the main chain miner list changes, the side chain's round generation detects this and creates a new round with the updated miner count: [6](#0-5) 

Subsequently, when `RevealSharedInValues` is called during extra block generation: [7](#0-6) 

The function attempts to decode secrets from a round with N miners using a threshold calculated from a round with M miners (where M ≠ N), violating the fundamental requirement of Shamir's secret sharing.

## Impact Explanation

**Consensus State Corruption:**

Shamir's secret sharing requires the same threshold for encoding and decoding. The implementation uses Lagrange interpolation for reconstruction: [8](#0-7) 

When the threshold parameter doesn't match the encoding threshold, the Lagrange interpolation reconstructs an incorrect secret value. This incorrectly decoded value is then stored as `PreviousInValue` in the consensus state: [9](#0-8) 

These corrupted `PreviousInValue` entries pollute the consensus state. The `PreviousInValue` is used in signature calculations for randomness: [10](#0-9) 

This breaks the consensus randomness invariant, as the revealed values no longer correspond to the actual in values used by miners, compromising the integrity of the secret sharing mechanism used for consensus security.

**Who is Affected:**

All side chains in the AElf ecosystem are vulnerable whenever the main chain undergoes a miner list update, which is a regular occurrence in the consensus protocol.

## Likelihood Explanation

**High Likelihood - Occurs Automatically:**

This vulnerability triggers automatically during normal consensus operations:

1. **Reachable Entry Point:** The vulnerability is in the consensus flow executed during extra block production via `GetConsensusExtraData`

2. **Feasible Preconditions:**
   - Side chain is running (standard configuration)
   - Main chain undergoes a miner list update (regular occurrence)
   - Side chain syncs the new miner list via `UpdateInformationFromCrossChain`
   
3. **Execution Practicality:** The bug triggers during the first round after the side chain adopts a new miner count from the main chain. No special conditions or attacker involvement required.

## Recommendation

Fix the threshold calculation in `RevealSharedInValues` to use the previous round's miner count:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");

    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

    // FIX: Use previousRound's miner count instead of currentRound's
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;

    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... rest of the function
    }
}
```

Additionally, fix the validation check on line 36 to use the same `minersCount` variable that's now correctly sourced from `previousRound`.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Set up a side chain with N miners
2. Trigger a cross-chain update with M miners (where M ≠ N)
3. Generate the next round with the extra block producer
4. Verify that `RevealSharedInValues` uses the wrong threshold
5. Confirm that the decoded `PreviousInValue` is incorrect by comparing it to the expected value

The test would show that when secret shares encoded with threshold N*2/3 are decoded with threshold M*2/3 (where N ≠ M), the reconstructed secret is incorrect, proving the state corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-50)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L147-149)
```csharp
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L55-61)
```csharp
        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
