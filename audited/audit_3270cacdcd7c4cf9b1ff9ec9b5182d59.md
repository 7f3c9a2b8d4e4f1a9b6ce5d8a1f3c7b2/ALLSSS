### Title
Miner Order Manipulation via Brute-Force InValue Selection

### Summary
Miners can manipulate their position in future consensus rounds by brute-forcing InValue candidates offline and selecting values that produce favorable signature-derived orders. The system lacks validation that InValue was generated using the intended cryptographic method, allowing miners to use arbitrary hash values that optimize their mining schedule.

### Finding Description

The vulnerability exists in the consensus order calculation mechanism across three key components:

**Order Calculation Location:** [1](#0-0) 

The `supposedOrderOfNextRound` is determined by converting the signature to an integer and taking its modulus with the miner count. This signature value directly controls mining position.

**Signature Calculation:** [2](#0-1) 

The signature is computed using `previousRound.CalculateSignature(triggerInformation.PreviousInValue)`, which XORs the PreviousInValue with all signatures from the previous round: [3](#0-2) 

**Insufficient Validation:** [4](#0-3) 

The only validation checks that `Hash(PreviousInValue) == previousOutValue`. There is no verification that the InValue was generated using the intended method.

**Intended Generation Method (Not Enforced):** [5](#0-4) 

InValue SHOULD be generated by signing round information, making it deterministic and non-manipulable. However, this is not validated on-chain.

**Root Cause:**
When a miner produces a block in round N-1, they must commit to InValue_(N-1) by publishing OutValue_(N-1) = Hash(InValue_(N-1)). This InValue will later be used in round N to calculate their signature, which determines their order in round N+1. Since there is no validation that InValue was properly generated, miners can:

1. Try thousands of random hash values as candidate InValues offline
2. For each candidate, compute what their signature would be by XORing it with known signatures from round N-2
3. Calculate the resulting order in round N+1 using `GetAbsModulus`
4. Select the InValue that gives the most favorable position (e.g., position 1 for earliest mining)
5. Commit to it by publishing its hash as OutValue
6. Later reveal it, passing validation since `Hash(chosen_InValue) == OutValue`

### Impact Explanation

**Consensus Integrity Violation:**
Miners can manipulate the deterministic mining order that is supposed to be unpredictable. This breaks a fundamental security assumption of the AEDPoS consensus mechanism.

**Concrete Harms:**
- **Unfair Advantage**: Manipulating miners can consistently secure position 1 (first to mine in each round), giving them priority for transaction fees and MEV opportunities
- **Centralization Risk**: Miners who exploit this gain cumulative advantages over honest miners, creating pressure for all miners to adopt the manipulation or become uncompetitive
- **Cross-Round Attacks**: Attackers can optimize to mine consecutively across round boundaries, enabling sophisticated attacks like selfish mining or chain reorganization attempts
- **Reward Manipulation**: Mining order affects reward distribution and the ability to produce extra blocks, allowing attackers to maximize their share

**Affected Parties:**
- All honest miners face reduced rewards and mining opportunities
- The network's security decentralization is compromised
- Users face reduced transaction finality guarantees

**Severity Justification:**
This is HIGH severity because it directly violates the "Correct round transitions and time-slot validation, miner schedule integrity" invariant specified in the audit requirements. The consensus mechanism's fairness and unpredictability are fundamental security properties.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the consensus set
- Requires only standard computational resources (modern CPU can try millions of hash values per second)
- No special privileges beyond being a registered miner

**Attack Complexity:**
- **Simple Execution**: Generate random hashes, compute XOR with known signatures, calculate modulus, select best
- **No On-Chain Traces**: All brute-forcing happens offline; on-chain behavior appears legitimate
- **Repeatable**: Can be executed every round indefinitely
- **Partial Information Sufficient**: Even without knowing all future signatures in the round, miners can significantly bias outcomes

**Feasibility Conditions:**
- Attack works best when miner produces blocks late in a round (more signatures known)
- Extra block producer (last in round) has perfect information for manipulation
- Even early miners can bias outcomes by trying multiple candidates
- No capital cost beyond normal mining operations

**Detection Constraints:**
- No mechanism exists to detect if InValue was properly generated
- Malicious InValues are indistinguishable from legitimate ones on-chain
- Success appears as "lucky" order assignments

**Probability Assessment:**
**Very High** - Once discovered, rational miners will adopt this strategy as it provides direct economic benefits with zero downside risk. The lack of validation makes exploitation trivial.

### Recommendation

**Primary Mitigation - Bind InValue to VRF:**
Integrate InValue generation with the existing VRF (Verifiable Random Function) mechanism. Currently, VRF is used separately for random hashes: [6](#0-5) 

Modify the system to:
1. Require InValue to be derived from or bound to the VRF proof
2. Validate on-chain that InValue has the correct relationship to the VRF proof
3. This makes InValue verifiable and non-manipulable

**Alternative Mitigation - Signature Verification:**
Add validation that InValue was generated by signing specific round data:

```
// In UpdateValueValidationProvider.ValidateHeaderInformation()
// Add check that InValue = Hash(Sign(Hash(roundInfo with pubkey)))
// Verify signature using miner's public key
```

**Additional Invariant Check:**
In `ApplyNormalConsensusData`, add:
```
// Verify no single miner controls >X% of position 1 assignments over last Y rounds
// This provides detection even if generation isn't fully constrained
```

**Test Cases:**
1. Test that modified InValue generation still produces deterministic values per miner per round
2. Test that arbitrary InValues are rejected during validation
3. Test that attempting to manipulate order via InValue selection fails
4. Simulate multi-round scenarios to verify fairness of position distribution

### Proof of Concept

**Initial State:**
- Blockchain at round N-2, all miners have produced blocks
- Attacker is miner M with position P in round N-1
- Round N-2 signatures are on-chain and known

**Attack Sequence:**

**Step 1 (Offline):** Before producing block in round N-1:
```
for i = 1 to 1,000,000:
    candidate_InValue = RandomHash()
    // Compute what signature would be in round N
    accumulated_sigs = XOR of known signatures from round N-2
    future_signature = XOR(candidate_InValue, accumulated_sigs)
    future_order = GetAbsModulus(future_signature.ToInt64(), minersCount) + 1
    
    if future_order == 1:  // Desired position
        chosen_InValue = candidate_InValue
        break
```

**Step 2 (Round N-1):** Produce block with:
- InValue_(N-1) = chosen_InValue
- OutValue_(N-1) = Hash(chosen_InValue)

Validation passes per `ValidatePreviousInValue` logic.

**Step 3 (Round N):** Produce block with:
- PreviousInValue_(N-1) = chosen_InValue
- Validation: `Hash(chosen_InValue) == OutValue_(N-1)` âœ“ passes

**Step 4 (Result):** 
- Signature_N calculated with chosen_InValue
- Order in round N+1 = `GetAbsModulus(Signature_N.ToInt64(), minersCount) + 1` = 1

**Expected vs Actual:**
- Expected: Order should be unpredictable, derived from cryptographically committed random values
- Actual: Attacker consistently gets position 1 (or other desired position)

**Success Condition:**
Attacker achieves position 1 in round N+1 with >50% probability across multiple rounds (versus expected ~1/minersCount probability of ~7-11% for typical miner sets), demonstrating manipulation capability.

### Notes

The VRF system exists separately for block-level randomness but does not constrain InValue selection. The InValue/OutValue/Signature mechanism was designed as a commitment-reveal scheme with secret sharing for Byzantine fault tolerance, but the lack of generation method verification undermines its security properties. The attack is most effective for miners producing later in rounds but remains viable even with partial information due to the ability to bias outcomes through repeated trials.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```
