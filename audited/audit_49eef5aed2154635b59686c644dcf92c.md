# Audit Report

## Title
Inconsistent Profit Detail Matching Logic Enables Wrong Profit Detail Extension for Votes with Identical Weight

## Summary
The Election contract's `GetProfitDetailByElectionVotingRecord()` and Profit contract's `FixProfitDetail()` use different fallback matching strategies (`LastOrDefault` vs `OrderBy().FirstOrDefault`) when dealing with legacy profit details where Id is null. This inconsistency allows attackers with multiple old votes of identical weight to extend the wrong profit detail, resurrecting expired votes and claiming unauthorized welfare profits.

## Finding Description

The vulnerability stems from an inconsistency in how two contracts match profit details when the ProfitDetailId field is null (legacy votes created before the Id feature was implemented).

**Root Cause - Inconsistent Matching Logic:**

In the Election contract, `GetProfitDetailByElectionVotingRecord()` uses `LastOrDefault` for fallback matching when Id-based lookup fails: [1](#0-0) 

However, the Profit contract's `FixProfitDetail()` uses `OrderBy(d => d.StartPeriod).FirstOrDefault` for the same fallback scenario: [2](#0-1) 

**Exploit Mechanism:**

When `ChangeVotingOption` is called with `IsResetVotingTime=true`, it triggers the `ExtendVoterWelfareProfits` flow: [3](#0-2) 

The vulnerability manifests when a voter has multiple legacy profit details with identical Shares (weight) values:
1. Line 140 calls `GetProfitDetailByElectionVotingRecord()` which returns the **last** matching profit detail
2. Line 141 validates that a profit detail exists
3. Line 144 calls `FixProfitDetail()` which operates on the **first** matching profit detail (ordered by StartPeriod)

These can be **different profit details**, allowing an attacker to:
- Check the existence of an active vote's profit detail (Vote B)
- Extend a different, expired vote's profit detail (Vote A)

**Vote Weight Determinism:**

Multiple votes can have identical weights because the calculation is deterministic based on amount and lock time: [4](#0-3) 

**Legacy Data Context:**

Current code sets ProfitDetailId for new votes: [5](#0-4) 

However, old votes created before this feature have Id=null in their profit details, making them vulnerable to the inconsistent matching logic.

## Impact Explanation

**Direct Financial Impact:**

An attacker who owns multiple old votes with identical weights can:
1. **Resurrect Expired Votes**: Extend the EndPeriod of an already-expired profit detail by pretending to extend a different active vote
2. **Steal Protocol Funds**: Continue claiming welfare profits beyond the legitimate period
3. **Dilute Legitimate Rewards**: The attacker's extended shares remain in the welfare scheme, reducing profits for all other beneficiaries

**Affected Parties:**
- All welfare scheme beneficiaries receive reduced profit shares
- Protocol integrity is compromised as time-based reward limits are bypassed

**Severity: HIGH**
- Enables direct theft of protocol funds through unauthorized profit claiming
- Requires only vote ownership (no special privileges)
- Legacy data with Id=null exists in production systems
- Impact scales with vote amounts and number of exploitable combinations

## Likelihood Explanation

**Attacker Capabilities:**
- Requires owning multiple votes with identical weights (same amount + lock time)
- Can intentionally create such votes by voting with identical parameters
- No special permissions needed - only calls public `ChangeVotingOption` method [6](#0-5) 

**Attack Complexity:**
- **Low**: Simple transaction call with normal parameters
- **Precondition**: Legacy profit details with Id=null exist for votes created before the ProfitDetailId feature
- **Execution**: All steps executable through standard contract calls

**Probability:**
- **High** for legacy systems: All systems with votes predating the Id feature are vulnerable
- **Moderate** for new systems: Attackers can intentionally create multiple votes with identical weights
- **Detection Difficulty**: The attack appears as a legitimate vote change operation

## Recommendation

Unify the fallback matching logic between both contracts. The recommended fix is to use consistent ordering in both methods:

**Option 1 - Use FirstOrDefault in both contracts:**
```csharp
// In GetProfitDetailByElectionVotingRecord
if (profitDetail == null)
{
    profitDetail = profitDetails.Details
        .OrderBy(d => d.StartPeriod)
        .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
}
```

**Option 2 - Use LastOrDefault in both contracts:**
```csharp
// In FixProfitDetail
if (fixingDetail == null)
{
    fixingDetail = profitDetails.Details
        .LastOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
}
```

**Option 3 - Add validation (recommended):**
Store and validate the actual profit detail that was found during the existence check:
```csharp
// In ExtendVoterWelfareProfits, pass the found detail to FixProfitDetail
var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
if (extendingDetail != null)
{
    // Pass extendingDetail.StartPeriod as additional validation parameter
    State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
    {
        // ... existing fields ...
        StartPeriod = extendingDetail.StartPeriod // Add validation
    });
}
```

## Proof of Concept

```csharp
[Fact]
public async Task InconsistentProfitDetailMatching_AllowsWrongDetailExtension()
{
    // Setup: Create candidate
    await AnnounceElectionAsync(CoreDataCenterKeyPairs[0]);
    
    // Create Vote A with 100 tokens for 50 days (will create earlier, lower StartPeriod)
    var voteIdA = await VoteToCandidateAsync(VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 
        50 * 86400, 
        100_00000000);
    
    // Advance time to create Vote B at a later period
    await ProduceBlocks(BootMinerKeyPair, 100);
    await NextTerm(BootMinerKeyPair);
    
    // Create Vote B with same 100 tokens for 50 days (same weight, higher StartPeriod)
    var voteIdB = await VoteToCandidateAsync(VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 
        50 * 86400, 
        100_00000000);
    
    // Get initial profit details - both should have same Shares
    var profitDetailsBefore = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    profitDetailsBefore.Details.Count.ShouldBe(2);
    
    var detailA = profitDetailsBefore.Details
        .OrderBy(d => d.StartPeriod).First();
    var detailB = profitDetailsBefore.Details
        .OrderBy(d => d.StartPeriod).Last();
    
    detailA.Shares.ShouldBe(detailB.Shares); // Same weight
    detailA.StartPeriod.ShouldBeLessThan(detailB.StartPeriod); // A created first
    
    // Advance time until Vote A expires but Vote B is still active
    while (await GetCurrentPeriod() <= detailA.EndPeriod)
    {
        await ProduceBlocks(BootMinerKeyPair, 10);
        await NextTerm(BootMinerKeyPair);
    }
    
    var currentPeriod = await GetCurrentPeriod();
    currentPeriod.ShouldBeGreaterThan(detailA.EndPeriod); // Vote A expired
    currentPeriod.ShouldBeLessThanOrEqualTo(detailB.EndPeriod); // Vote B active
    
    // Attack: Change voting option on Vote B with IsResetVotingTime=true
    await ChangeVotingOption(VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[1].PublicKey.ToHex(), 
        voteIdB, 
        true); // IsResetVotingTime=true
    
    // Get profit details after attack
    var profitDetailsAfter = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    
    var detailAAfter = profitDetailsAfter.Details
        .OrderBy(d => d.StartPeriod).First();
    var detailBAfter = profitDetailsAfter.Details
        .OrderBy(d => d.StartPeriod).Last();
    
    // Vulnerability: Vote A's EndPeriod was extended instead of Vote B's
    // GetProfitDetailByElectionVotingRecord used LastOrDefault -> found Vote B
    // FixProfitDetail used OrderBy().FirstOrDefault -> extended Vote A
    detailAAfter.EndPeriod.ShouldBeGreaterThan(detailA.EndPeriod); // Vote A extended!
    detailBAfter.EndPeriod.ShouldBe(detailB.EndPeriod); // Vote B unchanged
    
    // Impact: Expired vote A is now active, allowing unauthorized profit claims
    detailAAfter.EndPeriod.ShouldBeGreaterThan(currentPeriod); // A is now active
}
```

## Notes

This vulnerability specifically affects legacy votes where profit details have `Id=null`. While new votes created after the ProfitDetailId feature have proper Id tracking, production systems likely contain legacy votes that remain vulnerable. The deterministic nature of vote weight calculation means attackers can intentionally create exploitable scenarios by voting with identical parameters.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-124)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }

        // Withdraw old votes
        State.VoteContract.Withdraw.Send(new WithdrawInput
        {
            VoteId = input.VoteId
        });

        // Create new votes
        State.VoteContract.Vote.Send(new VoteInput
        {
            VoteId = input.VoteId,
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Amount = votingRecord.Amount,
            Voter = votingRecord.Voter,
            Option = input.CandidatePubkey,
            IsChangeTarget = true
        });

        // Update related candidate
        var oldVoteOptionPublicKey = GetNewestPubkey(votingRecord.Option);
        var oldCandidateVotes = State.CandidateVotes[oldVoteOptionPublicKey];
        oldCandidateVotes.ObtainedActiveVotingRecordIds.Remove(input.VoteId);
        oldCandidateVotes.ObtainedActiveVotedVotesAmount =
            oldCandidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        oldCandidateVotes.AllObtainedVotedVotesAmount =
            oldCandidateVotes.AllObtainedVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[oldVoteOptionPublicKey] = oldCandidateVotes;

        long voteAmountOfNewCandidate;
        var newCandidateVotes = State.CandidateVotes[input.CandidatePubkey];
        if (newCandidateVotes != null)
        {
            newCandidateVotes.ObtainedActiveVotingRecordIds.Add(input.VoteId);
            newCandidateVotes.ObtainedActiveVotedVotesAmount =
                newCandidateVotes.ObtainedActiveVotedVotesAmount.Add(votingRecord.Amount);
            newCandidateVotes.AllObtainedVotedVotesAmount =
                newCandidateVotes.AllObtainedVotedVotesAmount.Add(votingRecord.Amount);
            State.CandidateVotes[input.CandidatePubkey] = newCandidateVotes;
            voteAmountOfNewCandidate = newCandidateVotes.ObtainedActiveVotedVotesAmount;
        }
        else
        {
            State.CandidateVotes[input.CandidatePubkey] = new CandidateVote
            {
                Pubkey = ByteStringHelper.FromHexString(input.CandidatePubkey),
                ObtainedActiveVotingRecordIds = { input.VoteId },
                ObtainedActiveVotedVotesAmount = votingRecord.Amount,
                AllObtainedVotedVotesAmount = votingRecord.Amount
            };
            voteAmountOfNewCandidate = votingRecord.Amount;
        }

        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            dataCenterList.DataCenters[input.CandidatePubkey] =
                dataCenterList.DataCenters[input.CandidatePubkey].Add(votingRecord.Amount);
        }
        else if (dataCenterList.DataCenters.Count < GetValidationDataCenterCount())
        {
            // add data center
            dataCenterList.DataCenters.Add(input.CandidatePubkey,
                State.CandidateVotes[input.CandidatePubkey].ObtainedActiveVotedVotesAmount);

            AddBeneficiary(input.CandidatePubkey);
        }
        else
        {
            CandidateReplaceMemberInDataCenter(dataCenterList, input.CandidatePubkey, voteAmountOfNewCandidate);
        }

        if (dataCenterList.DataCenters.ContainsKey(oldVoteOptionPublicKey))
        {
            dataCenterList.DataCenters[oldVoteOptionPublicKey] =
                dataCenterList.DataCenters[oldVoteOptionPublicKey].Sub(votingRecord.Amount);
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, oldVoteOptionPublicKey);
        }

        State.DataCentersRankingList.Value = dataCenterList;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```
