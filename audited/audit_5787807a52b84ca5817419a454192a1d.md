### Title
Non-Member Proposers Can Create Unreleased Proposals, Causing Governance Release Deadlock

### Summary
The Association contract allows `ProposerWhiteList` to contain addresses that are not in `OrganizationMemberList`. Non-member proposers can create proposals that members can vote on and approve, but only the original proposer can release the proposal. If a non-member proposer becomes unavailable or refuses to release an approved proposal, it creates a permanent governance deadlock where critical approved actions cannot be executed.

### Finding Description

The vulnerability exists in the organization creation validation logic. The `Validate()` method checks that both `ProposerWhiteList` and `OrganizationMemberList` are non-empty and contain no duplicates, but it does NOT verify that proposer addresses must also be organization members. [1](#0-0) 

During organization creation, this insufficient validation is called: [2](#0-1) 

When creating a proposal, the contract only verifies that the sender is in the `ProposerWhiteList`: [3](#0-2) 

Members can vote on any proposal (Approve/Reject/Abstain), regardless of who created it, by verifying membership: [4](#0-3) [5](#0-4) 

However, the critical issue is in the `Release()` function, which enforces that ONLY the original proposer can release a proposal: [6](#0-5) 

**Attack Path:**
1. Organization is created with ProposerWhiteList = {AddressX} and OrganizationMemberList = {AddressA, AddressB, AddressC}
2. AddressX (non-member) creates a proposal for critical governance action
3. Members (AddressA, AddressB, AddressC) vote and approve the proposal, meeting the release threshold
4. AddressX is unavailable, uncooperative, or malicious and refuses to call `Release()`
5. The approved proposal can never be executed, causing governance deadlock

### Impact Explanation

**Operational Impact - Governance DoS:**
- Critical approved governance actions cannot be executed if the non-member proposer is unavailable
- Members lose effective control over their organization despite having voting power
- Time-sensitive proposals may expire before the proposer returns
- Malicious proposers can hold organizations hostage by creating but never releasing approved proposals

**Severity: HIGH**
- Breaks the fundamental governance invariant that approved proposals should be executable by the organization
- Affects all organizations that include non-members in their proposer whitelist
- Can permanently block critical operations like threshold changes, member management, or fund transfers
- No recovery mechanism exists for the organization to bypass an uncooperative proposer

### Likelihood Explanation

**Reachable Entry Point:** The `CreateOrganization()` method is publicly accessible and the validation explicitly allows this configuration.

**Feasible Preconditions:**
- Attacker needs to be added to ProposerWhiteList during organization creation
- Can occur accidentally through misconfiguration or intentionally by a malicious setup
- No special privileges required beyond being included in the whitelist

**Execution Practicality:**
- Simple to execute: create organization with non-member proposers, create proposal, refuse to release
- No complex state manipulation required
- Works with normal contract semantics

**Economic Rationality:**
- Near-zero cost to exploit
- High impact on organization operations
- Can be used for extortion (demanding payment to release proposals)

**Probability: HIGH** - The validation code explicitly permits this configuration, making it trivially exploitable either through malice or accident.

### Recommendation

**1. Add validation to ensure proposers are members:**

Modify the `Validate()` method in `Association_Helper.cs` to add this check:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    
    // NEW: Verify all proposers are organization members
    foreach (var proposer in organization.ProposerWhiteList.Proposers)
    {
        if (!organization.OrganizationMemberList.Contains(proposer))
            return false;
    }
    
    // ... rest of validation
}
```

**2. Enforce the invariant during whitelist changes:**

The same validation must be applied in `ChangeOrganizationProposerWhiteList()`: [7](#0-6) 

And when removing members via `RemoveMember()`: [8](#0-7) 

**3. Add test cases:**
- Test that creating an organization with non-member proposers fails validation
- Test that changing the whitelist to include non-members fails
- Test that removing a member who is in the proposer whitelist fails

### Proof of Concept

**Initial State:**
- Accounts: ProposerX, MemberA, MemberB, MemberC

**Step 1 - Create Organization with Non-Member Proposer:**
```
CreateOrganizationInput {
    OrganizationMemberList: [MemberA, MemberB, MemberC],
    ProposerWhiteList: [ProposerX],  // ProposerX is NOT a member
    ProposalReleaseThreshold: {
        MinimalApprovalThreshold: 2,
        MinimalVoteThreshold: 2
    }
}
```
**Result:** Organization created successfully (should fail but doesn't)

**Step 2 - ProposerX Creates Proposal:**
```
CreateProposal(organizationAddress) from ProposerX
```
**Result:** Proposal created successfully

**Step 3 - Members Vote and Approve:**
```
Approve(proposalId) from MemberA
Approve(proposalId) from MemberB
```
**Result:** Proposal reaches approval threshold (2/3 members approved)

**Step 4 - Members Attempt to Release:**
```
Release(proposalId) from MemberA
```
**Expected:** Proposal executes
**Actual:** Transaction fails with "No permission." error because only ProposerX can release

**Step 5 - ProposerX Refuses to Release:**
ProposerX never calls `Release()` or is unavailable

**Success Condition:** The approved proposal remains unreleased indefinitely, demonstrating the governance deadlock. Members have no mechanism to execute their approved decision without the non-member proposer's cooperation.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-67)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
