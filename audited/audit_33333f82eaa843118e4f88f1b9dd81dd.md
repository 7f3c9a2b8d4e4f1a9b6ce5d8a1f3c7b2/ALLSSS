# Audit Report

## Title
Scheme Manager Can Retroactively Increase MinimumLockMinutes to Prevent User Withdrawals

## Summary
The TokenHolder contract's `CreateScheme` function allows a scheme manager to call it multiple times, unconditionally overwriting the stored `TokenHolderProfitScheme` parameters including `MinimumLockMinutes`. Since user lock timestamps persist from the original registration but withdrawals validate against the current scheme's `MinimumLockMinutes`, a malicious manager can retroactively trap user funds indefinitely.

## Finding Description

The vulnerability exists because `CreateScheme` has no validation to prevent multiple invocations by the same manager. [1](#0-0) 

The function unconditionally overwrites `State.TokenHolderProfitSchemes[Context.Sender]` each time it's called, storing new parameters including `MinimumLockMinutes`. [2](#0-1) 

When users register for profits, their lock timestamp is recorded in separate state storage. [3](#0-2) 

During withdrawal, the function retrieves the current scheme and validates the lock duration against the stored timestamp. [4](#0-3) 

The root cause is the architectural mismatch: lock timestamps persist across scheme recreations, but the withdrawal validation uses the CURRENT scheme's `MinimumLockMinutes` against the ORIGINAL timestamp from registration.

The Profit contract enables this by using count-based scheme ID generation, creating a new scheme with a different ID for each call. [5](#0-4) 

The Profit contract's "Already exists" check only prevents duplicate scheme IDs, not multiple schemes by the same manager. [6](#0-5) 

**Attack Scenario:**
1. Manager creates scheme with `MinimumLockMinutes = 1` 
2. Users register and lock tokens, expecting 1-minute lock period
3. Manager calls `CreateScheme` again with `MinimumLockMinutes = 100000000` (190 years)
4. The new scheme overwrites the stored parameters
5. Users' lock timestamps remain unchanged
6. When users attempt withdrawal after 1 minute, the check compares their timestamp against the new 100,000,000-minute requirement and fails
7. Users' funds are trapped indefinitely

## Impact Explanation

**Direct Fund Impact**: Users' locked tokens become permanently inaccessible. A user who locks 10,000 ELF expecting a 1-minute lock period can have their funds frozen for decades if the manager sets `MinimumLockMinutes = 100000000` (approximately 190 years).

**No Recovery Path**: The only mechanism to unlock tokens is the `Withdraw` function, which will always fail its time validation check if `MinimumLockMinutes` is set sufficiently high. Users have no alternative method to recover their funds.

**Affected Parties**: 
- All users who registered for profits in the scheme before the parameter change
- Any smart contracts using TokenHolder for staking mechanisms
- Participants in profit-sharing schemes across the entire AElf ecosystem

**Severity Justification**: HIGH - This vulnerability enables complete theft or indefinite freezing of user funds. Unlike governance-based attacks that require consensus, this can be executed unilaterally by any scheme manager with a single transaction. The attack is silent (no events emitted for parameter changes) and users only discover the issue when attempting withdrawal, by which point their funds are already trapped.

## Likelihood Explanation

**Attacker Capabilities**: Any address that calls `CreateScheme` becomes a scheme manager. There is no special permission or stake requirement, making the barrier to becoming an attacker extremely low.

**Attack Complexity**: Trivial - requires only a single `CreateScheme` transaction with a modified `MinimumLockMinutes` parameter. No complex transaction sequencing or timing requirements.

**Feasibility Conditions**:
- Attacker must have created a scheme (anyone can do this)
- Users must have registered for profits (normal protocol operation)
- No timing constraints or coordination needed

**Detection Constraints**: The attack is completely silent. No events are emitted when scheme parameters change, and the contract state only reflects the current scheme. Users cannot detect the change until they attempt withdrawal and encounter an unexpected error.

**Economic Rationality**: Extremely favorable for malicious actors. The gas cost of one `CreateScheme` transaction can trap millions of dollars worth of user funds. This can be weaponized for rug pulls by advertising attractive short lock periods to attract deposits, then changing parameters to trap funds.

**Probability Assessment**: HIGH - The vulnerability is trivial to exploit, economically rational for attackers, has no detection mechanism, and can affect any TokenHolder scheme across the ecosystem.

## Recommendation

Add validation in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add check to prevent recreating schemes
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Alternatively, if scheme parameter updates are intended functionality, add a separate `UpdateScheme` method with proper safeguards:
- Validate that `MinimumLockMinutes` can only decrease or remain the same (never increase)
- Emit events when parameters change
- Implement a timelock before parameter changes take effect
- Store the original lock period with each user's registration

## Proof of Concept

```csharp
[Fact]
public async Task SchemeManager_CanTrapUserFunds_ByRecreatingScheme()
{
    // Setup: Manager creates initial scheme with 1 minute lock
    var manager = Accounts[1].Address;
    var user = Accounts[2].Address;
    
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // User registers with 10000 ELF expecting 1 minute lock
    await TokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = manager,
        Amount = 10000_00000000
    });
    
    var blockTime1 = BlockTimeProvider.GetBlockTime();
    
    // Wait 2 minutes - should be enough to withdraw
    BlockTimeProvider.SetBlockTime(blockTime1.AddMinutes(2));
    
    // Manager recreates scheme with 100000000 minute lock (190 years)
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 100000000
    });
    
    // User attempts withdrawal - should fail despite 2 minutes passing
    var result = await TokenHolderStub.Withdraw.SendWithExceptionAsync(manager);
    
    // Assert: Withdrawal fails with "Cannot withdraw" even though 
    // original lock period (1 minute) has passed
    result.TransactionResult.Error.ShouldContain("Cannot withdraw");
    
    // Funds are now trapped for ~190 years instead of the agreed 1 minute
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L166-167)
```csharp
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-228)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L59-60)
```csharp
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```
