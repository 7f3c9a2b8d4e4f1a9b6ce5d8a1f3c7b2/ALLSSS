### Title
Replacement Miners Unfairly Penalized in Reward Distribution Due to Missing IsReplacedEvilMiner Flag

### Summary
When evil miners are detected and replaced during consensus round generation, the Treasury contract's `RecordMinerReplacement` method is never called, causing the `IsReplacedEvilMiner` flag to remain unset for replacement miners. This results in replacement miners being subjected to the standard `CalculateShares()` formula that penalizes below-average block production, potentially giving them zero or heavily reduced reward shares despite their actual contribution.

### Finding Description
The vulnerability exists in the evil miner replacement flow spanning the Consensus and Treasury contracts:

**Root Cause Location 1 - Missing Treasury Notification:**
In the Consensus contract's `GenerateNextRoundInformation` method, when evil miners are detected via `GetMinerReplacementInformation`, the code updates the round information and fires events but never notifies the Treasury contract. [1](#0-0) 

The replacement happens in the consensus layer (lines 337-338 remove the evil miner and add the replacement), but no call to `TreasuryContract.RecordMinerReplacement` is made in this flow.

**Root Cause Location 2 - Only Call Site:**
The ONLY place where `RecordMinerReplacement` is called is in the `RecordCandidateReplacement` method, which handles voluntary pubkey changes initiated by the Election contract, NOT evil miner detection. [2](#0-1) 

This call (line 149) does not set the `IsOldPubkeyEvil` parameter, meaning it defaults to `false` in the protobuf message.

**Root Cause Location 3 - Flag Setting:**
The `IsReplacedEvilMiner` flag is set in the Treasury contract's `RecordMinerReplacement` method at line 596 for the new pubkey, regardless of the `IsOldPubkeyEvil` value. [3](#0-2) 

Since this method is never called during evil miner replacement, the flag remains unset.

**Impact Location - Reward Distribution:**
During reward distribution in `UpdateBasicMinerRewardWeights`, the absence of the `IsReplacedEvilMiner` flag causes replacement miners to be treated as regular miners. [4](#0-3) 

At line 802, if the flag is set, the miner receives shares equal to their actual `ProducedBlocks` (line 805). Without the flag, they go through `CalculateShares()` (line 811), which applies the penalty formula.

**The Penalty Formula:**
The `CalculateShares()` function penalizes miners with below-average block production: [5](#0-4) 

- Returns **0 shares** if blocks < average/2 (line 837-839)
- Returns blocks²/average if blocks < 4*average/5 (line 841-843)  
- Returns blocks only if blocks >= 4*average/5 (line 845)

Since replacement miners join mid-term and have fewer produced blocks, they are severely penalized by this formula despite not being at fault.

### Impact Explanation
**Concrete Financial Impact:**
Replacement miners who step in to replace evil miners (providing a critical service to maintain consensus) receive unfair reward distribution:

- **Zero rewards**: If a replacement miner joins late enough in the term that their produced blocks < average/2, they receive ZERO shares of the Basic Miner Reward pool
- **Quadratically reduced rewards**: If blocks < 4*average/5, they receive blocks²/average instead of blocks, which can be significantly less
- **Example**: If average is 1000 blocks and replacement miner produces 400 blocks (40% of term), they get 400²/1000 = 160 shares instead of 400 shares, losing 60% of their fair reward

**Who Is Affected:**
1. Replacement miners who provide critical consensus service
2. Their voters/supporters who expect reasonable returns
3. Protocol security, as this disincentivizes candidates from serving as replacement miners

**Severity Justification:**
Medium severity because:
- Direct financial impact on replacement miners
- Happens automatically during normal evil miner detection
- Creates perverse incentive against participating as backup miners
- Undermines the evil miner replacement mechanism's effectiveness

### Likelihood Explanation
**Automatic Trigger:**
This vulnerability is triggered automatically whenever the consensus contract detects evil miners during normal operation: [6](#0-5) 

Evil miners are identified via the Election contract's `GetMinerReplacementInformation`, which checks the `BannedPubkeyMap`: [7](#0-6) 

**Attacker Capabilities:**
No attacker action required - this is a bug in the legitimate evil miner replacement flow. The issue manifests during:
1. Normal consensus operation where miners miss time slots
2. Malicious miners being banned
3. Any scenario triggering `GenerateNextRoundInformation` with banned miners

**Feasibility:**
- Occurs automatically during consensus round generation
- No special permissions or state manipulation needed
- Happens every time an evil miner is replaced during a term
- Affects ALL replacement miners in such scenarios

**Detection:**
The issue would be observable in blockchain data where replacement miners receive unexpectedly low or zero rewards compared to their actual block production.

### Recommendation
**Code-Level Fix:**
Add a call to `TreasuryContract.RecordMinerReplacement` in the evil miner replacement loop within `GenerateNextRoundInformation`:

In `contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs` at line 324 (after firing `MinerReplaced` event), add:

```csharp
// Notify Treasury Contract about evil miner replacement
State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
{
    OldPubkey = evilMinerPubkey,
    NewPubkey = alternativeCandidatePubkey,
    CurrentTermNumber = currentRound.TermNumber,
    IsOldPubkeyEvil = true
});
```

**Invariant Check:**
Add validation in Treasury contract's `UpdateBasicMinerRewardWeights` to verify that miners with significantly below-average produced blocks either have the `IsReplacedEvilMiner` flag set or have a historical `LatestMinedTerm` indicating they're not new.

**Test Cases:**
1. Test evil miner detection and replacement with reward distribution verification
2. Test that replacement miners receive shares equal to produced blocks
3. Test that the flag is properly cleared after first term
4. Test multiple evil miner replacements in same term
5. Test replacement miner continuing into next term (should be treated normally)

### Proof of Concept
**Initial State:**
- Term N is in progress with current miners including MinerA
- MinerA accumulates enough missed time slots to be flagged as evil
- Backup candidate MinerB exists and is available as replacement

**Exploitation Steps:**
1. **Block height reaches term boundary** - Consensus contract calls `GenerateNextRoundInformation`
2. **Evil miner detected** - `GetMinerReplacementInformation` identifies MinerA as evil, MinerB as replacement
3. **Replacement occurs in consensus** - MinerA removed from round, MinerB added (line 337-338 of AEDPoSContract_ViewMethods.cs)
4. **Treasury NOT notified** - No call to `RecordMinerReplacement`, so `IsReplacedEvilMiner[MinerB]` remains unset
5. **MinerB produces blocks** - Mines for remainder of term, produces e.g., 400 blocks
6. **Term ends, rewards distributed** - Treasury's `Release` method called
7. **Unfair calculation** - `UpdateBasicMinerRewardWeights` calculates average as 1000 blocks
8. **MinerB penalized** - Without flag, uses `CalculateShares(400, 1000)` = 160 shares instead of 400 shares

**Expected Result:**
MinerB should receive 400 shares (equal to produced blocks) since they're a replacement miner who joined mid-term.

**Actual Result:**
MinerB receives 160 shares due to `CalculateShares()` formula: 400² / 1000 = 160, losing 60% of fair compensation.

**Success Condition:**
Compare MinerB's reward shares against their actual produced blocks. The vulnerability is confirmed when shares < produced blocks despite being a replacement miner.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-306)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L573-599)
```csharp
    public override Empty RecordMinerReplacement(RecordMinerReplacementInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only AEDPoS Contract can record miner replacement.");

        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
        else
        {
            var replaceCandidates = State.ReplaceCandidateMap[input.CurrentTermNumber] ?? new StringList();
            replaceCandidates.Value.Add(input.NewPubkey);
            State.ReplaceCandidateMap[input.CurrentTermNumber] = replaceCandidates;
        }

        State.IsReplacedEvilMiner[input.NewPubkey] = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```
