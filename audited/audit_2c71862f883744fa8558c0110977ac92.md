### Title
Integer Overflow in Transaction Size Fee Weight Calculation Causes DoS

### Summary
The `ChargeSizeFee()` function multiplies `txSizeFeeAmount` by `AddedTokenWeight` without validating upper bounds on the weight values. When governance sets `AddedTokenWeight` to large values (≥2,000,000) and users submit large transactions (near the 5MB limit), the multiplication overflows `long.MaxValue`, causing `OverflowException` and preventing all transactions from executing.

### Finding Description

**Vulnerable Code Location:** [1](#0-0) 

**Additional Affected Location:** [2](#0-1) 

**Root Cause:**
The `Mul()` extension method uses checked arithmetic that throws `OverflowException` on overflow: [3](#0-2) 

The weight values are defined as `int32` (not `long` as suggested in the question): [4](#0-3) 

**Insufficient Validation:**
The `SetSymbolsToPayTxSizeFee()` method only validates that weights are greater than zero, with no upper bound checks: [5](#0-4) 

**Transaction Size Context:**
Maximum transaction size is 5MB (5,242,880 bytes). For a 5MB transaction, `txSizeFeeAmount` can reach approximately 5,125,000,000,000 (calculated using the piecewise fee coefficient formula): [6](#0-5) [7](#0-6) 

**Overflow Threshold:**
For `txSizeFeeAmount = 5,125,000,000,000` and `AddedTokenWeight ≥ 2,000,000`:
- `5,125,000,000,000 × 2,000,000 = 10,250,000,000,000,000,000 > long.MaxValue (9,223,372,036,854,775,807)`
- The checked multiplication throws `OverflowException`

### Impact Explanation

**Direct Operational Impact:**
When overflow occurs, the `ChargeTransactionFees` execution fails with `OverflowException`, causing:
1. All transactions attempting to pay size fees with the affected alternative token fail
2. Users cannot execute any transactions if they have insufficient primary token but sufficient alternative token
3. Complete DoS of transaction processing for affected token holders

**Affected Users:**
All users who attempt to pay transaction fees using alternative tokens when large weight values are configured. Given that the fee charging happens during pre-execution plugin: [8](#0-7) 

**Severity Justification:**
HIGH - While this requires governance action to configure unsafe weight values, the impact is complete DoS of transaction processing. The vulnerability violates the critical invariant of correct fee deduction paths and causes operational disruption to the entire blockchain.

### Likelihood Explanation

**Attacker Capabilities:**
The `SetSymbolsToPayTxSizeFee()` method requires the caller to be the authorized controller (Parliament organization by default): [9](#0-8) [10](#0-9) [11](#0-10) 

**Attack Complexity:**
LOW - Once malicious or misconfigured weight values are set through governance:
1. Any user submitting a large transaction (near 5MB) triggers the overflow
2. No special transaction structure or timing required
3. Overflow is deterministic and inevitable with the right parameters

**Feasibility Conditions:**
MEDIUM-HIGH - Requires one of:
1. **Malicious governance:** Parliament organization deliberately sets `AddedTokenWeight ≥ 2,000,000`
2. **Configuration error:** Governance accidentally sets extreme weight values without understanding overflow implications
3. **Economic manipulation:** Bad actor gains control of Parliament through normal governance processes

The code provides no warnings, documentation, or safeguards about safe weight ranges. Test cases only use small values (1, 2, 4): [12](#0-11) 

**Probability Assessment:**
MEDIUM - While governance is typically trusted, the lack of bounds checking creates risk of accidental misconfiguration. The code provides no guidance on safe ranges, and `int32.MaxValue (2,147,483,647)` is a legal but dangerous value.

### Recommendation

**Add Upper Bound Validation:**
In `SetSymbolsToPayTxSizeFee()`, add maximum weight validation after line 635:

```csharp
Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
    
// Add these checks to prevent overflow
const int MAX_SAFE_WEIGHT = 1_000_000; // Conservative limit to prevent overflow
Assert(tokenWeightInfo.AddedTokenWeight <= MAX_SAFE_WEIGHT && 
       tokenWeightInfo.BaseTokenWeight <= MAX_SAFE_WEIGHT,
    $"symbol:{tokenWeightInfo.TokenSymbol} weight values must not exceed {MAX_SAFE_WEIGHT} to prevent overflow");
```

**Rationale for MAX_SAFE_WEIGHT = 1,000,000:**
- Maximum `txSizeFeeAmount` for 5MB transaction ≈ 5,125,000,000,000
- Safe multiplication: `5,125,000,000,000 × 1,000,000 = 5.125 × 10^18 < long.MaxValue (9.2 × 10^18)`
- Provides 10,000:1 ratio capability, which is more than sufficient for any realistic token exchange rate

**Test Cases to Add:**
1. Test that setting `AddedTokenWeight = 2,000,000` is rejected
2. Test that setting `AddedTokenWeight = MAX_SAFE_WEIGHT` succeeds
3. Test large transaction (5MB) with maximum allowed weights succeeds without overflow
4. Regression test confirming overflow protection

### Proof of Concept

**Initial State:**
1. Deploy MultiToken contract with primary token (ELF)
2. Create alternative token (ALT) with sufficient supply
3. Parliament organization is the default controller

**Exploitation Steps:**
1. **Governance Action:** Parliament submits and approves proposal to call `SetSymbolsToPayTxSizeFee()` with:
   ```
   SymbolToPayTxSizeFee {
       TokenSymbol = "ALT",
       BaseTokenWeight = 1,
       AddedTokenWeight = 2,000,000
   }
   ```

2. **User Transaction:** User prepares a large transaction (5MB size) with method fee and submits with:
   - Sufficient ALT token balance
   - Insufficient ELF token balance to force ALT usage

3. **Pre-Execution Plugin:** During `ChargeTransactionFees`:
   - `txSizeFeeAmount` calculated as ~5,125,000,000,000
   - Code path reaches line 403-404
   - Executes: `5,125,000,000,000.Mul(2,000,000)` 
   - Result: `10,250,000,000,000,000,000 > long.MaxValue`

**Expected Result:**
Transaction executes successfully, charging equivalent ALT tokens for size fee.

**Actual Result:**
`OverflowException` thrown by `SafeMath.Mul()`, transaction reverts, user cannot execute any transaction with ALT token.

**Success Condition:**
All transactions using ALT token for size fees fail with overflow exception, confirming complete DoS of the alternative token fee payment mechanism.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-52)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L403-404)
```csharp
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L618-618)
```csharp
        AssertControllerForSymbolToPayTxSizeFee();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L634-635)
```csharp
            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1394-1395)
```csharp
        txSizeFeeAmount = txSizeFeeAmount.Mul(tokenInfo.AddedTokenWeight)
            .Div(tokenInfo.BaseTokenWeight);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L79-85)
```csharp
    public static long Mul(this long a, long b)
    {
        checked
        {
            return a * b;
        }
    }
```

**File:** protobuf/token_contract.proto (L500-503)
```text
    int32 base_token_weight = 2;
    // The new added token charge weight. For example, the charge weight of primary Token is set to 1. 
    // The newly added token charge weight is set to 10. If the transaction requires 1 unit of primary token, 
    // the user can also pay for 10 newly added tokens.
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L274-312)
```csharp
    private CalculateFeeCoefficients GetTxFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Tx,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, 5000000): x / 80
                    Value =
                    {
                        5000000,
                        1, 1, 80
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (5000000, ∞): x / 80 + x^2 / 100000
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 80,
                        2, 1, 100000
                    }
                }
            }
        };
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Extensions/CalculateFeeCoefficientsExtensions.cs (L10-69)
```csharp
    private const decimal Precision = 100000000;

    internal static CalculateFunction ToCalculateFunction(
        this CalculateFeeCoefficients calculateFeeCoefficients)
    {
        var pieceCalculateFunction = new CalculateFunction(calculateFeeCoefficients.FeeTokenType);
        foreach (var pieceCoefficients in calculateFeeCoefficients.PieceCoefficientsList.Where(pc =>
                     (pc.Value.Count - 1) % 3 == 0))
            pieceCalculateFunction.AddFunction(pieceCoefficients.Value.ToArray(),
                GetFunction(pieceCoefficients.Value.ToArray()));

        return pieceCalculateFunction;
    }

    private static Func<int, long> GetFunction(int[] parameters)
    {
        return count => GetExponentialFunc(count, parameters);
    }

    // eg. 2x^2 + 3x + 1 -> (2,2,1, 1,3,1, 0,1,1)
    private static long GetExponentialFunc(int count, params int[] parameters)
    {
        long cost = 0;

        // Skip parameters[0] which is meant to be piece upper bound.
        var currentIndex = 1;
        while (currentIndex < parameters.Length)
        {
            cost += GetUnitExponentialCalculation(count, parameters[currentIndex],
                parameters[currentIndex + 1],
                parameters[currentIndex + 2]);
            currentIndex += 3;
        }

        return cost;
    }

    // (A, B, C)  ->  x^A * (B / C)
    private static long GetUnitExponentialCalculation(int count, params int[] parameters)
    {
        if (parameters[2] == 0) parameters[2] = 1;

        decimal decimalResult;
        var power = parameters[0];
        decimal divisor = parameters[1];
        decimal dividend = parameters[2];
        if (power == 0)
        {
            // This piece is (B / C)
            decimalResult = divisor / dividend;
        }
        else
        {
            // Calculate x^A at first.
            var powerResult = (decimal)Math.Pow(count, power);
            decimalResult = powerResult * divisor / dividend;
        }

        return (long)(decimalResult * Precision);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L354-357)
```csharp
    private AuthorityInfo GetDefaultSymbolToPayTxFeeController()
    {
        return GetDefaultParliamentController();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L399-405)
```csharp
    private void AssertControllerForSymbolToPayTxSizeFee()
    {
        if (State.SymbolToPayTxFeeController.Value == null)
            State.SymbolToPayTxFeeController.Value = GetDefaultSymbolToPayTxFeeController();

        Assert(State.SymbolToPayTxFeeController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L109-115)
```csharp
    [InlineData(new[] { 1, 2, 3 }, new[] { 10000L, 0, 0 }, new[] { 1, 1, 1 }, new[] { 1, 1, 1 }, 1000, "ELF", 2000,
        true)]
    [InlineData(new[] { 2, 1, 3 }, new[] { 10000L, 10000L, 0 }, new[] { 1, 1, 1 }, new[] { 1, 1, 1 }, 1000, "CWJ", 1000,
        true)]
    [InlineData(new[] { 2, 1, 3 }, new[] { 10000L, 10000L, 0 }, new[] { 1, 1, 1 }, new[] { 2, 1, 1 }, 1000, "CWJ", 2000,
        true)]
    [InlineData(new[] { 2, 1, 3 }, new[] { 10000L, 10000L, 0 }, new[] { 4, 1, 1 }, new[] { 2, 1, 1 }, 1000, "CWJ", 500,
```
