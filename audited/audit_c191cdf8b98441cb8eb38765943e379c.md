### Title
Multiple UpdateValue Submissions Allow Miners to Manipulate Next Round Position Order

### Summary
A miner who has already submitted consensus data via `UpdateValue` can call it again within the same round with a different signature to recalculate their `FinalOrderOfNextRound` position. This allows malicious miners to repeatedly try different signatures until they obtain a favorable position (e.g., first miner) in the next round, potentially displacing honest miners who had already secured better positions. The vulnerability exists because existing validations fail to prevent double-submission within the same round.

### Finding Description

**Location**: The vulnerability spans multiple files in the consensus data submission flow: [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause**:

The `UpdateValue` method allows miners to update their consensus information for the current round. However, there is no check to prevent a miner from calling this method multiple times within the same round. The critical issues are:

1. **Unconditional Overwrite in ProcessUpdateValue**: [4](#0-3) 

The function unconditionally overwrites `Signature`, `OutValue`, `SupposedOrderOfNextRound`, and `FinalOrderOfNextRound` without checking if these values were already set.

2. **Unconditional Overwrite in ApplyNormalConsensusData**: [5](#0-4) 

The signature and outValue are unconditionally overwritten, and the position is recalculated based on the new signature.

3. **Position Calculation Based on Signature**: [6](#0-5) 

The next round position is deterministically calculated from the signature hash, allowing miners to brute-force favorable positions offline.

4. **Conflict Resolution Displaces Other Miners**: [7](#0-6) 

When a conflict occurs, the code pushes OTHER miners to different positions, allowing an attacker to displace honest miners.

**Why Existing Protections Fail**:

1. **EnsureTransactionOnlyExecutedOnceInOneBlock is Insufficient**: [8](#0-7) 

This only prevents multiple executions in the SAME block, not across different blocks within the same round.

2. **UpdateValueValidationProvider Checks Wrong Data**: [9](#0-8) 

The validation checks `ProvidedRound` (the data being submitted) rather than checking whether the on-chain `BaseRound` already has these values set.

3. **RecoverFromUpdateValue Overwrites Before Validation**: [10](#0-9) [11](#0-10) 

The validation flow recovers (overwrites) the `BaseRound` with provided data BEFORE validation runs, so validators see the new submission, not the original on-chain state.

4. **TuneOrderInformation Propagates Position Changes**: [12](#0-11) 

The system applies position adjustments from `TuneOrderInformation`, allowing the attacker to legitimately encode position changes that displace other miners.

### Impact Explanation

**Direct Consensus Integrity Impact**:

- **Mining Order Manipulation**: Malicious miners can manipulate their position in the next round's mining order, potentially securing the first position (most profitable and influential).

- **Honest Miner Displacement**: When an attacker changes their position through resubmission, the conflict resolution logic displaces honest miners who had already secured their positions through legitimate means.

- **Consensus Fairness Violation**: The deterministic position assignment based on signatures is intended to be fair and tamper-resistant. This vulnerability undermines that fundamental assumption.

**Quantified Impact**:

- An attacker mining at position 10 could steal position 1 by resubmitting with a crafted signature, gaining the advantage of mining first in the next round.
- Each block position carries different rewards and influence (first miner has more control over transaction ordering).
- All miners are affected as their positions become subject to manipulation by any single malicious miner.

**Severity**: HIGH - This directly compromises the integrity of the consensus mechanism, which is a critical component of blockchain security.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be an authorized miner (already in the miner list)
- Requires ability to compute signature hashes offline (trivial)
- Requires ability to submit multiple transactions in the same round (normal miner capability)

**Attack Complexity**: LOW
1. Miner produces their first block normally with signature S1
2. Miner computes offline: for various input values, calculate resulting signatures and their corresponding positions
3. Miner identifies signature S2 that gives position 1
4. Miner produces another block in the same round (before round transition) with signature S2
5. The second `UpdateValue` call overwrites their previous data and displaces other miners

**Feasibility Conditions**:
- Attacker must be able to produce multiple blocks within one round (achievable in normal operations)
- No additional privileges beyond being a miner are required
- The round must be long enough to include multiple blocks (typical case)

**Detection and Operational Constraints**:
- Attack is difficult to detect as it appears as normal block production
- No rate limiting exists beyond the per-block check
- Transaction pool and block production mechanisms don't prevent this

**Probability**: HIGH - Any miner can execute this attack with minimal cost and effort. The only requirement is being in the miner list, which is a normal operational state.

### Recommendation

**Immediate Fix**:

Add a check in `ProcessUpdateValue` to prevent overwriting already-set consensus data:

```csharp
// In ProcessUpdateValue, before line 244:
Assert(
    minerInRound.OutValue == null || minerInRound.OutValue == Hash.Empty,
    "Consensus data already submitted for this round."
);
Assert(
    minerInRound.Signature == null || minerInRound.Signature == Hash.Empty,
    "Signature already submitted for this round."
);
```

**Alternative Approach**:

Modify `UpdateValueValidationProvider.NewConsensusInformationFilled` to check the on-chain BaseRound BEFORE recovery:

```csharp
// In ValidateBeforeExecution, check BaseRound before calling RecoverFromUpdateValue:
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    var minerInRound = baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()];
    if (minerInRound.OutValue != null && minerInRound.OutValue != Hash.Empty)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "Consensus data already submitted." 
        };
    }
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

**Invariant to Enforce**:
- Each miner can submit consensus data (OutValue, Signature) exactly once per round
- `FinalOrderOfNextRound` should only be set once and cannot be modified by resubmission

**Test Cases**:
1. Test that calling `UpdateValue` twice in the same round fails on the second attempt
2. Test that miners cannot modify their position after initial submission
3. Test that conflict resolution only occurs during the first submission
4. Test that round transitions properly reset the submission state for the new round

### Proof of Concept

**Initial State**:
- Round 1 is active with 10 miners
- Miner A is in position 5 for current round
- Miner B has not yet submitted consensus data

**Attack Sequence**:

**Transaction 1** (Block Height 100, Round 1):
- Miner A calls `UpdateValue` with:
  - Signature: Hash("MinerA_Input1") = 0xABCD... 
  - Calculated position: GetAbsModulus(0xABCD..., 10) + 1 = 7
- State after TX1: Miner A has `FinalOrderOfNextRound = 7`

**Transaction 2** (Block Height 101, Round 1):
- Miner B calls `UpdateValue` with:
  - Signature: Hash("MinerB_Input") = 0x1234...
  - Calculated position: GetAbsModulus(0x1234..., 10) + 1 = 1
- State after TX2: Miner B has `FinalOrderOfNextRound = 1`

**Transaction 3** (Block Height 102, Still Round 1 - EXPLOIT):
- Miner A computes offline: Hash("MinerA_Input2") = 0x5678... gives position 1
- Miner A calls `UpdateValue` AGAIN with:
  - Signature: Hash("MinerA_Input2") = 0x5678...
  - Calculated position: GetAbsModulus(0x5678..., 10) + 1 = 1
- Validation PASSES (all checks pass as described in Finding Description)
- `ProcessUpdateValue` executes:
  - Overwrites Miner A's signature: `0xABCD...` → `0x5678...`
  - Recalculates position: 7 → 1
  - Detects conflict with Miner B at position 1
  - Pushes Miner B to position 2 via `TuneOrderInformation`
- State after TX3: Miner A has `FinalOrderOfNextRound = 1`, Miner B pushed to `FinalOrderOfNextRound = 2`

**Expected vs Actual Result**:
- **Expected**: Miner A's second `UpdateValue` call should be rejected, maintaining their position 7 and Miner B's position 1
- **Actual**: Miner A successfully steals position 1 from Miner B through resubmission

**Success Condition**: 
After Transaction 3, query the round state and verify that Miner A now has `FinalOrderOfNextRound = 1` (stolen from Miner B), demonstrating the attacker successfully manipulated their position through double-submission.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```
