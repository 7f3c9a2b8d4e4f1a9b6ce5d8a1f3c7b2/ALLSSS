### Title
Integer Overflow in Cross-Chain Indexing Fee Debt Calculations Due to Missing Upper Bound Validation

### Summary
The `AdjustIndexingFeePrice` function lacks an upper bound check on the `IndexingFee` parameter, allowing values up to `Int64.MaxValue`. When combined with unchecked arithmetic operations in debt calculations, this enables integer overflow that causes arrears amounts to wrap to negative values, allowing side chains to recharge and reactivate with insufficient funds, breaking the economic model and causing indexers to lose payment.

### Finding Description

The vulnerability exists across multiple locations in the CrossChain contract:

**Entry Point - Missing Upper Bound:** [1](#0-0) 

The `AdjustIndexingFeePrice` function only validates that `input.IndexingFee >= 0`, with no maximum limit. Since `indexing_fee` is defined as `int64` in the protobuf schema, it can be set to values up to `9,223,372,036,854,775,807` (Int64.MaxValue). [2](#0-1) 

**Root Cause - Unchecked Arithmetic in Debt Calculation:** [3](#0-2) 

The `IndexSideChainBlockData` function performs unchecked arithmetic operations:
- Line 844: `lockedToken -= indexingPrice` can underflow when indexingPrice is large
- Line 849: `arrearsAmount += indexingPrice` can overflow when multiple blocks are indexed
- Line 873: `amount + arrearsAmount` can overflow when adding to existing arrears

These operations use native C# operators (`-=`, `+=`, `+`) instead of SafeMath methods. AElf provides SafeMath with checked arithmetic: [4](#0-3) 

But the contract code does not use these safe methods, allowing silent overflow.

**Overflow Propagation in Recharge:** [5](#0-4) 

The recharge validation at line 207 uses unchecked addition for both sides of the comparison. When the right side (`arrearsAmount + sideChainInfo.IndexingPrice`) overflows to a negative value, the assertion incorrectly passes even with insufficient funds.

**Debt Query Also Affected:** [6](#0-5) 

The `GetSideChainIndexingFeeDebt` function uses `.Sum()` which can also overflow when summing large arrears values.

**Contrast with Creation-Time Validation:**
During side chain creation, there IS a relationship check between IndexingPrice and LockedTokenAmount: [7](#0-6) 

However, this validation is NOT enforced in `AdjustIndexingFeePrice`, allowing the price to be increased beyond any reasonable bound post-creation.

### Impact Explanation

**Direct Economic Harm:**
When IndexingPrice is set to an astronomically high value (e.g., `Int64.MaxValue / 2 + 1`), and multiple blocks are indexed in one transaction:
1. First block: `arrearsAmount = 5,000,000,000,000,000,000`
2. Second block: `arrearsAmount += 5,000,000,000,000,000,000` = `10,000,000,000,000,000,000`, which exceeds Int64.MaxValue
3. Overflow wraps around to approximately `-8,446,744,073,709,551,616` (large negative number)
4. Recharge validation: `input.Amount + originBalance >= -8,446,744,073,709,551,616 + IndexingPrice` has a negative or small right side due to continued overflow
5. Side chain reactivates with minimal recharge, despite owing massive fees

**Who is Affected:**
- **Indexers**: Lose their rightful indexing fee payments as arrears are incorrectly recorded as negative values
- **Protocol integrity**: The cross-chain fee economic model is broken, as side chains can operate without proper payment
- **Network security**: Indexers may refuse to index side chain data without proper compensation

**Severity Justification:**
Medium severity is appropriate because:
- Real economic loss occurs (unpaid indexing fees)
- Protocol invariant "Token Supply & Fees - fee deduction paths" is violated
- Requires IndexingFeeController authorization (not arbitrary attacker), reducing likelihood
- Impact is limited to specific side chain's indexing economy, not entire network

### Likelihood Explanation

**Attacker Capabilities:**
The IndexingFeeController is an Association organization created during side chain initialization: [8](#0-7) 

This requires approval from both the side chain creator and the CrossChainIndexingController owner (typically a Parliament organization). This is NOT a system administrator role, but a designed governance mechanism for fee adjustment.

**Exploitation Scenarios:**
1. **Intentional exploitation**: Side chain creator colludes with CrossChainIndexingController to reduce indexing costs by exploiting overflow
2. **Accidental misconfiguration**: Governance participants set an unreasonably high fee without understanding overflow implications, especially during fee adjustment proposals
3. **Economic incentive**: Side chain operators have direct financial incentive to reduce their indexing fee burden

**Execution Practicality:**
- Entry point is reachable via standard governance proposal process
- No special contract state manipulation required
- Overflow occurs deterministically with high IndexingPrice values
- Multiple blocks per indexing transaction are common in production

**Detection Constraints:**
- Overflow is silent (no exceptions thrown)
- Negative arrears values may not be immediately obvious in monitoring
- Side chain might continue operating normally, hiding the exploit

**Probability Assessment:**
While requiring multi-party governance approval reduces likelihood compared to arbitrary attacker scenarios, this remains exploitable because:
- The missing validation is a clear implementation bug, not a design choice
- Economic incentives exist for exploitation
- Accidental overflow is realistic given lack of bounds
- The IndexingFeeController is meant to adjust fees, not a "trusted admin" that should be blindly trusted

### Recommendation

**Immediate Fix - Add Upper Bound Validation:**
In `AdjustIndexingFeePrice`, add validation to ensure the new fee is reasonable relative to the locked token amount:

```csharp
Assert(input.IndexingFee >= 0, "Invalid side chain fee price.");
var lockedAmount = GetSideChainIndexingFeeDeposit(input.SideChainId);
Assert(input.IndexingFee <= lockedAmount / 10, "Indexing fee too high relative to locked amount.");
// Or set a protocol-wide maximum:
Assert(input.IndexingFee <= 1_000_000_000_000_000, "Indexing fee exceeds maximum allowed.");
```

**Use SafeMath for Arithmetic:**
Replace unchecked arithmetic operations in `IndexSideChainBlockData` with SafeMath methods:

```csharp
lockedToken = lockedToken.Sub(indexingPrice);  // throws on underflow
arrearsAmount = arrearsAmount.Add(indexingPrice);  // throws on overflow
```

And in recharge validation:
```csharp
var requiredAmount = arrearsAmount.Add(sideChainInfo.IndexingPrice);
Assert(input.Amount.Add(originBalance) >= requiredAmount, "Indexing fee recharging not enough.");
```

**Invariant Checks:**
- Assert that arrears amounts are always non-negative
- Add bounds checking for IndexingPrice relative to total token supply
- Validate that debt calculations never wrap around

**Test Cases:**
Add regression tests for:
- Setting IndexingPrice to Int64.MaxValue / 2 and indexing multiple blocks
- Verifying overflow protection in arrears accumulation
- Confirming recharge validation with large debt values
- Testing boundary conditions (Int64.MaxValue - 1, etc.)

### Proof of Concept

**Initial State:**
- Side chain created with `LockedTokenAmount = 1,000,000` tokens, `IndexingPrice = 100`
- Side chain has existing deposit of 1,000,000 tokens

**Attack Steps:**

1. **Set Astronomical Fee:**
   - IndexingFeeController submits proposal: `AdjustIndexingFeePrice(sideChainId, indexingFee: 5,000,000,000,000,000,000)`
   - Proposal approved by Association members
   - `info.IndexingPrice` updated to `5,000,000,000,000,000,000`

2. **Index Multiple Blocks:**
   - Miner proposes indexing for 2 side chain blocks via `ProposeCrossChainIndexing`
   - During `ReleaseCrossChainIndexingProposal`, `IndexSideChainBlockData` executes:
   
   Block 1:
   - `lockedToken = 1,000,000`
   - `lockedToken -= 5,000,000,000,000,000,000` → underflows to large negative
   - `lockedToken < 0` → true
   - `arrearsAmount += 5,000,000,000,000,000,000` → `arrearsAmount = 5,000,000,000,000,000,000`
   
   Block 2:
   - `lockedToken` still negative
   - `arrearsAmount += 5,000,000,000,000,000,000` → overflows to approximately `-8,446,744,073,709,551,616`
   - Stored in `sideChainInfo.ArrearsInfo[proposer]`

3. **Recharge with Insufficient Funds:**
   - Call `Recharge(chainId, amount: 1,000)` with minimal tokens
   - Line 196: `arrearsAmount += arrears.Value` → `arrearsAmount = -8,446,744,073,709,551,616`
   - Line 207: Check `1,000 + 1,000,000 >= -8,446,744,073,709,551,616 + 5,000,000,000,000,000,000`
   - Right side overflows again to negative value
   - Assertion passes incorrectly
   - Side chain status set to Active with massive unpaid debt

**Expected Result:** 
Recharge should fail, requiring payment of actual debt (~10,000,000,000,000,000,000 tokens)

**Actual Result:**
Recharge succeeds with only 1,000 tokens due to integer overflow making debt appear negative

**Success Condition:**
Side chain status changes from `IndexingFeeDebt` to `Active` while actual arrears remain unpaid, and indexers receive no compensation for their work.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L190-208)
```csharp
        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L244-255)
```csharp
    public override Empty AdjustIndexingFeePrice(AdjustIndexingFeeInput input)
    {
        var info = State.SideChainInfo[input.SideChainId];
        Assert(info != null && info.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");
        Assert(input.IndexingFee >= 0, "Invalid side chain fee price.");
        var expectedOrganizationAddress = info.IndexingFeeController.OwnerAddress;
        Assert(expectedOrganizationAddress == Context.Sender, "No permission.");
        info.IndexingPrice = input.IndexingFee;
        State.SideChainInfo[input.SideChainId] = info;
        return new Empty();
    }
```

**File:** protobuf/acs7.proto (L264-269)
```text
message AdjustIndexingFeeInput{
    // The side chain id to adjust.
    int32 side_chain_id = 1;
    // The new price of indexing fee.
    int64 indexing_fee = 2;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L119-122)
```csharp
        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L657-673)
```csharp
    private AuthorityInfo CreateDefaultOrganizationForIndexingFeePriceManagement(Address sideChainCreator)
    {
        var createOrganizationInput =
            GenerateOrganizationInputForIndexingFeePrice(new List<Address>
            {
                sideChainCreator,
                GetCrossChainIndexingController().OwnerAddress
            });
        SetContractStateRequired(State.AssociationContract, SmartContractConstants.AssociationContractSystemName);
        State.AssociationContract.CreateOrganization.Send(createOrganizationInput);

        var controllerAddress = CalculateSideChainIndexingFeeControllerOrganizationAddress(createOrganizationInput);
        return new AuthorityInfo
        {
            ContractAddress = State.AssociationContract.Value,
            OwnerAddress = controllerAddress
        };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L842-876)
```csharp
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-106)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }

    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L89-99)
```csharp
    public override Int64Value GetSideChainIndexingFeeDebt(Int32Value input)
    {
        var chainId = input.Value;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");

        return new Int64Value
        {
            Value = sideChainInfo.ArrearsInfo.Values.Sum()
        };
    }
```
