### Title
Secret Sharing Reveals In-Values for Non-Producing Miners, Causing Validation Failure and DoS

### Summary
The `RevealSharedInValues` function and `PerformSecretSharing` logic set `PreviousInValue` for miners who failed to produce blocks in the previous round, violating the consensus invariant that only block-producing miners should have revealed in-values. This causes subsequent block production attempts by these miners to fail validation, resulting in a denial-of-service where miners who missed their previous time slot cannot produce blocks in the current round.

### Finding Description

The vulnerability exists in multiple locations where in-values are revealed and set without verifying that the target miner produced blocks in the previous round:

**Location 1: RevealSharedInValues** [1](#0-0) 

The function iterates through miners from the previous round and sets their `PreviousInValue` based on secret sharing reconstruction, but never checks if they have a non-null `OutValue` (the indicator of block production). [2](#0-1) 

**Location 2: PerformSecretSharing** [3](#0-2) 

This function directly sets `PreviousInValue` from `UpdateValueInput.MinersPreviousInValues` without any validation that the miners actually produced blocks.

**Location 3: MinersPreviousInValues Population** [4](#0-3) 

When preparing consensus updates, ALL miners with non-null `PreviousInValue` are included, regardless of whether they produced blocks (have `OutValue`).

**The Invariant Violation:**

The codebase establishes that `OutValue` being set is the definitive indicator of block production: [5](#0-4) 

The validation logic assumes that if a miner has `PreviousInValue` set, they must have a corresponding `OutValue` from the previous round: [6](#0-5) 

The validation retrieves `previousOutValue` and checks `Hash(previousInValue) == previousOutValue`. For non-producing miners, `previousOutValue` is null or empty, causing validation to fail.

**Why Existing Protections Fail:**

The `ApplyNormalConsensusData` function only sets `PreviousInValue` if it's currently empty/null: [7](#0-6) 

However, if `PreviousInValue` was already set by revealed values (via `PerformSecretSharing`), it won't be overridden. The miner is then stuck with an invalid `PreviousInValue` that cannot be validated.

### Impact Explanation

**Direct Operational Impact - Consensus DoS:**
- Miners who miss their time slot in round N become vulnerable to DoS in round N+1
- When other miners include revealed in-values via `MinersPreviousInValues`, non-producing miners get their `PreviousInValue` set
- These miners can no longer produce blocks because validation fails on the mismatch between the revealed `PreviousInValue` and their non-existent `OutValue`
- The affected miner loses all block rewards for the remainder of the current round
- Network consensus can be degraded if multiple miners are affected simultaneously

**Severity: Medium**
- Affects miners who missed their previous time slot (natural occurrence in distributed systems)
- Causes complete inability to produce blocks for one full round (typically several minutes)
- Financial impact: loss of block production rewards for affected miners
- Consensus impact: reduced active miner set degrades network security
- No permanent damage, but repeated exploitation could systematically exclude specific miners

### Likelihood Explanation

**Attacker Capabilities: Low - Any miner can trigger**
- Any miner producing blocks can include `MinersPreviousInValues` in their `UpdateValueInput`
- No special privileges required beyond being an active miner
- Can even occur unintentionally through honest protocol execution when secret sharing is enabled

**Attack Complexity: Low**
- The vulnerability triggers automatically when the protocol's secret sharing mechanism reveals in-values for non-producing miners
- Attacker simply needs to observe which miners missed their time slot
- Include those miners' revealed in-values in the next block production

**Feasibility Conditions: Highly Practical**
1. Secret sharing must be enabled (configurable via governance) [8](#0-7) 

2. Target miner must have missed their time slot in the previous round (common in distributed consensus)
3. Target miner must have shared encrypted pieces in the previous round (standard protocol behavior)
4. Attacker produces a block before the victim in the current round

**Detection/Prevention Constraints: None**
- No on-chain detection mechanism for malicious vs. legitimate revealed in-values
- The protocol treats all revealed in-values equally
- Miners cannot prevent others from including their revealed in-values

**Probability: Medium-High when secret sharing is enabled**
- Time slot misses occur naturally due to network issues, node restarts, or timing edge cases
- When secret sharing is active, revealed in-values are routinely propagated
- The vulnerability triggers automatically without attacker intention when the protocol operates normally

### Recommendation

**Add OutValue Validation Check:**

In `RevealSharedInValues`, add a check before setting `PreviousInValue`:
```csharp
// Before line 52, add:
if (anotherMinerInPreviousRound.OutValue == null || 
    anotherMinerInPreviousRound.OutValue == Hash.Empty) 
    continue;
```

In `PerformSecretSharing`, validate that miners in `MinersPreviousInValues` actually produced blocks:
```csharp
// Replace lines 295-296 with:
foreach (var previousInValue in input.MinersPreviousInValues)
{
    // Only set if the miner produced blocks in the previous round
    if (!TryToGetPreviousRoundInformation(out var prevRound)) continue;
    if (!prevRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key)) continue;
    if (prevRound.RealTimeMinersInformation[previousInValue.Key].OutValue == null ||
        prevRound.RealTimeMinersInformation[previousInValue.Key].OutValue == Hash.Empty)
        continue;
    
    round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

In `ExtractInformationToUpdateConsensus`, filter out non-producing miners:
```csharp
// Replace lines 30-33 with:
var minersPreviousInValues =
    RealTimeMinersInformation.Values
        .Where(info => info.PreviousInValue != null && 
                      info.OutValue != null && 
                      info.OutValue != Hash.Empty)
        .ToDictionary(info => info.Pubkey, info => info.PreviousInValue);
```

**Test Cases to Add:**
1. Verify that miners who miss time slots do not have `PreviousInValue` set by secret sharing
2. Test that miners who missed their previous slot can still produce blocks in the next round
3. Ensure validation accepts blocks from previously-inactive miners with fake/empty `PreviousInValue`
4. Verify that only miners with `OutValue` have their in-values revealed and propagated

### Proof of Concept

**Initial State:**
- Round N with 7 miners (A, B, C, D, E, F, G)
- Secret sharing is enabled
- All miners share encrypted pieces in Round N

**Execution Steps:**

1. **Round N - Miner A Misses Time Slot:**
   - Miners B, C, D, E, F, G produce blocks successfully (set `OutValue`, `Signature`)
   - Miner A fails to produce (no `OutValue` set)
   - All miners have encrypted pieces distributed

2. **Round N+1 - Miner B Produces First Block:**
   - Miner B's node runs secret sharing reconstruction
   - `SecretSharingService.RevealPreviousInValues` reconstructs Miner A's in-value (despite A not producing) [9](#0-8) 
   
   - The revealed value is included in `triggerInformation.RevealedInValues`
   - When B produces the block, `UpdateLatestSecretPieces` or `PerformSecretSharing` sets `round.RealTimeMinersInformation["A"].PreviousInValue = revealedValue`

3. **Round N+1 - Miner A Attempts to Produce Block:**
   - Miner A prepares block with `PreviousInValue = Hash.Empty` or null (since A didn't produce in Round N)
   - `ApplyNormalConsensusData` is called, but A's `PreviousInValue` is already set by the revealed value, so it's not overridden (lines 14-16 check prevents override)
   - Block validation calls `ValidatePreviousInValue`
   - Validation retrieves `previousOutValue = round_N.RealTimeMinersInformation["A"].OutValue` → null/empty
   - Validation checks `Hash(revealedInValue) == null/empty` → **FALSE**
   - Block validation fails with "Incorrect previous in value"

**Expected Result:** Miner A should be able to produce blocks using a fake/empty `PreviousInValue` since they didn't produce in Round N

**Actual Result:** Miner A's block is rejected due to validation failure, preventing them from producing any blocks for the remainder of Round N+1

**Success Condition:** The attack succeeds when Miner A cannot produce blocks despite having a valid time slot, due to the incorrectly revealed `PreviousInValue` causing validation failures.

### Notes

This vulnerability stems from a fundamental design flaw where the secret sharing mechanism operates independently of the block production tracking mechanism. The system assumes that having encrypted pieces distributed means the miner will produce blocks, but this assumption breaks when miners miss their time slots. The fix must enforce the invariant that `PreviousInValue` can only be set for miners who actually produced an `OutValue` in the corresponding round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L25-53)
```csharp
        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L150-155)
```csharp
    public MinerInRound FirstActualMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.OutValue != null)
            : null;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L144-184)
```csharp
    private void RevealPreviousInValues(SecretSharingInformation secretSharingInformation, string selfPubkey)
    {
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        var revealedInValues = new Dictionary<string, Hash>();

        foreach (var pair in round.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == selfPubkey) continue;

            var pubkey = pair.Key;
            var minerInRound = pair.Value;

            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
        }

        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
    }
```
