### Title
Miner Order Manipulation via Unconstrained Signature Calculation in GetConsensusExtraDataToPublishOutValue

### Summary
A critical flaw in `GetConsensusExtraDataToPublishOutValue` allows miners to manipulate their mining order for the next round by providing crafted `previousInValue` inputs. Even when validation fails and `previousInValue` is set to `Hash.Empty`, the signature is computed using the attacker-controlled value, enabling order manipulation through brute-force.

### Finding Description

The vulnerability exists in the consensus data generation flow within `GetConsensusExtraDataToPublishOutValue`. [1](#0-0) 

When a miner provides a `previousInValue` that doesn't match their committed `OutValue` from the previous round, the validation check at lines 80-82 fails and sets `previousInValue = Hash.Empty` at line 85. However, the signature calculation at line 92 occurs **outside** the validation if-else block and **unconditionally** uses `triggerInformation.PreviousInValue` (the attacker-controlled value) regardless of whether validation passed or failed. [2](#0-1) 

This crafted signature is then passed to `ApplyNormalConsensusData`, which uses it to determine the miner's order for the next round: [3](#0-2) 

The order calculation at lines 19-21 converts the signature to an integer and applies modulo arithmetic to determine `supposedOrderOfNextRound`. By controlling the signature input, an attacker can brute-force a `previousInValue` that yields their desired mining position.

The block validation allows this exploitation because `UpdateValueValidationProvider` explicitly permits `Hash.Empty` as a valid `previousInValue`: [4](#0-3) 

At line 46, when `previousInValue == Hash.Empty`, the validation returns `true`, allowing the manipulated data to be accepted.

The signature calculation uses XOR aggregation with previous round data: [5](#0-4) 

Since the previous round's aggregated signatures are fixed in state, the attacker can compute different candidate signatures offline and select one that produces their desired order.

### Impact Explanation

**Consensus Integrity Violation**: Miners can arbitrarily choose their position in the next round's mining schedule, breaking the randomness and fairness guarantees of the AEDPoS consensus mechanism.

**MEV Exploitation**: Being first in the mining order grants significant advantages:
- Priority access to transaction fees and MEV opportunities
- First mover advantage in DeFi arbitrage and liquidations
- Ability to front-run other miners' transactions
- Influence over randomness generation for the round

**Unfair Advantage**: Malicious miners can:
- Consistently position themselves as the first block producer
- Control when to trigger `NextRound` or `NextTerm` behaviors
- Manipulate their `ImpliedIrreversibleBlockHeight` settings strategically
- Gain disproportionate rewards through preferential positioning

**Repeated Exploitation**: Since any miner can exploit this during their turn, the vulnerability can be abused continuously across multiple rounds, compounding the unfair advantage.

### Likelihood Explanation

**Attacker Capabilities**: Any authorized miner in the current miner list can exploit this vulnerability during their scheduled mining slot. No additional privileges or coordination are required.

**Attack Complexity**: The attack is computationally trivial:
- With `n` miners, the probability of a random signature yielding a specific order is `1/n`
- Expected attempts to find order 1: `n` hash operations (typically 20-100 for AElf)
- Modern hardware can compute millions of hashes per second
- Attack execution time: milliseconds to seconds

**Feasibility**: The attack is highly practical:
1. Miner retrieves previous round data from contract state
2. Computes aggregated previous signatures using `CalculateSignature`
3. Brute-forces candidate `previousInValue` values until finding one where `signature.ToInt64() % minersCount + 1 == desired_order`
4. Provides this crafted value during block production
5. Block validation passes because `previousInValue = Hash.Empty` is explicitly allowed

**Economic Rationality**: The cost is negligible (CPU cycles), while the benefits (MEV, transaction fees, strategic positioning) can be substantial, making this economically attractive for any rational miner.

**Detection**: The manipulation is difficult to detect without recalculating and comparing expected vs. actual signatures for each miner, which requires off-chain monitoring infrastructure.

### Recommendation

**Immediate Fix**: Enforce that the signature calculation must use the validated `previousInValue` variable, not the raw input:

In `AEDPoSContract_GetConsensusBlockExtraData.cs` lines 74-93, move the signature calculation inside the validation logic:

```csharp
if (triggerInformation.PreviousInValue != null &&
    triggerInformation.PreviousInValue != Hash.Empty)
{
    Context.LogDebug(
        () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
    // Self check.
    if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
        previousRound.RealTimeMinersInformation[pubkey].OutValue)
    {
        Context.LogDebug(() => "Failed to produce block at previous round?");
        previousInValue = Hash.Empty;
        signature = previousRound.CalculateSignature(Hash.Empty); // Use validated value
    }
    else
    {
        previousInValue = triggerInformation.PreviousInValue;
        signature = previousRound.CalculateSignature(previousInValue); // Use validated value
    }
}
```

**Additional Validation**: In `UpdateValueValidationProvider`, reject `Hash.Empty` as invalid when the miner was present in the previous round and should have a valid `previousInValue`:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

    // Require valid previousInValue if miner was in previous round
    if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return false;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == Hash.Empty) return false; // Reject Hash.Empty for existing miners

    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

**Test Cases**: Add regression tests verifying:
1. Miners cannot manipulate order by providing invalid `previousInValue`
2. Signature calculation always uses validated data
3. Block validation rejects `Hash.Empty` when proper reveal is expected
4. Order assignment remains deterministic and unpredictable

### Proof of Concept

**Initial State**:
- Round N-1 completed with Miner X having stored `OutValue_X = Hash(InValue_X)`
- Round N begins, Miner X is scheduled to mine
- Current miner list has `n` miners

**Attack Execution**:
1. Miner X retrieves `previousRound` from contract state
2. Computes `aggregatedSigs = XOR of all previousRound.RealTimeMinersInformation[*].Signature`
3. For candidate values `c = 0, 1, 2, ...`:
   - Computes `testSig = XOR(Hash(c), aggregatedSigs)`
   - Computes `order = (testSig.ToInt64() % n) + 1`
   - If `order == 1`, selects `c` as crafted `previousInValue`
4. During block production, provides `triggerInformation.PreviousInValue = Hash(c)` (which ≠ `InValue_X`)
5. `GetConsensusExtraDataToPublishOutValue` executes:
   - Validation fails: `Hash(Hash(c)) ≠ OutValue_X`
   - Sets `previousInValue = Hash.Empty`
   - BUT computes `signature = CalculateSignature(Hash(c))` using crafted value
6. `ApplyNormalConsensusData` sets `SupposedOrderOfNextRound = 1` based on crafted signature
7. Block validation passes because `previousInValue == Hash.Empty` is allowed
8. `UpdateValue` transaction persists the manipulated order

**Expected Result**: Miner X should have randomized order based on honest `InValue_X` reveal.

**Actual Result**: Miner X achieves order 1 (first position) in next round through signature manipulation.

**Success Condition**: Miner X consistently mines first in subsequent rounds by repeating the attack, gaining unfair MEV and fee advantages.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-93)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
