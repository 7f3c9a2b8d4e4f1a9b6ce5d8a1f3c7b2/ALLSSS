# Audit Report

## Title
Quadratic Voting Mechanism Fundamentally Broken Due to Per-VoteId Count Tracking

## Summary
The quadratic voting implementation fails to impose increasing costs for multiple votes because `QuadraticVotesCountMap` is keyed by unique `VoteId` instead of by (voter, voting item) pair. Each vote transaction generates a new `VoteId`, causing the count to always start at zero and charging only the base `TicketCost` for every vote, completely defeating the purpose of quadratic voting as a mechanism to prevent vote concentration.

## Finding Description

The quadratic voting feature increments a counter and calculates vote cost based on that count. [1](#0-0) 

However, the counter map uses `VoteId` as the key, [2](#0-1)  where each `VoteId` is uniquely generated per vote transaction using the current `VotesAmount` as a seed. [3](#0-2) 

**The Critical Flaw**:

When a user casts their first vote, `votingResult.VotesAmount` has some value X. The `VoteId` is generated as `Hash(X)`. The quadratic count for `Hash(X)` starts at 0, becomes 1, and the cost is `ticketCost * 1`.

After the vote is processed, `UpdateVotingResult` increases `VotesAmount`. [4](#0-3) 

When the same user casts their second vote, `votingResult.VotesAmount` is now X + previous_amount, producing a completely different `VoteId = Hash(X + previous_amount)`. Since this is a new key in `QuadraticVotesCountMap`, the count is again 0, increments to 1, and costs `ticketCost * 1`.

This pattern repeats for every subsequent vote - each gets a fresh `VoteId`, each starts the count at 0, and each costs only `ticketCost * 1`.

The `Withdraw` method does not decrement `QuadraticVotesCountMap` [5](#0-4)  but this is irrelevant since each new vote uses a different `VoteId` anyway.

## Impact Explanation

Quadratic voting is designed to prevent plutocratic governance by making vote accumulation exponentially expensive. The Nth vote should cost N times the `ticketCost`, resulting in a total cost of 1+2+3+...+N = N(N+1)/2 * ticketCost for N votes.

With this implementation, all N votes cost only N * ticketCost total.

**Concrete Example**:
- To cast 10 votes with ticketCost=100:
  - **Intended cost**: (1+2+3+...+10) * 100 = 5,500 tokens
  - **Actual cost**: 10 * 100 = 1,000 tokens
  - **Discount**: 82% savings for the attacker

This allows wealthy voters to buy voting power at linear cost instead of quadratic cost, enabling governance capture. Any voting item registered with `IsQuadratic = true` is vulnerable to this manipulation, undermining the fairness guarantee that quadratic voting is meant to provide.

## Likelihood Explanation

**Certainty: 100%** - This is a structural flaw, not a conditional exploit.

**Requirements**:
- Any user with sufficient token balance
- Access to the public `Vote` method
- A voting item registered with `IsQuadratic = true` and a `TicketCost` value

**Execution**:
1. User calls `Vote()` multiple times on the same quadratic voting item
2. Each call automatically generates a unique `VoteId` based on the changing `VotesAmount`
3. Each vote accesses a fresh entry in `QuadraticVotesCountMap`, always getting count=1
4. User pays only N * ticketCost for N votes instead of the intended N(N+1)/2 * ticketCost

**Evidence of No Protection**: Test coverage shows no quadratic voting tests exist - the `RegisterVotingItemAsync` helper never sets `IsQuadratic=true` or `TicketCost` fields. [6](#0-5) 

## Recommendation

Fix the quadratic vote counting mechanism by tracking cumulative votes per (voter, votingItemId) pair instead of per VoteId.

**Recommended Fix**:

1. Change the state variable from:
```csharp
public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
to:
```csharp
public MappedState<Address, Hash, long> QuadraticVotesCountMap { get; set; }
```

2. Update the Vote method logic to use voter address and voting item ID as the key:
```csharp
if (votingItem.IsQuadratic)
{
    var currentVotesCount = State.QuadraticVotesCountMap[input.Voter][input.VotingItemId].Add(1);
    State.QuadraticVotesCountMap[input.Voter][input.VotingItemId] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

3. Update the Withdraw method to decrement the count:
```csharp
if (votingItem.IsQuadratic)
{
    var currentCount = State.QuadraticVotesCountMap[votingRecord.Voter][votingRecord.VotingItemId];
    if (currentCount > 0)
    {
        State.QuadraticVotesCountMap[votingRecord.Voter][votingRecord.VotingItemId] = currentCount.Sub(1);
    }
}
```

This ensures that each voter's cumulative vote count on each voting item is properly tracked and costs increase quadratically as intended.

## Proof of Concept

```csharp
[Fact]
public async Task QuadraticVoting_Should_Increase_Cost_Per_Vote_But_Does_Not()
{
    // Register a quadratic voting item with ticket cost = 100
    var startTime = TimestampHelper.GetUtcNow();
    var input = new VotingRegisterInput
    {
        TotalSnapshotNumber = 1,
        EndTimestamp = startTime.AddDays(10),
        StartTimestamp = startTime,
        Options = { "Option1", "Option2" },
        AcceptedCurrency = TestTokenSymbol,
        IsLockToken = true,
        IsQuadratic = true,
        TicketCost = 100
    };
    
    await VoteContractStub.Register.SendAsync(input);
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(input), 
        HashHelper.ComputeFrom(DefaultSender));
    
    var voter = Accounts[1].KeyPair;
    var voterAddress = Accounts[1].Address;
    
    // Get initial balance
    var initialBalance = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Symbol = TestTokenSymbol, Owner = voterAddress });
    
    // Cast first vote - should cost 100 (1 * 100)
    await GetVoteContractTester(voter).Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0 // Amount is calculated by contract for quadratic voting
    });
    
    var balanceAfterVote1 = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Symbol = TestTokenSymbol, Owner = voterAddress });
    var cost1 = initialBalance.Balance - balanceAfterVote1.Balance;
    
    // Cast second vote - SHOULD cost 200 (2 * 100) but will cost 100 (1 * 100)
    await GetVoteContractTester(voter).Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0
    });
    
    var balanceAfterVote2 = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Symbol = TestTokenSymbol, Owner = voterAddress });
    var cost2 = balanceAfterVote1.Balance - balanceAfterVote2.Balance;
    
    // Cast third vote - SHOULD cost 300 (3 * 100) but will cost 100 (1 * 100)
    await GetVoteContractTester(voter).Vote.SendAsync(new VoteInput
    {
        VotingItemId = votingItemId,
        Option = "Option1",
        Amount = 0
    });
    
    var balanceAfterVote3 = await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Symbol = TestTokenSymbol, Owner = voterAddress });
    var cost3 = balanceAfterVote2.Balance - balanceAfterVote3.Balance;
    
    // VULNERABILITY: All three votes cost the same amount (100)
    // Expected: cost1=100, cost2=200, cost3=300
    // Actual: cost1=100, cost2=100, cost3=100
    cost1.ShouldBe(100); // PASSES - first vote costs 100 as expected
    cost2.ShouldBe(200); // FAILS - second vote costs 100, not 200
    cost3.ShouldBe(300); // FAILS - third vote costs 100, not 300
    
    // Total cost should be 600 (100+200+300) but is only 300 (100+100+100)
    var totalCost = initialBalance.Balance - balanceAfterVote3.Balance;
    totalCost.ShouldBe(600); // FAILS - proves vulnerability
}
```

This test demonstrates that quadratic voting costs remain constant at `ticketCost` for each vote instead of increasing as 1x, 2x, 3x, etc., proving the mechanism is broken.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L94-103)
```csharp
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```

**File:** test/AElf.Contracts.Vote.Tests/VoteContractTestHelper.cs (L28-50)
```csharp
    private async Task<VotingItem> RegisterVotingItemAsync(int lastingDays, int optionsCount, bool isLockToken,
        Address sender,
        int totalSnapshotNumber = int.MaxValue)
    {
        var startTime = TimestampHelper.GetUtcNow();
        var input = new VotingRegisterInput
        {
            TotalSnapshotNumber = totalSnapshotNumber,
            EndTimestamp = startTime.AddDays(lastingDays),
            StartTimestamp = startTime,
            Options = { GenerateOptions(optionsCount) },
            AcceptedCurrency = TestTokenSymbol,
            IsLockToken = isLockToken
        };
        var transactionResult = (await VoteContractStub.Register.SendAsync(input)).TransactionResult;
        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        input.Options.Clear();
        var votingItemId = HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sender));
        return await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = votingItemId
        });
    }
```
