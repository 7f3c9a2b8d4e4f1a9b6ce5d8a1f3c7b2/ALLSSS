### Title
Organization Member List Manipulation Allows Governance Bypass Through Post-Creation Vote Manipulation

### Summary
The Association contract does not snapshot the organization member list at proposal creation time. Instead, it dynamically checks membership against the current member list during both voting authorization and vote counting. This allows an organization to add new members who can vote on existing proposals or remove members to invalidate their already-cast votes, completely undermining the integrity of the governance system.

### Finding Description

The vulnerability exists across multiple functions in the Association contract with two critical flaws:

**Flaw 1: Dynamic Member List Check During Voting**

When a member attempts to vote on a proposal, the contract checks authorization against the current organization member list, not a snapshot from proposal creation time. [1](#0-0) 

**Flaw 2: Vote Counting Uses Current Member List**

When determining if a proposal meets the release threshold, the contract filters votes by checking if voters exist in the current organization member list:

- Rejection counting filters by current member list [2](#0-1) 
- Abstention counting filters by current member list [3](#0-2) 
- Approval counting filters by current member list [4](#0-3) 

**Root Cause: No Member List Snapshot**

The ProposalInfo structure stores only the organization address reference, not a snapshot of members at creation time. [5](#0-4) 

**Exploitation Path: Member List Modification Functions**

The organization can modify its member list after proposal creation through three functions:

- `AddMember` adds new members [6](#0-5) 
- `RemoveMember` removes existing members [7](#0-6) 
- `ChangeMember` replaces members [8](#0-7) 

These functions are callable by the organization itself (via proposal execution), allowing the organization to manipulate its membership during active proposal voting.

### Impact Explanation

**Critical Governance Compromise:**

1. **Vote Dilution Attack**: An organization with a pending controversial proposal can execute a separate proposal to add new members favorable to the outcome. These new members, who were not members when the proposal was created, can vote on the existing proposal. This violates the fundamental governance principle that voting rights are determined at proposal creation time.

2. **Vote Invalidation Attack**: An organization facing rejection of a proposal can execute a separate proposal to remove members who voted against it. When the original proposal's release threshold is checked, the removed members' votes are filtered out (don't count) because the vote counting logic checks against the current member list. This can flip a failing proposal into a passing one.

3. **Threshold Manipulation**: By strategically adding or removing members, an attacker can manipulate the effective voting thresholds. For example, a proposal requiring 3 out of 5 approvals with max 2 rejections could be manipulated by removing 3 rejecting members, making their rejection votes invisible to the threshold calculation. [9](#0-8) 

**Who is Affected:**
- All Association organizations and their proposals
- Any governance decisions made through Association contracts
- Stakeholders who voted based on the member list at proposal creation time

**Severity Justification:**
This is CRITICAL because it completely undermines the integrity of the governance system. An organization can retroactively change the outcome of any active proposal by manipulating membership, making the entire voting process unreliable.

### Likelihood Explanation

**High Likelihood - Easily Exploitable:**

**Attacker Capabilities Required:**
- Ability to execute at least one proposal to modify membership (standard organization capability)
- No special privileges beyond normal organization operation

**Attack Complexity:**
- Low complexity: Only requires creating and executing standard proposals
- The member modification functions are designed features, not exploits

**Feasibility Conditions:**
- Any organization with at least one proposal that can pass (to modify membership)
- Common scenario during normal operation

**Execution Steps:**
1. Propose and vote on controversial Proposal A (e.g., treasury fund allocation)
2. Before Proposal A is released, create Proposal B to add favorable members or remove opposing members
3. Execute Proposal B (modifies member list)
4. New members vote on Proposal A, or removed members' votes are invalidated
5. Proposal A now passes with manipulated vote count

**Detection Constraints:**
- The member list modifications are legitimate function calls
- No on-chain indication that this is malicious behavior
- Difficult for voters to detect timing-based manipulation

**Probability Assessment:**
High probability of exploitation in any contested governance scenario where controlling parties have enough votes to modify membership but not enough to pass the target proposal directly.

### Recommendation

**Immediate Fix: Snapshot Member List at Proposal Creation**

1. Modify the `ProposalInfo` structure to include a member list snapshot:
```protobuf
message ProposalInfo {
    // ... existing fields ...
    // Snapshot of organization members at proposal creation time
    OrganizationMemberList member_list_snapshot = 14;
}
```

2. Update `CreateNewProposal` function to capture the member list snapshot when creating proposals. [10](#0-9) 

3. Update voting authorization to check against the snapshot:
```csharp
AssertIsAuthorizedOrganizationMember(proposal.MemberListSnapshot, Context.Sender);
```

4. Update all vote counting functions to use the snapshot instead of the current organization member list:
   - Update rejection counting to use `proposal.MemberListSnapshot.Contains`
   - Update abstention counting to use `proposal.MemberListSnapshot.Contains`
   - Update approval counting to use `proposal.MemberListSnapshot.Contains`

**Additional Safeguards:**

5. Add a check in `AddMember`, `RemoveMember`, and `ChangeMember` to emit warnings or require additional confirmation when active proposals exist.

6. Add test cases:
   - Test that members added after proposal creation cannot vote
   - Test that members removed after voting still have their votes counted
   - Test that threshold calculations use the snapshot, not current list

### Proof of Concept

**Initial State:**
- Organization with 5 members: A, B, C, D, E
- Threshold: MinimalApprovalThreshold = 3, MaximalRejectionThreshold = 2

**Attack Scenario 1: Adding Members to Vote**

1. Member A creates Proposal X (requires 3 approvals)
2. Members A and B vote to approve (2 approvals)
3. Members C, D, E vote to reject (3 rejections, exceeds max of 2)
4. Proposal X cannot pass (too many rejections)
5. Organization executes a separate proposal to add Members F, G, H via `AddMember` [6](#0-5) 
6. New members F and G call `Approve` on Proposal X - this succeeds because authorization checks current member list [1](#0-0) 
7. Proposal X now has 4 approvals from current members (A, B, F, G)
8. When checking release threshold, vote counting uses current member list [4](#0-3) 
9. **Result**: Proposal X can now be released despite being rejected by the original member majority

**Attack Scenario 2: Removing Members to Invalidate Votes**

1. Member A creates Proposal Y
2. Members A and B vote to approve (2 approvals)
3. Members C, D, E vote to reject (3 rejections, exceeds max of 2)
4. Proposal Y cannot pass (MaximalRejectionThreshold = 2, but has 3 rejections)
5. Organization executes a separate proposal to remove Members C, D, E via `RemoveMember` [7](#0-6) 
6. Organization now has only members A and B
7. When checking release threshold for Proposal Y:
   - Rejection count: `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` = 0 (C, D, E removed) [2](#0-1) 
   - Approval count: 2 (A and B still in member list)
8. **Result**: Proposal Y can now be released because rejection votes were invalidated

**Expected vs Actual:**
- **Expected**: Votes cast by members at voting time should always count in threshold calculations
- **Actual**: Votes are filtered by current member list, allowing retroactive vote manipulation

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L127-128)
```csharp
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-51)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```
