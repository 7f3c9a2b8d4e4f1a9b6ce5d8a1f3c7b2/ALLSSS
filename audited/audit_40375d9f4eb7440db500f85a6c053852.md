### Title
Unauthorized Profit Scheme Creation Enables DoS and Fund Misallocation via Manager Address Manipulation

### Summary
The `CreateScheme` method in the Profit contract allows any caller to specify an arbitrary address as the scheme manager without authorization checks. This enables attackers to pollute a victim's `ManagingSchemeIds` list with unlimited fake schemes, causing critical system failures including Treasury initialization DoS, wrong scheme index access leading to potential fund misallocation, and unbounded storage bloat.

### Finding Description

The vulnerability exists in the `CreateScheme` method where the manager address is set from user input without verifying the caller has authorization: [1](#0-0) 

The code simply accepts whatever manager address is provided in the input, defaulting to `Context.Sender` only if none is specified. The scheme is then unconditionally added to the manager's scheme list: [2](#0-1) 

There is no authorization check that `Context.Sender == manager` or that the sender has permission from the manager. The scheme ID generation also depends on the manager's existing scheme count: [3](#0-2) 

This means each fake scheme created will have a unique ID and successfully append to the victim's list.

### Impact Explanation

**1. Treasury Initialization DoS (Critical):**

The Treasury contract's initialization explicitly expects exactly 7 schemes in its `ManagingSchemeIds`: [4](#0-3) 

If an attacker creates additional schemes with `Manager = TreasuryContractAddress` before initialization, this assertion fails and the Treasury cannot initialize, breaking the core economic system.

**2. Scheme Index Corruption (High):**

The Economic contract retrieves Treasury schemes by index without bounds validation: [5](#0-4) 

If attacker-created schemes are prepended to the list, these hardcoded indices `[0]`, `[3]`, `[4]` will point to wrong schemes, potentially causing:
- Wrong scheme IDs assigned to Election contract
- Profit distribution to incorrect schemes
- Fund misallocation or loss

**3. Storage DoS and Gas Exhaustion:**

The `GetManagingSchemeIds` view function returns the entire list: [6](#0-5) 

With unlimited fake schemes, this causes:
- Unbounded storage growth on victim's address
- High gas costs when querying the list
- Degraded system performance for legitimate operations

### Likelihood Explanation

**Reachability:** The `CreateScheme` method is a public, unrestricted entry point requiring no special permissions.

**Attack Cost:** Attacker only pays transaction fees to create each scheme. No approval or authorization required.

**Execution Practicality:** The attack is trivial to execute:
- Call `CreateScheme` with `CreateSchemeInput { Manager = victimAddress, ... }`
- Repeat as many times as desired
- Each call succeeds and appends to victim's list

**Detection:** The attack is difficult to prevent once deployed since there are no access controls on who can specify a manager address.

**Probability:** HIGH - The vulnerability is in production code with no mitigations. Critical system contracts (Treasury, Economic) are vulnerable during initialization and operation.

### Recommendation

**1. Add Authorization Check:**

Modify `CreateScheme` to require that either:
- `input.Manager` is null or empty (defaulting to `Context.Sender`), OR
- `Context.Sender == input.Manager`

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    // NEW: Verify authorization if manager is explicitly set
    if (input.Manager != null && input.Manager != Context.Sender)
    {
        Assert(false, "Only the manager address itself can create schemes on its behalf.");
    }
    
    // Rest of method...
}
```

**2. Add Scheme Count Limits:**

Implement a maximum schemes per manager limit to prevent unbounded growth:

```csharp
const int MaxSchemesPerManager = 100;
var currentCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
Assert(currentCount < MaxSchemesPerManager, "Maximum schemes per manager exceeded.");
```

**3. Add Regression Tests:**

Create test cases that verify:
- Non-manager cannot create schemes for another address
- Treasury initialization fails if extra schemes exist
- Economic contract fails with corrupted scheme indices

### Proof of Concept

**Initial State:**
- Treasury contract deployed but not initialized
- Attacker has normal user account

**Attack Steps:**

1. **Before Treasury Initialization:**
   ```
   Attacker calls: CreateScheme(new CreateSchemeInput { 
       Manager = TreasuryContractAddress,
       ProfitReceivingDuePeriodCount = 10
   })
   ```
   Repeat 5 times.

2. **Treasury Attempts Initialization:**
   ```
   TreasuryContract.InitialTreasuryContract() creates 7 schemes
   TreasuryContract.InitialMiningRewardProfitItem() calls GetManagingSchemeIds
   ```

**Expected Result:**
Treasury has 7 schemes, initialization succeeds.

**Actual Result:**
Treasury has 12 schemes (5 fake + 7 real), assertion `managingSchemeIds.Count == 7` fails, initialization reverts, Treasury contract permanently broken.

**Success Condition:**
The attack prevents Treasury initialization or causes wrong schemes to be used at specific indices, breaking the economic system.

### Notes

This vulnerability breaks a critical invariant: only authorized parties should be able to associate schemes with a manager address. The lack of authorization enables both denial-of-service attacks on system initialization and potential fund misallocation through index corruption. The issue affects all profit scheme managers, but has the most severe impact on system contracts (Treasury, Economic, Election) that rely on specific scheme counts and indices.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L57-57)
```csharp
        var manager = input.Manager ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L83-88)
```csharp
        var managingSchemeIds = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = Context.Self
        }).SchemeIds;

        Assert(managingSchemeIds.Count == 7, "Incorrect schemes count.");
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L191-205)
```csharp
        var schemeIdsManagingByTreasuryContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)
            }).SchemeIds;
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
