### Title
Unauthorized Creator Assignment Enables Privilege Escalation and Impersonation in NFT Protocol Creation

### Summary
The `Create()` function allows any caller to specify an arbitrary address as `input.Creator`, which becomes the token issuer and is automatically added to the minter list without validating that the creator consented to this role. This enables attackers to assign victim addresses as creators of malicious NFT protocols while simultaneously granting themselves minting privileges, leading to impersonation attacks and unauthorized NFT minting.

### Finding Description

The root cause is the absence of authorization validation in the `Create()` function. At line 22, the function accepts an arbitrary `input.Creator` address without verifying that `Context.Sender` (the transaction caller) has permission to assign this role: [1](#0-0) 

This creator address is then used as the token `Issuer` in the MultiToken contract: [2](#0-1) 

And is automatically added to the minter list: [3](#0-2) 

The creator role carries significant privileges. Only the creator can add or remove minters: [4](#0-3) [5](#0-4) 

Being in the minter list grants the ability to mint NFTs: [6](#0-5) 

The underlying MultiToken contract also fails to validate that the issuer must be the caller, accepting any address provided: [7](#0-6) 

**Why existing protections fail:**
- No check that `Context.Sender == input.Creator`
- No signature verification from the creator address
- The NFT contract is whitelisted in MultiToken, allowing it to create tokens with arbitrary issuers
- The protobuf definition allows the creator field to be optional, but doesn't document authorization requirements [8](#0-7) 

### Impact Explanation

**Concrete harm:**
1. **Unauthorized Privilege Assignment**: An attacker can assign any victim address as the creator of an NFT protocol without their consent, making the victim responsible for a protocol they never created.

2. **Attacker Gains Minting Rights**: The attacker can simultaneously add their own address to `input.MinterList`, gaining the ability to mint NFTs in a protocol that appears to be created by the victim.

3. **Impersonation and Reputation Damage**: The attacker can create malicious or low-quality NFT protocols that appear to be created by reputable addresses, enabling:
   - Phishing attacks using victim's reputation
   - Association of victim with scam NFT projects
   - Fraudulent NFT sales under victim's apparent endorsement

4. **Pre-emptive Minting Attack**: Before the victim discovers the unauthorized protocol, the attacker can mint and distribute NFTs, potentially profiting from the victim's reputation.

**Who is affected:**
- Any address can be targeted as an unwilling creator
- Users who trust the victim's address may be defrauded
- The protocol's reputation system is compromised

**Severity justification (HIGH):**
- Direct privilege escalation without victim consent
- Enables fraud and impersonation at scale
- No authentication or authorization barrier
- Victim detection may occur only after damage is done

### Likelihood Explanation

**Attacker capabilities required:**
- Ability to submit transactions to the NFT contract (publicly accessible)
- Knowledge of victim's address (publicly available)
- No special privileges or funds required beyond transaction fees

**Attack complexity:**
- Single transaction to `Create()` function
- Simple parameter manipulation: set `Creator = VictimAddress`, `MinterList = [AttackerAddress]`
- No timing requirements or race conditions

**Feasibility conditions:**
- Function is public and unrestricted
- NFT contract is whitelisted in MultiToken, bypassing seed NFT requirements
- No rate limiting or other defensive measures

**Detection constraints:**
- Victim has no notification mechanism for being assigned as creator
- Discovery likely occurs through manual monitoring or third-party alerts
- By the time victim detects and removes attacker from minter list, NFTs may already be minted and distributed

**Economic rationality:**
- Attack cost: minimal (only transaction fees)
- Potential profit: unlimited (mint NFTs using victim's reputation, sell before detection)
- Risk: low (no on-chain penalty for exploitation)

**Probability assessment: HIGH**
The attack is trivial to execute, costs almost nothing, and carries significant profit potential with minimal risk.

### Recommendation

**Immediate mitigation:**
Add authorization check in the `Create()` function to ensure only the creator address itself can be assigned as creator:

```csharp
public override StringValue Create(CreateInput input)
{
    Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
        "NFT Protocol can only be created at aelf mainchain.");
    MakeSureTokenContractAddressSet();
    MakeSureRandomNumberProviderContractAddressSet();
    
    // NEW: Validate creator authorization
    if (input.Creator != null)
    {
        Assert(input.Creator == Context.Sender, 
            "Cannot assign another address as creator. Creator must be the transaction sender.");
    }
    
    var creator = input.Creator ?? Context.Sender;
    // ... rest of function
}
```

**Alternative approach:**
Remove the `Creator` field from `CreateInput` entirely and always use `Context.Sender` as the creator:

```csharp
var creator = Context.Sender; // Remove input.Creator support entirely
```

**Invariant checks to add:**
- Enforce: `creator == Context.Sender` at protocol creation
- Add event logging when creator privileges are exercised (AddMinters, RemoveMinters)
- Consider requiring multi-sig or time-delay for creator transfers if needed

**Test cases to prevent regression:**
1. Test that `Create()` with `input.Creator != Context.Sender` fails with proper error message
2. Test that `Create()` with `input.Creator == null` succeeds with `Context.Sender` as creator
3. Test that `Create()` with `input.Creator == Context.Sender` succeeds
4. Add fuzzing test with random addresses for creator field

### Proof of Concept

**Initial state:**
- Attacker address: `0xAttacker`
- Victim address: `0xVictim` (a reputable NFT creator)
- Both have sufficient ELF for transaction fees

**Attack steps:**

1. Attacker submits transaction to `NFTContract.Create()`:
```
CreateInput {
    nft_type: "ART",
    protocol_name: "Victim's Premium Collection",
    total_supply: 10000,
    creator: 0xVictim,  // ← Victim address assigned without consent
    is_burnable: false,
    issue_chain_id: 9992731,
    base_uri: "ipfs://malicious/",
    minter_list: {
        value: [0xAttacker]  // ← Attacker adds themselves
    }
}
```

2. Transaction succeeds, creating protocol with symbol (e.g., "AR-1")

3. Check `GetNFTProtocolInfo(symbol)`:
   - `creator: 0xVictim` ✓ (victim is unwilling creator)
   
4. Check `GetMinterList(symbol)`:
   - Contains: `[0xVictim, 0xAttacker]` ✓ (both can mint)

5. Attacker calls `Mint()` to create NFTs:
```
MintInput {
    symbol: "AR-1",
    quantity: 100,
    owner: 0xAttacker,
    uri: "ipfs://malicious/fake-art"
}
```

6. Attacker lists minted NFTs for sale, claiming they are from "Victim's Premium Collection" created by `0xVictim`

**Expected result (secure):** 
Transaction in step 1 should fail with error: "Cannot assign another address as creator"

**Actual result (vulnerable):**
All steps succeed. Attacker has minted 100 NFTs in a protocol falsely attributed to the victim, enabling fraud and reputation damage.

**Success condition:**
The vulnerability is exploited if an NFT protocol exists where `creator != original transaction sender` and the attacker is in the minter list.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-33)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** protobuf/nft_contract.proto (L116-117)
```text
    // The address that created the token.
    aelf.Address creator = 4;
```
