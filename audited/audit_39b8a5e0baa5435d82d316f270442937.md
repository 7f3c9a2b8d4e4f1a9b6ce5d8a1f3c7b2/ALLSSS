# Audit Report

## Title
Permanent DOS in TokenHolder RemoveBeneficiary Due to Single() Assumption on Multiple Profit Details

## Summary
The `RemoveBeneficiary()` and `AddBeneficiary()` functions in TokenHolderContract use `.Single()` to retrieve profit details, incorrectly assuming each beneficiary has exactly one detail. When a partial removal occurs (reducing but not eliminating shares), the Profit contract creates multiple details, causing all subsequent removal or modification attempts to fail with `InvalidOperationException`, permanently locking tokens and disabling scheme management.

## Finding Description

TokenHolderContract contains two critical `.Single()` calls that assume beneficiaries have exactly one profit detail: [1](#0-0) [2](#0-1) 

However, the underlying Profit contract explicitly supports multiple details per beneficiary. When `RemoveBeneficiary()` performs a partial removal (where `lockedAmount > input.Amount && input.Amount != 0`), the following sequence occurs:

1. The beneficiary is completely removed from the Profit contract
2. If unclaimed profits exist, the Profit contract marks the old detail as removed (`IsWeightRemoved = true`) and shortens its `EndPeriod`, but keeps it in the list: [3](#0-2) 

3. TokenHolder then re-adds the beneficiary with reduced shares: [4](#0-3) 

4. Profit's `AddBeneficiary` creates a NEW detail and adds it to the existing list: [5](#0-4) 

Result: The beneficiary now has 2 profit details. This is explicitly validated by the official test case: [6](#0-5) 

Once multiple details exist, any subsequent call to `RemoveBeneficiary()` or `AddBeneficiary()` will throw `InvalidOperationException` because `.Single()` requires exactly one element. This also affects `Withdraw()`, which internally calls `RemoveBeneficiary()`: [7](#0-6) 

The default scheme configuration enables this behavior: [8](#0-7) 

## Impact Explanation

**HIGH SEVERITY - Permanent Fund Lock and Complete Operational DOS:**

1. **Permanent Token Lock**: Users who called `RegisterForProfits()` and locked tokens cannot call `Withdraw()` once they have multiple profit details. Their tokens remain permanently locked in the contract with no recovery mechanism.

2. **Complete Scheme Management Failure**: Scheme managers lose the ability to:
   - Remove beneficiaries via `RemoveBeneficiary()`
   - Update beneficiary shares via `AddBeneficiary()`
   - Manage their schemes in any capacity

3. **Widespread Affected Parties**:
   - All users who registered and locked tokens via `RegisterForProfits()`
   - All beneficiaries added by scheme managers via `AddBeneficiary()`
   - All scheme managers who need to manage their TokenHolder schemes

The impact is permanent because once the state is corrupted (2+ details), there is no contract method to fix it without direct state manipulation.

## Likelihood Explanation

**HIGH LIKELIHOOD - Easily Triggered Through Normal Operations:**

**Triggering Conditions:**
- Scheme manager permissions (normal role)
- Single function call: `RemoveBeneficiary(beneficiary, partialAmount)`
- Where `0 < partialAmount < totalShares`
- Default scheme setting `CanRemoveBeneficiaryDirectly = true` enables this

**Attack Complexity:** Trivial
1. Beneficiary exists with shares (e.g., 1000)
2. Call `RemoveBeneficiary(beneficiary, amount=10)`
3. Beneficiary now has 2 details and is permanently stuck

**Realistic Scenario:** This can occur unintentionally during legitimate operations when scheme managers try to gradually reduce (not fully remove) beneficiary shares - a natural use case for profit scheme management.

**No Preconditions Required:**
- No special state needed
- No timing requirements
- Works immediately after any beneficiary is added

## Recommendation

Replace all `.Single()` calls with logic that handles multiple profit details. For example:

```csharp
// In AddBeneficiary, line 46-56:
if (detail.Details.Any())
{
    // Get total shares across all details
    var totalShares = detail.Details.Sum(d => d.Shares);
    
    // Remove all existing details
    State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
    {
        SchemeId = scheme.SchemeId,
        Beneficiary = input.Beneficiary
    });
    
    shares.Add(totalShares);
}

// In RemoveBeneficiary, line 74-79:
var details = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
{
    Beneficiary = input.Beneficiary,
    SchemeId = scheme.SchemeId
}).Details;

var lockedAmount = details.Sum(d => d.Shares);
```

Alternatively, ensure the Profit contract fully removes all details when `RemoveBeneficiary` is called with `CanRemoveBeneficiaryDirectly = true`.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_DOS_After_Partial_Removal_Test()
{
    // Setup: Create scheme and add beneficiary
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 9999
    });
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Shares = 1000
    });
    
    // Trigger: Partial removal creates 2 details
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Amount = 10
    });
    
    // Verify: 2 details now exist
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        Beneficiary = Starter,
        SchemeId = schemeIds.SchemeIds[0]
    });
    profitAmount.Details.Count.ShouldBe(2); // Multiple details exist
    
    // Exploit: Next RemoveBeneficiary call fails with InvalidOperationException
    var result = await TokenHolderContractStub.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = 10
        });
    result.TransactionResult.Error.ShouldContain("Sequence contains more than one element");
    
    // Impact: User cannot withdraw tokens
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    withdrawResult.TransactionResult.Error.ShouldContain("Sequence contains more than one element");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L55-55)
```csharp
            shares.Add(detail.Details.Single().Shares);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L74-78)
```csharp
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L85-95)
```csharp
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L239-243)
```csharp
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L346-356)
```csharp
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L187-196)
```csharp
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
