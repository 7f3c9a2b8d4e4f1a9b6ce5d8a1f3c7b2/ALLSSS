### Title
Accounting Error: SymbolList Mismatch Causes Donated Tokens to Be Stuck in Treasury

### Summary
The Treasury contract's `Donate` function accepts any burnable token without checking the `SymbolList`, while the `Release` function only distributes tokens present in `SymbolList`. This mismatch causes donated tokens that are excluded from or removed from `SymbolList` to accumulate permanently in the treasury without being distributed, creating accounting discrepancies and fund loss for beneficiaries.

### Finding Description

The root cause is a validation mismatch between donation acceptance and distribution logic:

**Donation Acceptance** [1](#0-0) 

The `Donate` function only checks if a token is available for method fees (i.e., burnable), and does NOT validate against `SymbolList`. If the token cannot be converted to native via TokenConverter, it proceeds to contribute directly to the profit scheme [2](#0-1) .

**Distribution Logic** [3](#0-2) 

The `Release` function creates an `AmountsMap` using ONLY symbols from `SymbolList`, meaning only these tokens get distributed. The same applies to all sub-scheme distributions [4](#0-3) .

**Profit Distribution** [5](#0-4) 

The Profit contract's `DistributeProfits` only processes symbols present in the input `AmountsMap`. Symbols not in the map are never distributed.

**Query Function** [6](#0-5) 

The `GetUndistributedDividends` function also uses `SymbolList` to query balances, so tokens not in the list become invisible to accounting queries.

**SetSymbolList Validation** [7](#0-6) 

While `SetSymbolList` prevents removing the native token (line 285) and validates that non-native tokens are either available for method fees OR the treasury is in their whitelist (lines 301-303), there is no validation preventing removal of tokens that already have donated balances in the treasury.

### Impact Explanation

**Direct Fund Loss**: Donated tokens that are not in `SymbolList` accumulate in the treasury's virtual address but are never distributed to beneficiaries (miners, citizens, backup nodes). These funds become permanently stuck with no recovery mechanism.

**Accounting Discrepancy**: The actual treasury balance exceeds the reported undistributed balance from `GetUndistributedDividends`, breaking the accounting invariant that all donated funds should be distributable.

**Affected Parties**: 
- Donors lose their contributed tokens
- Beneficiaries lose rightful dividend distributions
- Treasury balance accounting becomes unreliable

**Severity Justification**: HIGH - This violates the critical invariant for "Economics & Treasury: donation/release logic, dividend distribution and settlement accuracy." Any burnable token can be donated and stuck, with no administrative recovery function available.

### Likelihood Explanation

**Attacker Capabilities**: No malicious intent required - this occurs through normal operations when governance modifies `SymbolList` or when users donate tokens not in the initial list.

**Attack Complexity**: LOW
1. Token X must be burnable (available for method fees)
2. Token X must not be convertible to native via TokenConverter
3. Either: Token X is never added to `SymbolList`, OR Token X is removed from `SymbolList` after receiving donations

**Feasibility Conditions**: HIGHLY FEASIBLE
- Many tokens may be burnable (method fee eligible) but not in `SymbolList`
- Governance regularly updates `SymbolList` for legitimate reasons (token deprecation, policy changes)
- No validation prevents this scenario

**Probability**: HIGH - This can easily happen accidentally during normal treasury governance operations when deprecating tokens or adjusting the supported token list.

### Recommendation

**Code-Level Mitigation**:
1. Add `SymbolList` validation in the `Donate` function:
```csharp
// After line 181 in TreasuryContract.cs
if (!isNativeSymbol && !canExchangeWithNativeSymbol)
{
    Assert(State.SymbolList.Value.Value.Contains(input.Symbol), 
        "Symbol must be in SymbolList to donate non-convertible tokens.");
}
```

2. Add validation in `SetSymbolList` to prevent removing tokens with existing treasury balance:
```csharp
// After line 308 in TreasuryContract.cs
foreach (var oldSymbol in State.SymbolList.Value.Value.Where(s => !input.Value.Contains(s)))
{
    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = State.TreasuryVirtualAddress.Value,
        Symbol = oldSymbol
    }).Balance;
    Assert(balance == 0, $"Cannot remove symbol {oldSymbol} with existing balance {balance}");
}
```

**Invariant Checks**:
- Enforce: All donated tokens (except convertible ones) must be in `SymbolList`
- Enforce: Tokens cannot be removed from `SymbolList` while treasury holds non-zero balance

**Test Cases**:
- Test donating a burnable token not in `SymbolList` (should fail)
- Test removing a token from `SymbolList` that has treasury balance (should fail)
- Test that all donated tokens appear in `GetUndistributedDividends`
- Test that `Release` distributes all symbols with treasury balance

### Proof of Concept

**Required Initial State**:
- Token "TESTTOKEN" is created with `IsBurnable = true`
- Token "TESTTOKEN" is NOT in SymbolList (initially only contains native "ELF")
- Token "TESTTOKEN" is NOT convertible to native (not registered in TokenConverter)

**Transaction Steps**:
1. User calls `Donate(symbol: "TESTTOKEN", amount: 1000)`
   - Check at line 181 passes (token is burnable)
   - Check at line 191 returns false (not convertible)
   - Donation proceeds through lines 210-223
   - Treasury balance increases by 1000 TESTTOKEN

2. Consensus contract calls `Release(periodNumber: N)`
   - Line 133 creates AmountsMap with only "ELF" (from SymbolList)
   - TESTTOKEN is NOT included in distribution
   - Treasury still holds 1000 TESTTOKEN

3. User calls `GetUndistributedDividends()`
   - Line 373 uses SymbolList which doesn't contain TESTTOKEN
   - Returns only ELF balance, omitting 1000 TESTTOKEN

**Expected vs Actual Result**:
- **Expected**: Donated TESTTOKEN should be distributed to beneficiaries OR donation should fail
- **Actual**: TESTTOKEN is accepted, stored in treasury, but never distributed and not reported in undistributed dividends

**Success Condition**: Treasury balance of TESTTOKEN > 0 AND TESTTOKEN not in distribution AmountsMap AND TESTTOKEN not in GetUndistributedDividends result, confirming accounting error.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L123-133)
```csharp
    public override Empty Release(ReleaseInput input)
    {
        RequireAEDPoSContractStateSet();
        Assert(
            Context.Sender == State.AEDPoSContract.Value,
            "Only AElf Consensus Contract can release profits from Treasury.");
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L174-182)
```csharp
    public override Empty Donate(DonateInput input)
    {
        Assert(input.Amount > 0, "Invalid amount of donating. Amount needs to be greater than 0.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L210-223)
```csharp
        {
            State.TokenContract.Approve.Send(new ApproveInput
            {
                Symbol = input.Symbol,
                Amount = input.Amount,
                Spender = State.ProfitContract.Value
            });

            State.ProfitContract.ContributeProfits.Send(new ContributeProfitsInput
            {
                SchemeId = State.TreasuryHash.Value,
                Symbol = input.Symbol,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-310)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L367-380)
```csharp
    public override Dividends GetUndistributedDividends(Empty input)
    {
        return new Dividends
        {
            Value =
            {
                State.SymbolList.Value.Value.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = State.TreasuryVirtualAddress.Value,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L705-735)
```csharp
    private void ReleaseTreasurySubProfitItems(long termNumber)
    {
        var amountsMap = State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.RewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.BasicRewardHash.Value,
            Period = termNumber,
            AmountsMap = { amountsMap }
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-446)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
```
