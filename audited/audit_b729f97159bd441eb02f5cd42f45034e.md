### Title
EnableConnector DepositBalance Overwrite Vulnerability Leading to Fund Lock and Sell DoS

### Summary
The `EnableConnector` function directly overwrites `State.DepositBalance[toConnector.Symbol]` with a newly calculated value, completely ignoring any existing balance accumulated from previous buy transactions. This allows an attacker to repeatedly call `EnableConnector` on already-enabled connectors, causing accumulated base tokens to become unaccounted for and permanently locking user funds while disabling sell functionality.

### Finding Description

The vulnerability exists in the `EnableConnector` function where `State.DepositBalance` is directly assigned rather than incremented: [1](#0-0) 

**Root Cause:**

The function performs a direct assignment (`=`) instead of an addition (`.Add()`) operation, completely overwriting any existing deposit balance. When users buy tokens, the `Buy` function correctly increments `DepositBalance`: [2](#0-1) 

However, `EnableConnector` resets this accumulated value to whatever `GetNeededDeposit` calculates, without considering the current balance.

**Missing Protections:**

1. **No duplicate call prevention**: Unlike `UpdateConnector`, which checks if the connector is already enabled, `EnableConnector` has no such validation: [3](#0-2) 

2. **No authorization requirement**: `EnableConnector` is publicly callable with no `AssertPerformedByConnectorController()` check, unlike other critical functions: [4](#0-3) 

3. **Manipulable calculation**: The `needDeposit.NeedAmount` is calculated by `GetNeededDeposit` based on tokens outside the contract. An attacker can manipulate this by setting `AmountToTokenConvert` appropriately: [5](#0-4) 

**Execution Path:** [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**

When `DepositBalance` is overwritten to a value lower than the actual accumulated balance, the difference becomes permanently locked in the contract. For example:
- Initial `DepositBalance = 1000` base tokens after first `EnableConnector`
- Users buy tokens, accumulating `DepositBalance = 5000` base tokens
- Attacker calls `EnableConnector` with crafted parameters making `needDeposit = 100`
- `DepositBalance` overwritten to `100`
- **4900 base tokens are now unaccounted for and locked**

**Operational Impact:**

The `Sell` function subtracts from `DepositBalance` when users sell tokens: [7](#0-6) 

With `DepositBalance = 100` but actual contract balance of `5000`, users attempting to sell tokens worth more than 100 base tokens will face transaction failures due to arithmetic underflow, causing **complete DoS of sell functionality**.

**Who is Affected:**

- All token holders who purchased through `Buy` and wish to sell back
- The protocol's trading functionality and liquidity
- New users unable to enable legitimate connectors if base tokens are depleted

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call `EnableConnector` (public, no authorization)
- Attacker needs to own or obtain the resource tokens specified in `AmountToTokenConvert`
- No special privileges required

**Attack Complexity:**
Low. The attacker simply:
1. Identifies an active connector pair with accumulated `DepositBalance`
2. Calculates the appropriate `AmountToTokenConvert` value to minimize `needDeposit`
3. Calls `EnableConnector` with these parameters
4. Transfers minimal base tokens (possibly zero if `needDeposit = 0`)

**Feasibility Conditions:**
- Connector must be previously enabled (common scenario)
- Some users must have bought tokens (highly likely in active markets)
- Attacker needs access to some resource tokens (obtainable through initial purchase or issuance)

**Economic Rationality:**
The attack cost is minimal (just the `AmountToTokenConvert` tokens transferred, which remain in the contract), while the impact is severe (locking potentially large amounts of base tokens and disabling sell functionality). The attacker could even profit if they:
- Short the affected token before attacking
- Hold resource tokens they wish to prevent others from selling
- Seek to manipulate prices by removing sell liquidity

**Detection Constraints:**
The attack appears as a legitimate `EnableConnector` call in transaction logs, making detection difficult without specifically monitoring for duplicate enable calls.

### Recommendation

**Immediate Fix:**

1. Add a check to prevent calling `EnableConnector` on already-enabled connectors:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    
    // ADD THIS CHECK
    Assert(!fromConnector.IsPurchaseEnabled, 
        "Connector is already enabled and cannot be re-enabled.");
    
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    Assert(!toConnector.IsPurchaseEnabled, 
        "Connector is already enabled and cannot be re-enabled.");
    
    // ... rest of function
```

2. Change the DepositBalance assignment to addition if re-enabling must be supported:

```csharp
// Instead of: State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

3. Add authorization requirement:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    AssertPerformedByConnectorController();
    // ... rest of function
```

4. **Additional bug fix**: Save connector state after modifying `IsPurchaseEnabled`:

```csharp
State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
toConnector.IsPurchaseEnabled = true;
fromConnector.IsPurchaseEnabled = true;

// ADD THESE LINES
State.Connectors[toConnector.Symbol] = toConnector;
State.Connectors[fromConnector.Symbol] = fromConnector;

return new Empty();
```

**Invariant Checks:**
- `EnableConnector` should only succeed once per connector pair
- `DepositBalance` should never decrease except through legitimate `Sell` operations
- Sum of `DepositBalance` across all connectors should not exceed total base token balance in contract

**Test Cases:**
- Test calling `EnableConnector` twice on the same connector (should fail)
- Test `DepositBalance` preservation after buy operations
- Test unauthorized user attempting to call `EnableConnector` (should fail if auth added)
- Verify `IsPurchaseEnabled` persists after `EnableConnector` call

### Proof of Concept

**Initial State:**
- Connector pair created for token "ABC" via `AddPairConnector`
- Total supply: 10,000 ABC tokens
- All tokens initially in contract

**Transaction Sequence:**

1. **First EnableConnector (Legitimate):**
   - User1 calls `EnableConnector({TokenSymbol: "ABC", AmountToTokenConvert: 10000})`
   - `GetNeededDeposit` calculates: `amountOutOfTokenConvert = 10000 - 10000 - 10000 = -10000` â†’ clamps to 0
   - `needDeposit.NeedAmount = 0`
   - `State.DepositBalance["(NT)ABC"] = 0`
   - Result: Connector enabled with `DepositBalance = 0`

2. **Legitimate Trading:**
   - User2 calls `Buy({Symbol: "ABC", Amount: 5000})`, pays 500 base tokens
   - `State.DepositBalance["(NT)ABC"] = 0 + 500 = 500`
   - User3 calls `Buy({Symbol: "ABC", Amount: 3000})`, pays 300 base tokens
   - `State.DepositBalance["(NT)ABC"] = 500 + 300 = 800`
   - Current state: `DepositBalance = 800`, actual contract balance = 800

3. **Attack - Second EnableConnector:**
   - Attacker owns 1000 ABC tokens (purchased earlier)
   - Attacker calls `EnableConnector({TokenSymbol: "ABC", AmountToTokenConvert: 8000})`
   - Current token distribution: 2000 in contract, 8000 held by users
   - `GetNeededDeposit` calculates: `amountOutOfTokenConvert = 10000 - 2000 - 8000 = 0`
   - `needDeposit.NeedAmount = 0`
   - Attacker transfers 8000 ABC tokens to contract (line 287-295)
   - **Line 297 executes: `State.DepositBalance["(NT)ABC"] = 0`**
   - Result: `DepositBalance` reset to 0

**Expected vs Actual Result:**
- **Expected:** `DepositBalance` should remain 800 or increase
- **Actual:** `DepositBalance = 0`, while contract still holds 800 base tokens
- **Impact:** 800 base tokens are now unaccounted for and locked

**Success Condition:**
Users attempting to sell ABC tokens will fail when the sell amount would require more than 0 base tokens (which is immediately), causing complete DoS. The 800 base tokens are permanently locked as the accounting layer shows a balance of 0.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L60-60)
```csharp
        AssertPerformedByConnectorController();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
