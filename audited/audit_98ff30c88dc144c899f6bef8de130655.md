### Title
Arithmetic Overflow in Profit Calculation Due to Unbounded Beneficiary Shares Value

### Summary
The Profit contract lacks upper bound validation on beneficiary shares values, allowing scheme managers to set shares up to `long.MaxValue`. When combined with realistic profit distribution amounts exceeding ~8.6 billion base units, the decimal multiplication in `SafeCalculateProfits` overflows `decimal.MaxValue`, causing `ClaimProfits` to fail with `OverflowException` and permanently locking beneficiaries' profits.

### Finding Description

**Validation Gap:**
The `AssertValidInput` method only validates that shares are non-negative, with no upper bound check: [1](#0-0) 

This allows scheme managers to add beneficiaries with shares values up to `long.MaxValue` (9,223,372,036,854,775,807): [2](#0-1) 

**Root Cause - Overflow in Profit Calculation:**
The `SafeCalculateProfits` method performs multiplication before division: [3](#0-2) 

The critical operation `decimalTotalAmount * decimalShares` occurs before division by `decimalTotalShares`. When:
- `shares` ≈ `long.MaxValue` (9.2 × 10^18)
- `totalAmount` > 8.6 billion base units (8.6 × 10^9)
- Product: 9.2 × 10^18 × 8.6 × 10^9 ≈ 7.9 × 10^28

This exceeds `decimal.MaxValue` (approximately 7.9 × 10^28), causing `OverflowException`.

**Execution Path:**
When beneficiaries attempt to claim profits, the calculation is triggered: [4](#0-3) 

The overflow occurs at line 873 where `SafeCalculateProfits` is invoked with the large shares value.

**Authorization Context:**
Only scheme managers or the TokenHolder contract can add beneficiaries: [5](#0-4) 

However, profit contributions are unrestricted - anyone can contribute any amount: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact - Locked Profits:**
Beneficiaries with large shares values cannot claim their profits when the overflow condition is triggered. Since `ClaimProfits` throws `OverflowException`, the transaction fails and profits remain permanently locked in the scheme's virtual address.

**Quantified Scenario:**
- A scheme with one beneficiary having `shares = long.MaxValue`
- Profit distribution of 10 billion base units (equivalent to 100 tokens with 8 decimals)
- Calculation: `9.2 × 10^18 × 10^10 = 9.2 × 10^28` exceeds `decimal.MaxValue`
- Result: All profits for this period become unclaimable

**Affected Parties:**
1. **Beneficiaries**: Cannot withdraw earned profits, suffering direct financial loss
2. **Scheme Integrity**: Distribution mechanism breaks, requiring scheme recreation
3. **Token Holders**: If scheme is used for staking/voting rewards, participants cannot receive dividends

**Severity Justification:**
- High severity due to permanent loss of funds access
- Affects core economics and reward distribution functionality
- No recovery mechanism exists once overflow condition is met

### Likelihood Explanation

**Attacker Capabilities:**
- Requires scheme manager role (trusted position, but can act maliciously or negligently)
- No additional privileges needed beyond legitimate manager access
- Can be triggered accidentally through misconfiguration

**Attack Complexity:**
Low complexity with two simple steps:
1. Manager adds beneficiary with very large shares value (single transaction)
2. Wait for or trigger large profit distribution (may occur naturally)

**Feasibility Conditions:**
- **Realistic Token Amounts**: Many blockchain tokens have supplies in trillions with 8-18 decimal places. Distributing 10+ billion base units is common for:
  - Staking rewards from large validator pools
  - Treasury distributions from accumulated fees
  - Cross-chain bridge rewards
  - Token holder dividend schemes

- **No External Dependencies**: Exploit relies solely on profit contract state, no oracle or timing dependencies

**Economic Rationality:**
- Zero cost attack for malicious manager (no tokens spent)
- Natural occurrence probability is moderate-to-high in active schemes
- Economic incentive exists if manager wants to DoS competitor schemes

**Detection/Operational Constraints:**
- Difficult to detect before overflow occurs
- No warning mechanism for approaching dangerous shares values
- Once triggered, scheme is effectively bricked for that period

### Recommendation

**1. Add Maximum Shares Validation:**
Modify `AssertValidInput` to enforce reasonable upper bound: [1](#0-0) 

Add check: `Assert(input.BeneficiaryShare?.Shares <= MAX_SAFE_SHARES, "Shares exceed maximum safe value.");`

Calculate `MAX_SAFE_SHARES` as: `decimal.MaxValue / (expected_max_distribution_amount) - safety_margin`

For example, if maximum expected distribution is 1 trillion base units: `MAX_SAFE_SHARES = 7.9 × 10^28 / 10^12 / 10 = 7.9 × 10^15`

**2. Refactor Calculation Order:**
Modify `SafeCalculateProfits` to divide before multiplying when safe: [3](#0-2) 

Consider using `BigInteger` for intermediate calculations or restructure as:
```
if (totalShares > shares) {
    return (long)((decimal)totalAmount / totalShares * shares);
} else {
    return (long)((decimal)totalAmount * shares / totalShares);
}
```

**3. Add Input Validation Test:**
Create test case verifying `AddBeneficiary` rejects excessive shares values and that profit calculations handle large but valid values correctly.

### Proof of Concept

**Initial State:**
- Scheme exists with manager account
- Scheme has `TotalShares = 0`
- Token contract has sufficient balance

**Exploitation Steps:**

1. **Manager adds beneficiary with maximum shares:**
   ```
   AddBeneficiary({
       SchemeId: target_scheme,
       BeneficiaryShare: {
           Beneficiary: attacker_address,
           Shares: 9223372036854775807  // long.MaxValue
       },
       EndPeriod: 0
   })
   ```
   - Transaction succeeds
   - Scheme TotalShares becomes `long.MaxValue`

2. **Contribute large profit amount:**
   ```
   ContributeProfits({
       SchemeId: target_scheme,
       Amount: 10000000000,  // 10 billion base units
       Period: 1,
       Symbol: "ELF"
   })
   ```
   - Transaction succeeds
   - Profits added to scheme period 1

3. **Manager distributes profits:**
   ```
   DistributeProfits({
       SchemeId: target_scheme,
       Period: 1,
       AmountsMap: {"ELF": 10000000000}
   })
   ```
   - Transaction succeeds
   - Period marked as released

4. **Beneficiary attempts to claim:**
   ```
   ClaimProfits({
       SchemeId: target_scheme,
       Beneficiary: attacker_address
   })
   ```
   - **Expected**: Transfer 10 billion tokens to beneficiary (100% of shares)
   - **Actual**: `OverflowException` thrown at `SafeCalculateProfits` line 961
   - Transaction fails, profits remain locked

**Success Condition for Vulnerability:**
`ClaimProfits` transaction fails with overflow exception, demonstrating that profits are unclaimable despite being legitimately earned.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-920)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());

                        Context.Fire(new ProfitsClaimed
                        {
                            Beneficiary = beneficiary,
                            Symbol = symbol,
                            Amount = amount,
                            ClaimerShares = detailToPrint.Shares,
                            TotalShares = distributedProfitsInformation.TotalShares,
                            Period = periodToPrint
                        });
                    }

                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;

        return profitsMap;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
