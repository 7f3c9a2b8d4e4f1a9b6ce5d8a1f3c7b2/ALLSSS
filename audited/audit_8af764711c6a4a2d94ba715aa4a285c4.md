# Audit Report

## Title
Extra Block Producer Receives Regular Time Slot Instead of Extra Block Slot When Distance is Non-Positive

## Summary
The `ArrangeAbnormalMiningTime` method contains a logic error where the extra block producer's special handling only returns when distance > 0. When the extra block producer misses their time slot by more than one mining interval (distance ≤ 0), execution falls through to generic time slot calculation that assigns a regular Order-based time slot instead of the proper extra block time slot. This causes duplicate time slot assignments and consensus conflicts.

## Finding Description

The vulnerability exists in the `ArrangeAbnormalMiningTime` method where special handling for the extra block producer fails to cover all cases: [1](#0-0) 

When `distance <= 0` (meaning the extra block time has passed by more than one mining interval), the condition `if (distance > 0)` evaluates to false, so no return statement executes. Execution then falls through to the generic calculation: [2](#0-1) 

This fallthrough calculation uses `minerInRound.Order` to compute a time slot as if the extra block producer were a regular miner in a future round. However, the extra block producer's role is to produce a block at the END of the round (after all regular miners), not at their Order position.

The extra block mining time should be calculated as the last miner's time plus one interval: [3](#0-2) 

This method is called by `TerminateRoundCommandStrategy` to arrange mining time for extra block production: [4](#0-3) [5](#0-4) 

The consensus command indicates `NextRound` or `NextTerm` behavior, meaning the miner should produce an extra block to terminate the round. However, the arranged time is a regular slot that may conflict with another miner's expected time in that future round.

During round generation, miners are assigned Orders from 1 to N, and each Order corresponds to a specific time slot: [6](#0-5) 

When the extra block producer is assigned `futureRoundStartTime + Order * miningInterval`, this is the SAME time that will be assigned to the regular miner with that Order in the future round, creating a duplicate time slot assignment.

The total round time calculation confirms that extra blocks should be produced AFTER all regular miners: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Compromise:**
Two miners can be assigned the same time slot: the extra block producer (via the fallthrough calculation in `ArrangeAbnormalMiningTime`) and another miner with the same Order in the future round (via normal round generation logic). This creates a race condition where both miners attempt to produce blocks simultaneously at time T.

**Round Termination Disruption:**
Extra block production is critical for round termination and confirming the next round's mining order. Assigning the wrong time slot type (regular position-based slot instead of extra block slot) prevents proper round termination. The extra block producer will attempt to mine at a time slot that conflicts with a regular miner, potentially causing validation failures or consensus delays.

**Validation Gaps:**
The existing validation providers do not catch this issue:
- `TimeSlotValidationProvider` only validates within the current round
- `MiningPermissionValidationProvider` only checks if miner is in the miner list
- `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` validate round numbers but not time slot conflicts [8](#0-7) 

**Affected Parties:**
All network participants suffer from consensus disruption when the extra block producer's slot assignment conflicts with regular miners, potentially causing chain progression delays.

## Likelihood Explanation

**Triggering Conditions:**
The vulnerability triggers when:
1. The extra block producer calls `ArrangeAbnormalMiningTime` (via consensus command generation)
2. `mustExceededCurrentRound = false` (default for `ArrangeExtraBlockMiningTime`)
3. `currentBlockTime >= GetExtraBlockMiningTime() + miningInterval` (distance ≤ 0)

**Realistic Scenarios:**
- Network delays causing the extra block producer to miss their time slot by more than one mining interval
- Node downtime or synchronization issues during network instability
- High network latency during peak loads
- These are normal operational conditions documented in the method comments as expected scenarios [9](#0-8) 

**No Attacker Required:**
This is not an attack scenario but a natural consequence of network conditions and timing. The vulnerability manifests during legitimate consensus operations when network variability causes delays.

**Probability:**
Medium to High - occurs whenever the extra block producer experiences delays exceeding one mining interval, which can happen in production networks with variable latency or node availability issues.

## Recommendation

Add an explicit return statement for the extra block producer when distance ≤ 0 to prevent fallthrough to the generic calculation:

```csharp
if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
{
    var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
        .Milliseconds();
    if (distance > 0) return GetExtraBlockMiningTime();
    
    // Add explicit handling for distance <= 0
    // Calculate a proper extra block time in a future round
    var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
    var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
    var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
    // Extra block should be AFTER all regular miners (N miners * interval + 1 extra interval)
    return futureRoundStartTime.AddMilliseconds(TotalMilliseconds(miningInterval) - miningInterval);
}
```

This ensures the extra block producer is always assigned a time slot at the END of the round, not at their Order position.

## Proof of Concept

```csharp
[Fact]
public void ExtraBlockProducer_MissedSlot_ReceivesWrongTimeSlot()
{
    // Setup: Round with 5 miners, last miner is extra block producer with Order=3
    var round = GenerateTestRound(5);
    var extraBlockProducer = round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer);
    var extraBlockProducerPubkey = extraBlockProducer.Pubkey;
    var minerOrder = extraBlockProducer.Order; // e.g., Order = 3
    
    var miningInterval = round.GetMiningInterval();
    var extraBlockTime = round.GetExtraBlockMiningTime();
    
    // Simulate: Current time is AFTER extra block time + one full interval
    var currentBlockTime = extraBlockTime.AddMilliseconds(miningInterval + 1000);
    
    // Execute: ArrangeAbnormalMiningTime with mustExceededCurrentRound = false
    var arrangedTime = round.ArrangeAbnormalMiningTime(
        extraBlockProducerPubkey, 
        currentBlockTime, 
        mustExceededCurrentRound: false
    );
    
    // Verify vulnerability: Arranged time uses Order-based calculation
    var distanceToRoundStart = (currentBlockTime - round.GetRoundStartTime()).Milliseconds();
    var missedRounds = distanceToRoundStart / round.TotalMilliseconds(miningInterval);
    var expectedFutureRoundStart = round.GetRoundStartTime()
        .AddMilliseconds((missedRounds + 1) * round.TotalMilliseconds(miningInterval));
    var wrongTime = expectedFutureRoundStart.AddMilliseconds(minerOrder * miningInterval);
    
    // This should NOT be the arranged time for extra block producer
    Assert.Equal(wrongTime, arrangedTime);
    
    // The correct time should be AFTER all regular miners
    var correctExtraBlockTime = expectedFutureRoundStart
        .AddMilliseconds(round.TotalMilliseconds(miningInterval) - miningInterval);
    
    // Demonstrates the bug: arranged time is a regular slot, not extra block slot
    Assert.NotEqual(correctExtraBlockTime, arrangedTime);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L11-17)
```csharp
    /// <summary>
    ///     If one node produced block this round or missed his time slot,
    ///     whatever how long he missed, we can give him a consensus command with new time slot
    ///     to produce a block (for terminating current round and start new round).
    ///     The schedule generated by this command will be cancelled
    ///     if this node executed blocks from other nodes.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-73)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
    /// </summary>
    /// <param name="miningInterval"></param>
    /// <returns></returns>
    public int TotalMilliseconds(int miningInterval = 0)
    {
        if (miningInterval == 0) miningInterval = GetMiningInterval();

        return RealTimeMinersInformation.Count * miningInterval + miningInterval;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L22-25)
```csharp
        public static Timestamp ArrangeExtraBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return round.ArrangeAbnormalMiningTime(pubkey, currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-91)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
