### Title
Inadequate Validation Allows Time Slot Collisions via Duplicate FinalOrderOfNextRound Values

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly validates uniqueness of `FinalOrderOfNextRound` values by calling `.Distinct()` on `MinerInRound` objects instead of on the order values themselves. This allows miners to set duplicate `FinalOrderOfNextRound` values through `TuneOrderInformation` or direct assignment, resulting in multiple miners having identical `ExpectedMiningTime` slots in the next round and causing consensus failures.

### Finding Description

The vulnerability exists in the validation logic that checks the uniqueness of mining orders for the next round: [1](#0-0) 

The code calls `.Distinct()` on a collection of `MinerInRound` objects. Since `MinerInRound` is a protobuf-generated message type [2](#0-1) , its auto-generated `Equals()` method compares all 17 fields including the unique `pubkey` field (field 9). This means two `MinerInRound` objects are never considered equal even if they have identical `FinalOrderOfNextRound` values, causing the validation to always pass regardless of duplicate order values.

**Attack Vector 1 - Via TuneOrderInformation:**
During the `UpdateValue` transaction, miners can directly manipulate other miners' `FinalOrderOfNextRound` values through `TuneOrderInformation`: [3](#0-2) 

This assignment has no validation ensuring uniqueness of the assigned order values.

**Attack Vector 2 - Via Direct Assignment:**
Miners can also set their own `FinalOrderOfNextRound` directly from input: [4](#0-3) 

**Consequence - Time Slot Collision:**
When generating the next round, these duplicate `FinalOrderOfNextRound` values are used to calculate mining time slots: [5](#0-4) 

The `ExpectedMiningTime` is calculated as `currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order))`. If multiple miners have the same `order` (FinalOrderOfNextRound), they receive identical `ExpectedMiningTime` values, causing time slot collisions.

The validation provider is only invoked during `NextRound` behavior: [6](#0-5) 

However, by this point, the malicious `FinalOrderOfNextRound` values have already been set in state during previous `UpdateValue` transactions.

### Impact Explanation

**Consensus Integrity Violation:**
- Multiple miners receive the same `ExpectedMiningTime`, creating ambiguity about which miner should produce blocks at that time slot
- This breaks the fundamental assumption of the AEDPoS consensus mechanism that each miner has a unique, non-overlapping time slot
- Can lead to simultaneous block production attempts, fork creation, and consensus deadlock

**Operational Impact:**
- Network becomes unable to reliably produce blocks due to mining time conflicts
- Block production may stall entirely if all miners are assigned to colliding slots
- Requires manual intervention or chain restart to recover

**Severity: HIGH** - This directly compromises the core consensus mechanism's ability to function, affecting the entire network's operation.

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner can execute this attack during their legitimate mining turn
- No special privileges required beyond being in the current miner set
- Attack can be executed via the standard `UpdateValue` transaction

**Attack Complexity: LOW**
- Single transaction can set duplicate orders for multiple miners via `TuneOrderInformation`
- Alternatively, colluding miners can each set their own `FinalOrderOfNextRound` to the same value
- No complex timing or state manipulation required

**Feasibility Conditions:**
- Attacker must be an active miner (part of current round)
- Standard `UpdateValue` transaction execution rights
- Validation logic incorrectly passes duplicate values

**Detection:**
- Attack may not be immediately obvious as the validation appears to check for duplicates
- Impact becomes visible in next round when multiple miners attempt to mine at same time
- By then, malicious round data is already committed to state

**Probability: HIGH** - The attack is straightforward to execute, requires only miner privileges (which elected miners have), and the broken validation provides a false sense of security while allowing the attack through.

### Recommendation

**Code-Level Mitigation:**
Replace the validation logic to check uniqueness of order values, not object instances:

```csharp
// In NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()
var minersWithOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .ToList();
    
var distinctOrderCount = minersWithOrders
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
    
var minersWhoMinedCount = providedRound.RealTimeMinersInformation.Values
    .Count(m => m.OutValue != null);

if (distinctOrderCount != minersWhoMinedCount || distinctOrderCount != minersWithOrders.Count)
{
    validationResult.Message = "Invalid FinalOrderOfNextRound: duplicate order values detected.";
    return validationResult;
}
```

**Additional Invariant Checks:**
1. Add validation in `ProcessUpdateValue` to reject `TuneOrderInformation` containing duplicate values
2. Verify order values are within valid range [1, minersCount]
3. Add validation that all orders from 1 to minersCount are assigned exactly once

**Test Cases:**
1. Test that provides duplicate `FinalOrderOfNextRound` values and expects validation failure
2. Test that miners cannot use `TuneOrderInformation` to create duplicate orders
3. Test that time slots generated from orders are unique and non-overlapping
4. Test with edge cases: all miners same order, sequential miners same order, random duplicates

### Proof of Concept

**Required Initial State:**
- Active blockchain with multiple miners in current round (e.g., 7 miners)
- Current round where miners have produced blocks and set their signatures/out values

**Attack Sequence:**

**Step 1:** Malicious Miner A produces block via `UpdateValue` transaction with crafted input:
```
UpdateValueInput {
  OutValue: <valid_hash>,
  Signature: <valid_hash>,
  SupposedOrderOfNextRound: 3,  // Set own order to 3
  TuneOrderInformation: {
    "MinerB_Pubkey": 3,  // Set Miner B to same order
    "MinerC_Pubkey": 3,  // Set Miner C to same order  
    "MinerD_Pubkey": 3   // Set Miner D to same order
  },
  ... // other valid fields
}
```

**Step 2:** Transaction processes through `ProcessUpdateValue`:
- Line 247 sets Miner A's `FinalOrderOfNextRound = 3`
- Lines 259-260 set Miners B, C, D's `FinalOrderOfNextRound = 3`
- No validation prevents these duplicate assignments
- State is updated with 4 miners having `FinalOrderOfNextRound = 3`

**Step 3:** Next round transition occurs via `NextRound` transaction:
- `NextRoundMiningOrderValidationProvider` validates the round
- `.Distinct()` on `MinerInRound` objects returns 4 distinct objects (due to different pubkeys)
- Validation passes: `distinctCount = 4 == minersWhoMined = 4` âœ“
- `GenerateNextRoundInformation` calculates time slots based on order 3 for all 4 miners

**Expected vs Actual Result:**
- **Expected:** Each miner gets unique time slot, validation catches duplicate orders
- **Actual:** Validation passes, 4 miners receive identical `ExpectedMiningTime = currentBlockTime + (miningInterval * 3)`, causing time slot collision in next round

**Success Condition:** 
Check next round's `RealTimeMinersInformation` - multiple miners will have identical `ExpectedMiningTime` values, confirming the time slot collision vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```
