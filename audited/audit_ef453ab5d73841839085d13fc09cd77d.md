### Title
Missing Contract Address Validation in Governance Proposal Creation Allows Governance DoS

### Summary
The Referendum, Parliament, and Association governance contracts only validate that `ToAddress != null` when creating proposals, without verifying that the address corresponds to a deployed smart contract. This allows proposals to target non-existent contracts or user addresses (EOAs), causing governance denial-of-service when approved proposals cannot be successfully released, permanently locking voter tokens until proposal expiration.

### Finding Description

The vulnerability exists in the proposal validation logic across all three governance contracts. The `Validate(ProposalInfo)` method in Referendum_Helper.cs only checks if the address is non-null: [1](#0-0) 

The same insufficient validation pattern exists in Parliament: [2](#0-1) 

And Association: [3](#0-2) 

According to AElf's address specification, transaction destinations (`To` field) can only be Contract Addresses: [4](#0-3) 

When a proposal with an invalid `ToAddress` is released, the `Release` method attempts to execute an inline transaction: [5](#0-4) 

During execution, the system attempts to get an executive for the target address. If the address doesn't correspond to a deployed contract, a `SmartContractFindRegistrationException` is caught and the inline transaction fails: [6](#0-5) 

When any inline transaction fails, the parent transaction is marked as unsuccessful: [7](#0-6) 

The error is surfaced to the parent trace: [8](#0-7) 

Critically, when a transaction fails due to inline transaction failure, only pre/post plugin state changes are committed, not the main transaction's state changes. This is confirmed by test cases: [9](#0-8) 

The test shows that when an inline transaction fails (line 2128: `Status.ShouldBe(TransactionResultStatus.Failed)`), the parent transaction's state changes are not committed (line 2134: `blockStateSet.Changes.Count.ShouldBe(0)`).

This means the proposal removal at line 174 of Referendum.cs is reverted, leaving the proposal in an approved but unreleasable state.

### Impact Explanation

**Governance Disruption:** Approved proposals with invalid addresses cannot execute their intended governance actions, breaking the governance process for critical protocol updates or parameter changes.

**Resource Waste:** Voter tokens are locked in the proposal until expiration. For Referendum, voters must approve tokens for the proposal virtual address, and these remain locked until `ReclaimVoteToken` is called after expiration: [10](#0-9) 

**Permanent DoS:** Since the proposal state changes are reverted but the proposal remains approved, the proposer can repeatedly attempt to release, each time failing. The proposal cannot be successfully executed until it expires and is cleared: [11](#0-10) 

**Scope:** This affects all three governance contracts (Referendum, Parliament, Association), impacting the entire governance system. A single malicious or mistaken proposal can waste significant governance resources and time.

### Likelihood Explanation

**Reachable Entry Point:** The `CreateProposal` method is publicly accessible to whitelisted proposers: [12](#0-11) 

**Feasible Preconditions:** 
- Proposer must be in the organization's whitelist (verified by `AssertIsAuthorizedProposer`)
- This is a limited trust assumption - proposers are designated but can make mistakes or act maliciously within their scope
- No additional checks prevent invalid addresses

**Execution Practicality:** 
- Simple human error: Proposer copies wrong address or typos
- Intentional: Malicious proposer creates invalid proposal to waste governance resources
- Address format validation exists (base58 encoding) but not contract existence validation

**Attack Complexity:** Low - just requires creating a proposal with a non-existent address, which can occur accidentally or intentionally.

**Detection:** Voters can inspect `ToAddress` before voting, but may not verify contract existence. The validation gap means the contract doesn't catch this error at creation time when it should.

### Recommendation

Add contract address existence validation during proposal creation by querying the Genesis contract's `GetSmartContractRegistrationByAddress` method: [13](#0-12) 

**Specific Fix for Referendum_Helper.cs:**
```csharp
private bool Validate(ProposalInfo proposal)
{
    var validDestinationAddress = proposal.ToAddress != null;
    if (!validDestinationAddress) return false;
    
    // Add contract existence validation
    var registration = State.GenesisContract.GetSmartContractRegistrationByAddress.Call(proposal.ToAddress);
    if (registration == null || registration.CodeHash == null)
        return false;
    
    var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
    var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    var hasOrganizationAddress = proposal.OrganizationAddress != null;
    var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    return validDestinationMethodName && validExpiredTime && hasOrganizationAddress && validDescriptionUrl;
}
```

Add the Genesis contract state reference in ReferendumState.cs:
```csharp
internal ACS0Container.ACS0ReferenceState GenesisContract { get; set; }
```

Initialize in constructor or when first accessed (similar to TokenContract initialization pattern).

Apply the same fix to Parliament_Helper.cs and Association_Helper.cs.

**Test Cases:**
1. Test proposal creation with non-existent contract address should fail validation
2. Test proposal creation with user address (EOA) should fail validation
3. Test proposal creation with valid contract address should succeed
4. Test that existing deployed contracts can be targeted
5. Test error message clarity for invalid address

### Proof of Concept

**Initial State:**
- Referendum organization exists with proposer whitelist
- Proposer has sufficient tokens approved

**Attack Steps:**

1. Proposer creates proposal targeting non-existent address:
```
CreateProposalInput {
    OrganizationAddress: <valid_org>,
    ToAddress: Address.FromBase58("InvalidOrNonExistentContractAddress"),
    ContractMethodName: "SomeMethod",
    Params: <valid_params>,
    ExpiredTime: <future_time>
}
```

2. Proposal creation succeeds (only checks ToAddress != null)

3. Voters approve the proposal by locking tokens

4. Proposer calls `Release(proposalId)`

5. Release transaction executes, but inline transaction fails with "Invalid contract address"

6. Entire Release transaction fails, proposal remains in state

7. Proposal cannot be executed until expiration

**Expected vs Actual:**
- **Expected:** Proposal creation should fail with "Invalid contract address" error
- **Actual:** Proposal creation succeeds, later causes release failure and governance DoS

**Success Condition:** Proposal with invalid ToAddress exists in approved state, Release always fails, voter tokens remain locked until expiration (verifiable by checking proposal state and transaction failure logs).

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** docs-sphinx/protocol/addresses.md (L5-9)
```markdown
The changes of the state of an AElf blockchain are driven by the execution of transactions. An Address can identify one of the participants of a transaction, that is, either transaction sender or destination. The sender is marked as From in a transaction, and the destination is marked as To.

Actually, From can be a User Address, a Contract Address, or a Virtual Address, but To can only be a Contract Address, which means the transaction sender wants to construct a transaction to execute a certain method in that Smart Contract.

Here are some further explanations of all kinds of Address in an AElf blockchain.
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L115-122)
```csharp
    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L154-161)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L150-161)
```csharp
        try
        {
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L35-45)
```csharp
    public static void SurfaceUpError(this TransactionTrace txTrace)
    {
        foreach (var inline in txTrace.InlineTraces)
        {
            inline.SurfaceUpError();
            if (inline.ExecutionStatus < txTrace.ExecutionStatus)
            {
                txTrace.ExecutionStatus = inline.ExecutionStatus;
                txTrace.Error = $"{inline.Error}";
            }
        }
```

**File:** test/AElf.Parallel.Tests/DeleteDataFromStateDbTest.cs (L2101-2140)
```csharp
    public async Task Increase_Value_With_Failed_Inline()
    {
        var accountAddress = await _accountService.GetAccountAsync();
        var chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);

        const string key = "TestKey";

        var value = await GetValueAsync(accountAddress, key, chain.BestChainHash, chain.BestChainHeight);
        CheckValueNotExisted(value);

        var transaction = await GenerateTransactionAsync(accountAddress,
            ParallelTestHelper.BasicFunctionWithParallelContractAddress,
            nameof(BasicFunctionWithParallelContractContainer.BasicFunctionWithParallelContractStub
                .IncreaseValueWithFailedInline), new IncreaseValueInput
            {
                Key = key,
                Memo = Guid.NewGuid().ToString()
            });
        var transactions = new List<Transaction> { transaction };
        var block = _parallelTestHelper.GenerateBlock(chain.BestChainHash, chain.BestChainHeight, transactions);
        block = (await _blockExecutingService.ExecuteBlockAsync(block.Header, transactions)).Block;
        await _blockchainService.AddTransactionsAsync(transactions);
        await _blockchainService.AddBlockAsync(block);
        await _blockAttachService.AttachBlockAsync(block);

        var transactionResult = await GetTransactionResultAsync(transaction.GetHash(), block.Header);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);

        value = await GetValueAsync(accountAddress, key, block.GetHash(), block.Height);
        CheckValueNotExisted(value);

        var blockStateSet = await _blockStateSetManger.GetBlockStateSetAsync(block.GetHash());
        blockStateSet.Changes.Count.ShouldBe(0);
        blockStateSet.Deletes.Count.ShouldBe(0);

        chain = await _blockchainService.GetChainAsync();
        await SetIrreversibleBlockAsync(chain);
        await CheckValueNotExistedInVersionStateAsync(key);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L46-52)
```csharp
    public override SmartContractRegistration GetSmartContractRegistrationByAddress(Address input)
    {
        var info = State.ContractInfos[input];
        if (info == null) return null;

        return State.SmartContractRegistrations[info.CodeHash];
    }
```
