### Title
Quadratic Complexity in Association Proposal Vote Counting Enables Governance DoS

### Summary
The `IsProposalAbstained()` function and related vote-counting functions in the Association contract exhibit O(n*m) complexity when checking votes against organization membership lists, where n is the number of votes and m is the number of organization members. With no limit on organization size, this creates O(m²) worst-case complexity that can make proposal releases prohibitively expensive or impossible in large organizations, causing denial-of-service of governance operations.

### Finding Description

The vulnerability exists in the vote-counting logic across multiple functions in the Association contract: [1](#0-0) [2](#0-1) [3](#0-2) 

Each function uses LINQ's `Count(predicate)` with `organization.OrganizationMemberList.Contains` as the predicate. This iterates through all votes and for each vote, performs a linear search through the organization's member list: [4](#0-3) 

The `organizationMembers_` is a protobuf `RepeatedField<Address>` backed by a `List<T>`, making `Contains()` an O(m) operation. Combined with iterating through votes, this results in O(n*m) complexity.

**Root Cause:** The contract imposes no maximum limit on organization member count during validation: [5](#0-4) 

The validation only checks lower bounds (member count must satisfy thresholds) but never enforces an upper limit.

**Attack Path:**
1. Attacker creates organization via `CreateOrganization()` with a large member list (500-1000+ addresses they control) [6](#0-5) 

2. Attacker creates a proposal

3. Attacker has controlled member addresses vote (abstain/approve/reject): [7](#0-6) 

Each member can only vote once (enforced): [8](#0-7) 

4. When `Release()` is called, it invokes `IsReleaseThresholdReached()`: [9](#0-8) [10](#0-9) 

This triggers O(m²) operations where m = member count. With 1000 members and 1000 votes, this performs approximately 3,000,000 `Contains()` checks (across all three vote-counting functions).

**Note:** The question's framing that an attacker can "spam proposal.Abstentions with many addresses" is imprecise. Only authorized organization members can vote, and each can vote only once. However, an attacker who controls the organization creation can set up a large member list, making the vulnerability exploitable.

### Impact Explanation

**Operational DoS Impact:**
- Large organizations (500+ members with high participation) experience prohibitively expensive or failed proposal releases
- Transaction fees for `Release()` scale quadratically with member count
- In extreme cases, transactions may fail due to resource exhaustion or execution timeouts
- Legitimate governance becomes inoperable for affected organizations

**Quantified Harm:**
- Organization with 100 members, 100 votes: ~30,000 membership checks
- Organization with 500 members, 500 votes: ~750,000 membership checks  
- Organization with 1000 members, 1000 votes: ~3,000,000 membership checks

**Affected Parties:**
- Any Association-based governance organization with significant membership
- Particularly impacts intended use cases requiring broad multi-signature participation

**Severity Justification (Medium):**
- Causes operational DoS of governance but does not directly compromise funds or authorization invariants
- Requires attacker to either control organization creation or exploit legitimately large organizations
- Has setup cost (creating/funding many addresses) but achieves persistent governance disruption

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to create new organization with attacker-controlled parameters (public method)
- Control of multiple addresses to serve as organization members
- Funds to pay transaction fees for organization creation and voting

**Attack Complexity:**
- Low to Medium complexity
- Creating 500-1000 addresses is straightforward
- Each address needs minimal funding for vote transactions
- One-time setup achieves persistent DoS

**Feasibility Conditions:**
- No limit enforced on organization member count
- No optimization of membership checking (linear search on each vote)
- Vote-counting functions called during release transaction (not just view)

**Economic Analysis:**
- Cost: Creating/funding N addresses + N vote transaction fees
- Benefit: Permanent governance DoS for that organization
- Rational for adversarial scenarios (disrupting competitor DAOs) or griefing attacks

**Detection/Operational Constraints:**
- Attack is transparent on-chain (large organization creation, many votes)
- No automatic circuit breaker or complexity limit
- Once established, organization cannot be easily migrated without governance (which is DoS'd)

**Probability:** Medium - Requires setup effort but is practically executable and economically viable for targeted attacks on high-value governance organizations.

### Recommendation

**Immediate Fix:**
1. Add maximum organization member limit validation in `Validate()` function:
```csharp
private bool Validate(Organization organization)
{
    const int MaxOrganizationMembers = 100; // or appropriate limit
    
    if (organization.OrganizationMemberList.Count() > MaxOrganizationMembers)
        return false;
        
    // ... existing validation logic
}
```

2. Optimize membership checking using a hash set for O(1) lookups:
```csharp
private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
{
    var memberSet = new HashSet<Address>(organization.OrganizationMemberList.OrganizationMembers);
    var abstentionMemberCount = proposal.Abstentions.Count(memberSet.Contains);
    return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
}
```

**Invariant Checks:**
- Enforce `organization.OrganizationMemberList.Count() <= MAX_MEMBERS` in `CreateOrganization()`
- Enforce same limit in `AddMember()` before allowing member additions
- Consider gas/resource cost limits for proposal release operations

**Test Cases:**
- Test organization creation with 101, 500, 1000 members (should fail/succeed based on limit)
- Test proposal release with maximum allowed members all voting
- Measure transaction costs for various organization sizes
- Test AddMember() respects member count limit

### Proof of Concept

**Initial State:**
- Attacker has access to 1000 addresses (Address1...Address1000)
- Each address has minimal funding for transaction fees

**Attack Steps:**

1. **Create large organization (Transaction 1):**
```
CreateOrganizationInput {
    OrganizationMemberList: { Address1, Address2, ..., Address1000 }
    ProposalReleaseThreshold: {
        MinimalApprovalThreshold: 500,
        MinimalVoteThreshold: 600,
        MaximalAbstentionThreshold: 400,
        MaximalRejectionThreshold: 400
    }
    ProposerWhiteList: { Address1 }
}
Result: Organization created with 1000 members
```

2. **Create proposal (Transaction 2):**
```
CreateProposal from Address1
Result: Proposal created
```

3. **Cast 1000 votes (Transactions 3-1002):**
```
Address1.Abstain(proposalId)
Address2.Abstain(proposalId)
...
Address1000.Abstain(proposalId)
Result: proposal.Abstentions.Count = 1000
```

4. **Attempt release (Transaction 1003):**
```
Address1.Release(proposalId)

Expected: Proposal released after normal validation
Actual: Transaction experiences O(1000²) = ~1,000,000 Contains() operations
        - IsProposalAbstained: 1000 votes × 1000 members = 1,000,000 checks
        - IsProposalRejected: 0 votes × 1000 members = 0 checks  
        - CheckEnoughVoteAndApprovals: 0 votes × 1000 members = 0 checks
        Total: ~1,000,000 linear searches
        
Result: Transaction fails or succeeds with prohibitively high cost
Success Condition: Transaction cost exceeds practical limits, making governance unusable
```

**Verification:**
Compare Release() transaction cost for:
- Organization with 10 members, 10 votes: Low cost
- Organization with 100 members, 100 votes: 100× cost increase
- Organization with 1000 members, 1000 votes: 10,000× cost increase

The quadratic scaling confirms the vulnerability enables practical governance DoS.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L132-138)
```csharp
    private void AssertProposalNotYetVotedBySender(ProposalInfo proposal, Address sender)
    {
        var isAlreadyVoted = proposal.Approvals.Contains(sender) || proposal.Rejections.Contains(sender) ||
                             proposal.Abstentions.Contains(sender);

        Assert(!isAlreadyVoted, "Sender already voted.");
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L163-181)
```csharp
    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Abstentions.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Abstain),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
