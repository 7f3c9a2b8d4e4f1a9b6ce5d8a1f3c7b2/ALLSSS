### Title
Miner Order Grinding Attack via Non-Deterministic InValue Generation

### Summary
Miners can manipulate their position in the next round by generating multiple InValue candidates offline and selecting the one that produces the most favorable `supposedOrderOfNextRound`. This is possible because InValue generation uses non-deterministic ECDSA signatures with random nonces, allowing miners to create different valid InValues that all satisfy the commitment-reveal scheme but produce different next-round orderings.

### Finding Description

The vulnerability exists in the order determination mechanism for the next round. In `ApplyNormalConsensusData()`, a miner's next-round order is calculated deterministically from their signature: [1](#0-0) 

The signature is derived from the miner's `previousInValue` (revealed from prior round) via: [2](#0-1) 

where `CalculateSignature` XORs the previousInValue with all miners' signatures from the previous round: [3](#0-2) 

The root cause is that InValue generation uses non-deterministic ECDSA signatures. The `GenerateInValueAsync` method signs data using the account service: [4](#0-3) 

which ultimately calls `SignRecoverable` with random nonces: [5](#0-4) [6](#0-5) 

The commitment-reveal validation only checks that `Hash(previousInValue) == previousOutValue`: [7](#0-6) 

This validation does NOT prevent grinding because any InValue that hashes to the committed OutValue is accepted, but miners can generate multiple different InValues by signing the same message repeatedly (each produces a different signature due to random nonces).

**Attack Path:**
1. In round N-1, when miner's turn arrives (especially if late in round order), they can observe other miners' signatures already recorded in `RealTimeMinersInformation`
2. Offline, miner generates multiple InValue candidates by calling `SignAsync` repeatedly on the same data (each call uses different random nonce, producing different signature and thus different InValue)
3. For each InValue candidate, miner calculates: `Signature_N = XOR(InValue_{N-1}, XOR(known Signature_{N-1}))`, then `Order_{N+1} = GetAbsModulus(Signature_N.ToInt64(), minersCount) + 1`
4. Miner selects InValue producing most favorable order (e.g., order 1 for first position, specific order to become extra block producer)
5. Miner commits to `OutValue = Hash(selected InValue)` in round N-1 block
6. In round N, miner reveals selected InValue, which passes validation since `Hash(InValue) == OutValue`

### Impact Explanation

**Direct Consensus Impact:**
- Miners can manipulate their next-round position, breaking the fairness assumption of random order assignment
- This enables miners to preferentially select early positions (order 1-2) for timing advantages or late positions to maximize information when choosing their own InValue for the subsequent round
- Extra block producer selection uses the first miner's signature modulo miner count; grinding enables targeted manipulation to become the extra block producer who produces the round transition block: [8](#0-7) 

**Operational Impact:**
- Miners with favorable positions can potentially mine multiple consecutive blocks if they manipulate to be both extra block producer of one round and first miner of next round (though `BreakContinuousMining` provides partial mitigation)
- Accumulated advantage compounds across rounds as miners with late orders can grind more effectively (seeing more signatures)
- Reward distribution based on produced blocks becomes unfair when miners can increase their mining frequency through order manipulation

**Affected Parties:**
- Other miners suffer reduced mining opportunities and rewards
- Network security degrades as consensus fairness assumptions are violated
- Users may experience censorship or transaction ordering manipulation by miners who control specific time slots

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner (feasible for any elected validator)
- Attacker needs computational resources for grinding, but cost is minimal (ECDSA signing is ~10,000-100,000 operations per second on commodity hardware)
- Attacker produces blocks in normal consensus flow; no special access required

**Attack Complexity:**
- Low complexity: Simply call signing function repeatedly until favorable order found
- With 21 miners, expected ~10 attempts to get order 1, ~21 attempts to get any specific order
- Search space is linear in miner count, making grinding highly practical

**Feasibility Conditions:**
- Most effective when miner has late order in current round (can observe more signatures)
- Works for any miner but advantage scales with position
- No rate limiting or detection mechanisms exist in protocol
- Attack is undetectable from blockchain state (looks like normal random variation)

**Economic Rationality:**
- If mining rewards scale with block count, manipulation is profitable
- Even small advantages compound over many rounds
- Computational cost negligible compared to mining rewards
- No risk of detection or penalty

**Probability:** High - attack is practical, undetectable, and economically rational for any profit-motivated miner.

### Recommendation

**Primary Mitigation: Use Deterministic Signatures (RFC6979)**

Replace non-deterministic ECDSA with RFC6979 deterministic signatures for InValue generation. The codebase already has RFC6979 implementation available: [9](#0-8) 

Modify `SecretSharingService.GenerateInValueAsync` to use deterministic signing:
1. Use RFC6979 nonce generation instead of random nonces
2. Ensure same message always produces same signature
3. This prevents grinding while maintaining commitment-reveal security

**Additional Hardening:**

1. **Commit-then-reveal timing enforcement**: Require miners to commit to their InValue BEFORE observing other miners' signatures in the current round (enforce via time-slot validation)

2. **VRF-based order assignment**: Instead of modulo arithmetic on controllable signatures, use Verifiable Random Function (VRF) outputs which are already present in the system: [10](#0-9) 

3. **Multi-party randomness**: Require all miners' contributions before calculating any next-round orders (prevents partial grinding)

**Test Cases:**
- Verify InValue generation is deterministic (same input → same output)
- Verify order calculation cannot be biased by trying multiple InValues
- Test that late-order miners cannot grind for favorable next-round positions

### Proof of Concept

**Initial State:**
- Round N-1 in progress with 21 miners
- Attacker is miner #18 (late in round order)
- Miners #1-17 have already produced blocks, their signatures visible in `RealTimeMinersInformation`

**Attack Sequence:**

1. Attacker prepares `SecretSharingInformation` object for round N-1
2. Attacker runs grinding loop:
   ```
   for i in 1 to 10000:
       inValue_candidate = Sign(SecretSharingInfo)  // Random nonce produces different signature each time
       signature_N = XOR(inValue_candidate, XOR(known_signatures_from_N-1))
       order_N+1 = GetAbsModulus(signature_N.ToInt64(), 21) + 1
       if order_N+1 == 1:  // Target: first position in next round
           selected_inValue = inValue_candidate
           break
   ```
3. Attacker commits to `OutValue_{N-1} = Hash(selected_inValue)` in their round N-1 block
4. Round N begins, attacker reveals `selected_inValue`
5. System validates: `Hash(selected_inValue) == OutValue_{N-1}` ✓ (passes)
6. System calculates: `supposedOrderOfNextRound = GetAbsModulus(signature_N.ToInt64(), 21) + 1 = 1`
7. Attacker assigned order 1 in round N+1

**Expected Result:** Attacker randomly assigned order in [1, 21] with uniform distribution

**Actual Result:** Attacker achieves order 1 (or any other target order) through offline grinding

**Success Condition:** Attacker's `FinalOrderOfNextRound` in round N+1 matches their target order, achieved through selective InValue generation rather than random assignment

### Notes

The vulnerability fundamentally stems from allowing miners to generate multiple valid commitments offline before selecting which one to publish. While the commitment-reveal scheme correctly prevents revealing before commitment and validates the hash relationship, it does not prevent commitment grinding. The fix requires making the commitment generation deterministic (RFC6979) so miners cannot generate alternatives, or using external randomness sources (VRF) that miners cannot control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** src/AElf.OS/Account/Application/AccountService.cs (L24-28)
```csharp
    public async Task<byte[]> SignAsync(byte[] data)
    {
        var signature = CryptoHelper.SignWithPrivateKey((await GetAccountKeyPairAsync()).PrivateKey, data);
        return signature;
    }
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L89-96)
```csharp
        public static byte[] SignWithPrivateKey(byte[] privateKey, byte[] hash)
        {
            try
            {
                Lock.EnterWriteLock();
                var recSig = new byte[65];
                var compactSig = new byte[65];
                if (!Secp256K1.SignRecoverable(recSig, hash, privateKey))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** src/AElf.Cryptography/Core/Secp256k1Curve.cs (L113-120)
```csharp
            }

            return nonce;
        }

        public void Dispose()
        {
            _inner.Dispose();
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L79-79)
```csharp
        var randomProof = AsyncHelper.RunSync(async ()=> await _randomNumberProvider.GenerateRandomProofAsync(chainContext));
```
