### Title
Assembled NFTs Can Be Burned Directly Without Releasing Locked Components

### Summary
The `Burn` method does not verify whether an NFT is assembled before allowing it to be destroyed. This enables assembled NFTs to be burned directly without going through the `Disassemble` flow, permanently locking component NFTs and FTs in the contract with no recovery mechanism. The orphaned `AssembledNftsMap` entries cannot be removed since the assembled token no longer exists to trigger proper disassembly. [1](#0-0) 

### Finding Description

**Root Cause:**
The `Burn` method lacks validation to prevent burning assembled NFTs. It only checks protocol burnability and minter permissions, but never verifies `AssembledNftsMap` or `AssembledFtsMap` state. [1](#0-0) 

**Relevant Execution Paths:**

1. **Assembly Process:** Component NFTs are transferred to the contract address (`Context.Self`), and `AssembledNftsMap[tokenHash]` is populated: [2](#0-1) [3](#0-2) 

2. **Proper Disassembly:** The `Disassemble` method correctly burns the token, releases components, and removes the map entry: [4](#0-3) 

3. **Improper Burning:** Direct `Burn` calls destroy the assembled NFT but leave `AssembledNftsMap` entries and locked components untouched: [1](#0-0) 

**Why Protections Fail:**
The `Burn` method only validates:
- Protocol is burnable (line 87-88)
- Caller has balance and minter permissions (lines 90-93)

There is no check for assembled state. The map entry removal only occurs in `Disassemble`, which cannot be called after the token is burned. [5](#0-4) 

### Impact Explanation

**Direct Fund Impact:**
- Component NFTs and FTs transferred to the contract during assembly remain permanently locked
- No recovery mechanism exists since the assembled token (required to trigger `Disassemble`) no longer exists
- Orphaned `AssembledNftsMap` entries cannot be cleaned up

**Who Is Affected:**
- Any minter who accidentally calls `Burn` instead of `Disassemble` on assembled NFTs
- Users who transfer assembled NFTs to minters who inadvertently burn them
- The protocol suffers from permanent asset lockup in the contract

**Severity Justification:**
HIGH - Results in irreversible loss of locked assets with trivial execution (single method call) and realistic occurrence scenarios (user error or misunderstanding of proper disassembly flow).

### Likelihood Explanation

**Attacker Capabilities:**
- Must be in the protocol's `MinterListMap` 
- Must own the assembled NFT (balance check at line 91) [6](#0-5) [7](#0-6) 

**Attack Complexity:**
LOW - Requires only a single `Burn` transaction with standard parameters.

**Feasibility Conditions:**
- Protocol creator and authorized minters are common roles in NFT systems
- User error (calling `Burn` vs `Disassemble`) is realistic
- No warning or protection exists to prevent this

**Probability:**
HIGH - The attack requires no special privileges beyond normal minter status, and can occur accidentally through user confusion about the proper token destruction flow.

### Recommendation

**Code-Level Mitigation:**
Add an assertion in the `Burn` method to prevent burning assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Add this check before proceeding with burn
    Assert(State.AssembledNftsMap[tokenHash] == null || 
           !State.AssembledNftsMap[tokenHash].Value.Any(),
           "Cannot burn assembled NFT directly. Use Disassemble instead.");
    Assert(State.AssembledFtsMap[tokenHash] == null || 
           !State.AssembledFtsMap[tokenHash].Value.Any(),
           "Cannot burn assembled NFT directly. Use Disassemble instead.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of existing burn logic
}
``` [8](#0-7) 

**Invariant to Enforce:**
Assembled NFTs (those with non-empty `AssembledNftsMap` or `AssembledFtsMap` entries) can ONLY be destroyed through the `Disassemble` method, which ensures component release and map cleanup.

**Test Cases:**
1. Attempt to burn an assembled NFT → should fail with appropriate error
2. Successfully disassemble an assembled NFT → verify components returned and maps cleaned
3. Burn a non-assembled NFT → should succeed normally

### Proof of Concept

**Initial State:**
- User is in the protocol's minter list
- User owns component NFT with tokenHash `H1`

**Attack Steps:**

1. **Assemble NFT:**
   - Call `Assemble` with `input.AssembledNfts.Value = {H1: 1}`
   - Component NFT transferred to contract: `State.BalanceMap[H1][Context.Self] = 1`
   - Map entry created: `State.AssembledNftsMap[H_assembled] = {H1: 1}`
   - New assembled NFT minted with hash `H_assembled` [9](#0-8) 

2. **Burn Directly (Bypassing Disassemble):**
   - Call `Burn` with `Symbol` and `TokenId` of assembled NFT
   - Permission check passes (user in minter list, has balance)
   - Assembled NFT burned: `State.BalanceMap[H_assembled][Context.Sender] = 0`
   - **BUT** `State.AssembledNftsMap[H_assembled]` remains populated
   - **AND** component NFT stays locked: `State.BalanceMap[H1][Context.Self] = 1` [1](#0-0) 

**Expected vs Actual Result:**
- **Expected:** Burning assembled NFTs should fail, requiring `Disassemble` to release components
- **Actual:** Assembled NFT is destroyed but components remain permanently locked in contract

**Success Condition:**
Component NFT at hash `H1` is unrecoverable because:
- `Disassemble` cannot be called (tries to burn non-existent token at line 193)
- No other method transfers from `Context.Self` based on `AssembledNftsMap`
- The orphaned map entry has no cleanup mechanism [10](#0-9)

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-189)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;

        Context.Fire(new Assembled
        {
            Symbol = input.Symbol,
            TokenId = nftMinted.TokenId,
            AssembledNfts = input.AssembledNfts,
            AssembledFts = input.AssembledFts
        });

        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-210)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L15-15)
```csharp
    public MappedState<string, MinterList> MinterListMap { get; set; }
```
