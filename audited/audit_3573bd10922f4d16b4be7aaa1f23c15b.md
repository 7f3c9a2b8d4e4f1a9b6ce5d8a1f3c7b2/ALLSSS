### Title
Consensus Signature Manipulation Allows Mining Order Control

### Summary
The AEDPoS consensus validation does not verify that the signature field in UpdateValue transactions matches its expected calculated value. A malicious miner can submit arbitrary signature values that directly determine their mining order in the next round, breaking consensus fairness and allowing strategic mining position manipulation.

### Finding Description

The root cause is the absence of signature correctness validation in the consensus update flow. The signature field should be calculated deterministically using `CalculateSignature()` based on previous round state, but this is never validated.

**Vulnerable Code Path:**

1. In `RecoverFromUpdateValue`, the provided signature is blindly copied without validation: [1](#0-0) 

2. In `ValidateBeforeExecution`, this recovered BaseRound with the unvalidated signature is passed to validation providers: [2](#0-1) 

3. `UpdateValueValidationProvider` only checks that signature is not null, not that it's correct: [3](#0-2) 

4. In `ProcessUpdateValue`, the signature is stored directly without verification: [4](#0-3) 

5. The signature value directly determines the miner's order in the next round: [5](#0-4) 

While signatures are expected to be calculated using: [6](#0-5) 

There is no validation comparing the provided signature against this expected calculation. The signature definition confirms its intended purpose: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
- The mining order in AEDPoS should be deterministically derived from unpredictable signature values calculated from previous round state
- By manipulating the signature, an attacker can control their mining position in the next round
- This breaks the fundamental fairness guarantee of the consensus mechanism

**Concrete Harms:**
- **Strategic Mining Advantage**: Attacker can position themselves to mine at optimal times (e.g., first in round for maximum influence, or after specific miners for strategic block production)
- **Miner Order Manipulation**: Multiple colluding miners could coordinate their signature values to control the entire mining sequence
- **Protocol Randomness Compromise**: The consensus mechanism's unpredictability is destroyed, enabling predictable attack patterns
- **LIB Height Manipulation**: Strategic mining positions can influence irreversible block height calculations

**Affected Parties:**
- All honest miners lose their fair chance at mining positions
- Blockchain users face reduced security from compromised consensus randomness
- DApps relying on consensus fairness for timing-sensitive operations are at risk

### Likelihood Explanation

**Attacker Prerequisites:**
- Must be a legitimate miner in the current round (checked by MiningPermissionValidationProvider)
- Must produce blocks during their assigned time slot (checked by TimeSlotValidationProvider)
- Normal mining capabilities - no special access required beyond being an elected miner

**Attack Complexity: LOW**
1. Calculate correct `OutValue` from miner's `InValue`
2. Provide correct `PreviousInValue` (validated by `ValidatePreviousInValue`)
3. Instead of calculating `signature = CalculateSignature(previousInValue)`, choose arbitrary signature value targeting desired next-round position
4. Submit UpdateValue transaction with manipulated signature
5. All validations pass - no check verifies signature correctness

**Feasibility: HIGH**
- Attack requires no compromise of other system components
- Attacker only needs normal miner privileges (obtained through standard election process)
- No cryptographic breaking required - the signature field is simply not validated
- Can be executed every round by any miner
- Detection is difficult as the signature appears valid (not null, properly formatted)

**Economic Rationality: HIGH**
- Cost: Only the gas/transaction fees for normal block production
- Benefit: Strategic mining position worth significant value through MEV, block rewards, and consensus influence
- Risk: Low detection probability as manipulated signatures are indistinguishable from calculation errors

### Recommendation

**Immediate Fix:**
Add signature validation in `UpdateValueValidationProvider.ValidateHeaderInformation()`:

```csharp
private bool ValidateSignatureCorrectness(ConsensusValidationContext validationContext)
{
    var publicKey = validationContext.SenderPubkey;
    var providedSignature = validationContext.ProvidedRound.RealTimeMinersInformation[publicKey].Signature;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
        return true; // First time miner
        
    var previousInValue = validationContext.ProvidedRound.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // No previous in value to validate
        
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    return providedSignature == expectedSignature;
}
```

Then add this check in `ValidateHeaderInformation()`:
```csharp
if (!ValidateSignatureCorrectness(validationContext))
    return new ValidationResult { Message = "Incorrect signature value." };
```

**Additional Safeguards:**
1. Add unit tests verifying signature calculation matches expected value for all consensus behaviors
2. Add integration tests attempting to submit blocks with manipulated signatures
3. Log signature validation failures for monitoring
4. Consider adding signature freshness checks comparing against historical signatures to detect replay attempts

**Regression Prevention:**
Create test cases that:
- Submit UpdateValue with incorrect signature values
- Verify such transactions are rejected
- Confirm legitimate signatures continue to work
- Test boundary cases (first round, replacement miners, etc.)

### Proof of Concept

**Initial State:**
- Blockchain running with AEDPoS consensus
- Attacker is a legitimate miner (pubkey: "AttackerPubkey")
- Current round N, with 7 miners total
- Attacker's current order in round N: 4

**Attack Steps:**

1. **Attacker's Turn to Mine (Round N):**
   - Calculate legitimate `OutValue = Hash(InValue)`
   - Retrieve correct `PreviousInValue` from round N-1
   - **Instead of**: `signature = previousRound.CalculateSignature(PreviousInValue)`
   - **Attacker calculates**: What signature value would give order=1 in next round?
     - `targetOrder = 1`
     - `targetSigNum = (targetOrder - 1) + k * minersCount` for some k
     - Choose signature with `ToInt64() = targetSigNum`

2. **Submit UpdateValue Transaction:**
   ```
   UpdateValue({
     OutValue: <legitimate_out_value>,
     Signature: <manipulated_signature_for_order_1>,
     PreviousInValue: <legitimate_previous_in_value>,
     ActualMiningTime: <current_time>,
     ...
   })
   ```

3. **Validation Passes:**
   - MiningPermissionValidationProvider: ✓ (attacker is valid miner)
   - TimeSlotValidationProvider: ✓ (mining in assigned slot)
   - UpdateValueValidationProvider: ✓ (signature not null, PreviousInValue correct)
   - **No signature correctness check exists**

4. **State Update:**
   - `ProcessUpdateValue` stores manipulated signature
   - `ApplyNormalConsensusData` calculates: `supposedOrderOfNextRound = Abs(manipulated_signature.ToInt64() % 7) + 1 = 1`

**Expected vs Actual Result:**

**Expected (Secure):**
- Signature validation fails: "Incorrect signature value"
- Transaction rejected
- Attacker cannot manipulate next-round order

**Actual (Vulnerable):**
- All validations pass
- Attacker's manipulated signature stored in state
- Next round (N+1) generated with attacker at position 1
- Attacker successfully controls their mining order

**Success Condition:**
Query `GetRoundInformation(N+1).RealTimeMinersInformation["AttackerPubkey"].Order` returns `1`, confirming attacker achieved their target position through signature manipulation.

### Notes

This vulnerability exists because the AEDPoS consensus assumes miners will honestly calculate signatures, but provides no cryptographic or validation enforcement of this assumption. The signature field, despite its name, is not a cryptographic signature requiring private key signing - it's a deterministic hash-based value that should be verified but isn't.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** protobuf/aedpos_contract.proto (L276-276)
```text
    aelf.Hash signature = 5;
```
