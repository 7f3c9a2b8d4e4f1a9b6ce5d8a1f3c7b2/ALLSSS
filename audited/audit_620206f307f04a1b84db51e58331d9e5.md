### Title
Incorrect Admin Removal in SetCandidateAdmin Causes State Inconsistency in ManagedCandidatePubkeysMap

### Summary
The `SetCandidateAdmin()` function incorrectly removes the candidate pubkey from `Context.Sender`'s managed list instead of the actual old admin's list when Parliament or the candidate themselves invokes the function. This creates permanent state inconsistency where the old admin continues to appear as managing a candidate they no longer control, and `GetManagedPubkeys()` returns incorrect data for off-chain systems.

### Finding Description

The vulnerability exists in the `SetCandidateAdmin()` function where the permission check allows three different callers but the cleanup logic incorrectly assumes `Context.Sender` is always the old admin. [1](#0-0) 

The permission check allows:
1. Parliament (line 27) - bypasses all checks
2. Candidate address when admin is null (lines 29-33) - for legacy candidates
3. Old admin (lines 36-39) - normal case

However, the cleanup logic unconditionally removes from `Context.Sender`'s managed list: [2](#0-1) 

**Root Cause:** The code retrieves the old admin at line 37 but never uses it for the removal operation. Instead, it removes from `Context.Sender` which is only correct in scenario 3 (when the old admin calls). In scenarios 1 and 2, `Context.Sender` is not the old admin, causing:
- Removal from the wrong address's managed list
- Failure to clean up the actual old admin's managed list
- Permanent state corruption in `ManagedCandidatePubkeysMap`

**Comparison with Correct Implementation:** The `ReplaceCandidatePubkey()` function correctly verifies that `Context.Sender` is the admin before modifying the managed list: [3](#0-2) [4](#0-3) 

### Impact Explanation

**State Corruption:**
- The old admin's `ManagedCandidatePubkeysMap` retains the candidate pubkey even after admin transfer
- `GetManagedPubkeys()` view function returns incorrect results for the old admin [5](#0-4) 

**Operational Impact:**
- Off-chain systems querying `GetManagedPubkeys()` receive stale data showing incorrect admin-candidate relationships
- Parliament's managed list may be incorrectly modified if they transfer admin rights
- Data integrity invariant violated: `ManagedCandidatePubkeysMap` should accurately reflect which admins manage which candidates

**No Direct Security Bypass:** Authorization for critical operations (QuitElection, ReplaceCandidatePubkey) correctly checks `CandidateAdmins` directly, not `ManagedCandidatePubkeysMap`: [6](#0-5) [7](#0-6) 

Therefore, while this causes data corruption, it does not lead to unauthorized fund access or governance bypass.

### Likelihood Explanation

**High Likelihood:**
- Parliament routinely manages candidate admin changes as part of governance operations
- Entry point is a public function with no special economic cost
- No complex preconditions required - simply requires a candidate with an existing admin
- Triggers automatically whenever Parliament invokes `SetCandidateAdmin()`

**Realistic Scenario:**
1. Candidate announces election with Admin A via `AnnounceElection()` or `AnnounceElectionFor()`
2. Parliament calls `SetCandidateAdmin(pubkey, Admin B)` for governance purposes
3. State becomes inconsistent: Admin A still shows as managing the candidate, but Admin B is the actual admin

**Detection:** The bug manifests immediately upon invocation and persists permanently in contract state. Off-chain monitoring systems querying `GetManagedPubkeys()` would observe incorrect results.

### Recommendation

**Code Fix:** Store the old admin before overwriting and use it for cleanup:

```csharp
// Line 41 - Store old admin before overwriting
var oldAdmin = State.CandidateAdmins[pubkey];

// Line 42 - Update to new admin
State.CandidateAdmins[pubkey] = input.Admin;

// Lines 46-49 - Add to new admin (unchanged)
var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
    newAdminManagedPubkeys.Value.Add(pubkeyByteString);
State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

// Lines 51-54 - Remove from OLD admin, not Context.Sender
if (oldAdmin != null)
{
    var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[oldAdmin] ?? new PubkeyList();
    if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
        oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
    State.ManagedCandidatePubkeysMap[oldAdmin] = oldAdminManagedPubkeys;
}
```

**Invariant Check:** Add post-condition assertion:
```csharp
Assert(State.ManagedCandidatePubkeysMap[input.Admin].Value.Contains(pubkeyByteString), 
    "New admin must have pubkey in managed list");
if (oldAdmin != null)
    Assert(!State.ManagedCandidatePubkeysMap[oldAdmin].Value.Contains(pubkeyByteString), 
        "Old admin must not have pubkey in managed list");
```

**Test Cases:**
1. Parliament transfers admin from A to B - verify A's list is cleaned
2. Candidate with null admin sets admin to C - verify candidate address list unchanged
3. Admin A transfers to B, then B transfers to C - verify intermediate cleanup

### Proof of Concept

**Initial State:**
- Candidate pubkey: `"candidate_abc"`
- `State.CandidateAdmins["candidate_abc"] = AddressA`
- `State.ManagedCandidatePubkeysMap[AddressA] = ["candidate_abc"]`
- `State.ManagedCandidatePubkeysMap[Parliament] = []`

**Exploit Steps:**
1. Parliament calls `SetCandidateAdmin(pubkey: "candidate_abc", admin: AddressB)`
2. Permission check passes at line 27 (sender is Parliament)
3. Line 42 updates: `State.CandidateAdmins["candidate_abc"] = AddressB` ✓
4. Lines 46-49 add to AddressB: `State.ManagedCandidatePubkeysMap[AddressB] = ["candidate_abc"]` ✓
5. Lines 51-54 attempt removal from Parliament (Context.Sender), not AddressA ✗

**Expected Result:**
- `State.ManagedCandidatePubkeysMap[AddressA] = []` (cleaned up)
- `State.ManagedCandidatePubkeysMap[AddressB] = ["candidate_abc"]`

**Actual Result:**
- `State.ManagedCandidatePubkeysMap[AddressA] = ["candidate_abc"]` ✗ (stale data persists)
- `State.ManagedCandidatePubkeysMap[AddressB] = ["candidate_abc"]` ✓
- `GetManagedPubkeys(AddressA)` incorrectly returns `["candidate_abc"]`

**Success Condition:** Call `GetManagedPubkeys(AddressA)` and observe it still contains the candidate pubkey despite AddressA no longer being the admin, demonstrating state corruption.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L51-54)
```csharp
        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L323-326)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedPubkeys.Value.Remove(oldPubkeyByteString);
        managedPubkeys.Value.Add(ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(newPubkey)));
        State.ManagedCandidatePubkeysMap[Context.Sender] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L427-430)
```csharp
    public override PubkeyList GetManagedPubkeys(Address input)
    {
        return State.ManagedCandidatePubkeysMap[input];
    }
```
