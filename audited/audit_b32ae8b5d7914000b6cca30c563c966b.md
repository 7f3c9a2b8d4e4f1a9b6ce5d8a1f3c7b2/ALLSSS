# Audit Report

## Title
Repeated Welfare Profit Extension Without Additional Lock Commitment

## Summary
A voter can repeatedly call `ChangeVotingOption` with `IsResetVotingTime=true` before their vote expires to indefinitely extend their welfare profit collection period without any additional lock time commitment. This allows voters to collect welfare profits far beyond their original lock commitment, diluting rewards for legitimate long-term voters. [1](#0-0) 

## Finding Description

When `ChangeVotingOption` is called with `IsResetVotingTime=true`, it invokes `ExtendVoterWelfareProfits` which recalculates the welfare profit `endPeriod` based on the current treasury period. [2](#0-1) 

The critical issue is in `ExtendVoterWelfareProfits`: it reads `lockTime` from state but never modifies it, as explicitly stated in the comment "so the lockTime will *NOT* be changed." [3](#0-2) 

The `endPeriod` is calculated as `lockPeriod.Add(treasury.CurrentPeriod)`, where `lockPeriod` is derived from the unchanged `lockTime`. Since `treasury.CurrentPeriod` continuously increases, each repeated call pushes the profit collection period further into the future. [4](#0-3) 

The Profit Contract's `FixProfitDetail` method then updates the beneficiary's profit detail with this new extended `endPeriod`, cloning the old detail, updating the period, and replacing it. [5](#0-4) 

**Why Protections Fail**: The only restriction is the vote expiry check, which validates `actualLockedSeconds < claimedLockingSeconds`. [6](#0-5)  This check does NOT prevent multiple calls before expiry. My search confirmed there is no rate limiting, cooldown mechanism, or tracking of extension frequency for `ChangeVotingOption`.

A voter can execute this attack by repeatedly calling `ChangeVotingOption` with the same candidate pubkey and `IsResetVotingTime=true`, extending their profit eligibility each time without any additional token lock commitment.

## Impact Explanation

**Direct Economic Harm**: A voter with a 90-day lock (~13 periods at 7 days/period) can extend their welfare profit collection period significantly beyond their commitment:
- Original vote at period 100: endPeriod = 13 + 100 = 113
- First extension at period 110: endPeriod = 13 + 110 = 123 (10 extra periods)  
- Second extension at period 111: endPeriod = 13 + 111 = 124 (11 extra periods)
- Vote expires at period 113, but voter collects profits until period 124

**Who is Affected**:
- Legitimate long-term voters who lock tokens for extended periods receive diluted welfare rewards proportional to the exploiter's unfair gains
- The welfare profit scheme's integrity is fundamentally compromised as the lock-time incentive mechanism is broken
- Protocol economics are distorted as short-term commitments extract long-term rewards

**Quantified Damage**: A voter with minimum lock time can collect welfare profits for 2x or more of their actual commitment period. With each treasury period potentially distributing significant token amounts, this represents substantial value extraction over 10+ extra periods of profit collection.

## Likelihood Explanation

**Attacker Capabilities**: Any voter with an active vote can exploit this vulnerability. No special privileges, governance approval, or system access is required beyond normal voting participation.

**Attack Complexity**: Trivial - the attacker simply calls the public `ChangeVotingOption` method repeatedly with their voteId, the same candidate pubkey they already voted for, and `IsResetVotingTime=true`. The method is publicly accessible and has no cooldown or rate limiting mechanism.

**Feasibility Conditions**:
- Voter must have an active vote that hasn't expired yet
- Can be called multiple times per period or even per block with no restrictions  
- Works with any lock duration that satisfies the minimum lock requirement
- The vote expiry check allows all calls until `actualLockedSeconds >= claimedLockingSeconds`

**Economic Rationality**: Transaction costs for calling `ChangeVotingOption` are negligible compared to the extended welfare profit gains over 10+ additional periods. A rational economic actor would exploit this to maximize returns.

**Detection Difficulty**: Difficult to detect without specifically monitoring for repeated `ChangeVotingOption` calls with `IsResetVotingTime=true` on the same voteId. There are no on-chain safeguards that prevent or flag this behavior.

## Recommendation

Add state tracking to prevent repeated profit extensions within a reasonable timeframe. Implement one of the following solutions:

**Option 1 - Track Last Extension Time**: Add a mapping to track when each vote last extended its welfare profits, and enforce a minimum period between extensions:

```csharp
// In ElectionContractState.cs
public MappedState<Hash, long> LastExtensionPeriodMap { get; set; }

// In ExtendVoterWelfareProfits method
var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
var lastExtensionPeriod = State.LastExtensionPeriodMap[voteId];
Assert(treasury.CurrentPeriod > lastExtensionPeriod, 
    "Cannot extend welfare profits in the same period.");
State.LastExtensionPeriodMap[voteId] = treasury.CurrentPeriod;
```

**Option 2 - Limit Extension Count**: Track how many times a vote has been extended and impose a maximum limit:

```csharp
// In ElectionContractState.cs
public MappedState<Hash, int> ExtensionCountMap { get; set; }

// In ExtendVoterWelfareProfits method
var extensionCount = State.ExtensionCountMap[voteId];
Assert(extensionCount < 1, "Welfare profits can only be extended once per vote.");
State.ExtensionCountMap[voteId] = extensionCount + 1;
```

**Option 3 - Update Lock Time on Extension**: When extending welfare profits, also extend the actual lock time so the vote expiry moves forward proportionally:

```csharp
// In ExtendVoterWelfareProfits method
var additionalLockTime = treasury.CurrentPeriod.Sub(votingRecord.VoteTimestamp.Seconds.Div(State.TimeEachTerm.Value)).Mul(State.TimeEachTerm.Value);
State.LockTimeMap[voteId] = State.LockTimeMap[voteId].Add(additionalLockTime);
```

## Proof of Concept

```csharp
[Fact]
public async Task RepeatedWelfareProfitExtensionExploit()
{
    // Setup: Announce candidate
    await AnnounceElectionAsync(CoreDataCenterKeyPairs[0]);
    
    // Voter votes with 20-day lock (approximately 3 periods at 7 days/period)
    var voteAmount = 1000;
    var lockDays = 20;
    var voteResult = await VoteToCandidateAsync(
        VoterKeyPairs[0], 
        CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 
        lockDays * 86400, 
        voteAmount);
    var voteId = Hash.Parser.ParseFrom(voteResult.ReturnValue);
    
    // Get initial profit detail - should have endPeriod around currentPeriod + 3
    var initialTreasury = await ProfitContractStub.GetScheme.CallAsync(State.TreasuryHash.Value);
    var initialPeriod = initialTreasury.CurrentPeriod;
    var initialProfitDetail = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    var initialEndPeriod = initialProfitDetail.Details.First().EndPeriod;
    initialEndPeriod.ShouldBe(initialPeriod + 3); // Approximately 3 periods
    
    // Advance 2 periods
    await ProduceBlocks(BootMinerKeyPair, 10);
    await NextTerm(BootMinerKeyPair);
    await ProduceBlocks(BootMinerKeyPair, 10);
    await NextTerm(BootMinerKeyPair);
    
    // Exploit: Repeatedly extend welfare profits without extending lock time
    var sameCandidatePubkey = CoreDataCenterKeyPairs[0].PublicKey.ToHex();
    
    // First extension
    await ChangeVotingOption(VoterKeyPairs[0], sameCandidatePubkey, voteId, true);
    var afterFirstExtension = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    var firstExtendedPeriod = afterFirstExtension.Details.First().EndPeriod;
    
    // Advance one more period
    await ProduceBlocks(BootMinerKeyPair, 10);
    await NextTerm(BootMinerKeyPair);
    
    // Second extension
    await ChangeVotingOption(VoterKeyPairs[0], sameCandidatePubkey, voteId, true);
    var afterSecondExtension = await GetCitizenWelfareProfitDetails(
        Address.FromPublicKey(VoterKeyPairs[0].PublicKey));
    var secondExtendedPeriod = afterSecondExtension.Details.First().EndPeriod;
    
    // Verify exploit: endPeriod keeps extending beyond original commitment
    secondExtendedPeriod.ShouldBeGreaterThan(firstExtendedPeriod);
    secondExtendedPeriod.ShouldBeGreaterThan(initialEndPeriod + 3); // More than 3 periods beyond original
    
    // The vote will expire at its original time, but profits extend much further
    // This demonstrates the voter collecting welfare profits far beyond their lock commitment
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-43)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-139)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L296-304)
```csharp
        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
```
