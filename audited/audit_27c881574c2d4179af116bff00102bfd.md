### Title
Insufficient Validation of TuneOrderInformation Allows Miner Order Manipulation and Consensus DoS

### Summary
The `ProcessUpdateValue` function lacks validation to prevent miners from including themselves in the `TuneOrderInformation` dictionary. A malicious miner can override their `FinalOrderOfNextRound` value (set at line 247) by including their own public key in `TuneOrderInformation` (applied at line 260), enabling arbitrary order selection and creating duplicate orders that block round transitions.

### Finding Description

In `ProcessUpdateValue`, the current miner's `FinalOrderOfNextRound` is set equal to their `SupposedOrderOfNextRound`: [1](#0-0) 

Subsequently, the function iterates through `TuneOrderInformation` and updates miners' `FinalOrderOfNextRound` values without checking if the current miner is included: [2](#0-1) 

The `UpdateValueInput` structure defines `TuneOrderInformation` as an unrestricted map from miner public keys to order values: [3](#0-2) 

The validation provider for `UpdateValue` behavior only validates cryptographic fields (`OutValue`, `Signature`, `PreviousInValue`) and does not validate the contents or constraints of `TuneOrderInformation`: [4](#0-3) 

The legitimate use of `TuneOrderInformation` is to propagate order adjustments for OTHER miners who had conflicts, as shown in the extraction logic: [5](#0-4) 

However, nothing prevents a malicious miner from including their own public key with an arbitrary value.

### Impact Explanation

**1. Order Manipulation for Mining Advantage:**
Miners can arbitrarily select their position in the next round, bypassing the signature-based randomization mechanism. The `FinalOrderOfNextRound` directly determines mining order and time slots in the next round: [6](#0-5) 

A malicious miner could consistently place themselves first (order 1) to maximize influence, or manipulate timing to their advantage.

**2. Consensus DoS via Duplicate Orders:**
A malicious miner can set their order to match another miner's existing `FinalOrderOfNextRound`, creating duplicates. When the next miner attempts to call `NextRound`, the validation fails because the order validation provider detects that the count of distinct orders doesn't match the count of miners who produced blocks: [7](#0-6) 

This validation is only applied during `NextRound` behavior, not during `UpdateValue`: [8](#0-7) 

The blocked `NextRound` transaction prevents the consensus round from advancing, causing a denial of service.

**3. Invalid Order Values:**
Miners could set orders to invalid values (0, negative, or exceeding miner count), potentially breaking the round generation logic that assumes valid order ranges: [9](#0-8) 

This affects consensus integrity and violates the invariant that miner schedules must maintain proper ordering and timing.

### Likelihood Explanation

**Attacker Capabilities:** Any current miner during their mining turn can execute this attack.

**Attack Complexity:** LOW - The attacker modifies their local consensus transaction generation code to craft a malicious `UpdateValueInput`. Instead of using the standard `ExtractInformationToUpdateConsensus` method: [10](#0-9) 

They manually construct `TuneOrderInformation` to include their own public key with a manipulated value.

**Feasibility Conditions:** 
- Attacker must be in the current miner list
- Attack occurs during their scheduled `UpdateValue` transaction
- No special permissions beyond being an active miner

**Detection Constraints:** The manipulation is difficult to detect because `TuneOrderInformation` is a complex nested dictionary field not subject to external audit. The order change only becomes apparent in the next round's generation.

**Economic Rationality:** The attack cost is minimal (just modifying local code), while the impact is significant (consensus manipulation or DoS). This makes the attack highly rational for malicious miners.

### Recommendation

**1. Add validation in `ProcessUpdateValue` to prevent self-inclusion:**

After line 248, add:
```csharp
// Prevent miner from overriding their own order via TuneOrderInformation
Assert(!updateValueInput.TuneOrderInformation.ContainsKey(_processingBlockMinerPubkey),
       "Miner cannot include themselves in TuneOrderInformation.");
```

**2. Validate order value ranges and uniqueness:**

Before line 260, add:
```csharp
// Validate all tuned orders are within valid range and don't create duplicates
var minersCount = currentRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount, 
           $"Invalid order value: {tuneOrder.Value}");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
           $"Unknown miner in TuneOrderInformation: {tuneOrder.Key}");
}

// Check for duplicate orders after applying tuning
var finalOrders = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.SupposedOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
Assert(finalOrders.Count == finalOrders.Distinct().Count(),
       "Duplicate FinalOrderOfNextRound values detected.");
```

**3. Add invariant checks in test cases:**

Verify that for any `UpdateValueInput`:
- Current miner is never in their own `TuneOrderInformation`
- All orders in `TuneOrderInformation` are within [1, minersCount]
- No duplicate `FinalOrderOfNextRound` values exist after processing

### Proof of Concept

**Initial State:**
- 5 miners in current round
- Current miner is "MinerA" with calculated `SupposedOrderOfNextRound = 3`
- Another miner "MinerB" has `FinalOrderOfNextRound = 1`

**Attack Steps:**

1. MinerA's turn to produce block with `UpdateValue` behavior
2. MinerA modifies consensus transaction generation to craft malicious `UpdateValueInput`:
   ```
   SupposedOrderOfNextRound: 3
   TuneOrderInformation: {
     "MinerA": 1  // Override own order to 1 (conflicting with MinerB)
   }
   ```
3. Transaction executes:
   - Line 247: Sets `MinerA.FinalOrderOfNextRound = 3`
   - Line 260: Overrides to `MinerA.FinalOrderOfNextRound = 1`
4. Result: Both MinerA and MinerB now have `FinalOrderOfNextRound = 1`

**Expected vs Actual:**
- **Expected:** MinerA should have `FinalOrderOfNextRound = 3`, unique orders maintained
- **Actual:** MinerA has `FinalOrderOfNextRound = 1`, creating duplicate with MinerB

**Success Condition:** 
When the next miner tries to call `NextRound`, validation fails with "Invalid FinalOrderOfNextRound" because distinct order count doesn't match miner count, blocking round transition and causing consensus DoS.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-247)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```
