### Title
NFT Contract ACS1 Implementation Creates Silent Failure in Fee Governance

### Summary
The NFT contract's `SetMethodFee()` and `ChangeMethodFeeController()` methods return success without performing any state changes or validation, creating a false appearance of governance control. [1](#0-0)  This causes governance proposals to appear successful while fees remain hardcoded, [2](#0-1)  leading to operational confusion and audit trail inconsistency.

### Finding Description

The NFT contract implements the ACS1 (Transaction Fee Standard) interface but uses a minimal "stub" implementation. The `SetMethodFee()` method simply returns an empty response without any authorization checks, input validation, or state modifications. [3](#0-2) 

In contrast, all other AElf system contracts implementing ACS1 (Association, Parliament, Token, etc.) include:
- Authorization checks verifying the caller is the method fee controller
- Input validation for token symbols and fee amounts  
- State storage of the fees in `State.TransactionFees`
- Explicit error messages for unauthorized access [4](#0-3) 

The NFT contract's `GetMethodFee()` returns hardcoded values (100 ELF for the Create method) regardless of any `SetMethodFee()` calls. [2](#0-1) 

When governance attempts to modify NFT fees through the standard Parliament proposal process (CreateProposal → Approve → Release), the transaction succeeds without error, but the fees remain unchanged. [5](#0-4)  This violates the fail-fast principle and creates silent failures.

The NFT contract also lacks the required state variables (`State.TransactionFees` and `State.MethodFeeController`) that enable proper fee governance. [6](#0-5) 

### Impact Explanation

**Governance Confusion:** When governance stakeholders (Parliament members, block producers) attempt to adjust NFT creation fees through proposals, the transactions succeed but have no effect. This creates a false belief that fees are under governance control when they are actually immutable without contract upgrade.

**Audit Trail Inconsistency:** Transaction logs and blockchain history will show successful `SetMethodFee` executions, but querying `GetMethodFee` reveals the fees never changed. This inconsistency complicates auditing and monitoring, potentially masking governance issues.

**Economic Inflexibility:** If market conditions require fee adjustments (e.g., token price changes making 100 ELF prohibitively expensive), governance cannot respond without a full contract upgrade, despite the interface suggesting dynamic fee management is supported.

**Trust Degradation:** When governance discovers their fee changes have no effect despite successful transactions, it undermines trust in the system and creates confusion about which contracts actually support governance.

The severity is Medium because while no funds are directly at risk, it affects operational governance integrity and violates interface contract expectations defined by the ACS1 standard. [7](#0-6) 

### Likelihood Explanation

**High Likelihood:** Any governance attempt to modify NFT contract fees will trigger this issue. The scenario requires no special privileges beyond normal Parliament proposal authority, making it easily reachable through standard governance operations.

**Attacker Capability:** Not applicable - this affects legitimate governance operations, not malicious actors.

**Execution Practicality:** The standard governance flow (proposal creation, miner approval, release) will execute successfully with no indication of failure. [8](#0-7) 

**Detection Difficulty:** The issue is difficult to detect because transactions return success status. Only subsequent queries to `GetMethodFee` reveal the problem, and governance tooling may not automatically verify the result of fee changes.

**Probability:** If governance ever attempts to adjust NFT creation fees (reasonable given economic fluctuations), the issue will manifest with 100% certainty.

### Recommendation

**Option 1 (Recommended): Implement Full ACS1 Compliance**

Add proper state management and authorization:
```csharp
// In NFTContractState.cs
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }

// In NFTContract_ACS1.cs
public override Empty SetMethodFee(MethodFees input)
{
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}

public override MethodFees GetMethodFee(StringValue input)
{
    var fees = State.TransactionFees[input.Value];
    if (fees == null || fees.Fees.Count == 0)
    {
        // Return default hardcoded fee for Create
        if (input.Value == nameof(Create))
            return new MethodFees { /* hardcoded values */ };
    }
    return fees ?? new MethodFees();
}
```

**Option 2 (Alternative): Explicit Rejection**

If fees should remain immutable, actively reject governance attempts:
```csharp
public override Empty SetMethodFee(MethodFees input)
{
    Assert(false, "Method fee management not supported - fees are hardcoded and require contract upgrade to modify.");
    return new Empty();
}
```

**Test Cases:** Add tests verifying:
1. Unauthorized SetMethodFee calls are rejected
2. Authorized SetMethodFee calls (via Parliament) successfully modify fees
3. GetMethodFee returns the newly set values
4. Attempting to set invalid tokens/amounts fails with clear error messages [9](#0-8) 

### Proof of Concept

**Initial State:**
- NFT contract deployed with hardcoded Create fee of 100 ELF
- Parliament governance system operational

**Exploitation Steps:**

1. Governance creates proposal to reduce Create fee from 100 ELF to 10 ELF:
   ```
   CreateProposal(
     ToAddress: NFTContractAddress,
     MethodName: "SetMethodFee",
     Params: { MethodName: "Create", Fees: [{ Symbol: "ELF", BasicFee: 10_00000000 }] }
   )
   ```

2. Miners approve the proposal (reaches threshold)

3. Proposal is released:
   ```
   Release(proposalId) → Returns success (TransactionResultStatus.Mined)
   ```

4. Query the fee:
   ```
   GetMethodFee("Create") → Returns { Symbol: "ELF", BasicFee: 100_00000000 }
   ```

**Expected Result:** Fee should be 10 ELF (10_00000000)

**Actual Result:** Fee remains 100 ELF (100_00000000)

**Success Condition:** Audit logs show successful SetMethodFee execution, but fee is unchanged, confirming silent failure.

This demonstrates the governance process appears to work but has no actual effect, creating the inconsistency described in the security question.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-36)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L130-158)
```csharp
    public async Task SetMethodFee_Success_Test()
    {
        var methodName = "Transfer";
        var tokenSymbol = NativeTokenInfo.Symbol;
        var basicFee = 100;
        var methodFeeController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
        var proposalMethodName = nameof(TokenContractStub.SetMethodFee);
        var methodFees = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
            }
        };
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            methodFeeController.OwnerAddress, proposalMethodName, methodFees);
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var afterUpdateMethodFees = await TokenContractStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = methodName
        });
        var tokenFee = afterUpdateMethodFees.Fees.SingleOrDefault(x => x.Symbol == tokenSymbol);
        tokenFee.BasicFee.ShouldBe(basicFee);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L160-232)
```csharp
    [Fact]
    public async Task SetMethodFee_Fail_Test()
    {
        var tokenSymbol = NativeTokenInfo.Symbol;
        var methodName = "Transfer";
        // unauthorized
        {
            var basicFee = 100;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Unauthorized to set method fee");
        }

        // invalid fee
        {
            var basicFee = 0;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Invalid amount");
        }

        //invalid token symbol
        {
            var basicFee = 100;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = "NOTEXIST", BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Token is not found");
        }

        // token is not profitable
        {
            var tokenNotProfitable = "DLS";
            await CreateMutiTokenAsync(TokenContractStub,new CreateInput
            {
                Symbol = tokenNotProfitable,
                TokenName = "name",
                Issuer = DefaultAddress,
                Owner = DefaultAddress,
                TotalSupply = 1000_000
            });
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenNotProfitable, BasicFee = 100 }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain($"Token {tokenNotProfitable} cannot set as method fee.");
        }
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** docs-sphinx/reference/acs/acs1.rst (L14-24)
```text
+-----------------------------+------------------------------------------------------------------+------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| Method Name                 | Request Type                                                     | Response Type                                        | Description                                                                                          |
+=============================+==================================================================+======================================================+======================================================================================================+
| SetMethodFee                | `acs1.MethodFees <#acs1.MethodFees>`__                           | `google.protobuf.Empty <#google.protobuf.Empty>`__   | Set the method fees for the specified method. Note that this will override all fees of the method.   |
+-----------------------------+------------------------------------------------------------------+------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| ChangeMethodFeeController   | `AuthorityInfo <#AuthorityInfo>`__                               | `google.protobuf.Empty <#google.protobuf.Empty>`__   | Change the method fee controller, the default is parliament and default organization.                |
+-----------------------------+------------------------------------------------------------------+------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| GetMethodFee                | `google.protobuf.StringValue <#google.protobuf.StringValue>`__   | `acs1.MethodFees <#acs1.MethodFees>`__               | Query method fee information by method name.                                                         |
+-----------------------------+------------------------------------------------------------------+------------------------------------------------------+------------------------------------------------------------------------------------------------------+
| GetMethodFeeController      | `google.protobuf.Empty <#google.protobuf.Empty>`__               | `AuthorityInfo <#AuthorityInfo>`__                   | Query the method fee controller.                                                                     |
+-----------------------------+------------------------------------------------------------------+------------------------------------------------------+------------------------------------------------------------------------------------------------------+
```
