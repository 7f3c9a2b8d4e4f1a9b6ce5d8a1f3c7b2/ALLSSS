### Title
Non-Retroactive Vote Weight Updates Allow Early Voters to Maintain Permanently Inflated Profit Shares After Interest Rate Decreases

### Summary
The `SetVoteWeightInterest()` function modifies interest rate parameters globally but does not retroactively recalculate weights for existing votes. When governance decreases interest rates, early voters who locked tokens under higher rates maintain permanently inflated vote weights (profit shares), while new voters receive proportionally lower weights for identical stakes and lock periods. This creates systemic unfairness in welfare profit distribution that persists until old votes expire.

### Finding Description

The vulnerability exists at the intersection of three contract mechanisms:

**1. Interest Rate Update Without Retroactive Effect** [1](#0-0) 

The `SetVoteWeightInterest()` function updates the global `State.VoteWeightInterestList.Value` but contains no logic to iterate through and recalculate existing vote weights.

**2. Vote Weight Calculation at Voting Time Only** [2](#0-1) 

When users call `Vote()`, the weight is calculated once using the current interest rates via `GetVotesWeight()` and stored as "shares" in the profit scheme. [3](#0-2) 

The `GetVotesWeight()` function applies compound interest formula: `initBase = 1 + Interest/Capital`, then `weight = Pow(initBase, lockDays) * votesAmount + proportional_bonus`. This weight becomes the beneficiary's profit shares.

**3. Weight Preservation in Profit Details** [4](#0-3) 

Vote weights are stored as shares in profit details and persist unchanged throughout the vote's lifetime. Even when `ExtendVoterWelfareProfits()` is called during vote target changes, the underlying `FixProfitDetail` mechanism preserves original shares. [5](#0-4) 

The `FixProfitDetail()` method clones existing profit details and only updates period boundaries - it explicitly preserves the original shares value.

**Evidence of Incomplete Implementation** [6](#0-5) 

A `FixTotalWeightsInput` message exists in the protocol definition but has no corresponding implementation in the contract code. [7](#0-6) 

The `WeightsAlreadyFixedMap` state variable exists but is never set to `true` anywhere in the codebase - it's only checked and removed, suggesting abandoned functionality.

### Impact Explanation

**Concrete Harm - Unfair Profit Distribution:**

Using default interest rates as baseline:
- **Scenario**: Governance decreases 365-day interest from `Interest=1, Capital=1000` (0.1% daily) to `Interest=1, Capital=10000` (0.01% daily)
- **Early Voter**: Locked 1,000,000 tokens for 365 days under old rates
  - Weight = (1.001)^365 × 1,000,000 + proportional_bonus ≈ 1,440,000 shares
- **New Voter**: Locks identical 1,000,000 tokens for 365 days under new rates  
  - Weight = (1.0001)^365 × 1,000,000 + proportional_bonus ≈ 1,037,000 shares
- **Impact**: Early voter receives ~39% more welfare profits than new voter for identical economic commitment

**Who Is Affected:**
- All new voters are disadvantaged compared to legacy voters
- Welfare profit scheme becomes inequitable
- Governance policy changes are undermined - interest rate adjustments fail to apply uniformly

**Severity Justification:**
This is a **High severity** systemic issue:
- Affects core economic incentive mechanism
- Creates permanent two-tier voter system
- No self-correcting mechanism (persists until old votes naturally expire)
- Undermines governance authority over economic parameters
- Quantifiable: voters can maintain 1.5x-10x weight advantages depending on rate changes

### Likelihood Explanation

**Attacker Capabilities:**
Any voter with capital to lock can exploit this by front-running governance proposals.

**Attack Complexity:**
**Low** - The exploitation path is straightforward:
1. Monitor governance proposals for interest rate decreases
2. Vote with maximum amount and longest lock time before proposal executes
3. Maintain inflated weight throughout lock period with no further action required

**Feasibility Conditions:**
- **Entry Point**: Public `Vote()` function is unrestricted [8](#0-7) 
- **Preconditions**: Only requires governance decision to decrease interest rates (realistic - rates may be adjusted for economic reasons)
- **Execution**: Single transaction before rate change takes effect
- **Cost**: Requires locking capital, but capital is returned after lock period with bonus profits

**Economic Rationality:**
Highly rational - attacker gains disproportionate welfare profits with zero risk beyond opportunity cost of locked capital.

**Probability Assessment:**
**High likelihood** when interest rate governance changes occur:
- Front-running governance execution is trivial
- Multiple voters will naturally be affected across any rate change
- Rational economic actors will maximize returns under available rules
- Issue persists across all future rate decreases until fixed

### Recommendation

**Immediate Mitigation:**

Implement the abandoned `FixTotalWeights` functionality to allow retroactive weight updates:

1. **Complete the FixTotalWeights Implementation:**
   - Create batch weight recalculation function accepting vote IDs
   - For each vote ID, recalculate weight using current interest rates and original lock parameters
   - Call Profit contract's `RemoveBeneficiary` then `AddBeneficiary` with new shares
   - Set `WeightsAlreadyFixedMap[voteId] = true` to mark as updated

2. **Add Invariant Checks:**
   - Before executing interest rate changes via `SetVoteWeightInterest()`, require either:
     - All active votes have weights updated (check via `WeightsAlreadyFixedMap`)
     - OR explicit governance acknowledgment of creating weight disparity
   
3. **Alternative Design Pattern:**
   - Store interest rate version number with each vote
   - Calculate effective weight dynamically by applying current rates to stored parameters
   - This eliminates retroactive update complexity entirely

**Test Cases to Add:**
- Test interest rate decrease followed by new vote - verify weights differ appropriately
- Test batch weight update function updates all active votes correctly
- Test profit distribution reflects updated weights accurately
- Test that `WeightsAlreadyFixedMap` prevents duplicate updates

### Proof of Concept

**Initial State:**
- Interest rate configuration: Day=365, Interest=1, Capital=1000 (0.1% daily)
- Time proportion: 2, Amount proportion: 1
- No existing votes in system

**Exploitation Steps:**

1. **Alice votes before rate change** (Block N):
   - Calls `Vote()` with 1,000,000 tokens, 365-day lock
   - Weight calculated: (1.001)^365 × 1,000,000 + (1,000,000 × 1 / 2) ≈ 1,940,000 shares
   - Alice added to Welfare scheme with 1,940,000 shares

2. **Governance decreases interest rates** (Block N+100):
   - Parliament calls `SetVoteWeightInterest()` with Interest=1, Capital=10000 (0.01% daily)
   - Global state updated, Alice's existing 1,940,000 shares unchanged

3. **Bob votes after rate change** (Block N+200):
   - Calls `Vote()` with identical 1,000,000 tokens, 365-day lock  
   - Weight calculated: (1.0001)^365 × 1,000,000 + (1,000,000 × 1 / 2) ≈ 1,537,000 shares
   - Bob added to Welfare scheme with 1,537,000 shares

**Expected vs Actual Result:**

**Expected (Fair):** Alice and Bob should receive equal welfare profits for equal economic commitment

**Actual (Exploited):** Alice receives 1,940,000 / 1,537,000 ≈ **1.26x more welfare profits** than Bob for the same stake and duration, persisting for the entire 365-day lock period

**Success Condition:** 
Verify profit distribution at any period shows Alice's profit share is (1,940,000 / total_shares) while Bob's is (1,537,000 / total_shares), despite identical voting parameters except timing relative to interest rate change.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L530-533)
```text
message FixTotalWeightsInput {
    repeated aelf.Hash vote_ids = 1;
    
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L99-99)
```csharp
    public MappedState<Hash, bool> WeightsAlreadyFixedMap { get; set; }
```
