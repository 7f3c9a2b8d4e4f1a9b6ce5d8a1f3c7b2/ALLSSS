Based on my comprehensive analysis of the AElf consensus codebase, I have validated this security claim and confirmed it is a **valid vulnerability**.

# Audit Report

## Title
Miner Subset Exclusion Attack via Unvalidated ProvidedRound Miner List in NextRound Transitions

## Summary
The NextRound consensus transition validation fails to verify that the `ProvidedRound` contains all miners from the current `BaseRound`. A malicious miner can submit a `NextRoundInput` with an incomplete miner list, pass all validations, and commit corrupted consensus state that excludes legitimate miners from participation and rewards.

## Finding Description

The vulnerability exists in the validation logic for NextRound consensus transitions. The `NextRoundMiningOrderValidationProvider` performs only internal consistency checks within the provided round data: [1](#0-0) 

This validator compares the count of miners with `FinalOrderOfNextRound > 0` against miners with `OutValue != null`, but both counts are derived from the SAME `ProvidedRound.RealTimeMinersInformation` collection. There is no comparison against `BaseRound` to ensure completeness.

During NextRound behavior validation, the active validators are: [2](#0-1) 

The `MiningPermissionValidationProvider` only validates that the sender exists in BaseRound: [3](#0-2) 

None of the validators compare the miner list membership or count between `ProvidedRound` and `BaseRound`. The `ProvidedRound` comes from the `NextRoundInput` submitted by the block producer via the consensus header extra data: [4](#0-3) 

After validation passes, `ProcessNextRound` converts the input and commits it directly to state: [5](#0-4) 

The `ToRound()` conversion preserves whatever miners exist in the input without validation: [6](#0-5) 

The legitimate `GenerateNextRoundInformation` method preserves all miners from the current round: [7](#0-6) 

However, a malicious miner can bypass this by manually crafting a reduced `NextRoundInput` after calling `GetConsensusExtraData`: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Compromise**: An attacker can arbitrarily reduce the active consensus set from N to M miners (M < N), directly violating the miner schedule integrity invariant that all elected miners should participate in consensus.

**Reward Misallocation**: Excluded miners lose 100% of their mining rewards for all rounds until an honest miner produces the next NextRound block and restores the full miner list. In a 7-miner network where 2 miners are excluded, each remaining miner receives a 40% increase in rewards at the expense of the victims.

**Security Degradation**: Reducing the active miner set decreases Byzantine fault tolerance. A network that can normally tolerate 2 malicious miners (2/7 < 33%) becomes vulnerable when reduced to 5 miners, where 2 malicious miners represent 40% of the set.

**Operational Denial-of-Service**: Excluded miners cannot produce blocks despite being validly elected, creating a protocol-level DoS condition that persists across multiple rounds.

## Likelihood Explanation

**Reachable Entry Point**: Any current miner can execute this attack via the public `NextRound` method: [9](#0-8) 

**Minimal Attacker Capabilities**: The attacker only needs to:
1. Be an active miner with normal block production rights
2. Wait for their turn to produce the NextRound transition block  
3. Call `GetConsensusExtraData` to generate legitimate round data
4. Manually remove target miners from `RealTimeMinersInformation`
5. Submit both block header and transaction with the modified data

**No Special Privileges Required**: The attack uses normal miner permissions without requiring governance control, election manipulation, or system contract compromise.

**Attack Complexity**: LOW - The validation logic provides no defense against miner list manipulation. The attacker can ensure internal consistency is maintained (empty miners have consistent `FinalOrderOfNextRound` and `OutValue` fields) while excluding targets.

**Economic Rationality**: HIGH - Colluding miners gain 20-40% reward increases by excluding competitors, with minimal cost (one block production opportunity). The incentive is particularly strong during high-reward periods.

## Recommendation

Add a validator that compares the miner list between `BaseRound` and `ProvidedRound` during NextRound transitions. Implement in `NextRoundMiningOrderValidationProvider` or create a new dedicated validator:

```csharp
// Add to NextRound validation providers
public class MinerListCompletenessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRoundMiners = validationContext.BaseRound.RealTimeMinersInformation.Keys;
        var providedRoundMiners = validationContext.ProvidedRound.RealTimeMinersInformation.Keys;
        
        // Check that all miners from BaseRound are present in ProvidedRound
        foreach (var baseMiner in baseRoundMiners)
        {
            if (!providedRoundMiners.Contains(baseMiner))
            {
                validationResult.Message = $"Miner {baseMiner} missing from ProvidedRound";
                return validationResult;
            }
        }
        
        // For NextRound (not NextTerm), miner count should match exactly
        if (baseRoundMiners.Count != providedRoundMiners.Count)
        {
            validationResult.Message = "Miner count mismatch between BaseRound and ProvidedRound";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this validator to the NextRound behavior validation list in `ValidateBeforeExecution`: [10](#0-9) 

## Proof of Concept

A PoC would involve:

1. Deploy a test network with N miners (e.g., 7 miners)
2. Advance to a point where one miner is scheduled to produce the NextRound block
3. Have that miner call `GetConsensusExtraData` to generate legitimate round data
4. Modify the returned `AElfConsensusHeaderInformation.Round.RealTimeMinersInformation` to remove target miners
5. Create a `NextRoundInput` from the modified round
6. Submit the `NextRound` transaction with the modified input
7. Verify that validation passes and the modified round is committed to state
8. Confirm that excluded miners no longer appear in `GetCurrentRoundInformation`
9. Verify that excluded miners cannot produce blocks in subsequent rounds

The vulnerability is confirmed by the absence of any miner list comparison validation in the codebase.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-92)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
