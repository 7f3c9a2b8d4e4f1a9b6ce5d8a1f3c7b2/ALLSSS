### Title
Side Chain Consensus Deadlock Due to Systematic NextRound Transaction Execution Failures

### Summary
Side chains always return `NextRound` behavior to terminate rounds with no alternative fallback mechanism. If `NextRound` transactions systematically fail during execution (due to gas exhaustion, state errors, or contract bugs), all miners past their time slots will repeatedly attempt the same failing `NextRound` transition, causing complete chain halt with no automatic recovery path.

### Finding Description

**Root Cause:**

The side chain consensus behavior provider unconditionally returns `NextRound` when terminating a round: [1](#0-0) 

This is called from the base consensus behavior logic when a miner's time slot has passed: [2](#0-1) 

**Execution Path Without Recovery:**

When miners request consensus commands, side chains instantiate the behavior provider: [3](#0-2) 

The `NextRound` behavior generates a transaction that must execute `ProcessNextRound`: [4](#0-3) 

Critical operations include updating the round number: [5](#0-4) 

Which validates the round number increment: [6](#0-5) 

**Why Existing Protections Fail:**

The retry mechanism only handles validation failures (before execution), not execution failures: [7](#0-6) 

Validation checks occur before execution and cannot prevent execution-time failures: [8](#0-7) 

When consensus commands are requested after a failed round transition, the system still sees the old round: [9](#0-8) 

### Impact Explanation

**Operational Impact - Complete Chain Halt:**

If `NextRound` transactions fail systematically due to:
- Gas exhaustion in complex state operations
- State corruption preventing round updates  
- Contract bugs in `ProcessNextRound` logic
- Resource limits in `AddRoundInformation` or `RecordMinedMinerListOfCurrentRound`

Then every subsequent miner will:
1. Query consensus command based on old round N
2. Determine their time slot has passed
3. Receive `NextRound` behavior (no alternative for side chains)
4. Attempt transition to round N+1
5. Fail with the same systematic error
6. Leave round number unchanged at N

**Severity: High**
- Complete consensus failure - no blocks can be produced
- Affects all side chain operations (transactions, cross-chain messages, state updates)
- No automatic recovery - requires manual intervention or chain restart
- All miners are blocked simultaneously once their time slots pass

### Likelihood Explanation

**Feasibility Conditions:**

The vulnerability requires a systematic execution failure in `NextRound`, which could occur through:

1. **Gas Exhaustion**: Large miner sets or complex state operations could exceed gas limits during `RecordMinedMinerListOfCurrentRound` or `AddRoundInformation`

2. **State Corruption**: Database errors or state inconsistencies could cause `TryToUpdateRoundNumber` to fail or `State.Rounds` operations to throw exceptions

3. **Contract Logic Bugs**: Undetected bugs in round generation or validation logic could cause Assert failures

4. **Resource Constraints**: Memory or storage limits in constrained environments

**Attack Complexity:**
- No attacker required - can occur naturally
- Only requires triggering condition to persist
- Once triggered, self-perpetuating until manually resolved

**Detection:**
- Observable through chain halt (no new blocks)
- All miners logging NextRound execution failures
- Current round number frozen

**Probability:**
While not expected in normal operation, the impact severity and lack of recovery mechanism make this a high-risk issue. Side chains have no fallback behavior, unlike main chains which can alternate between `NextRound` and `NextTerm`.

### Recommendation

**Primary Fix - Add Fallback Behavior:**

Modify `SideChainConsensusBehaviourProvider` to include fallback logic when round progression is stuck:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check if round has been stuck (multiple failed NextRound attempts)
    if (IsRoundProgessionStuck())
    {
        // Allow continuing in current round with UpdateValue
        return AElfConsensusBehaviour.UpdateValue;
    }
    return AElfConsensusBehaviour.NextRound;
}
```

**Secondary Fix - Add Execution Failure Recovery:**

Implement a recovery mechanism similar to validation retries but for execution failures:
1. Track failed `NextRound` execution attempts in state
2. After threshold failures, allow miners to produce blocks without round transition
3. Implement manual round reset via governance

**Invariant Checks:**

Add monitoring for:
- Round number progression rate (alert if stuck)
- Consecutive NextRound failures (trigger recovery)
- Time since last successful round transition

**Test Cases:**

1. Simulate gas exhaustion in `ProcessNextRound`
2. Test behavior when `TryToUpdateRoundNumber` fails
3. Verify recovery when multiple miners encounter same failure
4. Test manual intervention procedures

### Proof of Concept

**Initial State:**
- Side chain at round N
- All miners have completed their time slots in round N
- Miner list: [A, B, C]

**Exploitation Steps:**

1. **Introduce systematic failure** (simulated via gas limit reduction or state corruption):
   - Configure environment so `ProcessNextRound` exceeds gas limits
   - OR corrupt `State.CurrentRoundNumber` to cause validation failure

2. **Miner A attempts NextRound:**
   - Queries `GetConsensusCommand` → receives `NextRound` behavior
   - Generates NextRound transaction for round N+1
   - Transaction execution fails (gas exhausted or Assert failure)
   - Block rejected, round remains at N

3. **Miner B attempts NextRound:**
   - Queries current round → still round N
   - Time slot passed → receives `NextRound` behavior  
   - Generates NextRound transaction for round N+1
   - Same failure occurs
   - Round remains at N

4. **Miner C attempts NextRound:**
   - Same pattern repeats
   - All miners past their time slots
   - All receive only `NextRound` behavior
   - All fail with same error

5. **Chain halted:**
   - No miner can produce blocks
   - Round stuck at N indefinitely
   - No automatic recovery mechanism triggered

**Success Condition:**
Chain stops producing blocks. All consensus command requests return `NextRound` behavior but all NextRound transactions fail execution, leaving the round number unchanged and preventing any miner from producing valid blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L44-46)
```csharp
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L91-97)
```csharp
    private bool TryToUpdateRoundNumber(long roundNumber)
    {
        var oldRoundNumber = State.CurrentRoundNumber.Value;
        if (roundNumber != 1 && oldRoundNumber + 1 != roundNumber) return false;
        State.CurrentRoundNumber.Value = roundNumber;
        return true;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/ConsensusValidationFailedEventHandler.cs (L28-40)
```csharp
    public async Task HandleEventAsync(ConsensusValidationFailedEventData eventData)
    {
        if (eventData.IsReTrigger)
        {
            Logger.LogTrace("Re-trigger consensus because validation failed.");
            var chain = await _blockchainService.GetChainAsync();
            await _consensusService.TriggerConsensusAsync(new ChainContext
            {
                BlockHash = chain.BestChainHash,
                BlockHeight = chain.BestChainHeight
            });
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
