### Title
Irreversible One-Way Restriction on Miner Increase Interval Enables Unrecoverable Rapid Miner Growth

### Summary
The `SetMinerIncreaseInterval()` function contains a flawed assertion that only allows the interval to decrease or stay the same, never increase. This creates an irreversible governance trap where if the interval is accidentally set too low, the blockchain's miner count will grow at an excessively rapid rate with no mechanism to slow it down, causing permanent operational degradation.

### Finding Description

The `SetMinerIncreaseInterval()` function at line 61 contains the assertion: [1](#0-0) 

This assertion requires `input.Value <= State.MinerIncreaseInterval.Value`, meaning the new interval value must be less than or equal to the current value. This restriction is backwards from what would be expected for flexible governance control.

The miner increase interval directly controls the rate of automatic miner count growth via the formula in `GetMinersCount()`: [2](#0-1) 

The calculation adds `(elapsed_seconds / MinerIncreaseInterval) * 2` additional miners to the base count. A smaller interval causes faster miner growth. With the default value of 31,536,000 seconds (1 year), the system adds 2 miners per year: [3](#0-2) 

The restriction is confirmed by the test suite which explicitly verifies that attempting to increase the interval fails with "Invalid interval", while decreasing it succeeds: [4](#0-3) 

There are only two places where `MinerIncreaseInterval` can be set: during initialization [5](#0-4)  and via this governance function [6](#0-5) . No alternative recovery mechanism exists.

### Impact Explanation

**Irreversible Operational Degradation:**
If governance accidentally sets the interval too low (e.g., from 31,536,000 seconds to 86,400 seconds - one day), the miner growth rate accelerates by 365x (from 2 miners/year to 2 miners/day). This causes:

1. **Rapid Network Expansion**: Uncontrolled miner count growth beyond intended capacity
2. **Consensus Overhead**: More miners means longer consensus rounds and increased coordination complexity
3. **Economic Distortion**: Reward dilution across unexpectedly large miner sets
4. **No Recovery Path**: The one-way restriction prevents reverting to a slower growth rate

The base miner count is 17: [7](#0-6) 

With an accidentally low interval, this could grow to hundreds of miners within months instead of the intended gradual decades-long scaling.

**Who is Affected:**
- Network operators must support unexpectedly large miner sets
- Token holders face diluted consensus rewards
- The entire blockchain experiences reduced efficiency

### Likelihood Explanation

**Execution Path:**
This requires governance approval via the MaximumMinersCountController (default: Parliament): [8](#0-7) 

**Feasibility:**
While this requires governance action rather than an adversarial attack, the risk is HIGH because:

1. **Operational Mistakes Happen**: Governance proposals may misunderstand the one-way nature
2. **Poor Error Messaging**: "Invalid interval" doesn't explain why increases are forbidden
3. **No Documentation**: Neither the protobuf definition [9](#0-8)  nor documentation indicates this restriction is intentional
4. **Irreversibility**: A single governance mistake causes permanent harm
5. **Human Error**: Operators might intend to slow growth but are unable to do so

The test suite confirms the restriction exists but provides no justification for why it's designed this way.

### Recommendation

**Code-Level Fix:**
Remove or reverse the assertion to allow bidirectional changes:

```csharp
// Option 1: Allow any positive interval (recommended)
Assert(input.Value > 0, "Miner increase interval must be positive.");

// Option 2: Allow only increases if one-way is truly needed
Assert(input.Value >= State.MinerIncreaseInterval.Value, 
    "Can only increase interval to slow miner growth.");
```

**Additional Safeguards:**
1. Add range validation (e.g., minimum 1 day, maximum 10 years)
2. Improve error messages to explain the impact of changes
3. Add documentation warning about growth rate implications
4. Consider a time-lock period before interval changes take effect

**Test Cases:**
1. Verify interval can be both increased and decreased
2. Test boundary conditions (very small/large intervals)
3. Validate miner count calculations with various interval changes
4. Add regression test for bidirectional updates

### Proof of Concept

**Initial State:**
- Current `MinerIncreaseInterval`: 31,536,000 seconds (1 year)
- Blockchain age: 2 years
- Expected miner growth: +4 miners total

**Attack Sequence:**
1. Governance accidentally approves proposal to set interval to 86,400 seconds (1 day)
2. Interval update succeeds due to `86400 <= 31536000`
3. Miner count now grows at 2 miners per day instead of 2 per year
4. After 30 days: +60 additional miners instead of expected +0.16
5. Governance attempts to revert by increasing interval back to 31,536,000
6. Transaction fails: `Assert(31536000 <= 86400, "Invalid interval")` 
7. Network permanently locked into rapid miner growth with no recovery

**Success Condition:**
The inability to reverse an interval decrease demonstrates the one-way trap, confirming the business logic vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L58-60)
```csharp
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L61-61)
```csharp
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L62-62)
```csharp
        State.MinerIncreaseInterval.Value = input.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L386-390)
```csharp
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L121-146)
```csharp
        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** protobuf/aedpos_contract.proto (L54-56)
```text
    // Set miner increase interval
    rpc SetMinerIncreaseInterval (google.protobuf.Int64Value) returns (google.protobuf.Empty){
    }
```
