### Title
Off-By-One Error in GetAllChainsIdAndHeight() Invalidates Genesis Block Height and Causes Cross-Chain DoS

### Summary
The `GetAllChainsIdAndHeight()` function incorrectly validates parent chain height using a strict greater-than comparison (`>`) instead of greater-than-or-equal (`>=`), causing it to reject the valid genesis block height of 1. This creates a denial-of-service condition for side chains created early in the parent chain's lifecycle, preventing cross-chain cache initialization and data updates.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The assertion uses `parentChainHeight > AElfConstants.GenesisBlockHeight` where `AElfConstants.GenesisBlockHeight` is defined as 1: [2](#0-1) 

**How CurrentParentChainHeight is Set:**
During side chain initialization, the `CurrentParentChainHeight` is set to `CreationHeightOnParentChain - 1`: [3](#0-2) 

This creates two problematic scenarios:

1. **Side chain created at parent height 2**: `CurrentParentChainHeight = 1`. Before indexing any parent blocks, calling `GetAllChainsIdAndHeight()` fails because 1 is not > 1.

2. **Side chain created at parent height 1 (genesis)**: `CurrentParentChainHeight = 0` initially. After indexing the parent genesis block, `CurrentParentChainHeight = 1`, but the function still fails permanently because 1 is not > 1.

**Why Protection Fails:**
The comparison should be `>=` instead of `>` to allow the genesis block height (1) as a valid value. The current logic incorrectly treats height 1 as invalid, contradicting the system's own test expectations: [4](#0-3) 

The test explicitly expects parent chain height 1 to be valid and returned, but only passes because it uses a mock implementation that bypasses the actual contract assertion: [5](#0-4) 

### Impact Explanation

**Operational Impact - Cross-Chain System DoS:**
The function is called by `GetAllChainIdHeightPairsAtLibAsync()` which is critical for cross-chain operations: [6](#0-5) 

This method is used in two critical flows: [7](#0-6) [8](#0-7) 

**Affected Parties:**
- Side chains created at parent chain height 1 or 2 are permanently affected
- Cross-chain cache cannot be initialized or updated
- Parent chain block data cannot be properly indexed
- All cross-chain functionality (verification, indexing, merkle proofs) becomes unavailable

**Severity Justification:**
While Low severity in production environments (side chains typically created much later), this becomes High severity in:
- Genesis block initialization scenarios
- Test environments
- Early parent chain lifecycle deployments

### Likelihood Explanation

**Feasibility Conditions:**
- Side chain creation has no minimum parent chain height validation: [9](#0-8) 

- The `CreateSideChain` method directly uses `Context.CurrentHeight` without bounds checking

**Attack Complexity:**
No attack needed - this is a natural system failure when:
1. Side chain is deployed during genesis or early blocks
2. Cross-chain initialization is triggered before sufficient parent chain indexing
3. Test environments routinely hit this condition

**Execution Practicality:**
The bug is triggered through normal operations without any special attacker capabilities. The function is a public view method callable by anyone.

**Probability Reasoning:**
- Low in production: Side chain creation typically occurs after governance processes taking multiple blocks
- High in test/development: Genesis scenarios and early-stage testing commonly trigger this
- Possible in practice: No technical barrier prevents early side chain creation

### Recommendation

**Code-Level Mitigation:**
Change the assertion in `GetAllChainsIdAndHeight()` from:
```csharp
Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
```

To:
```csharp
Assert(parentChainHeight >= AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
```

**Invariant Check to Add:**
The condition should allow any parent chain height that is greater than or equal to the genesis block height, as this represents a valid indexed state.

**Test Cases to Add:**
1. Test `GetAllChainsIdAndHeight()` with `CurrentParentChainHeight = 1` (should pass)
2. Test side chain initialization when `CreationHeightOnParentChain = 1` (genesis block scenario)
3. Test side chain initialization when `CreationHeightOnParentChain = 2` with immediate cross-chain cache initialization
4. Integration test that calls the actual contract method instead of relying on mocks

### Proof of Concept

**Required Initial State:**
1. Deploy parent chain at genesis (height 1)
2. Create side chain at parent chain height 2
3. Side chain state: `CreationHeightOnParentChain = 2`, `CurrentParentChainHeight = 1`

**Transaction Steps:**
1. Call `GetAllChainsIdAndHeight()` on the side chain's CrossChain contract
2. Function executes: `GetParentChainHeight()` returns 1
3. Assertion evaluates: `Assert(1 > 1, "Invalid parent chain height")`

**Expected vs Actual Result:**
- **Expected**: Function returns `ChainIdAndHeightDict` containing parent chain with height 1
- **Actual**: Function reverts with "Invalid parent chain height" assertion failure

**Success Condition:**
After fixing the assertion to use `>=`, the function should successfully return the parent chain data even when `CurrentParentChainHeight = 1`, matching the test expectations and allowing cross-chain operations to proceed normally.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L125-125)
```csharp
        Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
```

**File:** src/AElf.Types/AElfConstants.cs (L6-6)
```csharp
        public const long GenesisBlockHeight = 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L18-18)
```csharp
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L151-151)
```csharp
            CreationHeightOnParentChain = Context.CurrentHeight,
```

**File:** test/AElf.CrossChain.Core.Tests/Indexing/CrossChainIndexingDataServiceTests.cs (L731-740)
```csharp
        _crossChainTestHelper.AddFakeParentChainIdHeight(parentChainId, 1);

        var sideChainId = ChainHelper.GetChainId(100);
        _crossChainTestHelper.AddFakeSideChainIdHeight(sideChainId, 0);

        {
            var allChainIdAndHeightResult =
                await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();
            allChainIdAndHeightResult.IdHeightDict[parentChainId].ShouldBe(1);
            allChainIdAndHeightResult.IdHeightDict[sideChainId].ShouldBe(0);
```

**File:** test/AElf.CrossChain.Core.Tests/CrossChainTestHelper.cs (L88-94)
```csharp
        if (methodName == nameof(CrossChainContractImplContainer.CrossChainContractImplStub.GetAllChainsIdAndHeight))
        {
            var dict = new ChainIdAndHeightDict();
            dict.IdHeightDict.Add(_sideChainIdHeights);
            dict.IdHeightDict.Add(_parentChainIdHeight);
            return dict.ToByteArray();
        }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L157-176)
```csharp
    public async Task<ChainIdAndHeightDict> GetAllChainIdHeightPairsAtLibAsync()
    {
        var isReadyToCreateChainCache =
            await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!isReadyToCreateChainCache)
            return new ChainIdAndHeightDict();
        var lib = await _irreversibleBlockStateProvider.GetLastIrreversibleBlockHashAndHeightAsync();
        return await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = lib.BlockHash,
                BlockHeight = lib.BlockHeight,
                ContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
                {
                    BlockHash = lib.BlockHash,
                    BlockHeight = lib.BlockHeight
                })
            }).GetAllChainsIdAndHeight
            .CallAsync(new Empty());
    }
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L26-34)
```csharp
    public async Task FinishInitialSyncAsync()
    {
        CrossChainConfigOptions.Value.CrossChainDataValidationIgnored = false;
        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();
        foreach (var chainIdHeight in chainIdHeightPairs.IdHeightDict)
            // register new chain
            _crossChainCacheEntityService.RegisterNewChain(chainIdHeight.Key, chainIdHeight.Value);
    }
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L36-48)
```csharp
    public async Task UpdateCrossChainDataWithLibAsync(Hash blockHash, long blockHeight)
    {
        if (CrossChainConfigOptions.Value.CrossChainDataValidationIgnored
            || blockHeight <= AElfConstants.GenesisBlockHeight)
            return;

        _crossChainIndexingDataService.UpdateCrossChainDataWithLib(blockHash, blockHeight);

        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();

        await _crossChainCacheEntityService.UpdateCrossChainCacheAsync(blockHash, blockHeight, chainIdHeightPairs);
    }
```
