### Title
Alias Chain Attack via Unchecked Target Validation in SetTokenAlias

### Summary
The `SetTokenAlias` function allows creation of alias chains (A→B→C) where an alias points to another alias instead of a real token. This occurs because SetTokenAlias validates only the alias name format but never checks whether the target symbol is itself an alias. When `GetTokenInfo` or `GetActualTokenSymbol` attempts to resolve a chained alias, they perform only single-level resolution and return null, causing complete denial of service for all operations involving the aliased token.

### Finding Description
The vulnerability exists in the token alias creation flow through `SetTokenAlias`: [1](#0-0) 

When extracting alias settings from ExternalInfo during token creation: [2](#0-1) 

The extracted `symbol` (target) is set directly into `SymbolAliasMap[alias]` without validation. The only check performed is `CheckTokenAlias` which validates the alias name format: [3](#0-2) 

This validation ensures the alias matches the collection prefix but **never checks whether the target `symbol` is itself an alias**.

The function is invoked during token creation when ExternalInfo contains alias settings: [4](#0-3) 

The critical issue is that `GetTokenInfo` performs only single-level alias resolution: [5](#0-4) 

If `actualTokenSymbol` is itself an alias (exists in SymbolAliasMap but not in TokenInfos), `GetTokenInfo` returns null instead of continuing resolution.

Similarly, `GetActualTokenSymbol` also performs single-level resolution: [6](#0-5) 

### Impact Explanation
This vulnerability causes complete operational denial of service for tokens accessed via chained aliases:

1. **Balance Queries Fail**: `GetBalance` uses `GetActualTokenSymbol`, which resolves only one level, returning the intermediate alias instead of the actual token symbol. Balance lookups return 0 even when users hold the underlying token. [7](#0-6) 

2. **All Token Operations Fail**: Transfer, Issue, Burn, Lock, and other operations call `AssertValidToken`, which uses `GetTokenInfo`. With a chained alias, this returns null and causes assertion failure: [8](#0-7) [9](#0-8) 

3. **NFT Collections Affected**: Since aliases are designed for NFT items, this breaks critical NFT functionality including transfers, marketplace operations, and ownership verification.

4. **Cross-Chain Impact**: The vulnerability can be exploited via `CrossChainCreateToken`, affecting tokens synced from side chains. [10](#0-9) 

**Severity: HIGH** - Complete DoS of token operations affecting NFT collections and their holders, with no recovery mechanism except contract upgrade.

### Likelihood Explanation
**Likelihood: HIGH**

**Attacker Capabilities Required:**
- Ability to create NFT collections (standard user permission)
- No privileged roles needed
- No special governance approvals required

**Attack Complexity:**
1. Create legitimate NFT collection "REAL-0" with item "REAL-1"
2. Create NFT collection "ALIAS1-0" with ExternalInfo: `{"REAL-1":"ALIAS1"}` - creates first alias
3. Create NFT collection "ALIAS2-0" with ExternalInfo: `{"ALIAS1":"ALIAS2"}` - creates chained alias pointing to another alias
4. The chain is now established: ALIAS2 → ALIAS1 → REAL-1

**Feasibility:**
- All steps use standard public methods (Create)
- No timing constraints or race conditions
- Economic cost is minimal (just NFT collection creation fees)
- Attack is deterministic and guaranteed to succeed

**Detection Difficulty:**
- Malicious ExternalInfo looks like legitimate alias configuration
- No events or warnings indicate alias chain creation
- Users only discover the issue when operations fail unexpectedly

### Recommendation
**Immediate Fix - Add Recursive Resolution:**

Modify `SetTokenAlias` to validate that the target symbol is an actual token, not another alias:

```csharp
private void SetTokenAlias(TokenInfo tokenInfo)
{
    var (symbol, alias) = ExtractAliasSetting(tokenInfo);
    
    // NEW: Validate target is a real token, not another alias
    var targetTokenInfo = GetTokenInfo(symbol);
    Assert(targetTokenInfo != null && targetTokenInfo.Symbol == symbol, 
        $"Alias target {symbol} must be a real token, not another alias.");
    
    State.SymbolAliasMap[alias] = symbol;
    CheckTokenAlias(alias, tokenInfo.Symbol);
    
    Context.Fire(new SymbolAliasAdded
    {
        Symbol = symbol,
        Alias = alias
    });
}
```

**Alternative Fix - Recursive Resolution:**

Modify `GetTokenInfo` and `GetActualTokenSymbol` to recursively resolve alias chains with cycle detection:

```csharp
private TokenInfo GetTokenInfo(string symbolOrAlias)
{
    var visited = new HashSet<string>();
    var current = symbolOrAlias;
    
    while (current != null)
    {
        if (visited.Contains(current))
            throw new AssertionException("Circular alias reference detected.");
        visited.Add(current);
        
        var tokenInfo = State.TokenInfos[current];
        if (tokenInfo != null) return tokenInfo;
        
        current = State.SymbolAliasMap[current];
    }
    
    return null;
}
```

**Test Cases Required:**
1. Attempt to create alias pointing to another alias - should fail
2. Attempt to create circular alias (A→B→A) - should fail
3. Verify existing single-level aliases continue working
4. Verify multi-level resolution if recursive fix is implemented

### Proof of Concept

**Initial State:**
- Chain is MainChain (ChainId = "AELF")
- Attacker has permissions to create NFT collections

**Attack Sequence:**

**Step 1:** Create legitimate NFT collection and item
```
Create({
    Symbol: "REAL-0",
    TokenName: "Real Collection",
    TotalSupply: 1,
    ...
})

// Item REAL-1 exists or will be created
```

**Step 2:** Create first alias via ExternalInfo
```
Create({
    Symbol: "ALIAS1-0",
    TokenName: "Alias1 Collection",
    TotalSupply: 1,
    ExternalInfo: {
        "__alias_info__": "{\"REAL-1\":\"ALIAS1\"}"
    },
    ...
})

// Result: State.SymbolAliasMap["ALIAS1"] = "REAL-1"
```

**Step 3:** Create chained alias pointing to first alias
```
Create({
    Symbol: "ALIAS2-0",
    TokenName: "Alias2 Collection",
    TotalSupply: 1,
    ExternalInfo: {
        "__alias_info__": "{\"ALIAS1\":\"ALIAS2\"}"
    },
    ...
})

// Result: State.SymbolAliasMap["ALIAS2"] = "ALIAS1"
// Chain created: ALIAS2 → ALIAS1 → REAL-1
```

**Expected Result:**
`GetTokenInfo("ALIAS2")` should resolve to the TokenInfo of "REAL-1"

**Actual Result:**
- `GetTokenInfo("ALIAS2")` attempts resolution:
  - Checks `State.TokenInfos["ALIAS2"]` → returns null
  - Checks `State.SymbolAliasMap["ALIAS2"]` → returns "ALIAS1"
  - Checks `State.TokenInfos["ALIAS1"]` → returns null (ALIAS1 is also an alias!)
  - Returns null
- All operations using "ALIAS2" fail with "Token is not found"
- Balance queries for "ALIAS2" return incorrect results
- Transfers, burns, locks, and other operations are completely blocked

**Success Condition:**
The attack succeeds when `GetTokenInfo("ALIAS2")` returns null despite "REAL-1" being a valid token at the end of the chain, demonstrating complete DoS of all operations involving the aliased token.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L81-85)
```csharp
        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-183)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L505-505)
```csharp
        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L811-824)
```csharp
    private KeyValuePair<string, string> ExtractAliasSetting(TokenInfo tokenInfo)
    {
        if (!tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TokenAliasExternalInfoKey))
        {
            return new KeyValuePair<string, string>(string.Empty, string.Empty);
        }

        var tokenAliasSetting = tokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey];
        tokenAliasSetting = tokenAliasSetting.Trim('{', '}');
        var parts = tokenAliasSetting.Split(':');
        var key = parts[0].Trim().Trim('\"');
        var value = parts[1].Trim().Trim('\"');
        return new KeyValuePair<string, string>(key, value);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L826-838)
```csharp
    private void SetTokenAlias(TokenInfo tokenInfo)
    {
        var (symbol, alias) = ExtractAliasSetting(tokenInfo);
        State.SymbolAliasMap[alias] = symbol;

        CheckTokenAlias(alias, tokenInfo.Symbol);

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = symbol,
            Alias = alias
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L286-294)
```csharp
    private string GetActualTokenSymbol(string aliasOrSymbol)
    {
        if (State.TokenInfos[aliasOrSymbol] == null)
        {
            return State.SymbolAliasMap[aliasOrSymbol] ?? aliasOrSymbol;
        }

        return aliasOrSymbol;
    }
```
