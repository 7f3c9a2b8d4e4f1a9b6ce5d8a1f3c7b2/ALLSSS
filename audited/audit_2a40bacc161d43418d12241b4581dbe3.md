### Title
Hash.Empty Bypasses InValue Null Check Leading to Predictable Consensus Values

### Summary
The null check assertion for `triggerInformation.InValue` at line 65 can be bypassed by `Hash.Empty`, which is a valid Hash object (not null) returned by default when InValue is not cached. This allows miners to produce blocks with deterministic, predictable OutValue and Signature values, undermining the randomness guarantees of the AEDPoS consensus mechanism.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The assertion only validates `triggerInformation.InValue != null` but fails to check for `Hash.Empty`. However, `Hash.Empty` is defined as a static readonly Hash object with 32 zero bytes, not null: [2](#0-1) 

**Why Hash.Empty is Used**: When `InValueCache.GetInValue()` cannot find a cached InValue for the requested round, it returns `Hash.Empty` as the default: [3](#0-2) 

**Execution Path**:
1. InValue from cache (potentially `Hash.Empty`) passes the null check
2. OutValue is computed deterministically: [4](#0-3) 
3. These values are applied to the round state: [5](#0-4) 
4. Signature determines next round order: [6](#0-5) 

**Missing Validation**: The `UpdateValueValidationProvider` only checks that OutValue and Signature are non-null and non-empty, but does NOT verify they were computed from a proper random InValue: [7](#0-6) 

Note that while `Hash.Empty` is explicitly permitted for `PreviousInValue` [8](#0-7) , there is no equivalent check rejecting it for the current InValue.

### Impact Explanation

**Consensus Integrity Compromise**: The AEDPoS consensus relies on InValue being a cryptographically secure random value generated by signing a message with the miner's private key: [9](#0-8) 

When `Hash.Empty` is used instead:
- OutValue becomes `Hash(Hash.Empty)` - a deterministic, known value
- Signature computation becomes predictable
- Miner's position in next round (`supposedOrderOfNextRound`) is predetermined
- The secret sharing mechanism for random number generation is compromised

**Affected Parties**: 
- All consensus participants (reduced security of consensus randomness)
- Block production fairness (predictable miner ordering)
- Dependent systems relying on consensus-generated random numbers

**Severity Justification**: While this doesn't directly enable fund theft, it violates a critical invariant: "Correct round transitions and miner schedule integrity." Predictable consensus values can enable strategic manipulation of block production order and timing.

### Likelihood Explanation

**Reachable Entry Point**: The vulnerable function is called during normal block production via the ACS4 interface: [10](#0-9) 

**Attack Scenarios**:
1. **Intentional Manipulation**: A malicious miner deliberately avoids calling `AddSharingInformationAsync` to prevent InValue caching
2. **Cache Expiration**: The InValue cache only retains 10 most recent values, so requesting old rounds returns `Hash.Empty`
3. **Node Restart**: After restart without proper state recovery, cache may be empty
4. **Timing Issues**: Race conditions during round transitions could result in missing cache entries

**Attacker Capabilities Required**: 
- Must be an authorized miner (but this is normal for consensus operations)
- Can control their own node's InValue caching behavior
- No special permissions beyond being a consensus participant needed

**Detection Difficulty**: Since the current InValue is never stored in contract state (only OutValue/Signature are persisted), there's no way to audit whether miners used proper random InValues or `Hash.Empty`.

### Recommendation

**Code-Level Mitigation**: Add an explicit check to reject `Hash.Empty` as the current InValue:

```csharp
Assert(triggerInformation.InValue != null, "In value should not be null.");
Assert(triggerInformation.InValue != Hash.Empty, "In value cannot be Hash.Empty.");
```

Insert this check at: [1](#0-0) 

**Additional Validation**: In `UpdateValueValidationProvider`, add validation that OutValue appears to be computed from a non-trivial InValue (though the InValue itself isn't available at validation time, statistical checks on OutValue distribution could detect systematic use of `Hash.Empty`).

**Invariant Check**: Ensure InValue cache always contains valid entries before block production by validating in `GetTriggerInformationForBlockHeaderExtraData`: [11](#0-10) 

**Test Cases**: 
- Verify rejection when InValue is `Hash.Empty`
- Test cache miss scenarios return appropriate errors rather than `Hash.Empty`
- Validate that InValue is generated and cached for all rounds before block production

### Proof of Concept

**Initial State**:
- Node is configured as an authorized miner
- Consensus round N is active

**Exploitation Steps**:
1. Miner's node skips calling `SecretSharingService.AddSharingInformationAsync` for round N+1
2. When producing a block for round N+1, `GetTriggerInformationForBlockHeaderExtraData` calls `GetInValue(roundId)`
3. Cache miss occurs, returning `Hash.Empty`
4. `GetConsensusExtraDataToPublishOutValue` receives `triggerInformation.InValue = Hash.Empty`
5. Assertion at line 65 checks `!= null` - **passes** (Hash.Empty is not null)
6. OutValue computed as `Hash(Hash.Empty)` - deterministic value
7. Signature computed from deterministic OutValue
8. Block is produced with predictable consensus values
9. Validation passes because `UpdateValueValidationProvider` only checks non-null/non-empty

**Expected vs Actual**:
- **Expected**: InValue should be cryptographically random, OutValue/Signature unpredictable
- **Actual**: InValue is `Hash.Empty`, OutValue/Signature are deterministic, miner knows their next round position in advance

**Success Condition**: Miner successfully produces a valid block with `Hash.Empty`-derived consensus values, passing all validations, while having predictable next-round ordering.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L65-65)
```csharp
        Assert(triggerInformation.InValue != null, "In value should not be null.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** src/AElf.Types/Types/Hash.cs (L13-14)
```csharp
        public static readonly Hash Empty = LoadFromByteArray(Enumerable.Range(0, AElfConstants.HashByteArrayLength)
            .Select(x => byte.MinValue).ToArray());
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L31-32)
```csharp
        _inValues.TryGetValue(roundId, out var inValue);
        return inValue ?? Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L12-13)
```csharp
        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-58)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L55-56)
```csharp
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
```
