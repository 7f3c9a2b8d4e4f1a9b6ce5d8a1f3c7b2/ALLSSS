### Title
NFT Protocol Creator Loses Minting Control When MultiToken Issuer is Transferred

### Summary
The NFT contract's minting authorization relies on the MultiToken contract's issuer field, which can be changed independently of the NFT protocol creator. When the MultiToken issuer is transferred via `ModifyTokenIssuerAndOwner`, the new issuer gains unrestricted minting privileges that the NFT protocol creator cannot revoke, allowing unauthorized minting outside the creator's control.

### Finding Description

The vulnerability exists in the interaction between the NFT contract's minting authorization logic and the MultiToken contract's issuer modification mechanism.

**Root Cause:**

When an NFT protocol is created, both the NFT protocol creator and MultiToken issuer are initially the same address. [1](#0-0)  However, the MultiToken contract allows changing the token issuer through `ModifyTokenIssuerAndOwner` when the token owner is null. [2](#0-1) 

Since NFT tokens are created without an owner field set [3](#0-2) , they remain eligible for issuer transfer. The CreateInput message structure includes an optional owner field [4](#0-3)  which is not populated by the NFT contract.

**Why Protections Fail:**

The critical flaw is in the `PerformMint` function's authorization check. It retrieves token info from the MultiToken contract [5](#0-4)  and uses a helper function `GetMinterList(TokenInfo)` that dynamically adds the current MultiToken issuer to the effective minter list. [6](#0-5) 

This creates a critical discrepancy:
- The stored minter list (managed by the NFT protocol creator via `AddMinters`/`RemoveMinters`) [7](#0-6) 
- The effective minter list (stored list + current MultiToken issuer)

Only the NFT protocol creator can modify the stored minter list [8](#0-7) , but they have no control over the MultiToken issuer field, which is managed entirely by the MultiToken contract.

Additionally, the public view function `GetMinterList()` only returns the stored minter list [9](#0-8) , creating misleading information about who can actually mint.

### Impact Explanation

**Direct Impact:**
- **Unauthorized Minting**: A new MultiToken issuer (after transfer) can mint unlimited NFTs up to the total supply, bypassing the NFT protocol creator's minter list controls
- **Loss of Access Control**: The NFT protocol creator loses the ability to enforce who can mint tokens for their protocol
- **Supply Inflation**: Unauthorized minter can increase circulating supply without creator approval, potentially devaluing existing NFTs
- **Trust Model Violation**: Users and dApps relying on the minter list for authorization checks will have incorrect information

**Affected Parties:**
- NFT protocol creators who lose control over their protocols
- NFT holders whose assets may be devalued by unauthorized minting
- Marketplaces and dApps that query the minter list for authorization decisions

**Severity Justification:**
This is critical because it breaks the fundamental authorization invariant that only explicitly approved addresses can mint NFTs. The creator's ability to control their protocol is completely undermined by an external contract's state change.

### Likelihood Explanation

**Attacker Capabilities:**
- Only the current MultiToken issuer can call `ModifyTokenIssuerAndOwner` [10](#0-9) 
- This requires either: (1) the original creator intentionally transferring issuer rights, (2) compromise of the issuer's private key, or (3) social engineering

**Attack Complexity:**
Low - Single transaction to `ModifyTokenIssuerAndOwner` changes the issuer, immediately granting minting privileges to the new issuer.

**Feasibility Conditions:**
- The token must not have an owner set (satisfied for all NFT contract created tokens)
- The `TokenIssuerAndOwnerModificationEnabled` flag must not be disabled [11](#0-10) 
- The original issuer must be able to sign the transfer transaction

**Probability Reasoning:**
Medium-High likelihood because:
1. Issuer compromise is a realistic threat vector in blockchain systems
2. Protocol creators may intentionally transfer issuer rights without understanding the NFT minting implications
3. In multi-signature or organizational scenarios, issuer transfer may be approved without considering downstream effects on NFT contracts
4. No warning or protection mechanism exists in the NFT contract to prevent or detect this state divergence

### Recommendation

**Immediate Fix:**
1. Modify the NFT token creation to set the `owner` field to the protocol creator address in `CreateInput`, preventing future issuer transfers:
   ```
   tokenCreateInput.Owner = creator;
   ```

2. Remove the automatic issuer inclusion logic from `GetMinterList(TokenInfo)` helper function. Only use the stored minter list for authorization.

3. Add a validation check in `PerformMint` to assert that the MultiToken issuer matches the NFT protocol creator:
   ```
   Assert(tokenInfo.Issuer == protocolInfo.Creator, "Token issuer mismatch with protocol creator.");
   ```

**Additional Protections:**
1. Add an event emission when token info is retrieved, logging the issuer for monitoring purposes
2. Implement a circuit breaker that pauses minting if issuer divergence is detected
3. Update the public `GetMinterList()` view function to include the current issuer for transparency
4. Add explicit documentation warning about the relationship between MultiToken issuer and NFT minting permissions

**Test Cases:**
1. Verify NFT tokens are created with owner field set
2. Attempt to call `ModifyTokenIssuerAndOwner` on an NFT token and confirm it fails
3. Test that minting authorization only checks the stored minter list
4. Verify issuer mismatch detection triggers appropriate errors

### Proof of Concept

**Initial State:**
- Alice creates NFT protocol "TESTNFT" 
- Protocol creator = Alice
- MultiToken issuer = Alice  
- Stored minter list = [Alice]
- Token owner = null (not set during creation)

**Attack Sequence:**

1. **Issuer Transfer** (executed by Alice or attacker with Alice's compromised key):
   ```
   MultiToken.ModifyTokenIssuerAndOwner({
     Symbol: "TESTNFT",
     Issuer: Bob_Address,
     Owner: Bob_Address
   })
   ```
   Result: MultiToken issuer changes from Alice to Bob

2. **Bob Attempts to Mint** (executed by Bob):
   ```
   NFTContract.Mint({
     Symbol: "TESTNFT",
     TokenId: 1,
     Owner: Bob_Address
   })
   ```
   
3. **Authorization Check in PerformMint**:
   - Retrieves tokenInfo from MultiToken (issuer = Bob)
   - Calls GetMinterList(tokenInfo)
   - GetMinterList adds Bob to effective list (because Bob is issuer)
   - Check passes: Bob is in effective minter list
   - **Mint succeeds**

4. **Alice Attempts to Remove Bob**:
   ```
   NFTContract.RemoveMinters({
     Symbol: "TESTNFT",
     MinterList: [Bob_Address]
   })
   ```
   Result: Bob is removed from stored minter list, but can still mint because GetMinterList re-adds him

**Expected vs Actual Result:**
- **Expected**: Only addresses in the stored minter list controlled by the protocol creator can mint
- **Actual**: The MultiToken issuer can always mint, regardless of the stored minter list, and the protocol creator cannot prevent this

**Success Condition:**
Bob successfully mints NFT with TokenId=1 despite not being in the stored minter list and without Alice's approval.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-38)
```csharp
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L642-659)
```csharp
    public override Empty ModifyTokenIssuerAndOwner(ModifyTokenIssuerAndOwnerInput input)
    {
        Assert(!State.TokenIssuerAndOwnerModificationDisabled.Value, "Set token issuer and owner disabled.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");

        var tokenInfo = GetTokenInfo(input.Symbol);

        Assert(tokenInfo != null, "Token is not found.");
        Assert(tokenInfo.Issuer == Context.Sender, "Only token issuer can set token issuer and owner.");
        Assert(tokenInfo.Owner == null, "Can only set token which does not have owner.");
        
        tokenInfo.Issuer = input.Issuer;
        tokenInfo.Owner = input.Owner;

        return new Empty();
    }
```

**File:** protobuf/token_contract.proto (L279-300)
```text
message CreateInput {
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The precision of the token
    int32 decimals = 4;
    // The address that has permission to issue the token.
    aelf.Address issuer = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // A whitelist address list used to lock tokens.
    repeated aelf.Address lock_white_list = 7;
    // The chain id of the token.
    int32 issue_chain_id = 8;
    // The external information of the token.
    ExternalInfo external_info = 9;
    // The address that owns the token.
    aelf.Address owner = 10;
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-373)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }

    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L385-399)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L77-80)
```csharp
    public override MinterList GetMinterList(StringValue input)
    {
        return State.MinterListMap[input.Value];
    }
```
