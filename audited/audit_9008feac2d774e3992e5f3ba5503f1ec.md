### Title
InValue/OutValue Replay Attack Enabling Mining Order Manipulation

### Summary
The AEDPoS consensus contract lacks validation to prevent miners from reusing previous InValue/OutValue pairs across different rounds. This allows a malicious miner to strategically replay old InValues to manipulate their mining order in future rounds, breaking the unpredictability assumption of the consensus mechanism and potentially compromising the secret sharing scheme.

### Finding Description
The vulnerability exists in the `ProcessUpdateValue` function and its validation flow. When a miner submits an `UpdateValueInput`, the only validation performed on the PreviousInValue is in `UpdateValueValidationProvider`: [1](#0-0) 

This validation only checks that `Hash(previousInValue) == previousOutValue` from the previous round, but does NOT verify:
1. Whether the current OutValue being committed has been used before by this miner
2. Whether the InValue (which will be revealed in the next round) has been previously used

In `ProcessUpdateValue`, the OutValue and PreviousInValue are accepted without uniqueness checks: [2](#0-1) 

The contract state only stores rounds by round number without tracking historical InValue/OutValue usage: [3](#0-2) 

The critical impact comes from how the signature (calculated from PreviousInValue) determines mining order for the next round: [4](#0-3) 

The signature is calculated using the PreviousInValue: [5](#0-4) 

### Impact Explanation
**Consensus Integrity Compromise:**
- A miner can pre-compute signatures for multiple historical InValue options and select the one producing the most favorable mining position
- Mining order directly affects block production frequency, giving unfair advantage in earning block rewards
- Breaks the fundamental assumption that InValues are fresh and unpredictable

**Predictability:** 
- When a miner reuses OutValue_A from round X in round Y, they must reveal InValue_A in round Y+1
- Other miners already know InValue_A from round X+1, eliminating unpredictability
- This known InValue can be used to predict the miner's future signature and position

**Secret Sharing Compromise:**
If secret sharing is enabled, reusing InValue means:
- Encrypted pieces are derived from a known value
- Other miners who saved previous decrypted pieces can predict future shares
- Undermines the security of the secret sharing mechanism [6](#0-5) 

**Affected Parties:**
- All miners: unfair mining schedule distribution
- Token holders: rewards misallocation favoring the attacker
- Overall network: consensus fairness and randomness degradation

### Likelihood Explanation
**Attacker Capabilities:** Any miner in the current miner list can execute this attack. Miners naturally possess all their historical InValues since they generated them locally.

**Attack Complexity:** Low
1. Miner maintains a cache of their historical InValue/OutValue pairs
2. When producing a block, compute potential signatures for each old InValue option
3. Select the InValue giving the most favorable mining order
4. Submit UpdateValue transaction with the reused OutValue

**Feasibility Conditions:**
- Attacker is a valid miner (checked by permission validation)
- Has history of at least one previous round (highly likely in production)
- No computational barriers: signature calculation is simple modulo arithmetic [7](#0-6) 

**Economic Rationality:** 
- Direct benefit: Better mining positions = more blocks produced = more transaction fees and block rewards
- Minimal cost: No additional transaction fees beyond normal consensus participation
- Detection difficulty: Without historical OutValue tracking, replay is hard to detect

**Probability:** High - The attack requires no special privileges beyond being a miner, has clear economic incentives, and faces no technical barriers.

### Recommendation
**Immediate Fix:**
Add OutValue uniqueness validation in `UpdateValueValidationProvider` or `ProcessUpdateValue`:

1. Store a mapping of used OutValues per miner: `MappedState<string, MappedState<Hash, bool>> UsedOutValues`
2. In validation, check: `Assert(!State.UsedOutValues[pubkey][outValue], "OutValue already used")`
3. In ProcessUpdateValue, mark OutValue as used: `State.UsedOutValues[pubkey][outValue] = true`

**Alternative Approach:**
Implement a sliding window check that validates OutValue hasn't been used in the last N rounds (where N = maximum reasonable mining frequency).

**Additional Hardening:**
1. Add monitoring/logging to detect repeated OutValues across rounds
2. Consider incorporating round number into InValue generation to enforce round-specific values
3. Update InValue generation in `SecretSharingService` to include round-specific entropy [8](#0-7) 

**Test Cases:**
1. Test that submitting same OutValue twice for the same miner is rejected
2. Test that different miners can use same OutValue (should be allowed)
3. Test that after sufficient rounds, old OutValues can be garbage collected
4. Test attack scenario: attempt to replay InValue and verify rejection

### Proof of Concept
**Initial State:**
- Attacker is a valid miner in the consensus
- Network has completed at least 3 rounds
- Attacker has record of InValue_A from Round 1 where they got mining position 5
- Attacker has record of InValue_B from Round 2 where they got mining position 2

**Exploitation Steps:**
1. **Round N:** Attacker computes signatures for both InValue_A and InValue_B
   - signature_A = XOR(InValue_A, other_miners_signatures_from_round_N-1)
   - signature_B = XOR(InValue_B, other_miners_signatures_from_round_N-1)
   - position_A = GetAbsModulus(signature_A.ToInt64(), minersCount) + 1 = 5
   - position_B = GetAbsModulus(signature_B.ToInt64(), minersCount) + 1 = 1

2. **Round N:** Attacker chooses to reuse InValue_B (gives position 1 in next round)
   - Submit UpdateValue with OutValue_B = Hash(InValue_B)
   - Transaction succeeds, validation only checks Hash(PreviousInValue) == previous round's OutValue âœ“

3. **Round N+1:** Attacker must reveal InValue_B as PreviousInValue
   - Other miners recognize InValue_B was already revealed in Round 3
   - Attacker gets mining position 1 (earliest slot) in Round N+1

**Expected vs Actual:**
- **Expected:** Each round should use a fresh, unpredictable InValue
- **Actual:** Miner successfully reuses old InValue to gain favorable mining position

**Success Condition:** The attacker's UpdateValue transaction in Round N is accepted despite using a previously-used OutValue, and they obtain the predicted favorable mining position in Round N+1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-265)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L26-26)
```csharp
    public MappedState<long, Round> Rounds { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```
