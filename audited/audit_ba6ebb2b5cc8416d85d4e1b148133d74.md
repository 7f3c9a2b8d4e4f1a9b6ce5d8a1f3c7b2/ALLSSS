### Title
Permanent DoS of TokenHolder Method Fee Management Due to Unhandled Parliament Initialization Failure

### Summary
The `RequiredMethodFeeControllerSet()` function makes an unprotected cross-contract call to Parliament's `GetDefaultOrganizationAddress()` which will revert if Parliament is not initialized. If this call fails, `State.MethodFeeController.Value` is never set, causing permanent DoS of all method fee management functions (`SetMethodFee`, `ChangeMethodFeeController`, `GetMethodFeeController`) with no recovery mechanism.

### Finding Description

The vulnerability exists in the `RequiredMethodFeeControllerSet()` private method that initializes the method fee controller for the TokenHolder contract. [1](#0-0) 

The critical issue occurs at line 59 where a cross-contract call is made to `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())`. This call will fail if the Parliament contract is not initialized, as shown in the Parliament contract implementation: [2](#0-1) 

The Parliament method asserts `State.Initialized.Value` is true, and will revert with "Not initialized." if false.

**Execution path of the vulnerability:**

1. Any call to `SetMethodFee()`, `ChangeMethodFeeController()`, or `GetMethodFeeController()` invokes `RequiredMethodFeeControllerSet()` [3](#0-2) [4](#0-3) [5](#0-4) 

2. If `State.MethodFeeController.Value` is null, the function attempts to initialize it by calling Parliament

3. If Parliament's `GetDefaultOrganizationAddress()` reverts, the entire transaction fails and `State.MethodFeeController.Value` remains null

4. Every subsequent call repeats this pattern, permanently blocking all three methods

**Why existing protections fail:**
- No try-catch or error handling around the cross-contract call
- No fallback mechanism if Parliament is unavailable or uninitialized
- No admin function to manually set `MethodFeeController`
- TokenHolder has no initialization method to pre-set the controller [6](#0-5) 

### Impact Explanation

**Operational Impact - Complete DoS of Method Fee Management:**

1. **SetMethodFee() permanently blocked** - Cannot configure transaction fees for any TokenHolder method, preventing fee adjustments for operations like `CreateScheme`, `RegisterForProfits`, `Withdraw`, etc.

2. **ChangeMethodFeeController() permanently blocked** - Cannot transfer fee management authority to a different organization, making the contract ungovernable regarding fee policies

3. **GetMethodFeeController() permanently blocked** - Cannot even query the current controller, breaking integration with other contracts and tooling that depend on ACS1 standard

**Affected parties:**
- Contract administrators lose ability to manage method fees
- Users cannot determine fee costs through standard ACS1 interface
- Protocol governance cannot adjust fees in response to token price changes or operational needs

**Severity justification - HIGH:**
- Complete loss of critical governance functionality (method fee management)
- Permanent DoS with no recovery path except contract upgrade
- Affects core ACS1 standard implementation that other contracts may depend on
- Single point of failure with no defensive programming

### Likelihood Explanation

**Preconditions for vulnerability:**
1. Parliament contract must not be initialized (`State.Initialized.Value == false` in Parliament)
2. TokenHolder contract attempts to initialize its MethodFeeController for the first time

**Feasibility analysis:**

Under normal deployment flow, Parliament is always initialized via `ParliamentContractInitializationProvider`: [7](#0-6) 

However, the vulnerability becomes exploitable in these scenarios:

1. **Contract upgrade without re-initialization** - If Parliament is upgraded and new deployment doesn't properly initialize state
2. **Deployment failure/rollback** - If Parliament deployment succeeds but initialization transaction fails or is rolled back
3. **State corruption** - Though unlikely, any state corruption affecting Parliament's initialization flag

**Attack complexity:** None required - this is a failure scenario, not an active attack. No attacker capabilities needed.

**Probability assessment:** 
- LOW likelihood under normal production deployment
- However, the PERMANENT nature of the DoS combined with ZERO recovery mechanisms elevates this to HIGH severity
- This is a critical single point of failure that violates defensive programming principles

**No detection/prevention mechanisms exist** - No circuit breakers, no fallback paths, no manual overrides.

### Recommendation

**Primary mitigation - Add error handling and fallback:**

Modify `RequiredMethodFeeControllerSet()` to handle Parliament initialization failure gracefully:

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    Address defaultOrgAddress = null;
    try
    {
        defaultOrgAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    }
    catch
    {
        // Fallback: If Parliament is not initialized, use a zero address or Genesis contract
        // This allows basic functionality while signaling misconfiguration
        defaultOrgAddress = Context.GetZeroSmartContractAddress();
    }

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = defaultOrgAddress,
        ContractAddress = State.ParliamentContract.Value
    };

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Secondary mitigation - Add emergency admin function:**

Add a method callable only by Genesis contract to manually set MethodFeeController:

```csharp
public override Empty SetMethodFeeControllerByAdmin(AuthorityInfo input)
{
    Assert(Context.Sender == Context.GetZeroSmartContractAddress(), 
        "Only Genesis contract can set controller.");
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Invariant checks to add:**
- Assert Parliament contract is initialized before relying on it
- Log warning events when fallback paths are used
- Add health check view methods to detect misconfiguration

**Test cases to prevent regression:**
- Test TokenHolder methods when Parliament is not initialized
- Test recovery using admin override function
- Test upgrade scenarios where Parliament state might be inconsistent

### Proof of Concept

**Required initial state:**
1. AElf chain with TokenHolder contract deployed
2. Parliament contract address registered but NOT initialized (State.Initialized.Value = false)

**Transaction sequence:**

1. **Attempt to get method fee controller:**
   - Call: `TokenHolderContract.GetMethodFeeController(Empty)`
   - Expected: Should return current controller or initialize with default
   - Actual: Transaction reverts with "Not initialized." from Parliament contract
   - State: `State.MethodFeeController.Value` remains null

2. **Attempt to set method fee:**
   - Call: `TokenHolderContract.SetMethodFee(MethodFees)` as any authorized user
   - Expected: Should set fee or initialize controller first
   - Actual: Transaction reverts with "Not initialized." from Parliament contract
   - State: No fees can be configured, `State.MethodFeeController.Value` remains null

3. **Attempt to change controller:**
   - Call: `TokenHolderContract.ChangeMethodFeeController(AuthorityInfo)` as authorized user
   - Expected: Should change controller or initialize first
   - Actual: Transaction reverts with "Not initialized." from Parliament contract
   - State: Controller cannot be changed, `State.MethodFeeController.Value` remains null

4. **Verify permanent DoS:**
   - Repeat any of the above calls
   - Result: Same failure occurs indefinitely
   - State: No recovery mechanism exists without contract upgrade

**Success condition:** All three method fee management functions are permanently blocked, demonstrating complete DoS of fee governance with no recovery path.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L40-44)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L250-254)
```csharp
    public override Address GetDefaultOrganizationAddress(Empty input)
    {
        Assert(State.Initialized.Value, "Not initialized.");
        return State.DefaultOrganizationAddress.Value;
    }
```

**File:** src/AElf.EconomicSystem/TokenHolderContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** src/AElf.GovernmentSystem/ParliamentContractInitializationProvider.cs (L24-39)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var initializationData = _parliamentContractInitializationDataProvider.GetContractInitializationData();
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(ParliamentContractContainer.ParliamentContractStub.Initialize),
                Params = new InitializeInput
                {
                    PrivilegedProposer = initializationData.PrivilegedProposer,
                    ProposerAuthorityRequired = initializationData.ProposerAuthorityRequired
                }.ToByteString()
            }
        };
    }
```
