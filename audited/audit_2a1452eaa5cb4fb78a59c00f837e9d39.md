### Title
VoteId Collision Enables Vote Overwriting and Permanent Token Lock DoS in Delegated Voting

### Summary
The VoteContract allows sponsors of delegated voting items (IsLockToken=false) to provide arbitrary VoteIds when calling Vote(), with no uniqueness check before overwriting the global VotingRecords mapping. An attacker can register their own delegated voting item, observe victims' VoteIds from public blockchain data, then overwrite those VotingRecords, causing permanent token lock DoS for victims who can no longer withdraw their locked funds.

### Finding Description

**Root Cause Location:**
The vulnerability exists at line 117 where VotingRecords are directly overwritten without any existence check: [1](#0-0) 

**VoteId Generation in Delegated Voting:**
For delegated voting (IsLockToken=false), the sponsor provides the VoteId explicitly with no validation: [2](#0-1) 

**Global VotingRecords Mapping:**
The VotingRecords mapping is indexed solely by VoteId, not scoped by VotingItemId, allowing cross-voting-item collisions. When a vote is recorded, it directly assigns to this global mapping: [3](#0-2) 

**VoteId Computation for Locked Voting:**
For non-delegated voting (IsLockToken=true), VoteIds are generated deterministically using OriginTransactionId, which is publicly observable: [4](#0-3) 

The GenerateId implementation uses OriginTransactionId which becomes public after transaction execution: [5](#0-4) 

**Why Protections Fail:**
1. Anyone can register a voting item and become its sponsor with no restrictions: [6](#0-5) 

2. The validation only checks that the caller is the sponsor of their own voting item, but doesn't prevent VoteId reuse across different voting items: [7](#0-6) 

3. When the victim tries to withdraw, the overwritten VotingRecord now references the attacker's VotingItemId, causing permission check failure: [8](#0-7) 

### Impact Explanation

**Permanent Token Lock DoS:**
When a victim's vote is overwritten, their VotingRecord.VotingItemId changes to the attacker's voting item. The victim's tokens remain locked in the TokenContract with the original VoteId as LockId: [9](#0-8) 

When attempting withdrawal, the victim cannot proceed because the Withdraw function reads the overwritten VotingRecord and performs a permission check against the attacker's voting item (IsLockToken=false, Sponsor=Attacker): [10](#0-9) 

Since the victim is not the sponsor of the attacker's voting item, the withdrawal fails and tokens remain permanently locked.

**Direct Token Unlock Not Possible:**
Victims cannot bypass VoteContract and unlock directly from TokenContract because the virtual address computation requires the original locker (VoteContract) as Context.Sender: [11](#0-10) 

**Additional Impacts:**
- Vote count inflation: Original vote's contribution to VotingResults remains while new vote's contribution is added
- Data corruption: Victim's VotedItemsMap references a VoteId that now points to a different voter
- Voting integrity compromise: Legitimate votes effectively stolen/deleted

**Affected Parties:**
Any user who votes on a voting item where IsLockToken=true, as their VoteIds are publicly computable and can be maliciously overwritten.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Register a voting item with IsLockToken=false (unrestricted, anyone can call Register)
2. Observe victim's vote transaction on the public blockchain
3. Compute victim's VoteId from public transaction data (OriginTransactionId + contract address + VotesAmount)
4. Call Vote on attacker's voting item with the computed VoteId

**Attack Complexity:**
Low - The attack requires only:
- One transaction to register a voting item
- Reading public blockchain data to compute VoteIds
- One transaction to overwrite the victim's vote

**Feasibility Conditions:**
- Attacker needs minimal funds for gas fees
- All victim vote data is publicly observable on-chain
- No special permissions or roles required
- VoteId computation is deterministic and reproducible

**Detection Constraints:**
- The overwrite appears as a normal vote transaction
- No on-chain mechanism to detect cross-voting-item VoteId collisions
- Victims only discover the issue when attempting to withdraw (potentially months/years later)

**Probability Assessment:**
High likelihood given:
- No access control on Register function
- Public observability of all VoteId components
- Low attack cost relative to potential victim loss
- No existing detection or prevention mechanisms

### Recommendation

**Immediate Fix:**
Add VoteId existence check before overwriting VotingRecords:

```csharp
// In Vote function, before line 117
Assert(State.VotingRecords[input.VoteId] == null, 
    "Vote ID already exists. Cannot overwrite existing vote.");

State.VotingRecords[input.VoteId] = votingRecord;
```

**Alternative Design:**
Scope VotingRecords by VotingItemId to prevent cross-voting-item collisions:

```csharp
// Change state structure to:
// State.VotingRecords[votingItemId][voteId] = votingRecord;
```

**Validation Enhancement:**
For delegated voting, validate that sponsor-provided VoteIds don't collide with auto-generated VoteIds from other voting items by adding a prefix or namespace based on VotingItemId.

**Test Cases:**
1. Test that attempting to vote with an existing VoteId fails
2. Test that VoteIds from different voting items cannot collide
3. Test withdrawal still works correctly after failed overwrite attempts
4. Regression test ensuring Election contract functionality unaffected

### Proof of Concept

**Initial State:**
- Victim registers/participates in VotingItemB with IsLockToken=true
- VotingItemB has VotesAmount = 1000 at snapshot

**Attack Sequence:**

1. **Victim votes on VotingItemB:**
   - Victim calls Vote(VotingItemB, Amount=100, Option="CandidateX")
   - VoteId_X = Hash(VictimTxId + VoteContractAddress + "1000")
   - VotingRecords[VoteId_X] = {VotingItemId: B, Voter: Victim, Amount: 100}
   - TokenContract locks 100 tokens with LockId=VoteId_X

2. **Attacker observes and computes VoteId:**
   - Attacker reads VictimTxId from blockchain (public)
   - Attacker reads VotesAmount=1000 from VotingResults (public)
   - Attacker computes VoteId_X = Hash(VictimTxId + VoteContractAddress + "1000")

3. **Attacker registers malicious voting item:**
   - Attacker calls Register({IsLockToken: false, ...})
   - Attacker becomes sponsor of VotingItemA

4. **Attacker overwrites victim's vote:**
   - Attacker calls Vote({VotingItemId: A, VoteId: VoteId_X, Voter: AttackerAddress, Amount: 50})
   - Line 117 executes: VotingRecords[VoteId_X] = {VotingItemId: A, Voter: AttackerAddress, Amount: 50}
   - Victim's original VotingRecord is overwritten

5. **Victim attempts withdrawal (fails):**
   - Victim calls Withdraw(VoteId_X)
   - Line 193: Reads VotingRecords[VoteId_X] = {VotingItemId: A, ...}
   - Line 195: Loads VotingItems[A] = {IsLockToken: false, Sponsor: Attacker}
   - Line 200: Assert(Attacker == Victim) â†’ **FAILS**
   - Victim's 100 tokens remain permanently locked

**Expected Result:** Victim can withdraw their vote and unlock tokens

**Actual Result:** Victim's withdrawal fails permanently, tokens locked forever

**Success Condition:** Transaction at step 4 succeeds, transaction at step 5 reverts with "No permission to withdraw votes of others."

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-54)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-117)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L122-130)
```csharp
        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-206)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-146)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-242)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```
