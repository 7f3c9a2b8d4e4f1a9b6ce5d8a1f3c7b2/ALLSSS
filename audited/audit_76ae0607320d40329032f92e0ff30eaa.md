### Title
NextTerm Transaction Lacks Validation of Miner List Against Election Contract Results

### Summary
The `NextTermInput.Create()` method blindly copies `RealTimeMinersInformation` from the provided `Round` object without validating that these miners match the top N candidates from the Election contract. During the NextTerm transaction validation and execution phases, no cross-check is performed to verify the miner list against `ElectionContract.GetVictories()` results. This allows a malicious extra block producer to unilaterally inject arbitrary miners for the next term, completely bypassing the election process and seizing permanent consensus control.

### Finding Description

The vulnerability exists in the term transition flow where miners for a new term are accepted without validation:

**Root Cause:** [1](#0-0) 

The `Create()` method simply copies `RealTimeMinersInformation` from the input `Round` without any validation that these miners are the legitimate election winners.

**Missing Validation in Pre-Execution:** [2](#0-1) 

For `NextTerm` behavior, only `RoundTerminateValidationProvider` is added, which validates: [3](#0-2) 

This only checks round/term number progression, NOT the miner list validity.

**No Validation During Execution:** [4](#0-3) 

The `ProcessNextTerm` method directly extracts miners from the input and stores them via `SetMinerList` without querying the Election contract to verify they match `GetVictories()` results.

**SetMinerList Insufficient Protection:** [5](#0-4) 

`SetMinerList` only prevents duplicate updates for the same term, but does not validate that the miners are the correct election winners.

**Legitimate Flow Not Enforced:**
While the honest path queries the Election contract: [6](#0-5) [7](#0-6) 

This query result is never validated against the actual transaction input during validation or execution.

### Impact Explanation

**Consensus Integrity Catastrophic Failure:**
- A malicious extra block producer can inject arbitrary miners (themselves, colluding parties, or non-existent entities) as the complete miner set for the next term
- These unauthorized miners gain full block production rights for an entire term (typically 7 days)
- The attacker can exclude all legitimate election winners, effectively performing a consensus takeover

**Complete Bypass of Democratic Election:**
- All voter stakes and election results become meaningless
- Token holders lose their governance rights over block producer selection
- The fundamental "Delegated" aspect of AEDPoS is violated

**Cascading Control:**
- Malicious miners controlling term N can inject themselves into term N+1
- This creates permanent consensus capture with no recovery mechanism
- All subsequent blocks, transactions, and state transitions are under attacker control

**Who is Affected:**
- All token holders who voted in elections
- Legitimate candidates who won elections but are excluded
- All users whose transactions depend on honest consensus
- The entire chain's security and liveness guarantees

### Likelihood Explanation

**Reachable Entry Point:** [8](#0-7) 

NextTerm transactions are generated by the extra block producer when term change conditions are met: [9](#0-8) 

**Attacker Capabilities:**
- Must be the current extra block producer (one miner per round, rotates)
- Must have ability to modify consensus transaction generation code or block proposal
- Can craft malicious `Round` object with arbitrary miners before calling `NextTermInput.Create()`

**Execution Practicality:**
1. Wait until becoming extra block producer when `NeedToChangeTerm` returns true
2. Instead of calling honest `GenerateFirstRoundOfNextTerm`, craft a `Round` with chosen miners
3. Call `NextTermInput.Create()` with malicious Round
4. Generate and broadcast NextTerm block
5. Validation passes (only checks round/term numbers)
6. Execution accepts arbitrary miner list

**Attack Complexity: LOW**
- Single transaction during a scheduled event (term change every ~7 days)
- No need for complex state manipulation or race conditions
- No economic cost beyond normal block production

**Detection Difficulty: HIGH**
- Appears as legitimate NextTerm transaction
- No on-chain validation failure
- Off-chain observers would need to independently query Election contract and compare

### Recommendation

**Immediate Fix - Add Miner List Validation:**

In `AEDPoSContract_Validation.cs`, add a new validation provider for NextTerm:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new NextTermMinerListValidationProvider()); // NEW
    break;
```

**Create NextTermMinerListValidationProvider:**
```csharp
public class NextTermMinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        
        // Query Election contract for legitimate winners
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = new HashSet<string>(
            victories.Value.Select(v => v.ToHex())
        );
        
        // Compare against provided miner list
        var providedMiners = new HashSet<string>(
            extraData.Round.RealTimeMinersInformation.Keys
        );
        
        if (!expectedMiners.SetEquals(providedMiners))
        {
            return new ValidationResult 
            { 
                Message = $"NextTerm miner list does not match Election contract victories. " +
                         $"Expected: {string.Join(",", expectedMiners.OrderBy(x => x))}. " +
                         $"Provided: {string.Join(",", providedMiners.OrderBy(x => x))}"
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

**Additional Defense in ProcessNextTerm:**
Add explicit verification before `SetMinerList`:
```csharp
// In ProcessNextTerm, before line 188:
if (State.IsMainChain.Value)
{
    var victories = State.ElectionContract.GetVictories.Call(new Empty());
    var expectedMiners = victories.Value.Select(v => v.ToHex()).OrderBy(x => x).ToList();
    var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(x => x).ToList();
    
    Assert(expectedMiners.Count == actualMiners.Count && 
           expectedMiners.SequenceEqual(actualMiners),
           "NextTerm miner list does not match Election contract results");
}
```

**Test Cases:**
1. Test NextTerm transaction with correct miner list from GetVictories - should succeed
2. Test NextTerm transaction with one miner replaced - should fail validation
3. Test NextTerm transaction with completely different miners - should fail validation
4. Test NextTerm transaction with correct miners but different order - should succeed
5. Test side chain NextTerm (no Election contract) - should succeed without validation

### Proof of Concept

**Initial State:**
- Current term N with miners [A, B, C, D, E]
- Election results show top 5 candidates: [F, G, H, I, J] with highest votes
- Attacker is miner A, currently the extra block producer
- Term change condition met (`NeedToChangeTerm` returns true)

**Attack Steps:**

1. **Attacker intercepts NextTerm generation:**
   - Instead of calling honest `GenerateFirstRoundOfNextTerm()` which queries Election contract
   - Attacker crafts malicious `Round` object with chosen miners [A, K, L, M, N] where K,L,M,N are controlled by attacker

2. **Create malicious NextTermInput:**
   ```
   var maliciousRound = CreateRoundWithMiners([A, K, L, M, N]);
   var nextTermInput = NextTermInput.Create(maliciousRound, randomNumber);
   ```

3. **Broadcast NextTerm block:**
   - Block passes `ValidateConsensusBeforeExecution` (only validates round/term numbers)
   - Block passes `PreCheck` (attacker A is in current miner list)

4. **Execution accepts arbitrary miners:**
   - `ProcessNextTerm` extracts miners [A, K, L, M, N] from input
   - `SetMinerList` stores them for term N+1
   - No validation against Election contract occurs

**Expected Result:**
- NextTerm transaction should fail validation with error: "Miner list does not match Election contract victories"

**Actual Result:**
- NextTerm transaction succeeds
- Term N+1 begins with unauthorized miners [A, K, L, M, N]
- Legitimate election winners [F, G, H, I, J] are excluded
- Attacker controls consensus for entire next term

**Success Condition for Attack:**
Query `GetCurrentMinerList()` after term change shows [A, K, L, M, N] instead of [F, G, H, I, J], proving consensus capture.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
