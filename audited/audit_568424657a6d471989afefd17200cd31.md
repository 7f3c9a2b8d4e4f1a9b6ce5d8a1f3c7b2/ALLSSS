### Title
Unhandled KeyNotFoundException in RecoverFromUpdateValue During Miner Replacement Causes Block Validation DoS

### Summary
The `RecoverFromUpdateValue` function in `Round_Recover.cs` contains an unprotected foreach loop (lines 22-30) that iterates over miners in the provided round without verifying they exist in the current round. When a block contains both a miner replacement transaction and an UpdateValue system transaction, the post-execution validation throws a `KeyNotFoundException`, causing block validation failure and consensus disruption.

### Finding Description [1](#0-0) 

The root cause is in the foreach loop which accesses `RealTimeMinersInformation[information.Key]` for every miner in `providedRound` without checking if that key exists in the current round's `RealTimeMinersInformation`. While lines 10-12 protect against the specific `pubkey` being missing, they do not protect against OTHER miners in the provided round being absent from the current round. [2](#0-1) 

The vulnerability is triggered during `ValidateConsensusAfterExecution`: [3](#0-2) 

When a block includes a `RecordCandidateReplacement` transaction that executes before this validation: [4](#0-3) 

The replacement updates `State.Rounds[currentRoundNumber]` by removing the old miner pubkey and adding the new one. The block header's simplified round was created before this replacement: [5](#0-4) 

This creates a miner set mismatch where the provided round contains the old miner but the current round contains the new miner. The exception is thrown before the replacement detection logic can execute: [6](#0-5) 

### Impact Explanation
**Operational Impact - Consensus DoS:**
- Any block containing both a miner replacement and UpdateValue transaction fails validation with an unhandled exception
- Legitimate blocks from honest miners are rejected if they include replacement transactions
- Consensus can be disrupted by strategically timed replacement transactions
- The failure occurs in post-execution validation, after transactions have been executed, potentially leaving state inconsistent

**Affected Parties:**
- All network validators attempting to validate affected blocks
- Miners whose blocks are rejected due to including replacement transactions
- The overall chain availability and consensus reliability

**Severity:** Medium-High. While not directly stealing funds, this disrupts core consensus operations and can be triggered with moderate difficulty.

### Likelihood Explanation
**Attacker Capabilities Required:**
- Must be or control a candidate admin (achievable by becoming a candidate)
- Can call `ReplaceCandidatePubkey` at any time once they have admin privileges: [7](#0-6) 

**Attack Complexity:**
1. Attacker becomes a candidate admin (medium barrier)
2. Wait for target miner's time slot
3. Submit `ReplaceCandidatePubkey` transaction targeting any current miner
4. If miner includes the transaction in their block, validation fails

**Feasibility Conditions:**
- The replacement transaction must be included in a block with UpdateValue behavior
- Miner may unknowingly include attacker's transaction in their block
- No special network conditions required

**Detection/Operational Constraints:**
- Miners can see pending replacement transactions but may not realize the validation risk
- Once a miner includes the transaction, the block will fail validation
- This can happen accidentally during normal operation, not requiring malicious intent

**Probability:** Medium. The attack requires candidate admin access but can then be triggered reliably by timing transactions during active mining periods.

### Recommendation
**Code-Level Mitigation:**
Add a `ContainsKey` check before accessing `RealTimeMinersInformation` in the foreach loop:

```csharp
foreach (var information in providedRound.RealTimeMinersInformation)
{
    if (!RealTimeMinersInformation.ContainsKey(information.Key))
        continue; // Skip miners that have been replaced
        
    RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
        information.Value.SupposedOrderOfNextRound;
    RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
        information.Value.FinalOrderOfNextRound;
    RealTimeMinersInformation[information.Key].PreviousInValue =
        information.Value.PreviousInValue;
}
```

**Invariant Checks:**
- Verify that all miners in providedRound either exist in currentRound or are documented replacements
- Consider moving the replacement detection logic before the `RecoverFromUpdateValue` call

**Test Cases:**
1. Test block containing both `ReplaceCandidatePubkey` and `UpdateValue` transactions
2. Test `RecoverFromUpdateValue` with mismatched miner sets
3. Test `RecoverFromTinyBlock` (lines 35-47) for the same issue
4. Verify proper handling when replacement affects the block producer

### Proof of Concept
**Initial State:**
- Current round at height N: miners = [MinerA, MinerB, MinerC]
- MinerB is designated to produce next block
- Attacker controls candidate admin for MinerC

**Attack Sequence:**
1. Attacker submits transaction: `ElectionContract.ReplaceCandidatePubkey(oldPubkey: "MinerC", newPubkey: "MinerD")`
2. MinerB produces block N+1 containing:
   - User transaction: ReplaceCandidatePubkey (from step 1)
   - System transaction: UpdateValue for MinerB (with simplified round containing [MinerA, MinerB, MinerC])
3. Block N+1 validation:
   - ValidateConsensusBeforeExecution: state = [A,B,C], header = [A,B,C] âœ“ PASS
   - Execute ReplaceCandidatePubkey: state becomes [A,B,D]
   - Execute UpdateValue: completes
   - ValidateConsensusAfterExecution: state = [A,B,D], header = [A,B,C]
   - Calls `RecoverFromUpdateValue([A,B,C], "MinerB")`
   - Foreach processes MinerC: `RealTimeMinersInformation["MinerC"]` throws KeyNotFoundException

**Expected Result:**
Block validation succeeds with replacement handling

**Actual Result:**
Block validation fails with unhandled KeyNotFoundException, block is rejected

**Success Condition:**
Block validation throws exception, consensus disrupted, demonstrating the DoS vulnerability

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-113)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-31)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();

        var information = new AElfConsensusHeaderInformation();
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```
