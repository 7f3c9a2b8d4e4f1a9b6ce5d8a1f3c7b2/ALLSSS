### Title
Banned Miners Can Remain in Consensus When All Initial Miner Backups Are Unavailable

### Summary
The `GetMinerReplacementInformation()` function fails to provide sufficient alternative candidates when all initial miners are banned or already active, allowing banned miners to remain in the consensus indefinitely. This violates the critical invariant that miner schedule integrity must be maintained and enables banned malicious nodes to continue producing blocks.

### Finding Description

The vulnerability exists in the miner replacement logic when the system cannot find enough alternative candidates from the election snapshot. [1](#0-0) 

When `diff > 0` (indicating insufficient alternative candidates), the code attempts to select initial miners as backups but filters them by `!State.BannedPubkeyMap[k]`. If all initial miners are either banned or already in the current miner list, the `selectedInitialMiners` collection will be empty or insufficient, resulting in `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`.

The consensus contract only replaces as many evil miners as there are alternative candidates available: [2](#0-1) 

The loop at line 311 iterates only up to `AlternativeCandidatePubkeys.Count`, leaving unreplaced banned miners in `currentRound.RealTimeMinersInformation`. These miners are only removed at line 337 during replacement, so miners without alternatives remain.

The mining permission validation does not check banned status: [3](#0-2) 

This validation only verifies the miner exists in `RealTimeMinersInformation`, allowing unreplaced banned miners to continue producing blocks.

### Impact Explanation

**Consensus Integrity Violation:** Banned miners—nodes that have been explicitly marked as malicious or evil through governance or consensus detection—can continue participating in block production and consensus decisions. This directly violates the miner schedule integrity invariant.

**Permanent Degradation:** The system cannot self-heal from this state. Once all backup miners are unavailable, banned miners remain active indefinitely until the next term transition, potentially for the entire term duration.

**Attack Surface Expansion:** Malicious nodes that have already been detected and banned maintain their ability to:
- Produce blocks and earn rewards
- Participate in consensus voting
- Potentially coordinate further attacks with knowledge they cannot be removed

**Severity Justification:** This is a HIGH severity issue because it allows known malicious actors to maintain consensus participation after detection, fundamentally undermining the security model's assumption that banned miners are removed from active participation.

### Likelihood Explanation

**Feasible Preconditions:** This scenario occurs when:
1. Multiple miners exhibit malicious behavior and are banned (realistic in adversarial conditions)
2. Election participation is low, resulting in no valid candidates with sufficient votes (common in early network stages or during low activity periods)
3. The initial miner set is small (typical for production networks starting with 5-21 initial miners)

**Attack Complexity:** LOW - No active attack is required. This is a state that naturally emerges from:
- Normal governance operations (banning malicious miners)
- Network dynamics (candidate participation fluctuations)
- Initial configuration constraints (limited initial miner pool)

**Real-World Scenario:** Consider a network with 7 initial miners [A, B, C, D, E, F, G]. If miners A, B, and C are banned for malicious behavior, and the remaining initial miners D, E, F, G are the current active miners, then when D becomes malicious and needs replacement, there are no available alternatives. Miner D remains active despite being banned.

**Probability:** MEDIUM to HIGH in networks with:
- Small initial miner sets (< 10)
- Active governance that bans malicious nodes
- Low election candidate participation

### Recommendation

**Immediate Fix:** Add a fallback mechanism when insufficient alternatives exist:

```csharp
// After line 392 in ViewMethods.cs
if (alternativeCandidates.Count < evilMinersPubKeys.Count)
{
    // Log critical warning
    Context.LogDebug(() => 
        $"CRITICAL: Cannot replace all evil miners. " +
        $"Need {evilMinersPubKeys.Count}, have {alternativeCandidates.Count}");
    
    // Option 1: Trigger emergency term transition
    // Option 2: Return partial replacement and let governance handle
    // Option 3: Assert and halt (safest but disruptive)
    
    Assert(false, 
        "Insufficient backup miners available. Manual intervention required.");
}
```

**Long-term Solution:**
1. Implement emergency miner pool that can never be fully banned
2. Add validation in consensus contract to reject blocks from banned miners
3. Implement forced term transition when replacement is impossible
4. Add monitoring and alerts when backup miner pool becomes depleted

**Test Cases:**
1. Test scenario where all initial miners are banned
2. Test scenario where initial miners are all active and one becomes evil
3. Test scenario with zero valid election candidates
4. Test graceful degradation when partial replacement is possible

### Proof of Concept

**Initial State:**
- Network initialized with 5 initial miners: [A, B, C, D, E]
- Current active miners: [A, B, C, D, E]
- State.MinersCount.Value = 5
- No valid election candidates (insufficient votes)

**Execution Steps:**

1. **Governance bans miners A and B** (detected malicious behavior): [4](#0-3) 
   - State.BannedPubkeyMap[A] = true
   - State.BannedPubkeyMap[B] = true

2. **Consensus calls GetMinerReplacementInformation:**
   - CurrentMinerList = [A, B, C, D, E]
   - GetEvilMinersPubkeys returns [A, B]
   - latestSnapshot.ElectionResult is empty (no candidates)
   - alternativeCandidates = []

3. **Backup selection from initial miners:**
   - State.InitialMiners.Value = [A, B, C, D, E]
   - Filter by !State.BannedPubkeyMap[k] → [C, D, E]
   - Filter by !CurrentMinerList.Contains(k) → []
   - selectedInitialMiners = []
   - alternativeCandidates remains []

4. **Return value:**
   - EvilMinerPubkeys = [A, B]
   - AlternativeCandidatePubkeys = []

5. **Consensus replacement attempt:**
   - Line 309 condition: `AlternativeCandidatePubkeys.Count > 0` → FALSE
   - Replacement loop does not execute
   - Miners A and B remain in currentRound.RealTimeMinersInformation

**Expected vs Actual Result:**
- **Expected:** Miners A and B are removed from consensus; system enters safe degraded state
- **Actual:** Miners A and B remain active, continue producing blocks, pass validation checks

**Success Condition for Exploit:** Banned miner A successfully produces a block and it is accepted by the network, demonstrating that banned miners can maintain consensus participation.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```
