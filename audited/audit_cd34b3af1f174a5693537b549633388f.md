### Title
Authorization Bypass in Contract Update Proposal for Genesis-Authored Contracts

### Summary
The `AssertAuthorityByContractInfo` check in the Genesis contract incorrectly allows any caller to propose updates for contracts authored by Genesis (Context.Self). The flawed logic in the authorization check evaluates `contractInfo.Author == Context.Self` to TRUE when executing within the Genesis contract, bypassing the intended author restriction that should only permit the actual contract author to propose updates.

### Finding Description

The vulnerability exists in the authorization logic that validates who can propose contract updates: [1](#0-0) 

When `ProposeUpdateContract` is called, it invokes this check: [2](#0-1) 

**Root Cause**: The condition `contractInfo.Author == Context.Self` evaluates to TRUE for all Genesis-authored contracts when the code executes within the Genesis contract context. Since `Context.Self` refers to the currently executing contract (Genesis), and contracts deployed by non-whitelisted proposers have their author set to Genesis address, the first condition passes regardless of who `Context.Sender` is.

**How Contracts Get Genesis as Author**: During deployment, non-whitelisted proposers trigger this logic: [3](#0-2) 

When the proposer is not in the whitelist, `DecideNonSystemContractAuthor` returns `Context.Self` (Genesis address), setting the deployed contract's author to Genesis. [4](#0-3) 

Test evidence confirms contracts can be deployed with Genesis as author: [5](#0-4) 

**Why Protections Fail**: The check should validate that the SENDER is authorized, but instead validates that the AUTHOR equals Genesis. When `contractInfo.Author == Genesis` and code executes in Genesis context where `Context.Self == Genesis`, the condition is always TRUE, allowing any sender to pass.

### Impact Explanation

**Authorization Bypass**: Unauthorized users can propose updates for any contract authored by Genesis (Context.Self), circumventing the intended author-only restriction at the proposal stage.

**Affected Contracts**: All contracts deployed by non-whitelisted proposers through the governance process have `author = Genesis address` and are vulnerable to unauthorized update proposals by any address.

**Operational Impact**: 
- Attackers can spam the governance system with malicious update proposals
- Legitimate governance participants must review and reject unauthorized proposals
- Potential for social engineering if governance doesn't carefully validate proposal origins

**Governance Confusion**: The system expects only authorized authors to propose updates (confirmed by test expectations): [6](#0-5) 

However, Genesis-authored contracts allow anyone to propose, creating inconsistent authorization behavior.

**Severity Justification**: While actual execution still requires governance approval, bypassing author checks at the proposal stage violates the authorization invariant and enables operational disruption through proposal flooding.

### Likelihood Explanation

**Reachable Entry Point**: `ProposeUpdateContract` is a public method callable by any address: [7](#0-6) 

**Feasible Preconditions**: 
- Contracts with `author = Genesis` exist in production (any contract deployed by non-whitelisted proposers)
- Default configuration has `ContractDeploymentAuthorityRequired = true`: [8](#0-7) 

**Attack Complexity**: Low - attacker only needs to:
1. Identify a Genesis-authored contract address
2. Call `ProposeUpdateContract` with malicious code
3. The authorization check passes automatically

**Economic Rationality**: Minimal cost to propose (just transaction fees), high disruption potential through proposal spam.

### Recommendation

**Fix the Authorization Logic**: Modify `AssertAuthorityByContractInfo` to check if the SENDER (not just the author) is Genesis contract itself:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    // Allow Genesis contract itself to propose updates for contracts it authors
    // OR allow the actual author to propose
    Assert(address == Context.Self || address == contractInfo.Author, "No permission.");
}
```

This ensures:
- Genesis contract can update contracts it authored through its own methods (inline calls)
- Regular authors can update their own contracts
- External callers cannot bypass author restrictions

**Add Test Coverage**: Create test case validating that unauthorized users cannot propose updates for Genesis-authored contracts:
```csharp
[Fact]
public async Task ProposeUpdateContract_GenesisAuthoredContract_UnauthorizedSender_ShouldFail()
{
    // Deploy contract with author = Genesis (via non-whitelisted proposer)
    // Attempt ProposeUpdateContract from unauthorized address
    // Assert transaction fails with "No permission."
}
```

### Proof of Concept

**Initial State**:
- Contract deployed through governance by non-whitelisted proposer
- Contract has `info.Author = BasicContractZeroAddress` (Genesis)
- Attacker address is NOT the contract author

**Attack Steps**:
1. Attacker calls `ProposeUpdateContract` with:
   - `input.Address = <target Genesis-authored contract>`
   - `input.Code = <malicious code>`

2. `ProposeUpdateContract` executes `AssertAuthorityByContractInfo(info, attacker_address)` at line 183

3. Check evaluates: `Assert(Genesis == Genesis || attacker_address == Genesis, "No permission.")`

4. First condition is TRUE, assert passes

**Expected Result**: Transaction should fail with "No permission." error (as demonstrated in test line 1186)

**Actual Result**: Transaction succeeds, proposal is created, allowing unauthorized attacker to initiate governance process for updating a contract they don't own

**Success Condition**: Attacker successfully creates update proposal for Genesis-authored contract despite not being the contract author, confirmed by `ProposalCreated` and `ContractProposed` events in transaction logs.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-176)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L183-183)
```csharp
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L318-320)
```csharp
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L826-837)
```csharp
        creator.ShouldBe(BasicContractZeroAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;

        deployAddress.ShouldNotBeNull();

        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(BasicContractZeroAddress);
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1175-1187)
```csharp
        {
            var noPermissionProposingTx = await SideChainTester.GenerateTransactionAsync(SideBasicContractZeroAddress,
                nameof(BasicContractZero.ProposeUpdateContract), AnotherMinerKeyPair, new ContractUpdateInput
                {
                    Address = deployAddress,
                    Code = ByteString.Empty
                });
            var blockReturnSet = await SideChainTester.MineAsync(new List<Transaction> { noPermissionProposingTx });
            var noPermissionProposingTxResult =
                blockReturnSet.TransactionResultMap[noPermissionProposingTx.GetHash()];
            noPermissionProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            noPermissionProposingTxResult.Error.ShouldContain("No permission.");
        }
```

**File:** src/AElf.Kernel.SmartContract/ContractOptions.cs (L5-5)
```csharp
    public bool ContractDeploymentAuthorityRequired { get; set; } = true;
```
