### Title
Malicious Contract Address Bypass in Method Fee Controller Validation Allows Permanent Governance Bypass

### Summary
The `CheckOrganizationExist()` function in `ChangeMethodFeeController` does not validate that the provided `authorityInfo.ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, allowing them to set an arbitrary authority that bypasses all governance controls. This creates a permanent backdoor for method fee manipulation once a single compromised governance proposal is executed.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist()` method which blindly calls any provided contract address without validation: [1](#0-0) 

This function is used in `ChangeMethodFeeController` to validate the new authority: [2](#0-1) 

**Root Cause:** The function makes a cross-contract call to `authorityInfo.ContractAddress` without verifying it is one of the three legitimate governance contracts (Parliament, Association, or Referendum). Legitimate governance contracts implement `ValidateOrganizationExist` by checking their state: [3](#0-2) 

However, an attacker can deploy a malicious contract that always returns `true`:
```csharp
public class MaliciousContract {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true };
    }
}
```

**Why Existing Protections Fail:** 
- The `AssertSenderAddressWith` check on line 25 only verifies the CURRENT controller is calling, not that the NEW controller is legitimate
- There is no validation that `ContractAddress` is a registered system contract or known governance contract
- The system has mechanisms to validate system contracts via `ValidateSystemContractAddress` but they are not used here

**This is a systemic issue** affecting multiple contracts: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Governance Bypass:** Once a malicious authority is set, the attacker gains permanent unilateral control over method fee configuration without requiring any governance approval. This fundamentally breaks the governance invariant that critical system parameters must be controlled through consensus mechanisms.

**Operational Impact:** The attacker controlling `State.MethodFeeController.Value.OwnerAddress` can:
1. Call `SetMethodFee` to set arbitrary method fees for any contract function
2. Set extremely high fees to DoS critical operations
3. Set zero fees to drain expected fee revenue
4. Repeatedly change fees to destabilize the economic model

**Who is Affected:** All users of the TokenHolder contract and other affected system contracts (MultiToken, Consensus, etc.) are impacted by manipulated method fees.

**Severity Justification:** Critical - This creates a permanent backdoor that completely bypasses governance controls for a critical economic parameter (method fees). A single compromised governance proposal enables unlimited future attacks without detection or prevention.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Deploy a malicious contract (low barrier - any user can deploy contracts on AElf)
2. Get a Parliament proposal approved to change the method fee controller (requires social engineering, compromised miner keys, or exploiting other vulnerabilities)

**Attack Complexity:** Medium
- Deploying malicious contract: Trivial
- Getting proposal approved: Difficult but not impossible (51% miner approval required for Parliament)
- Once approved: Attack is permanent and undetectable

**Feasibility Conditions:**
- Parliament or current controller must approve ONE malicious proposal
- This could occur through: compromised miner keys, social engineering, or as part of a larger attack chain
- Historical precedent exists for governance attacks in blockchain systems

**Probability Reasoning:** While initial compromise requires governance control, the permanent nature of the bypass makes this critical. A single successful attack creates an irreversible backdoor. The systemic nature (affecting multiple contracts) multiplies the attack surface.

### Recommendation

**Immediate Fix:** Add validation that `authorityInfo.ContractAddress` is one of the known governance contracts before accepting it:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known governance contract
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    if (State.AssociationContract.Value == null)
        State.AssociationContract.Value = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    if (State.ReferendumContract.Value == null)
        State.ReferendumContract.Value = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    var isValidGovernanceContract = authorityInfo.ContractAddress == State.ParliamentContract.Value ||
                                   authorityInfo.ContractAddress == State.AssociationContract.Value ||
                                   authorityInfo.ContractAddress == State.ReferendumContract.Value;
    
    Assert(isValidGovernanceContract, "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply fix to all affected contracts:** TokenHolder, MultiToken, Consensus, Parliament, Association, Referendum, Configuration, CrossChain, Economic, Election, Profit, Treasury, TokenConverter, Vote, and Genesis contracts.

**Test Cases:**
1. Verify rejection when providing arbitrary contract addresses
2. Verify acceptance only for Parliament/Association/Referendum contract addresses
3. Test that malicious contracts cannot bypass validation
4. Add regression tests for all affected contracts

### Proof of Concept

**Initial State:**
- TokenHolder contract deployed with Parliament as default method fee controller
- State.MethodFeeController.Value.OwnerAddress = Parliament default organization address
- State.MethodFeeController.Value.ContractAddress = Parliament contract address

**Attack Steps:**

1. **Attacker deploys MaliciousContract:**
```csharp
public class MaliciousContract {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```
Deployed at address `0x1234...malicious`

2. **Attacker creates Parliament proposal:**
```csharp
var proposalInput = new CreateProposalInput {
    ToAddress = TokenHolderContractAddress,
    ContractMethodName = "ChangeMethodFeeController",
    Params = new AuthorityInfo {
        ContractAddress = "0x1234...malicious", // Malicious contract
        OwnerAddress = attackerAddress
    }.ToByteString(),
    OrganizationAddress = parliamentDefaultOrgAddress
};
```

3. **Proposal gets approved** (through compromise/social engineering)

4. **Proposal is released:**
    - Parliament.Release() calls TokenHolder.ChangeMethodFeeController()
    - Line 25 check passes (Parliament org is current controller)
    - Line 26: CheckOrganizationExist calls MaliciousContract.ValidateOrganizationExist(attackerAddress)
    - MaliciousContract returns true
    - Line 27: Assertion passes
    - Line 29: State.MethodFeeController.Value = malicious authority

**Result:**
- State.MethodFeeController.Value.OwnerAddress = attackerAddress
- State.MethodFeeController.Value.ContractAddress = 0x1234...malicious
- Attacker can now call SetMethodFee directly without any governance approval
- All future method fee changes bypass Parliament completely

**Success Condition:** Attacker can call `SetMethodFee` with arbitrary fees and only their signature, without requiring any governance proposal or approval.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
