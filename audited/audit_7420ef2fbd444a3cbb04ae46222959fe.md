# Audit Report

## Title
Governance Manipulation Through Strategic Member Removal in Association Contract

## Summary
The Association contract evaluates proposal thresholds dynamically using current organization membership rather than taking snapshots at voting time. This allows organizations to retroactively manipulate proposal outcomes by removing members who cast unfavorable votes, enabling proposals that were legitimately rejected to become acceptable and executable.

## Finding Description

The vulnerability stems from the Association contract's vote counting mechanism that filters votes based on current membership status rather than membership at the time of voting.

**Root Cause:**

When members vote on a proposal through `Approve()`, `Reject()`, or `Abstain()`, their addresses are permanently added to the proposal's vote lists [1](#0-0) . However, when determining if a proposal can be released, the contract filters these lists to count only votes from current organization members.

The `IsProposalRejected()` method explicitly filters rejections using current membership [2](#0-1) . Similarly, `IsProposalAbstained()` and `CheckEnoughVoteAndApprovals()` filter abstentions and approvals [3](#0-2) .

The `RemoveMember()` function allows an organization to remove members with no validation against active proposals [4](#0-3) .

**Execution Path:**

1. Organization has 10 members with thresholds: MinimalApprovalThreshold=4, MaximalRejectionThreshold=3
2. Proposal A is created and receives 4 approvals and 4 rejections
3. Proposal A is REJECTED (4 rejections > 3 threshold)
4. Approving members create Proposal B to remove one rejecting member
5. Proposal B passes (gets 5 approvals) and is released
6. The targeted member is removed from the organization
7. When checking Proposal A again via `IsReleaseThresholdReached()` [5](#0-4) , only 3 rejections now count (removed member's vote is filtered out)
8. Proposal A is no longer rejected (3 â‰¤ 3) and can be released

**Additional Issue:**

There's an inconsistency where `MinimalVoteThreshold` counts ALL votes without filtering by membership [6](#0-5) , creating unpredictable behavior when members are removed.

## Impact Explanation

**HIGH Severity** - This vulnerability breaks a fundamental governance invariant: that votes cast in good faith cannot be retroactively invalidated.

**Direct Impacts:**
- Organizations can manipulate proposal outcomes by selectively removing members whose votes are unfavorable
- Proposals that were legitimately rejected by the organization can be forced through
- Approved proposals can be blocked by removing approving members
- This completely undermines the integrity and trustworthiness of the Association governance mechanism

**Affected Parties:**
- Organization members who voted believing their votes were final
- Downstream contracts relying on Association governance decisions
- Any funds, permissions, or system configurations controlled by the organization
- The broader AElf ecosystem's governance credibility

## Likelihood Explanation

**Medium-High Likelihood** - The attack requires organizational control but is otherwise straightforward.

**Attacker Prerequisites:**
- Control sufficient votes to pass a member removal proposal
- This is achievable in organizations with contentious splits (e.g., 6-4 voting patterns)
- Member removal proposals may have different thresholds than other proposals, making this more feasible

**Attack Complexity:**
- LOW - Uses only standard public contract methods
- No special timing requirements
- Predictable and reliable outcome
- Entry point `RemoveMember()` is publicly accessible to the organization

**Detection Difficulty:**
- HIGH - Member removal is a legitimate governance action
- Manipulation only becomes apparent through careful analysis of voting patterns and timing
- No on-chain indicators distinguish malicious from legitimate member removal

## Recommendation

Implement vote snapshots at proposal creation or voting time. Options include:

1. **Snapshot membership at proposal creation:**
   Store the organization's member list with each proposal and use that list for vote counting.

2. **Validate votes remain valid:**
   Only count votes from addresses that are still members AND were members when they cast their vote.

3. **Prevent member changes during active proposals:**
   Add a check in `RemoveMember()` to prevent removal if the member has voted on any non-expired proposals.

4. **Fix the MinimalVoteThreshold inconsistency:**
   Ensure all threshold calculations use the same filtering logic.

**Recommended Fix (Option 1):**
In `CreateNewProposal()`, store a snapshot of current members. In threshold checking methods, filter votes against this snapshot rather than current membership. This preserves governance integrity while allowing membership changes for future proposals.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
public async Task Governance_Manipulation_Through_Member_Removal()
{
    // Setup: Create organization with 10 members
    // Thresholds: MinimalApproval=4, MaximalRejection=3
    var members = CreateMemberAddresses(10);
    var organization = await CreateOrganizationAsync(members, 
        minimalApproval: 4, maximalRejection: 3);
    
    // Step 1: Create Proposal A
    var proposalA = await CreateProposalAsync(organization);
    
    // Step 2: Vote on Proposal A
    // 4 approvals from members 0-3
    for(int i = 0; i < 4; i++)
        await ApproveAsync(proposalA, members[i]);
    
    // 4 rejections from members 4-7
    for(int i = 4; i < 8; i++)
        await RejectAsync(proposalA, members[i]);
    
    // Step 3: Verify Proposal A is rejected (4 > 3)
    var canRelease = await CanReleaseAsync(proposalA);
    Assert.False(canRelease); // Should be rejected
    
    // Step 4: Create and pass Proposal B to remove member 4
    var proposalB = await CreateRemoveMemberProposalAsync(organization, members[4]);
    
    // Get 5 approvals for Proposal B (members 0-3 + member 9)
    for(int i = 0; i < 4; i++)
        await ApproveAsync(proposalB, members[i]);
    await ApproveAsync(proposalB, members[9]);
    
    // Step 5: Release Proposal B, removing member 4
    await ReleaseAsync(proposalB);
    
    // Step 6: Check Proposal A again - now only 3 rejections count
    canRelease = await CanReleaseAsync(proposalA);
    Assert.True(canRelease); // VULNERABILITY: Now can release!
    
    // Proposal A can now be released despite being legitimately rejected
    await ReleaseAsync(proposalA); // Should succeed, demonstrating manipulation
}
```

## Notes

The vulnerability is confirmed through direct code analysis. The vote counting methods explicitly filter by current membership, and the `RemoveMember()` function has no safeguards against active proposals. This is a design flaw in the Association contract that breaks vote immutability and enables governance manipulation.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L130-131)
```csharp
        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-51)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```
