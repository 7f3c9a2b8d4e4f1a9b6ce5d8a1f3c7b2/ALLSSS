### Title
Insufficient Access Control in UpdateValue Allows Malicious Miners to Manipulate Consensus State

### Summary
The `ExtractInformationToUpdateConsensus` function only validates that a pubkey exists in the miner list via a simple `ContainsKey` check, without verifying ownership. Combined with the public `UpdateValue` method that lacks input validation, any current miner can craft arbitrary consensus update data to corrupt their own consensus values or manipulate other miners' consensus state, breaking consensus integrity.

### Finding Description

The vulnerability exists across multiple files in the consensus update flow:

**Root Cause 1 - No Ownership Validation:** [1](#0-0) 

The function only checks if the pubkey exists in the miner list but doesn't validate that the caller owns or has permission to extract information for that pubkey. Any caller can extract consensus information for any miner.

**Root Cause 2 - Public Entry Point Without Input Validation:** [2](#0-1) 

The `UpdateValue` method is publicly callable and only performs a basic miner check via `PreCheck()`, which merely validates the caller is in the current/previous miner list: [3](#0-2) 

**Root Cause 3 - No Validation of Input Values:** [4](#0-3) 

The `ProcessUpdateValue` function uses `_processingBlockMinerPubkey` (the actual transaction sender) to update miner information, but blindly accepts all values from the `UpdateValueInput` without validating they were legitimately generated by the caller. A malicious miner can set arbitrary `OutValue`, `Signature`, and `PreviousInValue`.

**Root Cause 4 - Manipulation of Other Miners' State:** [5](#0-4) 

Any miner can manipulate OTHER miners' `FinalOrderOfNextRound` through the `TuneOrderInformation` dictionary without validation. [6](#0-5) 

Similarly, miners can overwrite OTHER miners' `PreviousInValue` through `MinersPreviousInValues` without authorization checks.

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` exists but only validates consensus extra data during block validation (before/after execution): [7](#0-6) 

This validation applies to the block header's consensus data, not to direct transaction calls to `UpdateValue`. When a miner submits a transaction directly calling `UpdateValue`, this validation is bypassed.

The code comments reference a non-existent `ConstrainedAEDPoSTransactionValidationProvider`: [8](#0-7) 

This validation provider does not exist in the codebase, leaving a critical security gap.

### Impact Explanation

**Consensus Integrity Violation:**
- Malicious miners can set fraudulent `OutValue` and `Signature` values, corrupting the random number generation mechanism that depends on these cryptographic values
- The consensus system's security properties rely on honest signature generation from secret in-values, which can be violated

**Miner Order Manipulation:**
- Attackers can arbitrarily modify any miner's `FinalOrderOfNextRound` through `TuneOrderInformation`, allowing them to control the block production schedule
- This breaks the fairness and security assumptions of the round-robin consensus mechanism

**Cross-Miner State Corruption:**
- Via `MinersPreviousInValues`, attackers can overwrite other miners' `PreviousInValue`, corrupting the cryptographic chain of consensus values
- Via `DecryptedPieces`, attackers can inject fake secret sharing data into other miners' state

**Affected Parties:**
- All network participants are affected as consensus integrity is compromised
- Honest miners have their consensus state manipulated without their knowledge
- The network's random number generation and block scheduling become unreliable

**Severity Justification:**
This is a HIGH severity vulnerability because it allows any current miner to unilaterally break core consensus invariants, manipulate block production order, and corrupt the cryptographic integrity of the consensus mechanism.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker only needs to be an active miner (member of current or previous round's miner list)
- No special privileges beyond normal miner status required

**Attack Complexity:**
- Very low - attacker simply crafts a transaction calling `UpdateValue` with malicious input
- Can extract another miner's data via `ExtractInformationToUpdateConsensus` or craft entirely arbitrary values
- Single transaction execution achieves the exploit

**Feasibility Conditions:**
- Attack works whenever the attacker is in the miner list
- No timing constraints or race conditions required
- No economic barriers beyond standard transaction fees

**Detection Constraints:**
- Malicious `UpdateValue` transactions appear legitimate (signed by a valid miner)
- No on-chain validation would reject the transaction
- Corruption may not be immediately obvious until consensus failures occur

**Probability:**
HIGH - The attack is trivial to execute, requires only miner status (which attackers targeting consensus would naturally have), and has no meaningful barriers. The missing `ConstrainedAEDPoSTransactionValidationProvider` indicates this attack surface was recognized but not properly mitigated.

### Recommendation

**1. Add Caller Ownership Validation:**

In `ProcessUpdateValue`, validate that the values in `UpdateValueInput` match expected values for the caller:

```csharp
// Validate OutValue matches caller's expected generation
var expectedOutValue = HashHelper.ComputeFrom(minerInRound.InValue);
Assert(updateValueInput.OutValue == expectedOutValue, 
    "OutValue must match caller's InValue hash");

// Validate Signature matches previous round's calculation
if (TryToGetPreviousRoundInformation(out var prevRound)) {
    var expectedSignature = prevRound.CalculateSignature(updateValueInput.PreviousInValue);
    Assert(updateValueInput.Signature == expectedSignature,
        "Signature validation failed");
}
```

**2. Restrict Cross-Miner Data Modification:**

Remove or strictly validate the ability to modify other miners' state:

```csharp
// Only allow modifications to other miners if explicitly authorized
// For TuneOrderInformation, validate against consensus rules
foreach (var tuneOrder in updateValueInput.TuneOrderInformation) {
    Assert(IsValidOrderTuning(tuneOrder.Key, tuneOrder.Value, currentRound),
        $"Invalid order tuning for {tuneOrder.Key}");
}

// For MinersPreviousInValues, only allow if cryptographically verified
foreach (var previousInValue in input.MinersPreviousInValues) {
    Assert(IsValidPreviousInValueReveal(previousInValue.Key, previousInValue.Value),
        "Invalid previous in value reveal");
}
```

**3. Implement Transaction-Level Validation:**

Create the missing `ConstrainedAEDPoSTransactionValidationProvider` to validate `UpdateValue` transactions before they enter the transaction pool, ensuring they match expected consensus data.

**4. Add Invariant Checks:**

After `ProcessUpdateValue`, verify consensus invariants:
- OutValue is unique and properly generated
- Signature chain is unbroken
- Miner order changes follow consensus rules

**5. Test Cases:**

Add test cases that verify:
- Non-owner cannot extract and use another miner's consensus data
- Miners cannot set arbitrary OutValue/Signature values
- Cross-miner state modifications are properly restricted
- Direct `UpdateValue` calls are validated same as block-generated ones

### Proof of Concept

**Initial State:**
- Network has multiple active miners: MinerA, MinerB, MinerC
- Current round information is established with each miner's data

**Attack Sequence:**

**Step 1:** MinerA extracts MinerB's consensus information (or crafts arbitrary values)
```csharp
var round = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
var stolenData = round.ExtractInformationToUpdateConsensus(MinerB_Pubkey, randomNumber);
// ContainsKey passes, no ownership check fails
```

**Step 2:** MinerA crafts malicious UpdateValueInput
```csharp
var maliciousInput = new UpdateValueInput {
    OutValue = stolenData.OutValue,  // Steal MinerB's value
    Signature = stolenData.Signature, // Steal MinerB's signature
    PreviousInValue = Hash.Empty,
    TuneOrderInformation = {
        { MinerC_Pubkey, 999 }  // Manipulate MinerC's next round order
    },
    MinersPreviousInValues = {
        { MinerB_Pubkey, FakeHash }  // Corrupt MinerB's previous in value
    },
    // ... other fields
};
```

**Step 3:** MinerA submits transaction
```csharp
await MinerAStub.UpdateValue.SendAsync(maliciousInput);
// PreCheck passes (MinerA is a miner)
// ProcessUpdateValue executes without validation
```

**Expected Result:**
Transaction should be rejected due to unauthorized data or invalid values for caller

**Actual Result:**
- MinerA's consensus information is updated with MinerB's OutValue and Signature
- MinerC's `FinalOrderOfNextRound` is set to 999 (breaking miner ordering)
- MinerB's `PreviousInValue` is overwritten with `FakeHash` (corrupting consensus chain)
- Consensus integrity is violated
- No validation failure occurs

**Success Condition:**
Query the round information after the attack and observe:
- MinerA has MinerB's cryptographic values
- MinerC has manipulated order
- MinerB has corrupted previous in value
- All updates succeeded despite being unauthorized/invalid

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L18-18)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-265)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```
