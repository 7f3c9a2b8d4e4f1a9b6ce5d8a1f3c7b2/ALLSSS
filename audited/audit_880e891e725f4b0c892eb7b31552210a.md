# Audit Report

## Title
Period Desynchronization Causes RegisterForProfits DoS and Auto-Distribution Failure

## Summary
The TokenHolder contract maintains a cached period value that becomes desynchronized from the Profit contract's CurrentPeriod when distributions are initiated externally by the scheme manager. This desynchronization causes RegisterForProfits transactions to revert during auto-distribution attempts, preventing users from locking tokens and registering as beneficiaries.

## Finding Description

The vulnerability stems from period synchronization issues between the TokenHolder and Profit contracts. When a user creates a TokenHolder profit scheme, they become the scheme manager [1](#0-0) . The scheme manager is authorized to call `Profit.DistributeProfits` directly [2](#0-1) .

When `RegisterForProfits` is called, it retrieves the scheme without updating the period [3](#0-2) . The `GetValidScheme` method with `updateSchemePeriod=false` returns early without synchronizing the period from the Profit contract [4](#0-3) .

During auto-distribution within `RegisterForProfits`, the cached stale period is used to create the distribution input [5](#0-4) . When this distribution request reaches the Profit contract, it performs strict period validation [6](#0-5) .

**Desynchronization Scenario:**
1. Scheme manager calls `Profit.DistributeProfits` directly (bypassing TokenHolder)
2. Profit contract increments `CurrentPeriod` [7](#0-6) 
3. TokenHolder's cached period remains stale (not updated)
4. User calls `RegisterForProfits` triggering auto-distribution
5. Period mismatch causes assertion failure and transaction revert

The TokenHolder contract only updates its cached period when `DistributeProfits` is called with `updateSchemePeriod=true` [8](#0-7) , but this synchronization is bypassed when the manager calls Profit contract directly.

## Impact Explanation

**High Severity - Denial of Service:**
- Complete DoS of `RegisterForProfits` function when auto-distribution is triggered
- Users cannot lock their tokens to participate in profit schemes
- Users cannot become beneficiaries and receive profit distributions
- The auto-distribution mechanism, a core contract feature, becomes unreliable
- Affects all users attempting to register during the desynchronization period
- Requires manual intervention by scheme manager to restore synchronization by calling `TokenHolder.DistributeProfits`

While profits are not lost (they remain in the VirtualAddress and can be distributed later), and double distribution is prevented by the period validation, the operational impact is severe as it breaks a critical user-facing function. Users lose the ability to participate in profit schemes until the period is manually resynchronized.

## Likelihood Explanation

**High Likelihood:**
The vulnerability occurs through normal, authorized operations without requiring any malicious behavior:

1. **Scheme Manager Authority:** Any user who creates a TokenHolder scheme becomes the scheme manager and gains authorization to call `Profit.DistributeProfits` directly
2. **Expected Behavior:** Direct calls to the Profit contract by the manager are authorized and legitimate
3. **No Special Privileges:** No elevated permissions or complex setup required beyond normal scheme creation
4. **Natural Occurrence:** Will happen whenever a scheme manager performs manual distribution outside TokenHolder's control
5. **Immediate Impact:** The issue manifests immediately as failed transactions when users attempt to register

The vulnerability has a high probability of occurrence in any actively managed profit scheme where the manager performs manual distributions.

## Recommendation

Modify `RegisterForProfits` to always update the scheme period before performing auto-distribution:

```csharp
public override Empty RegisterForProfits(RegisterForProfitsInput input)
{
    Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
    // Change: Pass true to updateSchemePeriod to ensure synchronization
    var scheme = GetValidScheme(input.SchemeManager, true);
    
    // ... rest of the method
}
```

Alternatively, modify `GetValidScheme` to always synchronize the period when auto-distribution thresholds are configured:

```csharp
private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
{
    var scheme = State.TokenHolderProfitSchemes[manager];
    Assert(scheme != null, "Token holder profit scheme not found.");
    // Always update if auto-distribution is configured
    bool shouldUpdate = updateSchemePeriod || (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any());
    UpdateTokenHolderProfitScheme(ref scheme, manager, shouldUpdate);
    return scheme;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task PeriodDesynchronization_Causes_RegisterForProfits_DoS()
{
    // Setup: Create TokenHolder scheme (user becomes manager)
    await TokenHolderStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1,
        AutoDistributeThreshold = { { "ELF", 100 } }
    });
    
    var schemeManager = DefaultAddress;
    var schemeId = (await ProfitStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = schemeManager })).SchemeIds.First();
    
    // Contribute profits to trigger auto-distribution threshold
    await TokenStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ProfitAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await ProfitStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = "ELF",
        Amount = 1000
    });
    
    // Manager calls Profit.DistributeProfits DIRECTLY (bypassing TokenHolder)
    // This increments Profit's CurrentPeriod but leaves TokenHolder's cached period stale
    await ProfitStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1,
        AmountsMap = { { "ELF", 0 } }
    });
    
    // Verify: Profit's CurrentPeriod is now 2
    var profitScheme = await ProfitStub.GetScheme.CallAsync(schemeId);
    Assert.Equal(2, profitScheme.CurrentPeriod);
    
    // Verify: TokenHolder's cached period is still 1
    var tokenHolderScheme = await TokenHolderStub.GetScheme.CallAsync(schemeManager);
    Assert.Equal(1, tokenHolderScheme.Period);
    
    // Attack: User tries to RegisterForProfits (with auto-distribution triggered)
    var result = await TokenHolderStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            SchemeManager = schemeManager,
            Amount = 100
        });
    
    // Result: Transaction REVERTS due to period mismatch
    Assert.Contains("Invalid period", result.TransactionResult.Error);
    
    // Impact: User cannot lock tokens or register as beneficiary
    // DoS of RegisterForProfits function until manual resynchronization
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L133-145)
```csharp
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-152)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-197)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-289)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
