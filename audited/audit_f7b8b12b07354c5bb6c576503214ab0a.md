### Title
Duplicate Mining Order Validation Bypass Allows Consensus Disruption

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method uses `Distinct()` on entire `MinerInRound` objects rather than on `FinalOrderOfNextRound` values, allowing duplicate mining orders to pass validation. A malicious miner can submit NextRound consensus data with duplicate `FinalOrderOfNextRound` values that will be accepted and propagated to blockchain state, causing multiple miners to have identical `Order` values in subsequent rounds and disrupting consensus integrity.

### Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider` attempts to verify that all miners who produced blocks have determined their next round order: [1](#0-0) 

However, `Distinct()` operates on entire `MinerInRound` objects. The `MinerInRound` protobuf message contains 17 fields including `pubkey`, `order`, `expected_mining_time`, `produced_blocks`, etc.: [2](#0-1) 

Protobuf-generated C# classes implement `Equals()` and `GetHashCode()` comparing all fields. Therefore, two miners with the same `FinalOrderOfNextRound` but different `Pubkey` (or any other field) are considered distinct objects by `Distinct()`.

**Why existing protections fail:**

The codebase explicitly handles `FinalOrderOfNextRound` conflicts during normal consensus data application: [3](#0-2) 

This conflict resolution mechanism proves the system design requires unique `FinalOrderOfNextRound` values. However, when validating externally-provided round data during NextRound transitions, the flawed `Distinct()` check fails to detect duplicates.

**Exploitation path:**

1. During a NextRound behavior transition (line 84-87 in validation setup): [4](#0-3) 

2. A malicious miner crafts `extraData.Round` with duplicate `FinalOrderOfNextRound` values across different miners
3. The validation checks distinct `MinerInRound` objects (not distinct order values), so duplicates pass
4. The corrupt round is saved to state: [5](#0-4) 

5. When generating the next round, miners are ordered by their `FinalOrderOfNextRound`: [6](#0-5) 

6. Multiple miners receive the same `Order` value in the new round, since their `FinalOrderOfNextRound` values are identical
7. The calculation of available orders for non-mining miners uses `occupiedOrders.Contains()` which only removes one occurrence of each value: [7](#0-6) 

### Impact Explanation

**Concrete harm:**
- Multiple miners assigned identical `Order` values receive the same `ExpectedMiningTime`
- Both miners attempt to produce blocks simultaneously, creating competing blocks at the same height
- Extra block producer selection becomes ambiguous when the designated order maps to multiple miners
- Round time slot validation breaks as it assumes unique orders per miner
- Consensus cannot progress correctly with duplicate mining orders

**Protocol damage:**
- Chain progression halts or experiences persistent forking
- Block finality is compromised as conflicting blocks compete for the same slot
- Mining schedule integrity—a critical consensus invariant—is violated
- Recovery requires manual intervention to fix the corrupt round state

**Affected parties:**
- All network participants experience consensus disruption
- Honest miners cannot produce blocks in their proper time slots
- dApps and users face transaction processing failures
- Chain security is degraded during the disruption period

**Severity justification:**
This is **Critical** because it directly violates the "Correct round transitions and miner schedule integrity" invariant, allows any active miner to disrupt consensus without requiring special privileges, and affects the entire network's operation.

### Likelihood Explanation

**Attacker capabilities:**
- Must be an active miner in the current round
- Can submit consensus transactions during their mining turn
- No special privileges beyond normal miner status required

**Attack complexity:**
- Trivial: simply craft a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
- No complex timing or state manipulation needed
- Single transaction execution

**Feasibility conditions:**
- Any miner during their NextRound transition can execute
- No preconditions beyond being scheduled to perform NextRound behavior
- The validation flaw is deterministic and always exploitable

**Detection/operational constraints:**
- The validation provider is always active for NextRound behaviors
- No rate limiting or additional checks exist
- Once corrupt data enters state, the damage propagates automatically to subsequent rounds

**Probability:**
High likelihood of exploitation given the simplicity and guaranteed success once the attacker obtains miner status.

### Recommendation

**Code-level mitigation:**

Replace the validation logic to count distinct `FinalOrderOfNextRound` values instead of distinct `MinerInRound` objects:

```csharp
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
    
if (finalOrders != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
{
    validationResult.Message = "Invalid FinalOrderOfNextRound - duplicates detected.";
    return validationResult;
}
```

**Additional invariant checks:**

Add explicit validation in `ProcessNextRound` before saving to state:

```csharp
var orderCounts = nextRound.RealTimeMinersInformation.Values
    .GroupBy(m => m.Order)
    .Where(g => g.Count() > 1);
    
Assert(!orderCounts.Any(), "Duplicate Order values detected in next round.");
```

**Test cases to prevent regression:**

1. Create test with 5 miners where 2 have `FinalOrderOfNextRound = 2` but different pubkeys
2. Verify validation fails with appropriate error message
3. Create test ensuring legitimate scenarios (all unique orders) still pass
4. Add integration test verifying `GenerateNextRoundInformation` produces unique `Order` values

### Proof of Concept

**Initial state:**
- Current round with 5 active miners (A, B, C, D, E)
- All 5 miners have produced blocks (non-null `OutValue`)
- Miner A is scheduled to perform NextRound transition

**Attack sequence:**

1. Miner A crafts malicious `NextRoundInput` with:
   - Miner A: `FinalOrderOfNextRound = 2`, `Pubkey = "A"`, `OutValue = Hash1`
   - Miner B: `FinalOrderOfNextRound = 2`, `Pubkey = "B"`, `OutValue = Hash2` (duplicate!)
   - Miner C: `FinalOrderOfNextRound = 3`, `Pubkey = "C"`, `OutValue = Hash3`
   - Miner D: `FinalOrderOfNextRound = 4`, `Pubkey = "D"`, `OutValue = Hash4`
   - Miner E: `FinalOrderOfNextRound = 5`, `Pubkey = "E"`, `OutValue = Hash5`

2. Miner A submits `NextRound` transaction with this data

3. Validation executes:
   - `Where(m => m.FinalOrderOfNextRound > 0)` → 5 miners
   - `Distinct()` → 5 distinct `MinerInRound` objects (different pubkeys)
   - `Count()` → 5
   - Compare to `Count(m => m.OutValue != null)` → 5
   - **Validation passes** ✓

4. Corrupt round saved to state via `AddRoundInformation(nextRound)`

5. Next round transition occurs, calling `GenerateNextRoundInformation`:
   - Miners ordered by `FinalOrderOfNextRound`: [A(2), B(2), C(3), D(4), E(5)]
   - Miner A assigned `Order = 2`
   - Miner B assigned `Order = 2` (duplicate!)
   - Miner C assigned `Order = 3`
   - Miner D assigned `Order = 4`
   - Miner E assigned `Order = 5`

**Expected result:**
Validation should reject the malicious data with error "Invalid FinalOrderOfNextRound - duplicates detected."

**Actual result:**
Validation passes, corrupt round enters blockchain state, subsequent round has two miners with `Order = 2`, causing consensus disruption.

**Success condition:**
Both Miner A and Miner B have `Order = 2` in the generated next round, proving the duplicate detection bypass succeeded.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
