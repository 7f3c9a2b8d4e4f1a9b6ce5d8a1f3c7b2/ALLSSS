# Audit Report

## Title
Off-By-One Error in MinersCountOfConsent Enables Term Change Denial-of-Service When Miner Count is Divisible by Three

## Summary
The `MinersCountOfConsent` formula in the AEDPoS consensus mechanism incorrectly calculates the 2/3 majority threshold when the total miner count is divisible by 3, requiring an additional vote beyond the intended Byzantine Fault Tolerance threshold. This allows an attacker controlling exactly 1/3 of miners to temporarily block term changes by ceasing block production, preventing newly elected miners from joining and delaying treasury distributions for up to 3 days.

## Finding Description

The vulnerability exists in the consensus threshold calculation used to determine when term changes should occur. [1](#0-0) 

The formula computes `(Count * 2) / 3 + 1` using integer division. When the miner count is divisible by 3, this produces an inflated threshold:
- Count=6: requires 5 votes (83.3%) instead of standard 2/3 = 4 votes (66.7%)
- Count=9: requires 7 votes (77.8%) instead of standard 2/3 = 6 votes (66.7%)
- Count=3: requires 3 votes (100%) instead of standard 2/3 = 2 votes (66.7%) [2](#0-1) 

The `NeedToChangeTerm` function filters only miners who have produced blocks (`.ActualMiningTimes.Any()`) and compares this count against `MinersCountOfConsent`. The comment explicitly states the intent is "two thirds of miners": [3](#0-2) 

This discrepancy between intent and implementation breaks the Byzantine Fault Tolerance assumption that the system should tolerate up to 1/3 faulty nodes.

**Exploitation Path:**
1. Network operates with 6 miners (configurable via governance [4](#0-3) )
2. Attacker controls 2 miners (exactly 1/3)
3. When the term period expires, honest miners' blocks signal term change
4. Attacker's 2 miners cease block production entirely
5. Only 4 honest miners have `ActualMiningTimes.Any()` evaluating to true
6. Since 4 < 5 (MinersCountOfConsent), `NeedToChangeTerm` returns false
7. The consensus behavior provider returns `NextRound` instead of `NextTerm`: [5](#0-4) 

## Impact Explanation

**Governance Disruption:**
When term changes are blocked, newly elected miners cannot join the active miner set, breaking the democratic election cycle. The old miner set (including attackers) remains in power beyond their elected term. Election snapshots are not taken: [6](#0-5) 

**Economic Impact:**
Treasury profit releases for the completed term are delayed, and current miners continue earning block rewards that should go to newly elected miners: [7](#0-6) 

Initial mining rewards are substantial: [8](#0-7) 

**Temporary Nature:**
The attack is self-limiting. After 3 days (4,320 missed time slots), the non-producing miners are detected as evil and marked: [9](#0-8) [10](#0-9) 

Evil miners are then replaced during subsequent round generation: [11](#0-10) 

**Severity:** Medium - while this does not enable permanent fund theft, it constitutes a denial-of-service attack on the governance layer for up to 3 days, disrupts democratic miner rotation, and delays economic distributions. Block production continues normally, preventing complete chain halt.

## Likelihood Explanation

**Feasibility Conditions:**
- Network must have 3, 6, 9, 12, 15, 18, or 21 miners (multiples of 3)
- While the default is 17 miners (not vulnerable), the system is configurable via Parliament governance
- Production networks may choose values like 6, 9, or 12 for operational reasons

**Attacker Capabilities:**
- Must control exactly `Count/3` miners when `Count` is divisible by 3
- Attack execution is trivial: simply stop mining blocks
- Observable but takes 3 days before penalties apply

**Economic Rationality:**
Attackers who are current miners and lost the recent election can delay replacement for days, continuing to earn block rewards that should go to newly elected miners.

## Recommendation

Fix the formula to correctly implement a standard 2/3 majority threshold. Replace the current calculation:

```
public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

With the mathematically correct ceiling-based formula:

```
public int MinersCountOfConsent => (RealTimeMinersInformation.Count.Mul(2).Add(2)).Div(3);
```

Or alternatively, use:
```
public int MinersCountOfConsent => (int)Math.Ceiling(RealTimeMinersInformation.Count * 2.0 / 3.0);
```

This ensures that for any miner count N:
- N=3: requires 2 votes (66.7%)
- N=6: requires 4 votes (66.7%)
- N=9: requires 6 votes (66.7%)

This maintains proper Byzantine Fault Tolerance by tolerating exactly 1/3 faulty nodes, matching the documented intent.

## Proof of Concept

```csharp
[Fact]
public void MinersCountOfConsent_OffByOne_WhenCountDivisibleByThree()
{
    // Setup: Network with 6 miners (divisible by 3)
    var round = new Round();
    for (int i = 0; i < 6; i++)
    {
        round.RealTimeMinersInformation.Add($"miner{i}", new MinerInRound
        {
            Pubkey = $"miner{i}",
            ActualMiningTimes = { Timestamp.FromDateTime(DateTime.UtcNow) }
        });
    }
    
    // Calculate threshold
    int threshold = round.MinersCountOfConsent;
    
    // Verify: Current formula requires 5 (83.3%)
    Assert.Equal(5, threshold);
    
    // Expected: Standard 2/3 majority should require 4 (66.7%)
    int expectedThreshold = (int)Math.Ceiling(6 * 2.0 / 3.0);
    Assert.Equal(4, expectedThreshold);
    
    // Demonstrate attack: 2 miners (1/3) stop producing
    round.RealTimeMinersInformation["miner4"].ActualMiningTimes.Clear();
    round.RealTimeMinersInformation["miner5"].ActualMiningTimes.Clear();
    
    // Count miners who produced blocks
    int activeMiners = round.RealTimeMinersInformation.Values
        .Count(m => m.ActualMiningTimes.Any());
    
    // Attack succeeds: 4 active miners < 5 threshold
    Assert.Equal(4, activeMiners);
    Assert.True(activeMiners < threshold, "Term change blocked by attack");
    
    // With correct threshold, attack would fail
    Assert.True(activeMiners >= expectedThreshold, "Term change should proceed");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L209-210)
```csharp
    /// <summary>
    ///     Change term if two thirds of miners latest ActualMiningTime meets threshold of changing term.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-320)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

```
