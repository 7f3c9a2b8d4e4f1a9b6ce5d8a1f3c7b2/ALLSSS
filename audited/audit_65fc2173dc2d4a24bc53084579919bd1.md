# Audit Report

## Title
Unvalidated Secret Sharing Revelations Allow Consensus State Poisoning via First-Write-Wins Policy

## Summary
The AEDPoS consensus contract accepts `RevealedInValues` from miner-controlled trigger information without cryptographic validation, implementing a first-write-wins policy that allows malicious miners to inject incorrect `PreviousInValue` data for other miners. These poisoned values persist to state and are used to calculate consensus signatures, corrupting randomness generation and round transitions.

## Finding Description

The vulnerability exists in the secret sharing revelation mechanism where a malicious miner can inject arbitrary `PreviousInValue` data for other miners without on-chain validation.

**Attack Flow:**

1. When a miner produces a block with `UpdateValue` behavior, their node provides trigger information containing `RevealedInValues` [1](#0-0) 

2. `UpdateLatestSecretPieces()` processes these revealed values and writes them directly to the Round object if the target miner's `PreviousInValue` is null or empty [2](#0-1) 

3. The modified Round flows into transaction input via `ExtractInformationToUpdateConsensus()`, which extracts all non-null `PreviousInValue` fields into `MinersPreviousInValues` [3](#0-2) 

4. During transaction execution, `PerformSecretSharing()` writes these unvalidated values directly to state [4](#0-3) 

5. When `NextRound` is triggered, `SupplyCurrentRoundInformation()` reads the poisoned `PreviousInValue` from state for miners who didn't mine, and uses it to calculate their signatures [5](#0-4) 

**Root Cause:**

The validation provider only checks the sender's own `PreviousInValue` against their previous `OutValue` [6](#0-5) 

No validation occurs for the `RevealedInValues` that the sender provides for OTHER miners. A malicious miner can inject arbitrary hash values for victim miners who failed to mine in previous rounds.

## Impact Explanation

**Consensus State Corruption:** The attack corrupts the cryptographic integrity of consensus state. Signatures are calculated using XOR operations that combine the malicious `PreviousInValue` with all miners' existing signatures [7](#0-6) 

**Specific Impacts:**
- **Randomness Manipulation**: Incorrect signatures affect consensus randomness generation, potentially influencing block producer selection and other randomness-dependent operations
- **Mining Order Disruption**: Corrupted signature values influence the calculated mining order for subsequent rounds through the XOR-based signature mechanism
- **Persistent State Corruption**: Incorrect values remain in on-chain state until affected miners successfully mine again, potentially spanning multiple rounds
- **Consensus Integrity Violation**: The fundamental security guarantee that consensus state reflects legitimate cryptographic operations is broken

While this doesn't directly result in fund theft, it undermines the security properties of the consensus mechanism itself, which is critical for blockchain operation.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a scheduled miner in the current miner list
- Must control their node software to inject arbitrary `RevealedInValues` in trigger information
- Must produce a block during a round where target miners have failed to mine

**Feasibility:** MEDIUM
- Miners naturally control their own node software and can modify consensus command generation
- The trigger information is generated by the attacker's node and directly accepted by the contract [8](#0-7) 
- The first-write-wins policy at lines 150-151 ensures malicious values persist once written
- Detection is difficult as revealed values appear legitimate without independent secret sharing verification

**Exploitation Window:** The attack targets miners who missed their time slots in previous rounds, which naturally occurs during network issues or node maintenance. A malicious miner producing blocks after such events can inject incorrect recovery values.

## Recommendation

Implement cryptographic verification of revealed in values before accepting them:

1. **Verify Secret Sharing Reconstruction**: Before accepting `RevealedInValues`, verify that each revealed value correctly reconstructs from the available encrypted/decrypted pieces using the Shamir Secret Sharing algorithm. The legitimate `RevealSharedInValues()` function shows the correct reconstruction process [9](#0-8) 

2. **Add Validation in UpdateLatestSecretPieces()**: Before writing to `updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue`, verify that:
   - The revealed value matches what would be computed from legitimate secret sharing reconstruction
   - Sufficient encrypted/decrypted pieces exist to validate the reconstruction
   - The hash relationship to previous OutValue is correct

3. **Extend UpdateValueValidationProvider**: Add validation logic that checks not just the sender's own `PreviousInValue`, but also validates any `MinersPreviousInValues` they provide for other miners against available cryptographic evidence.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system, a full PoC would require:
1. Setting up a test network with multiple miners
2. Simulating a miner missing their time slot
3. Having a malicious miner produce the next block with manipulated `RevealedInValues` in trigger information
4. Observing the corrupted state persisting and being used in signature calculations

The vulnerability path is confirmed through code analysis showing the unvalidated flow from trigger information → UpdateLatestSecretPieces → ExtractInformationToUpdateConsensus → PerformSecretSharing → state persistence → SupplyCurrentRoundInformation usage.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L61-74)
```csharp
    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-47)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L38-52)
```csharp
            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```
