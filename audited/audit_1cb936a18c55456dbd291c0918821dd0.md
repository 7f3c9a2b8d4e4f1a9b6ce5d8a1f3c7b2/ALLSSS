### Title
Governance Migration Deadlock Due to Immutable Cached Parliament Address

### Summary
The NFT contract permanently caches the parliament default organization address in persistent state without providing any mechanism to update it. This prevents governance migration to a new parliament address, creating a critical security gap where the contract cannot adapt to governance changes required for security incidents or planned upgrades.

### Finding Description

The NFT contract declares a `ParliamentDefaultAddress` state variable that stores the parliament's default organization address: [1](#0-0) 

This address is lazily initialized and permanently cached in the `AssertSenderIsParliamentDefaultAddress()` method: [2](#0-1) 

The cached value is used to authorize critical governance operations `AddNFTType` and `RemoveNFTType`: [3](#0-2) [4](#0-3) 

**Root Cause**: Once the `State.ParliamentDefaultAddress.Value` is set, it is never refreshed. The NFT contract has no Initialize method and no mechanism to update this cached address. The protobuf service definition confirms no such update method exists: [5](#0-4) 

**Why This Differs from Other Contracts**: The Election contract demonstrates the secure pattern by fetching the parliament address fresh on each call without persistent caching: [6](#0-5) 

The MultiToken contract similarly retrieves the default parliament controller without persistent state caching: [7](#0-6) 

**Parliament Address Immutability**: The Parliament contract's `DefaultOrganizationAddress` is set once during initialization and never modified: [8](#0-7) [9](#0-8) 

However, in emergency scenarios requiring governance migration, the system needs flexibility to recognize a new parliament organization, which the NFT contract's caching prevents.

### Impact Explanation

**Governance Deadlock**: If parliament governance needs to migrate to a new organization address (due to key compromise, security incident, or governance upgrade), the NFT contract cannot recognize the new parliament. The contract would continue requiring authorization from the old, potentially compromised parliament address.

**Loss of Critical Functionality**: The `AddNFTType` and `RemoveNFTType` operations become permanently locked to the original parliament address. These operations are essential for:
- Adding new NFT type categories as the ecosystem evolves
- Removing deprecated or malicious NFT types
- Maintaining the NFT type registry integrity

**Security Response Inability**: In a security incident where the parliament keys are compromised, the system cannot migrate governance away from the compromised address for NFT type management, leaving this critical functionality under adversary control.

**Severity Justification**: HIGH - This breaks the fundamental governance invariant that authority can be migrated in response to security events. It affects all future NFT type management operations indefinitely.

### Likelihood Explanation

**Reachable Entry Point**: The vulnerability is triggered through the public `AddNFTType` and `RemoveNFTType` methods, which are governance-critical operations.

**Feasible Preconditions**: 
1. NFT contract is deployed and `AddNFTType`/`RemoveNFTType` is called at least once, caching the parliament address
2. Parliament governance needs to migrate (security incident, key rotation, governance upgrade, or emergency response)
3. New parliament organization is established but cannot control NFT type management

**Execution Practicality**: The scenario is realistic because:
- Governance migrations are necessary security operations in long-lived blockchain systems
- Key compromise or rotation events require rapid governance transition
- Planned governance upgrades may require new organization structures
- The Parliament contract even includes emergency response organization functionality, indicating such scenarios are anticipated [10](#0-9) 

**Probability Assessment**: MEDIUM - While not an everyday occurrence, governance migration is a necessary capability for any production blockchain system, particularly for responding to security incidents. The inability to perform this operation represents a critical gap.

### Recommendation

**Option 1 - Add Update Method** (Preferred):
Add a governance-controlled method to update the cached parliament address:

```csharp
public override Empty UpdateParliamentAddress(Empty input)
{
    // Verify caller is either current parliament or genesis contract
    AssertSenderIsParliamentDefaultAddress();
    
    // Clear cache to force refresh
    State.ParliamentDefaultAddress.Value = null;
    
    // Fetch and cache new address
    AssertSenderIsParliamentDefaultAddress();
    
    return new Empty();
}
```

**Option 2 - Remove Caching** (More Robust):
Modify `AssertSenderIsParliamentDefaultAddress()` to fetch the address fresh on each call, matching the pattern used by Election and MultiToken contracts:

```csharp
private void AssertSenderIsParliamentDefaultAddress()
{
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    var currentDefaultAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    Assert(Context.Sender == currentDefaultAddress, "No permission.");
}
```

**Invariant to Enforce**: Parliament address authorization must always reflect the current parliament governance structure, not a stale cached value.

**Test Cases**:
1. Verify parliament address is refreshed after parliament organization changes
2. Test that new parliament can successfully call AddNFTType/RemoveNFTType after migration
3. Verify old parliament loses access after migration
4. Test cross-contract call cost remains acceptable with fresh fetching

### Proof of Concept

**Initial State**:
- Parliament contract initialized with DefaultOrganizationAddress = Address_A (miners' organization)
- NFT contract deployed but `AddNFTType` never called yet
- Parliament governs system through Address_A

**Step 1 - Cache Original Parliament**:
- Transaction: Call `NFTContract.AddNFTType({fullName: "TestType", shortName: "TT"})` from Address_A
- Expected: NFT type added successfully
- Actual: NFT type added, AND `State.ParliamentDefaultAddress.Value` cached as Address_A
- State: NFT contract now permanently stores Address_A

**Step 2 - Governance Migration Attempt**:
- Scenario: Security incident detected, parliament keys potentially compromised
- Parliament creates emergency response organization Address_B through proposal system
- New governance structure established with Address_B as new default organization
- State: Parliament contract may have internal migration logic, but NFT contract still caches Address_A

**Step 3 - Governance Deadlock**:
- Transaction: New parliament (Address_B) calls `NFTContract.AddNFTType({fullName: "NewType", shortName: "NT"})`
- Expected: New parliament can manage NFT types
- Actual: Transaction FAILS with "No permission." error
- Reason: Line 181 of NFTContract_Create.cs checks `Context.Sender == State.ParliamentDefaultAddress.Value` where cached value is still Address_A, but sender is Address_B

**Step 4 - Old Parliament Retains Control**:
- Transaction: Old parliament (Address_A, potentially compromised) calls `NFTContract.AddNFTType({fullName: "MaliciousType", shortName: "MT"})`
- Expected: Old parliament should be rejected after migration
- Actual: Transaction SUCCEEDS because cached address is still Address_A
- Impact: Compromised old parliament can continue controlling NFT type management indefinitely

**Success Condition for Exploit**: Old parliament retains NFT type management control after governance migration, preventing proper security response and creating permanent governance split.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L38-38)
```csharp
    public SingletonState<Address> ParliamentDefaultAddress { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-133)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-154)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** protobuf/nft_contract.proto (L18-101)
```text
service NFTContract {
    option (aelf.csharp_state) = "AElf.Contracts.NFT.NFTContractState";
    option (aelf.base) = "acs1.proto";

    // Create a new nft protocol.
    rpc Create (CreateInput) returns (google.protobuf.StringValue) {
    }
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
    // Mint (Issue) an amount of nft.
    rpc Mint (MintInput) returns (aelf.Hash) {
    }
    // Transfer nft to another address.
    rpc Transfer (TransferInput) returns (google.protobuf.Empty) {
    }
    // Transfer nft from one address to another.
    rpc TransferFrom (TransferFromInput) returns (google.protobuf.Empty) {
    }
    // Approve another address to transfer nft from own account.
    rpc Approve (ApproveInput) returns (google.protobuf.Empty) {
    }
    // De-approve.
    rpc UnApprove (UnApproveInput) returns (google.protobuf.Empty) {
    }
    // Approve or de-approve another address as the operator of all NFTs of a certain protocol.
    rpc ApproveProtocol (ApproveProtocolInput) returns (google.protobuf.Empty) {
    }
    // Destroy nfts.
    rpc Burn (BurnInput) returns (google.protobuf.Empty) {
    }
    // Lock several nfts and fts to mint one nft.
    rpc Assemble (AssembleInput) returns (aelf.Hash) {
    }
    // Disassemble one assembled nft to get locked nfts and fts back.
    rpc Disassemble (DisassembleInput) returns (google.protobuf.Empty) {
    }
    // Modify metadata of one nft.
    rpc Recast (RecastInput) returns (google.protobuf.Empty) {
    }

    rpc AddMinters (AddMintersInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveMinters (RemoveMintersInput) returns (google.protobuf.Empty) {
    }
    
    rpc AddNFTType (AddNFTTypeInput) returns (google.protobuf.Empty) {
    }
    rpc RemoveNFTType (google.protobuf.StringValue) returns (google.protobuf.Empty) {
    }

    rpc GetNFTProtocolInfo (google.protobuf.StringValue) returns (NFTProtocolInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTInfo (GetNFTInfoInput) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTInfoByTokenHash (aelf.Hash) returns (NFTInfo) {
        option (aelf.is_view) = true;
    }
    rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetBalanceByTokenHash (GetBalanceByTokenHashInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowance (GetAllowanceInput) returns (GetAllowanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetAllowanceByTokenHash (GetAllowanceByTokenHashInput) returns (GetAllowanceOutput) {
        option (aelf.is_view) = true;
    }
    rpc GetMinterList (google.protobuf.StringValue) returns (MinterList) {
        option (aelf.is_view) = true;
    }
    rpc CalculateTokenHash (CalculateTokenHashInput) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
    rpc GetNFTTypes (google.protobuf.Empty) returns (NFTTypes) {
        option (aelf.is_view) = true;
    }
    rpc GetOperatorList (GetOperatorListInput) returns (AddressList) {
        option (aelf.is_view) = true;
    }
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L66-73)
```csharp
    private Address GetParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L288-293)
```csharp
        var defaultOrganizationAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = defaultOrganizationAddress
        };
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-36)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L203-210)
```csharp
    public override Empty CreateEmergencyResponseOrganization(Empty input)
    {
        Assert(State.EmergencyResponseOrganizationAddress.Value == null,
            "Emergency Response Organization already exists.");
        AssertSenderAddressWith(State.DefaultOrganizationAddress.Value);
        CreateEmergencyResponseOrganization();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L250-254)
```csharp
    public override Address GetDefaultOrganizationAddress(Empty input)
    {
        Assert(State.Initialized.Value, "Not initialized.");
        return State.DefaultOrganizationAddress.Value;
    }
```
