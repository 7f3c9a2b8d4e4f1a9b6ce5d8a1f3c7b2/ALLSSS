### Title
Past Timestamp Return in ArrangeAbnormalMiningTime Causes Consensus Scheduler Crash

### Summary
The `ArrangeAbnormalMiningTime` function contains a logic error where it checks if `(extraBlockTime + miningInterval - currentBlockTime) > 0` but returns only `extraBlockTime` without the miningInterval offset. This mismatch allows the function to return a timestamp in the past when currentBlockTime falls within the buffer window, ultimately causing the consensus scheduler to crash with an ArgumentOutOfRangeException and preventing block production.

### Finding Description

The vulnerability exists in the `ArrangeAbnormalMiningTime` method where there is a mismatch between the distance calculation and the return value: [1](#0-0) 

The distance is calculated as `(GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)`, but when `distance > 0`, the function returns `GetExtraBlockMiningTime()` without the miningInterval offset. This creates a critical timing window where:

- If `currentBlockTime` is **after** `extraBlockTime` but **before** `extraBlockTime + miningInterval`
- The distance check passes (distance > 0)
- But the returned timestamp is already in the past

This past timestamp propagates through the consensus system: [2](#0-1) 

The past timestamp becomes `ArrangedMiningTime` in the ConsensusCommand, which then flows to ConsensusService: [3](#0-2) 

The code calculates `leftMilliseconds` as a potentially negative Duration but only checks for positive overflow (line 89-91), not negative values. This negative duration is then passed to the scheduler: [4](#0-3) 

Finally, the RxNetScheduler attempts to create an Observable.Timer with a negative TimeSpan: [5](#0-4) 

According to .NET semantics, `Observable.Timer` throws `ArgumentOutOfRangeException` when given a negative TimeSpan, causing the consensus node to crash.

### Impact Explanation

**Operational Impact - High Severity:**

When this bug triggers, the extra block producer's consensus scheduler crashes, completely preventing that node from producing blocks. This constitutes a Denial of Service on the consensus mechanism.

**Who is affected:**
- Extra block producers attempting to terminate rounds
- The entire blockchain network, as round termination is blocked

**Quantified damage:**
- Complete inability to produce blocks until the node is restarted
- Potential chain halt if multiple extra block producers encounter this simultaneously
- Loss of block rewards for affected miners
- Network instability and potential consensus stalls

The severity is high because this directly disrupts the core consensus mechanism's ability to function, violating the "miner schedule integrity" critical invariant.

### Likelihood Explanation

**High Likelihood:**

This is not a deliberate attack but a bug that occurs during normal operation:

**Attacker capabilities:** None required - this happens naturally during consensus operations

**Timing window:** The vulnerable window occurs when an extra block producer checks for a consensus command while `currentBlockTime` is between `extraBlockTime` and `extraBlockTime + miningInterval`. Given that:
- `miningInterval` is typically in the range of seconds (e.g., 4000ms)
- Nodes frequently query consensus commands
- The timing window is a natural part of every round's lifecycle

**Execution practicality:** Extremely practical - this can happen in every round where the extra block producer queries its mining time during the buffer period. No special conditions or attack setup required.

**Detection constraints:** The crash occurs immediately when the condition is met, making it both easily triggered and easily detected through node crashes and missing blocks.

**Probability:** Medium-High - occurs whenever the timing aligns during normal consensus operation, which happens regularly given the continuous nature of block production.

### Recommendation

**Option 1: Fix the return value to match the check logic**
In `ArrangeAbnormalMiningTime`, change line 30 to return the timestamp that includes the miningInterval offset:

```csharp
if (distance > 0) return GetExtraBlockMiningTime().AddMilliseconds(miningInterval);
```

**Option 2: Fix the check logic to match the return value**
Change the distance calculation at line 28 to not include miningInterval:

```csharp
var distance = (GetExtraBlockMiningTime() - currentBlockTime).Milliseconds();
```

**Option 3: Add defensive check in ConsensusService**
Add a negative duration check in `ConsensusService.TriggerConsensusAsync` after line 88:

```csharp
var leftMilliseconds = _consensusCommand.ArrangedMiningTime - TimestampHelper.GetUtcNow();
if (leftMilliseconds.Seconds < 0)
{
    leftMilliseconds = new Duration { Seconds = 0 };  // Schedule immediately
}
leftMilliseconds = leftMilliseconds.Seconds > ConsensusConstants.MaximumLeftMillisecondsForNextBlock
    ? new Duration { Seconds = ConsensusConstants.MaximumLeftMillisecondsForNextBlock }
    : leftMilliseconds;
```

**Recommended approach:** Implement Option 2 as it preserves the original intent (checking if extra block time has passed), plus Option 3 as a defensive safeguard. This provides defense in depth.

**Test cases to add:**
1. Test `ArrangeAbnormalMiningTime` when `currentBlockTime = extraBlockTime + (miningInterval / 2)`
2. Test ConsensusService behavior when ArrangedMiningTime is in the past
3. Integration test verifying scheduler doesn't crash with edge-case timing

### Proof of Concept

**Initial State:**
- Round is configured with miners and extra block producer
- Extra block mining time (`extraBlockTime`) = 10000ms
- Mining interval = 2000ms
- Current block time progresses to 11000ms (past extraBlockTime, within buffer)

**Execution Steps:**

1. Extra block producer calls `GetConsensusCommand` at currentBlockTime = 11000ms

2. `ArrangeAbnormalMiningTime` is invoked:
   - Calculates: `distance = (10000 + 2000) - 11000 = 1000ms > 0`
   - Returns: `10000ms` (in the past by 1000ms)

3. `TerminateRoundCommandStrategy` creates ConsensusCommand with `ArrangedMiningTime = 10000ms`

4. `ConsensusService.TriggerConsensusAsync` processes command:
   - Sets: `leftMilliseconds = 10000 - 11500 = -1500ms` (negative)
   - No negative check, passes through

5. `RxNetScheduler.Subscribe` attempts:
   - `Observable.Timer(TimeSpan.FromMilliseconds(-1500))`
   - **Throws ArgumentOutOfRangeException**

**Expected Result:** 
Consensus command should provide a future timestamp for mining

**Actual Result:** 
Node crashes with exception, consensus scheduler fails, block production halts

**Success Condition:** 
The node crashes and stops producing blocks, demonstrating the DoS condition

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L87-91)
```csharp
        _nextMiningTime = _consensusCommand.ArrangedMiningTime;
        var leftMilliseconds = _consensusCommand.ArrangedMiningTime - TimestampHelper.GetUtcNow();
        leftMilliseconds = leftMilliseconds.Seconds > ConsensusConstants.MaximumLeftMillisecondsForNextBlock
            ? new Duration { Seconds = ConsensusConstants.MaximumLeftMillisecondsForNextBlock }
            : leftMilliseconds;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L107-108)
```csharp
        _consensusScheduler.CancelCurrentEvent();
        _consensusScheduler.NewEvent(leftMilliseconds.Milliseconds(), blockMiningEventData);
```

**File:** src/AElf.Kernel.Consensus.Scheduler.RxNet/RxNetScheduler.cs (L60-61)
```csharp
        return Observable.Timer(TimeSpan.FromMilliseconds(countingMilliseconds))
            .Select(_ => consensusRequestMiningEventData).Subscribe(this);
```
