### Title
Null Reference Exception in Consensus Validation Due to Missing Round Field Validation

### Summary
The `ValidateBeforeExecution` method in the consensus validation flow does not verify that `extraData.Round` is non-null before passing it to recovery methods. If a malicious miner crafts a block with null Round field in the consensus extra data, the validation process crashes with a `NullReferenceException`, causing a denial-of-service condition that prevents nodes from processing the malicious block.

### Finding Description

The vulnerability exists in the consensus validation flow where `extraData.Round` is used without null checking: [1](#0-0) 

When `extraData.Behaviour` is `UpdateValue` or `TinyBlock`, the code calls `RecoverFromUpdateValue` or `RecoverFromTinyBlock` methods, passing `extraData.Round` directly without validating it is non-null.

The `RecoverFromUpdateValue` method immediately attempts to access properties of the `providedRound` parameter: [2](#0-1) 

At line 11, the code accesses `providedRound.RealTimeMinersInformation.ContainsKey(pubkey)`, which throws a `NullReferenceException` if `providedRound` is null. The same issue exists in `RecoverFromTinyBlock`: [3](#0-2) 

The `Round` field in `AElfConsensusHeaderInformation` is defined as an optional protobuf message field: [4](#0-3) 

In Protocol Buffers proto3, message fields are optional and can be null if not set during serialization. The existing validation only checks that the sender's public key matches the block signer: [5](#0-4) 

There is no validation that the `Round` field is populated before the extra data is passed to `ValidateConsensusBeforeExecution`: [6](#0-5) 

### Impact Explanation

**Operational Impact - Denial of Service:**
- When a node attempts to validate a block with null Round field, the consensus validation crashes with an unhandled `NullReferenceException`
- The affected node cannot process this block and subsequent blocks, effectively halting its participation in the network
- If multiple nodes encounter the same malicious block, network consensus is disrupted
- The blockchain cannot progress past the malicious block until nodes are manually recovered or the block is excluded

**Affected Parties:**
- All nodes attempting to validate the malicious block
- The entire network if the malicious block is broadcast widely
- Users experiencing transaction delays due to network disruption

**Severity Justification:**
Medium severity because while it causes significant operational disruption (DoS), it requires the attacker to be an authorized miner with valid signing credentials. The attack is easily detectable (nodes crash with visible exception traces) and can be mitigated by excluding the malicious block and potentially removing the malicious miner.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized miner in the current miner list
- Must possess valid private keys to sign blocks
- Must be able to craft custom block headers with malformed consensus data

**Attack Complexity:**
- Low technical complexity once attacker has miner credentials
- Attacker can intentionally create `AElfConsensusHeaderInformation` with null Round field
- Block passes initial signature verification since it's signed by a valid miner
- Block passes sender pubkey validation in the extractor

**Feasibility Conditions:**
- Attacker has compromised a miner's credentials OR is a malicious miner
- In Byzantine Fault Tolerant (BFT) consensus systems, some fraction of malicious miners is expected
- However, this specific attack is not accidental - normal consensus flow always populates Round field

**Detection/Operational Constraints:**
- Easily detected: nodes crash with clear `NullReferenceException` stack traces
- Network operators can identify and exclude the malicious block
- Malicious miner can be identified from block signature and removed from miner list

**Probability Assessment:**
Medium-to-Low probability because it requires miner credentials, but once compromised, the attack is trivial to execute. The defensive assumption in BFT systems is that some miners may act maliciously, so the system should handle this gracefully rather than crashing.

### Recommendation

**Immediate Fix:**
Add null validation for `extraData.Round` before calling recovery methods in `ValidateBeforeExecution`:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    if (extraData.Round == null)
        return new ValidationResult { Success = false, Message = "Round information is required for UpdateValue behaviour." };
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}

if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    if (extraData.Round == null)
        return new ValidationResult { Success = false, Message = "Round information is required for TinyBlock behaviour." };
    baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

**Additional Validation in Extractor:**
Consider adding validation in `AEDPoSExtraDataExtractor.ExtractConsensusExtraData` to reject blocks with null Round when behaviour requires it:

```csharp
if ((headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue || 
     headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock) && 
    headerInformation.Round == null)
    return null;
```

**Test Cases:**
Add unit tests that verify proper handling of null Round:
1. Test `ValidateBeforeExecution` with `extraData.Round = null` and `Behaviour = UpdateValue`
2. Test `ValidateBeforeExecution` with `extraData.Round = null` and `Behaviour = TinyBlock`
3. Verify validation returns graceful failure instead of throwing exception
4. Test that properly formed blocks continue to validate successfully

### Proof of Concept

**Required Initial State:**
- Attacker has access to valid miner private keys
- Attacker is in the current miner list
- Network is operational with normal consensus

**Attack Steps:**
1. Attacker creates a new block with valid header and signature
2. Attacker crafts `AElfConsensusHeaderInformation` with:
   - `SenderPubkey` set to attacker's valid miner public key
   - `Behaviour` set to `AElfConsensusBehaviour.UpdateValue`
   - `Round` field left unset (null in protobuf)
3. Attacker serializes this malformed consensus data and includes it in block's extra data
4. Attacker signs the block with their miner private key
5. Attacker broadcasts the block to the network

**Expected vs Actual Result:**
- **Expected:** Validation should gracefully reject the block with an appropriate error message
- **Actual:** Node crashes with `NullReferenceException` when accessing `providedRound.RealTimeMinersInformation` at line 11 of `RecoverFromUpdateValue`

**Success Condition:**
The attack succeeds when target nodes crash during validation and fail to process subsequent blocks, requiring manual intervention to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-12)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-39)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** protobuf/aedpos_contract.proto (L303-310)
```text
message AElfConsensusHeaderInformation {
    // The sender public key.
    bytes sender_pubkey = 1;
    // The round information.
    Round round = 2;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 3;
}
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```
