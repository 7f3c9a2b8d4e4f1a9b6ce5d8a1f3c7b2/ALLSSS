### Title
Missing Validation of Term Transition State Allows Arbitrary Miner List Manipulation

### Summary
`ProcessNextTerm` converts `NextTermInput` to a `Round` object via `ToRound()` but fails to validate that the resulting miner information matches the expected state from `GenerateFirstRoundOfNextTerm`. A malicious block producer can submit modified consensus extra data with arbitrary miner lists, mining orders, and time slots, which will be committed to state without verification, completely compromising consensus integrity.

### Finding Description

The vulnerability exists in the term transition logic of the AEDPoS consensus contract. When transitioning to a new consensus term:

1. **Round Generation**: The legitimate flow calls `GenerateFirstRoundOfNextTerm` to create the next term's `Round` object with miner information derived from election victories or the current miner list. [1](#0-0) 

2. **Conversion Without Validation**: In `ProcessNextTerm`, the code simply converts `NextTermInput` to `Round` via `ToRound()` without any validation: [2](#0-1) 

3. **Insufficient Validation**: The only validations performed are basic term and round number increments: [3](#0-2) 

4. **Direct State Commitment**: The unvalidated `nextRound.RealTimeMinersInformation` is used to create and commit the miner list: [4](#0-3) 

5. **Header Validation Gap**: The pre-execution validation only checks round/term number increments and null InValues, not the actual miner information content: [5](#0-4) 

6. **No Cryptographic Binding**: While the extractor validates that `SenderPubkey` matches the block signer, this doesn't prevent the signer from modifying the Round data: [6](#0-5) 

**Root Cause**: There is no comparison between the submitted `nextRound.RealTimeMinersInformation` and what `GenerateFirstRoundOfNextTerm` would produce. The `ToRound()` method is a simple data structure conversion with no validation logic: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Compromise (CRITICAL)**:
- A malicious block producer can arbitrarily modify the miner list for the next term, adding unauthorized miners or removing legitimate ones
- Can manipulate mining orders and time slots to favor specific miners or create unfair advantages
- On mainchain deployments, completely bypasses the election system by ignoring victory results from the Election contract

**Concrete Harm**:
- **Miner List Manipulation**: Attacker can set `RealTimeMinersInformation` to include their own colluding nodes while excluding legitimate elected miners
- **Schedule Manipulation**: Can assign impossible `ExpectedMiningTime` values to competitors or favorable time slots to themselves
- **Consensus Disruption**: Incorrect miner information causes consensus failures, block production issues, and potential chain halts
- **Election Bypass**: The legitimate miner selection from `TryToGetVictories` can be completely ignored: [8](#0-7) 

**Affected Parties**: All network participants, as consensus safety is the foundation of the entire blockchain system.

**Severity Justification**: HIGH - This breaks a critical consensus invariant (miner schedule integrity) and allows unauthorized control over block production rights, which is a fundamental security property.

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be a current block producer (in the active miner list)
- Must produce the NextTerm block (occurs once per term, approximately every few days/weeks depending on configuration)

**Attack Complexity**: LOW
1. Call `GetConsensusExtraData` with `NextTerm` behavior to generate legitimate consensus data
2. Parse the `AElfConsensusHeaderInformation` and modify the `Round.RealTimeMinersInformation` fields
3. Create `NextTermInput` from the modified `Round` object using `NextTermInput.Create`: [9](#0-8) 
4. Generate and sign the transaction calling `NextTerm` with malicious input: [10](#0-9) 
5. Include in block - validation passes because only numbers are checked: [11](#0-10) 

**Feasibility Conditions**:
- Attacker controls at least one miner position in current term
- Has opportunity to produce the term transition block
- No special privileges beyond normal miner rights required

**Detection**: Difficult - the modified miner list appears legitimate in the committed state, and there's no on-chain record of what the "correct" list should have been

**Probability**: MEDIUM-HIGH - Any compromised or malicious miner can execute this during their term transition opportunity

### Recommendation

**Code-Level Mitigation**:

Add validation in `ProcessNextTerm` to regenerate and compare the expected Round:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL FIX: Validate against expected state
    var expectedRound = GenerateFirstRoundOfNextTerm(
        Context.RecoverPublicKey().ToHex(), 
        State.MiningInterval.Value
    );
    
    // Validate miner list matches
    Assert(nextRound.RealTimeMinersInformation.Keys.Count == 
           expectedRound.RealTimeMinersInformation.Keys.Count,
           "Miner count mismatch");
    
    foreach (var expectedMiner in expectedRound.RealTimeMinersInformation)
    {
        Assert(nextRound.RealTimeMinersInformation.ContainsKey(expectedMiner.Key),
               $"Missing expected miner: {expectedMiner.Key}");
        
        var submittedMiner = nextRound.RealTimeMinersInformation[expectedMiner.Key];
        var expectedMinerInfo = expectedMiner.Value;
        
        // Validate critical fields
        Assert(submittedMiner.Order == expectedMinerInfo.Order,
               "Mining order mismatch");
        Assert(submittedMiner.ExpectedMiningTime == expectedMinerInfo.ExpectedMiningTime,
               "Mining time mismatch");
        Assert(submittedMiner.IsExtraBlockProducer == expectedMinerInfo.IsExtraBlockProducer,
               "Extra block producer mismatch");
    }
    
    // Continue with existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ... rest of function
}
```

**Alternative Approach**: Store a hash of the expected Round in a previous block and validate against it during ProcessNextTerm.

**Invariant Checks**:
- Miner public keys must match election victories (on mainchain) or current miner list (on sidechains)
- Mining orders must follow the deterministic sorting algorithm: [12](#0-11) 
- Expected mining times must follow the correct interval-based calculation: [13](#0-12) 

**Test Cases**:
1. Test that ProcessNextTerm rejects input with modified miner public keys
2. Test that ProcessNextTerm rejects input with altered mining orders
3. Test that ProcessNextTerm rejects input with manipulated time slots
4. Test that legitimate NextTermInput (from GetConsensusExtraData) is accepted

### Proof of Concept

**Initial State**:
- Network running with current term miners: [MinerA, MinerB, MinerC]
- MinerA is scheduled to produce the NextTerm block
- Election contract has victories: [MinerB, MinerC, MinerD] for next term

**Attack Steps**:

1. **MinerA (attacker) generates legitimate consensus data**:
   - Calls `GetConsensusExtraData` with NextTerm trigger
   - Receives `AElfConsensusHeaderInformation` with Round containing [MinerB, MinerC, MinerD]

2. **MinerA modifies the Round data**:
   - Replaces MinerD's pubkey with MinerA's own pubkey
   - Or adds MinerA as an additional miner
   - Or changes mining orders to favor MinerA

3. **MinerA creates malicious transaction**:
   - Calls `NextTermInput.Create(modifiedRound, randomNumber)`
   - Generates transaction to `NextTerm(maliciousInput)`

4. **Block validation**:
   - `ValidateConsensusBeforeExecution` is called
   - `RoundTerminateValidationProvider` checks: term number = current + 1 ✓, round number = current + 1 ✓, InValues = null ✓
   - Validation PASSES (only checks numbers, not miner content)

5. **Transaction execution**:
   - `ProcessNextTerm` converts input via `ToRound()`
   - Checks `TryToUpdateTermNumber` - PASSES (term incremented correctly)
   - Checks `TryToUpdateRoundNumber` - PASSES (round incremented correctly)
   - Calls `SetMinerList` with malicious miner list - COMMITS TO STATE
   - Calls `AddRoundInformation` with malicious round - COMMITS TO STATE

**Expected Result**: MinerA should be rejected/removed from next term (not in election victories)

**Actual Result**: MinerA successfully added to next term miner list, bypassing election results

**Success Condition**: Query `GetMinerList` for the new term returns the attacker-controlled list instead of the legitimate election victories

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-163)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L173-174)
```csharp
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-196)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-33)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L32-33)
```csharp
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```
