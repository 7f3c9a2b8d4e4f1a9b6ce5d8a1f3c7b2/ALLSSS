# Audit Report

## Title
Hash Collision in NFT Token Identification Causes Cross-Protocol Balance and State Corruption

## Summary
The `CalculateTokenHash` function concatenates NFT symbol and tokenId without a delimiter, creating hash collisions when protocol symbol lengths transition from N to N+1 digits. This allows different NFTs from different protocols to share the same tokenHash, corrupting balances, metadata, allowances, and assembly data across the protocol.

## Finding Description

The root vulnerability lies in the `CalculateTokenHash` function which computes NFT identifiers through direct string concatenation without any delimiter: [1](#0-0) 

NFT protocol symbols follow the format `{2-letter-code}{N-digit-number}`. The 2-letter codes are mapped in `InitialNFTTypeNameMap` (AR, MU, VW, etc.) and the random number portion has a dynamically growing length: [2](#0-1) 

The number length starts at 9 digits and increases as more protocols are created: [3](#0-2) 

The length growth mechanism in `GetCurrentNumberLength` triggers when protocol count exceeds capacity: [4](#0-3) 

**Collision Scenario:**
- Early protocol: "AR123456789" (2 letters + 9 digits)
- Later protocol: "AR1234567891" (2 letters + 10 digits)
- Concatenation "AR123456789" + "123" = "AR123456789123"
- Concatenation "AR1234567891" + "23" = "AR123456789123"
- **Both produce identical strings before hashing → same tokenHash**

This colliding tokenHash corrupts all state mappings that use it as a key: [5](#0-4) 

Critical operations use this flawed hash calculation including `Transfer`, `Burn`, `Approve`, and `GetBalance`: [6](#0-5)  and [7](#0-6) 

The `PerformMint` function only validates tokenId uniqueness within a protocol, not tokenHash uniqueness across protocols: [8](#0-7) 

Minters can specify arbitrary tokenIds when minting: [9](#0-8) 

## Impact Explanation

**Critical State Corruption:**

1. **Balance Mixing**: `BalanceMap[tokenHash][owner]` combines balances from NFTs of different protocols. A user querying balance of ("AR123456789", 123) receives an incorrect total that includes the balance from ("AR1234567891", 23).

2. **NFT Metadata Overwrite**: When the second colliding NFT is minted, it overwrites the first NFT's metadata in `NftInfoMap[tokenHash]`: [10](#0-9) 

3. **Allowance Confusion**: `AllowanceMap[tokenHash][owner][spender]` shares approval state between different NFTs, allowing unintended transfers.

4. **Assembly Data Corruption**: `AssembledNftsMap` and `AssembledFtsMap` store incorrect component data, breaking disassembly operations.

**Fund Impact**: Users lose access to NFTs or receive incorrect balances. Transfers and burns may affect the wrong NFTs. Protocol supply counters become inaccurate. Assembled NFTs cannot be properly disassembled, potentially locking funds.

**Affected Parties**: All users holding NFTs from protocols created after symbol length transitions occur. Multi-protocol NFT applications that rely on accurate balance queries and transfers.

## Likelihood Explanation

**Attacker Capabilities:**
- Protocol creation is open to any user on mainchain
- Minters can specify custom tokenIds when minting NFTs
- No special permissions or governance approval required

**Attack Complexity**: Low
1. Monitor or wait for protocol count to reach transition threshold (9→10 digits)
2. Identify an existing protocol with N-digit number (e.g., "AR123456789")
3. Create protocols until obtaining an N+1-digit number that overlaps (e.g., "AR1234567891")
4. Calculate the required tokenId to create collision using simple arithmetic
5. Mint NFT with the calculated tokenId (e.g., tokenId 23 to collide with tokenId 123)

**Feasibility**: HIGH
- Occurs naturally as the ecosystem scales and protocol count grows
- Initial protocols use 9-digit numbers (100,000,000 - 999,999,999)
- Transition to 10-digit numbers happens after sufficient protocol creation
- Collision opportunities exist at every length transition boundary
- Attack requires only being a minter, which protocol creators can grant

**Detection**: Difficult - Appears as legitimate protocol creation and NFT minting. Balance queries return values without error, but the values are incorrect, making the issue hard to detect until users notice discrepancies.

## Recommendation

Add a delimiter between symbol and tokenId when calculating the hash:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

Alternatively, use a structured hash computation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

Additionally, implement a global tokenHash uniqueness check in `PerformMint`:

```csharp
var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
Assert(State.NftInfoMap[tokenHash] == null || 
       State.NftInfoMap[tokenHash].Symbol == input.Symbol,
       "TokenHash collision detected with different protocol");
```

## Proof of Concept

```csharp
// Test demonstrating hash collision
[Fact]
public void HashCollision_DifferentNFTs_SameTokenHash()
{
    // Setup: Create first protocol with 9-digit number
    var protocol1Symbol = "AR123456789"; // 2-letter + 9-digit
    var tokenId1 = 123L;
    
    // Setup: Create second protocol with 10-digit number
    var protocol2Symbol = "AR1234567891"; // 2-letter + 10-digit  
    var tokenId2 = 23L;
    
    // Calculate hashes using the vulnerable concatenation
    var hash1 = HashHelper.ComputeFrom($"{protocol1Symbol}{tokenId1}"); 
    // "AR123456789" + "123" = "AR123456789123"
    
    var hash2 = HashHelper.ComputeFrom($"{protocol2Symbol}{tokenId2}");
    // "AR1234567891" + "23" = "AR123456789123"
    
    // Verify collision
    Assert.Equal(hash1, hash2); // COLLISION: Same hash for different NFTs
    
    // This means both NFTs will share:
    // - BalanceMap[hash][owner] - mixed balances
    // - NftInfoMap[hash] - overwritten metadata
    // - AllowanceMap[hash][owner][spender] - confused approvals
    // - AssembledNftsMap[hash] - corrupted assembly data
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-24)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-393)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-439)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-33)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L32-35)
```csharp
    public override GetBalanceOutput GetBalance(GetBalanceInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var balance = State.BalanceMap[tokenHash][input.Owner];
```
