### Title
Race Condition Allows Unauthorized SEED-0 Collection Creation Leading to Token Creation Monopoly

### Summary
The `GetSymbolType()` function lacks fail-safe checks for reserved symbols like "SEED-0", relying entirely on upstream validation. However, the upstream `CreateToken()` method explicitly exempts "SEED-0" from seed NFT requirements, and SEED-0 is not created at genesis. This creates a race condition where any user can claim ownership of SEED-0 before governance, gaining monopoly control over all token creation on the chain.

### Finding Description

The vulnerability exists across multiple locations:

**1. Missing fail-safe in GetSymbolType()** [1](#0-0) 

`GetSymbolType()` only validates symbol format (alphanumeric base, numeric NFT ID) but does not check for reserved keywords like "SEED-0". It assumes upstream validation will handle reserved symbols.

**2. Explicit exemption for SEED-0 creation** [2](#0-1) 

The `CreateToken()` method contains logic that explicitly allows creation of `TokenContractConstants.SeedCollectionSymbol` ("SEED-0") without requiring a seed NFT, even for non-whitelisted users.

**3. SEED-0 not created at genesis** [3](#0-2) 

The Economic Contract's initialization only creates native, resource, and election tokens. SEED-0 is not created during genesis, leaving a window for unauthorized creation.

**4. Owner-only SEED NFT creation** [4](#0-3) 

Only the owner of SEED-0 collection can create individual SEED NFTs (SEED-1, SEED-2, etc.), which are required for all token creation.

**Execution Path:**
1. Chain deploys at genesis without SEED-0
2. Attacker calls `Create(CreateInput{Symbol="SEED-0",...})`
3. `GetSymbolType("SEED-0")` returns `SymbolType.NftCollection` without checking if reserved
4. `CreateNFTCollection` â†’ `CreateToken` is called
5. Line 57 condition `input.Symbol != TokenContractConstants.SeedCollectionSymbol` is false, skipping seed NFT check
6. Attacker becomes owner of SEED-0
7. Governance/legitimate users cannot create SEED-0 (duplicate check prevents it)
8. Only attacker can create SEED NFTs required for token creation

### Impact Explanation

**Operational DoS + Authorization Bypass:**
- Complete denial-of-service of the token creation system
- Attacker gains monopoly control over which tokens can be created on the chain
- Legitimate token projects cannot create tokens without attacker permission
- Governance cannot create SEED NFTs for the ecosystem
- Entire chain's token economy is compromised

**Affected Parties:**
- All users attempting to create new tokens
- Governance organizations
- Token-dependent contracts and applications
- Chain's economic functionality

**Severity:** Critical - The token creation system is a fundamental chain operation. Monopoly control over it breaks the permissionless nature of the blockchain and allows extortion/censorship.

### Likelihood Explanation

**Attack Feasibility: HIGH**

**Reachability:** The `Create()` method is publicly accessible without special permissions: [5](#0-4) 

**Preconditions:** Only requires that:
- Chain has been deployed but SEED-0 not yet created by governance
- Attacker monitors mempool or chain deployment to front-run governance

**Attack Complexity:** Trivial - single transaction:
```
TokenContract.Create({
  Symbol: "SEED-0",
  Decimals: 0,
  TotalSupply: 1,
  IsBurnable: true,
  TokenName: "Malicious SEED Collection",
  Issuer: AttackerAddress,
  Owner: AttackerAddress
})
```

**Economic Cost:** Minimal (only transaction gas fees)

**Detection:** Difficult to prevent after the fact. Once SEED-0 is created, the duplicate check prevents recreation: [6](#0-5) 

**Probability:** High during chain deployment phase if SEED-0 creation is not part of genesis or immediate post-genesis governance actions.

### Recommendation

**1. Add Reserved Symbol Validation in GetSymbolType()**

Add fail-safe check for reserved symbols:
```csharp
private SymbolType GetSymbolType(string symbol)
{
    var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
    Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
    
    // NEW: Fail-safe for reserved symbols
    Assert(symbol != TokenContractConstants.SeedCollectionSymbol || 
           IsAddressInCreateWhiteList(Context.Sender),
           "Reserved symbol can only be created by authorized addresses.");
    
    if (words.Length == 1) return SymbolType.Token;
    Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
    return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
}
```

**2. Create SEED-0 at Genesis**

Modify the TokenContractInitializationProvider or EconomicContract initialization to create SEED-0 with governance ownership during genesis: [7](#0-6) 

**3. Restrict SEED-0 Creation to Governance**

Remove the blanket exemption for SEED-0 and require whitelist:
```csharp
if (!IsAddressInCreateWhiteList(Context.Sender))
{
    var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
    CheckSeedNFT(symbolSeed, input.Symbol);
    // ... rest of seed burning logic
}
```

**4. Add Test Cases**

- Test that non-whitelisted users cannot create SEED-0
- Test that SEED-0 exists after genesis
- Test that attempting to create SEED-0 twice fails appropriately

### Proof of Concept

**Initial State:**
- Fresh AElf chain deployed
- Token contract initialized via genesis
- SEED-0 does not exist yet
- Attacker has address A with sufficient gas

**Attack Steps:**

**Step 1:** Attacker monitors chain deployment and submits transaction immediately after genesis:
```
Transaction {
  To: TokenContractAddress,
  Method: "Create",
  Params: CreateInput {
    Symbol: "SEED-0",
    TokenName: "Attacker SEED Collection",
    Decimals: 0,
    TotalSupply: 1,
    IsBurnable: true,
    Issuer: AddressA,
    Owner: AddressA,
    ExternalInfo: {}
  }
}
```

**Expected Result:** Transaction should fail with "Reserved symbol" error

**Actual Result:** Transaction succeeds, SEED-0 created with Attacker as owner

**Step 2:** Governance attempts to create SEED-0:
```
// Via Parliament proposal
Transaction {
  To: TokenContractAddress,
  Method: "Create",
  Params: CreateInput {
    Symbol: "SEED-0",
    TokenName: "Official SEED Collection",
    Issuer: GovernanceAddress,
    Owner: GovernanceAddress,
    ...
  }
}
```

**Result:** Transaction fails with "Token already exists" error

**Step 3:** Legitimate user attempts to create a token "ABC":
```
Transaction {
  To: TokenContractAddress,
  Method: "Create",
  Params: CreateInput {
    Symbol: "ABC",
    ...
  }
}
```

**Result:** Transaction fails - requires SEED NFT which can only be created by attacker (owner of SEED-0)

**Exploitation Success Condition:** Attacker owns SEED-0, governance cannot reclaim it, all token creation requires attacker permission.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L106-136)
```csharp
    private void CreateElectionTokens()
    {
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
        foreach (var symbol in new List<string>
                     { EconomicContractConstants.ElectionTokenSymbol, EconomicContractConstants.ShareTokenSymbol })
        {
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = symbol,
                TokenName = $"{symbol} Token",
                TotalSupply = EconomicContractConstants.ElectionTokenTotalSupply,
                Decimals = EconomicContractConstants.ElectionTokenDecimals,
                Issuer = Context.Self,
                IsBurnable = true,
                LockWhiteList = { lockWhiteList },
                Owner = Context.Self
            });
            State.TokenContract.Issue.Send(new IssueInput
            {
                Symbol = symbol,
                Amount = EconomicContractConstants.ElectionTokenTotalSupply,
                To = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
                Memo = "Issue all election tokens to Election Contract."
            });
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L35-36)
```csharp
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L24-129)
```csharp
    public virtual List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var methodList = new List<ContractInitializationMethodCall>();
        var initializationData = _tokenContractInitializationDataProvider.GetContractInitializationData();

        // For the main chain, we use the economic contract to initialize the token contract.
        // So no initialization methods are required in here.
        // But for the side chain, which has no economic contract, we need initialize token contract.
        if (initializationData != null)
        {
            var nativeTokenInfo = TokenInfo.Parser.ParseFrom(initializationData.NativeTokenInfoData);
            var resourceTokenList =
                TokenInfoList.Parser.ParseFrom(initializationData.ResourceTokenListData);

            // native token
            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                Params = GenerateTokenCreateInput(nativeTokenInfo).ToByteString()
            });

            // resource token
            foreach (var resourceTokenInfo in resourceTokenList.Value)
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(resourceTokenInfo).ToByteString()
                });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitialCoefficients),
                Params = new Empty().ToByteString()
            });

            if (initializationData.PrimaryTokenInfoData != null)
            {
                // primary token
                var chainPrimaryTokenInfo =
                    TokenInfo.Parser.ParseFrom(initializationData.PrimaryTokenInfoData);

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.Create),
                    Params = GenerateTokenCreateInput(chainPrimaryTokenInfo, initializationData.Creator)
                        .ToByteString()
                });

                foreach (var issueStuff in initializationData.TokenInitialIssueList)
                    methodList.Add(new ContractInitializationMethodCall
                    {
                        MethodName = nameof(TokenContractContainer.TokenContractStub.Issue),
                        Params = new IssueInput
                        {
                            Symbol = chainPrimaryTokenInfo.Symbol,
                            Amount = issueStuff.Amount,
                            Memo = "Initial issue",
                            To = issueStuff.Address
                        }.ToByteString()
                    });

                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
            }
            else
            {
                // set primary token with native token 
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = nativeTokenInfo.Symbol
                    }.ToByteString()
                });
            }

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeFromParentChain),
                Params = new InitializeFromParentChainInput
                {
                    ResourceAmount = { initializationData.ResourceAmount },
                    RegisteredOtherTokenContractAddresses =
                    {
                        initializationData.RegisteredOtherTokenContractAddresses
                    },
                    Creator = initializationData.Creator
                }.ToByteString()
            });

            methodList.Add(new ContractInitializationMethodCall
            {
                MethodName = nameof(TokenContractContainer.TokenContractStub.InitializeAuthorizedController),
                Params = ByteString.Empty
            });
        }

        return methodList;
    }
```
