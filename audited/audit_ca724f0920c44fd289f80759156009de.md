### Title
Infinite Loop in NFT Symbol Generation Causes Guaranteed Transaction Failure on Collision

### Summary
The `GenerateSymbolNumber()` function contains a critical flaw where the `randomHash` is computed once before a do-while loop but never updated within the loop. Since `Context.ConvertHashToInt64()` is deterministic, any collision with an existing entry in `State.IsCreatedMap` will cause an infinite loop that exhausts transaction gas, resulting in guaranteed transaction failure. This vulnerability worsens as the protocol scales, and can be weaponized by attackers to increase collision probability and deny NFT creation services to legitimate users.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function. [1](#0-0) 

The root cause is that `randomHash` is computed once before the do-while loop (lines 71-77) by hashing the sender address and random bytes from the consensus contract. Inside the loop (lines 79-82), this same `randomHash` is used to generate a random number via `Context.ConvertHashToInt64()`. 

Since `Context.ConvertHashToInt64()` is a deterministic function that always returns the same output for the same input hash and range, the loop will **always generate the exact same `randomNumber`** on every iteration. If that number already exists in `State.IsCreatedMap`, the while condition `State.IsCreatedMap[randomNumber]` will always evaluate to `true`, creating an infinite loop.

The function is called during NFT protocol creation. [2](#0-1) 

This is invoked from the public `Create()` method. [3](#0-2) 

No existing protections prevent this issue - there is no rehashing mechanism, no fallback strategy, and no iteration limit on the loop.

### Impact Explanation

**Operational Impact - Critical DoS of NFT Creation:**

1. **Immediate Transaction Failure**: When a collision occurs (randomly generated number already exists in `State.IsCreatedMap`), the user's transaction enters an infinite loop, exhausts its gas limit, and fails completely. The user loses the transaction fee but receives no NFT protocol.

2. **Increasing Probability**: With 9-digit numbers initially [4](#0-3) , there are 900 million possible values (10^8 to 10^9). As `State.IsCreatedMap` fills with created protocols [5](#0-4) , collision probability increases:
   - At 1% saturation (9M protocols): ~1% chance of transaction failure
   - At 10% saturation: ~10% chance of transaction failure
   - At 50% saturation: ~50% chance of transaction failure

3. **Affected Users**: All users attempting to create NFT protocols on the mainchain are vulnerable. Unlike typical DoS attacks that affect availability temporarily, this creates permanent transaction failures for unlucky users.

4. **No Recovery**: Once a user's random generation hits a collision, there is no retry mechanism - the transaction simply fails and they must submit a new transaction (hoping for better randomness), paying gas fees each time.

### Likelihood Explanation

**High Likelihood - Practical Attack Vector:**

1. **Attacker Capabilities**: Any user can call the public `Create()` method to create NFT protocols. An attacker can systematically create many protocols to fill `State.IsCreatedMap`, increasing global collision probability for all subsequent users.

2. **Attack Complexity**: Low. The attacker simply needs to:
   - Call `Create()` repeatedly with different parameters
   - Each successful creation adds one entry to `State.IsCreatedMap`
   - No special privileges or complex transaction sequences required

3. **Economic Feasibility**: While creating millions of protocols requires significant transaction fees, an attacker could:
   - Target specific saturation thresholds (e.g., 10-20% of namespace) to create meaningful disruption
   - The attack is persistent - once protocols are created, they remain in `State.IsCreatedMap` forever
   - Cost is amortized over time as all future users face increased failure rates

4. **Natural Occurrence**: Even without malicious intent, as the protocol grows organically, collision probability naturally increases, making this a time-bomb vulnerability that will eventually impact legitimate users.

5. **Detection/Prevention**: There are no rate limits, monitoring, or preventive measures in the contract to detect or mitigate namespace exhaustion.

### Recommendation

**Fix the Infinite Loop by Regenerating Randomness:**

Modify `GenerateSymbolNumber()` to regenerate a new random hash on each iteration:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    var maxAttempts = 100; // Add safety limit
    var attempts = 0;
    
    do
    {
        attempts++;
        Assert(attempts <= maxAttempts, "Failed to generate unique symbol number after maximum attempts");
        
        // Regenerate randomness on each iteration using attempt counter
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attempts) // Add attempt counter for uniqueness
        );
        
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Additional Mitigations:**

1. **Add iteration limit** to prevent excessive gas consumption and provide clear error messaging
2. **Monitor namespace saturation** and trigger automatic length increases before collision probability becomes significant
3. **Consider alternative generation strategies** such as sequential counters with random prefixes
4. **Add test cases** that verify collision handling with pre-populated `IsCreatedMap`

### Proof of Concept

**Initial State:**
- `State.IsCreatedMap` contains entry for number `123456789` (marked as `true`)
- Current symbol number length is 9 digits
- Range is 100,000,000 to 1,000,000,000

**Attack Sequence:**

1. Attacker creates multiple NFT protocols to populate `State.IsCreatedMap` with specific values, including `123456789`

2. Victim calls `Create()` with valid input:
   ```
   CreateInput { NftType = "VirtualWorlds", ... }
   ```

3. Execution flow:
   - `Create()` calls `GetSymbol("VirtualWorlds")` 
   - `GetSymbol()` calls `GenerateSymbolNumber()`
   - `GenerateSymbolNumber()` computes `randomHash` once from victim's address and consensus randomness
   - **Critical**: `Context.ConvertHashToInt64(randomHash, 100000000, 1000000000)` happens to return `123456789`
   - Loop condition checks: `State.IsCreatedMap[123456789]` returns `true` (collision detected)
   - Loop iterates again with **same** `randomHash`
   - `Context.ConvertHashToInt64(randomHash, 100000000, 1000000000)` returns `123456789` again (deterministic)
   - Loop continues indefinitely...

**Expected vs Actual Result:**
- **Expected**: Function should generate a different random number on retry or fail gracefully with error message
- **Actual**: Transaction runs until gas limit is exhausted, then reverts. Victim loses transaction fee, no NFT protocol is created.

**Success Condition for Attack:**
Victim's transaction fails with "Out of Gas" error despite having valid inputs and sufficient initial gas, demonstrating the DoS condition.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L10-10)
```csharp
    public MappedState<long, bool> IsCreatedMap { get; set; }
```
