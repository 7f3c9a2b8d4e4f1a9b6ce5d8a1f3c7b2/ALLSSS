### Title
Unbounded Array Iteration in GetVotingRecords Enables Resource Exhaustion DoS

### Summary
The `GetVotingRecords` view method lacks array size validation on the `input.Ids` parameter, allowing an attacker to supply up to ~150,000 Hash values (limited only by the 5MB transaction size). Each element triggers a state read operation, causing excessive I/O and memory consumption that can exhaust node resources and disrupt RPC service availability.

### Finding Description

The vulnerability exists in the `GetVotingRecords` method where an unbounded `Select` operation processes the entire `input.Ids` array without validation: [1](#0-0) 

The `GetVotingRecordsInput` message definition allows an unbounded repeated field with no size constraints: [2](#0-1) 

This is a public view method accessible via RPC: [3](#0-2) 

**Root Cause**: The method performs `input.Ids.Select(id => State.VotingRecords[id])` without checking `input.Ids.Count`, allowing an attacker to force arbitrary numbers of state read operations.

**Why Existing Protections Fail**:

1. **Transaction Size Limit Insufficient**: The 5MB transaction size limit still permits approximately 150,000+ Hash values (32 bytes each), as defined in: [4](#0-3) 

2. **ExecutionObserver Doesn't Count State Reads**: The ExecutionObserver with default thresholds of 15,000 only counts method calls at boundaries: [5](#0-4) [6](#0-5) 

LINQ `Select` operations and mapped state property access (`State.VotingRecords[id]`) do not trigger `CallCount()` increments, as the observer is only injected at contract method boundaries, not framework code or property accessors.

3. **No Array Size Validation**: Unlike other contracts that implement explicit array size limits, `GetVotingRecords` lacks any assertion on input size. Compare with the MultiToken contract's best practice: [7](#0-6) [8](#0-7) 

**Execution Path**: 
1. Attacker crafts `GetVotingRecordsInput` with ~150,000 Hash values
2. Sends via `CallReadOnly` RPC endpoint (requires no authentication)
3. Node executes the view method without transaction fees
4. For each Hash, performs state read via `State.VotingRecords[id]`
5. Constructs massive `VotingRecords` response containing all records
6. Consumes excessive CPU, memory, and I/O resources

### Impact Explanation

**Operational DoS Impact on Node Resources**:

- **Resource Exhaustion**: Each call forces up to 150,000 state read operations from disk/memory storage. State reads involve I/O operations that consume significant resources when performed at scale.

- **Memory Consumption**: Creating a `VotingRecords` protobuf message containing 150,000 `VotingRecord` objects (each with multiple fields including addresses, timestamps, amounts) can consume hundreds of megabytes of memory per request.

- **Service Availability**: The attack targets RPC nodes processing view method calls. Since view methods execute on the node handling the RPC request (not through network consensus), repeated exploitation can overwhelm individual nodes, degrading or denying RPC service to legitimate users.

- **Amplification Factor**: Each attack request costs the attacker nothing (view methods are free), while forcing the target node to perform 150,000+ operations, creating a severe resource amplification attack.

**Who Is Affected**: All nodes exposing RPC endpoints that accept `GetVotingRecords` calls, particularly public RPC infrastructure serving dApps and wallets.

**Severity Justification**: HIGH severity due to ease of exploitation, zero cost to attacker, significant resource consumption per request, and ability to deny service through repeated attacks.

### Likelihood Explanation

**Highly Exploitable**:

- **Attacker Capabilities**: Any external party with network access to an RPC endpoint can exploit this. No blockchain account, tokens, or special permissions required.

- **Attack Complexity**: Trivial - construct a protobuf message with a large array of Hash values (can be random or enumerated) and send via standard RPC call.

- **Feasibility Conditions**: 
  - View methods are callable without gas fees or transaction submission
  - No authentication required for RPC calls
  - Transaction size limit (5MB) provides ample space for attack payload
  - No rate limiting visible at contract level

- **Economic Rationality**: Extremely favorable to attacker:
  - Zero cost per attack (no gas fees for view methods)
  - Can automate and repeat indefinitely
  - High resource cost imposed on victim node
  - Asymmetric resource consumption favors attacker

- **Detection Constraints**: Attack traffic may blend with legitimate queries for voting records. Standard RPC rate limiting might help but isn't contract-enforced.

**Probability**: HIGH - The vulnerability is trivially exploitable by any attacker with basic knowledge of RPC interactions.

### Recommendation

**Immediate Mitigation** - Add explicit array size validation in `GetVotingRecords`:

```csharp
public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
{
    Assert(input?.Ids != null && input.Ids.Count > 0, "Invalid input.");
    Assert(input.Ids.Count <= VoteContractConstants.MaxBatchQueryCount, 
        $"Query count exceeds maximum allowed ({VoteContractConstants.MaxBatchQueryCount}).");
    
    var votingRecords = new VotingRecords();
    votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
    return votingRecords;
}
```

**Add Contract Constant**:
Define a reasonable upper bound in `VoteContractConstants.cs`:
```csharp
public const int MaxBatchQueryCount = 100; // Align with MultiToken pattern
```

**Test Cases to Prevent Regression**:
1. Test that queries with count <= limit succeed
2. Test that queries with count > limit are rejected with appropriate error
3. Test boundary case at exactly the limit
4. Performance test to verify limit prevents resource exhaustion

**Additional Hardening**:
- Apply same validation pattern to any other view methods accepting array inputs
- Consider implementing pagination for large result sets
- Add monitoring for unusually large view method calls

### Proof of Concept

**Required Initial State**: 
- Running AElf node with RPC endpoint exposed
- Vote contract deployed and accessible

**Exploitation Steps**:

1. **Craft malicious input** with 150,000 Hash values:
```
GetVotingRecordsInput {
  ids: [Hash1, Hash2, Hash3, ... Hash150000] // 150,000 random or enumerated hashes
}
```

2. **Send via RPC CallReadOnly endpoint**:
```
POST /api/blockChain/executeTransaction
{
  "rawTransaction": "<serialized_transaction_with_massive_ids_array>"
}
```

3. **Expected Result**: 
   - Node accepts the request (passes 5MB size check)
   - Executes GetVotingRecords with 150,000 iterations
   - Performs 150,000 state reads
   - Attempts to serialize massive response
   - Consumes excessive CPU, memory, and I/O

4. **Actual Result vs Desired**:
   - **Actual**: Request processes fully, consuming excessive resources
   - **Desired**: Request rejected with "Query count exceeds maximum" error before processing

5. **Success Condition**: 
   - Monitor node resource usage (CPU, memory, I/O) during attack
   - Observe significant spike in resource consumption
   - Measure response time degradation (likely seconds instead of milliseconds)
   - Verify multiple concurrent requests can cause service degradation
   - Confirm no gas fees charged to attacker

**Attack Automation**: Attacker can script multiple parallel requests to amplify impact and achieve sustained DoS.

### Notes

This vulnerability exemplifies a common pattern in smart contract view methods: assuming array inputs will be reasonable in size without enforcing explicit limits. The AElf codebase demonstrates awareness of this issue in other contracts (MultiToken's `BatchApprove` with 100-element limit), but the Vote contract's `GetVotingRecords` method was implemented without this critical safeguard. The 5MB transaction size limit provides some boundary but is insufficient to prevent resource exhaustion attacks on view methods that process each element individually with expensive operations like state reads.

### Citations

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** protobuf/vote_contract.proto (L71-74)
```text
    // Get the voting record according to vote ids.
    rpc GetVotingRecords (GetVotingRecordsInput) returns (VotingRecords) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/vote_contract.proto (L259-262)
```text
message GetVotingRecordsInput {
    // The vote ids.
    repeated aelf.Hash ids = 1;
}
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L285-286)
```csharp
        Assert(input != null && input.Value != null && input.Value.Count > 0, "Invalid input .");
        Assert(input.Value.Count <= GetMaxBatchApproveCount(), "Exceeds the max batch approve count.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L27-27)
```csharp
    public const int DefaultMaxBatchApproveCount = 100;
```
