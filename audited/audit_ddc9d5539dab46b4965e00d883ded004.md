# Audit Report

## Title
Seed NFT Expiration Time Overflow Enables Permanent Symbol Monopolization

## Summary
The `ExtendSeedExpirationTime` method accepts arbitrary expiration time values without bounds validation, allowing seed NFT owners to set expiration times to extreme values like `long.MaxValue`. This causes expiration validation logic to malfunction, permanently blocking the creation of new seeds for monopolized symbols and enabling indefinite seed validity.

## Finding Description

The vulnerability exists in the `ExtendSeedExpirationTime` method which updates the expiration time stored in a seed NFT's external information. The method only validates that the caller is the seed owner but performs no validation on the expiration time value itself. [1](#0-0) 

When a seed owner calls this method with `input.ExpirationTime = 9223372036854775807L` (long.MaxValue), the expiration time is stored directly without validation. This breaks two critical expiration checks:

**1. CheckSymbolSeed - Blocks New Seed Creation:**
When creating a new seed NFT for a symbol, the system checks if any existing seed for that symbol has expired. The check validates that `Context.CurrentBlockTime.Seconds > symbolSeedExpireTime`. With `long.MaxValue` as the expiration time (representing year ~292 billion), this condition will never be satisfied, causing the assertion to fail permanently with "OwnedSymbol has been created". [2](#0-1) 

**2. CheckSeedNFT - Enables Indefinite Validity:**
When using a seed to create a token, the system validates that the seed hasn't expired by checking `Context.CurrentBlockTime.Seconds <= expirationTimeLong`. With `long.MaxValue`, this check always passes, allowing the seed to be used indefinitely without ever expiring. [3](#0-2) 

The attack flow requires:
1. Attacker acquires or creates a seed NFT for a desirable symbol
2. Calls `ExtendSeedExpirationTime` with expiration time set to `long.MaxValue`
3. The symbol becomes permanently monopolized - no new seeds can be created for it
4. The attacker's seed never expires and can be used at any future time

## Impact Explanation

This vulnerability constitutes a **permanent denial of service attack** on the symbol namespace, which is a critical protocol resource. The impact includes:

- **Permanent Monopolization**: Valuable symbol names can be indefinitely reserved by attackers, blocking legitimate users from creating tokens with those symbols
- **No Recovery Mechanism**: Once a seed's expiration is set to an extreme value, there is no administrative function to force-expire or reclaim the symbol without a contract upgrade
- **Symbol Namespace Pollution**: The attack creates a fragmented namespace with reserved but potentially unused symbols
- **Ecosystem Degradation**: The broader AElf ecosystem suffers from symbol unavailability, which could hinder project launches and token creation

While this does not result in direct fund theft or supply inflation, it breaks a critical protocol invariant that expired seeds should be replaceable, and it permanently damages the availability of a finite protocol resource.

## Likelihood Explanation

The vulnerability has **high likelihood** of exploitation due to:

**Minimal Prerequisites:**
- Attacker only needs to own a seed NFT, which can be acquired through normal creation or secondary market purchase
- No special privileges, governance control, or elevated permissions required
- The `ExtendSeedExpirationTime` method is a public RPC function accessible to any seed owner [4](#0-3) 

**Trivial Attack Complexity:**
- Single transaction calling `ExtendSeedExpirationTime` with maximum value
- No complex state manipulation, timing requirements, or multi-step processes
- Attack succeeds with 100% reliability
- No rate limiting or cooldown periods exist

**Economic Rationality:**
- Attack cost is minimal (transaction fee + seed acquisition cost)
- Potential value is high for desirable symbol names (e.g., common words, brand names, ticker symbols)
- Rational strategy for symbol squatting or competitive advantage
- The attack remains undetected until someone attempts to create a new seed for the monopolized symbol

## Recommendation

Implement validation in the `ExtendSeedExpirationTime` method to enforce reasonable bounds on the expiration time:

```csharp
public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
{
    var tokenInfo = GetTokenInfo(input.Symbol);
    if (tokenInfo == null)
    {
        throw new AssertionException("Seed NFT does not exist.");
    }

    Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
    
    var oldExpireTimeLong = 0L;
    if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
            out var oldExpireTime))
    {
        long.TryParse(oldExpireTime, out oldExpireTimeLong);
    }

    // ADD VALIDATION HERE
    Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds, 
        "Expiration time must be in the future.");
    Assert(input.ExpirationTime > oldExpireTimeLong, 
        "New expiration time must be greater than old expiration time.");
    
    // Define a reasonable maximum extension period (e.g., 10 years)
    var maxExpirationTime = Context.CurrentBlockTime.Seconds + (10 * 365 * 24 * 60 * 60);
    Assert(input.ExpirationTime <= maxExpirationTime, 
        "Expiration time exceeds maximum allowed period.");

    tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
        input.ExpirationTime.ToString();
    State.TokenInfos[input.Symbol] = tokenInfo;
    Context.Fire(new SeedExpirationTimeUpdated
    {
        ChainId = tokenInfo.IssueChainId,
        Symbol = input.Symbol,
        OldExpirationTime = oldExpireTimeLong,
        NewExpirationTime = input.ExpirationTime
    });
    return new Empty();
}
```

Additional considerations:
- Define `MaxSeedExpirationExtensionPeriod` as a configurable constant
- Consider implementing governance-controlled override mechanisms for reclaiming monopolized symbols
- Add monitoring/alerting for seeds with extremely long expiration times

## Proof of Concept

```csharp
[Fact]
public async Task ExtendSeedExpirationTime_Overflow_Monopolization_Test()
{
    // Setup: Create a seed NFT for symbol "TEST"
    var seedSymbol = "SEED-1";
    var ownedSymbol = "TEST";
    await CreateSeedNFT(seedSymbol, ownedSymbol, DefaultAddress);
    
    // Attack: Extend expiration time to long.MaxValue
    await TokenContractStub.ExtendSeedExpirationTime.SendAsync(new ExtendSeedExpirationTimeInput
    {
        Symbol = seedSymbol,
        ExpirationTime = long.MaxValue // 9,223,372,036,854,775,807
    });
    
    // Verify: Attempt to create a new seed for the same symbol fails permanently
    var result = await TokenContractStub.Create.SendWithExceptionAsync(new CreateInput
    {
        Symbol = "SEED-2",
        TokenName = "New Seed",
        TotalSupply = 1,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        Owner = DefaultAddress,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "__seed_owned_symbol", ownedSymbol },
                { "__seed_exp_time", (Context.CurrentBlockTime.Seconds + 86400).ToString() }
            }
        }
    });
    
    // Assert: Creation fails with "OwnedSymbol has been created"
    result.TransactionResult.Error.ShouldContain("OwnedSymbol has been created");
    
    // Verify: Original seed with long.MaxValue expiration never expires
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput 
    { 
        Symbol = seedSymbol 
    });
    tokenInfo.ExternalInfo.Value["__seed_exp_time"].ShouldBe(long.MaxValue.ToString());
}
```

This test demonstrates that once a seed's expiration is set to `long.MaxValue`, no new seeds can be created for that symbol, achieving permanent monopolization.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L57-67)
```csharp
    private void CheckSymbolSeed(string ownedSymbol)
    {
        var oldSymbolSeed = State.SymbolSeedMap[ownedSymbol.ToUpper()];

        Assert(oldSymbolSeed == null || !GetTokenInfo(oldSymbolSeed).ExternalInfo.Value
                   .TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var oldSymbolSeedExpireTime) ||
               !long.TryParse(oldSymbolSeedExpireTime, out var symbolSeedExpireTime)
               || Context.CurrentBlockTime.Seconds > symbolSeedExpireTime,
            "OwnedSymbol has been created");
    }
```

**File:** protobuf/token_contract_impl.proto (L195-196)
```text
    rpc ExtendSeedExpirationTime (ExtendSeedExpirationTimeInput) returns (google.protobuf.Empty) {
    }
```
