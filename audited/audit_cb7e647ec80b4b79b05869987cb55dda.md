### Title
Overly Strict Validation in Secret Sharing Reconstruction Defeats Byzantine Fault Tolerance

### Summary
The `RevealSharedInValues` method requires all miners to provide decrypted pieces before reconstructing any miner's InValue, but Shamir's Secret Sharing only requires a 2/3 threshold. This allows a single non-participating miner to prevent all secret reconstruction, defeating the Byzantine fault tolerance property and enabling manipulation of the random number generation mechanism.

### Finding Description

The vulnerability exists in the secret sharing reconstruction logic within the AEDPoS consensus mechanism. [1](#0-0) 

The code correctly calculates the threshold (`minimumCount`) as 2/3 of the total miners, which is the minimum number of shares needed for Shamir's Secret Sharing reconstruction. [2](#0-1) 

However, line 36 requires that `DecryptedPieces.Count >= minersCount` (i.e., ALL miners must contribute) before attempting reconstruction. This contradicts the threshold property of the secret sharing scheme. [3](#0-2) 

The actual reconstruction call at line 50 correctly uses `minimumCount` as the threshold parameter, confirming that only 2/3 of shares are mathematically required. [4](#0-3) 

The test suite confirms the intended design: reconstruction should proceed as soon as `MinimumCount` (2/3) shares are available, not when all shares are present. [5](#0-4) 

When miners call `UpdateValue`, their decrypted pieces are distributed to other miners' `DecryptedPieces` maps. If any miner fails to provide decryptions, the target miners won't reach the `minersCount` threshold. [6](#0-5) 

The `ExtractInformationToUpdateConsensus` function collects only available decrypted pieces, which is correct behavior. The issue is the overly strict validation during reconstruction, not the collection logic.

### Impact Explanation

**Consensus Integrity Degradation**: The secret sharing mechanism is designed to reveal miners' committed InValues even if they go offline or act maliciously, ensuring randomness cannot be manipulated. By requiring 100% participation instead of the 2/3 threshold, a single miner can prevent all InValue reconstruction.

**Concrete Harm**:
- Any single miner (malicious or offline) can cause secret reconstruction to fail for all miners in that round
- Miners can hide their previously committed values, potentially manipulating the VRF-based random number generation
- The Byzantine fault tolerance property (designed to work with up to 1/3 malicious nodes) is completely negated
- Affects all consensus participants and any systems relying on consensus randomness

**Severity Justification**: HIGH - This breaks a critical security property of the consensus mechanism (accountability and randomness integrity) and creates a single point of failure where the design explicitly intended fault tolerance.

### Likelihood Explanation

**Attacker Capabilities**: Must be an active miner in the consensus round. This is a realistic precondition as miners are expected to include both honest and potentially malicious actors.

**Attack Complexity**: Trivial - the attacker simply omits `DecryptedPieces` from their `UpdateValue` transaction or only provides partial decryptions. No special timing, economic resources, or coordination required. [7](#0-6) 

The system already permits miners to omit InValue publication, confirming that partial participation is expected and shouldn't break the protocol.

**Detection Difficulty**: Low - the attack is passive (omission) and appears identical to legitimate network issues or node downtime, making it indistinguishable from benign failures.

**Probability Assessment**: VERY HIGH - This condition will trigger in any scenario with even one offline/lagging miner, meaning it occurs frequently under normal operational conditions, not just during attacks.

### Recommendation

**Immediate Fix**: Change the validation threshold from `minersCount` to `minimumCount` to align with the actual cryptographic threshold:

```csharp
// Line 36 in AEDPoSContract_SecretSharing.cs
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

**Additional Safeguards**:
1. Add explicit validation that `minimumCount` shares are mathematically sufficient for reconstruction
2. Implement monitoring to alert when secret reconstruction success rate drops below expected thresholds
3. Add integration tests that verify reconstruction works with exactly `minimumCount` shares, not just with all shares

**Test Cases to Add**:
- Verify reconstruction succeeds with exactly 2/3 miners providing decryptions
- Verify reconstruction fails gracefully when fewer than 2/3 miners participate
- Simulate scenarios with 1-2 non-participating miners to ensure Byzantine tolerance

### Proof of Concept

**Initial State**:
- 7 active miners in consensus (arbitrary example count)
- Secret sharing enabled via configuration
- `minimumCount = 7 * 2 / 3 = 4` (threshold)

**Attack Steps**:

1. **Round N-1**: All 7 miners produce blocks and commit OutValues with encrypted secret shares for each other miner

2. **Round N**: Miners begin producing blocks with `UpdateValue` behavior:
   - Miners 1-6 call `UpdateValue` and include their full `DecryptedPieces` maps (6 entries each from decrypting other miners' shares)
   - Miner 7 (attacker) calls `UpdateValue` but provides empty or partial `DecryptedPieces` (omitting some or all decryptions)

3. **Secret Reconstruction Phase**: When `RevealSharedInValues` is called for any miner during round transition:
   - Check at line 36 evaluates: `DecryptedPieces.Count < minersCount` 
   - For all miners, count will be 6 (missing Miner 7's contribution)
   - Condition `6 < 7` evaluates to true, triggering `continue` statement
   - Reconstruction is skipped for ALL miners

**Expected vs Actual**:
- **Expected**: With 6 out of 7 miners providing shares (86% > 67% threshold), reconstruction should succeed
- **Actual**: Reconstruction fails because 6 < 7, even though 6 â‰¥ 4 (minimumCount) should be sufficient

**Success Condition**: All miners' `PreviousInValue` fields remain unset (null or Hash.Empty) despite having sufficient shares available for reconstruction, confirming the DoS condition.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/InValueRecoveryTest.cs (L52-58)
```csharp
            if (decryptedValues.Count >= MinimumCount)
            {
                decryptResult = SecretSharingHelper.DecodeSecret(
                    decryptedValues.Values.ToList(),
                    Enumerable.Range(1, MinimumCount).ToList(), MinimumCount);
                break;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L262-264)
```csharp
        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-293)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-28)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);
```
