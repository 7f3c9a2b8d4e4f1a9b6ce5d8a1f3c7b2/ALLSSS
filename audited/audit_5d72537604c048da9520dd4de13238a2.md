### Title
Integer Overflow in Method Fee Calculation via Duplicate Symbol Aggregation

### Summary
The `SetMethodFee` function in VoteContract (and all ACS1 implementations) validates that `BasicFee >= 0` but lacks an upper bound check. When multiple `MethodFee` entries with the same symbol are set with large values, the downstream `GetBaseFeeDictionary` function uses LINQ's `Sum()` method which employs unchecked arithmetic, causing integer overflow. This results in fee bypass where users pay minimal or no transaction fees instead of the intended amounts.

### Finding Description
The vulnerability exists across all ACS1 (Transaction Fee Standard) implementations. In VoteContract's `SetMethodFee`: [1](#0-0) 

The validation in `AssertValidToken` only checks for non-negative amounts: [2](#0-1) 

The system explicitly supports multiple `MethodFee` entries with the same symbol, as demonstrated in test: [3](#0-2) 

However, when fees are aggregated in `GetBaseFeeDictionary`, LINQ's `Sum()` is used: [4](#0-3) 

LINQ's `Sum()` uses unchecked arithmetic and does not throw overflow exceptions, despite the codebase's extensive use of SafeMath for overflow protection: [5](#0-4) 

When the summed fee overflows to a negative or small positive value, the fee charging logic at line 773 either always succeeds (for negative values, since any allowance >= negative number) or charges minimal fees: [6](#0-5) 

### Impact Explanation
**Direct Impact:** Transaction fee bypass violating the "fee deduction paths" critical invariant. Users would pay near-zero fees instead of intended amounts, undermining the protocol's fee economy.

**Quantified Damage:** With two `MethodFee` entries each set to `(long.MaxValue / 2 + 1)`, the sum overflows to `long.MinValue` (-9,223,372,036,854,775,808). The fee charging logic then treats this negative amount as "always satisfied" and charges zero fees.

**Affected Parties:** All transactions to methods with overflowed fees would bypass fee collection, impacting Treasury revenue and validator incentives. All ACS1-implementing contracts are vulnerable: Vote, Token, Parliament, Election, Profit, Treasury, TokenConverter, TokenHolder, Referendum, Association, Configuration, Consensus, CrossChain, Economic, and Genesis contracts.

**Severity:** Medium - While requiring governance approval, this breaks a fundamental mathematical invariant and could occur accidentally if governance doesn't understand the overflow risk.

### Likelihood Explanation
**Entry Point:** `SetMethodFee` is accessible via governance proposal through Parliament's default organization. [7](#0-6) 

**Preconditions:** Requires 2/3 approval from block producers via Parliament governance. However, this is not purely "trusted role compromise" because:
1. The bug could be triggered accidentally - governance may not realize duplicate high-value symbols cause overflow
2. It violates mathematical invariants that even trusted roles shouldn't bypass
3. The test suite explicitly validates duplicate symbol support but lacks overflow boundary testing

**Execution Practicality:** Fully executable. Governance creates proposal with `MethodFees` containing multiple entries with same symbol and `BasicFee` values that sum to > `long.MaxValue`. After approval and release, subsequent transactions to that method bypass fee collection.

**Detection Constraints:** Governance proposals are public but numerical overflow may not be obvious during review. No runtime checks prevent overflow during fee setting or aggregation.

### Recommendation
1. **Add upper bound validation** in `AssertValidToken` across all ACS1 implementations:
   ```csharp
   private void AssertValidToken(string symbol, long amount)
   {
       Assert(amount >= 0, "Invalid amount.");
       Assert(amount <= MaxReasonableFee, "Fee amount exceeds maximum limit.");
       // ... existing token validation
   }
   ```

2. **Validate aggregate sum** in `SetMethodFee` before storing:
   ```csharp
   var aggregateFees = input.Fees.GroupBy(f => f.Symbol)
       .ToDictionary(g => g.Key, g => g.Select(f => f.BasicFee).Aggregate(0L, (a,b) => a.Add(b))); // Use SafeMath.Add
   ```

3. **Replace LINQ Sum() with SafeMath accumulation** in `GetBaseFeeDictionary`:
   ```csharp
   private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
   {
       return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
           .GroupBy(f => f.Symbol)
           .ToDictionary(g => g.Key, g => g.Aggregate(0L, (sum, fee) => sum.Add(fee.BasicFee)));
   }
   ```

4. **Add regression test** verifying overflow protection for large BasicFee values and duplicate symbols.

### Proof of Concept
**Initial State:**
- Vote contract deployed with Parliament as method fee controller
- Test token available for method fees

**Attack Steps:**
1. Governance creates proposal to set method fee for `Vote` method:
   ```
   MethodFees {
     MethodName: "Vote",
     Fees: [
       { Symbol: "ELF", BasicFee: 4611686018427387904 },  // long.MaxValue / 2 + 1
       { Symbol: "ELF", BasicFee: 4611686018427387904 }   // long.MaxValue / 2 + 1
     ]
   }
   ```

2. Governance approves and releases proposal (2/3 block producer approval)

3. User calls `Vote` method with minimal ELF balance

**Expected Result:** Transaction should fail with insufficient fee balance (sum = 9,223,372,036,854,775,808 which exceeds user's balance)

**Actual Result:** `GetBaseFeeDictionary` computes sum using LINQ `Sum()` → overflow to -9,223,372,036,854,775,808 → `TryToChargeUserBaseFee` at line 773 treats negative amount as "always satisfied" → transaction succeeds with zero fee charged

**Success Condition:** Transaction executes successfully while `TransactionFeeCharged` event shows 0 amount deducted, confirming fee bypass via integer overflow.

### Notes
This vulnerability affects all 15 system contracts implementing ACS1. The ProfitContract has a count limit of 5 fees but still vulnerable since 5 × (long.MaxValue / 4) overflows. The root cause is the mismatch between the system's SafeMath overflow protection design and LINQ's unchecked arithmetic in the aggregation path.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L71-85)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L99-108)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L66-104)
```csharp
    public async Task Set_Repeat_Token_Test()
    {
        await IssueTokenToDefaultSenderAsync(NativeTokenSymbol, 100000_00000000);
        await SetPrimaryTokenSymbolAsync();
        var address = DefaultSender;
        var methodName = nameof(TokenContractContainer.TokenContractStub.Transfer);
        var basicMethodFee = 1000;
        var methodFee = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                },
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                }
            }
        };
        var sizeFee = 0;
        await TokenContractImplStub.SetMethodFee.SendAsync(methodFee);
        var beforeChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        var chargeTransactionFeesInput = new ChargeTransactionFeesInput
        {
            MethodName = methodName,
            ContractAddress = TokenContractAddress,
            TransactionSizeFee = sizeFee,
        };

        var chargeFeeRet = await TokenContractStub.ChargeTransactionFees.SendAsync(chargeTransactionFeesInput);
        chargeFeeRet.Output.Success.ShouldBeTrue();
        var afterChargeBalance = await GetBalanceAsync(address, NativeTokenSymbol);
        beforeChargeBalance.Sub(afterChargeBalance).ShouldBe(basicMethodFee.Add(basicMethodFee));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L747-777)
```csharp
    private bool TryToChargeUserBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, out long amount,
        out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        // priority: enough allowance -> symbolWithEnoughBalancePlusAllowance -> symbolWithEnoughBalance -> symbolWithAnything
        symbolOfValidBalance = null;
        string symbolWithAnything = null;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        //For user
        //Find the token that satisfies the balance of the fee,if there is no token that satisfies the balance of the fee, find the token that balance > 0
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);

            var existingBalancePlusAllowance = existingBalance.Add(existingAllowance);

            
            // allowance is enough to cover the base fee
            if (existingAllowance >= amount)
            {
                symbolOfValidBalance = symbol;
                return true;
            }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```
