# Audit Report

## Title
Signature Non-Repudiation Vulnerability: Unvalidated Signature Mismatch Between Block Header and Transaction State

## Summary
The AEDPoS consensus system fails to validate that the signature in the block header matches the signature stored in the transaction state during `UpdateValue` operations. A malicious miner can provide a valid signature for block validation but store a different signature (including `Hash.Empty`) in the consensus state, breaking signature non-repudiation and corrupting the signature chain used for randomness generation and mining order calculations.

## Finding Description

The vulnerability exists in the dual-path signature handling during the `UpdateValue` consensus operation:

**Path 1: Block Header Signature**

The `GetUpdateValueRound()` function creates a simplified Round object for the block header, copying the signature from the current round. [1](#0-0)  This signature is validated before execution through `ValidateBeforeExecution()`. [2](#0-1) 

**Path 2: Transaction Signature**

The `ExtractInformationToUpdateConsensus()` function creates an `UpdateValueInput` containing a signature field. [3](#0-2)  During transaction execution, this signature from the transaction input is stored directly to state without cross-validation against the header signature. [4](#0-3) 

**Missing Validation**

The `UpdateValueValidationProvider` only checks that the header signature exists and is non-empty, but does not compare it with the transaction signature. [5](#0-4) 

The `ValidateConsensusAfterExecution()` method attempts validation through hash comparison, but is ineffective because `RecoverFromUpdateValue()` modifies the current round in-place by overwriting the state signature with the header signature before the comparison occurs. [6](#0-5)  The recovery operation [7](#0-6)  makes the subsequent hash comparison meaningless as both sides reference the same modified object, while the persisted state retains the transaction signature.

## Impact Explanation

**Consensus Integrity Corruption:**

The signature is critical for consensus operations. The `CalculateSignature()` method aggregates all miner signatures through XOR operations to compute future signatures. [8](#0-7)  A corrupted signature in the state breaks this cryptographic chain, affecting all subsequent rounds.

Mining order for the next round is calculated directly from the signature value. [9](#0-8)  A manipulated signature affects the fairness of miner selection and round ordering.

**Specific Harms:**
1. **Non-Repudiation Failure**: A miner can provide a valid signature for validation but store `Hash.Empty` in state, denying participation while appearing compliant to the validation system
2. **Randomness Corruption**: Future random number generation depends on signature chain integrity through `GetLatestSignature` [10](#0-9) 
3. **Fairness Violation**: Mining order calculations use corrupted signatures, affecting the deterministic miner selection process
4. **Consensus Instability**: Signature chain breaks propagate through all subsequent rounds, affecting long-term consensus stability

**Severity: MEDIUM** - Requires a malicious miner (privileged but not trusted role) but breaks critical consensus invariants with network-wide impact.

## Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner (privileged but distributed role, not in the trusted role list per threat model)
- Must modify node implementation to generate mismatched signatures between header and transaction
- Node modification is technically feasible for sophisticated actors with access to their own mining infrastructure

**Attack Complexity:**
- LOW - Once node is modified, exploitation is straightforward
- Both block header and transaction are generated through calls to `GetConsensusBlockExtraData` with different parameters [11](#0-10) 
- Attacker can modify the trigger information provider or consensus contract to use different signatures for header versus transaction generation

**Feasibility Conditions:**
- Attacker controls a miner node and its software
- No contract-level validation prevents the attack - validation only examines the header
- Block validation passes with the header signature
- State stores the transaction signature without cross-checking against the header

**Detection Difficulty:**
- Difficult to detect without explicit comparison of historical block header data versus stored consensus state signatures
- Attack may only become apparent when signature chain is used for critical operations like mining order calculation or randomness generation in future rounds

**Probability: MEDIUM-HIGH** - Technical barrier exists (node modification and maintaining miner status) but no protocol-level prevention mechanism exists once these barriers are overcome.

## Recommendation

Add explicit validation in `ValidateConsensusAfterExecution` that compares the signature from the block header's extra data against the signature that was actually stored in state, before the recovery operation modifies the local copy. Alternatively, add validation in `ProcessUpdateValue` to verify that the transaction input signature matches the signature from the block header's consensus extra data.

Specific fix approach:
1. In `ValidateConsensusAfterExecution`, retrieve the stored round state before recovery
2. Extract the signature from both the header's simplified round and the stored state
3. Explicitly compare these signatures before performing recovery
4. Reject the block if signatures do not match

## Proof of Concept

A proof of concept would require:
1. Modifying a miner node's `AEDPoSTriggerInformationProvider` or consensus contract to generate different signatures for `GetTriggerInformationForBlockHeaderExtraData` versus `GetTriggerInformationForConsensusTransactions`
2. Mining a block with mismatched signatures (header has SIG_A, transaction has SIG_B)
3. Verifying that the block passes validation
4. Confirming that the stored consensus state contains SIG_B while the validation succeeded with SIG_A
5. Demonstrating that subsequent round's mining order calculation uses the corrupted SIG_B from state

This would demonstrate that the validation system allows signature mismatches to persist in state, corrupting the consensus signature chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-24)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-38)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L95-106)
```csharp
    private Hash GetLatestSignature(Round currentRound)
    {
        var latestSignature = currentRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .LastOrDefault(m => m.Signature != null)?.Signature;
        if (latestSignature != null) return latestSignature;
        if (TryToGetPreviousRoundInformation(out var previousRound))
            latestSignature = previousRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
                .LastOrDefault(m => m.Signature != null)
                ?.Signature;

        return latestSignature;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-244)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-32)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L61-74)
```csharp
    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L16-17)
```csharp
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
