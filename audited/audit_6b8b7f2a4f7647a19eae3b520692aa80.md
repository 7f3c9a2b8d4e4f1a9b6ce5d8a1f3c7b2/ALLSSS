### Title
Round Mismatch Causes Miner DoS Due to Missing UpdateValueInput.RoundId Validation

### Summary
The `UpdateValueInput.RoundId` field is never validated against the current round ID, despite protobuf documentation stating it should "ensure the values to update will be apply to correct round by comparing round id." When a round transition occurs between UpdateValueInput generation and validation, miners not present in the new round will have their transactions rejected by `MiningPermissionValidationProvider`, causing them to lose their block production opportunity and mining rewards.

### Finding Description

The vulnerability exists in the consensus update value flow:

**Root Cause:** The `UpdateValueInput.RoundId` field is set in `ExtractInformationToUpdateConsensus` [1](#0-0)  but is never validated in any validation provider or processing logic.

**Missing Validation:** `UpdateValueValidationProvider` only checks OutValue and Signature fields [2](#0-1)  and completely ignores the `RoundId` field. The protobuf specification explicitly states this field exists to "ensure the values to update will be apply to correct round by comparing round id" [3](#0-2)  but no such comparison is implemented.

**Failure Path:** When validation occurs in `ValidateBeforeExecution`, it calls `RecoverFromUpdateValue` which returns early if the miner's pubkey is not found in the current round [4](#0-3) . Subsequently, `MiningPermissionValidationProvider` checks if the sender exists in the BaseRound and fails if not [5](#0-4) .

**Execution Path:**
1. Miner generates `UpdateValueInput` for round N via `GenerateConsensusTransactions` [6](#0-5) 
2. Another miner produces NextRound/NextTerm transaction, advancing to round N+1
3. Original miner's transaction enters validation with stale RoundId
4. If miner not in new round's miner list (e.g., during term change), validation fails
5. Transaction rejected with "Sender is not a miner" error

### Impact Explanation

**Direct Impact:**
- **Mining Opportunity Loss:** Affected miner loses their assigned time slot and cannot produce a block
- **Reward Loss:** No block production means no mining rewards for that slot
- **Reputation Damage:** Failed attempts are counted as missed time slots, which can lead to the miner being marked as evil if it exceeds `TolerableMissedTimeSlotsCount` [7](#0-6) 

**Who Is Affected:**
- Miners during round/term transitions
- Miners with higher network latency
- Any miner whose UpdateValueInput spans a round boundary

**Severity Justification:** Medium severity because:
- Causes operational DoS for legitimate miners
- Results in direct financial loss (missed rewards)
- Can trigger cascading reputation penalties
- However, requires specific timing (round transition) to manifest

### Likelihood Explanation

**Natural Occurrence Conditions:**
- Round transitions happen regularly based on configured intervals
- Term transitions change miner lists, creating highest risk window
- Network latency can delay transaction inclusion
- No attacker action required - pure race condition

**Attack Complexity:** None required - this is a natural timing issue, not an exploit

**Feasibility:** High during:
- Last time slot of any round when NextRound is imminent
- Term changes when miner lists are reconfigured [8](#0-7) 
- Network congestion scenarios

**Time Window:** Between `GetConsensusExtraData` call generating UpdateValueInput and `ValidateConsensusBeforeExecution` during block inclusion - typically narrow but real.

**Probability:** Medium - happens naturally without exploitation, more frequent during term transitions, proportional to network latency and round duration ratio.

### Recommendation

**Code-Level Mitigation:**

Add RoundId validation in `UpdateValueValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    // Validate RoundId matches
    var updateValueInput = /* extract from context */;
    if (updateValueInput.RoundId != validationContext.BaseRound.RoundId)
    {
        return new ValidationResult 
        { 
            Message = $"UpdateValue RoundId mismatch: expected {validationContext.BaseRound.RoundId}, got {updateValueInput.RoundId}",
            IsReTrigger = true // Allow miner to retry with new round
        };
    }
    
    // Existing validations...
}
```

**Alternative:** Store UpdateValueInput in validation context and validate in `UpdateValueValidationProvider` [2](#0-1) 

**Invariant Check:** Ensure `UpdateValueInput.RoundId == CurrentRound.RoundId` before processing in `ProcessUpdateValue` [9](#0-8) 

**Test Cases:**
1. Generate UpdateValueInput for round N
2. Advance to round N+1 via NextRound
3. Attempt to process stale UpdateValueInput
4. Verify rejection with IsReTrigger=true to allow retry
5. Test during term transitions with miner list changes

### Proof of Concept

**Initial State:**
- Blockchain at round N, height H
- Miner A in round N miner list
- Term transition scheduled at round N+1 with new miner list (Miner A removed)

**Transaction Steps:**
1. Miner A calls `GetConsensusCommand` at time T, receives command for round N [10](#0-9) 
2. Miner A generates consensus extra data via `GetConsensusBlockExtraData` with round N data [11](#0-10) 
3. `ExtractInformationToUpdateConsensus` creates UpdateValueInput with `RoundId = round_N_id` [12](#0-11) 
4. Before Miner A's block is included, another miner produces NextTerm block advancing to round N+1
5. Miner A's UpdateValue transaction enters `ValidateBeforeExecution` [13](#0-12) 
6. Current round is N+1, Miner A not in new miner list
7. `RecoverFromUpdateValue` returns early (Miner A not in current round) [4](#0-3) 
8. `MiningPermissionValidationProvider` fails: Miner A not in BaseRound [5](#0-4) 

**Expected Result:** Transaction should be rejected with clear RoundId mismatch error and IsReTrigger=true

**Actual Result:** Transaction rejected with "Sender is not a miner" - miner loses time slot, cannot retry in time, counted as missed slot

**Success Condition:** Miner A's UpdateValue transaction for round N is rejected when current round is N+1, causing DoS for that mining opportunity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L35-50)
```csharp
        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** protobuf/aedpos_contract.proto (L199-200)
```text
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L10-12)
```csharp
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L180-181)
```csharp
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-240)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L34-37)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-47)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```
