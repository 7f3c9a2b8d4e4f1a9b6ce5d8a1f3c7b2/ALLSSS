# Audit Report

## Title
Missing Miner Count Validation in NextRound Consensus Transitions Allows Bypassing Maximum Miner Limit

## Summary
The AEDPoS consensus contract fails to validate miner count during NextRound transitions, allowing a malicious block producer to inject additional unauthorized miners beyond the governance-controlled `MaximumMinersCount` limit. This bypasses critical consensus integrity checks and undermines the election-based miner selection mechanism.

## Finding Description

The vulnerability exists in the NextRound consensus transition flow where miner count validation is completely absent.

**Root Cause - Unchecked Data Copying:**

The `NextRoundInput.Create()` method blindly copies the entire `RealTimeMinersInformation` dictionary without any validation against `MaximumMinersCount`. [1](#0-0) 

**Missing Validation in Pre-Execution Checks:**

When a NextRound behavior is validated before execution, only two validation providers are registered: [2](#0-1) 

The `RoundTerminateValidationProvider` only validates round number increment and that InValues are null - it does NOT check miner count: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` only validates mining order consistency by checking that miners with `FinalOrderOfNextRound > 0` equals miners with `OutValue != null` - it does NOT validate total miner count: [4](#0-3) 

**Unchecked State Update:**

After validation passes, `ProcessNextRound` converts the input and directly stores the round without any miner count verification: [5](#0-4) 

The `AddRoundInformation` method stores the round directly to state without validation: [6](#0-5) 

**Maximum Miner Count Constraint Exists But Is Not Enforced:**

The system has a configurable `MaximumMinersCount` that is properly managed through governance: [7](#0-6) 

The `GetMinersCount` helper method correctly calculates allowed count respecting the maximum: [8](#0-7) 

However, this constraint is never validated against incoming NextRoundInput data during the NextRound consensus flow.

**Attack Scenario:**

1. Malicious miner generates legitimate NextRound consensus extra data: [9](#0-8) 

2. Before including in block, attacker modifies the returned `nextRound.RealTimeMinersInformation` to add extra miners beyond `MaximumMinersCount`

3. Modified consensus extra data is included in proposed block

4. Validation passes because no validator checks miner count

5. Malicious round with excess miners is committed to state

## Impact Explanation

**Consensus Integrity Violation (HIGH):**
- Breaks the fundamental consensus invariant: "Miner schedule must respect governance-controlled maximum miner count"
- Bypasses the election-based miner selection where only top-voted candidates should become miners
- Renders the `SetMaximumMinersCount` governance control meaningless

**Attack Enablement:**
- **Sybil Attacks:** Attacker can add multiple controlled public keys as miners to dominate consensus and potentially achieve >51% control
- **Unauthorized Participation:** Non-elected candidates can be added as miners without proper voting/staking requirements
- **Governance Circumvention:** Parliament-approved miner count limits become unenforceable

**Severity Justification:**
While this does not directly lead to fund loss, it enables severe consensus manipulation that can lead to:
- Block production control and censorship
- Potential double-spend attacks if attacker controls majority
- Complete undermining of the DPoS election mechanism
- Loss of protocol integrity and trust

## Likelihood Explanation

**Attacker Prerequisites (REALISTIC):**
- Must be a current miner (authorized block producer) - this is realistic as there are typically 5-21 active miners
- Must run modified node software to craft malicious consensus extra data - technically feasible for any miner
- No additional economic stake or permissions required beyond being an active miner

**Attack Complexity (LOW):**
The attack is straightforward:
1. Call contract view method to generate legitimate next round data
2. Modify the `RealTimeMinersInformation` dictionary to add extra miner entries
3. Include modified data in block header
4. All existing validation checks pass
5. Malicious round is accepted and stored

**Detection Difficulty (HIGH):**
- No on-chain detection mechanism exists
- Modified rounds appear structurally valid (only the count exceeds maximum)
- Would require off-chain monitoring comparing actual miner count vs configured maximum
- By the time detection occurs, consensus schedule is already compromised

**Overall Likelihood: HIGH** - Single compromised miner + simple data modification + no validation = easily exploitable

## Recommendation

Add miner count validation to the NextRound validation flow:

```csharp
// In AEDPoSContract_Validation.cs, add a new validation provider for NextRound:
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new MinerCountValidationProvider()); // NEW
    break;
```

Create new validation provider:

```csharp
// New file: ConsensusHeaderInfoValidationProviders/MinerCountValidationProvider.cs
public class MinerCountValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedRound = validationContext.ProvidedRound;
        var actualMinerCount = providedRound.RealTimeMinersInformation.Count;
        
        // Get maximum allowed miner count from state
        var maximumMinersCount = GetMaximumMinersCount();
        var autoIncreasedCount = GetAutoIncreasedMinersCount();
        var allowedMaxCount = Math.Min(autoIncreasedCount, maximumMinersCount);
        
        if (actualMinerCount > allowedMaxCount)
        {
            return new ValidationResult 
            { 
                Message = $"Miner count {actualMinerCount} exceeds maximum {allowedMaxCount}." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Additionally, add a defensive check in `ProcessNextRound`:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Add defensive validation
    var maxAllowed = Math.Min(GetAutoIncreasedMinersCount(), State.MaximumMinersCount.Value);
    Assert(nextRound.RealTimeMinersInformation.Count <= maxAllowed, 
        $"Next round miner count exceeds maximum: {nextRound.RealTimeMinersInformation.Count} > {maxAllowed}");
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of the method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanBypassMaximumMinerCount_ByInjectingExtraMiners()
{
    // Setup: Initialize consensus with 3 miners and MaximumMinersCount = 5
    await InitializeConsensusWithMiners(3);
    await SetMaximumMinersCount(5);
    
    // Attacker (current miner) generates legitimate next round
    var currentMiner = Miners[0];
    var nextRoundData = await GenerateNextRoundConsensusData(currentMiner);
    
    // Attack: Modify nextRoundData to add 10 extra unauthorized miners (exceeds max of 5)
    for (int i = 0; i < 10; i++)
    {
        var maliciousMiner = GenerateNewMinerKeyPair();
        nextRoundData.RealTimeMinersInformation[maliciousMiner.PublicKey.ToHex()] = new MinerInRound
        {
            Pubkey = maliciousMiner.PublicKey.ToHex(),
            Order = nextRoundData.RealTimeMinersInformation.Count + 1,
            ExpectedMiningTime = Timestamp.FromDateTime(DateTime.UtcNow)
        };
    }
    
    // Execute NextRound with malicious data
    var result = await ExecuteNextRound(currentMiner, nextRoundData);
    
    // VULNERABILITY: Transaction succeeds despite exceeding MaximumMinersCount
    result.Status.ShouldBe(TransactionResultStatus.Mined); // Should FAIL but PASSES
    
    // Verify malicious round was stored with excess miners
    var storedRound = await GetCurrentRoundInformation();
    storedRound.RealTimeMinersInformation.Count.ShouldBe(13); // 3 original + 10 malicious
    
    // Verify MaximumMinersCount (5) was bypassed
    var maxCount = await GetMaximumMinersCount();
    maxCount.Value.ShouldBe(5);
    storedRound.RealTimeMinersInformation.Count.ShouldBeLessThanOrEqualTo(maxCount.Value); // FAILS - vulnerability confirmed
}
```

## Notes

This vulnerability is valid and exploitable on mainnet. The attack requires a single compromised miner but enables severe consensus manipulation. While it doesn't directly cause fund loss, it fundamentally breaks the DPoS consensus integrity and governance controls. The fix requires adding miner count validation to the NextRound validation pipeline and defensive checks in state update logic.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
