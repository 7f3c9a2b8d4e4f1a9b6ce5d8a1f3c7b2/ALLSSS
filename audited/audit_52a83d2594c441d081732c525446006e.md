# Audit Report

## Title
ImpliedIrreversibleBlockHeight Validation Bypass via RecoverFromUpdateValue State Mutation

## Summary
The `LibInformationValidationProvider` validation for `ImpliedIrreversibleBlockHeight` is completely bypassed because `RecoverFromUpdateValue` modifies `BaseRound` in-place before validation occurs. This allows malicious miners to report arbitrarily low implied LIB heights, enabling manipulation of consensus finality.

## Finding Description

The validation mechanism designed to prevent miners from reporting decreasing `ImpliedIrreversibleBlockHeight` values is defeated by an order-of-operations flaw.

**Vulnerable Execution Flow:**

When processing `UpdateValue` behavior, the validation logic first calls `RecoverFromUpdateValue` on the `baseRound` fetched from state: [1](#0-0) 

This method modifies `baseRound` in-place by overwriting the miner's `ImpliedIrreversibleBlockHeight` with the provided value: [2](#0-1) 

The modified `baseRound` is then passed to the validation context: [3](#0-2) 

When `LibInformationValidationProvider` executes, it compares the base value (now already overwritten with the provided value) against the provided value: [4](#0-3) 

After `RecoverFromUpdateValue`, both values are identical, so the check `baseRound[pubkey].ImpliedIrreversibleBlockHeight > providedRound[pubkey].ImpliedIrreversibleBlockHeight` becomes `providedValue > providedValue`, which is always false, causing validation to pass.

The invalid value is then written to state: [5](#0-4) 

## Impact Explanation

**Consensus Finality Manipulation:**

The `ImpliedIrreversibleBlockHeight` values are used to calculate the Last Irreversible Block (LIB): [6](#0-5) 

The LIB calculator takes the value at position `(count-1)/3` from sorted implied heights, effectively requiring 2/3+ consensus. If 1/3+ colluding miners report artificially low values, the LIB calculation will be poisoned with these low values, preventing proper advancement of finality.

**Concrete Harms:**
1. **LIB Freeze/Regression**: The LIB could stall or even move backwards, violating a fundamental consensus invariant
2. **Cross-Chain Security Breakdown**: Cross-chain bridges depend on LIB for irreversibility guarantees
3. **Application Disruption**: dApps relying on transaction finality would be unable to confirm settlements
4. **Economic Impact**: Time-sensitive operations requiring finality guarantees would fail

**Severity: HIGH** - This directly breaks the consensus finality mechanism, a critical security invariant.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an elected miner in the current round
- Can construct consensus extra data with arbitrary `ImpliedIrreversibleBlockHeight` values

**Attack Complexity: LOW**
- Single malicious miner can exploit the bypass
- No complex transaction sequences required  
- Direct exploitation through normal block production

**Feasibility: HIGH**
- No special privileges beyond miner status required
- Validation automatically bypassed due to the flaw
- Attack cost is just normal block production cost
- Detection is difficult as blocks appear valid

For coordinated attacks with 1/3+ colluding miners, the impact scales significantly to completely freeze consensus finality.

## Recommendation

Move the `RecoverFromUpdateValue` call to **after** validation completes, or better yet, create a separate immutable copy for validation purposes:

```csharp
private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
{
    if (!TryToGetCurrentRoundInformation(out var baseRound))
        return new ValidationResult { Success = false, Message = "Failed to get current round information." };

    // Create validation context with UNMODIFIED baseRound
    var validationContext = new ConsensusValidationContext
    {
        BaseRound = baseRound,  // Original state values preserved
        CurrentTermNumber = State.CurrentTermNumber.Value,
        CurrentRoundNumber = State.CurrentRoundNumber.Value,
        PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
        LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
        ExtraData = extraData
    };

    // Add validation providers and run validation FIRST
    var validationProviders = new List<IHeaderInformationValidationProvider> { /* ... */ };
    var service = new HeaderInformationValidationService(validationProviders);
    var validationResult = service.ValidateInformation(validationContext);
    
    if (!validationResult.Success)
        return validationResult;

    // ONLY AFTER validation passes, apply the recovery
    if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
        baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

    if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
        baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
        
    return validationResult;
}
```

## Proof of Concept

The vulnerability can be demonstrated by examining the execution sequence:

1. Current state has miner's `ImpliedIrreversibleBlockHeight = 1000`
2. Malicious miner produces block with `UpdateValue` containing `ImpliedIrreversibleBlockHeight = 100`
3. `ValidateBeforeExecution` calls `RecoverFromUpdateValue` which overwrites baseRound to 100
4. `LibInformationValidationProvider` checks if 100 > 100 → false → validation passes
5. `ProcessUpdateValue` writes value 100 to state
6. LIB calculation now uses artificially low value 100 instead of monotonically increasing from 1000

The core issue is evident from the code flow where validation operates on already-mutated state rather than comparing against the original state values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-19)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-248)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
