### Title
Incorrect LIB Index Calculation Violates 2/3 Consensus Threshold in AEDPoS

### Summary
The Last Irreversible Block (LIB) height calculation in `LastIrreversibleBlockHeightCalculator.Deconstruct()` uses an incorrect index formula `Count.Sub(1).Div(3)` that fails to ensure 2/3 consensus when the count of implied irreversible heights exactly equals `MinersCountOfConsent`. This allows blocks to be finalized with insufficient Byzantine Fault Tolerance, potentially as low as 57% miner agreement instead of the required 67%, violating the fundamental security guarantee of the consensus protocol.

### Finding Description

The vulnerability exists in the LIB calculation logic: [1](#0-0) 

The `MinersCountOfConsent` property is calculated as: [2](#0-1) 

**Root Cause:**

The algorithm checks if `impliedIrreversibleHeights.Count >= MinersCountOfConsent` (line 26), then selects the height at index `(Count - 1) / 3` (line 32). This index calculation is fundamentally flawed.

For a sorted list of heights `[H₀, H₁, H₂, ..., Hₙ₋₁]`, selecting index `i` means that `(n - i)` miners have reported heights ≥ Hᵢ. Using index `(n-1)/3`:
- Miners agreeing = `n - (n-1)/3 = (2n+1)/3`

However, when `n = MinersCountOfConsent = (totalMiners * 2/3) + 1`:
- For 7 total miners: MinersCountOfConsent = 5, index = 1, agreeing miners = 4 (57% of 7)
- For 10 total miners: MinersCountOfConsent = 7, index = 2, agreeing miners = 5 (50% of 10)

This violates the 2/3 (67%) consensus requirement.

**Why Existing Protection Fails:**

The check at line 26 only ensures sufficient miners have mined, but doesn't validate that the selected index provides 2/3 consensus. The index formula `(Count-1)/3` was likely intended for a different consensus model and doesn't align with the `MinersCountOfConsent` threshold.

### Impact Explanation

**Consensus/Cross-Chain Integrity Violation:**

When the LIB is advanced prematurely without proper 2/3 consensus:

1. **Byzantine Fault Tolerance Breakdown**: The system can finalize blocks with only ~57% agreement, breaking the fundamental BFT assumption that up to 1/3 malicious nodes can be tolerated
2. **Irreversible Block Compromise**: The `IrreversibleBlockFound` event is fired, updating the chain's `LastIrreversibleBlockHeight`: [3](#0-2) 
3. **System-Wide Impact**: The LIB is used throughout the system for state finalization, cross-chain verification, and pruning: [4](#0-3) 

**Severity: High**
- Blocks can be irreversibly finalized without proper consensus
- Cross-chain operations may rely on finalized blocks that lack sufficient agreement
- State transitions and transaction finality guarantees are compromised
- The entire security model of Byzantine Fault Tolerance is violated

### Likelihood Explanation

**Highly Feasible - Occurs Naturally:**

1. **Reachable Entry Point**: Triggered during normal consensus operation via `ProcessUpdateValue`: [5](#0-4) 

2. **Natural Occurrence**: The vulnerable condition occurs when exactly `MinersCountOfConsent` miners have mined in the current round - a common scenario during normal operations

3. **No Attack Required**: This is a logic bug that manifests during legitimate protocol execution, not requiring any malicious actor

4. **Frequency**: With 7 miners, the probability that exactly 5 have mined when a miner calls `UpdateValue` is substantial during each round

5. **Detection Difficulty**: The miscalculation produces a valid (but incorrect) height, making it undetectable without deep analysis

### Recommendation

**Fix the index calculation to ensure proper 2/3 consensus:**

Change line 32 in `AEDPoSContract_LIB.cs` from:
```
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

To:
```
libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(_currentRound.MinersCountOfConsent)];
```

This ensures that at least `MinersCountOfConsent` miners (from the selected index to the end of the sorted list) have reported heights ≥ the selected LIB height, maintaining proper 2/3 consensus.

**Additional Validation:**
Add an assertion to verify the invariant:
```csharp
var selectedIndex = impliedIrreversibleHeights.Count.Sub(_currentRound.MinersCountOfConsent);
Assert(selectedIndex >= 0, "Invalid LIB index calculation");
libHeight = impliedIrreversibleHeights[selectedIndex];
```

**Test Cases:**
- Test with 7 miners, exactly 5 having mined (edge case)
- Test with 10 miners, exactly 7 having mined (edge case)
- Verify selected height has at least MinersCountOfConsent miners agreeing
- Test with varying miner counts to ensure formula correctness

### Proof of Concept

**Initial State:**
- Total miners in system: 7
- MinersCountOfConsent = (7 * 2 / 3) + 1 = 5
- Required consensus: 5 out of 7 miners (71%)

**Previous Round - Miners report ImpliedIrreversibleBlockHeight:**
- Miner A: height 1000
- Miner B: height 1005
- Miner C: height 1010
- Miner D: height 1015
- Miner E: height 1020
- Miners F, G: did not mine (or reported 0)

**Current Round:**
- Exactly 5 miners (A, B, C, D, E) have mined
- One of them calls `UpdateValue`, triggering LIB calculation

**Vulnerable Execution:**
1. `minedMiners = [A, B, C, D, E]` (5 miners)
2. `impliedIrreversibleHeights = [1000, 1005, 1010, 1015, 1020]` (sorted, Count = 5)
3. Check passes: `5 >= 5` ✓
4. Index = (5 - 1) / 3 = 1
5. **Selected LIB = 1005**

**Actual Result:**
- Miners agreeing on height ≥ 1005: B, C, D, E = **4 miners (57%)**
- **FAILS 2/3 requirement** (need 67%)

**Expected Result with Correct Formula:**
- Index should be: 5 - 5 = 0
- Selected LIB should be: 1000
- Miners agreeing on height ≥ 1000: A, B, C, D, E = **5 miners (71%)**
- **PASSES 2/3 requirement** ✓

**Success Condition:**
The vulnerability is confirmed when block 1005 is finalized despite only 4 out of 7 miners (57%) agreeing, violating the 2/3 Byzantine Fault Tolerance guarantee.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L54-87)
```csharp
    private async Task ProcessLogEventAsync(Block block, IrreversibleBlockFound irreversibleBlockFound)
    {
        try
        {
            var chain = await _blockchainService.GetChainAsync();

            if (chain.LastIrreversibleBlockHeight > irreversibleBlockFound.IrreversibleBlockHeight)
                return;

            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;

            if (chain.LastIrreversibleBlockHeight == irreversibleBlockFound.IrreversibleBlockHeight) return;

            var blockIndex = new BlockIndex(libBlockHash, irreversibleBlockFound.IrreversibleBlockHeight);
            Logger.LogDebug($"About to set new lib height: {blockIndex.BlockHeight} " +
                            $"Event: {irreversibleBlockFound} " +
                            $"BlockIndex: {blockIndex.BlockHash} - {blockIndex.BlockHeight}");
            _taskQueueManager.Enqueue(
                async () =>
                {
                    var currentChain = await _blockchainService.GetChainAsync();
                    if (currentChain.LastIrreversibleBlockHeight < blockIndex.BlockHeight)
                        await _blockchainService.SetIrreversibleBlockAsync(currentChain, blockIndex.BlockHeight,
                            blockIndex.BlockHash);
                }, KernelConstants.UpdateChainQueueName);
        }
        catch (Exception e)
        {
            Logger.LogError(e, "Failed to resolve IrreversibleBlockFound event.");
            throw;
        }
    }
```
