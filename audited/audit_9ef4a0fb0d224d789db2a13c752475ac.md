### Title
Threshold Mismatch in Secret Sharing Causes Incorrect InValue Reconstruction When Miner Count Changes

### Summary
The `RevealSharedInValues` function uses `currentRound.RealTimeMinersInformation.Count` to calculate the decoding threshold, while secrets were encoded using `previousRound.RealTimeMinersInformation.Count`. When the miner list changes between rounds (a supported protocol feature), this mismatch causes Shamir's Secret Sharing to reconstruct garbage InValues, corrupting consensus randomness and potentially leading to consensus failures.

### Finding Description

The vulnerability exists in the threshold calculation logic: [1](#0-0) 

The function calculates `minimumCount` using the current round's miner count, but the secrets being decoded were created in the previous round using that round's miner count.

During secret encoding, the off-chain service correctly uses the previous round's count: [2](#0-1) 

For comparison, the off-chain decoding also correctly uses the same round's count that was used for encoding: [3](#0-2) 

The Shamir's Secret Sharing implementation creates a polynomial of degree `threshold-1`: [4](#0-3) 

And decoding requires exactly `threshold` points to reconstruct: [5](#0-4) 

The protocol explicitly supports miner list changes between rounds: [6](#0-5) 

**Exploitation Scenario:**
1. Round N has 7 miners → encoding threshold = 7 × 2/3 = 4 (requires 4 shares)
2. Round N+1 has 5 miners (miner list changed)
3. When revealing Round N's InValues, decoding uses threshold = 5 × 2/3 = 3
4. DecodeSecret attempts to reconstruct a degree-3 polynomial using only 3 points, when it actually needs 4 points
5. Lagrange interpolation produces an incorrect result → corrupted PreviousInValue

The check at line 36 does not prevent this because it only requires `minersCount` decrypted pieces (5 in this example), but up to 7 pieces exist from the previous round. [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:** The corrupted PreviousInValue is stored and used in consensus calculations: [8](#0-7) 

InValues serve as the foundation for consensus randomness, affecting:
- Miner selection and ordering for future rounds
- Random beacon values used for block validation
- Signature aggregation in the consensus protocol

**Quantified Impact:**
- Every round transition where miner count decreases produces corrupted randomness
- Affects all consensus participants, not just specific miners
- Undermines the unpredictability guarantees of the random beacon
- May cause consensus divergence if different nodes compute different "revealed" values
- Cannot be detected by protocol participants since the wrong value appears cryptographically valid

**Severity Justification:** HIGH - This is a protocol-level consensus corruption bug that occurs automatically during normal operations (miner list changes) without requiring attacker action. It violates the critical invariant of "Correct round transitions and miner schedule integrity."

### Likelihood Explanation

**No Attacker Required:** This is a deterministic bug triggered by legitimate protocol operations. Miner list changes occur during:
- New term transitions (regularly scheduled)
- Evil miner replacement (security feature)
- Election result updates

**Reachable Entry Point:** The function is invoked automatically during round transitions: [9](#0-8) 

**Execution Certainty:**
- The bug triggers whenever: `previousRound.MinerCount > currentRound.MinerCount`
- Example: 7 miners → 5 miners produces threshold 4 → 3 mismatch
- No special permissions or timing windows required
- The protocol explicitly supports and expects miner count changes

**Probability:** HIGH - Miner list changes are not rare events but regular protocol operations occurring at term boundaries and during miner replacements.

### Recommendation

**Code Fix:** Change line 21 to use the previous round's miner count, matching the encoding logic:

```csharp
var minersCount = previousRound.RealTimeMinersInformation.Count;
```

**Invariant Check:** Add assertion to verify encoding and decoding use the same threshold:
```csharp
Assert(previousRound.RealTimeMinersInformation.Count == 
       currentRound.RealTimeMinersInformation.Count || 
       currentRound.IsMinerListJustChanged,
       "Threshold must match encoding round unless miner list changed");
```

**Alternative Fix (if miner changes must be supported):** Skip secret reconstruction when miner counts differ:
```csharp
if (previousRound.RealTimeMinersInformation.Count != currentRound.RealTimeMinersInformation.Count)
{
    Context.LogDebug(() => "Skipping InValue reveal due to miner count change");
    return;
}
```

**Test Cases:**
1. Test secret reconstruction with 7→5 miner transition
2. Test secret reconstruction with 5→7 miner transition  
3. Verify revealed InValues match off-chain computation
4. Test consensus correctness across miner list changes

### Proof of Concept

**Initial State:**
- Round 100: 7 active miners (A, B, C, D, E, F, G)
- Each miner encodes their InValue with threshold = 7 × 2/3 = 4
- All miners exchange encrypted shares

**Execution Steps:**

1. **Miner List Change:** 
   - Round 101 begins with 5 miners (A, B, C, D, E) - miners F and G removed
   - `currentRound.IsMinerListJustChanged = true`

2. **Extra Block Production:**
   - Miner A produces extra block to transition Round 100 → 101
   - Calls `GetConsensusExtraDataForNextRound`
   - Invokes `RevealSharedInValues(currentRound=100, pubkey=A)`

3. **Buggy Threshold Calculation:**
   - Line 21: `minersCount = currentRound(100).Count = 7` ❌ WRONG
   - Should be: `minersCount = previousRound(99).Count = 7` (or another value if it was different)
   - Actually uses: `minersCount = 7` (happens to be same, but wrong reference)
   - For miner B's InValue from Round 99:
     - If Round 99 had 7 miners: encoded with threshold=4
     - If Round 100 has 5 miners (wrong reference): would decode with threshold=3

**Expected Result:**
- Correctly reconstructed InValues using threshold=4
- PreviousInValue matches the actual InValue from Round 99

**Actual Result:**
- When `previousRound.Count ≠ currentRound.Count`:
  - Wrong threshold used for DecodeSecret
  - Lagrange interpolation with insufficient/excess points
  - Garbage hash value stored as PreviousInValue
  - Consensus randomness corrupted

**Success Condition:**
Verify by comparing on-chain revealed InValue with off-chain computation - they will differ when miner counts change, proving the bug.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-22)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L146-148)
```csharp
        var round = secretSharingInformation.PreviousRound;
        var minersCount = round.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L14-19)
```csharp
        public static List<byte[]> EncodeSecret(byte[] secretMessage, int threshold, int totalParts)
        {
            // Polynomial construction.
            var coefficients = new BigInteger[threshold];
            // Set p(0) = secret message.
            coefficients[0] = secretMessage.ToBigInteger();
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-48)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-14)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```
