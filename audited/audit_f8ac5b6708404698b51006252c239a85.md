### Title
Round Number Manipulation Bypasses Continuous Block Production Limits in AEDPoS Consensus

### Summary
The `ContinuousBlocksValidationProvider` skips validation when `ProvidedRound.RoundNumber ≤ 2`, but for `UpdateValue` and `TinyBlock` behaviors, no validator ensures that the round number provided in the block header matches the actual current round. A malicious miner can set the round number to 1 or 2 in their block header to bypass continuous block limits and produce unlimited blocks, breaking fair block production distribution.

### Finding Description

The vulnerability exists in the validation flow for consensus block headers:

**Root Cause Location:** [1](#0-0) 

The continuous block validation is skipped when `validationContext.ProvidedRound.RoundNumber > 2` evaluates to false. The `ProvidedRound` is sourced from the block header's consensus extra data provided by the miner: [2](#0-1) 

**Missing Validation:**
For `UpdateValue` and `TinyBlock` behaviors (the most common block production behaviors), the validation pipeline does not include round number verification: [3](#0-2) 

Only `NextRound` and `NextTerm` behaviors add the `RoundTerminateValidationProvider` which validates round numbers: [4](#0-3) 

**Why Protections Fail:**
The `UpdateValueValidationProvider` only checks cryptographic values, not round numbers: [5](#0-4) 

The continuous block limit mechanism relies on `LatestPubkeyToTinyBlocksCount.BlocksCount` becoming negative to reject blocks: [6](#0-5) 

However, this check is entirely bypassed when the round number condition fails.

**Execution Path:**
1. Miner produces 8+ continuous blocks (exceeding `MaximumTinyBlocksCount = 8`)
2. `BlocksCount` becomes negative, normally triggering rejection
3. Miner modifies their node to set `Round.RoundNumber = 1` in consensus extra data
4. Block validation runs via `ValidateBeforeExecution`
5. `ContinuousBlocksValidationProvider` sees `RoundNumber ≤ 2` and skips the check entirely
6. Block is accepted and processed using `BaseRound` from state (not the manipulated `ProvidedRound`)
7. Miner repeats indefinitely to produce unlimited continuous blocks [7](#0-6) 

### Impact Explanation

**Consensus Integrity Impact:**
This vulnerability breaks the fundamental fairness property of the AEDPoS consensus mechanism. The continuous block limit exists to prevent any single miner from dominating block production: [8](#0-7) [9](#0-8) 

**Concrete Harm:**
- **Block Production Centralization**: A malicious miner can produce 100% of blocks instead of their fair share (~1/N where N is number of miners)
- **Time Slot Starvation**: Other miners are denied their allocated time slots
- **Reward Theft**: Malicious miner receives disproportionate mining rewards (economic impact quantified by blocks produced × reward per block)
- **Censorship Capability**: Controlling all blocks allows transaction censorship
- **Network Decentralization**: Defeats the multi-miner consensus model

**Who Is Affected:**
- All honest miners lose expected block production opportunities and rewards
- Network users face censorship risk
- Overall chain security and decentralization are compromised

**Severity Justification:**
HIGH severity because it compromises a core consensus invariant (fair block production distribution) that is critical to network security and decentralization.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner in the consensus set
- Must run modified node software to manipulate consensus extra data
- No additional permissions or special conditions required

**Attack Complexity:**
- Low: Simple modification of round number field in block header
- The manipulation point is clear in the code generation flow: [10](#0-9) [11](#0-10) 

A malicious miner can intercept the generated extra data and modify `RoundNumber` before block submission.

**Feasibility Conditions:**
- Exploitable in any round > 2 (i.e., always after initial network bootstrap)
- No race conditions or timing requirements
- Deterministic and repeatable
- Works for both `UpdateValue` and `TinyBlock` behaviors (the primary block production modes) [12](#0-11) 

**Detection Constraints:**
- Block appears valid to other nodes (passes all validation)
- Difficult to attribute malicious intent (could claim software bug)
- Detection requires comparing `ProvidedRound.RoundNumber` with `BaseRound.RoundNumber`

**Economic Rationality:**
- High reward: Monopolize block production and mining rewards
- Low cost: No staking penalty, no special resources required
- Rational for any miner seeking to maximize revenue

**Probability Assessment:**
HIGH likelihood - the attack is straightforward, requires only standard miner privileges, and provides immediate economic benefit with low detection risk.

### Recommendation

**Primary Fix - Add Round Number Validation:**
For `UpdateValue` and `TinyBlock` behaviors, validate that the provided round number matches the current round from state. Add this check in `ValidateBeforeExecution`:

```csharp
// After line 60 in AEDPoSContract_Validation.cs
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue || 
    extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    if (extraData.Round.RoundNumber != baseRound.RoundNumber)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Round number mismatch: provided {extraData.Round.RoundNumber}, expected {baseRound.RoundNumber}" 
        };
    }
}
```

**Alternative Fix - Remove Round Number Dependency:**
Modify `ContinuousBlocksValidationProvider` to not rely on `ProvidedRound.RoundNumber` for the skip condition. Instead, use `BaseRound.RoundNumber` (which comes from trusted state):

```csharp
// Line 13 in ContinuousBlocksValidationProvider.cs
if (validationContext.BaseRound.RoundNumber > 2 && // Use BaseRound instead of ProvidedRound
    validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**Invariant Checks:**
- Assert: `ProvidedRound.RoundNumber == BaseRound.RoundNumber` for UpdateValue/TinyBlock behaviors
- Assert: Round number transitions are monotonic (BaseRound.RoundNumber ≤ ProvidedRound.RoundNumber ≤ BaseRound.RoundNumber + 1)

**Test Cases:**
1. Test that blocks with manipulated round numbers are rejected for UpdateValue behavior
2. Test that blocks with manipulated round numbers are rejected for TinyBlock behavior  
3. Test that legitimate blocks in rounds 1-2 still pass validation
4. Test that continuous block limits are enforced regardless of provided round number
5. Regression test for multi-miner scenario with round number validation

### Proof of Concept

**Initial State:**
- Network is in round 100 (well past initial rounds)
- Malicious miner M has produced 8 continuous blocks
- `LatestPubkeyToTinyBlocksCount.Pubkey = M`, `BlocksCount = -1` (limit exceeded)
- `BaseRound.RoundNumber = 100`

**Attack Steps:**
1. Miner M generates consensus command for next block via `GetConsensusCommand`
2. System returns `UpdateValue` or `TinyBlock` behavior
3. `GetConsensusBlockExtraData` generates extra data with `Round.RoundNumber = 100`
4. **Malicious modification**: M's modified node changes `Round.RoundNumber` to `1` in the extra data
5. M produces block with modified consensus extra data
6. Block validation runs `ValidateBeforeExecution`
7. `ContinuousBlocksValidationProvider.ValidateHeaderInformation` is called
8. Check at line 13 evaluates: `1 > 2` → FALSE
9. Entire continuous block validation is skipped
10. Block passes all validation and is accepted
11. `ProcessUpdateValue` or `ProcessTinyBlock` executes using `BaseRound` (round 100 from state)
12. Miner M successfully produces block #9, #10, #11... without limit

**Expected Result:**
Block should be rejected with message "Sender produced too many continuous blocks."

**Actual Result:**
Block is accepted because continuous block validation is bypassed.

**Success Condition:**
Miner M can produce unlimited continuous blocks by setting `ProvidedRound.RoundNumber ≤ 2` in every block header, completely circumventing the `MaximumTinyBlocksCount` limit and monopolizing block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L35-37)
```csharp
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-82)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L29-31)
```csharp
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L14-16)
```csharp
        var round = new Round
        {
            RoundNumber = RoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-62)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
