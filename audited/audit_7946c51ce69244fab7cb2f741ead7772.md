### Title
NextRound Validation Bypass via RoundId Collision Allows Invalid Time Slot Distribution

### Summary
The consensus validation logic incorrectly uses `RoundId` equality to determine whether a new round is being proposed, but does not enforce that NextRound behavior must produce a different `RoundId`. A malicious block producer can craft a `ProvidedRound` with the same `RoundId` as `BaseRound` by manipulating `ExpectedMiningTime` values, bypassing critical time slot validation (`CheckRoundTimeSlots`) and introducing a round with invalid time slot distribution into the consensus state.

### Finding Description

The vulnerability exists in the interaction between `TimeSlotValidationProvider` and the `RoundId` calculation mechanism.

**Root Cause:**

The `RoundId` property is calculated as the sum of all miners' `ExpectedMiningTime.Seconds` values: [1](#0-0) 

When validating NextRound behavior, `TimeSlotValidationProvider` uses `RoundId` equality to determine if it's a new round or an update to the current round: [2](#0-1) 

If `ProvidedRound.RoundId == BaseRound.RoundId`, the critical `CheckRoundTimeSlots()` validation is skipped, and only `CheckMinerTimeSlot()` is executed against the `BaseRound`.

**Why Protections Fail:**

For NextRound behavior, the validation providers added are: [3](#0-2) 

None of these validators explicitly check that `ProvidedRound.RoundId` must differ from `BaseRound.RoundId` for NextRound behavior:

1. `RoundTerminateValidationProvider` only validates `RoundNumber` increment, not `RoundId`: [4](#0-3) 

2. `NextRoundMiningOrderValidationProvider` only checks `FinalOrderOfNextRound` consistency: [5](#0-4) 

The `CheckRoundTimeSlots()` method is critical as it validates:
- All miners have valid `ExpectedMiningTime`
- Mining interval is positive
- Time slots are approximately equal (variance within tolerance) [6](#0-5) 

**Execution Path:**

1. Attacker crafts malicious `ProvidedRound` with `RoundNumber = BaseRound.RoundNumber + 1`
2. Sets `ExpectedMiningTime` values that sum to `BaseRound.RoundId` but with invalid distribution (e.g., unequal intervals)
3. Submits block with NextRound behavior
4. Validation runs through `ValidateBeforeExecution`: [7](#0-6) 

5. `TimeSlotValidationProvider` sees matching `RoundId`, skips `CheckRoundTimeSlots()`
6. `RoundTerminateValidationProvider` passes (only checks `RoundNumber` increment)
7. Malicious round accepted and stored in state: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Compromise:**

Once the malicious round is accepted into state, it becomes the `BaseRound` for subsequent blocks. The invalid time slot distribution allows the attacker to:

1. **Manipulate Mining Windows**: Create unequal time slots giving certain miners (including themselves) unfair advantages or disadvantages
2. **Break Time-Based Consensus**: Set mining intervals to zero or negative values, disrupting the temporal ordering guarantees
3. **Persist Invalid State**: The malicious round persists in `State.Rounds`, affecting all subsequent consensus operations until a new NextRound overwrites it

**Affected Parties:**
- All miners in the compromised round face unfair time slot allocation
- Network consensus integrity is undermined
- Block production schedule becomes unpredictable

**Severity Justification:**
This is a Medium severity issue because:
- It requires a malicious block producer (privileged position but realistic in PoS/DPoS)
- Impact is limited to one round's time slot distribution (not permanent consensus takeover)
- Requires active exploitation during NextRound transition window
- Does not directly lead to fund theft but compromises consensus fairness

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active block producer with mining permission
- Must be the designated extra block producer for the current round (probability 1/N where N = miner count)
- Must modify consensus client to craft malicious round data instead of using `GenerateNextRoundInformation`: [9](#0-8) 

**Attack Complexity:**
- Moderate - requires understanding of `RoundId` calculation and validation flow
- Attacker must compute `ExpectedMiningTime` values that sum to target `RoundId` (mathematical constraint satisfaction)
- Example: For 5 miners with `BaseRound.RoundId = 5040`, attacker could use times `[800, 1060, 1060, 1060, 1060]` instead of legitimate sequential times

**Feasibility Conditions:**
- Attacker must be producing the NextRound block (periodic opportunity)
- No cryptographic or economic barriers beyond being a selected BP
- Validation logic is deterministic and bypassable as shown

**Detection Constraints:**
- Malicious round data appears structurally valid (all required fields present)
- `RoundNumber` increments correctly, masking the RoundId manipulation
- Other validators may not immediately detect time slot inequality until subsequent blocks

**Probability Assessment:**
- Medium likelihood given the need for BP position but straightforward exploitation
- Opportunity arises at every round transition for eligible miners
- No runtime detection mechanisms exist for this specific attack vector

### Recommendation

**Immediate Fix:**

Add explicit `RoundId` validation for NextRound behavior in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // NEW: Explicitly check RoundId must differ for NextRound
    if (validationContext.BaseRound.RoundId == extraData.Round.RoundId)
        return new ValidationResult { Message = "RoundId must differ for next round." };
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

Location to modify: [4](#0-3) 

**Additional Hardening:**

1. Always call `CheckRoundTimeSlots()` for NextRound behavior regardless of `RoundId`, since it's a new round by definition
2. Add assertion in `ProcessNextRound` that incoming round's `RoundId` differs from current round
3. Add unit tests verifying NextRound with matching `RoundId` is rejected

### Proof of Concept

**Initial State:**
- Current round N in state with 5 miners
- `BaseRound.RoundId = 5040` (sum of `ExpectedMiningTime.Seconds`: 1000+1004+1008+1012+1016)
- `BaseRound.RoundNumber = 100`
- Attacker is designated extra block producer for round 100

**Attack Steps:**

1. Attacker's turn to produce NextRound block arrives
2. Instead of calling legitimate `GenerateNextRoundInformation`, attacker crafts:
   ```
   ProvidedRound:
     RoundNumber: 101 (= BaseRound.RoundNumber + 1)
     RealTimeMinersInformation:
       Miner1: ExpectedMiningTime.Seconds = 800  (short slot)
       Miner2: ExpectedMiningTime.Seconds = 1060 (long slot)
       Miner3: ExpectedMiningTime.Seconds = 1060
       Miner4: ExpectedMiningTime.Seconds = 1060
       Miner5: ExpectedMiningTime.Seconds = 1060
     RoundId: 800+1060+1060+1060+1060 = 5040 (MATCHES BaseRound!)
     InValues: all null
     FinalOrderOfNextRound: set consistently
   ```

3. Submit block with `AElfConsensusBehaviour.NextRound` and crafted `ProvidedRound`

**Validation Execution:**

4. `TimeSlotValidationProvider` line 14: `ProvidedRound.RoundId (5040) != BaseRound.RoundId (5040)` → FALSE
5. Enters else branch, calls `CheckMinerTimeSlot` with `BaseRound` (not `CheckRoundTimeSlots` on `ProvidedRound`)
6. `RoundTerminateValidationProvider`: checks `100 + 1 == 101` → PASS, checks InValues null → PASS
7. All validations pass

**Expected vs Actual:**
- **Expected**: Malicious round rejected due to unequal time slots (260-second vs 4-second interval violates CheckRoundTimeSlots tolerance)
- **Actual**: Malicious round accepted into `State.Rounds[101]` with compromised time slot distribution

**Success Condition:**
Query `GetRoundInformation(101)` returns round with ExpectedMiningTime values `[800, 1060, 1060, 1060, 1060]` showing successful insertion of invalid time slot distribution.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-60)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```
