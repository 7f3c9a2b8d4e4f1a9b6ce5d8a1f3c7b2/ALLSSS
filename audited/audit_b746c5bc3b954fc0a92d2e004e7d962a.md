### Title
Evil Nodes Bypass Punishment During Term Transitions Due to Missing Banned Pubkey Check in GetVictories Fallback Logic

### Summary
When the Election contract's `GetVictories` method encounters insufficient valid candidates during term transitions, it falls back to selecting backup miners from current miners and initial miners without checking if they are banned. This allows evil nodes marked via `State.BannedPubkeyMap` to continue as miners in the next term, completely bypassing the punishment mechanism.

### Finding Description

**Root Cause**: The vulnerability exists in the `GetVictories` method's fallback logic that selects backup miners when there aren't enough valid candidates. [1](#0-0) 

When valid candidates are insufficient (line 62), the fallback selects backups from current miners (line 66) and initial miners (lines 68-69) without checking `State.BannedPubkeyMap`. The evil node marking process sets this flag and removes nodes from candidates: [2](#0-1) 

However, banned nodes remain in `State.InitialMiners` and the current miner list, making them eligible for backup selection.

**Correct Implementation Exists Elsewhere**: The same file's `GetMinerReplacementInformation` method demonstrates the correct approach by filtering banned pubkeys when selecting from initial miners: [3](#0-2) 

**Term Transition Flow**: During term changes, `GenerateFirstRoundOfNextTerm` calls `TryToGetVictories` to obtain the new miner list: [4](#0-3) 

The returned list is wrapped by `NextTermInput.Create()`: [5](#0-4) 

And directly used to set the miner list without additional validation: [6](#0-5) 

**Why Miner Replacement Doesn't Help**: The miner replacement mechanism only activates during same-term transitions, not during term changes: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation**: Evil nodes that should be excluded continue participating in block production, undermining the punishment mechanism designed to maintain network security.

**Reward Misallocation**: Banned miners continue earning mining rewards despite being marked as malicious actors, as evidenced by the reward distribution flow: [8](#0-7) 

**Severity Justification**: CRITICAL because:
- Completely bypasses the evil node punishment system
- Malicious nodes continue attacking across multiple terms
- Triggered automatically during normal term transitions when candidate participation is low
- No privileged access required beyond initial marking (which happens through legitimate governance)

**Affected Parties**: Network security, legitimate miners facing unfair competition, token holders whose rewards fund banned nodes, and overall network trustworthiness.

### Likelihood Explanation

**Reachable Entry Point**: Triggered through public term transition mechanism occurring automatically based on blockchain time.

**Feasible Preconditions**:
1. At least one miner marked as evil (realistic - happens through governance or automatic detection)
2. Valid candidates < required miners count (realistic during low participation periods)
3. Term transition occurs (happens regularly in normal operation)

**Execution Practicality**: 
- No special attacker capabilities required
- Triggered automatically during term transitions
- Low candidate participation is realistic, especially in early network stages or low voter engagement periods

**Detection Constraints**: Occurs silently without errors or events, making detection difficult without explicit monitoring.

**Probability**: HIGH - Will occur deterministically whenever insufficient candidates exist during term transition and at least one banned node remains in backup pools.

### Recommendation

**Immediate Fix**: Add banned pubkey filtering to the `GetVictories` fallback logic in `contract/AElf.Contracts.Election/ViewMethods.cs` at lines 66-69:

```csharp
var backups = currentMiners
    .Where(k => !validCandidates.Contains(k))
    .Where(k => !State.BannedPubkeyMap[k])  // ADD THIS CHECK
    .ToList();
    
if (State.InitialMiners.Value != null)
    backups.AddRange(
        State.InitialMiners.Value.Value
            .Select(k => k.ToHex())
            .Where(k => !backups.Contains(k))
            .Where(k => !State.BannedPubkeyMap[k]));  // ADD THIS CHECK
```

**Additional Invariant Checks**:
1. Add assertion in `ProcessNextTerm` verifying no banned pubkeys in new miner list
2. Add event emission when banned nodes are filtered during victory selection
3. Implement monitoring to detect banned nodes in miner lists

**Test Cases**:
1. Mark current miner as evil, trigger term transition with insufficient candidates, verify exclusion
2. Mark initial miner as evil, trigger term transition with insufficient candidates, verify exclusion
3. Multiple banned miners with insufficient candidates, verify all filtered
4. Verify correct miner count after filtering banned nodes

### Proof of Concept

**Initial State**:
- 17 miners required, current term has 17 including miner A
- Miner A exists in `State.InitialMiners` from genesis
- Only 10 candidates have votes

**Attack Steps**:

1. **Mark Evil Node** (Term N): Emergency response organization calls `RemoveEvilNode(A)`, setting `State.BannedPubkeyMap[A] = true` and removing A from candidates

2. **Term Transition** (N â†’ N+1): Blockchain time triggers term change, invoking `GenerateFirstRoundOfNextTerm`

3. **GetVictories Execution**: Returns 10 valid candidates, needs 7 more (diff=7), fallback activates without checking `State.BannedPubkeyMap[A]`, includes A in backup list

4. **New Term Setup**: `NextTermInput.Create()` wraps round including A, `ProcessNextTerm` sets miner list with A included

5. **Result**:
   - **Expected**: Miner A excluded from term N+1
   - **Actual**: Miner A active in term N+1, produces blocks, earns rewards
   
**Success Condition**: Query `GetCurrentMinerList` after term transition shows banned pubkey A, proving punishment bypass.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L385-392)
```csharp
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-310)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-190)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```
