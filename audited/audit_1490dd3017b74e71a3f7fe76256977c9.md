### Title
Double Withdrawal Vulnerability in Non-Locked Token Voting Items

### Summary
The `Withdraw()` function in VoteContract lacks a check to verify that `IsWithdrawn` is false before processing a withdrawal. For voting items with `IsLockToken = false` (delegated voting), this allows the Sponsor to withdraw the same vote multiple times, corrupting voting results by incorrectly decrementing vote amounts, voter counts, and option tallies each time. [1](#0-0) 

### Finding Description

The `Withdraw()` function retrieves the voting record and checks only if it exists (line 194), then validates permissions (lines 197-200), but **never verifies that `votingRecord.IsWithdrawn` is false** before proceeding. [2](#0-1) 

The function unconditionally sets `IsWithdrawn = true` at line 203 and updates voting results at lines 215-220, subtracting the vote amount from totals: [3](#0-2) 

**For `IsLockToken = true` voting items:** The vulnerability is NOT exploitable because token unlocking at lines 224-231 would fail on the second withdrawal attempt. The virtual address would have insufficient balance, causing `ModifyBalance` to throw an assertion error and revert the entire transaction. [4](#0-3) [5](#0-4) 

**For `IsLockToken = false` voting items:** The vulnerability IS exploitable because no token locking/unlocking occurs. Only the Sponsor can call `Withdraw()` for these items, and if the Sponsor (either due to a bug or malicious intent) calls `Withdraw()` multiple times on the same `VoteId`:
- First call succeeds normally
- Second call also succeeds (no `IsWithdrawn` check blocks it)
- Voting results are decremented again: `VotesAmount`, `Results[option]`, and potentially `VotersCount`
- If sufficient other votes exist to prevent underflow in the checked subtraction operations, the transaction completes successfully with corrupted voting data [6](#0-5) 

The Election contract uses `IsLockToken = false` for its voting mechanism: [7](#0-6) 

### Impact Explanation

**Voting Result Corruption:** Each duplicate withdrawal incorrectly decrements:
- `VotesAmount` by the vote amount
- `Results[option]` by the vote amount  
- `VotersCount` by 1 (if no other active votes remain from that voter)

This breaks the integrity of voting tallies. In the Election system context, this could:
- Misrepresent the actual vote distribution among candidates
- Cause incorrect election outcomes if vote counts are manipulated
- Undermine trust in the governance system

**Affected Parties:** Any voting item with `IsLockToken = false`, particularly the Election contract's miner election voting.

**Severity:** High - While requiring Sponsor access, the impact on voting integrity is severe, and the Election contract's use of this pattern makes it a critical system component at risk.

### Likelihood Explanation

**Attacker Capabilities:** The "attacker" must be the Sponsor of an `IsLockToken = false` voting item, which is typically a contract address with special privileges.

**Attack Complexity:** Low - Simply calling `Withdraw()` multiple times with the same `VoteId`.

**Feasibility Conditions:**
- Sponsor contract has a bug that calls `Withdraw()` multiple times for the same vote
- Sponsor is compromised or malicious
- Sufficient other votes exist to prevent underflow exceptions

**Probability:** Medium - This requires the Sponsor role to be compromised or contain a bug, but the lack of defensive checks in the Vote contract means any such bug in dependent contracts could trigger this vulnerability. Given that Election contract uses this pattern, any future bugs in election vote withdrawal logic could exploit this.

### Recommendation

**Immediate Fix:** Add an assertion at the beginning of the `Withdraw()` function to check that the vote has not already been withdrawn:

```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    Assert(!votingRecord.IsWithdrawn, "Vote already withdrawn.");  // ADD THIS CHECK
    
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    // ... rest of function
}
```

Insert this check immediately after retrieving the voting record and before any state modifications.

**Test Case:** Add a test that attempts to withdraw the same vote twice for an `IsLockToken = false` voting item and verifies the second call reverts with "Vote already withdrawn."

### Proof of Concept

**Initial State:**
1. Register a voting item with `IsLockToken = false` (delegated voting)
2. Sponsor calls `Vote()` to record a vote with amount = 100
3. Other votes exist with total `VotesAmount = 1000`

**Exploitation Steps:**
1. Sponsor calls `Withdraw(voteId)` - succeeds, `VotesAmount = 900`, `Results[option] = X - 100`
2. Sponsor calls `Withdraw(voteId)` again with same `voteId` - succeeds (NO CHECK)
3. `VotesAmount = 800` (should still be 900)
4. `Results[option] = X - 200` (should be X - 100)

**Expected Result:** Second `Withdraw()` should fail with "Vote already withdrawn."

**Actual Result:** Second `Withdraw()` succeeds, corrupting voting results by double-decrementing all tallies.

**Success Condition:** Query voting results after double withdrawal shows incorrectly decremented values without any transaction revert.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-68)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```
