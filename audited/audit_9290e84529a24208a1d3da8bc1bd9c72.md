### Title
ACS1 Method Fee Management Methods Are Non-Functional Stub Implementations Despite Standard Documentation

### Summary
The NFT contract implements ACS1 (Transaction Fee Standard) interface methods `SetMethodFee` and `ChangeMethodFeeController` as silent no-ops that return success without performing any operations, despite the ACS1 standard documentation explicitly describing these methods as functional fee management mechanisms. This creates a documentation mismatch where the contract appears to support standard ACS1 governance but actually provides immutable hardcoded fees.

### Finding Description

The NFT contract's ACS1 implementation contains methods that are documented in the ACS1 standard but implemented as non-functional stubs: [1](#0-0) [2](#0-1) [3](#0-2) 

The ACS1 standard documentation explicitly describes the expected behavior: [4](#0-3) [5](#0-4) 

In contrast, properly implemented system contracts like Profit and Vote follow the documented pattern with full state management, authorization checks, and actual functionality: [6](#0-5) [7](#0-6) 

The NFT contract only implements hardcoded fee returns without override capability: [8](#0-7) 

The documentation explicitly describes both implementation approaches, with the recommended approach being state-based fee management: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Governance Limitation Impact:**
- The Create method fee is permanently fixed at 100 ELF and cannot be adjusted through standard governance mechanisms
- Governance organizations (Parliament) cannot respond to economic changes requiring fee adjustments
- The contract falsely advertises ACS1 compliance, misleading integrators who expect standard fee management capabilities

**Operational Impact:**
- Methods return successful responses (`Empty()`) without performing any state changes, violating the principle of least surprise
- Users calling `SetMethodFee` believe the operation succeeded but no configuration change occurs
- No error messages indicate the methods are non-functional, creating silent failures

**Severity Justification (Low):**
- No direct fund theft or loss possible
- No unauthorized operations can be performed
- Impact limited to inability to perform authorized fee adjustments
- Affects operational governance capability rather than security invariants

### Likelihood Explanation

**Reachability:**
- The methods are publicly exposed as part of the ACS1 interface
- Any caller can invoke these methods and receive success responses

**Execution Practicality:**
- The mismatch exists permanently - every call to these methods results in silent no-op
- Governance attempting fee adjustments will encounter this limitation immediately
- No special preconditions required - the issue manifests on any invocation

**Detection Constraints:**
- The silent success responses make detection non-obvious
- Callers must verify state changes to discover the methods are non-functional
- No tests exist validating the ACS1 implementation functionality

**Probability Assessment:**
- Guaranteed to occur whenever governance attempts fee management
- The hardcoded 100 ELF fee cannot be changed without contract upgrade
- Impact is certain but limited to governance operational capability

### Recommendation

**Option 1: Implement Full ACS1 Functionality (Recommended)**

Add state management for fee storage in the contract state file:
```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

Implement `SetMethodFee` with proper validation, authorization, and state updates following the pattern used in Profit/Vote contracts: [6](#0-5) 

Update `GetMethodFee` to check state first, then fall back to hardcoded defaults: [7](#0-6) 

Implement controller initialization and management: [11](#0-10) 

**Option 2: Explicitly Indicate Unsupported Methods**

If fixed fees are intentional, make methods throw assertions:
```csharp
public override Empty SetMethodFee(MethodFees input)
{
    Assert(false, "NFT contract uses fixed method fees. Fee changes require contract upgrade.");
    return new Empty();
}
```

**Option 3: Document the Limitation**

Add XML comments explicitly stating the methods are not functional and fees are immutable.

**Test Cases to Add:**
1. Verify `SetMethodFee` actually updates state and affects `GetMethodFee` results
2. Verify `ChangeMethodFeeController` updates the controller authority
3. Test authorization - unauthorized calls should fail
4. Test that governance proposals can successfully modify fees

### Proof of Concept

**Step 1: Query Current Method Fee**
```
Call NFTContract.GetMethodFee("Create")
Result: Returns MethodFees with 100 ELF BasicFee
```

**Step 2: Query Fee Controller**
```
Call NFTContract.GetMethodFeeController(Empty)
Result: Returns empty AuthorityInfo (no controller set)
```

**Step 3: Attempt to Set Method Fee**
```
Call NFTContract.SetMethodFee(new MethodFees { 
    MethodName = "Create", 
    Fees = { new MethodFee { Symbol = "ELF", BasicFee = 50_00000000 } }
})
Result: Returns Empty() - appears successful
```

**Step 4: Verify No State Change**
```
Call NFTContract.GetMethodFee("Create") again
Expected: Returns 50 ELF if SetMethodFee worked
Actual: Still returns 100 ELF - no change occurred
```

**Step 5: Verify Documentation Mismatch**

Compare the implementation against the documented behavior: [4](#0-3) 

The documentation states the method should "override all fees" but the implementation performs no override operation.

**Success Condition:**
The proof demonstrates that methods return success responses without performing documented operations, confirming the documentation mismatch.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** protobuf/acs1.proto (L22-23)
```text
    rpc SetMethodFee (MethodFees) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/acs1.proto (L25-27)
```text
    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var methodFees = State.TransactionFees[input.Value];
        if (methodFees != null) return methodFees;

        switch (input.Value)
        {
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L71-83)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        ValidateContractState(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L279-288)
```text
A more recommended implementation needs to define an ``MappedState`` in
the State file for the contract:

.. code:: c#

   public MappedState<string, MethodFees> TransactionFees { get; set; }

Modify the ``TransactionFees`` data structure in the ``SetMethodFee``
method, and return the value in the ``GetMethodFee`` method.

```

**File:** docs-sphinx/reference/acs/acs1.rst (L315-326)
```text

   public override Empty SetMethodFee(MethodFees input)
   {
     foreach (var symbolToAmount in input.Fees)
     {
        AssertValidToken(symbolToAmount.Symbol, symbolToAmount.BasicFee); 
     }
     RequiredMethodFeeControllerSet();
     Assert(Context.Sender ==             State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
       State.TransactionFees[input.MethodName] = input;
       return new Empty();
   }
```
