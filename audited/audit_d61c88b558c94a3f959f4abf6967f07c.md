### Title
First Round Logic Allows Double Mining in Same Round via Flawed Time Slot Calculation

### Summary
The `IsCurrentMiner` function in the AEDPoS consensus contract contains a critical flaw in its first round validation logic that allows miners who have already produced blocks in the first round of a term to mine again in the same round. The first round logic (lines 191-216) bypasses all normal time slot checks and fails to verify whether the miner has already mined, enabling a consensus violation where a single miner can produce multiple blocks per round.

### Finding Description

The vulnerability exists in the first round special case logic of the `IsCurrentMiner` private method: [1](#0-0) 

**Root Cause:**

The first round logic at line 198 finds the latest miner that has already mined (excluding the current pubkey), but crucially does NOT check if the current miner has already produced a block in this round. It only checks:
1. If it's round number 1
2. If at least one other miner has mined
3. If the calculated `passedSlotsCount` matches one of two specific formulas [2](#0-1) 

The exclusion criterion `i.Pubkey != pubkey` only prevents the current miner from being selected as `latestMinedInfo`, but doesn't check if the current miner has entries in `ActualMiningTimes`.

**Why Normal Protections Fail:**

1. The time slot validation provider explicitly bypasses checks for the first round: [3](#0-2) 

2. The `ProcessUpdateValue` method has no check preventing multiple mining calls per round - it simply appends to `ActualMiningTimes`: [4](#0-3) 

3. The first round logic's calculation formulas (lines 209-210) add `minersCount` to handle wraparound scenarios, creating two acceptable `passedSlotsCount` values. These conditions can be satisfied even when a miner has already mined earlier in the round.

### Impact Explanation

**Consensus Integrity Violation:**
A miner in the first round of any term can produce multiple blocks in the same round, violating the core consensus invariant that each miner produces exactly one block per round. This allows:

1. **Unfair Block Rewards**: The double-mining miner receives rewards for multiple blocks while other miners get only one, distorting the economic incentives and reward distribution
2. **Consensus Manipulation**: By controlling multiple block production slots in the same round, an attacker can manipulate transaction ordering, round transitions, and the LIB calculation
3. **Chain Instability**: Other miners may reject these blocks as invalid once they discover the double-mining, leading to chain forks and consensus failures

**Affected Parties:**
- All honest miners lose potential block rewards
- Network consensus becomes unreliable during term transitions
- Applications relying on fair miner rotation face security risks

**Severity:** CRITICAL - This breaks the fundamental consensus rule during every term transition (first round of each term), which occurs regularly in the protocol lifecycle.

### Likelihood Explanation

**Attacker Capabilities:**
Any legitimate miner in the network can exploit this vulnerability. No special privileges beyond normal mining rights are required.

**Attack Complexity:**
LOW - The attack sequence is straightforward:
1. Wait for a new term to begin (first round)
2. Mine a block legitimately during your assigned time slot
3. Wait for another miner with higher order to mine
4. Calculate the exact time when `passedSlotsCount` matches the formula conditions (2-3 specific time points)
5. Mine a second block via the first round logic bypass
6. Receive double rewards

**Feasibility Conditions:**
- Occurs naturally during term transitions (first round of each term)
- Requires only timing coordination, which miners already perform for normal mining
- No transaction costs beyond normal block production
- Detection is difficult as the blocks appear valid individually

**Probability:** HIGH - The vulnerability is deterministically exploitable in every first round of every term, making it a recurring attack vector throughout the blockchain's operation.

### Recommendation

**Immediate Fix:**
Add a check in the first round logic to prevent double mining:

```csharp
// Line 191-216 replacement
if (currentRound.RoundNumber == 1)
{
    Context.LogDebug(() => "First round");
    
    // NEW CHECK: Prevent double mining in same round
    var currentMinerInfo = currentRound.RealTimeMinersInformation[pubkey];
    if (currentMinerInfo.ActualMiningTimes.Any())
    {
        Context.LogDebug(() => "[CURRENT MINER]ALREADY MINED IN THIS ROUND");
        return false;
    }
    
    var latestMinedInfo = currentRound.RealTimeMinersInformation.Values
        .OrderByDescending(i => i.Order)
        .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
    // ... rest of logic
}
```

**Additional Invariant Checks:**
1. In `ProcessUpdateValue`, add assertion: `Assert(minerInRound.ActualMiningTimes.Count == 0 || currentRound.RoundNumber > 1, "Double mining attempt detected");`
2. In `TimeSlotValidationProvider.CheckMinerTimeSlot`, remove the blanket bypass for first round and apply proper checks

**Test Cases:**
1. Verify that a miner who has already mined in round 1 cannot mine again via first round logic
2. Test that `ActualMiningTimes.Any()` check correctly prevents duplicate mining
3. Validate that the fix doesn't break legitimate recovery scenarios for missed time slots

### Proof of Concept

**Initial State:**
- Network in first round of a new term (RoundNumber = 1, TermNumber = N)
- 5 miners with orders 1, 2, 3, 4, 5
- Mining interval = 4000ms

**Attack Sequence:**

1. **T0 (Block Height H):** Attacker (order 2) mines legitimately at their expected time slot
   - `IsCurrentMiner` returns true via normal time slot check (lines 161-167)
   - `UpdateValue` called, adding T0 to `ActualMiningTimes[0]`
   - `ProducedBlocks` incremented to 1

2. **T0 + 12000ms (Height H+3):** Miner with order 5 mines their block
   - Round is still round 1 (no NextRound called yet)
   - Attacker's `ActualMiningTimes = [T0]`

3. **T0 + 16000ms:** Attacker attempts second mining in same round
   - Normal time slot check fails (T0 + 4000ms already passed)
   - Extra block check fails (not extra block producer)
   - Saving time check fails
   - **First round logic executes:**
     - `latestMinedInfo` = Miner order 5 (highest order that mined, excluding attacker)
     - `latestMinedOrder` = 5, `currentMinerOrder` = 2
     - `passedSlotsCount` = (T0+16000 - (T0+12000)) / 4000 = 1... wait this needs recalculation
     
Let me recalculate properly: If miner 5 mined at T0+12000, and current time is T0+16000 or T0+20000:
    - `passedSlotsCount` = 1 or 2
    - Formula checks: `2-5+1+5=3` or `2-5+5=2`
    - At T0+20000: `passedSlotsCount = (T0+20000-(T0+12000))/4000 = 2` âœ“ Matches formula 2!
   - `IsCurrentMiner` returns TRUE via first round logic
   
4. **Result:** Attacker mines second block at height H+5
   - `UpdateValue` adds T0+20000 to `ActualMiningTimes[1]`
   - `ProducedBlocks` incremented to 2
   - Attacker receives double rewards for same round

**Expected vs Actual:**
- **Expected:** Attacker can only mine once per round, `IsCurrentMiner` returns false for second attempt
- **Actual:** `IsCurrentMiner` returns true via first round bypass, allowing second block production and double rewards

**Success Condition:** `ActualMiningTimes.Count == 2` and `ProducedBlocks == 2` for attacker in same round (RoundNumber = 1).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L191-216)
```csharp
        // If current round is the first round of current term.
        if (currentRound.RoundNumber == 1)
        {
            Context.LogDebug(() => "First round");

            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
                {
                    Context.LogDebug(() => "[CURRENT MINER]FIRST ROUND");
                    return true;
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L39-39)
```csharp
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-251)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
```
