### Title
TokenHash Collision via Ambiguous String Concatenation Causes NFT State Corruption

### Summary
The `CalculateTokenHash` function uses undelimited string concatenation of symbol and tokenId, allowing different (symbol, tokenId) pairs to produce identical hashes when NFT symbol lengths vary. This enables multiple distinct NFTs to share the same storage slot, corrupting ownership data, balances, and metadata when protocols with `IsTokenIdReuse=true` mint colliding tokenIds.

### Finding Description

The root cause lies in the tokenHash calculation mechanism. [1](#0-0) 

The hash is computed by concatenating symbol and tokenId without a delimiter. NFT symbols follow the format `{2-letter-code}{number}`, where the number portion has variable length. [2](#0-1) 

The number length starts at 9 digits and increases over time. [3](#0-2) [4](#0-3) 

This creates ambiguous concatenation scenarios:
- Symbol "AR100000000" (9-digit suffix) + tokenId 123 → "AR100000000123"  
- Symbol "AR1000000001" (10-digit suffix) + tokenId 23 → "AR100000000123"

Both produce identical hash inputs, resulting in the same tokenHash key.

In `PerformMint`, this tokenHash is used to retrieve and store NFTInfo. [5](#0-4) 

The uniqueness check only verifies if the hash exists, not the actual (symbol, tokenId) pair. [6](#0-5) 

When `IsTokenIdReuse=true` for a protocol, this check is bypassed, and the code proceeds to modify existing NFTInfo from a completely different protocol. [7](#0-6) 

The corrupted NFTInfo and balances are then stored. [8](#0-7) 

All state maps use this flawed tokenHash as the key. [9](#0-8) 

No validation confirms the retrieved NFTInfo's symbol and tokenId match the requested values - there are no such checks in the codebase.

### Impact Explanation

**Critical State Corruption:**
- Multiple distinct NFTs (different protocols and tokenIds) share the same storage slot in `State.NftInfoMap[tokenHash]`
- Balance mappings in `State.BalanceMap[tokenHash]` are mixed between unrelated NFTs
- Allowances, assembled NFTs/FTs, and all token-specific state become shared

**Ownership and Value Corruption:**
- When Protocol B mints a colliding tokenId, it increments the quantity and adds its minter to Protocol A's NFTInfo
- Transfers of one NFT affect balances of the other
- Burns can destroy the wrong NFT's quantity
- Users querying GetNFTInfo receive incorrect symbol/tokenId data

**Severity Justification:**
This violates the critical invariant of "NFT uniqueness and ownership checks." The vulnerability enables:
- Theft: Attackers can manipulate balances to claim ownership of victim's NFTs
- State corruption: Permanent mixing of unrelated NFT data
- Loss of funds: Burns and transfers affect wrong tokens
- Protocol breakdown: NFT identity becomes ambiguous

All NFT holders across different protocols are affected when collisions occur.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a minter for a protocol with `IsTokenIdReuse=true`
- Can create such a protocol or be added to an existing one's minter list
- No special system privileges required

**Attack Complexity:**
- Straightforward: Calculate colliding (symbol, tokenId) pair using public symbol format rules
- Symbol format and generation logic are observable on-chain
- Attacker simply mints with the calculated colliding tokenId

**Feasibility Conditions:**
- Guaranteed to occur naturally: As protocols are created, symbol number lengths WILL transition from 9 to 10+ digits
- Both 9-digit and 10+ digit symbols will coexist in the system
- Any protocol with `IsTokenIdReuse=true` enables the attack vector

**Economic Rationality:**
- Attack cost: Standard minting fees only
- Potential gain: Ability to corrupt high-value NFT ownership data
- Risk: Low, as minting is a normal operation

**Detection Constraints:**
- Collision appears as normal minting transaction
- No protocol-level alerts for hash collisions
- Corrupted state may go unnoticed until users discover balance discrepancies

The vulnerability has HIGH likelihood because symbol length transitions are inevitable in the protocol's design.

### Recommendation

**Immediate Fix:**
Modify the `CalculateTokenHash` function to use a delimiter or structured encoding that prevents ambiguous concatenation:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Use delimiter to prevent ambiguous parsing
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
    
    // OR use structured encoding
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

**Additional Validation:**
Add integrity checks in `PerformMint` to verify retrieved NFTInfo matches expected values:

```csharp
var nftInfo = State.NftInfoMap[tokenHash];
if (nftInfo != null)
{
    Assert(nftInfo.Symbol == input.Symbol, "Symbol mismatch - hash collision detected");
    Assert(nftInfo.TokenId == tokenId, "TokenId mismatch - hash collision detected");
}
```

**Testing Requirements:**
- Unit tests for hash uniqueness across symbol length variations
- Integration tests for concurrent minting with different symbol lengths
- Regression tests preventing (symbol1, id1) != (symbol2, id2) from sharing state

### Proof of Concept

**Initial State:**
- Protocol A created early with symbol "AR100000000" (9-digit number: 100000000)
- Protocol B created later with symbol "AR1000000001" (10-digit number: 1000000001, when length increased)
- Protocol B has `IsTokenIdReuse=true`

**Exploitation Steps:**

1. **Protocol A mints NFT:**
   - Call `Mint(symbol="AR100000000", tokenId=123, quantity=1, owner=Alice)`
   - tokenHash = Hash("AR100000000123")
   - Creates NFTInfo{Symbol="AR100000000", TokenId=123, Quantity=1, Minters=[Alice]}
   - BalanceMap[tokenHash][Alice] = 1

2. **Attacker mints colliding NFT:**
   - Call `Mint(symbol="AR1000000001", tokenId=23, quantity=10, owner=Attacker)`
   - tokenHash = Hash("AR100000000123") ← SAME HASH!
   - Retrieves existing NFTInfo (Protocol A's)
   - IsTokenIdReuse=true, so uniqueness check bypassed
   - Modifies: Quantity=11, Minters=[Alice, Attacker]
   - BalanceMap[tokenHash][Attacker] += 10

3. **Result - State Corruption:**
   - Both NFTs share the same storage slot
   - GetNFTInfo("AR1000000001", 23) returns NFTInfo with Symbol="AR100000000", TokenId=123
   - BalanceMap contains mixed balances for both protocols
   - Transfers/burns of either NFT affect the shared state

**Success Condition:**
Hash("AR100000000123") == Hash("AR100000000123") is guaranteed by the string concatenation, demonstrating exploitable collision.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-394)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-22)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }
```
