### Title
Cross-Contract Trust Vulnerability in ChangeMethodFeeController Enables Permanent Governance Bypass

### Summary
The `ChangeMethodFeeController` function in ElectionContract trusts caller-provided contract addresses without validation, allowing a compromised Parliament to install a fake authorization contract that bypasses all governance checks. This enables permanent control over method fees without requiring further proposals, escalating temporary governance compromise into persistent unauthorized access.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` helper method that validates new method fee controllers: [1](#0-0) 

This function accepts an `AuthorityInfo` parameter containing both `ContractAddress` and `OwnerAddress` fields, then makes a cross-contract call to the provided `ContractAddress` to validate organization existence. The critical flaw is that **no validation occurs to verify the contract address corresponds to a legitimate system authorization contract** (Parliament, Association, or Referendum).

The function is called during controller changes: [2](#0-1) 

While line 24 enforces that only the current controller owner can initiate changes, there is no constraint on what contract address can be specified in the new `AuthorityInfo`. Legitimate governance contracts properly validate organizations against their internal state: [3](#0-2) [4](#0-3) 

However, an attacker can deploy a malicious contract that implements `ValidateOrganizationExist` to always return `true`, bypassing genuine organization validation. The same pattern exists across all AElf contracts implementing ACS1: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Governance Bypass:** Once a fake authorization contract is installed, the attacker controlling the new `OwnerAddress` can call `SetMethodFee` directly without Parliament/Association/Referendum proposals: [7](#0-6) 

This breaks the fundamental governance invariant that method fees must be controlled through transparent, multi-party approval processes.

**Operational Denial of Service:** The attacker can set arbitrarily high method fees across all contract functions, making the Election contract economically inaccessible to legitimate users and effectively disabling voting, candidate registration, and election maintenance operations.

**Permanent Escalation:** Unlike a single malicious proposal that can be detected and reverted, this vulnerability allows a compromised Parliament to install a permanent backdoor. The fake controller can immediately change itself again (since `CheckOrganizationExist` will pass with their fake contract), making recovery require external intervention beyond normal governance processes.

**System-Wide Impact:** This vulnerability affects all 15+ system contracts implementing ACS1, including critical infrastructure like MultiToken, Consensus, Treasury, and Genesis contracts. A coordinated attack could compromise method fee control across the entire blockchain.

### Likelihood Explanation

**Preconditions:** The attack requires Parliament to be compromised through one of:
1. Malicious proposal that gets approved (requires majority miner support)
2. Compromised miner majority
3. Social engineering of Parliament members

While this is a high bar, it's realistic because:
- Human error in proposal review is common
- Complex proposals can obscure malicious intent
- Miner collusion is a known blockchain threat model

**Execution Complexity:** Once the proposal passes, execution is trivial:
1. Deploy a 10-line malicious contract with `ValidateOrganizationExist() { return true; }`
2. Proposal executes `ChangeMethodFeeController` with malicious contract address
3. Future `SetMethodFee` calls succeed without governance

**Detection Difficulty:** The attack appears as a legitimate governance action. The malicious contract address may not be immediately recognized as fake, and method fee changes could be gradual to avoid detection.

**Economic Rationality:** Contract deployment costs are minimal compared to the value of controlling method fees across system contracts. High fees could extract value through forced transaction costs or render competitors' operations unprofitable.

### Recommendation

**Immediate Fix:** Validate that `ContractAddress` in `AuthorityInfo` corresponds to a registered system contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate authorization contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid authorization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Apply this fix across all ACS1 implementations: Election, MultiToken, Genesis, Parliament, Association, Referendum, Consensus, Treasury, Profit, TokenConverter, TokenHolder, Vote, Configuration, Economic, CrossChain, and NFT contracts.

**Test Cases:**
1. Verify `ChangeMethodFeeController` rejects non-system contract addresses
2. Verify legitimate changes with Parliament/Association/Referendum still work
3. Test that malicious contract deployment and proposal fails validation
4. Regression test for all system contracts implementing ACS1

### Proof of Concept

**Step 1 - Deploy Malicious Contract:**
```
Deploy MaliciousAuthContract:
  ValidateOrganizationExist(Address input) {
    return BoolValue { Value = true };
  }
```

**Step 2 - Create Parliament Proposal:**
```
Parliament.CreateProposal({
  contract_method_name: "ChangeMethodFeeController",
  to_address: ElectionContract,
  params: AuthorityInfo {
    ContractAddress: MaliciousAuthContract,
    OwnerAddress: AttackerEOA
  },
  organization_address: ParliamentDefaultOrg
})
```

**Step 3 - Approve and Release:**
```
Miners approve proposal → Parliament.Release(proposalId)
→ ElectionContract.ChangeMethodFeeController executes
→ CheckOrganizationExist calls MaliciousAuthContract.ValidateOrganizationExist
→ Returns true (fake validation)
→ Controller changed successfully
```

**Step 4 - Exploit:**
```
AttackerEOA calls ElectionContract.SetMethodFee({
  method_name: "Vote",
  fees: [{ symbol: "ELF", basic_fee: 1000000000 }]  // 1000 ELF per vote
})
→ Line 16 checks Context.Sender == OwnerAddress (AttackerEOA) ✓
→ No governance proposal required
→ Voting becomes economically infeasible
```

**Success Condition:** Method fees are changed without Parliament proposal, demonstrating permanent governance bypass.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L67-72)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
