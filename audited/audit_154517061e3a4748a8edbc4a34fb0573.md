### Title
Missing Temporal Validation Allows Premature Term Transitions

### Summary
The consensus validation logic fails to verify whether a term change is actually due when processing `NextTerm` behaviour. A malicious miner can trigger term transitions prematurely by providing `NextTerm` consensus extra data before the time-based conditions are met, bypassing the `NeedToChangeTerm()` check that should govern term transitions.

### Finding Description

**Root Cause:** The validation logic for `NextTerm` behaviour only validates structural correctness (round/term number increments) but does not validate temporal correctness (whether it's actually time to change terms). [1](#0-0) 

The `ValidationForNextTerm` method only checks:
- Round number increments by 1
- Term number increments by 1  
- InValues are null

However, it does NOT invoke `NeedToChangeTerm()` on the base round to verify that the temporal condition for term change is satisfied. [2](#0-1) 

The `NeedToChangeTerm()` method contains the actual time-based logic that determines when term transitions should occur, checking if 2/3 of miners have `ActualMiningTimes` that meet the period-based threshold. This critical check is bypassed during validation.

**Execution Path:**

1. Honest flow uses `MainChainConsensusBehaviourProvider` to determine behaviour based on state: [3](#0-2) 

2. However, validation does not enforce that the provided behaviour matches what should happen: [4](#0-3) 

3. A malicious miner can provide `NextTerm` behaviour in consensus extra data even when `NeedToChangeTerm()` would return false, and validation will pass.

### Impact Explanation

When `ProcessNextTerm` executes prematurely, it triggers critical operations: [5](#0-4) 

**Concrete Harms:**

1. **Treasury Fund Release:** Premature release of treasury funds for a term that shouldn't have ended (lines 203-210)
2. **Election Snapshot Timing:** Election snapshots taken at incorrect times, disrupting governance (lines 213-218)
3. **Miner Statistics Reset:** Premature reset of `MissedTimeSlots` and `ProducedBlocks` counters (lines 179-183)
4. **Miner List Updates:** Updating to new elected miners before the term period completes (lines 187-190)
5. **Mining Reward Miscalculation:** Rewards donated based on incomplete term data (line 203)

**Severity:** HIGH - Disrupts consensus timing mechanism, causes premature fund releases, and corrupts governance/election data.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in the current miner list (checked by `MiningPermissionValidationProvider`)
- Must be able to produce a block during their time slot

**Attack Complexity:** LOW
- Attacker simply sets `Behaviour = NextTerm` in consensus extra data when producing a block
- Generates next term round using standard methods
- All validation passes because only structural checks exist, not temporal checks

**Feasibility:** HIGH
- Any malicious miner in the miner list can execute this
- No special permissions beyond being a current miner required
- No economic cost beyond normal block production

**Detection:** The attack is observable on-chain through term number advancing prematurely, but may be attributed to normal consensus operation initially.

**Probability:** MEDIUM-HIGH - Requires a malicious miner, but the attack is straightforward once in position.

### Recommendation

**Add temporal validation in `RoundTerminateValidationProvider.ValidationForNextTerm()`:**

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Is next term number correct?
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Verify it's actually time to change terms
    // Need to access blockchain start timestamp and period seconds from context
    // This requires passing these values through ConsensusValidationContext
    if (!ShouldChangeTerm(validationContext))
        return new ValidationResult { Message = "Term change not due yet." };
    
    return new ValidationResult { Success = true };
}
```

**Additional steps:**
1. Extend `ConsensusValidationContext` to include `BlockchainStartTimestamp` and `PeriodSeconds`
2. Implement `ShouldChangeTerm()` helper that invokes `BaseRound.NeedToChangeTerm()`
3. Add integration tests verifying NextTerm is rejected when temporal conditions aren't met
4. Add test case confirming NextTerm succeeds only when â‰¥2/3 miners meet time threshold

### Proof of Concept

**Initial State:**
- Current term: 1
- Current round: 5  
- Period seconds: 604800 (7 days)
- Blockchain age: 3 days (less than period)
- Current round has NOT met `NeedToChangeTerm()` criteria (only 3 days elapsed, not 7)

**Attack Steps:**

1. Malicious miner waits for their time slot in round 5
2. When producing block, miner provides consensus extra data with:
   - `Behaviour = NextTerm`
   - `Round = GenerateFirstRoundOfNextTerm()` (round 6, term 2)
   - Valid round/term number increments

3. Validation executes:
   - `MiningPermissionValidationProvider`: PASS (miner in list)
   - `TimeSlotValidationProvider`: PASS (in time slot)
   - `RoundTerminateValidationProvider`: PASS (only checks numbers, not timing)
   
4. Block executes, `ProcessNextTerm()` runs:
   - Term number updated from 1 to 2
   - Treasury releases funds for "completed" term 1 (only 3 days old)
   - Election snapshot taken prematurely
   - Miner statistics reset

**Expected Result:** Validation should reject NextTerm because only 3/7 days elapsed

**Actual Result:** NextTerm succeeds, term transitions 4 days early

**Success Condition:** `State.CurrentTermNumber.Value == 2` after only 3 days instead of required 7 days

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
