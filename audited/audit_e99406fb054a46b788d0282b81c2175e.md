# Audit Report

## Title
Flawed Mining Order Validation Allows Duplicate FinalOrderOfNextRound Values in NextRound Consensus

## Summary
The `NextRoundMiningOrderValidationProvider` incorrectly validates mining orders by calling `.Distinct()` on `MinerInRound` objects instead of on `FinalOrderOfNextRound` integer values. This allows multiple miners to be assigned identical mining orders, bypassing validation and corrupting the next round's mining schedule, causing consensus disruption and potential chain liveness issues.

## Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider` contains a critical flaw in how it verifies uniqueness of mining orders. [1](#0-0) 

The code calls `.Distinct()` on an `IEnumerable<MinerInRound>` collection (the result of `.Values.Where(...)`), not on the `FinalOrderOfNextRound` integer values themselves. Since `MinerInRound` is a protobuf-generated class with 17 fields [2](#0-1)  that implements value-based equality comparing all fields (including the unique `Pubkey` field), two different miners with identical `FinalOrderOfNextRound` but different pubkeys are counted as distinct objects.

The validation compares the count of distinct `MinerInRound` objects (line 15-16) against the count of miners who mined (line 17). If you have 3 miners who mined with FinalOrderOfNextRound values [1, 1, 3], the validation sees 3 distinct `MinerInRound` objects and compares this to 3 miners who mined - the check passes despite having duplicate order value 1.

The correct implementation should be:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // ← Extract the integer values
    .Distinct()
    .Count();
```

When a malicious NextRound block passes this flawed validation, it gets stored in blockchain state. [3](#0-2)  The corrupted round data is then persisted via `AddRoundInformation`. [4](#0-3) 

The corrupted round data subsequently affects next round generation. When `GenerateNextRoundInformation` processes miners, it iterates over them ordered by `FinalOrderOfNextRound` and assigns each miner their `FinalOrderOfNextRound` value as their order in the next round. [5](#0-4) 

Multiple miners with the same `FinalOrderOfNextRound` will both be assigned the same `Order` value in the next round (line 32). Additionally, the `occupiedOrders` list will contain duplicate values [6](#0-5) , causing the calculation of available orders for non-mining miners to incorrectly skip some valid order slots while leaving others unassigned.

## Impact Explanation

**Consensus Integrity Violation**: The AEDPoS consensus mechanism relies on the invariant that each miner has a unique, sequential mining order within a round. When multiple miners are assigned to the same order slot:
- Two or more miners expect to produce blocks at the same expected mining time (calculated from their order)
- Time slot collisions cause block production conflicts or failures
- Some miners may receive no valid time slot as their intended orders are occupied by duplicates
- Mining schedule corruption persists until a proper NextRound or NextTerm transition corrects it

**Chain Liveness Risk**: If critical miners (e.g., the extra block producer responsible for finalizing rounds) are assigned duplicate orders or completely skipped, the chain may fail to progress during affected rounds. The consensus mechanism's core assumption of unique, sequential mining orders is fundamentally violated.

**Operational Disruption**: Nodes following the corrupted mining schedule will have inconsistent views of which miner should produce blocks at what time, potentially causing network disagreements, failed block propagation, or consensus timeouts.

**Attack Surface**: Any consensus miner can exploit this vulnerability when they are assigned to produce a NextRound block, which occurs multiple times per term during normal operation.

## Likelihood Explanation

**Reachable Entry Point**: The validation is triggered during `ValidateBeforeExecution` for any block with `AElfConsensusBehaviour.NextRound`. [7](#0-6)  The validation service executes all registered providers [8](#0-7)  and will accept blocks where this flawed validation passes.

**Attacker Capabilities**: Any consensus miner can construct a malicious block header when assigned to produce the NextRound block. They control the `AElfConsensusHeaderInformation` structure containing the `Round` data with `FinalOrderOfNextRound` values. The miner can craft a block where two or more miners in `ProvidedRound.RealTimeMinersInformation` have identical `FinalOrderOfNextRound` values.

**Execution Practicality**: The attacker simply sets duplicate `FinalOrderOfNextRound` values in the round data (e.g., MinerA and MinerB both set to order 1). The flawed validation counts 2 distinct `MinerInRound` objects and compares against 2 miners who mined - the check passes. The corrupted round is then stored via `ProcessNextRound` and `AddRoundInformation`.

**Detection Difficulty**: The validation appears to pass normally - the count equality check succeeds because it's counting objects instead of values. Only inspection of actual `FinalOrderOfNextRound` integer values (not performed by the validator) would reveal duplicates. Post-execution mining schedule chaos may be misattributed to network issues rather than recognized as an attack.

**Economic Rationality**: Attack cost is minimal (normal block production), while motivations include: griefing competitor miners by causing time slot conflicts, disrupting consensus to delay unfavorable governance actions, or creating operational chaos for strategic advantage.

## Recommendation

Fix the validation to check uniqueness of `FinalOrderOfNextRound` **values** rather than `MinerInRound` **objects**:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Extract the integer values before applying Distinct()
    var distinctCount = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound)  // ← Add this line
        .Distinct()
        .Count();
        
    if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

Additionally, consider adding an explicit validation that all `FinalOrderOfNextRound` values form a contiguous sequence from 1 to the number of miners who mined, ensuring no gaps or duplicates.

## Proof of Concept

```csharp
[Fact]
public async Task Malicious_NextRound_With_Duplicate_FinalOrderOfNextRound_Should_Be_Rejected()
{
    // Setup: Initialize consensus with 5 miners and advance to a state where NextRound is needed
    var miners = await InitializeConsensusWithMiners(5);
    await ProduceBlocksUntilNextRoundNeeded();
    
    // Attack: Craft malicious NextRound with duplicate FinalOrderOfNextRound
    var currentRound = await GetCurrentRoundInformation();
    var nextRound = CreateNextRoundWithDuplicateOrders(currentRound, miners);
    
    // Both Miner[0] and Miner[1] are assigned FinalOrderOfNextRound = 1
    nextRound.RealTimeMinersInformation[miners[0]].FinalOrderOfNextRound = 1;
    nextRound.RealTimeMinersInformation[miners[1]].FinalOrderOfNextRound = 1;
    nextRound.RealTimeMinersInformation[miners[2]].FinalOrderOfNextRound = 3;
    
    var nextRoundInput = new NextRoundInput { RoundInformation = nextRound };
    
    // Execute: Attempt to process malicious NextRound
    var result = await ConsensusContract.NextRound.SendAsync(nextRoundInput);
    
    // Verify: Should reject due to duplicate orders, but currently passes
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Invalid FinalOrderOfNextRound");
    
    // After fix, validation should fail. Currently this test would fail because
    // the malicious round is accepted and stored, corrupting consensus.
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ValidationService.cs (L16-26)
```csharp
    public ValidationResult ValidateInformation(ConsensusValidationContext validationContext)
    {
        foreach (var headerInformationValidationProvider in _headerInformationValidationProviders)
        {
            var result =
                headerInformationValidationProvider.ValidateHeaderInformation(validationContext);
            if (!result.Success) return result;
        }

        return new ValidationResult { Success = true };
    }
```
