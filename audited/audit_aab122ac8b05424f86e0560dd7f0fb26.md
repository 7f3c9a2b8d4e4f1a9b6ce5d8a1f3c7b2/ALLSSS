# Audit Report

## Title 
Symbol Number Collision Causes Guaranteed Transaction Failure with Maximum Fee Consumption in NFT Creation

## Summary
The `GenerateSymbolNumber()` function in the NFT contract contains a critical flaw where the random hash is computed once before entering a collision-handling loop but never updated within it. When a symbol number collision occurs, the deterministic `ConvertHashToInt64()` function returns the same number on every iteration, causing the loop to execute until AElf's branch threshold of 15,000 is exceeded, resulting in transaction failure with maximum fee consumption.

## Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` method where the `randomHash` is calculated once before the do-while loop and remains static throughout all iterations. [1](#0-0) 

The `randomHash` is computed from the previous block's random bytes and the sender's address before entering the loop. [2](#0-1) 

Inside the do-while loop, `Context.ConvertHashToInt64(randomHash, from, from.Mul(10))` is called with the same unchanging hash value. [3](#0-2) 

The `ConvertHashToInt64` implementation uses deterministic modulo arithmetic, guaranteeing identical outputs for identical inputs. [4](#0-3) 

When a collision occurs (the generated number exists in `State.IsCreatedMap`), the while condition remains true indefinitely since the same static hash produces the same number on every iteration, and the collision check continues to fail.

While AElf's execution observer limits branch execution to 15,000 iterations, [5](#0-4)  this protection causes the transaction to fail with `RuntimeBranchThresholdExceededException` [6](#0-5)  after consuming maximum computational resources.

The execution path is: User calls `Create(CreateInput)` [7](#0-6)  → `GetSymbol()` invokes `GenerateSymbolNumber()` [8](#0-7)  → Collision triggers infinite loop until branch threshold → Transaction fails with maximum fees consumed.

## Impact Explanation

**Direct Financial Loss:** Users lose transaction fees equivalent to 15,000 loop iterations when encountering a symbol collision, representing substantial resource consumption without successful NFT protocol creation.

**Denial of Service:** Legitimate users cannot create NFT protocols when collisions occur. As `State.IsCreatedMap` grows with more NFT creations, collision probability increases, progressively degrading system reliability.

**Affected Users:** Any user calling the `Create()` method can be affected. The initial number space spans 900 million values (from 10^8 to 10^9) [9](#0-8)  but collisions become inevitable as adoption grows.

**Severity:** HIGH - This combines guaranteed financial loss (wasted transaction fees), denial of critical functionality (NFT protocol creation), and exploitability by malicious actors who can predict or influence the deterministic random number generation.

## Likelihood Explanation

**Attacker Capabilities:** An attacker can predict the symbol number by observing publicly available block height, target user addresses (from pending transactions), and the deterministic nature of random number generation based on these inputs.

**Attack Complexity:** LOW to MEDIUM
1. Monitor pending `Create()` transactions or identify target user
2. Calculate the symbol number that will be generated for that user at the next block
3. Front-run by creating an NFT with that exact symbol number  
4. Victim's transaction executes, hits collision, and fails after 15,000 iterations

**Accidental Triggering:** Even without malicious intent, natural collisions will occur as more NFTs are created. With deterministic random generation based on limited entropy sources (block height and sender address), the birthday paradox makes collisions statistically likely over time.

**Economic Rationality:** Attacker cost is minimal (one NFT creation fee), while the victim suffers maximum transaction fee loss. The attack is economically profitable if the attacker benefits from denying the victim's NFT creation (e.g., competitive NFT launch scenarios).

## Recommendation

Regenerate the `randomHash` inside the do-while loop on each collision attempt. This ensures that each iteration uses fresh randomness to generate a different symbol number:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    do
    {
        // Regenerate randomBytes and randomHash on each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(Context.TransactionId) // Add transaction ID for additional entropy
        );
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

Alternatively, implement a counter or nonce that increments on each iteration to ensure different hash inputs.

## Proof of Concept

```csharp
[Fact]
public async Task SymbolCollision_CausesInfiniteLoopAndTransactionFailure()
{
    // Setup: Create first NFT to occupy a symbol number
    var firstCreateInput = new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "First NFT",
        TotalSupply = 1000,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    };
    
    var firstResult = await NFTContractStub.Create.SendAsync(firstCreateInput);
    var firstSymbol = firstResult.Output.Value;
    
    // Simulate scenario where second user's deterministic random will collide
    // By using same sender address and predictable block height
    var secondCreateInput = new CreateInput
    {
        NftType = NFTType.Art.ToString(),
        ProtocolName = "Second NFT",
        TotalSupply = 1000,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    };
    
    // This should fail with RuntimeBranchThresholdExceededException
    // after 15,000 iterations if collision occurs with same randomHash
    var exception = await Assert.ThrowsAsync<RuntimeBranchThresholdExceededException>(
        async () => await NFTContractStub.Create.SendAsync(secondCreateInput)
    );
    
    // Verify maximum branch count exceeded
    Assert.Contains("branch", exception.Message.ToLower());
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L26-26)
```csharp
        var randomNumber = GenerateSymbolNumber();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-82)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/Exceptions.cs (L77-86)
```csharp
public class RuntimeBranchThresholdExceededException : BaseAElfException
{
    public RuntimeBranchThresholdExceededException()
    {
    }

    public RuntimeBranchThresholdExceededException(string message) : base(message)
    {
    }
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-14)
```csharp
    public override StringValue Create(CreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```
