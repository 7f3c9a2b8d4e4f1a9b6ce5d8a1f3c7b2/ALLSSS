### Title
NextTerm Block Production Bypasses Tiny Block Limit Due to ActualMiningTimes/ProducedTinyBlocks Desynchronization

### Summary
The `GetConsensusExtraDataForNextTerm` function increments `ProducedTinyBlocks` to 1 but fails to add an entry to `ActualMiningTimes`, creating a persistent desynchronization. This allows miners producing NextTerm blocks to bypass the `MaximumTinyBlocksCount` limit (8 blocks) and produce 9 total blocks in their time slot, violating the fork prevention mechanism designed to maintain consensus stability.

### Finding Description

**Root Cause:**

In `GetConsensusExtraDataForNextTerm`, only `ProducedTinyBlocks` is set to 1 without updating `ActualMiningTimes`: [1](#0-0) 

This contrasts sharply with `GetConsensusExtraDataForNextRound`, which correctly updates both fields: [2](#0-1) 

Similarly, `GetConsensusExtraDataForTinyBlock` and `GetConsensusExtraDataToPublishOutValue` both synchronize the fields: [3](#0-2) [4](#0-3) 

**Why Protections Fail:**

The block production limit enforcement uses `ActualMiningTimes.Count`, not `ProducedTinyBlocks`: [5](#0-4) 

The vulnerable calculation in `IsLastTinyBlockOfCurrentSlot` uses `ActualMiningTimes.Count` to determine `blocksBeforeCurrentRound`: [6](#0-5) 

After NextTerm processing, the stored round has `ProducedTinyBlocks = 1` but `ActualMiningTimes = []`: [7](#0-6) 

**Execution Path:**

1. Miner produces NextTerm block → `ProducedTinyBlocks = 1`, `ActualMiningTimes = []`
2. For subsequent tiny blocks, `GetConsensusBehaviour` checks `ActualMiningTimes.Count < 8` (always true for counts 0-7)
3. Miner can produce 8 additional tiny blocks before `ActualMiningTimes.Count = 8`
4. Total: 1 NextTerm + 8 tiny blocks = 9 blocks, exceeding the 8-block limit

The limit is defined as: [8](#0-7) 

### Impact Explanation

**Harm:**
- **Consensus Integrity Violation**: Miners bypass the fork prevention mechanism that limits blocks to 8 per time slot
- **Increased Fork Risk**: The limit exists explicitly to "avoid too many forks" per the implementation comments: [9](#0-8) 

- **Unfair Advantage**: Only miners producing NextTerm blocks can exceed the limit (12.5% more blocks)
- **Protocol Safety Degradation**: Undermines the carefully designed block production throttling

**Who is Affected:**
- All network participants suffer from increased fork probability
- Miners not producing NextTerm blocks are disadvantaged
- Consensus stability and finality are compromised

**Quantification:**
- 1 extra block per NextTerm (12.5% over the 8-block limit)
- Affects every term transition (election cycles)
- Cumulative impact on network fork rate

### Likelihood Explanation

**Attacker Capabilities:**
- Requires only being a miner at term transition (no special privileges)
- No additional authority beyond normal miner role
- Exploitation is automatic—occurs without deliberate action

**Attack Complexity:**
- Low: The vulnerability triggers naturally during NextTerm block production
- No special transaction crafting required
- State desynchronization persists automatically

**Feasibility:**
- Occurs at every term transition (periodic and predictable)
- No preconditions beyond being in the miner set during term change
- Publicly observable and verifiable

**Detection:**
- Difficult to detect as it appears as normal block production
- The extra block is produced within normal consensus flow
- Only detectable through careful ActualMiningTimes vs ProducedTinyBlocks analysis

**Probability:** High - Executes automatically at every term transition for miners producing NextTerm blocks.

### Recommendation

**Code-Level Mitigation:**

In `GetConsensusExtraDataForNextTerm`, add the ActualMiningTimes update to match the pattern used in other consensus methods:

```csharp
private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
    AElfConsensusTriggerInformation triggerInformation)
{
    var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
    Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
    if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        // FIX: Add ActualMiningTimes entry to synchronize with ProducedTinyBlocks
        firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
    }

    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = firstRoundOfNextTerm,
        Behaviour = triggerInformation.Behaviour
    };
}
```

**Invariant Check:**

Add assertion in consensus processing to verify `ProducedTinyBlocks == ActualMiningTimes.Count + blocksInPreviousRounds` after each block.

**Test Cases:**

1. Test NextTerm block production followed by maximum tiny blocks
2. Verify ActualMiningTimes and ProducedTinyBlocks remain synchronized
3. Confirm block count never exceeds MaximumTinyBlocksCount per time slot
4. Compare behavior between NextRound and NextTerm for consistency

### Proof of Concept

**Initial State:**
- Network at term transition
- Miner A is in both current and next term miner lists
- `MaximumTinyBlocksCount = 8`

**Transaction Steps:**

1. **Miner A produces NextTerm block:**
   - State after: `ProducedTinyBlocks = 1`, `ActualMiningTimes = []`
   - Round starts with desynchronized counters

2. **Miner A requests consensus command for tiny block #1-7:**
   - Each request: `GetConsensusBehaviour` checks `ActualMiningTimes.Count < 8` → returns `TinyBlock`
   - Each block: `ProducedTinyBlocks++`, `ActualMiningTimes.Add(time)`
   - After block #7: `ProducedTinyBlocks = 8`, `ActualMiningTimes.Count = 7`

3. **Miner A requests consensus command for tiny block #8:**
   - `GetConsensusBehaviour`: `ActualMiningTimes.Count = 7 < 8` → returns `TinyBlock` (SHOULD BE BLOCKED)
   - `IsLastTinyBlockOfCurrentSlot`: `8 == 0 + 8` → true (marks as last block)
   - Block produced: `ProducedTinyBlocks = 9`, `ActualMiningTimes.Count = 8`

4. **Miner A requests consensus command for tiny block #9:**
   - `GetConsensusBehaviour`: `ActualMiningTimes.Count = 8 < 8` → false → returns NOT `TinyBlock`
   - Miner cannot produce more blocks

**Expected Result:** Miner should produce maximum 8 blocks total in time slot

**Actual Result:** Miner produces 9 blocks total (1 NextTerm + 8 tiny blocks)

**Success Condition:** `ActualMiningTimes.Count` reaches 8 while total blocks produced is 9, demonstrating the bypass of the `MaximumTinyBlocksCount` limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-64)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L155-171)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForTinyBlock(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = currentRound.GetTinyBlockRound(pubkey),
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L57-79)
```csharp
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L54-63)
```csharp
        private bool IsLastTinyBlockOfCurrentSlot()
        {
            var producedBlocksOfCurrentRound = MinerInRound.ProducedTinyBlocks;
            var roundStartTime = CurrentRound.GetRoundStartTime();

            if (CurrentBlockTime < roundStartTime) return producedBlocksOfCurrentRound == _maximumBlocksCount;

            var blocksBeforeCurrentRound = MinerInRound.ActualMiningTimes.Count(t => t < roundStartTime);
            return producedBlocksOfCurrentRound == blocksBeforeCurrentRound.Add(_maximumBlocksCount);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-7)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L17-22)
```csharp
    /// <summary>
    ///     Implemented GitHub PR #1952.
    ///     Adjust (mainly reduce) the count of tiny blocks produced by a miner each time to avoid too many forks.
    /// </summary>
    /// <returns></returns>
    private int GetMaximumBlocksCount()
```
