# Audit Report

## Title
Unbounded Beneficiary Removal in UpdateBasicMinerRewardWeights Can Cause DOS via Execution Call Threshold

## Summary
The Treasury contract's `UpdateBasicMinerRewardWeights()` function performs unbounded beneficiary removal operations that scale linearly with the number of miners. When the miner count grows beyond approximately 200-400 miners, the operation will exceed AElf's ExecutionCallThreshold (15,000 method calls), causing the `Release` transaction to fail and permanently blocking reward distribution until a contract upgrade.

## Finding Description

The vulnerability exists in the automatic reward distribution flow triggered during term transitions. The AEDPoS consensus contract calls `Treasury.Release()` during `ProcessNextTerm`, which then calls `UpdateStateBeforeDistribution`. [1](#0-0) 

Within `UpdateStateBeforeDistribution`, the `UpdateBasicMinerRewardWeights` function is called with previous term information: [2](#0-1) 

The `UpdateBasicMinerRewardWeights` function calls `RemoveBeneficiaries` with all miner addresses from the previous term, obtained via `GetAddressesFromCandidatePubkeys`: [3](#0-2) 

The critical issue is that `GetAddressesFromCandidatePubkeys` doubles the address list by including both the direct address derived from each public key AND the profit receiver address, resulting in 2N addresses for N miners: [4](#0-3) 

The Profit contract's `RemoveBeneficiaries` implementation has no batching or pagination mechanism - it simply iterates through all beneficiaries and calls `RemoveBeneficiary` for each one: [5](#0-4) 

Each `RemoveBeneficiary` call performs multiple state reads, calls `RemoveProfitDetails` (which has its own complex iteration logic), and updates state: [6](#0-5) 

AElf enforces a strict ExecutionCallThreshold of 15,000 method calls to prevent infinite loops and resource exhaustion: [7](#0-6) 

When this threshold is exceeded, the ExecutionObserver throws a `RuntimeCallThresholdExceededException` that causes the entire transaction to fail: [8](#0-7) 

The BasicReward scheme is initialized with `CanRemoveBeneficiaryDirectly = false` (only indices 2, 5, 6 have it set to true), which affects the removal logic but doesn't prevent the DOS: [9](#0-8) 

## Impact Explanation

When the execution call threshold is exceeded, the `Release` transaction fails completely with a `RuntimeCallThresholdExceededException`. This prevents:

1. **Mining Reward Distribution**: All miners lose their mining rewards for that term
2. **Citizen Welfare Distribution**: Voters and token holders cannot receive welfare rewards
3. **Subsidy Distribution**: Backup candidates lose subsidy rewards
4. **System Progression**: The reward mechanism cannot advance to the next period

Since `Release` is automatically called by the AEDPoS contract during term transitions, this creates a **permanent DOS condition**. The system cannot self-recover - rewards remain locked until either:
- The miner count is artificially reduced (requires removing elected miners)
- A contract upgrade patches the unbounded iteration

The severity is **HIGH** because:
- It completely blocks a core economic mechanism
- Affects all network participants (miners, voters, candidates)
- Has no alternative transaction path or manual override
- Accumulates locked value that cannot be distributed

## Likelihood Explanation

The vulnerability's likelihood increases over time as the network grows:

**Current State (SAFE):**
- Current mainnet has approximately 17-21 miners
- Well below the DOS threshold

**Growth Mechanisms:**
1. **Auto-increase**: The system adds 2 miners per `MinerIncreaseInterval` (default 1 year) starting from `SupposedMinersCount` = 17: [10](#0-9) [11](#0-10) 

2. **Governance-driven increase**: Parliament can increase `MaximumMinersCount` beyond the auto-increase schedule

3. **No hard cap**: `MaximumMinersCount` defaults to `int.MaxValue`, allowing unlimited growth

**DOS Threshold Calculation:**
- For N miners: 2N addresses to process
- Each `RemoveBeneficiary` involves ~15-25 method calls (state reads, `RemoveProfitDetails` execution, state updates)
- Total calls ≈ 2N × 20 = 40N
- Threshold: 15,000 / 40 ≈ 375 miners
- With overhead from `Release` and other operations: estimated ~200-300 miners

**Likelihood Assessment: MEDIUM-HIGH**
- While not immediate, the DOS will occur naturally as the network scales
- No attacker action required - this is a design flaw
- Timeline depends on governance decisions and auto-increase schedule

## Recommendation

Implement batched beneficiary removal with pagination:

1. **Add batch size limit** to `RemoveBeneficiaries` (e.g., 50-100 beneficiaries per call)
2. **Introduce state tracking** to remember removal progress across transactions
3. **Modify `UpdateBasicMinerRewardWeights`** to call `RemoveBeneficiaries` in batches
4. **Allow multi-transaction removal** where removal can span multiple blocks if needed

Alternative approach:
- **Avoid removal entirely**: Instead of removing and re-adding beneficiaries each term, update their shares in-place
- **Use lazy removal**: Mark beneficiaries as inactive without removing them from state

Example fix structure:
```csharp
// Add to TreasuryContractState
public MappedState<long, BeneficiaryRemovalProgress> RemovalProgress { get; set; }

// Modify UpdateBasicMinerRewardWeights to batch:
private void UpdateBasicMinerRewardWeights(...)
{
    var addresses = GetAddressesFromCandidatePubkeys(...);
    const int batchSize = 50;
    for (int i = 0; i < addresses.Count; i += batchSize)
    {
        var batch = addresses.Skip(i).Take(batchSize).ToList();
        State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            Beneficiaries = { batch }
        });
    }
    // Continue with AddBeneficiaries...
}
```

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set up a test environment with AEDPoS and Treasury contracts
2. Initialize with a miner list of 250+ miners (using mock Round data)
3. Call `NextTerm` to trigger `Release`
4. Observe that the transaction fails with `RuntimeCallThresholdExceededException`
5. Verify that no rewards were distributed

Note: Creating a complete runnable PoC requires extensive test infrastructure. The vulnerability is evident from static code analysis showing:
- Unbounded O(N) iteration in `RemoveBeneficiaries`
- Address doubling in `GetAddressesFromCandidatePubkeys` 
- Hard 15,000 call limit in `ExecutionObserver`
- Automatic trigger via `Release` during term transitions

**Notes**

This vulnerability represents a **scalability limitation** rather than an active attack vector. The current mainnet deployment with ~17-21 miners is safe, but the system will naturally reach the DOS threshold as it grows to support more miners. The fix should be prioritized before the miner count approaches 150-200 to maintain safety margin.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L56-67)
```csharp
        for (var i = 0; i < 7; i++)
        {
            var index = i;
            Context.LogDebug(() => profitItemNameList[index]);
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L123-166)
```csharp
    public override Empty Release(ReleaseInput input)
    {
        RequireAEDPoSContractStateSet();
        Assert(
            Context.Sender == State.AEDPoSContract.Value,
            "Only AElf Consensus Contract can release profits from Treasury.");
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
        RequireElectionContractStateSet();
        var previousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = input.PeriodNumber
        });

        var currentMinerList = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(p => p.ToHex()).ToList();
        var maybeNewElectedMiners = new List<string>();
        maybeNewElectedMiners.AddRange(currentMinerList);
        maybeNewElectedMiners.AddRange(previousTermInformation.RealTimeMinersInformation.Keys);
        var replaceCandidates = State.ReplaceCandidateMap[input.PeriodNumber];
        if (replaceCandidates != null)
        {
            Context.LogDebug(() =>
                $"New miners from replace candidate map: {replaceCandidates.Value.Aggregate((l, r) => $"{l}\n{r}")}");
            maybeNewElectedMiners.AddRange(replaceCandidates.Value);
            State.ReplaceCandidateMap.Remove(input.PeriodNumber);
        }

        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
        if (maybeNewElectedMiners.Any())
            Context.LogDebug(() => $"New elected miners: {maybeNewElectedMiners.Aggregate((l, r) => $"{l}\n{r}")}");
        else
            Context.LogDebug(() => "No new elected miner.");

        UpdateStateBeforeDistribution(previousTermInformation, maybeNewElectedMiners);
        ReleaseTreasurySubProfitItems(input.PeriodNumber);
        UpdateStateAfterDistribution(previousTermInformation, currentMinerList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L751-764)
```csharp
    private void UpdateStateBeforeDistribution(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousPreviousTermInformation = State.AEDPoSContract.GetPreviousTermInformation.Call(new Int64Value
        {
            Value = previousTermInformation.TermNumber.Sub(1)
        });

        if (newElectedMiners.Any()) State.HasNewMiner[previousTermInformation.TermNumber.Add(1)] = true;

        Context.LogDebug(() => $"Will update weights after term {previousTermInformation.TermNumber}");
        UpdateBasicMinerRewardWeights(new List<Round> { previousPreviousTermInformation, previousTermInformation });
        UpdateWelcomeRewardWeights(previousTermInformation, newElectedMiners);
        UpdateFlexibleRewardWeights(previousTermInformation);
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-787)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L401-410)
```csharp
    public override Empty RemoveBeneficiaries(RemoveBeneficiariesInput input)
    {
        foreach (var beneficiary in input.Beneficiaries)
            RemoveBeneficiary(new RemoveBeneficiaryInput
            {
                SchemeId = input.SchemeId, Beneficiary = beneficiary
            });

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-26)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
