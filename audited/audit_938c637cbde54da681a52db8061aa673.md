### Title
Double-Subtraction Vulnerability in RemoveSubScheme Causes Negative TotalShares and Profit Distribution Failure

### Summary
The `RemoveSubScheme` function unconditionally subtracts shares from `TotalShares` based on the `SubSchemes` list without verifying that these shares still exist in the profit accounting system. If `RemoveBeneficiary` is called on a sub-scheme's virtual address before `RemoveSubScheme`, the shares are subtracted twice from `TotalShares`, causing it to become negative. The `Sub()` extension method uses checked arithmetic but does not prevent negative values within the valid long range, resulting in state corruption.

### Finding Description

The vulnerability exists in the `RemoveSubScheme` function where `TotalShares` is decremented: [1](#0-0) 

When a sub-scheme is added via `AddSubScheme`, two actions occur:
1. The sub-scheme is added to the `SubSchemes` list with its share count
2. `AddBeneficiary` is called internally, which adds the sub-scheme's virtual address to `ProfitDetailsMap` and increments `TotalShares` [2](#0-1) 

However, `RemoveBeneficiary` can be called directly on the sub-scheme's virtual address by the scheme manager: [3](#0-2) 

This removes the profit details and decrements `TotalShares` (line 260), but leaves the entry in the `SubSchemes` list unchanged.

Subsequently, when `RemoveSubScheme` is called, it retrieves the shares value from the `SubSchemes` list and subtracts it from `TotalShares` again, without checking if these shares were already removed: [4](#0-3) 

The `Sub()` extension method uses checked arithmetic: [5](#0-4) 

While this prevents integer overflow/underflow beyond `long.MinValue/MaxValue`, it does NOT prevent `TotalShares` from becoming negative within the valid long range. For example, `0 - 100 = -100` executes without throwing an exception, causing semantic state corruption.

### Impact Explanation

**Direct Impact:**
1. **State Corruption**: `TotalShares` becomes negative, violating the invariant that it represents the sum of all active beneficiary shares
2. **Profit Distribution Failure**: When distributing profits, the code checks if `totalShares <= 0` and burns all profits instead of distributing them to legitimate beneficiaries: [6](#0-5) 

3. **Calculation Errors**: The `SafeCalculateProfits` function divides by `TotalShares`, producing invalid negative results when `TotalShares` is negative: [7](#0-6) 

**Affected Parties**: All legitimate beneficiaries of the scheme lose their ability to receive profits, as distributions are burned instead of allocated.

**Severity**: High - This represents a critical failure of the profit distribution mechanism, resulting in permanent loss of profits for all participants.

### Likelihood Explanation

**Attacker Capabilities**: Requires scheme manager authorization for both `RemoveBeneficiary` and `RemoveSubScheme`: [8](#0-7) [9](#0-8) 

**Attack Complexity**: Simple two-transaction sequence - no complex preconditions or timing requirements.

**Feasibility**: 
- **Accidental Scenario**: A manager may not understand that sub-schemes are also beneficiaries in `ProfitDetailsMap` and attempt to remove a sub-scheme using both methods
- **Malicious Scenario**: A compromised or malicious manager could intentionally brick the scheme

**Probability**: Moderate - While it requires manager cooperation, the lack of validation makes this error easy to trigger, and the consequences affect all scheme participants.

### Recommendation

Add validation in `RemoveSubScheme` to ensure shares are only subtracted if they actually exist in the accounting system:

```csharp
public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
{
    // ... existing validation ...
    
    var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
    if (shares == null) return new Empty();
    
    var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
    
    // NEW: Check if profit details exist and calculate actual shares to remove
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress];
    var actualSharesToRemove = 0L;
    if (profitDetails != null && profitDetails.Details.Any())
    {
        actualSharesToRemove = profitDetails.Details
            .Where(d => !d.IsWeightRemoved)
            .Sum(d => d.Shares);
    }
    
    // Clear profit details
    State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
    scheme.SubSchemes.Remove(shares);
    
    // Only subtract shares that were actually accounted for
    if (actualSharesToRemove > 0)
    {
        scheme.TotalShares = scheme.TotalShares.Sub(actualSharesToRemove);
    }
    
    State.SchemeInfos[input.SchemeId] = scheme;
    return new Empty();
}
```

Alternatively, prevent `RemoveBeneficiary` from operating on sub-scheme virtual addresses, or ensure `SubSchemes` and `ProfitDetailsMap` remain synchronized.

**Test Cases**:
1. Verify that calling `RemoveBeneficiary` followed by `RemoveSubScheme` on the same sub-scheme does not cause negative `TotalShares`
2. Verify that `TotalShares` always equals the sum of active shares in `ProfitDetailsMap`
3. Verify that profit distribution continues to work correctly after various removal sequences

### Proof of Concept

**Initial State:**
- Scheme A exists with manager M
- Sub-scheme B exists

**Transaction Sequence:**

1. **Manager M calls `AddSubScheme`**:
   - Input: `schemeId=A, subSchemeId=B, shares=100`
   - Result: `scheme.TotalShares = 100`, `SubSchemes` contains {B, 100}, `ProfitDetailsMap[A][virtualAddress(B)]` has details with shares=100

2. **Manager M calls `RemoveBeneficiary`**:
   - Input: `schemeId=A, beneficiary=virtualAddress(B)`
   - Result: `scheme.TotalShares = 0` (decremented by 100), `ProfitDetailsMap[A][virtualAddress(B)]` is removed/cleared
   - `SubSchemes` still contains {B, 100}

3. **Manager M calls `RemoveSubScheme`**:
   - Input: `schemeId=A, subSchemeId=B`
   - Retrieves `shares.Shares = 100` from `SubSchemes` list
   - Executes: `scheme.TotalShares = 0.Sub(100) = -100`
   - **Result: `scheme.TotalShares = -100` (NEGATIVE)**

**Expected Result**: `TotalShares` should remain at 0 or be properly validated to prevent negative values.

**Actual Result**: `TotalShares` becomes -100, causing all subsequent profit distributions to burn tokens instead of distributing them to legitimate beneficiaries.

**Success Condition**: Query `GetScheme(A)` and observe `TotalShares = -100`, then attempt `DistributeProfits` and observe that all profits are burned per the condition at line 485.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L139-139)
```csharp
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L141-153)
```csharp
        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```
