### Title
Method Fee Configuration Allows Denial of Service of TokenConverter Operations Through Non-Connector Symbols

### Summary
The `SetMethodFee` function in TokenConverter validates fee symbols only against token existence and burnability, without checking if the symbol is available in Connectors. This allows the method fee controller to set fees for Buy/Sell operations using symbols that users cannot obtain through TokenConverter, causing all conversion operations to fail when `ChargeTransactionFees` cannot collect the required fee.

### Finding Description

The root cause is insufficient validation in the `SetMethodFee` function at: [1](#0-0) 

The validation only calls `AssertValidToken` which checks: [2](#0-1) 

This delegates to the Token contract's `IsTokenAvailableForMethodFee` which only verifies the token exists and is burnable: [3](#0-2) 

**Missing validation**: No check that the fee symbol exists in the TokenConverter's Connectors mapping or is obtainable by users.

When users attempt Buy/Sell operations, the pre-execution plugin calls `ChargeTransactionFees`: [4](#0-3) 

This retrieves method fees and attempts to charge the user: [5](#0-4) 

If users lack the required fee token, `ChargeFirstSufficientToken` returns false: [6](#0-5) 

The transaction fails with `Success = false` and error "Transaction fee not enough": [7](#0-6) 

### Impact Explanation

**Complete Denial of Service** of TokenConverter's Buy and Sell operations:

Buy operations are the primary mechanism for users to acquire resource tokens: [8](#0-7) 

Sell operations allow users to liquidate resource tokens: [9](#0-8) 

If method fees are set to a symbol not in Connectors (e.g., "RARE_TOKEN" that exists but cannot be purchased), users cannot:
1. Acquire the fee token (not tradeable via TokenConverter)
2. Execute Buy/Sell even with sufficient ELF/resource tokens
3. Circumvent the fee requirement (charged before transaction execution)

**Affected parties**: All users attempting token conversion operations. The TokenConverter is critical infrastructure for the resource token economy (READ, WRITE, STORAGE, TRAFFIC).

**Severity**: High - complete operational disruption of core economic functionality without any workaround available to users.

### Likelihood Explanation

**Attacker capabilities**: Requires method fee controller authority (Parliament's default organization requiring 2/3 block producer approval).

**Attack complexity**: Low - single `SetMethodFee` transaction with a valid but non-Connector token symbol.

**Feasibility**: High - this can occur through:
1. Misconfiguration during governance updates
2. Lack of awareness about Connector symbol requirements
3. Token being removed from Connectors after fees are set

**Execution practicality**: Demonstrated in tests where method fees are set via Parliament proposals: [10](#0-9) 

The test shows typical fee configuration, but lacks validation that the symbol is obtainable. The validation test only checks token existence: [11](#0-10) 

**Probability**: While requiring governance action, the lack of technical safeguards makes misconfiguration a realistic operational risk, not requiring malicious intent.

### Recommendation

Add validation in `SetMethodFee` to ensure fee symbols are obtainable by users:

```csharp
private void AssertValidToken(string symbol, long amount)
{
    Assert(amount >= 0, "Invalid amount.");
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
        $"Token {symbol} cannot set as method fee.");
    
    // Add validation: fee symbol must be base token or exist in Connectors
    Assert(symbol == State.BaseTokenSymbol.Value || State.Connectors[symbol] != null,
        $"Token {symbol} is not available for TokenConverter operations. Must be base token or exist in Connectors.");
}
```

Add test case to prevent regression:
- Test setting method fee with non-Connector symbol should fail
- Test Buy/Sell operations succeed only when fee symbols are obtainable
- Test that removing a Connector symbol used in method fees is prevented or handled gracefully

### Proof of Concept

**Initial state:**
- TokenConverter initialized with ELF base token
- WRITE connector exists and is enabled
- RARE_TOKEN exists in Token contract, is burnable, but NOT in Connectors

**Attack sequence:**
1. Parliament creates proposal to set method fee for Buy operation:
   - Symbol: "RARE_TOKEN"
   - BasicFee: 100
2. Proposal approved and released via Parliament
3. `SetMethodFee` executes successfully (passes AssertValidToken check)
4. User attempts to buy WRITE tokens with sufficient ELF balance
5. Pre-execution plugin calls `ChargeTransactionFees`
6. `ChargeFirstSufficientToken` fails (user has no RARE_TOKEN)
7. Transaction reverts with "Transaction fee not enough"

**Expected result:** User's Buy transaction succeeds, fee charged in ELF or available token

**Actual result:** All Buy/Sell operations fail permanently for users lacking RARE_TOKEN, which they cannot obtain through TokenConverter

**Success condition for vulnerability:** Buy/Sell operations blocked despite users having sufficient tokens for the actual trade, demonstrating complete DoS of TokenConverter functionality.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L78-87)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L252-257)
```csharp
    private bool IsTokenAvailableForMethodFee(string symbol)
    {
        var tokenInfo = GetTokenInfo(symbol);
        if (tokenInfo == null) throw new AssertionException("Token is not found.");
        return tokenInfo.IsBurnable;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L119-121)
```csharp
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L268-299)
```csharp
    private bool ChargeTransactionFeesToBill(ChargeTransactionFeesInput input, Address fromAddress,
        ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee, bool isSizeFeeFree = false,
        TransactionFeeDelegations delegations = null)
    {
        var successToChargeBaseFee = true;

        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L704-745)
```csharp
    private bool ChargeFirstSufficientToken(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        out string symbol, out long amount, out long existingBalance, out long existingAllowance,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, TransactionFeeDelegations delegations = null)
    {
        symbol = null;
        amount = 0L;
        existingBalance = 0L;
        existingAllowance = 0L;
        bool chargeResult;

        if (delegations != null)
        {
            //from address -> delegatee
            chargeResult = TryToChargeDelegateBaseFee(symbolToAmountMap, fromAddress, transactionFeeFreeAllowancesMap,
                delegations, out amount, out symbol, out existingBalance, out existingAllowance);
            return chargeResult;
        }

        chargeResult = TryToChargeUserBaseFee(symbolToAmountMap, fromAddress, transactionFeeFreeAllowancesMap,
            out amount, out symbol, out existingBalance, out existingAllowance);

        if (symbol != null)
        {
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            amount = symbolToAmountMap[symbol];
        }

        //For user, if charge failed and delegation is null, priority charge primary token
        if (!chargeResult)
        {
            var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
            if (symbolToAmountMap.ContainsKey(primaryTokenSymbol))
            {
                symbol = primaryTokenSymbol;
                existingBalance = GetBalance(fromAddress, symbol);
                existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
            }
        }

        return chargeResult;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-212)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
        // Transfer sold token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
        Context.Fire(new TokenSold
        {
            Symbol = input.Symbol,
            SoldAmount = input.Amount,
            BaseAmount = amountToReceive,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/TransactionFeeProviderTests.cs (L125-137)
```csharp
    public async Task TokenConverter_FeeProvider_Test()
    {
        await ExecuteProposalForParliamentTransaction(TokenConverterContractAddress, MethodName, new MethodFees
        {
            MethodName = nameof(TokenConverterContractStub.Buy),
            Fees = { TokenAmount }
        });
        var result = await TokenConverterContractStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = nameof(TokenConverterContractStub.Buy)
        });
        result.Fees.First().ShouldBe(TokenAmount);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ACS1_ImplementTest.cs (L122-137)
```csharp
        // token does not exist
        {
            var setMethodFeeRet = await DefaultStub.SetMethodFee.SendWithExceptionAsync(new MethodFees
            {
                MethodName = "Test",
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = "NOTEXIST",
                        BasicFee = 111
                    }
                }
            });
            setMethodFeeRet.TransactionResult.Error.ShouldContain("Token is not found.");
        }
```
