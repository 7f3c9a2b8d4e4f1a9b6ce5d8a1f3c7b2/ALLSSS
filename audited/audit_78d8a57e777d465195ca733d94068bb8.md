### Title
Vote Persistence After Member Removal Enables Governance Manipulation

### Summary
When a member is removed from an Association organization, their votes on pending proposals remain in the proposal's vote lists and continue to count toward the MinimalVoteThreshold calculation, while not counting toward approval/rejection/abstention thresholds. This inconsistency allows organizations to manipulate proposal outcomes by strategically removing members who voted unfavorably, bypassing intended governance protections.

### Finding Description

The `RemoveMember()` function only removes the member from the organization's member list without cleaning up their existing votes on pending proposals. [1](#0-0) 

The root cause is a critical inconsistency in threshold calculation logic. The rejection, abstention, and approval counts filter votes by checking if the voter is still in the current member list using `.Count(organization.OrganizationMemberList.Contains)`. [2](#0-1) 

However, the total vote threshold calculation concatenates all vote lists and counts them without filtering by current membership, meaning removed members' votes still count toward meeting the MinimalVoteThreshold. [3](#0-2) 

This inconsistency is exploited through the following execution path:
1. A proposal is created and receives votes from members
2. Some members vote to reject or abstain
3. The organization (via another proposal) calls `RemoveMember()` to remove dissenting members
4. When `IsReleaseThresholdReached()` is called during proposal release, removed members' rejection/abstention votes no longer count against thresholds, but their votes still count toward the total vote requirement

### Impact Explanation

**Direct Governance Impact:**
Organizations can bypass MaximalRejectionThreshold and MaximalAbstentionThreshold protections by removing members who voted unfavorably. For example, with an organization of 10 members requiring 7 votes and 5 approvals, a proposal with 5 approvals and 3 rejections (8 total votes) would normally fail if MaximalRejectionThreshold is 2. By removing the 3 rejecting members, the rejection count becomes 0 while the total vote count remains 8, allowing the proposal to pass.

**Who is Affected:**
All Association organization members and stakeholders whose interests depend on honest governance. This includes token holders, protocol users, and DApps relying on Association-based multi-sig governance.

**Severity Justification:**
This is a critical governance integrity violation that completely undermines the intended checks and balances of the Association voting system. It enables minority factions to force through proposals by manipulating membership rather than achieving genuine consensus.

### Likelihood Explanation

**Attacker Capabilities:**
The organization itself (acting through a proposal) can remove members. While this requires initial consensus, once a faction gains enough control to pass one proposal, they can use it to remove opposition and then pass subsequent proposals without proper scrutiny.

**Attack Complexity:**
Low to medium. The attack requires:
1. Gaining enough initial support to pass a member removal proposal
2. Timing the removal to occur after unfavorable votes are cast
3. Subsequently releasing the manipulated proposal

**Feasibility Conditions:**
The attack is practical in organizations where:
- A faction controls just above the MinimalApprovalThreshold
- Opposition exists that votes to reject or abstain
- The faction can pass a single member removal proposal first

**Detection/Operational Constraints:**
The inconsistency is not obvious from normal operations and can appear as legitimate governance activity. The manipulation leaves no direct evidence beyond the timing correlation between member removals and proposal releases.

### Recommendation

**Code-Level Mitigation:**
Modify the `CheckEnoughVoteAndApprovals()` method to filter the total vote count by current membership, ensuring consistency with other threshold checks:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Invariant Checks to Add:**
Add an assertion in `RemoveMember()` to verify that the organization has no pending proposals, or alternatively implement vote cleanup logic that removes all votes from the removed member across all pending proposals for that organization.

**Test Cases to Prevent Regression:**
1. Test that removed members' votes do not count toward any threshold calculation
2. Test that a proposal cannot be released if it only meets thresholds due to removed members' votes
3. Test edge cases where member removal occurs between voting and release

### Proof of Concept

**Required Initial State:**
- Organization with 10 members
- ProposalReleaseThreshold: MinimalVoteThreshold=7, MinimalApprovalThreshold=5, MaximalRejectionThreshold=2, MaximalAbstentionThreshold=2

**Transaction Steps:**
1. Member A creates Proposal X
2. Members 1-5 call `Approve(ProposalX)` 
3. Members 6-8 call `Reject(ProposalX)` (8 total votes)
4. Organization creates and releases Proposal Y to `RemoveMember(Member6)`, `RemoveMember(Member7)`, `RemoveMember(Member8)`
5. Member A calls `Release(ProposalX)`

**Expected vs Actual Result:**
- **Expected:** Proposal X should fail because rejection count (3) exceeds MaximalRejectionThreshold (2)
- **Actual:** Proposal X succeeds because:
  - Approval count: 5 (from current members) ≥ 5 ✓
  - Rejection count: 0 (removed members don't count) ≤ 2 ✓
  - Total votes: 8 (includes removed members) ≥ 7 ✓
  - Proposal executes despite not achieving legitimate consensus

**Success Condition:**
Proposal X executes its target transaction even though it had insufficient legitimate support under the organization's governance rules.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-51)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-58)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```
