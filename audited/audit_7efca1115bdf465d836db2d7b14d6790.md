### Title
Null Reference Exception in DistributeProfitsForSubSchemes Due to Missing Null Check on Sub-Scheme Profit Details

### Summary
The `DistributeProfitsForSubSchemes` function assumes `subItemDetail` is never null when accessing profit details for sub-schemes. However, a scheme manager can call `RemoveBeneficiary` on a sub-scheme's virtual address, removing the profit details while leaving the sub-scheme in the `SubSchemes` list. This inconsistent state causes a NullReferenceException during profit distribution, resulting in complete DoS of the scheme's profit distribution mechanism.

### Finding Description
The vulnerable code is located in the `DistributeProfitsForSubSchemes` function where profit details for sub-schemes are retrieved and accessed without null validation: [1](#0-0) 

The root cause stems from an inconsistency in state management. When a sub-scheme is added via `AddSubScheme`, it performs two actions: (1) adds the sub-scheme's virtual address as a beneficiary with profit details, and (2) adds the sub-scheme to the `scheme.SubSchemes` list: [2](#0-1) 

However, the `RemoveBeneficiary` function can be called directly by the manager on any beneficiary address, including a sub-scheme's virtual address: [3](#0-2) 

This invokes `RemoveProfitDetails`, which completely removes the beneficiary entry from the state map when all profit details are removed: [4](#0-3) 

Critically, `RemoveBeneficiary` does NOT remove the entry from `scheme.SubSchemes` - only `RemoveSubScheme` does that: [5](#0-4) 

This creates an inconsistent state where a sub-scheme exists in the `SubSchemes` list but has no corresponding profit details in the map. The function is called from the profit distribution path: [6](#0-5) 

No validation exists in `RemoveBeneficiary` to prevent removing a sub-scheme's virtual address as a beneficiary.

### Impact Explanation
When `DistributeProfits` is called on a scheme with this inconsistency:
- The transaction fails with a NullReferenceException when accessing `subItemDetail.Details` at line 635
- Complete DoS of profit distribution for the entire scheme
- All beneficiaries of the scheme cannot receive their entitled profits until the manager manually fixes the inconsistency
- The manager must either re-add the sub-scheme's profit details via `AddBeneficiary` or completely remove the sub-scheme via `RemoveSubScheme`
- This affects the entire scheme's economic functionality, impacting all participants, not just the problematic sub-scheme

**Severity Justification**: Medium - This causes operational DoS of a critical economic function (profit distribution), affecting all scheme beneficiaries. While it doesn't directly result in fund theft, it prevents legitimate profit claims and requires manual intervention to restore functionality.

### Likelihood Explanation
This vulnerability can be triggered through scheme manager error or oversight:

**Feasible Preconditions**:
- A scheme must have at least one sub-scheme added via `AddSubScheme`
- The manager (or TokenHolder contract) must call `RemoveBeneficiary` with the sub-scheme's virtual address

**Attacker Capabilities**:
- Only the scheme manager or TokenHolder contract can call `RemoveBeneficiary` (not external attackers)
- The manager may not realize a particular address is a sub-scheme's virtual address when cleaning up beneficiaries
- No validation prevents this action - the code treats sub-scheme virtual addresses identically to regular beneficiaries

**Execution Practicality**:
- Completely practical under normal AElf contract semantics
- Requires only standard contract calls available to the manager
- For schemes with `CanRemoveBeneficiaryDirectly=true`, managers may be more liberal in removing beneficiaries, increasing the likelihood

**Probability Reasoning**: While this requires manager action rather than external attack, it represents a coding error (missing defensive check) that allows an easily-triggered inconsistent state. The lack of safeguards makes this a realistic scenario in production environments where managers may not fully understand the relationship between beneficiaries and sub-schemes.

### Recommendation
**Immediate Fix - Add Null Check**:
In `DistributeProfitsForSubSchemes` at line 634, add defensive null checking before accessing `subItemDetail.Details`:

```csharp
var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
if (subItemDetail != null)
{
    foreach (var detail in subItemDetail.Details) 
        detail.LastProfitPeriod = scheme.CurrentPeriod;
    State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress] = subItemDetail;
}
```

**Preventive Fix - Add Validation**:
In `RemoveBeneficiary` function (around line 240), add validation to prevent removing sub-scheme virtual addresses:

```csharp
// After line 231's scheme null check, add:
var subSchemeVirtualAddresses = scheme.SubSchemes
    .Select(s => Context.ConvertVirtualAddressToContractAddress(s.SchemeId))
    .ToList();
Assert(!subSchemeVirtualAddresses.Contains(input.Beneficiary),
       "Cannot remove beneficiary that is a sub-scheme. Use RemoveSubScheme instead.");
```

**Test Cases to Add**:
1. Test that calling `RemoveBeneficiary` on a sub-scheme's virtual address is prevented with clear error message
2. Test that `DistributeProfits` handles missing profit details gracefully without throwing exceptions
3. Integration test covering the full scenario: add sub-scheme, attempt removal via `RemoveBeneficiary`, verify profit distribution still works

### Proof of Concept

**Required Initial State**:
- Two profit schemes created: SchemeA (parent) and SchemeB (child)
- SchemeA's manager has permission to call all management functions

**Transaction Steps**:

1. **Setup**: Manager calls `CreateScheme()` twice to create SchemeA and SchemeB
   - Result: SchemeA and SchemeB exist with their respective scheme IDs

2. **Add Sub-Scheme**: Manager calls `AddSubScheme(schemeId: SchemeA, subSchemeId: SchemeB, shares: 100)`
   - Result: SchemeB added as sub-scheme of SchemeA
   - SchemeB's virtual address registered as beneficiary with profit details in `State.ProfitDetailsMap[SchemeA][virtualAddressOfSchemeB]`
   - SchemeB added to `SchemeA.SubSchemes` list

3. **Obtain Virtual Address**: Calculate `virtualAddressB = ConvertVirtualAddressToContractAddress(SchemeB)`

4. **Remove Beneficiary (Triggers Inconsistency)**: Manager calls `RemoveBeneficiary(schemeId: SchemeA, beneficiary: virtualAddressB, profitDetailId: null)`
   - Result: Entry removed from `State.ProfitDetailsMap[SchemeA][virtualAddressB]` via line 382
   - SchemeB still remains in `SchemeA.SubSchemes` list
   - **Inconsistent State Achieved**

5. **Trigger Vulnerability**: Manager calls `DistributeProfits(schemeId: SchemeA, period: 1, amountsMap: {"ELF": 1000})`
   - Execution path: `DistributeProfits` → `PerformDistributeProfits` → `DistributeProfitsForSubSchemes`
   - At line 634: `subItemDetail = State.ProfitDetailsMap[SchemeA][virtualAddressB]` returns **null**
   - At line 635: Attempting `foreach (var detail in subItemDetail.Details)` 
   - **Actual Result**: NullReferenceException thrown, transaction fails
   - **Expected Result**: Transaction succeeds and distributes profits

**Success Condition**: The transaction at step 5 fails with NullReferenceException, proving that profit distribution is completely DoS'd for SchemeA until the inconsistency is manually resolved.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-125)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });

        // Add a sub profit scheme.
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-155)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-241)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L376-383)
```csharp
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L585-604)
```csharp
    private void PerformDistributeProfits(Dictionary<string, long> profitsMap, Scheme scheme, long totalShares,
        Address profitsReceivingVirtualAddress)
    {
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var remainAmount = DistributeProfitsForSubSchemes(symbol, amount, scheme, totalShares);
            Context.LogDebug(() => $"Distributing {remainAmount} {symbol} tokens.");
            // Transfer remain amount to individuals' receiving profits address.
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L634-635)
```csharp
            var subItemDetail = State.ProfitDetailsMap[scheme.SchemeId][subItemVirtualAddress];
            foreach (var detail in subItemDetail.Details) detail.LastProfitPeriod = scheme.CurrentPeriod;
```
