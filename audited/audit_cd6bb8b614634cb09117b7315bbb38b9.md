### Title
Missing Order Value Validation in Round Structure Enables Consensus DoS Attack

### Summary
The `CommandStrategyBase` constructor accepts a `Round` parameter without validating that miner Order values are sequential starting from 1. The `GetMiningInterval()` method specifically filters for miners with `Order == 1` or `Order == 2`, while the validation logic in `CheckRoundTimeSlots()` only validates time intervals without enforcing proper Order assignment. A malicious miner can exploit this by submitting a `NextRoundInput` with invalid Order values, causing all nodes to crash when attempting to retrieve consensus commands.

### Finding Description

The vulnerability exists in the `CommandStrategyBase` constructor which accepts a `Round` parameter without validation: [1](#0-0) 

The `MiningInterval` property accesses `GetMiningInterval()` on the CurrentRound: [2](#0-1) 

The `GetMiningInterval()` method specifically filters for miners with `Order == 1` or `Order == 2`: [3](#0-2) 

If no miners have Order 1 or 2, the `firstTwoMiners` list will have fewer than 2 elements, and accessing `firstTwoMiners[1]` will throw an `ArgumentOutOfRangeException`.

The validation in `CheckRoundTimeSlots()` only verifies that ExpectedMiningTime is not null and time intervals are consistent, but does NOT validate Order values: [4](#0-3) 

This validation is called when a new round is provided: [5](#0-4) 

When a malicious `NextRoundInput` is processed, it passes validation and gets stored: [6](#0-5) 

The Round data is stored without additional validation: [7](#0-6) 

Subsequently, when any miner requests a consensus command, the malicious Round is retrieved and passed to strategy classes: [8](#0-7) 

All strategy implementations access the `MiningInterval` property, triggering the crash: [9](#0-8) [10](#0-9) [11](#0-10) 

### Impact Explanation

**Operational Impact**: Complete denial of service of the consensus mechanism. Once a malicious Round is stored in state, all nodes crash with an unhandled exception when attempting to retrieve consensus commands. This halts block production entirely until manual intervention.

**Severity Justification**: HIGH - The entire blockchain stops producing blocks. All miners are affected regardless of their behavior. The attack requires only a single malicious block from any current miner. Recovery requires coordinated manual intervention across all nodes to reset state, which is operationally complex and time-consuming.

**Who is Affected**: All network participants - miners cannot produce blocks, users cannot submit transactions, and the entire chain becomes frozen.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be an active miner (member of current or previous round's miner list), which is verified by `PreCheck()`: [12](#0-11) 

**Attack Complexity**: LOW - The attacker simply needs to:
1. Craft a `NextRoundInput` with miners having Orders starting from 10 (or any value other than starting from 1)
2. Set ExpectedMiningTime values correctly with consistent intervals
3. Submit a block containing this NextRoundInput

**Feasibility Conditions**: 
- No special economic cost beyond being a miner
- Single malicious block execution
- Validation passes because `CheckRoundTimeSlots()` doesn't check Order values
- Immediate and permanent impact on all nodes

**Detection Constraints**: The attack is difficult to detect before execution because the malformed Round passes all validation checks. Once executed, the impact is immediate and catastrophic.

**Probability**: MEDIUM-HIGH - While limited to miners, the attack is trivial to execute and has maximum impact with minimal cost.

### Recommendation

**Code-level Mitigation**:

1. Add Order validation to `CheckRoundTimeSlots()` to ensure Orders are sequential starting from 1:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };
    
    // Validate Orders are sequential starting from 1
    for (var i = 0; i < miners.Count; i++)
    {
        if (miners[i].Order != i + 1)
            return new ValidationResult { Message = $"Invalid miner order. Expected {i + 1}, got {miners[i].Order}." };
    }
    
    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
    
    // ... rest of validation
}
```

2. Add defensive validation in `CommandStrategyBase` constructor:

```csharp
protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime)
{
    Assert(currentRound != null, "CurrentRound cannot be null");
    Assert(currentRound.RealTimeMinersInformation != null, "RealTimeMinersInformation cannot be null");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(pubkey), "Pubkey must exist in miner list");
    
    if (currentRound.RealTimeMinersInformation.Count > 1)
    {
        var hasOrderOne = currentRound.RealTimeMinersInformation.Values.Any(m => m.Order == 1);
        var hasOrderTwo = currentRound.RealTimeMinersInformation.Values.Any(m => m.Order == 2);
        Assert(hasOrderOne && hasOrderTwo, "Round must have miners with Order 1 and 2");
    }
    
    CurrentRound = currentRound;
    Pubkey = pubkey;
    CurrentBlockTime = currentBlockTime;
}
```

**Test Cases**:
- Test NextRoundInput with Orders starting from 0
- Test NextRoundInput with Orders 2, 3, 4 (missing Order 1)
- Test NextRoundInput with duplicate Orders
- Test NextRoundInput with gaps in Order sequence
- Test GetMiningInterval() behavior with various Order configurations

### Proof of Concept

**Initial State**:
- Network running normally with N miners
- Current round has miners with proper Orders 1, 2, 3, ... N

**Attack Steps**:

1. Malicious miner (who is in current miner list) crafts a `NextRoundInput`:
   - Sets `RoundNumber` to `CurrentRound.RoundNumber + 1`
   - Creates N `MinerInRound` entries with Orders 10, 11, 12, ... (10+N-1)
   - Sets `ExpectedMiningTime` for each miner with consistent 4000ms intervals
   - Sets all other fields correctly (TermNumber, etc.)

2. Malicious miner produces a block with behavior `NextRound` containing this crafted input

3. Block validation executes:
   - `MiningPermissionValidationProvider`: PASSES (sender is valid miner)
   - `TimeSlotValidationProvider.CheckRoundTimeSlots()`: PASSES (ExpectedMiningTime set, intervals consistent)
   - `RoundTerminateValidationProvider`: PASSES (round number incremented correctly)

4. Block is accepted, `ProcessNextRound()` executes and stores malicious Round in `State.Rounds`

5. Next miner attempts to get consensus command via `GetConsensusCommand()`

6. Creates `NormalBlockCommandStrategy` with malicious Round

7. Accesses `MiningInterval` property → calls `GetMiningInterval()`

8. `GetMiningInterval()` filters for `Order == 1 || Order == 2` → finds 0 miners → `firstTwoMiners` is empty

9. Accessing `firstTwoMiners[1]` throws `ArgumentOutOfRangeException`

**Expected Result**: Normal consensus operation continues

**Actual Result**: All nodes crash with unhandled exception, consensus halts permanently

**Success Condition**: Chain stops producing blocks, all `GetConsensusCommand()` calls fail with exception

### Notes

This vulnerability demonstrates a critical gap between validation logic and usage assumptions. While `CheckRoundTimeSlots()` validates time-based properties of the Round structure, it assumes Orders are properly assigned. The `GetMiningInterval()` method has a hard dependency on specific Order values (1 and 2) existing, but this invariant is never enforced by validation. The mismatch creates an exploitable DoS vector that completely halts consensus with a single malicious block.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L28-33)
```csharp
        protected CommandStrategyBase(Round currentRound, string pubkey, Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;
            Pubkey = pubkey;
            CurrentBlockTime = currentBlockTime;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L20-57)
```csharp
    private ConsensusCommand GetConsensusCommand(AElfConsensusBehaviour behaviour, Round currentRound,
        string pubkey, Timestamp currentBlockTime = null)
    {
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        Context.LogDebug(() => $"Params to get command: {behaviour}, {pubkey}, {currentBlockTime}");

        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();

        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();

            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();

            case AElfConsensusBehaviour.TinyBlock:
            {
                var consensusCommand =
                    new ConsensusCommandProvider(new TinyBlockCommandStrategy(currentRound, pubkey,
                        currentBlockTime, GetMaximumBlocksCount())).GetConsensusCommand();
                return consensusCommand;
            }

            default:
                return ConsensusCommandProvider.InvalidConsensusCommand;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L38-39)
```csharp
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L35-37)
```csharp
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L34-38)
```csharp
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
                    ? MinerInRound.ActualMiningTimes.First()
                    : MinerInRound.ExpectedMiningTime;
            var currentTimeSlotEndTime = currentTimeSlotStartTime.AddMilliseconds(MiningInterval);
```
