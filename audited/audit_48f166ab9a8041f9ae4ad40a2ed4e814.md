### Title
Missing Validation of Next Round Mining Order Allows Position Manipulation

### Summary
Miners can manipulate their mining position in the next round by providing arbitrary `SupposedOrderOfNextRound` values without validation. The consensus mechanism calculates this value deterministically from the miner's signature but never validates that the miner-provided value matches the calculation, allowing miners to choose favorable positions for increased block rewards and MEV opportunities.

### Finding Description

The vulnerability exists in the UpdateValue processing flow where miners provide their next round order information without cryptographic validation.

**Root Cause:**

In `ProcessUpdateValue`, the miner's `SupposedOrderOfNextRound` is directly accepted from the `UpdateValueInput` transaction without verification: [1](#0-0) 

Similarly, `TuneOrderInformation` is applied without validating it contains only legitimate conflict resolutions: [2](#0-1) 

The correct calculation should use `GetAbsModulus(signature.ToInt64(), minersCount) + 1` as shown in the deterministic calculation: [3](#0-2) 

**Why Protections Fail:**

1. The `UpdateValueValidationProvider` only checks that signature and out-value are present, not that the order matches the signature: [4](#0-3) 

2. The `NextRoundMiningOrderValidationProvider` only validates the count of miners with orders, not the correctness of those orders: [5](#0-4) 

3. During validation, `RecoverFromUpdateValue` blindly copies the provided order values without recalculating them: [6](#0-5) 

**Execution Path:**

When generating next round information, miners are ordered by their `FinalOrderOfNextRound` values, which can be manipulated: [7](#0-6) 

### Impact Explanation

**Direct Harm:**
- Miners can position themselves as the first producer in the next round, gaining first-mover advantages for MEV extraction
- Unfair distribution of block rewards favoring manipulating miners
- Potential manipulation of extra block producer selection, as this is also calculated from order positions [8](#0-7) 

**Protocol Damage:**
- Undermines the cryptographic randomness guarantees of the AEDPoS consensus
- Allows strategic miners to consistently obtain favorable positions across rounds
- Could impact LIB (Last Irreversible Block) height calculations which depend on miner ordering

**Affected Parties:**
- Honest miners receive fewer block rewards due to unfair competition
- Network security degraded as consensus order becomes predictable
- Token holders affected by compromised consensus integrity

**Severity Justification:**
Medium severity - while this doesn't directly steal funds, it provides unfair advantages in block production that translate to significant economic benefits over time and undermines consensus fairness.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the current round
- Requires ability to produce blocks normally (already has mining privileges)
- No additional permissions or resources needed beyond normal mining

**Attack Complexity:**
- Low - attacker simply provides different `SupposedOrderOfNextRound` values in both consensus header extra data and transaction
- Both are generated by the same miner during block production, giving full control
- Only constraint is consistency between header and transaction, and avoiding duplicate final orders

**Feasibility:**
- Highly feasible - when generating consensus data via `GetConsensusExtraDataToPublishOutValue`, the miner has full control over the round information passed to `GetUpdateValueRound`: [9](#0-8) 

- The miner can modify order values before they're included in the simplified round for the header

**Detection/Operational Constraints:**
- Difficult to detect - manipulated orders look like normal consensus data
- No alerts or events triggered when orders deviate from expected calculations
- Would require offline analysis comparing signatures to reported orders

**Probability:**
High - straightforward exploit with significant economic incentives and low risk of detection.

### Recommendation

**Code-Level Mitigation:**

1. In `ProcessUpdateValue`, validate that `SupposedOrderOfNextRound` matches the deterministic calculation:

```csharp
// After line 247 in ProcessUpdateValue
var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), 
    currentRound.RealTimeMinersInformation.Count) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder,
    $"Invalid SupposedOrderOfNextRound. Expected {expectedOrder}, got {updateValueInput.SupposedOrderOfNextRound}");
```

2. Validate `TuneOrderInformation` by recalculating conflicts:

```csharp
// After line 260 in ProcessUpdateValue
var expectedTuneOrders = CalculateExpectedTuneOrders(currentRound, updateValueInput.Signature);
Assert(updateValueInput.TuneOrderInformation.SequenceEqual(expectedTuneOrders),
    "Invalid TuneOrderInformation provided");
```

3. Add a new validation provider `OrderCalculationValidationProvider` to verify order calculations during header validation.

**Invariant Checks:**
- Assert `SupposedOrderOfNextRound == GetAbsModulus(signature, minersCount) + 1` for all miners
- Assert `FinalOrderOfNextRound` values are unique across all miners who produced blocks
- Assert `TuneOrderInformation` only contains orders that actually had conflicts

**Test Cases:**
- Test case: Miner provides SupposedOrderOfNextRound = 1 when signature calculates to 5 → should fail
- Test case: Miner provides TuneOrderInformation for non-conflicting orders → should fail
- Test case: Multiple miners with same calculated order → conflict resolution should be deterministic and verifiable

### Proof of Concept

**Initial State:**
- Round N with 7 active miners (M1-M7)
- M1 has already mined with SupposedOrderOfNextRound = 3
- M2 is about to produce a block

**Attack Steps:**

1. M2 generates block with signature that would calculate to `SupposedOrderOfNextRound = GetAbsModulus(M2_signature, 7) + 1 = 5`

2. Instead of using calculated value 5, M2 provides `SupposedOrderOfNextRound = 1` in both:
   - Header extra data via `GetUpdateValueRound`
   - Transaction via `UpdateValueInput`

3. M2 optionally provides false `TuneOrderInformation` claiming M1 has a conflict (even though M1's order 3 doesn't conflict with M2's claimed order 1)

4. Block validation passes because:
   - No validator checks signature → order relationship
   - `NextRoundMiningOrderValidationProvider` only checks count matches
   - Values are consistent between header and transaction

5. `ProcessUpdateValue` accepts M2's claimed order = 1

6. Next round generation orders miners by `FinalOrderOfNextRound`, placing M2 first

**Expected Result:**
M2 should have `FinalOrderOfNextRound = 5` (from signature calculation)

**Actual Result:**
M2 has `FinalOrderOfNextRound = 1` and mines first in the next round

**Success Condition:**
M2 consistently obtains position 1 in subsequent rounds by always claiming `SupposedOrderOfNextRound = 1`, gaining unfair advantage in block rewards and MEV opportunities.

### Notes

The vulnerability stems from a fundamental design flaw: the system calculates `SupposedOrderOfNextRound` deterministically during block generation but treats it as untrusted input during validation and processing. This creates an exploitable gap where miners control values that should be cryptographically enforced. The conflict resolution mechanism via `TuneOrderInformation` further compounds the issue by allowing miners to manipulate not just their own order but potentially others' orders as well.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
