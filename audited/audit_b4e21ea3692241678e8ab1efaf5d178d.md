### Title
Partial Miner Replacement Causes isMinerListChanged Flag to Be Set Incorrectly, Allowing Banned Miners to Continue Mining

### Summary
In `GenerateNextRoundInformation()`, when the Election contract returns fewer alternative candidates than evil miners, the replacement loop only processes partial replacements but still sets `isMinerListChanged=true`. This leaves banned miners active in the consensus round while triggering side effects designed for complete miner list changes, including disabling secret sharing and bypassing mining permission checks.

### Finding Description

The vulnerability exists in the miner replacement logic within `GenerateNextRoundInformation()`: [1](#0-0) 

The loop iterates based on `minerReplacementInformation.AlternativeCandidatePubkeys.Count`, but the Election contract's `GetMinerReplacementInformation()` can return fewer alternatives than evil miners: [2](#0-1) 

The Election contract limits alternatives to available candidates from the previous term's snapshot and initial miners. When multiple miners are banned simultaneously and the candidate pool is limited, the method returns mismatched counts (lines 376-377, 383-392).

**Root Cause:** The consensus contract assumes a 1-to-1 correspondence between evil miners and alternatives, but no validation enforces `AlternativeCandidatePubkeys.Count == EvilMinerPubkeys.Count`.

**Why Existing Protections Fail:**
1. The `MiningPermissionValidationProvider` only checks if a pubkey exists in `RealTimeMinersInformation`, not whether it's banned: [3](#0-2) 

2. The `IsCurrentMiner` method does not check banned status: [4](#0-3) 

3. When `isMinerListChanged=true` is passed to generate the next round, it sets `IsMinerListJustChanged=true`: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Violation:**
- Banned miners who should be removed remain active and can produce blocks
- The banned miner retains their time slot, order, and block production privileges
- This violates the core invariant that evil miners must be excluded from consensus

**Secret Sharing Disruption:**
When `IsMinerListJustChanged=true`, secret sharing is skipped: [6](#0-5) 

This is intended for legitimate miner list changes but occurs even when banned miners remain, breaking the random number generation mechanism.

**Altered Consensus Behavior:**
The flag affects extra block producer logic: [7](#0-6) 

Unreplaced evil miners may gain or lose block production opportunities incorrectly.

**Severity:** High - Banned miners continue participating in consensus despite being marked as evil, undermining the security model.

### Likelihood Explanation

**Reachable Entry Point:** The consensus contract's normal round generation flow calls `GenerateNextRoundInformation()` during block production.

**Feasible Preconditions:**
1. Main chain operation (checked at line 299)
2. Same term (not transitioning to new term)
3. Multiple miners flagged as evil in `BannedPubkeyMap`
4. Limited candidate pool - election snapshot has fewer qualified candidates than evil miners
5. Initial miners either banned or already in current miner list

**Execution Practicality:**
This scenario naturally occurs when:
- Network has small candidate pool (side chains, early mainnet)
- Multiple miners violate consensus rules simultaneously
- Initial miners have also been compromised or banned

**Economic Rationality:** No attack cost required - this is a natural failure mode when legitimate banning mechanisms encounter insufficient replacement candidates.

**Probability:** Medium - More likely in smaller networks or during security incidents involving multiple miners, but not an everyday occurrence on established networks with healthy candidate pools.

### Recommendation

**Immediate Fix:**
Add validation after the replacement loop to ensure all evil miners were replaced:

```csharp
// After line 339, before line 341:
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count < 
    minerReplacementInformation.EvilMinerPubkeys.Count)
{
    // If we couldn't replace all evil miners, don't set the flag
    // and log a critical warning
    Context.LogDebug(() => 
        $"WARNING: Could only replace {minerReplacementInformation.AlternativeCandidatePubkeys.Count} " +
        $"of {minerReplacementInformation.EvilMinerPubkeys.Count} evil miners. " +
        "Miner list change incomplete.");
}
else if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
{
    isMinerListChanged = true;
}
```

**Additional Protection:**
Add banned status check in `MiningPermissionValidationProvider` by calling the Election contract to verify the miner is not banned before allowing block production.

**Invariant to Enforce:**
`isMinerListChanged` should only be `true` when ALL identified evil miners have been successfully replaced with valid alternatives.

**Test Cases:**
1. Test with `EvilMinerPubkeys.Count > AlternativeCandidatePubkeys.Count`
2. Verify unreplaced evil miners cannot produce blocks
3. Verify `IsMinerListJustChanged` is only true when replacement is complete
4. Test secret sharing continues when replacement is incomplete

### Proof of Concept

**Initial State:**
- Current round has 5 miners: [M1, M2, M3, M4, M5]
- Three miners marked as evil: M3, M4, M5 (in `BannedPubkeyMap`)
- Election snapshot has only 1 valid candidate: C1
- Initial miners are all banned or already mining

**Execution Steps:**
1. Round generation calls `GenerateNextRoundInformation()`
2. `GetMinerReplacementInformation()` is called with current miner list
3. Returns: `EvilMinerPubkeys=[M3, M4, M5]`, `AlternativeCandidatePubkeys=[C1]`
4. Replacement loop executes once (i=0):
   - M3 is replaced with C1
   - M4 and M5 remain in `currentRound.RealTimeMinersInformation`
5. `isMinerListChanged = true` is set (line 341)
6. Next round is generated with `IsMinerListJustChanged=true`

**Expected vs Actual Result:**
- **Expected:** Either all evil miners replaced OR flag remains false and replacements deferred
- **Actual:** Flag set to true, M4 and M5 remain active miners in next round
- **Verification:** M4 and M5 can still pass `MiningPermissionValidationProvider` check and produce blocks
- **Side Effect:** Secret sharing is skipped via the check at `AEDPoSContract_HelpMethods.cs:107`

**Success Condition:** Banned miners M4 and M5 successfully produce blocks in subsequent rounds despite being marked as evil, while the system believes a complete miner list change occurred.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-144)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-342)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-14)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```
