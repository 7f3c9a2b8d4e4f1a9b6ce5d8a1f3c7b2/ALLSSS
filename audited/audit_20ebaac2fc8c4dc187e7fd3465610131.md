### Title
Extra Block Producer Can Delay Secret Revelation by Manipulating NextRound Block Timing

### Summary
The extra block producer can delay producing the NextRound block beyond their designated time slot without validation enforcement. The `RevealSharedInValues()` function is called during NextRound block generation, and since `TimeSlotValidationProvider` only validates the structural correctness of the new round (not the current block time), the extra block producer can observe network state before revealing secrets, violating the fairness of the secret sharing mechanism.

### Finding Description

The vulnerability exists in the validation flow for NextRound consensus behavior: [1](#0-0) 

The `RevealSharedInValues()` function is called during NextRound block generation: [2](#0-1) 

The critical flaw is in the validation logic. When a new round is being produced, `TimeSlotValidationProvider` only validates the structural correctness of the round: [3](#0-2) 

At line 14, when `ProvidedRound.RoundId != BaseRound.RoundId` (indicating a new round), the validator only calls `CheckRoundTimeSlots()` which validates the structure: [4](#0-3) 

This method only checks that time slots are evenly spaced with positive intervals, but **does not validate whether `Context.CurrentBlockTime` is appropriate** for the extra block producer to be producing the NextRound block.

The `CheckMinerTimeSlot()` method that would validate timing is only called for same-round blocks (line 20-30 in TimeSlotValidationProvider), **not for NextRound transitions**.

The other validators for NextRound also don't check timing: [5](#0-4) [6](#0-5) 

While the extra block mining time is calculated: [7](#0-6) 

This calculated time is never enforced during validation for NextRound blocks.

### Impact Explanation

**Consensus Timing Manipulation**: The extra block producer can delay producing the NextRound block to observe network conditions, transaction mempool, price movements, or other miners' actions before committing to reveal secrets via `RevealSharedInValues()`. This violates the fairness guarantee of the secret sharing protocol.

**Specific Harms**:
1. **Unfair Information Advantage**: The attacker sees other blocks/transactions before revealing their secrets, gaining timing advantage
2. **Secret Sharing Compromise**: The security of the secret sharing mechanism relies on timely revelation; delayed revelation undermines this
3. **Round Transition Manipulation**: The attacker can strategically time the round transition to their advantage
4. **Minimum Attack Window**: At least one mining interval (typically 4000ms) of manipulation opportunity without other miners being able to intervene

**Affected Parties**: All network participants who rely on fair consensus timing and secret sharing integrity for randomness generation and block production order.

**Severity Justification (Medium)**: While not resulting in direct fund theft, this compromises a critical consensus invariant (correct round transitions and time-slot validation). The attack window is limited by the mining interval, and the attacker must already be designated as the extra block producer (1/N probability per round).

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the consensus set can execute this attack when they are designated as the extra block producer (rotation happens pseudo-randomly each round based on signatures). [8](#0-7) 

**Attack Complexity**: Very low - the attacker simply delays calling the NextRound consensus command that they would normally call.

**Feasibility Conditions**: 
- Attacker must be in the miner list (realistic for any block producer)
- Attacker must be designated as extra block producer for that round (1/N chance where N = number of miners)
- No additional permissions or compromises required

**Detection Constraints**: Difficult to detect as the delay appears as normal network latency or processing time within the allowed window.

**Probability**: Medium-High - every extra block producer has the opportunity and incentive to observe network state before committing.

### Recommendation

**Code-Level Mitigation**: 

Add timing validation in `TimeSlotValidationProvider` for new rounds. When validating NextRound behavior, check that the current block time is within an acceptable window of the expected extra block mining time:

Modify the validation logic to add:
```csharp
// In TimeSlotValidationProvider.ValidateHeaderInformation
if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
{
    // Existing structure check
    validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
    if (!validationResult.Success) return validationResult;
    
    // NEW: Add timing check for extra block producer
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextRound)
    {
        var expectedExtraBlockTime = validationContext.BaseRound.GetExtraBlockMiningTime();
        var miningInterval = validationContext.BaseRound.GetMiningInterval();
        var maxAllowedDelay = miningInterval; // One mining interval grace period
        
        if (validationContext.CurrentBlockTime < expectedExtraBlockTime ||
            validationContext.CurrentBlockTime > expectedExtraBlockTime.AddMilliseconds(maxAllowedDelay))
        {
            validationResult.Message = "NextRound block produced outside allowed time window";
            return validationResult;
        }
    }
}
```

**Invariant to Enforce**: NextRound blocks must be produced within `[GetExtraBlockMiningTime(), GetExtraBlockMiningTime() + MiningInterval]` time window.

**Test Cases**: 
1. Verify NextRound block is rejected if produced before `GetExtraBlockMiningTime()`
2. Verify NextRound block is rejected if produced after `GetExtraBlockMiningTime() + MiningInterval`  
3. Verify NextRound block is accepted within the valid time window
4. Verify other miners can produce "saving" blocks if extra block producer delays beyond window

### Proof of Concept

**Initial State**:
- Network has N miners in current round
- Miner A is designated as extra block producer
- All regular miners have completed their time slots
- Current time = `GetExtraBlockMiningTime()` (start of extra block time slot)

**Attack Steps**:
1. Miner A receives GetConsensusCommand indicating NextRound behavior
2. Miner A delays producing the NextRound block for time T (where T < mining_interval)
3. During delay, Miner A observes:
   - Other transactions in mempool
   - Price movements in token contracts
   - Actions by other network participants
4. At time `GetExtraBlockMiningTime() + T`, Miner A produces NextRound block
5. Block validation occurs via ValidateBeforeExecution
6. TimeSlotValidationProvider sees new RoundId, calls CheckRoundTimeSlots() - passes (only checks structure)
7. No validator checks that CurrentBlockTime is appropriate for extra block timing
8. Block is accepted and RevealSharedInValues() executes with delayed timing

**Expected Result**: Block should be rejected for being produced outside proper time window

**Actual Result**: Block is accepted, secrets are revealed at manipulated time, Miner A gains information advantage

**Success Condition**: Miner A successfully delays secret revelation by time T while validation passes

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```
