### Title
Next Round Order Manipulation via Unvalidated FinalOrderOfNextRound Values in UpdateValue

### Summary
A malicious miner can manipulate `FinalOrderOfNextRound` values for all miners during `UpdateValue` block production, granting themselves favorable positions (such as first miner or extra block producer) in subsequent rounds. The consensus validation logic fails to verify that order values are correctly calculated from signatures, allowing manipulated values to propagate through `RecoverFromUpdateValue` and determine the next round's mining schedule.

### Finding Description

The vulnerability exists in the consensus update flow across multiple files: [1](#0-0) 

The `GetUpdateValueRound()` function creates a simplified round containing `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` for **all miners**, not just the target pubkey. These values are copied from the current round state into the block header without cryptographic commitment to their correctness. [2](#0-1) 

During validation, `RecoverFromUpdateValue()` blindly copies these order values from the block header into the consensus state for **all miners** without verification. [3](#0-2) 

The validation logic only checks that the sender's `OutValue` and `Signature` are filled, and that `PreviousInValue` is correct. **There is no validation** that `SupposedOrderOfNextRound` or `FinalOrderOfNextRound` values match their expected calculation. [4](#0-3) 

The correct calculation should be: `supposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), minersCount) + 1`, followed by deterministic conflict resolution. However, this calculation is only performed locally during block creation and never validated by other nodes. [5](#0-4) 

The manipulated `FinalOrderOfNextRound` values are then used directly to assign mining orders in the next round, with lower order numbers mining earlier and having preferential access to block production rewards. [6](#0-5) 

The transaction processing applies `TuneOrderInformation` to modify other miners' order values without verifying these modifications are legitimate.

### Impact Explanation

**Consensus Integrity Violation**: A malicious miner can arbitrarily determine the mining order for the next round, fundamentally breaking the consensus mechanism's fairness and randomness guarantees.

**Direct Economic Impact**: 
- The attacker can assign themselves `FinalOrderOfNextRound = 1` to always mine first in subsequent rounds
- By mining first repeatedly, they capture more block production opportunities and associated mining rewards
- The attacker can manipulate which miner becomes the extra block producer (who produces an additional block per round)
- Other honest miners suffer reduced mining opportunities and rewards

**Severity Justification**: This is **Critical** because:
1. Any active miner can exploit this without special privileges
2. The attack directly subverts consensus fairness
3. It enables sustained reward manipulation across multiple rounds
4. The consensus system's security model assumes order values reflect cryptographic randomness from signatures, which this attack violates

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the active consensus set can execute this attack. The attacker needs only to:
1. Run a modified node that manipulates the `Round` object before calling `GetUpdateValueRound()`
2. Include the manipulated data in their block header and corresponding transaction

**Attack Complexity**: Low. The attacker modifies their local consensus client to set desired `FinalOrderOfNextRound` values before block creation. Both the block header (via `GetConsensusExtraData`) and transaction (via `GenerateConsensusTransactions`) are generated locally with the same manipulated values, so hash verification passes. [7](#0-6) 

**Feasibility**: The attack is immediately executable. The validation logic has no checks for order value correctness, and the hash-based validation in `ValidateConsensusAfterExecution` only confirms consistency between header and transaction data, not correctness against the protocol rules.

**Detection Constraints**: The attack is difficult to detect because manipulated order values appear valid to all validation checks. Only manual auditing of whether order assignments follow the signature-based calculation would reveal the manipulation.

**Economic Rationality**: The attack cost is zero (no additional resources beyond normal block production), while benefits include increased mining rewards and strategic control over consensus timing.

### Recommendation

**Immediate Fix**: Add validation in `UpdateValueValidationProvider` to verify order value correctness:

1. Recalculate `SupposedOrderOfNextRound` from the sender's signature and verify it matches the provided value:
   ```
   expectedSupposedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1
   Assert(minerInRound.SupposedOrderOfNextRound == expectedSupposedOrder, "Invalid SupposedOrderOfNextRound")
   ```

2. For each entry in `TuneOrderInformation`, verify the conflict resolution follows the deterministic algorithm by simulating conflict resolution and comparing results.

3. Add a validation provider that checks `FinalOrderOfNextRound` values are within valid range `[1, minersCount]` and have no duplicates among miners who produced blocks.

**Architectural Fix**: Make order calculation part of the consensus validation rather than relying on block producer honesty. Store signatures in the block and have validators independently calculate next-round orders during validation.

**Test Cases**:
1. Test that blocks with manipulated `FinalOrderOfNextRound` values are rejected
2. Test that conflict resolution is deterministic and cannot be manipulated
3. Test that order values outside valid range are rejected
4. Fuzz test with various signature values to ensure order calculation is consistently validated

### Proof of Concept

**Initial State**:
- Round N with 5 active miners: A, B, C, D, E
- Miner A (attacker) is scheduled to produce next block
- Current `FinalOrderOfNextRound` values are distributed: A=3, B=1, C=5, D=2, E=4

**Attack Sequence**:

1. Miner A's modified node calls `GetConsensusExtraData` for `UpdateValue` behavior
2. Before `GetUpdateValueRound()` is called, attacker modifies the `updatedRound`:
   - Sets `updatedRound.RealTimeMinersInformation[A].FinalOrderOfNextRound = 1`
   - Sets `updatedRound.RealTimeMinersInformation[B].FinalOrderOfNextRound = 5`
   - Keeps other miners' values unchanged
3. Modified `GetUpdateValueRound()` returns simplified round with manipulated values in block header
4. `ExtractInformationToUpdateConsensus()` generates `UpdateValueInput` with `TuneOrderInformation` reflecting the manipulations
5. Block is broadcast with manipulated data

**Validation Flow** (all pass):
- `ValidateBeforeExecution`: `UpdateValueValidationProvider` only checks `OutValue`/`Signature`, passes
- Execution: `ProcessUpdateValue` applies manipulated order values to state
- `ValidateConsensusAfterExecution`: Hash comparison passes because header and transaction data match

**Expected Result**: Block should be rejected for invalid order values

**Actual Result**: Block is accepted, and in Round N+1:
- Miner A mines in position 1 (earliest time slot)
- Miner B pushed to position 5 (latest time slot)
- Attacker gains preferential mining position and can repeat attack

**Success Condition**: After the attack block is accepted, querying the consensus state shows Miner A has `Order = 1` in Round N+1, despite this not being their legitimate calculated position.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-31)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);
```
