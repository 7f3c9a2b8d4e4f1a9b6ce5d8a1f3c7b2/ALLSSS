### Title
ImpliedIrreversibleBlockHeight Validation Bypass Due to Premature State Recovery

### Summary
The `LibInformationValidationProvider` validation logic is broken because `RecoverFromUpdateValue` modifies `baseRound` before validation occurs, causing the check to compare identical values instead of StateDb values against provided values. This allows malicious miners to report artificially low `ImpliedIrreversibleBlockHeight` values that should be rejected, potentially preventing Last Irreversible Block (LIB) advancement.

### Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior: [1](#0-0) 

Before validation providers are invoked, `RecoverFromUpdateValue` is called on `baseRound`, which copies values from `providedRound` into `baseRound`, including the miner's `ImpliedIrreversibleBlockHeight`: [2](#0-1) 

Subsequently, the `LibInformationValidationProvider` attempts to validate that the miner's `ImpliedIrreversibleBlockHeight` hasn't decreased: [3](#0-2) 

**Root Cause**: Since `baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` was just overwritten with `providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight` on line 19 of `Round_Recover.cs`, the comparison at line 25-26 of `LibInformationValidationProvider.cs` always compares identical values, making this validation check ineffective.

The intended behavior is to compare the value from StateDb (representing the miner's previous reported height) against the new value being provided, rejecting any regression. However, the premature recovery destroys the StateDb baseline before comparison.

### Impact Explanation

**Operational Impact - High Severity**:

1. **LIB Finalization Prevention**: Malicious miners can report artificially low `ImpliedIrreversibleBlockHeight` values. During LIB calculation, these values are sorted and the value at position (count-1)/3 is selected as the new LIB height: [4](#0-3) 

If 1/3+ miners collude to provide fake low values, the calculated LIB will be artificially suppressed.

2. **Cross-Chain Operations Disruption**: LIB height is critical for cross-chain verification and merkle proof validation. Stalled LIB prevents parent/side-chain synchronization.

3. **State Management Issues**: LIB determines which blocks can be safely pruned. Preventing LIB advancement causes unbounded state growth and resource exhaustion.

4. **Transaction Finality Delay**: Users cannot achieve finality guarantees on their transactions, affecting economic activity and confidence.

While this is a liveness attack rather than a safety violation (LIB cannot decrease due to the check at line 272 of ProcessUpdateValue), the operational impact is severe enough to warrant HIGH severity. [5](#0-4) 

### Likelihood Explanation

**Medium Likelihood**:

**Attacker Capabilities**: 
- Must be an elected miner in the consensus round
- Can modify consensus extra data before block production since `ImpliedIrreversibleBlockHeight` is set by the contract at: [6](#0-5) 

The miner receives this data and can tamper with it before signing and producing the block.

**Attack Complexity**: 
- Low complexity for individual miner to provide false data
- Medium complexity to coordinate 1/3+ miners for significant LIB impact
- No cryptographic protection prevents miners from modifying their own consensus extra data

**Feasibility Conditions**:
- Block validation is sequential (not concurrent), eliminating race conditions
- Post-execution validation also fails to detect tampering since StateDb is already updated with fake values
- No upper-bound validation exists, only lower-bound (preventing LIB regression)

**Detection/Operational Constraints**:
- Attack is detectable through monitoring of individual miner `ImpliedIrreversibleBlockHeight` reports
- Miners have reputation and economic stake at risk through the election mechanism
- However, subtle variations may go unnoticed if not explicitly monitored

The attack requires malicious intent from elected miners but is technically straightforward to execute once mining permissions are obtained.

### Recommendation

**Immediate Fix**:

1. Store the original `baseRound` miner information before calling `RecoverFromUpdateValue`:

```csharp
// In AEDPoSContract_Validation.cs, around line 46
var originalBaseRound = baseRound.Clone(); // Or save specific fields

if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    OriginalBaseRound = originalBaseRound, // Add this field
    // ... rest of context
};
```

2. Update `LibInformationValidationProvider` to use the original values:

```csharp
// Compare against ORIGINAL StateDb values, not recovered values
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    validationContext.OriginalBaseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
{
    validationResult.Message = "Incorrect implied lib height.";
    return validationResult;
}
```

**Additional Validations**:

1. Add upper-bound check to ensure `ImpliedIrreversibleBlockHeight` doesn't exceed reasonable thresholds relative to `Context.CurrentHeight`
2. Add monotonicity check across a miner's recent blocks (not just within one round)
3. Consider adding cryptographic commitment to `ImpliedIrreversibleBlockHeight` that's verified post-execution

**Test Cases**:

1. Test that miner providing lower `ImpliedIrreversibleBlockHeight` than previous block is rejected
2. Test that miner providing significantly lower value triggers validation failure
3. Test normal case where `ImpliedIrreversibleBlockHeight` increases monotonically passes
4. Test boundary conditions around round transitions

### Proof of Concept

**Initial State**:
- Current round R at block height 100
- Miner Alice has previously produced blocks with `ImpliedIrreversibleBlockHeight = 100`
- StateDb contains: `State.Rounds[R].RealTimeMinersInformation["Alice"].ImpliedIrreversibleBlockHeight = 100`

**Attack Sequence**:

1. **Block Production**: At height 150, Alice requests consensus extra data. The contract sets:
   - `updatedRound.RealTimeMinersInformation["Alice"].ImpliedIrreversibleBlockHeight = 150` (Context.CurrentHeight)

2. **Tampering**: Alice modifies the consensus extra data before producing the block:
   - Changes `ImpliedIrreversibleBlockHeight` from 150 to 50 (fake low value)
   - Signs and produces the block with modified data

3. **Validation** (`ValidateBeforeExecution`):
   - Loads `baseRound` from StateDb (has Alice's ImpliedIrreversibleBlockHeight = 100)
   - Calls `baseRound.RecoverFromUpdateValue(providedRound, "Alice")`
   - This updates `baseRound.RealTimeMinersInformation["Alice"].ImpliedIrreversibleBlockHeight = 50`
   - `LibInformationValidationProvider` checks: `50 > 50`? NO → **Passes (Should Reject)**

4. **Expected vs Actual**:
   - **Expected**: Validation should compare `100 > 50` → TRUE → Reject block
   - **Actual**: Validation compares `50 > 50` → FALSE → Accept block

5. **Execution**: `ProcessUpdateValue` stores the fake value (50) in StateDb

6. **Result**: Alice successfully injected false `ImpliedIrreversibleBlockHeight = 50` into the consensus state, contributing to artificially low LIB calculation in subsequent rounds.

**Success Condition**: Block with regressed `ImpliedIrreversibleBlockHeight` is accepted when it should be rejected, and the fake value persists in StateDb for future LIB calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
