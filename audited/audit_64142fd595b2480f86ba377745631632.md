### Title
Manipulation of IsMinerListJustChanged Flag Allows Unauthorized Extra Block Production After Miner List Changes

### Summary
A malicious block producer can manipulate the `IsMinerListJustChanged` flag to `false` when generating a `NextRound` transaction, even when miner replacements occur. This allows the extra block producer from the previous round to continue producing tiny blocks in the new round despite the miner list change, violating consensus rules and enabling unfair mining reward extraction.

### Finding Description

The vulnerability exists in the consensus behaviour determination logic and the lack of validation for the `IsMinerListJustChanged` flag: [1](#0-0) 

The check at line 73 uses `!CurrentRound.IsMinerListJustChanged` to determine if the extra block producer from the previous round can continue producing tiny blocks. The logic intends to prevent this when the miner list has just changed (first round of new term or after miner replacement).

However, the flag can be manipulated during round generation: [2](#0-1) 

When a miner replacement occurs (lines 301-342), `isMinerListChanged` should be set to `true` at line 341. However, a malicious block producer generating the `NextRound` consensus extra data can:
1. Still apply the miner replacement (to pass validation)
2. Manually set `IsMinerListJustChanged = false` in the constructed Round object
3. Include this in the `NextRoundInput` [3](#0-2) 

The input directly transfers the flag value, and when processed: [4](#0-3) 

The `ProcessNextRound` function at line 110 converts the input to a Round and stores it without validating the flag.

**Why Protections Fail:**

The validation providers do not check if `IsMinerListJustChanged` is set correctly: [5](#0-4) 

The `NextRound` validation only checks round number increments and that InValues are null, not the flag's correctness. [6](#0-5) 

The after-execution validation compares hashes using the flag value (line 99), but since both header and state contain the manipulated value, they match and validation passes.

### Impact Explanation

**Direct Harm:**
- **Mining Reward Misallocation**: The extra block producer from the previous round earns additional mining rewards by producing more tiny blocks than permitted after a miner list change
- **Unfair Competitive Advantage**: One miner gains disproportionate block production rights over others in the round
- **Consensus Rule Violation**: Breaks the invariant that extra block rights should not carry over when the miner list changes

**Quantification:**
- Maximum tiny blocks per miner is determined by `_maximumBlocksCount`
- The exploiting miner can produce up to `_maximumBlocksCount + blocksBeforeCurrentRound` blocks when they should be limited to their normal allocation
- Each extra block earns `GetMiningRewardPerBlock()` rewards [7](#0-6) 

**Who is Affected:**
- Other honest miners who lose their fair share of block production
- The network's consensus integrity
- Token holders whose mining rewards are unfairly distributed

**Severity Justification:**
HIGH severity due to:
- Direct financial impact (reward theft)
- Consensus integrity violation
- Unfair advantage that compounds over multiple rounds
- Can be repeated by any block producer during miner replacements

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a miner in the consensus set (semi-trusted role)
- Must be the block producer who terminates a round when miner replacement occurs
- This role rotates among all miners, making the opportunity regular

**Attack Complexity:**
- LOW - Requires only modifying local consensus extra data generation code
- The attacker locally calls `GenerateNextRoundInformation` and changes one flag value
- No complex cryptographic operations or multi-step transactions required

**Feasibility Conditions:**
- Occurs during miner replacement events within a term
- Miner replacement happens when the Election contract detects evil miners (those who miss too many time slots)
- This is a regular occurrence in normal network operation

**Detection Constraints:**
- Difficult to detect because the manipulated flag is stored on-chain as legitimate state
- The miner replacement is correctly applied, only the flag is wrong
- No obvious transaction pattern distinguishes this from normal operation

**Probability Reasoning:**
HIGH probability because:
1. Miner replacements occur regularly as part of consensus mechanism
2. Any miner can become a block producer through normal rotation
3. The attack is undetectable and has direct financial benefit
4. No technical barriers prevent execution
5. The attack can be automated in modified node software

### Recommendation

**Code-Level Mitigation:**

Add validation in `ValidateBeforeExecution` to verify `IsMinerListJustChanged` matches actual miner list changes:

1. In `RoundTerminateValidationProvider`, add a check for NextRound behaviour:
   - Query `State.ElectionContract.GetMinerReplacementInformation` with the previous round's miner list
   - If replacements are returned, assert `extraData.Round.IsMinerListJustChanged == true`
   - If no replacements, assert `extraData.Round.IsMinerListJustChanged == false` (unless it's a term change on sidechains)

2. For side chains, add validation in `ValidationForNextRound`:
   - Compare the miner list hash of the provided round against the main chain miner list
   - If different, assert `IsMinerListJustChanged == true`

**Invariant Checks:**
Add assertion in `ProcessNextRound`:
```
if (nextRound.IsMinerListJustChanged) {
    // Verify this is justified by either:
    // 1. Miner replacement occurred
    // 2. Side chain main chain miner list changed
    // Assert the flag matches reality
}
```

**Test Cases:**
1. Test that NextRound with miner replacement and `IsMinerListJustChanged=false` is rejected
2. Test that extra block producer rights do not carry over when flag is true
3. Test that legitimate miner replacements set the flag correctly and are accepted
4. Test side chain scenario where main chain miner list changes

### Proof of Concept

**Initial State:**
- Round N-1: Active with 5 miners (A, B, C, D, E)
- Miner A is the extra block producer
- Miner B has missed excessive time slots and is marked as evil by Election contract
- Alternative candidate Miner F is ready to replace B

**Attack Steps:**

1. Miner D (or any miner) terminates Round N-1 by producing the last block
2. When generating consensus extra data for the terminating block:
   - Call `GenerateNextRoundInformation` locally
   - The function queries Election contract and gets replacement info (B â†’ F)
   - The function applies the replacement and sets `isMinerListChanged = true`
   - **ATTACK**: Before creating `NextRoundInput`, manually set `IsMinerListJustChanged = false`
   - Create block with this manipulated Round information

3. Block validation:
   - `ValidateBeforeExecution` runs - PASSES (no check for flag correctness)
   - `NextRound` transaction executes - stores manipulated Round
   - `ValidateAfterExecution` runs - PASSES (header matches state)

4. Round N begins with:
   - Miners: A, C, D, E, F (B replaced)
   - `IsMinerListJustChanged = false` (WRONG - should be true)
   - `ExtraBlockProducerOfPreviousRound = "A"`

5. Exploitation:
   - Miner A queries `GetConsensusCommand` to produce blocks
   - Check at line 71-79 evaluates: `"A" == "A" && !false && block_count_ok`
   - Returns `TinyBlock` behaviour
   - Miner A produces extra blocks beyond normal allocation

**Expected vs Actual Result:**
- **Expected**: Miner A should NOT get extra block production rights because miner list changed
- **Actual**: Miner A CAN produce extra blocks and earns additional mining rewards

**Success Condition:**
Miner A successfully produces `_maximumBlocksCount + blocksBeforeCurrentRound` blocks in Round N, earning extra mining rewards, despite the miner list having changed from Round N-1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-346)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L143-151)
```csharp
    private long GetMiningRewardPerBlock()
    {
        var miningReward = AEDPoSContractConstants.InitialMiningRewardPerBlock;
        var blockAge = GetBlockchainAge();
        var denominator = blockAge.Div(AEDPoSContractConstants.TimeToReduceMiningRewardByHalf);
        for (var i = 0; i < denominator; i++) miningReward = miningReward.Div(2);

        return miningReward;
    }
```
