### Title
Governance Deadlock via Non-Member Proposer Whitelist Leading to Irrecoverable Organization Paralysis

### Summary
The `ChangeOrganizationProposerWhiteList` function lacks validation to ensure overlap between the proposer whitelist and organization member list. This allows setting a proposer whitelist containing only non-members, creating a governance deadlock where members cannot create proposals to recover, and the organization becomes permanently paralyzed if non-member proposers become uncooperative or unavailable.

### Finding Description

The vulnerability exists in the Association contract's organization validation and proposer authorization logic.

**Root Cause**: The `Validate` function only checks that both `ProposerWhiteList` and `OrganizationMemberList` are non-empty and contain no duplicates, but does NOT verify any overlap between these lists. [1](#0-0) 

When `ChangeOrganizationProposerWhiteList` is called, it updates the whitelist and validates the organization, but this validation cannot prevent a whitelist containing only non-members: [2](#0-1) 

**Authorization Separation**: The contract enforces strict separation between who can propose and who can vote:

- Only addresses in `ProposerWhiteList` can create proposals (enforced by `AssertIsAuthorizedProposer`): [3](#0-2) 

- Only addresses in `OrganizationMemberList` can vote on proposals (enforced by `AssertIsAuthorizedOrganizationMember`): [4](#0-3) 

**No Recovery Path**: To change the whitelist back, the organization must call `ChangeOrganizationProposerWhiteList` through a proposal. However, only the organization address itself can call this method: [5](#0-4) 

This creates a circular dependency: members need a proposal to fix the whitelist, but only non-member proposers can create that proposal.

### Impact Explanation

**Severity: HIGH - Complete Governance Denial of Service**

Once the proposer whitelist is set to contain only non-members and those non-members become uncooperative or unavailable:

1. **Permanent Governance Paralysis**: Organization members cannot create any proposals to:
   - Change the proposer whitelist back
   - Transfer assets held by the organization
   - Update approval thresholds
   - Add/remove members
   - Execute any governance action

2. **Asset Lock**: Any tokens or assets held by the organization's virtual address become permanently locked, as executing transfers requires proposal approval and release.

3. **No Recovery Mechanism**: The contract provides no emergency override, admin function, or alternative path to recover from this state.

4. **Affected Parties**: All organization members lose governance rights and access to organization-controlled assets.

The organization becomes a "zombie" - it exists on-chain but cannot perform any governance functions, making it permanently inoperable.

### Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Capabilities**: Requires ability to create and pass a proposal (either as a legitimate member or through social engineering).

**Attack Complexity**: LOW
- No special privileges required beyond normal proposal creation
- No validation prevents setting non-member proposers
- Easy to execute through standard proposal workflow

**Feasible Scenarios**:
1. **Social Engineering**: Attacker convinces members to approve a proposal claiming to "add new trusted proposers" without members realizing they're being removed
2. **Operational Error**: Members accidentally vote for a proposal that sets wrong addresses (e.g., testnet addresses on mainnet)
3. **Malicious Insider**: A member with sufficient voting power intentionally sabotages the organization
4. **Key Loss**: After legitimate whitelist change, non-member proposers lose private keys or become unavailable

**Execution Practicality**: The test suite confirms whitelist changes work as expected, with no overlap validation: [6](#0-5) 

**Economic Rationality**: Attack cost is minimal (gas for proposal creation/voting), while potential damage is complete loss of governance over the organization's assets.

### Recommendation

**Primary Mitigation**: Add validation to ensure at least one address exists in both the proposer whitelist and member list.

Modify the `Validate` function in `Association_Helper.cs`:

```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
        
    // ADD THIS CHECK:
    // Ensure at least one proposer is also a member to prevent governance deadlock
    var hasOverlap = organization.ProposerWhiteList.Proposers
        .Any(proposer => organization.OrganizationMemberList.Contains(proposer));
    if (!hasOverlap)
        return false;
        
    if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
        return false;
    // ... rest of validation
}
```

**Alternative Mitigation**: Allow organization members to create "recovery proposals" if no proposer is a member (requires more significant refactoring).

**Test Cases**: Add tests verifying:
1. Creating organization with non-overlapping lists fails
2. Changing whitelist to non-overlapping list fails
3. Organization with at least one member-proposer can always self-govern

### Proof of Concept

**Initial State**:
- Organization created with members: [AddressA, AddressB, AddressC]
- Initial proposer whitelist: [AddressA, AddressB, AddressC]
- Approval threshold: 2/3 members

**Attack Sequence**:

1. **Malicious Proposal Creation**: AddressA creates a proposal to call `ChangeOrganizationProposerWhiteList` with:
   ```
   ProposerWhiteList = { AddressX, AddressY, AddressZ }
   ```
   where X, Y, Z are NOT in the member list

2. **Proposal Approval**: AddressA and AddressB approve the proposal (deceived or malicious)

3. **Proposal Release**: AddressA releases the approved proposal

4. **State After Attack**:
   - Organization members: [AddressA, AddressB, AddressC] (unchanged)
   - Proposer whitelist: [AddressX, AddressY, AddressZ] (non-members)

5. **Deadlock Demonstration**:
   - AddressA tries to create proposal to fix whitelist → **FAILS** ("Unauthorized to propose")
   - AddressX creates proposal to fix whitelist → **SUCCEEDS**
   - AddressA, AddressB, AddressC approve it → **SUCCEEDS**
   - But if AddressX, AddressY, AddressZ are hostile/unavailable → **Cannot release proposal**
   - Organization is permanently deadlocked

**Expected Result**: Proposal to change whitelist should be rejected during validation

**Actual Result**: Proposal succeeds, organization enters unrecoverable deadlock state when non-member proposers become unavailable

**Success Condition**: After step 5, no member can create proposals, and organization governance is permanently disabled if non-member proposers don't cooperate.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L790-839)
```csharp
    public async Task Change_OrganizationProposalWhitelist_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);

        var proposerWhiteList = new ProposerWhiteList
        {
            Proposers = { Reviewer2 }
        };

        var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair, proposerWhiteList,
            nameof(associationContractStub.ChangeOrganizationProposerWhiteList), organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, changeProposalId);
        var releaseResult = await associationContractStub.Release.SendAsync(changeProposalId);
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        await TransferToOrganizationAddressAsync(organizationAddress);
        var transferInput = new TransferInput
        {
            Symbol = "ELF",
            Amount = 100,
            To = Reviewer1,
            Memo = "Transfer"
        };
        associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
        var createProposalInput = new CreateProposalInput
        {
            ContractMethodName = nameof(TokenContractStub.Approve),
            ToAddress = TokenContractAddress,
            Params = transferInput.ToByteString(),
            ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
            OrganizationAddress = organizationAddress
        };
        var result = await associationContractStub.CreateProposal.SendWithExceptionAsync(createProposalInput);
        result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        result.TransactionResult.Error.ShouldContain("Unauthorized to propose.");

        //Verify association proposal
        var verifyResult = await associationContractStub.ValidateProposerInWhiteList.CallAsync(
            new ValidateProposerInWhiteListInput
            {
                OrganizationAddress = organizationAddress,
                Proposer = Reviewer2
            });
        verifyResult.Value.ShouldBeTrue();
    }
```
