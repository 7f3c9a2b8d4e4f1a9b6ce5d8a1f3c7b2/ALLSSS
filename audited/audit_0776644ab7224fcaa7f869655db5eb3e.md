### Title
Consensus Halt via Unvalidated Mining Order Manipulation in UpdateValue Behavior

### Summary
A malicious miner can include arbitrary `FinalOrderOfNextRound` values for all miners in the consensus header data of an UpdateValue block, bypassing validation and corrupting the consensus state. This causes multiple miners to be assigned the same mining order in the next round, resulting in consensus halt as no valid NextRound block can be produced.

### Finding Description

The vulnerability exists in the UpdateValue consensus flow where miners can manipulate mining orders for the next round without proper validation.

**Root Cause:**

The `RecoverFromUpdateValue` function unconditionally overwrites `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` for ALL miners based on the provided round data from the block header: [1](#0-0) 

This function is called during validation to prepare the base round state: [2](#0-1) 

However, the `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring the order values: [3](#0-2) 

**Exploitation Path:**

When the block executes, `ExtractInformationToUpdateConsensus` extracts miners where `FinalOrderOfNextRound` differs from `SupposedOrderOfNextRound` into `TuneOrderInformation`: [4](#0-3) 

This transaction is generated from the block header's round data: [5](#0-4) 

The malicious `TuneOrderInformation` is then applied directly to state without any validation: [6](#0-5) 

**Failed Protection:**

The after-execution validation has a critical bug where it modifies the comparison object in place, causing it to compare an object's hash with itself: [7](#0-6) 

Since `RecoverFromUpdateValue` modifies `this` and returns it, both `headerInformation.Round` and `currentRound` reference the same modified object, making the hash comparison always pass.

**Impact on Next Round:**

When generating the next round, miners are ordered by their `FinalOrderOfNextRound` and assigned positions: [8](#0-7) 

If all miners have `FinalOrderOfNextRound = 1`, they all receive `Order = 1` in the next round, creating an invalid consensus state where multiple miners believe they should mine at the same time slot.

### Impact Explanation

**Consensus Halt:**
- Multiple miners assigned the same `Order` in the next round violates the fundamental consensus invariant that each miner must have a unique time slot
- When the next round should start, either:
  1. `NextRoundMiningOrderValidationProvider` fails validation (if it functions correctly), preventing ANY NextRound block from being produced, OR
  2. An invalid NextRound is produced with duplicate orders, causing multiple miners to attempt mining simultaneously
- Either scenario results in consensus halt as the chain cannot progress beyond the current round

**Affected Parties:**
- All network participants: Chain becomes unable to produce new blocks
- Applications: Cannot execute transactions or queries on frozen chain
- Economic impact: Complete disruption of on-chain operations until manual intervention

**Severity Justification:**
This is **HIGH severity** because it achieves complete denial of service of the consensus mechanism, the most critical component of the blockchain. Unlike temporary disruptions, this corruption requires manual intervention or chain restart to recover.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires attacker to be an active miner in the current round
- Miner controls the consensus extra data included in their block header
- No special permissions beyond normal mining rights required

**Attack Complexity:**
- Low: Attacker simply modifies the `Round` object returned from `GetConsensusExtraData` before including it in the block header
- The manipulation is straightforward: set all miners' `FinalOrderOfNextRound` to the same value (e.g., 1)
- No timing constraints or race conditions required

**Feasibility Conditions:**
- Attacker must have one mining slot in the current round (standard for any miner)
- No additional prerequisites or special chain state required
- Attack succeeds on first attempt if validation passes

**Detection Constraints:**
- Block appears valid during validation
- Corruption only becomes apparent when attempting to generate the next round
- By that time, the malicious state is already committed

**Probability Assessment:**
HIGH likelihood - Any compromised or malicious miner can execute this attack during any round they participate in. The attack is deterministic and requires no special conditions.

### Recommendation

**Immediate Fix:**

1. Add validation of `TuneOrderInformation` in `UpdateValueValidationProvider`:
   - Verify that each pubkey in `TuneOrderInformation` exists in the current round
   - Verify that all `FinalOrderOfNextRound` values are unique across all miners
   - Verify that values are within valid range [1, minersCount]

2. Fix the after-execution validation bug:
   - Create a copy of `currentRound` before calling `RecoverFromUpdateValue`
   - Compare the recovered header round against the unmodified current round copy

3. Add explicit check in `ProcessUpdateValue`:
   - Before applying `TuneOrderInformation`, validate uniqueness of resulting orders
   - Reject transaction if duplicate orders would be created

**Code-Level Mitigation Example:**

In `UpdateValueValidationProvider`, add:
```csharp
// Validate TuneOrderInformation
var providedRound = validationContext.ProvidedRound;
var baseRound = validationContext.BaseRound;
var tuneOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (tuneOrders.Distinct().Count() != tuneOrders.Count)
    return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound values detected" };
```

**Invariant Checks:**
- Assert that all miners have distinct `FinalOrderOfNextRound` values before state update
- Assert that `FinalOrderOfNextRound` values are in range [1, minersCount]
- Add unit test verifying that duplicate orders are rejected during validation

### Proof of Concept

**Initial State:**
- Current round with 7 active miners
- Each miner has unique `Order` and different `FinalOrderOfNextRound` values
- Attacker is miner with pubkey "AttackerPubkey"

**Attack Transaction Steps:**

1. Attacker calls `GetConsensusExtraData` to get legitimate `AElfConsensusHeaderInformation` for UpdateValue behavior

2. Attacker modifies the returned `Round` object:
   ```
   For each miner in round.RealTimeMinersInformation:
       miner.FinalOrderOfNextRound = 1
   ```

3. Attacker includes the modified consensus header in their block and produces the block

4. Validation executes:
   - `ValidateBeforeExecution` calls `RecoverFromUpdateValue` (applies malicious orders to validation context)
   - `UpdateValueValidationProvider.ValidateHeaderInformation` checks OutValue and PreviousInValue only
   - Validation PASSES ✓

5. Block execution:
   - `ExtractInformationToUpdateConsensus` creates `TuneOrderInformation` with all miners mapped to order 1
   - `ProcessUpdateValue` applies malicious orders to state (line 259-260)
   - State now has 7 miners all with `FinalOrderOfNextRound = 1`

6. After-execution validation:
   - `ValidateConsensusAfterExecution` compares modified object with itself
   - Validation PASSES ✓ (bug)

7. Next round attempt:
   - Another miner tries to produce NextRound block
   - `GenerateNextRoundInformation` assigns all 7 miners `Order = 1` in next round
   - `NextRoundMiningOrderValidationProvider` should fail (distinct count = 1, expected = 7)
   - NextRound block is REJECTED

**Expected vs Actual Result:**
- Expected: Malicious order manipulation rejected during validation
- Actual: Malicious orders applied to state, consensus halts at next round transition

**Success Condition:**
Attack succeeds when `State.Rounds[currentRoundNumber].RealTimeMinersInformation.Values.Select(m => m.FinalOrderOfNextRound).Distinct().Count() == 1` while `minersCount == 7`, indicating all miners have the same order value, making next round generation impossible.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
