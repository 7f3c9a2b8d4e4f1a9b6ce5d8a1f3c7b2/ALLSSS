### Title
Scheme Manager Can Permanently Destroy All Accumulated Profits by Removing Beneficiaries Before Distribution

### Summary
A malicious TokenHolder scheme manager can remove all beneficiaries immediately before calling `DistributeProfits`, reducing the scheme's `TotalShares` to zero. When distribution occurs with zero total shares, the Profit contract automatically burns all accumulated profits instead of distributing them, permanently destroying funds that legitimate beneficiaries were entitled to claim.

### Finding Description

**Root Cause:**

TokenHolder schemes are created with `CanRemoveBeneficiaryDirectly = true`, allowing the scheme manager to remove beneficiaries at any time without restrictions. [1](#0-0) 

The `RemoveBeneficiary` function in TokenHolderContract can only be called by the scheme manager (verified through `GetValidScheme(Context.Sender)`), and it forwards the removal request to the underlying Profit contract: [2](#0-1) 

In the Profit contract, `RemoveBeneficiary` calls `RemoveProfitDetails` and subtracts the removed shares from the scheme's `TotalShares`: [3](#0-2) 

The `RemoveProfitDetails` function removes all beneficiary details when `CanRemoveBeneficiaryDirectly` is true: [4](#0-3) 

**Critical Flaw:**

When `DistributeProfits` is called and `totalShares <= 0`, the contract invokes `BurnProfits` instead of distributing to beneficiaries: [5](#0-4) 

The `BurnProfits` function permanently destroys the tokens by calling the Token contract's `Burn` method: [6](#0-5) 

**Why Protections Fail:**

1. No minimum `TotalShares` requirement exists before allowing distribution
2. No timelock or delay between beneficiary removal and profit distribution
3. The scheme manager controls both `RemoveBeneficiary` and `DistributeProfits` functions
4. No check prevents `TotalShares` from reaching zero [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**

All accumulated profits in the scheme are permanently destroyed through token burning. The total supply decreases, and there is no recovery mechanism. This is confirmed by the test that verifies supply reduction when profits are burned: [8](#0-7) 

**Who Is Affected:**

- Legitimate beneficiaries who staked tokens or were entitled to profit distributions lose their entire share
- Users who contributed profits to the scheme lose those contributions
- The broader protocol loses token supply permanently

**Severity Justification:**

This is a **HIGH** severity issue because:
1. Complete loss of accumulated funds with no recovery
2. Simple exploitation path requiring only manager privileges
3. No external dependencies or complex preconditions
4. Affects core dividend distribution functionality

The test suite even demonstrates that `TotalShares` reaching zero is a valid state: [9](#0-8) 

### Likelihood Explanation

**Attacker Capabilities:**

The attacker must be (or compromise) a TokenHolder scheme manager, which is the scheme creator. In many use cases, scheme managers are DApp operators managing staking rewards.

**Attack Complexity:**

Low complexity - the attack requires only:
1. Calling `RemoveBeneficiary` for each beneficiary (or all at once if batched)
2. Calling `DistributeProfits`

Both functions are directly accessible to the scheme manager.

**Feasibility Conditions:**

- No timelock between beneficiary removal and distribution
- No on-chain governance approval required
- Can be executed in a single block or across multiple blocks
- No economic disincentive (manager can profit from other schemes or have malicious intent)

**Detection Constraints:**

The removal transactions appear legitimate and are authorized. Without monitoring beneficiary count before distribution, the attack would only be detected after profits are burned.

**Probability:**

Medium-to-High probability due to:
- Insider threat scenarios (compromised or malicious DApp operators)
- Potential for "exit scam" by scheme managers
- No deterrent mechanism in the code
- Direct financial incentive to harm competitors or users

### Recommendation

**Immediate Fix:**

Add a validation check in `DistributeProfits` to prevent distribution when `TotalShares` is zero:

```csharp
// In ProfitContract.DistributeProfits
Assert(totalShares > 0, "Cannot distribute profits: no beneficiaries in scheme");
```

**Comprehensive Solution:**

1. **Add Minimum Beneficiary Check:**
   - Require at least one beneficiary with non-zero shares before allowing distribution
   - Store beneficiary count and validate it's greater than zero

2. **Implement Timelock:**
   - Add a delay period (e.g., 1 day) between beneficiary removal and distribution eligibility
   - Store `lastBeneficiaryModificationTime` in the scheme
   - Require `CurrentBlockTime > lastModificationTime + MinimumDelay` before distribution

3. **Add Emergency Pause:**
   - Implement pause mechanism for schemes when suspicious activity detected
   - Allow governance to intervene before irreversible burns occur

4. **Modify Burn Behavior:**
   - Instead of burning when `totalShares == 0`, hold funds in the scheme
   - Allow re-adding beneficiaries to claim held funds
   - Only burn after explicit manager action with time delay

**Test Cases:**

Add regression tests:
1. Test that distribution fails when all beneficiaries removed
2. Test that timelock prevents immediate distribution after removal
3. Test that funds can be recovered if beneficiaries re-added before distribution

### Proof of Concept

**Initial State:**
1. Scheme manager creates a TokenHolder scheme for token "APP"
2. Multiple users register as beneficiaries with locked tokens (e.g., 5 users with 100 tokens each = 500 total shares)
3. Profits accumulate: 10,000 ELF tokens contributed to the scheme

**Attack Sequence:**

**Transaction 1-5:** Manager removes all beneficiaries
```
For each beneficiary:
  TokenHolderContract.RemoveBeneficiary({
    Beneficiary: <user_address>
  })
```

**Result:** `scheme.TotalShares` becomes 0 (confirmed by test at line 151 of TokenHolderTests.cs)

**Transaction 6:** Manager calls distribution
```
TokenHolderContract.DistributeProfits({
  SchemeManager: <manager_address>,
  AmountsMap: { "ELF": 0 }  // 0 means distribute all
})
```

**Expected Result:** 
- Each of 5 beneficiaries receives 2,000 ELF tokens proportionally

**Actual Result:**
- `ProfitContract.DistributeProfits` detects `totalShares <= 0`
- `BurnProfits` is called instead of normal distribution
- All 10,000 ELF tokens are transferred to contract and burned
- Token supply decreases by 10,000 ELF permanently
- All beneficiaries receive 0 tokens

**Success Condition:**
Query token supply before and after - supply decreases by exactly the contributed amount, confirming permanent loss.

### Notes

This vulnerability exists by design in the delayed distribution mechanism to handle cases where no beneficiaries exist during distribution period. However, the TokenHolder contract's `CanRemoveBeneficiaryDirectly = true` setting creates an exploitable edge case where a malicious manager can weaponize this burn mechanism to destroy legitimately-owned profits.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-84)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L241-260)
```csharp
        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L546-550)
```csharp
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L85-94)
```csharp
        var supplyBeforeBurning = (await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = ProfitContractTestConstants.NativeTokenSymbol
        })).Supply;
        await ContributeAndDistribute(creator, contributeAmountEachTime, period);
        var supplyAfterBurning = (await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
        {
            Symbol = ProfitContractTestConstants.NativeTokenSymbol
        })).Supply;
        supplyBeforeBurning.Sub(supplyAfterBurning).ShouldBe(contributeAmountEachTime);
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L149-152)
```csharp
        {
            var originScheme = await ProfitContractStub.GetScheme.CallAsync(tokenHolderProfitScheme.SchemeId);
            originScheme.TotalShares.ShouldBe(0);
        }
```
