### Title
Case-Insensitive Token Duplicate Registration via CrossChainCreateToken

### Summary
The `CrossChainCreateToken` function bypasses case-insensitive duplicate validation, allowing tokens with identical case-insensitive symbols (e.g., "TOKEN" and "token") to be registered as separate tokens on the same chain. This violates the protocol's invariant that token symbols should be case-insensitively unique, leading to balance confusion and potential double-accounting exploits.

### Finding Description

The `RegisterTokenInfo` helper function stores token existence in a case-insensitive map but does not validate against existing case-insensitive duplicates: [1](#0-0) 

The normal token creation path (`Create` → `CreateToken`) properly protects against case-insensitive duplicates by calling `CheckTokenExists` before `RegisterTokenInfo`: [2](#0-1) 

The `CheckTokenExists` function validates both exact symbol match and case-insensitive existence: [3](#0-2) 

**However**, the `CrossChainCreateToken` function bypasses this protection by only checking the case-sensitive `State.TokenInfos` map before calling `RegisterTokenInfo`: [4](#0-3) 

This check at line 506 is case-sensitive (`State.TokenInfos["token"]` is different from `State.TokenInfos["TOKEN"]`), so it passes even when a case-insensitive duplicate already exists. The function then calls `RegisterTokenInfo` directly without checking `State.InsensitiveTokenExisting[symbol.ToUpper()]`.

### Impact Explanation

**Concrete Harm:**
- Multiple tokens with case-insensitive identical symbols coexist on the same chain (e.g., both "TOKEN" and "token" registered)
- Each token has separate `State.TokenInfos` entries with potentially different properties (supply, decimals, issuer, owner)
- Separate balance tracking: `State.Balances[address]["TOKEN"]` vs `State.Balances[address]["token"]`
- User confusion when querying token information or balances
- Potential for economic exploits where users mistakenly transfer/approve the wrong token variant
- Violates the critical invariant that token symbols must be case-insensitively unique

**Affected Parties:**
- All users on chains receiving cross-chain tokens
- Token holders who may lose funds by interacting with wrong token variant
- DApps and integrations expecting unique case-insensitive token symbols

**Severity Justification:**
High severity due to violation of core token uniqueness invariant, potential for user fund loss through confusion, and corruption of token accounting integrity across the entire chain.

### Likelihood Explanation

**Attacker Capabilities:**
No special privileges required. The attacker only needs:
1. Ability to create tokens on multiple chains (Chain A and Chain B)
2. Ability to trigger cross-chain token synchronization to target chain (Chain C)

**Attack Complexity:**
Moderate. The attack requires coordination across multiple chains but uses standard cross-chain token creation functionality.

**Feasibility Conditions:**
1. Multiple independent chains in the AElf ecosystem (already exists)
2. Different chains independently create tokens with case-variant symbols (realistic - chains may not coordinate symbol creation)
3. Both chains synchronize their tokens to a common chain via `CrossChainCreateToken`

**Detection/Operational Constraints:**
- Difficult to detect without explicit case-insensitive duplicate monitoring
- No on-chain prevention mechanism in `CrossChainCreateToken`
- The vulnerability is in the protocol logic, not external attack vectors

**Probability Reasoning:**
High probability in production cross-chain environments where:
- Multiple chains operate independently
- Token creation on different chains is uncoordinated
- Common tokens (e.g., stablecoins, wrapped assets) may be created with different case conventions on different chains

### Recommendation

**Immediate Fix:**
Add case-insensitive duplicate check in `CrossChainCreateToken` before calling `RegisterTokenInfo`:

```csharp
// In CrossChainCreateToken, replace lines 506-508 with:
var upperSymbol = tokenInfo.Symbol.ToUpper();
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    // Add case-insensitive duplicate check
    Assert(!State.InsensitiveTokenExisting[upperSymbol], 
           $"Token with case-insensitive symbol {upperSymbol} already exists.");
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

**Alternative Fix:**
Call `CheckTokenExists` before `RegisterTokenInfo` to reuse existing validation logic:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    CheckTokenExists(tokenInfo.Symbol);  // Add this line
    RegisterTokenInfo(tokenInfo);
    // ... rest of the code
}
```

**Test Cases to Add:**
1. Test cross-chain token creation with "TOKEN" from Chain A and "token" from Chain B to Chain C - should fail on second registration
2. Test that error message clearly indicates case-insensitive duplicate
3. Test that legitimate cross-chain token updates still work correctly

### Proof of Concept

**Initial State:**
- Chain A (main chain): Empty token registry
- Chain B (side chain): Empty token registry  
- Chain C (target chain): Empty token registry

**Attack Sequence:**

1. **On Chain A**: Call `Create` to register token "TOKEN"
   - Result: `State.TokenInfos["TOKEN"]` set on Chain A
   - Result: `State.InsensitiveTokenExisting["TOKEN"]` = true on Chain A

2. **On Chain B**: Call `Create` to register token "token" (lowercase)
   - Result: `State.TokenInfos["token"]` set on Chain B
   - Result: `State.InsensitiveTokenExisting["TOKEN"]` = true on Chain B
   - Note: This succeeds because Chain B has independent state

3. **On Chain C**: Call `CrossChainCreateToken` with proof from Chain A for "TOKEN"
   - Execution: Line 506 checks `State.TokenInfos["TOKEN"] == null` → PASSES
   - Execution: Line 508 calls `RegisterTokenInfo("TOKEN")`
   - Result: `State.TokenInfos["TOKEN"]` set on Chain C
   - Result: `State.InsensitiveTokenExisting["TOKEN"]` = true on Chain C

4. **On Chain C**: Call `CrossChainCreateToken` with proof from Chain B for "token"
   - Execution: Line 506 checks `State.TokenInfos["token"] == null` → PASSES (only "TOKEN" exists, not "token")
   - Execution: Line 508 calls `RegisterTokenInfo("token")`
   - Result: `State.TokenInfos["token"]` set on Chain C
   - Result: `State.InsensitiveTokenExisting["TOKEN"]` = true (already true)

**Final State on Chain C:**
- Both `State.TokenInfos["TOKEN"]` and `State.TokenInfos["token"]` exist as separate token entries
- Users can hold balances of both tokens independently
- Violation of case-insensitive uniqueness invariant confirmed

**Success Condition:**
Query `GetTokenInfo("TOKEN")` and `GetTokenInfo("token")` on Chain C - both return non-null TokenInfo objects with potentially different properties, proving the vulnerability allows case-insensitive duplicates.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```
