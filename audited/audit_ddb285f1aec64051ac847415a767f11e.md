### Title
Malicious Contract Address Bypass in Controller Change Functions Enables Permanent Governance Circumvention

### Summary
The `CheckOrganizationExist` function in BasicContractZero_Helper.cs calls an arbitrary contract address without validating it's a legitimate governance contract (Parliament, Association, or Referendum). A compromised governance organization can pass a proposal to change the deployment or code check controller to point to a malicious contract that always validates organizations as existing, permanently bypassing all future governance checks and enabling immediate, unilateral contract deployment and updates.

### Finding Description

**Exact Code Location:** [1](#0-0) 

The `CheckOrganizationExist` helper function makes an inter-contract call to `authorityInfo.ContractAddress` without any validation that this address corresponds to a legitimate governance contract. It simply assumes the contract at that address will correctly implement `ValidateOrganizationExist`.

**Entry Points:** [2](#0-1) [3](#0-2) 

Both `ChangeContractDeploymentController` and `ChangeCodeCheckController` use this vulnerable validation function. While these methods enforce that only the current controller's `OwnerAddress` can call them, they don't validate that the new `AuthorityInfo.ContractAddress` is a legitimate governance contract.

**Why Existing Protections Fail:**

The system correctly validates authorized callers but fails to validate the controller contract itself. When the system initializes, the controller is set to a legitimate governance contract: [4](#0-3) 

However, subsequent changes via `ChangeContractDeploymentController` or `ChangeCodeCheckController` accept arbitrary `AuthorityInfo` structures without verifying the `ContractAddress` is one of the known governance contracts (Parliament, Association, or Referendum).

**Execution Path:**
1. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` to always return `true`
2. Current controller organization creates and approves a governance proposal to change the controller
3. Proposal calls `ChangeContractDeploymentController` with `AuthorityInfo{ContractAddress: malicious_contract, OwnerAddress: attacker_controlled_address}`
4. `CheckOrganizationExist` calls the malicious contract's `ValidateOrganizationExist`, which returns `true`
5. Controller is permanently changed to the malicious setup

### Impact Explanation

**Governance Bypass:**
Once the controller is changed to a malicious contract, the attacker gains permanent, unilateral control over contract deployment and updates. Normal governance requires:
- Creating proposals
- Voting by organization members
- Time delays for proposal expiration
- Release by the proposer

With the malicious controller, the attacker can:
- Deploy arbitrary contracts immediately via `DeploySmartContract` [5](#0-4) 
- Update any contract including system contracts via `UpdateSmartContract` [6](#0-5) 

**System Integrity Compromise:**
The attacker can:
- Deploy malicious contracts that drain funds from other contracts
- Update system contracts (Token, Treasury, Profit, etc.) to steal funds or manipulate economics
- Modify consensus contracts to disrupt the blockchain
- Update the Genesis contract itself to gain total control

**Persistence:**
Unlike a temporary governance compromise that requires passing new proposals for each action, this vulnerability provides permanent control. The malicious controller's `OwnerAddress` is attacker-controlled, making it extremely difficult to revert without the attacker's cooperation.

**Affected Parties:**
- All token holders (funds at risk from malicious contract deployments)
- The entire blockchain (consensus and system contract integrity)
- All users and developers (arbitrary code execution via contract updates)

### Likelihood Explanation

**Attacker Capabilities Required:**
The attacker must first compromise the current governance organization enough to pass a malicious proposal. This could occur through:
- Social engineering of organization members
- Compromised keys of organization members
- Exploiting other vulnerabilities in the governance contracts
- In Association contracts with few members, compromising a smaller number of accounts

**Attack Complexity:**
Once governance is compromised, execution is straightforward:
1. Deploy malicious contract (single transaction)
2. Create governance proposal to change controller (single transaction)
3. Approve proposal through compromised governance (depends on organization type)
4. Release proposal (single transaction)

**Feasibility:**
This is highly feasible because:
- No special technical knowledge required beyond standard contract deployment
- The malicious contract is simple (always return `true`)
- No on-chain validation prevents this attack
- Tests don't cover this scenario: [7](#0-6) [8](#0-7) 

Tests verify legitimate governance contract changes but not malicious contract addresses.

**Detection:**
The attack would be visible on-chain as a controller change, but by the time it's detected, the damage is done and reverting requires attacker cooperation.

**Probability Assessment:**
While initial governance compromise is required, this vulnerability converts a temporary compromise into permanent control, significantly increasing the attack's value and likelihood of exploitation.

### Recommendation

**Immediate Fix:**
Add validation in `CheckOrganizationExist` to verify the contract address is one of the known governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Alternative Approach:**
Use the system contract validation method: [9](#0-8) 

Check if the contract address is in the system contract mapping: [10](#0-9) 

**Test Coverage:**
Add test cases that verify:
1. Changing controller to a non-governance contract fails
2. Changing controller to a malicious contract that returns true fails
3. Only Parliament, Association, and Referendum contracts are accepted

**Apply to All Contracts:**
This same pattern exists in multiple contracts using `CheckOrganizationExist`: [11](#0-10) 

All instances should be fixed consistently.

### Proof of Concept

**Step 1: Initial State**
- Genesis contract initialized with Parliament as deployment controller
- Parliament organization controls contract deployment via governance proposals

**Step 2: Deploy Malicious Contract**
```csharp
// Malicious contract that always validates organizations
public class MaliciousAuthContract : MaliciousAuthContractContainer.MaliciousAuthContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always return true
    }
}
```

**Step 3: Create Governance Proposal**
Through compromised Parliament organization, create proposal to call:
- Method: `ChangeContractDeploymentController`
- Parameters: `AuthorityInfo{ContractAddress: malicious_contract_address, OwnerAddress: attacker_address}`

**Step 4: Approve and Release Proposal**
Through compromised governance, approve and release the proposal.

**Step 5: Expected vs Actual Result**
- **Expected**: Proposal should fail with "Invalid governance contract address"
- **Actual**: Proposal succeeds, controller is changed to malicious setup

**Step 6: Verify Bypass**
Attacker can now call `DeploySmartContract` or `UpdateSmartContract` directly through proposals to their malicious controller, which will always validate their "organization" as existing, bypassing all governance checks.

**Success Condition:**
After controller change, attacker can deploy arbitrary contracts without going through legitimate governance by:
1. Creating proposal to their fake organization via malicious contract
2. Malicious contract validates organization exists (always true)
3. Proposal is released and contract deployed immediately

### Notes

This vulnerability represents a critical defense-in-depth failure. While it requires initial governance compromise, it converts temporary access into permanent, unilateral control over the blockchain's contract deployment infrastructure. The lack of contract address validation violates the principle of least privilege and enables privilege escalation from governance participant to system administrator.

The system correctly uses named system contracts during initialization but fails to enforce this constraint on subsequent controller changes, creating an asymmetric security model where initial setup is secure but later modifications are not.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L348-364)
```csharp
    public override Empty SetInitialControllerAddress(Address input)
    {
        Assert(State.ContractDeploymentController.Value == null && State.CodeCheckController.Value == null,
            "Genesis owner already initialized");
        var parliamentContractAddress =
            GetContractAddressByName(SmartContractConstants.ParliamentContractSystemHashName);
        Assert(Context.Sender == parliamentContractAddress, "Unauthorized to initialize genesis contract.");
        Assert(input != null, "Genesis Owner should not be null.");
        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = input,
            ContractAddress = parliamentContractAddress
        };
        State.ContractDeploymentController.Value = defaultAuthority;
        State.CodeCheckController.Value = defaultAuthority;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L375-382)
```csharp
    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L732-748)
```csharp
    public async Task ChangeContractZeroOwner_Test_Invalid_Address()
    {
        var address = Tester.GetCallOwnerAddress();
        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                ContractAddress = contractDeploymentController.ContractAddress,
                OwnerAddress = address
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Failed);
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L751-838)
```csharp
    public async Task ChangeContractZeroOwner_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
            nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateOrganization),
            new CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1000,
                    MinimalVoteThreshold = 1000
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        // test deployment with only one miner
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory,
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);

        var contractProposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;

        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        var tester = Tester.CreateNewContractTester(Tester.InitialMinerList.First());
        await ApproveWithTesterAsync(tester, ParliamentAddress, contractProposalId);

        // release contract code and trigger code check proposal
        var releaseApprovedContractTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ReleaseApprovedContract), new ReleaseContractInput
            {
                ProposalId = contractProposalId,
                ProposedContractInputHash = proposedContractInputHash
            });

        var codeCheckProposalId = ProposalCreated.Parser
            .ParseFrom(releaseApprovedContractTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;

        await ApproveWithMinersAsync(Tester, ParliamentAddress, codeCheckProposalId);

        // release code check proposal and deployment completes
        var deploymentResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ReleaseCodeCheckedContract),
            new ReleaseContractInput
                { ProposedContractInputHash = proposedContractInputHash, ProposalId = codeCheckProposalId });

        var creator = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).Indexed[0])
            .Author;

        creator.ShouldBe(BasicContractZeroAddress);

        var deployAddress = ContractDeployed.Parser
            .ParseFrom(deploymentResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed)
            .Address;

        deployAddress.ShouldNotBeNull();

        var author = Address.Parser.ParseFrom(await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractAuthor), deployAddress));

        author.ShouldBe(BasicContractZeroAddress);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L39-48)
```csharp
    public override Address CreateOrganizationBySystemContract(CreateOrganizationBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
        var organizationAddress = CreateNewOrganization(input.OrganizationCreationInput);
        if (!string.IsNullOrEmpty(input.OrganizationAddressFeedbackMethod))
            Context.SendInline(Context.Sender, input.OrganizationAddressFeedbackMethod, organizationAddress);

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
