### Title
Unhandled Exception in CrossChainCreate Due to Missing External Info Validation

### Summary
The `CrossChainCreate` function accesses token external info dictionary keys without validation, causing `KeyNotFoundException` or `FormatException` when required metadata is missing or malformed. This creates a denial-of-service vector where improperly created tokens cannot be synced cross-chain as NFT protocols.

### Finding Description

The vulnerability exists in the `CrossChainCreate` method at lines 87-88 where external info dictionary values are accessed without checking key existence or validating content format: [1](#0-0) 

**Root Cause:**
The code assumes `NftBaseUriMetadataKey` and `NftTokenIdReuseMetadataKey` exist in `tokenInfo.ExternalInfo.Value` and that the latter contains a valid boolean string. However, tokens can be created directly via MultiToken contract without these metadata keys.

**Why Protections Fail:**
1. No validation that the token was created via NFT contract's `Create` method, which properly sets metadata [2](#0-1) 
2. No checks before dictionary access (no `TryGetValue` or `ContainsKey`)
3. No validation of boolean string format before `bool.Parse()`

**Execution Path:**
1. Token created on main chain via `MultiToken.Create` (bypassing NFT contract) with missing or invalid external info [3](#0-2) 
2. Token synced to side chain via `CrossChainCreateToken` preserving external info [4](#0-3) 
3. `CrossChainCreate` called on side chain for that token symbol
4. Dictionary access throws exception, transaction reverts

### Impact Explanation

**Harm:**
- Denial of service: prevents cross-chain synchronization of NFT protocols for tokens lacking proper metadata
- Transaction reversion with gas consumption up to failure point
- Potential griefing vector through symbol squatting

**Scope:**
- Affects only tokens NOT created via NFT contract's proper `Create` method
- Legitimate NFT protocols with correct metadata (created via NFT.Create) remain functional
- No state corruption, fund loss, or authorization bypass occurs

**Severity Justification:**
While this creates operational disruption, impact is limited to edge cases where tokens bypass standard NFT creation flow. The transaction fails safely without corrupting state. This represents a **Medium severity** defensive programming issue rather than a critical vulnerability, despite being marked "High" in the audit question.

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can create tokens via `MultiToken.Create` without restrictions on external info content
- No special permissions required to call `CrossChainCreate` [5](#0-4) 

**Attack Complexity:**
- Low: straightforward three-step process (create token, sync cross-chain, trigger exception)
- No cryptographic or timing requirements

**Feasibility Conditions:**
- Attacker must create token on main chain first (consumes resources)
- Token must be synced cross-chain via legitimate MultiToken mechanisms
- Limited practical benefit: only blocks NFT protocol sync for that specific symbol

**Probability:**
- More likely to occur accidentally (users not following proper NFT creation procedures) than maliciously
- Automated cross-chain sync systems could encounter this with improperly created tokens

### Recommendation

**Code-Level Mitigation:**
Replace direct dictionary access with safe access pattern:

```csharp
// Line 87-88 replacement
if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri))
    throw new AssertionException($"Token {input.Symbol} missing required NFT metadata: {NftBaseUriMetadataKey}");

if (!tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var isTokenIdReuseStr) ||
    !bool.TryParse(isTokenIdReuseStr, out var isTokenIdReuse))
    throw new AssertionException($"Token {input.Symbol} has invalid {NftTokenIdReuseMetadataKey} value");
```

**Additional Validation:**
Add check that token has NFT characteristics (decimals = 0) [6](#0-5) 

**Test Cases:**
1. Test `CrossChainCreate` with token missing `NftBaseUriMetadataKey`
2. Test with invalid boolean string value for `NftTokenIdReuseMetadataKey` (e.g., "invalid", empty string)
3. Test with token having decimals != 0
4. Verify proper error messages for all validation failures

### Proof of Concept

**Initial State:**
- Main chain and side chain operational
- MultiToken contracts deployed on both chains
- NFT contract deployed on side chain
- Cross-chain token contract addresses registered

**Attack Steps:**
1. On main chain, call `MultiToken.Create` directly with `CreateInput` containing symbol "TT-0", decimals 0, but ExternalInfo without `NftTokenIdReuseMetadataKey` or with value "invalid"
2. Execute cross-chain token sync via `MultiToken.CrossChainCreateToken` to side chain
3. On side chain, call `NFT.CrossChainCreate` with `CrossChainCreateInput` containing symbol "TT-0"

**Expected Result:**
Transaction should validate external info and reject with clear error message

**Actual Result:**
Transaction reverts with `KeyNotFoundException` (if key missing) or `FormatException` (if value invalid), exposing internal implementation details

**Success Condition:**
Transaction fails at step 3, demonstrating DoS of cross-chain NFT protocol creation for improperly formatted tokens

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L26-26)
```csharp
            Decimals = 0, // Fixed
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-75)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L501-501)
```csharp
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```
