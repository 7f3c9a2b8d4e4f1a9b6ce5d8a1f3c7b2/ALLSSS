### Title
Mining Order Manipulation via Unvalidated SupposedOrderOfNextRound and TuneOrderInformation

### Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` and `TuneOrderInformation` values from miner-provided input without validating that they match the required calculation from the miner's signature. A malicious miner can modify these values in the consensus extra data to gain unfair advantages in the next round's mining order, consistently positioning themselves to mine first and maximizing block rewards while disadvantaging honest miners.

### Finding Description

The vulnerability exists in the `ProcessUpdateValue` method where mining order information is processed without cryptographic verification.

**Location 1 - Order Values Accepted Without Validation:** [1](#0-0) 

**Location 2 - TuneOrderInformation Applied Without Verification:** [2](#0-1) 

**Root Cause:**

The `SupposedOrderOfNextRound` should be deterministically calculated from the miner's signature using: [3](#0-2) 

However, the contract never re-validates this calculation during block validation or execution. The calculation only occurs in `ApplyNormalConsensusData` when generating consensus extra data: [4](#0-3) 

**Why Protections Fail:**

1. **Validation Provider Insufficient**: The `UpdateValueValidationProvider` only checks that OutValue and Signature fields are filled, and verifies PreviousInValue correctness - it does NOT validate order calculations: [5](#0-4) 

2. **RecoverFromUpdateValue Blindly Copies**: During validation, the recovery process copies order values from provided data without recalculation: [6](#0-5) 

3. **Hash Comparison Ineffective**: The after-execution validation compares hashes of rounds that both contain the same manipulated values, so it cannot detect tampering: [7](#0-6) 

**Attack Path:**

A malicious miner can modify consensus extra data after calling `GetConsensusExtraData` but before including it in the block header. The extraction of `TuneOrderInformation` occurs here: [8](#0-7) 

This extracted information is blindly trusted and applied to modify other miners' FinalOrderOfNextRound values.

### Impact Explanation

**Direct Consensus Integrity Violation:**

The manipulated `FinalOrderOfNextRound` values directly determine the mining order in the next round: [9](#0-8) 

**Concrete Harm:**

1. **Unfair Mining Advantage**: Attacker can consistently set their `FinalOrderOfNextRound = 1` to always mine first in subsequent rounds
2. **Reward Misallocation**: First miners have higher probability of producing blocks and earning rewards; attacker gains disproportionate rewards while honest miners lose opportunities
3. **Consensus Fairness Breakdown**: The unpredictability guarantee of order assignment (based on signature hash) is completely bypassed
4. **Competitor Suppression**: Attacker can push specific honest miners to later orders via malicious `TuneOrderInformation`, reducing their mining opportunities

**Severity Justification**: CRITICAL - This breaks a core consensus invariant (miner schedule integrity) and directly impacts economic fairness and block production distribution across all network participants.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an authorized miner in the current round (normal precondition for block production)
- Can modify protobuf messages in their own node before signing and propagating blocks
- No special cryptographic capabilities needed beyond normal block signing

**Attack Complexity**: LOW
1. Call `GetConsensusExtraData` through standard miner node process
2. Parse the returned `AElfConsensusHeaderInformation` protobuf
3. Modify `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` fields in the embedded Round object
4. Serialize modified data and include in block header
5. Sign block with miner's own key (validates as SenderPubkey == SignerPubkey)

**Feasibility**: HIGH
- No additional permissions beyond normal miner role required
- Block validation passes because no recalculation/verification occurs
- Attack repeatable every round the attacker mines
- No on-chain detection mechanism exists

**Economic Rationality**: Highly profitable - mining rewards justify the manipulation, especially for validators with significant stake who can exploit this persistently.

**Detection Constraints**: None - the contract has no mechanism to detect order manipulation since it never recalculates the expected values from signatures.

### Recommendation

**Immediate Fix - Add Order Validation:**

In `AEDPoSContract_ProcessConsensusInformation.cs`, add validation before accepting order values:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // VALIDATION: Verify SupposedOrderOfNextRound matches signature calculation
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), minersCount) + 1;
    Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, 
        $"Invalid SupposedOrderOfNextRound. Expected {expectedOrder}, got {updateValueInput.SupposedOrderOfNextRound}");
    
    // Existing code continues...
}
```

**Additional Validation - Verify TuneOrderInformation:**

Validate that TuneOrderInformation only contains miners who would actually have conflicts, and that the reassigned orders are correctly calculated:

```csharp
// Validate each tune order entry
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    var targetMiner = currentRound.RealTimeMinersInformation[tuneOrder.Key];
    // Verify this miner had an actual conflict requiring order tuning
    Assert(targetMiner.SupposedOrderOfNextRound != targetMiner.FinalOrderOfNextRound,
        "TuneOrderInformation contains miner without order conflict");
    // Verify the new order is within valid range and unoccupied
    Assert(tuneOrder.Value > 0 && tuneOrder.Value <= minersCount,
        "Invalid tuned order value");
}
```

**Test Cases to Add:**

1. Test rejecting UpdateValue with manipulated SupposedOrderOfNextRound (not matching signature)
2. Test rejecting UpdateValue with invalid TuneOrderInformation (miners without conflicts)
3. Test rejecting UpdateValue with out-of-range order values
4. Test correct order calculation for all miners across multiple rounds

### Proof of Concept

**Initial State:**
- Round N with 5 authorized miners: [A, B, C, D, E]
- Attacker is miner C, scheduled to produce block in round N
- Normal signature calculation would give C order 3 for round N+1

**Attack Steps:**

1. Attacker's node calls `GetConsensusExtraData` for UpdateValue behavior
2. Contract returns consensus data with correctly calculated:
   - C.SupposedOrderOfNextRound = 3
   - C.FinalOrderOfNextRound = 3
   - Other miners have their correct orders

3. Attacker modifies the Round object in consensus extra data:
   - Change C.SupposedOrderOfNextRound = 1
   - Change C.FinalOrderOfNextRound = 1
   - Set TuneOrderInformation = { "A": 3, "B": 4 } (push competitors back)

4. Attacker includes modified data in block header and signs block with their key

5. Block propagates to network and undergoes validation:
   - `ValidateBeforeExecution`: No order recalculation, passes ✓
   - `ProcessUpdateValue`: Accepts manipulated order values ✓
   - `ValidateAfterExecution`: Hash comparison matches (both have same manipulated data) ✓

6. State updated with manipulated orders

7. Next round (N+1) generation uses manipulated FinalOrderOfNextRound values:
   - Attacker C gets Order = 1 (mines first)
   - Honest miner A gets Order = 3 (mines third)
   - Honest miner B gets Order = 4 (mines fourth)

**Expected Result**: Attacker C should get Order = 3 based on their signature

**Actual Result**: Attacker C gets Order = 1, gaining unfair advantage

**Success Condition**: Attacker consistently mines first in subsequent rounds, maximizing block rewards while honest miners are pushed to later time slots.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
