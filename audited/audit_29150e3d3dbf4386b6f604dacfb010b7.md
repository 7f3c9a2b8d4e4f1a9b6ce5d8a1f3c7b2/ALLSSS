# Audit Report

## Title
Miners Can Manipulate Mining Order by Providing Arbitrary SupposedOrderOfNextRound Values

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` values from miners without validating they match the signature-based calculation, allowing miners to arbitrarily choose their mining position in subsequent rounds and breaking consensus fairness guarantees.

## Finding Description

The AEDPoS consensus mechanism is designed to calculate each miner's position in the next round based on their cryptographic signature to ensure unpredictability and fairness. The calculation formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1` exists in the `ApplyNormalConsensusData` method: [1](#0-0) 

However, this calculation only occurs when `GetConsensusBlockExtraData` calls `ApplyNormalConsensusData`: [2](#0-1) 

The critical vulnerability is in `ProcessUpdateValue`, which directly assigns the `SupposedOrderOfNextRound` value from the transaction input without any recalculation or validation: [3](#0-2) 

The validation phase only checks that `OutValue` and `Signature` are non-null and validates the `PreviousInValue` hash relationship, but completely omits validation of the `SupposedOrderOfNextRound`: [4](#0-3) [5](#0-4) 

Furthermore, the `NextRoundMiningOrderValidationProvider` that could validate mining orders is only applied for `NextRound` behavior, not for `UpdateValue`: [6](#0-5) 

This validator only checks that the count of miners with valid orders matches the count who mined, but does not verify individual `SupposedOrderOfNextRound` correctness: [7](#0-6) 

The manipulated `SupposedOrderOfNextRound` becomes the `FinalOrderOfNextRound` and is used by `GenerateNextRoundInformation` to determine mining positions: [8](#0-7) 

## Impact Explanation

This vulnerability fundamentally breaks the fairness and unpredictability guarantees of the AEDPoS consensus mechanism:

1. **Consensus Manipulation**: A malicious miner can consistently position themselves first in mining order, giving them priority access to block production and extra block rewards.

2. **Economic Advantage**: The first miner produces extra blocks if subsequent miners are offline or late, earning disproportionate rewards. They also have priority in transaction inclusion and MEV extraction.

3. **Random Number Influence**: Mining order affects the sequence of random number generation in the consensus mechanism, potentially enabling manipulation of consensus randomness for other protocol operations.

4. **Systemic Risk**: If multiple colluding miners exploit this, they could coordinate their positions to dominate consensus, destabilize round transitions, or create predictable mining patterns that undermine the security model.

The impact is **CRITICAL** because it breaks a core invariant: that mining order must be cryptographically unpredictable and derived from signatures, not arbitrarily chosen by miners.

## Likelihood Explanation

The attack is **HIGHLY LIKELY** with minimal complexity:

**Attacker Capabilities**: Any active miner in the consensus set can execute this attack. No special privileges required beyond normal miner participation.

**Attack Steps**:
1. Miner calls `GetConsensusBlockExtraData` (a view function) to obtain valid `OutValue` and `Signature` values for their legitimate mining operation
2. Miner constructs a modified `UpdateValueInput` with the valid cryptographic values but replaces `SupposedOrderOfNextRound` with their desired value (e.g., 1 for first position)
3. Miner submits this modified transaction, which passes all validation checks
4. The contract accepts the arbitrary order value and uses it for next round generation

**Feasibility**: The attack requires no special conditionsâ€”just normal participation in consensus. The cost is negligible (standard transaction gas), while the benefit is continuous preferential mining positions and increased block rewards. Miners are economically incentivized to exploit this vulnerability.

**Detection Difficulty**: While theoretically detectable by comparing submitted values against signature-calculated values, there is no automatic enforcement, making exploitation practical and profitable.

## Recommendation

Add validation in `ProcessUpdateValue` to recalculate and verify the `SupposedOrderOfNextRound` from the miner's signature:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // ADDED: Validate SupposedOrderOfNextRound matches signature
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    var sigNum = updateValueInput.Signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, 
           "Invalid SupposedOrderOfNextRound for given signature.");
    
    minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
    minerInRound.Signature = updateValueInput.Signature;
    minerInRound.OutValue = updateValueInput.OutValue;
    minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
    // ... rest of method
}
```

Alternatively, instead of accepting `SupposedOrderOfNextRound` from input, recalculate it directly from the validated signature, eliminating the ability to manipulate this value.

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateOrderByProvidingArbitrarySupposedOrderOfNextRound()
{
    // Setup: Initialize consensus with multiple miners
    var miners = GenerateMiners(5);
    await InitializeConsensus(miners);
    
    // Miner calls GetConsensusBlockExtraData to get valid signature and outValue
    var triggerInfo = new AElfConsensusTriggerInformation 
    { 
        Pubkey = miners[0].PublicKey,
        InValue = GenerateInValue(),
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    var extraData = await ConsensusStub.GetConsensusExtraData.CallAsync(
        triggerInfo.ToBytesValue());
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(extraData.Value);
    
    // Extract valid cryptographic values
    var minerInfo = headerInfo.Round.RealTimeMinersInformation[miners[0].PublicKey.ToHex()];
    var validSignature = minerInfo.Signature;
    var validOutValue = minerInfo.OutValue;
    var calculatedOrder = minerInfo.SupposedOrderOfNextRound; // Should be 3 based on signature
    
    // Attack: Construct UpdateValueInput with ARBITRARY order (1 instead of calculated 3)
    var maliciousInput = new UpdateValueInput
    {
        OutValue = validOutValue,
        Signature = validSignature,
        PreviousInValue = Hash.Empty,
        SupposedOrderOfNextRound = 1, // MANIPULATED: Should be 3, but attacker chooses 1
        RoundId = headerInfo.Round.RoundId,
        ActualMiningTime = Timestamp.FromDateTime(DateTime.UtcNow),
        RandomNumber = GenerateRandomNumber()
    };
    
    // Submit malicious transaction - should pass validation
    var result = await ConsensusStub.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Miner's manipulated order is accepted
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    currentRound.RealTimeMinersInformation[miners[0].PublicKey.ToHex()]
        .SupposedOrderOfNextRound.ShouldBe(1); // Manipulated value accepted!
    
    // Trigger NextRound and verify attacker gets first position
    await ProduceNextRound();
    var nextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    nextRound.RealTimeMinersInformation[miners[0].PublicKey.ToHex()]
        .Order.ShouldBe(1); // Attacker successfully manipulated their position to first!
}
```

**Notes**

The vulnerability exists because the contract architecture separates the calculation logic (in `ApplyNormalConsensusData`) from the transaction processing logic (in `ProcessUpdateValue`), with no validation bridge between them. The `TuneOrderInformation` mechanism is designed to handle legitimate conflicts from signature collisions, not to prevent deliberate manipulation. Any miner can exploit this to gain systematic advantage in mining order, fundamentally compromising the fairness properties the signature-based ordering is designed to provide.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-37)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```
