### Title
Permanent Governance Lockout via Unreachable Method Fee Controller Organization

### Summary
The `ChangeMethodFeeController()` function allows changing the method fee controller to a Parliament organization with unreachable voting thresholds (e.g., 100% approval requirement), permanently locking the system from any future fee updates or controller changes. Once set to such an organization, there is no recovery mechanism, as the only way to change the controller requires authorization from the locked controller itself.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The `ChangeMethodFeeController()` function only validates that the target organization exists, but does not validate whether the organization's approval thresholds are practically achievable by the current or future miner set. [2](#0-1) 

The organization validation logic only checks existence: [3](#0-2) 

**Why Protections Fail**: The `Validate(Organization)` function in the Parliament helper allows organizations with extreme thresholds such as `MinimalApprovalThreshold = 10000` (100% approval): [4](#0-3) 

This validation only checks mathematical bounds (e.g., threshold â‰¤ 10000, > 0) but does not verify that the threshold can realistically be met given that even a single offline, malicious, or abstaining miner would prevent 100% approval.

**Test Evidence**: The codebase explicitly demonstrates that organizations with 100% approval thresholds can be successfully created: [5](#0-4) 

**No Recovery Mechanism**: Both `SetMethodFee()` and `ChangeMethodFeeController()` require the sender to be the current controller's owner address: [6](#0-5)  and [7](#0-6) 

Once locked to an unreachable organization, there is no admin override, no emergency mechanism, and no way to reset the controller.

### Impact Explanation

**Concrete Harm**: Permanent loss of method fee governance capability across the Parliament contract. The system becomes unable to:
- Adjust transaction fees via `SetMethodFee()` in response to network conditions
- Change the method fee controller back to a reachable organization via `ChangeMethodFeeController()`

**Protocol Damage**: Complete governance lockout for transaction fee management. If network conditions change (e.g., token price volatility requires fee adjustments), the protocol has no mechanism to adapt, potentially leading to:
- User accessibility issues (fees too high)
- Network spam vulnerability (fees too low)
- Economic model breakdown

**Affected Parties**: All users of the Parliament contract and any contract functionality that depends on method fee adjustments.

**Severity Justification**: CRITICAL - This is a permanent, irreversible lockout of critical governance functionality with no recovery path. The impact is systemic and affects the entire protocol's ability to adjust to changing conditions.

### Likelihood Explanation

**Attacker Capabilities**: Requires control of 2/3 of current miners (the default organization's approval threshold) to pass the governance proposal changing the controller. [8](#0-7) 

**Attack Complexity**: LOW
1. Create a Parliament organization with unreachable thresholds (MinimalApprovalThreshold = 10000)
2. Create a proposal to change the method fee controller to this organization
3. Get 2/3 miner approval (standard governance threshold)
4. Release the proposal

**Feasibility Conditions**: 
- Requires 2/3 miner coordination (malicious intent, compromise, or honest mistake)
- No additional technical barriers beyond standard governance process
- Attack is permanent once executed

**Detection/Operational Constraints**: The attack may not be immediately obvious since:
- The transaction succeeds without errors
- The impact only manifests when trying to adjust fees later
- Could be disguised as a legitimate governance change

**Probability Reasoning**: MEDIUM-HIGH
- Standard governance threshold (not an exceptional requirement)
- Could occur through coordinated attack, governance compromise, or configuration error
- Historical blockchain governance shows such mistakes have occurred
- No safeguards warn about unreachable thresholds

### Recommendation

**Code-Level Mitigation**:

Add validation in `ChangeMethodFeeController()` to ensure the new organization's thresholds are achievable. Specifically, check that `MinimalApprovalThreshold < 10000` to prevent requiring 100% consensus:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // NEW VALIDATION: Ensure thresholds are achievable
    if (input.ContractAddress == Context.Self)
    {
        var organization = State.Organizations[input.OwnerAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold < AbstractVoteTotal,
            "Organization threshold requires unanimous approval which is unreachable.");
    }
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Invariant Checks**: 
- Add constraint: `MinimalApprovalThreshold < AbstractVoteTotal` (strictly less than 100%)
- Consider maximum threshold cap (e.g., 9500 = 95%) to ensure proposals can pass even with reasonable miner unavailability
- Validate threshold reachability in `Validate(Organization)` function: [4](#0-3) 

**Test Cases**:
1. Test attempting to change controller to organization with MinimalApprovalThreshold = 10000 (should fail)
2. Test attempting to change controller to organization with MinimalApprovalThreshold = 9999 (should succeed)
3. Test that proposals can still be approved/released through the new organization
4. Test edge cases with high but achievable thresholds (e.g., 9500)

### Proof of Concept

**Required Initial State**:
- Parliament contract initialized with default organization (2/3 approval threshold)
- Current method fee controller set to default organization
- At least 3 miners in the consensus (to demonstrate 2/3 approval)

**Transaction Steps**:

1. **Create Unreachable Organization**:
   - Call `CreateOrganization()` with:
     - `MinimalApprovalThreshold = 10000` (100% approval)
     - `MinimalVoteThreshold = 10000` (100% votes)
     - `MaximalAbstentionThreshold = 0`
     - `MaximalRejectionThreshold = 0`
   - Transaction succeeds (proven by test): [5](#0-4) 
   - Store returned organization address

2. **Create Proposal to Change Controller**:
   - Call `CreateProposal()` on default organization with:
     - `ContractMethodName = "ChangeMethodFeeController"`
     - `ToAddress = ParliamentContractAddress`
     - `Params = AuthorityInfo { OwnerAddress = unreachable_org_address, ContractAddress = ParliamentContractAddress }`

3. **Approve and Release**:
   - Get 2/3 miners to call `Approve()` on proposal
   - Original proposer calls `Release()` 
   - Proposal executes successfully, changing controller

4. **Demonstrate Lockout**:
   - Attempt to create any proposal through new unreachable organization
   - Get all miners except one to approve
   - Call `Release()` - fails because approval threshold not met
   - System permanently locked from fee changes

**Expected vs Actual Result**:
- **Expected**: System should reject changing controller to unreachable organization
- **Actual**: Change succeeds, permanently locking fee governance with no recovery path

**Success Condition**: After step 3, `GetMethodFeeController()` returns the unreachable organization address, and no subsequent fee changes can ever be made, even with 99% miner approval.

### Notes

The vulnerability exists because the validation logic focuses on mathematical validity of threshold ratios but ignores operational reachability. The emergency response organization [9](#0-8)  is not a recovery mechanism for this issue - it's merely another high-threshold organization (90%) and provides no override capability for the method fee controller lockout scenario.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L15-15)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L188-196)
```csharp
            createOrganizationInput.ProposalReleaseThreshold = proposalReleaseThreshold;
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```
