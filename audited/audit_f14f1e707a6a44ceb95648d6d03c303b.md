### Title
Insufficient Validation of ProducedBlocks in NextRound Allows Mining Reward Inflation

### Summary
The `NextRoundInput.Create()` method and `NextRound` transaction processing accept and store `RealTimeMinersInformation` containing `ProducedBlocks` values without validating that these values match the legitimate accumulated counts from the previous round. A malicious miner producing a NextRound block can inflate these values, leading to excessive mining reward distribution and corrupted election statistics.

### Finding Description
The vulnerability exists in the consensus round transition logic: [1](#0-0) 

The `Create()` method accepts a `Round` object with `RealTimeMinersInformation` containing `ProducedBlocks` values and copies them without any validation. When `NextRound` is called: [2](#0-1) 

The `ProcessNextRound` method converts the input to a Round object (line 110) and stores it directly via `AddRoundInformation` (line 156): [3](#0-2) 

The validation for NextRound behavior only checks round number incrementation and InValue nullity: [4](#0-3) 

**Critically, there is NO validation that the `ProducedBlocks` values in the NextRoundInput match what they should be based on the current round stored in state.** While honest nodes generate next round information by copying ProducedBlocks from their local state via `GenerateNextRoundInformation`, the contract does not enforce this invariant during validation.

### Impact Explanation
The inflated `ProducedBlocks` values directly impact mining reward calculations. During term changes, `DonateMiningReward` calculates total rewards: [5](#0-4) 

At line 119-120, it computes `amount = minedBlocks.Mul(miningRewardPerBlock)` where `minedBlocks` comes from: [6](#0-5) 

This sums all miners' `ProducedBlocks` values. An attacker inflating these values (e.g., doubling all counts) would double the mining rewards donated to Treasury, causing token inflation. Additionally, these inflated values are sent to the Election contract for candidate statistics, corrupting governance metrics and reward distributions.

**Concrete impact**: If legitimate total is 100 blocks but attacker inflates to 200 blocks, mining rewards would be 2x the intended amount, potentially causing significant token supply inflation over multiple terms.

### Likelihood Explanation
**Attacker capabilities**: Any miner who can produce a block triggering NextRound behavior. This occurs naturally at the end of each round when the extra block producer mines.

**Attack complexity**: Moderate. Attacker must:
1. Run a modified node that alters consensus extra data generation to inflate `ProducedBlocks` values
2. Produce a block at the appropriate time to trigger NextRound
3. Include the manipulated consensus data in the block

**Feasibility**: High. Miners regularly produce NextRound blocks as part of normal consensus operation. The validation system does not reconstruct and compare the expected next round information, only checking superficial properties (round number, InValue nullity).

**Detection**: Difficult. The manipulation occurs within consensus data that varies legitimately between rounds. Without comparing against expected values derived from current state, validators cannot detect the inflation.

### Recommendation
Add validation in `ProcessNextRound` to verify that `ProducedBlocks` values in the input match those in the current round:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // VALIDATION: Verify ProducedBlocks match current round
    foreach (var minerInNextRound in nextRound.RealTimeMinersInformation)
    {
        if (currentRound.RealTimeMinersInformation.ContainsKey(minerInNextRound.Key))
        {
            var currentMiner = currentRound.RealTimeMinersInformation[minerInNextRound.Key];
            var nextMiner = minerInNextRound.Value;
            
            // ProducedBlocks should only increase by 1 for the block producer
            var expectedProducedBlocks = currentMiner.ProducedBlocks;
            if (minerInNextRound.Key == Context.RecoverPublicKey().ToHex())
                expectedProducedBlocks = expectedProducedBlocks.Add(1);
                
            Assert(nextMiner.ProducedBlocks == expectedProducedBlocks, 
                $"Invalid ProducedBlocks for miner {minerInNextRound.Key}");
        }
    }
    
    RecordMinedMinerListOfCurrentRound();
    // ... rest of method
}
```

Alternatively, reconstruct the expected next round using `GenerateNextRoundInformation` and compare critical fields including `ProducedBlocks` against the provided input.

### Proof of Concept
**Initial state**: Round N with Miner A (ProducedBlocks: 10), Miner B (ProducedBlocks: 15), Miner C (ProducedBlocks: 12).

**Attack sequence**:
1. Miner A modifies node software to alter `GetConsensusExtraDataForNextRound` to inflate all `ProducedBlocks` by 2x
2. Miner A produces extra block triggering NextRound with manipulated `NextRoundInput` containing: Miner A (ProducedBlocks: 21), Miner B (ProducedBlocks: 30), Miner C (ProducedBlocks: 24)
3. Validation executes `RoundTerminateValidationProvider.ValidationForNextRound` which only checks round number (+1) and InValue nullity - **passes**
4. `ProcessNextRound` stores manipulated round via `AddRoundInformation`
5. At term change, `DonateMiningReward` calculates: `minedBlocks = 21+30+24 = 75` instead of legitimate `11+15+12 = 38`
6. Mining reward donated = `75 * rewardPerBlock` instead of `38 * rewardPerBlock`, nearly 2x inflation

**Expected result**: Validation should reject the NextRound transaction due to mismatched ProducedBlocks values.

**Actual result**: Transaction succeeds, inflated values stored and later used for reward calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```
