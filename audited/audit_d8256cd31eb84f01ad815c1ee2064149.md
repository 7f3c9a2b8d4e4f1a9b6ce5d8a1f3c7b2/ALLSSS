# Audit Report

## Title
Unauthorized ExtraBlockProducer Assignment Allows Any Miner to Gain Privileged Mining Rights

## Summary
The `GenerateFirstRoundOfNextTerm()` function unconditionally assigns the sender's public key to `ExtraBlockProducerOfPreviousRound` without validating that the sender was the legitimate extra block producer of the current round. This allows any miner to produce the NextTerm block and gain unauthorized mining privileges, disrupting consensus fairness.

## Finding Description

**Root Cause:** The vulnerable code unconditionally sets the sender as the previous round's extra block producer without verification: [1](#0-0) 

**Missing Authorization Checks:**

1. **PreCheck Insufficient:** The authorization check only verifies miner list membership, not the extra block producer role: [2](#0-1) 

2. **MiningPermissionValidationProvider Inadequate:** Only checks if sender is in the miner list: [3](#0-2) 

3. **RoundTerminateValidationProvider Missing Check:** For NextTerm, only validates term/round number increments, not producer authorization: [4](#0-3) 

4. **Validation Provider Registration:** NextTerm only adds RoundTerminateValidationProvider, lacking extra block producer validation: [5](#0-4) 

**Exploit Path:** Any miner can receive NextTerm behavior when term change conditions are met (time-based, not role-based): [6](#0-5) 

The term change determination is based on timing, not on who is the designated extra block producer: [7](#0-6) 

**Security Impact:** The `ExtraBlockProducerOfPreviousRound` field grants additional mining privileges at the start of the next round: [8](#0-7) [9](#0-8) 

**Intended Design:** Each round has exactly one designated extra block producer who should produce the term-ending block: [10](#0-9) 

The extra block time slot is specifically reserved for this designated producer: [11](#0-10) 

## Impact Explanation

**Consensus Integrity Violation:** An attacker who successfully produces the NextTerm block (despite not being the designated extra block producer) gains unauthorized mining privileges at the start of the new term. This allows them to produce additional tiny blocks during time slots reserved for the legitimate extra block producer, disrupting the fair block production schedule.

**Reward Misallocation:** The attacker receives more block production opportunities and consequently more mining rewards than deserved, while the legitimate extra block producer loses their earned privilege.

**Fairness Violation:** The extra block producer role is carefully calculated based on the first miner's signature to ensure fair rotation. This vulnerability allows any miner to bypass this fairness mechanism by racing to produce the NextTerm block first.

## Likelihood Explanation

**High Probability:** When term change conditions are met (every ~7 days based on `PeriodSeconds`), multiple miners can simultaneously receive NextTerm behavior. The consensus mechanism has no protection against multiple miners attempting to produce the NextTerm block concurrently.

**Low Attack Complexity:** An attacker only needs to:
1. Be a legitimate miner in the current term
2. Monitor when `NeedToChangeTerm()` returns true
3. Race to produce the NextTerm block before the designated extra block producer
4. Leverage network latency and block propagation timing

**Repeatable Attack:** This can be exploited at every term change, providing persistent opportunities for privilege escalation.

## Recommendation

Add validation in `GenerateFirstRoundOfNextTerm()` to verify the sender is the designated extra block producer:

```csharp
private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
{
    Round newRound;
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // Add validation: verify sender is the designated extra block producer
    var extraBlockProducer = currentRound.RealTimeMinersInformation
        .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
    Assert(extraBlockProducer.Key == senderPubkey, 
        "Only the designated extra block producer can initiate NextTerm.");
    
    // ... rest of the method
    newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
    return newRound;
}
```

Alternatively, add a validation provider specifically for NextTerm that checks extra block producer authorization:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new ExtraBlockProducerValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

A proof of concept would demonstrate that:
1. Miner A is designated as the extra block producer (IsExtraBlockProducer = true) in current round
2. Term change conditions are met (NeedToChangeTerm returns true)
3. Miner B (not the extra block producer) queries GetConsensusCommand and receives NextTerm behavior
4. Miner B produces the NextTerm block before Miner A
5. Miner B's public key is recorded as ExtraBlockProducerOfPreviousRound in the new term
6. Miner B gains unauthorized tiny block production privileges at the start of the new term

This breaks the consensus invariant that only the designated extra block producer should initiate term transitions and have their privileges carried forward.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-35)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-223)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L105-112)
```csharp
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
