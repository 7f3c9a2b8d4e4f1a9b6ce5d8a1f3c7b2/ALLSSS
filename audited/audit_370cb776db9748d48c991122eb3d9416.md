# Audit Report

## Title
Missing Round Expiration Validation Allows Stale Rounds to be Accepted

## Summary
The `TimeSlotValidationProvider` fails to validate that a round has expired when `ProvidedRound.RoundId` matches `BaseRound.RoundId`. The validation only checks historical mining time consistency without comparing against current blockchain time, allowing miners to produce blocks for rounds that should have timed out.

## Finding Description

When `ValidateBeforeExecution()` creates the `ConsensusValidationContext`, it does NOT include `Context.CurrentBlockTime` [1](#0-0) , and the context structure itself lacks this field [2](#0-1) .

When the provided round's `RoundId` equals the base round's `RoundId`, `TimeSlotValidationProvider.ValidateHeaderInformation()` enters the else branch [3](#0-2)  and calls `CheckMinerTimeSlot()`.

The `CheckMinerTimeSlot()` function [4](#0-3)  only validates internal consistency by checking if `latestActualMiningTime < endOfExpectedTimeSlot`. Critically, if a miner hasn't mined yet (`latestActualMiningTime == null`), it returns true without any time-based checks.

In contrast, the proper time slot expiration method `Round.IsTimeSlotPassed()` exists and correctly compares against `currentBlockTime` [5](#0-4) . This method is properly used in consensus command generation where `currentBlockTime` is available [6](#0-5) , but NOT in validation.

**Exploit Scenario:**
1. Round N is active with `State.CurrentRoundNumber = N`
2. Network disruption prevents all miners from producing blocks or triggering NextRound
3. Current blockchain time progresses far beyond the round's designated time period
4. A miner from Round N produces a block with `RoundId = N`
5. Validation sees `ProvidedRound.RoundId == BaseRound.RoundId`, enters else branch
6. `CheckMinerTimeSlot()` returns true (either because miner hasn't mined yet, or based on historical time relationships)
7. Block is accepted despite the round being logically expired in wall-clock time

## Impact Explanation

This vulnerability breaks the fundamental consensus invariant that rounds must transition within their designated time periods. It allows miners to produce blocks for rounds that have expired in wall-clock time as long as `State.CurrentRoundNumber` hasn't been updated.

**Severity: HIGH** - Compromises consensus integrity by:
- Enabling double mining opportunities when stale and current rounds coexist
- Allowing manipulation of round transition timing
- Creating consensus confusion across nodes with different timing perceptions
- Violating the time-based scheduling that AEDPoS fundamentally depends on

While this doesn't directly result in fund loss, consensus integrity violations are critical security failures that can cascade into broader protocol failures.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Capabilities:** Any valid miner in the current round - no special privileges required beyond normal mining rights.

**Attack Complexity:** LOW
- Can occur naturally during network disruptions when no miner successfully triggers NextRound
- Requires only patience and timing - no complex transaction sequences
- No economic stake at risk for the attacker

**Feasibility Conditions:**
All conditions are realistic and can occur during normal network operation:
- Network partition or coordination failure prevents miners from producing blocks
- Time progresses while `State.CurrentRoundNumber` remains unchanged
- Any miner from that round can later produce a block that passes validation

**Detection:** Difficult - the validation passes legitimately from the contract's perspective since the missing check IS the vulnerability.

## Recommendation

Add `CurrentBlockTime` to the `ConsensusValidationContext` and use it in validation:

1. **Update ConsensusValidationContext** to include:
```csharp
public Timestamp CurrentBlockTime { get; set; }
```

2. **Update ValidateBeforeExecution** to pass current time:
```csharp
var validationContext = new ConsensusValidationContext
{
    BaseRound = baseRound,
    CurrentTermNumber = State.CurrentTermNumber.Value,
    CurrentRoundNumber = State.CurrentRoundNumber.Value,
    PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
    LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
    ExtraData = extraData,
    CurrentBlockTime = Context.CurrentBlockTime  // ADD THIS
};
```

3. **Update TimeSlotValidationProvider.CheckMinerTimeSlot** to validate against current time:
```csharp
private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
{
    if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
    
    // Check if time slot has passed relative to current blockchain time
    if (validationContext.BaseRound.IsTimeSlotPassed(
        validationContext.SenderPubkey, 
        validationContext.CurrentBlockTime))
    {
        return false; // Time slot expired
    }
    
    // Existing historical consistency checks...
    var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
    if (latestActualMiningTime == null) return true;
    
    var expectedMiningTime = minerInRound.ExpectedMiningTime;
    var endOfExpectedTimeSlot = expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
    
    if (latestActualMiningTime < expectedMiningTime)
        return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();
    
    return latestActualMiningTime < endOfExpectedTimeSlot;
}
```

## Proof of Concept

A test demonstrating this vulnerability would:

1. Initialize Round N with multiple miners at time T0
2. Set expected mining times for each miner (e.g., T0+0s, T0+4s, T0+8s)
3. Simulate time progression to T0+100s (far past all time slots)
4. Create a block from a miner who hasn't mined yet with `RoundId = N`
5. Call `ValidateBeforeExecution()` 
6. **Expected Result**: Validation should FAIL because round has expired
7. **Actual Result**: Validation PASSES because current blockchain time isn't checked

The test would verify that `TimeSlotValidationProvider.ValidateHeaderInformation()` returns success even though `Context.CurrentBlockTime` is far beyond the round's designated time period, confirming blocks from expired rounds are incorrectly accepted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L20-31)
```csharp
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L26-36)
```csharp
        protected ConsensusBehaviourProviderBase(Round currentRound, string pubkey, int maximumBlocksCount,
            Timestamp currentBlockTime)
        {
            CurrentRound = currentRound;

            _pubkey = pubkey;
            _maximumBlocksCount = maximumBlocksCount;
            _currentBlockTime = currentBlockTime;

            _isTimeSlotPassed = CurrentRound.IsTimeSlotPassed(_pubkey, _currentBlockTime);
            _minerInRound = CurrentRound.RealTimeMinersInformation[_pubkey];
```
