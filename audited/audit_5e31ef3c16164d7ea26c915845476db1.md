### Title
Arithmetic Overflow in Bancor Price Calculation Causes Denial of Service for Token Purchases

### Summary
The `GetAmountToPayFromReturn` method in `BancorHelper.cs` can experience arithmetic overflow when the deposit connector balance approaches critically low values (e.g., 1) and users attempt to purchase large amounts of tokens with unfavorable weight ratios. This overflow causes transaction reversion, effectively denying service to the buy functionality until deposit reserves are replenished.

### Finding Description

The vulnerability exists in the Bancor price calculation formula at line 93 of `BancorHelper.cs`. [1](#0-0) 

The calculation computes: `amountToPay = fromConnectorBalance * (Exp(y * Ln(x)) - 1)` where:
- `x = toConnectorBalance / (toConnectorBalance - amountToReceive)`
- `y = toConnectorWeight / fromConnectorWeight`

When `fromConnectorBalance` is extremely low (e.g., 1) and `amountToReceive` is close to `toConnectorBalance`, the value of `x` becomes very large. Combined with an unfavorable weight ratio where `y > 1`, the exponential term `Exp(y * Ln(x))` grows to astronomical values that exceed `Long.MaxValue` (9.223 × 10^18).

Example scenario:
- `fromConnectorBalance = 1`
- `toConnectorBalance = 10^15`
- `amountToReceive = 9.99 × 10^14` (99.9% of supply)
- `fromConnectorWeight = 0.05`, `toConnectorWeight = 0.95`
- Result: `x = 1000`, `y = 19`, `Exp(19 * ln(1000)) ≈ 10^57` >> `Long.MaxValue`

The deposit balance can reach such low values through the `Sell` operation, which decrements the deposit balance without minimum threshold checks. [2](#0-1) 

The `Buy` operation calls this vulnerable method without overflow protection. [3](#0-2) 

AElf contracts enforce overflow checking through the `CheckForOverflowUnderflow` compilation flag, meaning any overflow throws an `OverflowException` and reverts the transaction. [4](#0-3) 

### Impact Explanation

**Severity: High** - Operational Denial of Service

When the deposit connector balance is depleted to critically low levels:
1. Any user attempting to buy significant amounts of the resource token will trigger an overflow
2. The transaction reverts with `OverflowException`, preventing the purchase
3. The buy functionality becomes completely unusable for that token pair
4. Legitimate users cannot acquire tokens through the converter
5. The DoS persists until administrators manually replenish the deposit balance through `EnableConnector` or similar governance actions

This affects all users of the TokenConverter for the impacted token pair and can occur for multiple pairs simultaneously if their deposits are depleted. The impact is amplified for connector pairs with high weight ratios (e.g., toWeight/fromWeight > 5).

### Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can manifest through two pathways:

1. **Natural Depletion** (Higher probability):
   - Through legitimate sell operations, the deposit balance naturally drains over time
   - No minimum balance checks exist to prevent depletion to critical levels
   - Weight ratios are set during initialization and cannot be easily adjusted
   - Token pairs with unfavorable weight ratios are more susceptible

2. **Intentional Exploitation** (Medium probability):
   - An attacker with sufficient resource tokens can deliberately drain the deposit through repeated sells
   - Once deposit reaches critical threshold, they can trigger overflow by attempting large purchases
   - Cost depends on existing liquidity but can be economically rational for high-value token pairs

The preconditions are entirely feasible:
- Public `Buy` and `Sell` methods are accessible to all users
- No special permissions required
- Connector weights are immutable after activation
- No monitoring or alerts for low deposit balances

### Recommendation

**Immediate Mitigations:**

1. **Add Minimum Balance Check** in `GetAmountToPayFromReturn`:
```csharp
// Before line 91 in BancorHelper.cs
Assert(fromConnectorBalance >= MIN_CONNECTOR_BALANCE, 
       "Connector balance too low for safe calculation");
```
Define `MIN_CONNECTOR_BALANCE` based on maximum supported token supply and weight ratios (e.g., 10^6).

2. **Add Overflow Guard** before the cast:
```csharp
// At line 93 in BancorHelper.cs
var result = bf * (Exp(y * Ln(x)) - decimal.One);
Assert(result <= (decimal)long.MaxValue, 
       "Payment amount exceeds maximum supported value");
return (long)result;
```

3. **Add Reserve Protection** in the `Sell` operation:
```csharp
// In TokenConverterContract.cs after line 193
var remainingBalance = State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
Assert(remainingBalance >= MIN_DEPOSIT_BALANCE, 
       "Insufficient deposit reserves - sale would deplete connector");
```

4. **Validate Weight Ratios** during connector initialization:
```csharp
// In Initialize/AddPairConnector methods
var weightRatio = Math.Max(toWeight, fromWeight) / Math.Min(toWeight, fromWeight);
Assert(weightRatio <= MAX_WEIGHT_RATIO, 
       "Weight ratio exceeds safe calculation bounds");
```

**Test Cases to Add:**
- Test overflow scenario with `fromConnectorBalance = 1` and large purchase amounts
- Test boundary conditions for various weight ratio combinations
- Test deposit depletion scenarios that trigger minimum balance protections

### Proof of Concept

**Initial State:**
1. Initialize connector pair with weights: `fromWeight = 0.05`, `toWeight = 0.95`
2. Set initial `toConnectorBalance = 10^15` (large token supply)
3. Set initial `fromConnectorBalance = 10^9` (reasonable deposit)

**Exploitation Steps:**

1. **Drain Deposit** (via legitimate or malicious sells):
   - Execute repeated `Sell` operations to transfer resource tokens
   - Each sell decrements `State.DepositBalance[fromConnector]`
   - Continue until deposit balance reaches 1

2. **Trigger Overflow** (via buy attempt):
   - Call `Buy(symbol, amount = 9.99 × 10^14, payLimit = 0)`
   - This triggers `GetAmountToPayFromReturn(1, 0.05, 10^15, 0.95, 9.99×10^14)`
   
3. **Calculation Process:**
   - `x = 10^15 / (10^15 - 9.99×10^14) = 1000`
   - `y = 0.95 / 0.05 = 19`
   - `Exp(19 * ln(1000)) = Exp(131.25) ≈ 2.8 × 10^56`
   - `result = 1 * (2.8×10^56 - 1) ≈ 2.8×10^56`

**Expected Result:** Transaction succeeds with calculated payment amount

**Actual Result:** Transaction reverts with `System.OverflowException: Arithmetic operation resulted in an overflow` because result exceeds `Long.MaxValue = 9.223×10^18`

**Success Condition for Attack:** All subsequent buy attempts for this token pair fail with overflow exception until deposit is manually replenished by governance.

---

**Notes:**
- The vulnerability stems from the mathematical properties of the Bancor formula when applied to extreme reserve ratios
- While AElf's overflow protection prevents silent corruption, it converts the issue into a DoS vector
- The lack of minimum balance enforcement during sell operations is the root enabling condition
- Connector pairs with weight ratios closer to 1:1 are less susceptible but not immune
- The issue affects the `GetNeededDeposit` view method as well, which uses the same calculation

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L20-30)
```markdown
- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```
```
