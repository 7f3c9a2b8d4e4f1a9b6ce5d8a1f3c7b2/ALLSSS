# Audit Report

## Title
Parliament Proposal Release Failure Due to Miner List Changes Between Voting and Execution

## Summary
The Parliament contract's `IsReleaseThresholdReached()` method evaluates vote thresholds using the CURRENT miner list at release time rather than the historical miner list when votes were cast. When consensus term transitions change the miner composition between voting and release, previously valid votes from departed miners are excluded from threshold calculations, causing legitimately approved proposals to permanently fail release.

## Finding Description

The vulnerability exists in the Parliament contract's vote threshold validation logic. When a proposal is released, the `Release()` method calls `IsReleaseThresholdReached()` to verify approval thresholds have been met. [1](#0-0) 

The core issue is that `IsReleaseThresholdReached()` retrieves the CURRENT miner list from the consensus contract at the moment of release: [2](#0-1) 

This current miner list is then used to filter ALL votes (approvals, rejections, abstentions) using LINQ's `.Contains()` predicate: [3](#0-2) 

The vote filtering operations explicitly exclude votes from addresses not in the current miner list: [4](#0-3) 

The miner list changes during consensus term transitions as the AEDPoS consensus updates the active miner set: [5](#0-4) 

The current miner list is retrieved from the current round's real-time miner information: [6](#0-5) 

**Broken Invariant:** Votes are immutable once cast and stored permanently in the proposal: [7](#0-6) 

However, their validity for threshold calculations changes dynamically based on current consensus state, violating the expectation that approved proposals remain releasable.

**Execution Scenario:**
1. At Term N: Miner set = {A, B, C, D, E} (5 miners)
2. Proposal created with default threshold 6667/10000 (66.67%): [8](#0-7) 

3. Miners A, B, C, D approve → 4/5 = 80% ≥ 66.67% (threshold reached)
4. Term transition occurs, new miner set = {B, C, F, G, H}
5. Proposer calls `Release()`
6. `IsReleaseThresholdReached()` filters approvals: only B and C remain valid
7. Threshold check: 2/5 = 40% < 66.67% → **FAILS**
8. Transaction reverts with "Not approved"

The proposal cannot be released even though it legitimately achieved approval threshold. If the proposal expires, it becomes permanently lost: [9](#0-8) 

## Impact Explanation

**HIGH Severity - Governance Denial of Service**

This vulnerability causes critical governance failures:

1. **Legitimately Approved Proposals Become Unreleasable**: Proposals that achieved proper approval thresholds at voting time can no longer be released, breaking the fundamental governance guarantee.

2. **System-Critical Operations Blocked**: The default organization handles system upgrades and critical configuration changes: [10](#0-9) 

3. **Emergency Response Disruption**: The Emergency Response Organization (with 90% threshold) is equally affected: [11](#0-10) 

4. **Governance Deadlock**: Expired proposals are permanently cleared with no recovery mechanism, forcing restart of entire approval process.

5. **Misleading View State**: The `GetProposal()` method also uses current miner list, so its `ToBeReleased` flag can fluctuate based on consensus state: [12](#0-11) 

## Likelihood Explanation

**HIGH Likelihood - Occurs During Normal Operations**

This issue requires no attacker action and manifests during routine system operation:

1. **Regular Term Transitions**: Consensus terms transition periodically based on `PeriodSeconds` (typically 7 days in production), updating the miner list.

2. **Natural Voting Duration**: Contentious or important proposals often require days to gather sufficient miner approvals, making it highly likely that voting periods span term boundaries.

3. **Guaranteed Miner Rotation**: The Election contract regularly updates miner composition through democratic election, ensuring miner sets change across terms.

4. **No Special Privileges Required**: Any proposer using standard Parliament governance will encounter this issue if their proposal's voting period crosses a term transition where any approving miners leave the active set.

5. **Silent Failure Mode**: The issue is invisible until release is attempted. Proposers see `ToBeReleased = true` during voting, then unexpectedly fail at release time with no clear indication of the root cause.

## Recommendation

Implement one of these solutions:

**Option 1: Snapshot Miner List at Proposal Creation**
Store the miner list in the proposal at creation time and use that snapshot for threshold validation:

```csharp
// In CreateProposal: 
proposal.MinerListSnapshot = GetCurrentMinerList();

// In IsReleaseThresholdReached:
var parliamentMembers = proposal.MinerListSnapshot;
```

**Option 2: Record Vote-Time Miner Status**
When miners vote, record their membership status as valid metadata:

```csharp
// In Approve/Reject/Abstain:
proposal.ValidVoterAddresses.Add(parliamentMemberAddress);

// In IsReleaseThresholdReached:
var approvedMemberCount = proposal.Approvals.Count(proposal.ValidVoterAddresses.Contains);
```

**Option 3: Store Term Number with Votes**
Record the term number when each vote is cast and validate against that historical term's miner list:

```csharp
// Store term number with each vote
proposal.ApprovalTerms[parliamentMemberAddress] = State.ConsensusContract.GetCurrentTermNumber();

// Validate against historical miner lists
var validApprovals = proposal.Approvals.Where(addr => 
    State.ConsensusContract.GetMinerListForTerm(proposal.ApprovalTerms[addr]).Contains(addr));
```

## Proof of Concept

```csharp
[Fact]
public async Task Parliament_Release_Fails_After_MinerList_Change()
{
    // Setup: Create organization with default 66.67% threshold
    var organizationAddress = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    
    // Create proposal requiring miner approval
    var proposalId = await CreateParliamentProposalAsync(
        nameof(TokenContractStub.Transfer), 
        organizationAddress,
        new TransferInput { Symbol = "ELF", Amount = 100, To = Tester },
        TokenContractAddress);
    
    // Initial miner set: 3 miners
    var initialMiners = InitialMinersKeyPairs; // {Miner0, Miner1, Miner2}
    
    // All 3 miners approve (100% approval, exceeds 66.67% threshold)
    foreach (var minerKeyPair in initialMiners)
    {
        var minerStub = GetParliamentContractTester(minerKeyPair);
        await minerStub.Approve.SendAsync(proposalId);
    }
    
    // Verify proposal is approved with current miner list
    var proposal = await ParliamentContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBeTrue();
    proposal.ApprovalCount.ShouldBe(3);
    
    // Simulate term transition with new miner list {Miner0, NewMiner3, NewMiner4}
    var newMinerList = new MinerList 
    { 
        Pubkeys = 
        { 
            ByteStringHelper.FromHexString(InitialMinersKeyPairs[0].PublicKey.ToHex()),
            ByteStringHelper.FromHexString(Accounts[10].KeyPair.PublicKey.ToHex()),
            ByteStringHelper.FromHexString(Accounts[11].KeyPair.PublicKey.ToHex())
        } 
    };
    await ConsensusContractStub.NextTerm.SendAsync(
        newMinerList.GenerateFirstRoundOfNewTerm(MiningInterval, BlockchainStartTime.AddDays(7)));
    
    // Now only 1 of 3 approvals (Miner0) is still valid
    // 1/3 = 33.33% < 66.67% threshold
    
    // Attempt to release proposal - should FAIL despite having been approved
    var releaseResult = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalId);
    
    // VULNERABILITY: Previously approved proposal can no longer be released
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // The proposal is now permanently stuck - votes are immutable but no longer count
}
```

## Notes

This is a **time-of-check-to-time-of-use (TOCTOU)** vulnerability in governance logic. The threshold is validated against dynamic consensus state rather than historical voting context, creating a temporal inconsistency that breaks governance integrity. The issue affects ALL Parliament organizations (default, custom, and emergency response) and has no workaround once a proposal enters this state.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-37)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-78)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-5)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
```
