### Title
Insufficient Validation in Recharge() Allows Side Chain to Immediately Return to Debt Status

### Summary
The `Recharge()` function contains a flawed validation check at line 207 that reads the balance AFTER paying arrears, causing `input.Amount` to be double-counted in the assertion. This allows a side chain to be recharged with insufficient funds, passing validation but immediately falling back into `IndexingFeeDebt` status upon the next block indexing attempt.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The validation logic at line 207 has a critical ordering flaw. The code executes in this sequence:

1. Transfers `input.Amount` to the side chain's virtual address [2](#0-1) 
2. For chains in `IndexingFeeDebt` status, pays off all arrears by transferring from the virtual address [3](#0-2) 
3. Reads `originBalance` from `GetSideChainIndexingFeeDeposit()` AFTER arrears are paid [4](#0-3) 
4. Validates: `Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice)` [5](#0-4) 

At line 206, `originBalance = balance_before_recharge + input.Amount - arrearsAmount` (balance after both recharge and arrears payment).

The assertion at line 207 becomes:
`input.Amount + (balance_before_recharge + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`

Simplifying: `2 × input.Amount + balance_before_recharge >= 2 × arrearsAmount + IndexingPrice`

This double-counts both `input.Amount` (appears twice) and `arrearsAmount` (required twice on right side despite being paid once).

**Why Protections Fail:** The correct invariant should ensure that after recharge and paying arrears, the remaining balance is sufficient for at least one more block indexing: `balance_before_recharge + input.Amount - arrearsAmount >= IndexingPrice`. However, the flawed check allows recharges that violate this invariant.

### Impact Explanation

**Operational Disruption:** A side chain can be successfully recharged and marked as `Active` status, but lacks sufficient funds for the next block indexing operation. When miners attempt to index the next block [6](#0-5) , the chain immediately returns to `IndexingFeeDebt` status, creating:

1. **Indexing Failure Cycle:** The side chain oscillates between Active and IndexingFeeDebt status without successfully processing blocks
2. **Miner Payment Loss:** Miners proposing blocks don't receive indexing fees because arrears accumulate instead [7](#0-6) 
3. **Gas Waste:** Multiple recharge attempts required before achieving stable operation
4. **Cross-Chain Communication Disruption:** Parent chain cannot reliably index side chain data, breaking cross-chain functionality
5. **Accounting Confusion:** Chain appears Active in status but functionally remains in debt

**Severity Justification:** Medium - While not causing direct fund theft, this creates operational DoS of cross-chain indexing and wastes resources through failed indexing attempts.

### Likelihood Explanation

**Reachable Entry Point:** `Recharge()` is a public function callable by anyone with sufficient token allowance.

**Feasible Preconditions:** 
- Side chain must be in `IndexingFeeDebt` status (common scenario when chains run out of deposited funds)
- `balance_before_recharge < IndexingPrice` (typical for chains that went into debt)

**Execution Practicality:** The exploit requires simple arithmetic calculation. Given `arrearsAmount = A`, `IndexingPrice = P`, and `balance_before_recharge = B`:

The exploit range exists when `(2A + P - B)/2 ≤ input.Amount < A + P - B`

This range is non-empty whenever `B < P`, which is the typical state for chains in debt.

**Attack Complexity:** Low - A simple recharge transaction with a calculated amount. No special privileges or complex multi-step sequences required.

**Economic Rationality:** Minimal cost - only the gas for the recharge transaction plus the recharge amount itself. The "attacker" (or legitimate user making an honest mistake) doesn't lose funds, they just create an unstable state.

### Recommendation

**Code-Level Fix:** Modify the validation logic to check the balance BEFORE paying arrears, or check the remaining balance AFTER paying arrears:

**Option 1 - Check before paying arrears:**
```
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
// Then pay arrears
foreach (var arrears in sideChainInfo.ArrearsInfo) { ... }
```

**Option 2 - Check remaining balance directly:**
```
// Pay arrears first
foreach (var arrears in sideChainInfo.ArrearsInfo) { ... }
var remainingBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(remainingBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

**Invariant to Enforce:** After recharge completes, `GetSideChainIndexingFeeDeposit(chainId) >= sideChainInfo.IndexingPrice` must hold to prevent immediate return to debt.

**Test Case:** Add test verifying that recharging with exactly `arrearsAmount` fails, and recharging with `arrearsAmount + IndexingPrice - balance_before_recharge` succeeds and keeps chain Active for at least one block indexing.

### Proof of Concept

**Initial State:**
- Side chain `chainId` in `IndexingFeeDebt` status
- `sideChainInfo.ArrearsInfo` contains total arrears = 100 tokens
- `sideChainInfo.IndexingPrice` = 100 tokens
- Balance before recharge = 0 tokens

**Exploit Transaction:**
1. Caller approves CrossChain contract for 150 tokens
2. Call `Recharge(new RechargeInput { ChainId = chainId, Amount = 150 })`

**Execution Flow:**
1. Line 181-188: Transfer 150 tokens → virtual address balance = 150
2. Line 194-204: Pay arrears of 100 tokens → virtual address balance = 50
3. Line 206: `originBalance = GetSideChainIndexingFeeDeposit(chainId)` returns 50
4. Line 207: Check `150 + 50 >= 100 + 100`? → `200 >= 200`? → **PASSES** ✓
5. Lines 211-213: Clear arrears, set status to `Active`

**Actual Result:** 
- Recharge succeeds, chain status = `Active`
- Remaining balance = 50 tokens

**Expected vs Actual:**
- Expected: Chain should have at least 100 tokens (IndexingPrice) to handle next block
- Actual: Chain has only 50 tokens

**Success Condition for Exploit:** On next call to `IndexSideChainBlockData()` [8](#0-7) , at line 844 the balance (50) minus IndexingPrice (100) becomes negative, immediately setting the chain back to `IndexingFeeDebt` status at line 850, proving the recharge was insufficient despite passing validation.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-893)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            long arrearsAmount = 0;
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }

            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
            
            Context.Fire(new SideChainIndexed
            {
                ChainId = chainId,
                IndexedHeight = currentSideChainHeight
            });
        }

        if (indexedSideChainBlockData.Count > 0)
            Context.LogDebug(() =>
                $"Last indexed height {indexedSideChainBlockData.Last().Height} for side chain {chainId}");

        return indexedSideChainBlockData;
    }
```
