### Title
Missing Validation Allows Transaction Fee Free Allowance Overflow Causing DoS

### Summary
The `ConfigTransactionFeeFreeAllowances` method lacks validation on allowance amounts, allowing parliament to configure multiple symbols with allowances that overflow when summed. When users hold multiple configured tokens above threshold, the fee charging system throws an `OverflowException` during allowance summation, causing a denial-of-service for affected users who cannot execute transactions.

### Finding Description

The vulnerability exists in the transaction fee free allowances system across multiple components:

**Configuration Without Validation:**
The `ConfigTransactionFeeFreeAllowances` method only validates that threshold and refresh seconds are non-negative, but performs no validation on the actual allowance amounts or their potential sum across configurations. [1](#0-0) 

**Overflow-Prone Summation:**
The `GetFreeFeeAllowanceAmount` method iterates through all configured symbols for which a user meets the threshold and sums their allowances for a specific fee token using the `.Add()` extension method. [2](#0-1) 

**Checked Arithmetic Throws Exception:**
The `.Add()` method uses C#'s `checked` keyword, which throws an `OverflowException` when the sum exceeds `long.MaxValue` (9,223,372,036,854,775,807). [3](#0-2) 

**Critical Path Integration:**
This summation occurs during transaction fee charging in `ChargeTransactionFees`, which is executed as a pre-plugin transaction for every user transaction. [4](#0-3) 

The allowance calculation is invoked multiple times during fee charging to determine available fee payment options. [5](#0-4) 

**Data Structure:**
The state variable stores configurations per symbol, where each configuration contains nested allowances. [6](#0-5) 

The protobuf definition shows `TransactionFeeFreeAllowance` amounts are `int64` fields with no defined constraints. [7](#0-6) 

### Impact Explanation

**Operational DoS:**
When parliament configures multiple symbols (e.g., ELF and TOKEN1) with allowance amounts that sum beyond `long.MaxValue` for any fee token, all users holding both tokens above their thresholds become unable to execute transactions. The overflow exception in `GetFreeFeeAllowanceAmount` propagates up and causes the pre-plugin fee charging transaction to fail, blocking the user's actual transaction from executing.

**Affected Users:**
Any user who legitimately holds multiple tokens for which parliament has configured free allowances above the respective thresholds. This could affect a significant portion of the user base if common tokens are misconfigured.

**System Impact:**
The blockchain's transaction processing capability is degraded for affected users until parliament reconfigures the allowances with corrected values. This requires governance action to fix, during which time users cannot transact.

**Severity:**
Medium severity - This causes operational disruption without direct fund loss. The impact is significant (DoS) but requires a configuration error by parliament rather than malicious exploitation.

### Likelihood Explanation

**Configuration Error Likelihood:**
Parliament must configure transaction fee free allowances through governance proposals. Without validation warnings or maximum limits, administrators could unknowingly set values like:
- Symbol1: ELF allowance = 5,000,000,000,000,000,000
- Symbol2: ELF allowance = 5,000,000,000,000,000,000
- Sum = 10,000,000,000,000,000,000 > `long.MaxValue`

**Practical Scenario:**
This is not a malicious attack but an operational error. Given that:
1. No validation exists on individual allowance amounts
2. No validation exists on the cumulative sum across configurations
3. No UI warnings would alert administrators to the risk
4. Token amounts often use large values (e.g., 1 ELF = 100,000,000 base units)

The likelihood is **medium** - it could reasonably occur through administrative oversight, especially when configuring multiple generous allowances across several tokens.

**Execution Path:**
The vulnerability triggers automatically during normal user operations (sending any transaction) without requiring specific attacker actions beyond the initial misconfiguration.

### Recommendation

**Add Configuration Validation:**
In `ConfigTransactionFeeFreeAllowances`, add validation to check:
1. Each individual allowance amount is within reasonable bounds (e.g., < `long.MaxValue / 1000`)
2. Simulate the potential sum of allowances across all configured symbols for each fee token
3. Reject configurations where any fee token's total allowances could approach `long.MaxValue`

**Specific Code Addition:** [8](#0-7) 

Add validation before line 1257:
```
// Validate allowance amounts and check for potential overflow
foreach (var allowance in config.FreeAllowances.Map.Values)
{
    Assert(allowance.Amount >= 0 && allowance.Amount < long.MaxValue / 1000, 
        $"Allowance amount {allowance.Amount} for {allowance.Symbol} exceeds safe limits");
    
    // Check cumulative sum across all existing configurations
    var existingSumForSymbol = CalculateTotalConfiguredAllowance(allowance.Symbol);
    Assert(existingSumForSymbol.Add(allowance.Amount) < long.MaxValue / 2,
        $"Total allowances for {allowance.Symbol} would exceed safe limits");
}
```

**Add Test Cases:**
Create tests that verify:
1. Configuration is rejected when individual allowances exceed safe thresholds
2. Configuration is rejected when cumulative allowances would overflow
3. Edge cases near `long.MaxValue` are handled correctly

### Proof of Concept

**Initial State:**
1. Parliament has governance authority
2. Two tokens exist: ELF and TOKEN1
3. User Alice holds: 1000 ELF and 1000 TOKEN1 (both above thresholds)

**Transaction Steps:**

1. Parliament configures ELF free allowances:
```
ConfigTransactionFeeFreeAllowances({
  Symbol: "ELF",
  Threshold: 100,
  FreeAllowances: { "ELF": 6,000,000,000,000,000,000 }
})
```

2. Parliament configures TOKEN1 free allowances:
```
ConfigTransactionFeeFreeAllowances({
  Symbol: "TOKEN1", 
  Threshold: 100,
  FreeAllowances: { "ELF": 5,000,000,000,000,000,000 }
})
```

3. Alice attempts to send any transaction

**Expected Result:**
Transaction executes successfully with fee deducted

**Actual Result:**
Transaction fails with `OverflowException` during `GetFreeFeeAllowanceAmount`:
- Method attempts: 6,000,000,000,000,000,000 + 5,000,000,000,000,000,000
- Sum: 11,000,000,000,000,000,000 > `long.MaxValue` (9,223,372,036,854,775,807)
- Checked arithmetic throws `OverflowException`
- Fee charging fails, Alice's transaction is blocked

**Success Condition:**
Alice cannot execute transactions until parliament reconfigures with corrected allowance values that don't overflow when summed.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L436-460)
```csharp
    private void GetAvailableBalance(string symbolToPayTxFee, Address fromAddress, TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, TransactionFreeFeeAllowanceBill allowanceBill,
        out string symbolChargedForBaseFee, out long amountChargedForBaseFee, out long amountChargedForBaseAllowance,
        out long availableBalance, out long availableAllowance)
    {
        symbolChargedForBaseFee = null;
        amountChargedForBaseFee = 0L;
        amountChargedForBaseAllowance = 0L;

        if (bill.FeesMap.Any())
        {
            symbolChargedForBaseFee = bill.FeesMap.First().Key;
            amountChargedForBaseFee = bill.FeesMap.First().Value;
            amountChargedForBaseAllowance = allowanceBill.FreeFeeAllowancesMap[symbolChargedForBaseFee];
        }

        availableBalance = symbolChargedForBaseFee == symbolToPayTxFee
            // Available balance need to deduct amountChargedForBaseFee, if base fee is charged in the same token.
            ? GetBalance(fromAddress, symbolToPayTxFee).Sub(amountChargedForBaseFee)
            : GetBalance(fromAddress, symbolToPayTxFee);
        availableAllowance = symbolChargedForBaseFee == symbolToPayTxFee
            ? GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolToPayTxFee)
                .Sub(amountChargedForBaseAllowance)
            : GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbolToPayTxFee);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1224-1266)
```csharp
    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");

        State.TransactionFeeFreeAllowancesSymbolList.Value ??= new TransactionFeeFreeAllowancesSymbolList
        {
            Symbols = { new RepeatedField<string>() }
        };

        foreach (var allowances in input.Value!)
        {
            ValidateToken(allowances.Symbol);
            Assert(
                allowances.TransactionFeeFreeAllowances?.Value != null &&
                allowances.TransactionFeeFreeAllowances.Value.Count > 0,
                "Invalid input allowances");
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");

            var config = new TransactionFeeFreeAllowanceConfig
            {
                Symbol = allowances.Symbol,
                Threshold = allowances.Threshold,
                RefreshSeconds = allowances.RefreshSeconds,
                FreeAllowances = new TransactionFeeFreeAllowanceMap()
            };

            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
            }

            State.TransactionFeeFreeAllowancesConfigMap[allowances.Symbol] = config;

            if (!State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Contains(allowances.Symbol))
            {
                State.TransactionFeeFreeAllowancesSymbolList.Value.Symbols.Add(allowances.Symbol);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L42-55)
```csharp
    /// <summary>
    ///  Symbol List
    /// </summary>
    public SingletonState<TransactionFeeFreeAllowancesSymbolList> TransactionFeeFreeAllowancesSymbolList { get; set; }
    
    /// <summary>
    /// Symbol -> TransactionFeeFreeAllowanceConfig
    /// </summary>
    public MappedState<string, TransactionFeeFreeAllowanceConfig> TransactionFeeFreeAllowancesConfigMap { get; set; }
    
    /// <summary>
    /// Address -> Symbol -> TransactionFeeFreeAllowanceMap
    /// </summary>
    public MappedState<Address, string, TransactionFeeFreeAllowanceMap> TransactionFeeFreeAllowances { get; set; }
```

**File:** protobuf/token_contract_impl.proto (L356-393)
```text
message TransactionFeeFreeAllowance {
    string symbol = 1;
    int64 amount = 2;
}

message TransactionFeeFreeAllowancesSymbolList {
    repeated string symbols = 1;
}

message ConfigTransactionFeeFreeAllowancesInput {
    repeated ConfigTransactionFeeFreeAllowance value = 1;
}

message ConfigTransactionFeeFreeAllowance {
    string symbol = 1;
    TransactionFeeFreeAllowances transaction_fee_free_allowances = 2;
    int64 refresh_seconds = 3;
    int64 threshold = 4;
}

message RemoveTransactionFeeFreeAllowancesConfigInput {
    repeated string symbols = 1;
}

message GetTransactionFeeFreeAllowancesConfigOutput {
    repeated TransactionFeeFreeAllowanceConfig value = 1;
}

message TransactionFeeFreeAllowanceConfig {
    string symbol = 1;
    TransactionFeeFreeAllowanceMap free_allowances = 2;
    int64 refresh_seconds = 3;
    int64 threshold = 4;
}

message TransactionFeeFreeAllowanceMap {
    map<string, TransactionFeeFreeAllowance> map = 1;
}
```
