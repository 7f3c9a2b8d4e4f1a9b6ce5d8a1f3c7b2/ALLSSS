### Title
VotingResult Data Inconsistency Due to Missing Results Map Initialization in Snapshot

### Summary
When `TakeSnapshot()` creates a new voting snapshot, it copies `VotersCount` and `VotesAmount` from the previous snapshot but fails to copy the `Results` map (option â†’ vote amounts). This creates a state inconsistency where the new snapshot's aggregate vote counts include previous votes, but the detailed per-option results do not, causing `GetVotingResult()` to return incomplete and misleading voting data. [1](#0-0) 

### Finding Description

In the `TakeSnapshot()` function, when creating a new `VotingResult` for the next snapshot, the code copies `VotersCount` and `VotesAmount` from the previous snapshot but does not initialize or copy the `Results` map: [2](#0-1) 

The `Results` map (defined as `map<string, int64>` in the protobuf) automatically initializes as an empty map in protobuf3. This creates a data inconsistency:

**Previous Snapshot State:**
- `VotingResult.Results` = {"Option A": 100, "Option B": 200}  
- `VotingResult.VotersCount` = 2
- `VotingResult.VotesAmount` = 300

**New Snapshot State After TakeSnapshot:**
- `VotingResult.Results` = {} (empty!)
- `VotingResult.VotersCount` = 2 (copied)
- `VotingResult.VotesAmount` = 300 (copied) [3](#0-2) 

When new votes are cast in the new snapshot, the `Results` map only reflects new votes while `VotersCount` and `VotesAmount` continue accumulating. This violates the invariant that `VotesAmount` should equal the sum of all values in the `Results` map. [4](#0-3) 

The `UpdateVotingResult()` function handles empty Results maps defensively (line 174), so new votes DO record properly - but the existing votes from previous snapshots are not reflected in the Results map of the new snapshot.

### Impact Explanation

**Data Integrity Violation:**
The `VotingResult` structure maintains inconsistent state where aggregate counts (`VotersCount`, `VotesAmount`) include votes from previous snapshots, but the detailed breakdown (`Results` map) does not. For example, a snapshot might show `VotesAmount = 850` tokens but `sum(Results.values) = 400` tokens - a discrepancy of 450 tokens from previous snapshots.

**Misleading Query Results:**
External contracts and UIs querying voting results via `GetVotingResult()` receive incomplete data. The `Results` map only shows votes cast within that specific snapshot, not the total active votes that `VotesAmount` represents. [5](#0-4) 

**Election Contract Impact:**
The Election contract's `GetElectionResult()` method uses `votingResult.Results` to return election outcomes. This would show incomplete voting data for a given term: [6](#0-5) 

**Severity Justification:**
Medium severity - no fund loss or governance bypass, but creates persistent data inconsistency affecting all consumers of voting result data. The core voting mechanism (via `VotingRecords`) remains functional, limiting the operational impact.

### Likelihood Explanation

**Automatic Occurrence:**
This inconsistency occurs automatically during normal operation whenever `TakeSnapshot()` is called while votes from previous snapshots remain active. No attacker action required.

**Common Scenario:**
Multi-snapshot voting items (election terms, multi-round governance votes) routinely trigger this condition. The test case demonstrates this occurring in standard election scenarios with 3 snapshots: [7](#0-6) 

At line 94, `VotersCount = 7` includes votes from both snapshot 1 (3 votes before withdrawal) and snapshot 2 (4 new votes), but the `Results` map at lines 95-98 shows only the 3 options voted in snapshot 2, not the options from snapshot 1.

**Detection:**
The inconsistency persists in state and affects all queries to `GetVotingResult()` for snapshots after the first. It is immediately observable by comparing `VotesAmount` to the sum of `Results` values.

### Recommendation

**Code-Level Fix:**
Copy the `Results` map from the previous snapshot when creating a new snapshot, similar to how `VotersCount` and `VotesAmount` are copied:

```csharp
// In TakeSnapshot() at line 264:
var previousResults = new Dictionary<string, long>(previousVotingResult.Results);
State.VotingResults[currentVotingGoingHash] = new VotingResult
{
    VotingItemId = input.VotingItemId,
    SnapshotNumber = nextSnapshotNumber,
    SnapshotStartTimestamp = Context.CurrentBlockTime,
    VotersCount = previousVotingResult.VotersCount,
    VotesAmount = previousVotingResult.VotesAmount,
    Results = { previousResults }  // Copy the Results map
};
```

**Invariant Check:**
Add validation in `GetVotingResult()` to assert consistency:
```csharp
Assert(votingResult.VotesAmount == votingResult.Results.Values.Sum(), 
    "Results map inconsistent with VotesAmount");
```

**Test Case:**
Add test verifying that after `TakeSnapshot()`, the new snapshot's `Results` map matches the previous snapshot's `Results` map before any new votes are cast.

### Proof of Concept

**Initial State:**
1. Register voting item with `TotalSnapshotNumber = 2`
2. Alice votes 100 tokens for "Option A" in Snapshot 1
3. Bob votes 200 tokens for "Option B" in Snapshot 1
4. Query Snapshot 1: `Results = {"Option A": 100, "Option B": 200}`, `VotesAmount = 300`

**Trigger Vulnerability:**
5. Sponsor calls `TakeSnapshot(snapshotNumber = 1)`
6. New Snapshot 2 created with: `VotesAmount = 300`, `VotersCount = 2`, `Results = {}`

**Observe Inconsistency:**
7. Query Snapshot 2 via `GetVotingResult(votingItemId, snapshotNumber=2)`
8. **Expected**: `Results = {"Option A": 100, "Option B": 200}`, `VotesAmount = 300`
9. **Actual**: `Results = {}` (empty), `VotesAmount = 300`
10. Inconsistency: `VotesAmount = 300` but `sum(Results.values) = 0`

**Additional Votes Compound Issue:**
11. Carol votes 50 tokens for "Option C" in Snapshot 2
12. Query Snapshot 2: `Results = {"Option C": 50}`, `VotesAmount = 350`
13. Inconsistency: `VotesAmount = 350` but `sum(Results.values) = 50` (missing 300 from previous snapshot)

**Success Condition:**
The vulnerability is confirmed when querying any snapshot after the first shows `VotesAmount` not equal to the sum of values in the `Results` map, demonstrating that the `Results` map does not reflect the votes counted in `VotesAmount`.

### Notes

While new votes continue to record properly in the `Results` map (via the defensive check in `UpdateVotingResult()` at line 174), the fundamental issue is that the `Results` map for a new snapshot does not include votes from previous snapshots, even though `VotersCount` and `VotesAmount` do. This creates a persistent data inconsistency that affects all consumers of the voting result data through the `GetVotingResult()` API.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L263-271)
```csharp
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L34-42)
```csharp
    public override VotingResult GetVotingResult(GetVotingResultInput input)
    {
        var votingResultHash = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = input.SnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L102-115)
```csharp
    public override ElectionResult GetElectionResult(GetElectionResultInput input)
    {
        var votingResult = State.VoteContract.GetVotingResult.Call(new GetVotingResultInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            SnapshotNumber = input.TermNumber
        });

        var result = new ElectionResult
        {
            TermNumber = input.TermNumber,
            IsActive = input.TermNumber == State.CurrentTermNumber.Value,
            Results = { votingResult.Results }
        };
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L12-101)
```csharp
    public async Task MultipleUsers_Vote_Scenario_Test()
    {
        var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 3);

        var user1 = Accounts[1];
        var user2 = Accounts[2];
        var user3 = Accounts[3];

        //phase 1
        {
            //user1 vote 100
            var transactionResult1 = await Vote(user1.KeyPair, registerItem.VotingItemId, registerItem.Options[0], 100);
            transactionResult1.Status.ShouldBe(TransactionResultStatus.Mined);

            //user2 vote 150
            var transactionResult2 = await Vote(user2.KeyPair, registerItem.VotingItemId, registerItem.Options[0], 150);
            transactionResult2.Status.ShouldBe(TransactionResultStatus.Mined);

            //user3 vote 200
            var transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, registerItem.Options[1], 200);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingResult = await GetVotingResult(registerItem.VotingItemId, 1);
            votingResult.VotersCount.ShouldBe(3);
            votingResult.Results.Count.ShouldBe(2);
            votingResult.Results[registerItem.Options[0]].ShouldBe(250);
            votingResult.Results[registerItem.Options[1]].ShouldBe(200);

            //take snapshot
            var snapshotResult = await TakeSnapshot(registerItem.VotingItemId, 1);
            snapshotResult.Status.ShouldBe(TransactionResultStatus.Mined);

            //query vote ids
            var voteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            //query result
            var voteRecord = await GetVotingRecord(voteIds.ActiveVotes.First());
            voteRecord.Option.ShouldBe(registerItem.Options[0]);
            voteRecord.Amount.ShouldBe(100);

            //withdraw
            var beforeBalance = GetUserBalance(user1.Address);
            await Withdraw(user1.KeyPair, voteIds.ActiveVotes.First());
            var afterBalance = GetUserBalance(user1.Address);

            beforeBalance.ShouldBe(afterBalance - 100);

            voteIds = await GetVoteIds(user1.KeyPair, registerItem.VotingItemId);
            voteIds.ActiveVotes.Count.ShouldBe(0);
            voteIds.WithdrawnVotes.Count.ShouldBe(1);
        }

        //phase 2
        {
            //add some more option
            var options = new[]
            {
                Accounts[3].Address.ToBase58(),
                Accounts[4].Address.ToBase58(),
                Accounts[5].Address.ToBase58()
            };
            var optionResult = (await VoteContractStub.AddOptions.SendAsync(new AddOptionsInput
            {
                VotingItemId = registerItem.VotingItemId,
                Options = { options }
            })).TransactionResult;
            optionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            //user1 vote new option 1
            var transactionResult1 = await Vote(user1.KeyPair, registerItem.VotingItemId, options[0], 100);
            transactionResult1.Status.ShouldBe(TransactionResultStatus.Mined);

            //user2 vote new option 2
            var transactionResult2 = await Vote(user2.KeyPair, registerItem.VotingItemId, options[1], 100);
            transactionResult2.Status.ShouldBe(TransactionResultStatus.Mined);

            //user3 vote new option 3 twice
            var transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);
            transactionResult3 = await Vote(user3.KeyPair, registerItem.VotingItemId, options[2], 100);
            transactionResult3.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
            votingResult.Results.Count.ShouldBe(3);
            votingResult.Results[options[0]].ShouldBe(100);
            votingResult.Results[options[1]].ShouldBe(100);
            votingResult.Results[options[2]].ShouldBe(200);

            //take snapshot
            var snapshotResult = await TakeSnapshot(registerItem.VotingItemId, 2);
```
