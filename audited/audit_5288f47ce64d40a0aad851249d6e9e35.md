# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound Allows Manipulation of Block Producer Privileges

## Summary
The `ValidationForNextRound()` function fails to validate that the `ExtraBlockProducerOfPreviousRound` field in `NextRoundInput` matches the actual transaction sender, allowing any miner to arbitrarily set this value when transitioning to a new round. This manipulated field is then used to grant unauthorized mining privileges before the round start time and additional tiny block production quota, directly affecting consensus fairness and reward distribution.

## Finding Description

The vulnerability exists in the AEDPoS consensus round transition validation logic. When a miner produces a block to transition to the next round via the public `NextRound` method [1](#0-0) , the `NextRoundInput` structure contains an `ExtraBlockProducerOfPreviousRound` field that should identify which miner produced the extra block in the previous round.

The validation performed by `ValidationForNextRound()` only checks that the round number increments correctly and that InValues are null, but does not validate that `ExtraBlockProducerOfPreviousRound` matches the actual sender [2](#0-1) . The validation service applies the `RoundTerminateValidationProvider` for NextRound transitions [3](#0-2) .

When processing the NextRound input, the system converts it to a Round object via `ToRound()`, which directly copies the unvalidated field without any verification [4](#0-3) . This manipulated Round object is then stored [5](#0-4) .

The correctly set value should be the actual sender's pubkey, as shown in `GetConsensusExtraDataForNextRound` [6](#0-5) .

The manipulated field is then used in two critical consensus functions to grant special privileges:

**1. Mining permission before round start**: The `IsCurrentMiner()` function explicitly allows the `ExtraBlockProducerOfPreviousRound` to mine before the round officially begins [7](#0-6) .

**2. Additional tiny block quota**: The consensus behavior provider grants extra tiny blocks beyond normal limits to the `ExtraBlockProducerOfPreviousRound`. This is implemented in two places within `ConsensusBehaviourProviderBase`:
- When the miner has already produced blocks [8](#0-7) 
- When handling a miner in a new round [9](#0-8) 

## Impact Explanation

This vulnerability represents a **consensus integrity violation** that breaks the fundamental fairness of the AEDPoS consensus mechanism:

1. **Unauthorized Mining Windows**: An attacker can grant any miner (including themselves) permission to mine during the pre-round period before `GetRoundStartTime()`, a time slot that should only be available to the legitimate extra block producer from the previous round.

2. **Additional Block Production Quota**: The manipulated miner receives `_maximumBlocksCount + blocksBeforeCurrentRound` tiny blocks instead of the normal `_maximumBlocksCount` limit, allowing significantly more block production than intended by the consensus rules.

3. **Reward Misallocation**: More blocks produced directly translates to more mining rewards. By manipulating which miner receives these privileges, the attacker can unfairly redirect economic rewards away from legitimate miners.

4. **Block Producer Selection Manipulation**: By granting unauthorized miners extra time slots and quotas, the attacker can influence the consensus schedule, determining which miners produce blocks and when, undermining the deterministic nature of the consensus mechanism.

5. **Chain-wide Impact**: This affects all network participants as it compromises the fairness and predictability of block production scheduling, which is fundamental to the security and proper functioning of the blockchain.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is trivially exploitable:

- **Public Entry Point**: The `NextRound` method is publicly accessible and can be called by any miner when producing the extra block that terminates a round.

- **Minimal Attacker Requirements**: The attacker only needs to be a valid miner in the current round - no special permissions, compromised keys, or elevated privileges required.

- **Trivial Execution**: The exploit is as simple as modifying the `ExtraBlockProducerOfPreviousRound` field value when constructing the `NextRoundInput` in their consensus client before submitting the transaction.

- **No Validation Barriers**: The validation logic has a clear gap - no validator checks this field against the actual sender (`Context.RecoverPublicKey()`) or verifies it against previous round state.

- **Immediate Economic Benefit**: The attacker gains extra mining privileges in the very next round, providing immediate economic incentive with each round transition.

- **Low Detection Risk**: Since the field is accepted without validation, the manipulation appears as valid consensus data in the blockchain state, making it difficult to detect without specifically auditing for this issue.

## Recommendation

Add validation in `ValidationForNextRound()` to verify that the `ExtraBlockProducerOfPreviousRound` field matches the actual transaction sender:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Validate InValues are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate ExtraBlockProducerOfPreviousRound matches sender
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != validationContext.SenderPubkey)
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match the sender." };
    
    return new ValidationResult { Success = true };
}
```

This ensures that only the actual miner who produced the extra block can be recorded as the `ExtraBlockProducerOfPreviousRound`, preventing privilege manipulation.

## Proof of Concept

A malicious miner (Miner A) who is producing the NextRound block can:

1. Call `NextRound` with a `NextRoundInput` where `ExtraBlockProducerOfPreviousRound` is set to Miner B's pubkey (or any arbitrary miner)
2. The validation passes because `ValidationForNextRound()` doesn't check this field
3. The Round is stored with the manipulated `ExtraBlockProducerOfPreviousRound` value
4. In the next round, Miner B incorrectly receives:
   - Mining permission before round start time via `IsCurrentMiner()`
   - Additional tiny block quota via `GetConsensusBehaviour()`
5. This results in unauthorized mining privileges and economic rewards for Miner B

The vulnerability can be demonstrated by submitting a NextRound transaction with a modified `ExtraBlockProducerOfPreviousRound` field and observing that the validation accepts it, subsequently granting the specified miner unauthorized privileges in the following round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-178)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```
