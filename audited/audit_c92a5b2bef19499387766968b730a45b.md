# Audit Report

## Title
FixProfitDetail Allows Retroactive Profit Claims Through Unconstrained StartPeriod Modification

## Summary
The `FixProfitDetail` method in the Profit contract permits scheme managers to arbitrarily modify a beneficiary's `StartPeriod` to any historical value without validation. This enables beneficiaries to retroactively claim profits from periods before they were added to the scheme, violating the fundamental profit distribution invariant and diluting legitimate beneficiaries' shares.

## Finding Description

The vulnerability exists in the `FixProfitDetail` method which lacks validation on the `StartPeriod` value being set. [1](#0-0) 

When a beneficiary is legitimately added via `AddBeneficiary`, their `StartPeriod` is correctly initialized to `scheme.CurrentPeriod + DelayDistributePeriodCount`, ensuring they only receive profits from when they joined onwards: [2](#0-1) 

However, `FixProfitDetail` allows the manager to replace this value with any period through a simple conditional assignment at line 299, with only authorization checks but no validation that:
- The new `StartPeriod` >= original `StartPeriod`
- The new `StartPeriod` >= the period when the beneficiary was actually added
- The new `StartPeriod` is within valid scheme distribution periods

When `ClaimProfits` is called for the first time (when `LastProfitPeriod == 0`), it initializes `LastProfitPeriod` to the manipulated `StartPeriod`: [3](#0-2) 

The `ProfitAllPeriods` method then iterates from this manipulated starting period, calculating and transferring tokens from historical period virtual addresses: [4](#0-3) 

**Evidence of Design Intent:**

Test expectations explicitly verify that `StartPeriod` should remain unchanged after legitimate `FixProfitDetail` usage: [5](#0-4) 

The only production usage in the Election contract never modifies `StartPeriod` - it explicitly sets the input value to 0 to preserve the original, with a comment confirming this intent: [6](#0-5) 

## Impact Explanation

**Direct Fund Theft**: A malicious or compromised scheme manager can:
1. Add a beneficiary at period N with legitimate `StartPeriod = N`
2. Before the beneficiary claims, call `FixProfitDetail` to set `StartPeriod = 1`
3. The beneficiary claims and receives profits from periods 1 through N-1

**Share Dilution**: When a beneficiary claims retroactive profits using shares that didn't exist in those historical periods, they receive a portion calculated against the `TotalShares` from those earlier periods. This directly reduces the remaining tokens available for legitimate beneficiaries who were actually present during those periods.

**Governance Bypass**: For DAO-controlled schemes (Treasury, Election welfare schemes managed by Parliament), the manager can unilaterally redistribute historical profits without governance approval, bypassing intended control mechanisms.

**Value at Risk**: All historical accumulated profits in any scheme are vulnerable. For major schemes like Treasury citizen welfare distributions, this represents significant token amounts accumulated over many periods.

## Likelihood Explanation

**Attack Complexity**: Extremely simple - requires only a single `FixProfitDetail` transaction with a modified `StartPeriod` parameter.

**Attacker Capabilities**: Requires scheme manager access. However, the critical issue is that even legitimate managers have MORE power than the design intends:
- For DAO-managed schemes, this bypasses governance controls
- For any scheme, this violates the expected invariant that beneficiaries only receive profits from their participation period
- Compromised manager keys enable direct exploitation

**Feasibility Conditions**: 
- Scheme must have distributed profits in historical periods
- Beneficiary must not have claimed yet (common for newly added beneficiaries)
- Manager retains access
- No additional preconditions required

**Detection Difficulty**: The modification is a permanent state change. After claiming, profits are transferred and cannot be recovered. On-chain events show the claim but may not reveal the period manipulation.

## Recommendation

Add validation in `FixProfitDetail` to prevent retroactive `StartPeriod` modification:

```csharp
// After line 294, add validation:
if (input.StartPeriod != 0 && input.StartPeriod < fixingDetail.StartPeriod)
{
    throw new AssertionException($"Cannot set StartPeriod earlier than existing value. Current: {fixingDetail.StartPeriod}, Attempted: {input.StartPeriod}");
}
```

Additionally, consider whether `StartPeriod` modification should be allowed at all. The production usage pattern suggests `FixProfitDetail` is only intended to modify `EndPeriod`, not `StartPeriod`.

## Proof of Concept

```csharp
[Fact]
public async Task FixProfitDetail_AllowsRetroactiveClaims()
{
    // Setup: Create scheme and distribute profits in period 1
    var schemeId = await CreateScheme();
    await DistributeProfits(schemeId, period: 1, amount: 1000);
    
    // Move to period 5 and add beneficiary (should have StartPeriod = 5)
    await MoveToNextPeriod(); // periods 2-5
    var beneficiary = Address.FromPublicKey(SampleKeyPairs[1].PublicKey);
    await ProfitContractStub.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = 10 },
        EndPeriod = long.MaxValue
    });
    
    // Exploit: Manager modifies StartPeriod to 1 (before beneficiary was added)
    await ProfitContractStub.FixProfitDetail.SendAsync(new FixProfitDetailInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiary, Shares = 10 },
        StartPeriod = 1, // RETROACTIVE - beneficiary didn't exist in period 1
        EndPeriod = long.MaxValue
    });
    
    // Beneficiary claims and receives profits from period 1
    var balanceBefore = await GetBalance(beneficiary);
    await ProfitContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    var balanceAfter = await GetBalance(beneficiary);
    
    // Assertion: Beneficiary received profits from period 1 despite being added in period 5
    var claimedAmount = balanceAfter - balanceBefore;
    claimedAmount.ShouldBeGreaterThan(0); // Successfully claimed historical profits
}
```

## Notes

This is a **mis-scoped privilege vulnerability** where legitimate scheme managers possess capabilities beyond design intent. The `FixProfitDetail` method's purpose (based on production usage and test expectations) is to modify `EndPeriod` for extending participation periods, not to enable retroactive profit claims through `StartPeriod` manipulation. The lack of validation represents a fundamental design flaw that violates the profit distribution model's core invariant.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L780-784)
```csharp
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-895)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L830-832)
```csharp
        profitDetail.StartPeriod.ShouldBe(originProfitDetail.Details.First().StartPeriod);
        profitDetail.EndPeriod.ShouldBe(originProfitDetail.Details.First().EndPeriod
            .Add(currentPeriod.Value.Sub(originProfitDetail.Details.First().StartPeriod).Add(1)));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L143-154)
```csharp
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```
