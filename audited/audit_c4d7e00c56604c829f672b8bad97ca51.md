# Audit Report

## Title
Banned Candidates Can Become Miners Through Incomplete Duplicate Prevention in Snapshot Processing

## Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function in the Election Contract contains a flawed duplicate prevention check that fails to remove banned candidates when multiple banned pubkeys resolve to the same newest pubkey through replacement chains. This allows banned candidates to remain in election snapshots and subsequently be selected as alternative miners by the consensus contract, violating consensus security guarantees.

## Finding Description

The vulnerability exists in the snapshot processing logic where banned candidates are replaced with their newest pubkeys. When the Election Contract processes replacement chains (e.g., A→B→C), both A and B will resolve to C via `GetNewestPubkey`. However, the duplicate prevention check causes only the first banned candidate to be properly removed. [1](#0-0) 

When processing banned candidate A:
- `GetNewestPubkey(A)` returns C
- Check `snapshot.ElectionResult.ContainsKey(C)` returns false
- C is added with A's votes, A is removed

When processing banned candidate B:
- `GetNewestPubkey(B)` also returns C  
- Check `snapshot.ElectionResult.ContainsKey(C)` returns **true** (C was just added)
- Execution hits `continue` statement, **skipping the removal at line 157**
- B remains in the snapshot despite being banned

The replacement chain is established through `PerformReplacement` which maintains the mapping structure: [2](#0-1) 

Both old and new pubkeys in a replacement chain are marked as banned: [3](#0-2) 

The `GetNewestPubkey` helper correctly resolves any pubkey to its current replacement: [4](#0-3) 

However, `GetMinerReplacementInformation` does not filter banned pubkeys from the snapshot: [5](#0-4) 

The consensus contract then directly uses these alternative candidates without validating their banned status: [6](#0-5) 

## Impact Explanation

This vulnerability allows banned candidates—potentially marked as evil nodes—to become active miners and participate in block production. The impact is severe:

**Consensus Security Breach**: Candidates banned for malicious behavior (via `UpdateCandidateInformation` with `IsEvilNode=true`) can regain miner status and continue attacking the network.

**Reward Misallocation**: Banned candidates receive mining rewards they are not entitled to, diluting rewards for legitimate miners.

**Protocol Integrity**: Undermines the fundamental security mechanism designed to remove compromised or misbehaving nodes from the active miner set.

The banned status check exists and is correctly enforced elsewhere: [7](#0-6) 

But this protection is bypassed in the snapshot processing path, allowing banned candidates to slip through when they share a newest pubkey with another banned candidate.

## Likelihood Explanation

This vulnerability has **Medium** likelihood of occurrence:

**Attack Complexity**: Low. Replacement chains occur naturally during normal operations when candidates rotate keys for security or administrative purposes.

**Preconditions Required**:
1. Multiple candidates in the same replacement chain (common during key rotation)
2. A snapshot taken before replacements (happens automatically each term via `TakeSnapshot`)
3. Evil miner detection triggering replacement mechanism (part of normal consensus operation)

**Attacker Capabilities**: No special privileges required. Any candidate admin can call the public `ReplaceCandidatePubkey` method: [8](#0-7) 

**Economic Rationale**: Cost is minimal (standard transaction fees), while potential gains include mining rewards and ability to influence consensus decisions.

The vulnerability is particularly concerning because it can be triggered unintentionally through legitimate key rotation practices, meaning no malicious intent is required for the security breach to occur.

## Recommendation

Fix the duplicate prevention logic to ensure all banned candidates are removed from the snapshot, even when they share the same newest pubkey:

```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // If newest pubkey not exists or same as old pubkey (which is banned), skip replacement but still remove
    if (newestPubkey == null || newestPubkey == bannedCandidate)
    {
        if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) 
            snapshot.ElectionResult.Remove(bannedCandidate);
        continue;
    }
    
    // Only add the newest pubkey if it doesn't already exist
    if (!snapshot.ElectionResult.ContainsKey(newestPubkey))
    {
        var electionResult = snapshot.ElectionResult[bannedCandidate];
        snapshot.ElectionResult.Add(newestPubkey, electionResult);
    }
    
    // Always remove the banned candidate
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) 
        snapshot.ElectionResult.Remove(bannedCandidate);
}
```

Additionally, add a defensive check in `GetMinerReplacementInformation` to filter out banned pubkeys:

```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    .Where(cs => !State.InitialMiners.Value.Value.Contains(...))
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    .Where(cs => !IsPubkeyBanned(cs.Key))  // Add this check
    .OrderByDescending(s => s.Value).ToList();
```

## Proof of Concept

```csharp
// POC demonstrating the vulnerability
[Fact]
public async Task BannedCandidates_CanBecomeMiners_ThroughReplacementChain()
{
    // Setup: Create candidates A and B with votes
    var candidateA = "pubkeyA";
    var candidateB = "pubkeyB"; 
    var candidateC = "pubkeyC";
    
    // Take snapshot with A and B
    await ElectionContract.TakeSnapshot(termNumber: 1);
    
    // Create replacement chain: A→B→C
    await ElectionContract.ReplaceCandidatePubkey(new ReplaceCandidatePubkeyInput 
    { 
        OldPubkey = candidateA, 
        NewPubkey = candidateB 
    });
    
    await ElectionContract.ReplaceCandidatePubkey(new ReplaceCandidatePubkeyInput 
    { 
        OldPubkey = candidateB, 
        NewPubkey = candidateC 
    });
    
    // Verify A and B are banned
    Assert.True(await ElectionContract.IsPubkeyBanned(candidateA));
    Assert.True(await ElectionContract.IsPubkeyBanned(candidateB));
    
    // Get miner replacement information
    var replacementInfo = await ElectionContract.GetMinerReplacementInformation(
        new GetMinerReplacementInformationInput { CurrentMinerList = {...} }
    );
    
    // BUG: B should not be in alternative candidates but it is
    Assert.Contains(candidateB, replacementInfo.AlternativeCandidatePubkeys);
}
```

---

## Notes

This is a valid **Medium to High severity** vulnerability affecting the core consensus mechanism. The bug occurs at the intersection of three subsystems (Election, Consensus, and snapshot processing), making it subtle but dangerous. The fix requires changes to both the snapshot processing logic and defensive validation in the miner replacement flow.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```
