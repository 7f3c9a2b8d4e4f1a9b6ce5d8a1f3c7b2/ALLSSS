# Audit Report

## Title
Evil Miners Can Continue Operating When Valid Replacement Candidates Exist Due to Incomplete Alternative Candidate Search

## Summary
The `GetMinerReplacementInformation()` function in the Election contract only searches for alternative candidates in the previous term's election snapshot, completely ignoring currently valid candidates with active votes. During term 1 (blockchain bootstrap) or after terms with empty election results, evil miners continue operating even when legitimate voted candidates are available, violating consensus security guarantees.

## Finding Description

The vulnerability exists in the `GetMinerReplacementInformation()` method which is responsible for identifying replacement candidates when evil miners are detected during consensus operations.

**Root Cause:**

The function retrieves only the previous term's snapshot and conditionally populates alternative candidates: [1](#0-0) 

The critical flaw is that alternative candidates are ONLY populated if `latestSnapshot != null && latestSnapshot.ElectionResult.Any()`. When this condition fails, the function falls back exclusively to initial miners: [2](#0-1) 

**Why Current Candidates Are Ignored:**

The contract maintains current candidate state through `State.Candidates` and `State.CandidateVotes`: [3](#0-2) 

A helper function `GetValidCandidates()` exists that correctly queries these state variables to retrieve candidates with active votes: [4](#0-3) 

However, `GetMinerReplacementInformation()` never calls `GetValidCandidates()` and never queries current candidate state, relying solely on the previous term's snapshot.

**Execution Path:**

The consensus contract invokes this function during mid-term round generation when on the main chain within the same term: [5](#0-4) 

If alternative candidates are found, evil miners are replaced in the current round: [6](#0-5) 

If the returned `AlternativeCandidatePubkeys` list is empty, no replacement occurs and evil miners remain active.

**Critical Scenarios:**

1. **Term 1 (Blockchain Bootstrap):** The previous snapshot retrieval attempts to access term 0: [7](#0-6) 

Since term 0 never exists, the snapshot is null and no election candidates are considered for replacement, even if candidates have announced and received votes during term 1.

2. **After Empty Terms:** If a term completes with no election results, the snapshot's `ElectionResult` will be empty, triggering the same failure path.

**Security Invariant Violated:**

Evil miners (those marked in `BannedPubkeyMap`) are detected automatically: [8](#0-7) 

The protocol's security guarantee is that evil miners should be replaced when alternative candidates exist. This guarantee is broken when current valid candidates are ignored.

## Impact Explanation

**Consensus Integrity Compromise:**

Evil miners who should be replaced continue participating in block production with the following impacts:

- **Transaction Censorship:** Evil miners can refuse to include specific transactions, preventing legitimate operations
- **Block Withholding:** Can deliberately skip their mining slots, degrading network performance and reliability  
- **Undeserved Rewards:** Continue earning block production rewards despite malicious behavior
- **Centralization Risk:** Reduces effective validator set, increasing centralization and attack surface

**Voter Disenfranchisement:**

Token holders who voted for candidates during the current term have their votes effectively ignored. Candidates they supported who should be eligible for miner positions are never considered, undermining the election system's purpose.

**Network Security Degradation:**

The most critical impact occurs during term 1 (chain bootstrap), which is the most vulnerable period for a new blockchain. If initial miners become evil before term 2 begins, the network has no defense mechanism even when legitimate candidates are available.

## Likelihood Explanation

**High Probability for Term 1:**

- Term 1 scenario is **guaranteed** to occur during every blockchain bootstrap
- No term 0 snapshot exists by definition
- If any initial miner becomes evil in term 1, the vulnerability is triggered

**Attacker Requirements (Low Complexity):**

An attacker only needs to:
1. Become a miner (initially legitimate, or be an initial miner)
2. Exhibit malicious behavior that triggers evil node detection (miss mining time slots)
3. Time the attack when previous snapshot is null/empty

Evil detection is automatic and built into the consensus mechanism - miners missing time slots are automatically flagged without requiring governance action.

**Current Candidates Can Exist:**

Candidates can announce election at any time with no term restrictions, and voters can vote for them immediately. The contract state tracks these candidates in real-time through `State.Candidates` and `State.CandidateVotes`, making it entirely feasible for valid voted candidates to exist when the vulnerability is triggered.

**Natural Occurrence:**

This is not a complex attack requiring sophisticated manipulation - it occurs through natural consensus operations during the blockchain's most vulnerable early lifecycle phase.

## Recommendation

Modify `GetMinerReplacementInformation()` to also consider current valid candidates when the previous term's snapshot is unavailable or empty:

```csharp
public override MinerReplacementInformation GetMinerReplacementInformation(
    GetMinerReplacementInformationInput input)
{
    var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
    var alternativeCandidates = new List<string>();
    var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
    
    // Check previous term snapshot first
    if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
    {
        var maybeNextCandidates = latestSnapshot.ElectionResult
            .Where(cs => !State.InitialMiners.Value.Value.Contains(
                ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
            .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
            .OrderByDescending(s => s.Value).ToList();
        var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
        alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
    }
    
    // If still need more alternatives, check current valid candidates
    var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
    if (diff > 0)
    {
        var currentValidCandidates = GetValidCandidates()
            .Where(c => !State.InitialMiners.Value.Value.Contains(
                ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(c))))
            .Where(c => !input.CurrentMinerList.Contains(c))
            .Where(c => !State.BannedPubkeyMap[c])
            .OrderByDescending(c => State.CandidateVotes[c].ObtainedActiveVotedVotesAmount)
            .Take(diff);
        alternativeCandidates.AddRange(currentValidCandidates);
    }
    
    // Finally, if still need more, use initial miners
    diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
    if (diff > 0)
    {
        var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
        var selectedInitialMiners = State.InitialMiners.Value.Value
            .Select(k => k.ToHex())
            .Where(k => !State.BannedPubkeyMap[k])
            .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
        alternativeCandidates.AddRange(selectedInitialMiners);
    }

    return new MinerReplacementInformation
    {
        EvilMinerPubkeys = { evilMinersPubKeys },
        AlternativeCandidatePubkeys = { alternativeCandidates }
    };
}
```

This ensures that during term 1 and after empty terms, current valid candidates are properly considered as replacement options before falling back to initial miners.

## Proof of Concept

Due to the complexity of setting up a full consensus test environment, the vulnerability can be demonstrated by examining the code paths:

1. During term 1, `State.CurrentTermNumber.Value = 1`
2. `GetPreviousTermSnapshotWithNewestPubkey()` attempts `State.Snapshots[0]` which is null
3. Condition `latestSnapshot != null && latestSnapshot.ElectionResult.Any()` fails
4. `alternativeCandidates` remains empty from election results
5. Even if `State.Candidates` contains valid candidates with votes in `State.CandidateVotes`, they are never queried
6. Only initial miners can be used as replacements
7. If all initial miners are already mining or banned, evil miners continue operating

The existing test suite does not cover this scenario, as evidenced by the skipped evil node test: [9](#0-8) 

A complete test would require:
- Initializing blockchain in term 1
- Having candidates announce and receive votes
- Triggering evil miner detection
- Verifying that current valid candidates are not considered for replacement

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L130-134)
```csharp
    private TermSnapshot GetPreviousTermSnapshotWithNewestPubkey()
    {
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
        if (snapshot == null) return null;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-380)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L382-392)
```csharp
        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L21-27)
```csharp
    public MappedState<string, CandidateVote> CandidateVotes { get; set; }

    public MappedState<string, CandidateInformation> CandidateInformationMap { get; set; }

    public Int64State CurrentTermNumber { get; set; }

    public SingletonState<PubkeyList> Candidates { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-305)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** test/AElf.Contracts.Economic.AEDPoSExtension.Tests/EvilNodeRelatedTests.cs (L22-23)
```csharp
    [Fact(Skip = "Need fix.")]
    internal async Task MarkEvilNodeTest()
```
