# Audit Report

## Title
Legitimate Vote Target Changes Blocked by Missing Profit Details Due to Integer Division Rounding

## Summary
When voters attempt to change their voting target with `IsResetVotingTime = true`, the operation can fail for legitimate active votes due to missing profit details. This occurs because profit detail `EndPeriod` is calculated using integer division that rounds down, creating a timing gap where profit details can be removed via `ClaimProfits` before the vote lock expires, causing `ExtendVoterWelfareProfits` to throw an `AssertionException` and blocking the vote change operation.

## Finding Description

**Root Cause - Integer Division Rounding:**

The vulnerability originates in the `GetEndPeriod` calculation where `lockTime` (in seconds) is divided by `TimeEachTerm` (period duration in seconds) using integer division [1](#0-0) . When `lockTime` is not perfectly divisible by `TimeEachTerm`, the result rounds down. For example, a 30-day lock (2,592,000 seconds) with 7-day periods (604,800 seconds) results in `EndPeriod = currentPeriod + 4` (representing only 28 days), while the actual vote lock lasts the full 30 days.

**Profit Detail Removal:**

When `ClaimProfits` is called on the welfare scheme, it processes all claimable periods through `ProfitAllPeriods` [2](#0-1) , which updates `LastProfitPeriod` to `period + 1` after claiming each period [3](#0-2)  and persists this to the profit detail [4](#0-3) .

After claiming up to the `EndPeriod`, `LastProfitPeriod` becomes `EndPeriod + 1`. Subsequently, the profit detail is identified for removal because `LastProfitPeriod > EndPeriod` [5](#0-4) , and is then completely removed from the beneficiary's profit details list [6](#0-5) .

**Vote Change Failure:**

When a voter attempts to change their voting target, the function first validates that the vote hasn't expired [7](#0-6) . This check passes because the actual lock time (e.g., 30 days) hasn't elapsed yet, even though the profit detail's `EndPeriod` (representing only 28 days due to rounding) has passed.

If `IsResetVotingTime = true`, the function calls `ExtendVoterWelfareProfits` [8](#0-7) . This function attempts to locate the profit detail using `GetProfitDetailByElectionVotingRecord`, which tries two lookups - first by ID, then by Shares [9](#0-8) .

Since the profit detail was completely removed from the list, both lookups fail and the function returns `null`. This causes `ExtendVoterWelfareProfits` to throw an `AssertionException` [10](#0-9) , blocking the vote change operation even though the vote is legitimate and active.

## Impact Explanation

**Harm Occurrence:**
Voters are unable to change their voting targets when `IsResetVotingTime = true`, resulting in denial of service on a core election functionality. Users are forced to either:
1. Change targets without resetting voting time (`IsResetVotingTime = false`), losing the benefit of extended profit participation
2. Wait until the vote fully expires, then withdraw and create a new vote, incurring additional transaction costs and potentially missing voting opportunities

**Who is Affected:**
Any voter whose `lockTime` is not perfectly divisible by `TimeEachTerm` and who (or whose beneficiaries) claims profits after the rounded-down `EndPeriod` passes but before the actual vote lock expires. This affects a significant portion of users since:
- Common lock periods (30, 60, 90, 180 days) often don't align with the typical 7-day period duration [11](#0-10) 
- Profit claiming is routine user behavior to realize rewards
- The timing window exists in every such scenario (e.g., 2 days for 30-day locks, 4 days for 60-day locks)

**Protocol Damage:**
- **Operational Disruption**: Core voting functionality becomes unreliable during the timing gap
- **User Experience Degradation**: Legitimate operations fail with cryptic error messages
- **Reduced Flexibility**: Users cannot dynamically adjust their voting strategies during active lock periods
- **No Direct Fund Loss**: Tokens remain locked and recoverable after expiration

**Severity Justification:**
Medium severity is appropriate because:
- **Impact**: Operational denial of service affecting core functionality but no fund theft or permanent loss
- **Likelihood**: High - fractional periods are common in real-world usage with typical configurations
- **Scope**: Affects significant user population with realistic timing conditions

## Likelihood Explanation

**Attacker Capabilities:**
No attacker needed - this is a logic flaw affecting legitimate users. Any voter or third-party profit claimer can inadvertently trigger the condition through normal protocol usage.

**Attack Complexity:**
Minimal complexity:
1. User votes with non-perfectly-divisible lock time (common scenario)
2. Time elapses past the rounded-down `EndPeriod`
3. Anyone calls `ClaimProfits` on the welfare scheme (routine maintenance operation)
4. User attempts to change voting target with reset time
5. Operation fails with `AssertionException`

**Feasibility Conditions:**
Highly feasible and occurs naturally:
- **Fractional Periods**: Lock times like 30 days with 7-day periods create 2-day gaps; 60 days creates 4-day gaps; 90 days creates 6-day gaps
- **Profit Claiming**: Regular operation performed by users or automated systems to realize welfare rewards
- **Timing Window**: Exists from when `EndPeriod` passes until vote expiration (2-6 days in typical scenarios)
- **User Intent**: Legitimate users routinely change voting targets to optimize rewards based on candidate performance

**Probability Reasoning:**
High probability of occurrence:
- Integer division rounding affects the majority of lock time choices (any lock period not perfectly divisible by 7 days)
- Profit claiming happens regularly (weekly, monthly) for reward realization
- Vote changes are common as candidates' performance and rewards vary
- No special privileges or edge conditions required - occurs through normal protocol usage

## Recommendation

**Solution 1 - Use Ceiling Division for EndPeriod:**
Modify `GetEndPeriod` to use ceiling division instead of floor division, ensuring the profit detail `EndPeriod` covers the entire vote lock duration:

```csharp
private long GetEndPeriod(long lockTime)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var timeEachTerm = State.TimeEachTerm.Value;
    var periods = (lockTime + timeEachTerm - 1).Div(timeEachTerm); // Ceiling division
    return periods.Add(treasury.CurrentPeriod);
}
```

**Solution 2 - Handle Missing Profit Details Gracefully:**
Modify `ExtendVoterWelfareProfits` to recreate the profit detail if it's missing but the vote is still active:

```csharp
private void ExtendVoterWelfareProfits(Hash voteId)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);
    var lockTime = State.LockTimeMap[voteId];
    var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
    if (lockPeriod == 0)
    {
        return;
    }

    var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
    var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
    
    if (extendingDetail != null)
    {
        State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = electionVotingRecord.Voter,
                Shares = electionVotingRecord.Weight
            },
            EndPeriod = endPeriod,
            ProfitDetailId = voteId
        });
    }
    else
    {
        // Recreate profit detail if missing but vote is still active
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = electionVotingRecord.Voter,
                Shares = electionVotingRecord.Weight
            },
            EndPeriod = endPeriod,
            ProfitDetailId = voteId
        });
    }
}
```

**Recommended Approach:** Implement Solution 1 (ceiling division) as it prevents the root cause. This ensures profit details always cover the full vote lock duration, eliminating the timing gap entirely.

## Proof of Concept

```csharp
[Fact]
public async Task VoteChangeFailsAfterProfitDetailRemoval_IntegerDivisionGap()
{
    // Setup: Initialize contracts and create candidate
    const long voteAmount = 100_00000000;
    const int lockDays = 30; // 30 days
    const int periodDays = 7; // 7-day periods (typical TimeEachTerm)
    
    var candidateKeyPair = ValidationDataCenterKeyPairs.First();
    var voterKeyPair = VoterKeyPairs.First();
    
    await AnnounceElectionAsync(candidateKeyPair);
    
    // Step 1: Vote with 30-day lock (not divisible by 7-day periods)
    var voteId = await VoteToCandidate(voterKeyPair, candidateKeyPair.PublicKey.ToHex(), 
        lockDays * 86400, voteAmount);
    
    // Verify: EndPeriod = currentPeriod + (30*86400 / 7*86400) = currentPeriod + 4
    // This represents only 28 days, leaving a 2-day gap
    var profitDetail = await GetProfitDetail(voterKeyPair.PublicKey.ToHex(), voteId);
    var expectedPeriods = (lockDays * 86400) / (periodDays * 86400); // = 4 (floor division)
    profitDetail.EndPeriod.ShouldBe(profitDetail.StartPeriod + expectedPeriods);
    
    // Step 2: Advance time past EndPeriod (28 days) but before vote expiry (30 days)
    await ProduceBlocks(voterKeyPair, (periodDays * expectedPeriods) * 86400 / 4 + 1000);
    
    // Step 3: Claim profits - this will remove the profit detail
    await ClaimProfits(voterKeyPair.PublicKey.ToHex());
    
    // Verify: Profit detail has been removed
    profitDetail = await GetProfitDetail(voterKeyPair.PublicKey.ToHex(), voteId);
    profitDetail.ShouldBeNull();
    
    // Step 4: Attempt to change vote with IsResetVotingTime = true
    // This should fail with "Cannot find profit detail" even though vote is still active
    var newCandidateKeyPair = ValidationDataCenterKeyPairs[1];
    await AnnounceElectionAsync(newCandidateKeyPair);
    
    var result = await ElectionContractStub.ChangeVotingOption.SendWithExceptionAsync(
        new ChangeVotingOptionInput
        {
            VoteId = voteId,
            CandidatePubkey = newCandidateKeyPair.PublicKey.ToHex(),
            IsResetVotingTime = true
        });
    
    // Assert: Transaction fails with AssertionException
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Cannot find profit detail of given vote id");
}
```

## Notes

This vulnerability demonstrates a critical timing mismatch between two different calculations of the same conceptual duration:
1. The actual vote lock time (used for vote expiry validation)
2. The profit detail `EndPeriod` (calculated using integer division)

The integer division in `GetEndPeriod` [12](#0-11)  creates a systematic underestimation of the profit participation period whenever the lock time is not perfectly divisible by the period duration. Combined with the profit detail removal logic in `ClaimProfits` [13](#0-12) , this creates a guaranteed window of failure for legitimate vote change operations.

The issue is particularly impactful because:
- It affects common lock periods (30, 60, 90, 180 days) with typical 7-day period configurations
- It blocks a core governance feature (`ChangeVotingOption` with profit extension)
- Users have no way to work around it during the timing gap
- The error message is cryptic and doesn't indicate the root cause

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L29-31)
```csharp
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-37)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L156-159)
```csharp
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L612-616)
```csharp
    private long GetEndPeriod(long lockTime)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        return lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod);
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L784-785)
```csharp
            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-806)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
        foreach (var delayToPeriod in scheme.CachedDelayTotalShares.Keys)
        {
            scheme.CachedDelayTotalShares[delayToPeriod] =
                scheme.CachedDelayTotalShares[delayToPeriod].Sub(sharesToRemove);
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;

        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```

**File:** protobuf/election_contract.proto (L254-255)
```text
    // The number of seconds per term.
    int64 time_each_term = 4;
```
