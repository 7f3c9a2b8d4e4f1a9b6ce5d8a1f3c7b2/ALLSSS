### Title
Profit Receiver Mapping Premature Removal Causes Incorrect Reward Share Calculations

### Summary
The `ReplaceCandidateProfitsReceiver` function removes the old pubkey's profit receiver mapping immediately upon replacement, before the next term's distribution can properly clean up beneficiaries from the BasicReward profit scheme. This causes beneficiary removal to fail, leaving stale beneficiaries with inflated TotalShares, resulting in incorrect reward distribution calculations for all miners.

### Finding Description

The vulnerability exists in the interaction between three key functions:

**Root Cause:** [1](#0-0) 

When `ReplaceCandidateProfitsReceiver` is called during a candidate replacement, line 636 removes `State.ProfitsReceiverMap[input.OldPubkey]` immediately. However, this mapping is still needed for the next term's reward distribution cycle to properly remove the old beneficiary from the BasicReward profit scheme.

**Failed Cleanup Process:**

During the next term's distribution, `UpdateBasicMinerRewardWeights` attempts to remove beneficiaries from the previous term: [2](#0-1) 

This removal uses `GetAddressesFromCandidatePubkeys`, which calls `GetProfitsReceiver` for each pubkey: [3](#0-2) 

Since `GetProfitsReceiver` returns a fallback address when the mapping is missing: [4](#0-3) 

The removal attempts to remove the wrong address (default address from pubkey instead of the custom receiver address that was actually added as a beneficiary).

**Why Protections Fail:**

The Profit contract's `RemoveBeneficiary` silently fails when the beneficiary address is not found: [5](#0-4) 

When `currentDetail` is null (wrong address lookup), it returns empty without decrementing TotalShares: [6](#0-5) 

Furthermore, BasicReward scheme does NOT have `CanRemoveBeneficiaryDirectly` enabled: [7](#0-6) 

BasicReward is scheme index 4, which does not appear in the list `{2, 5, 6}` at line 66, meaning exact address matching is required for removal.

### Impact Explanation

**Direct Harm:**
- The custom profit receiver's beneficiary entry remains in the BasicReward scheme with its shares counted in TotalShares
- All subsequent reward distributions calculate incorrect share proportions, as the denominator (TotalShares) is artificially inflated by unreachable beneficiary shares
- Every active miner receives proportionally less rewards than they should

**Quantified Impact:**
If a miner with custom receiver has X shares and is not properly removed:
- TotalShares remains inflated by X shares
- All other miners' rewards are diluted by factor of `(TotalShares - X) / TotalShares`
- This persists until either: (a) the stale beneficiary claims their past rewards triggering cleanup, or (b) indefinitely if never claimed

**Affected Parties:**
- All active miners in the BasicReward scheme receive reduced rewards
- The effect compounds with multiple failed removals from multiple replacements
- Protocol's economic invariant of accurate reward distribution is violated

**Severity Justification:**
This is a Medium severity issue because:
1. It causes direct fund misallocation (miners receive less than entitled)
2. The impact is persistent across multiple terms
3. It affects the core reward distribution mechanism
4. No single party benefits (rewards are locked in unreachable beneficiary)

### Likelihood Explanation

**Entry Point:**
The vulnerability is triggered through the Election contract's `ReplaceCandidatePubkey` function: [8](#0-7) 

Which calls `ReplaceCandidateProfitsReceiver` at line 248, subsequently invoking the Treasury contract method.

**Preconditions:**
1. A candidate must have set a custom profit receiver via `SetProfitsReceiver`: [9](#0-8) 

2. The candidate must be actively mining (earning BasicReward)
3. The candidate's pubkey is replaced via `ReplaceCandidatePubkey`

**Attack Complexity:**
This is not an attack but a natural operational scenario:
- Candidates commonly set custom profit receivers for treasury management
- Node operators regularly replace pubkeys for security reasons (key rotation)
- The issue triggers automatically without malicious intent

**Feasibility:**
- All required functions are publicly accessible with proper authorization
- The scenario occurs during normal protocol operations
- Test evidence shows replacement with custom receivers is a supported use case: [10](#0-9) 

**Probability:**
HIGH - This will occur every time a miner with a custom profit receiver is replaced, which is a routine operational event.

### Recommendation

**Fix 1: Delay Mapping Removal**
Store the old mapping temporarily until the next distribution cycle completes:

```csharp
public override Empty ReplaceCandidateProfitsReceiver(ReplaceCandidateProfitsReceiverInput input)
{
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
        "No permission");
    var profitReceiver = State.ProfitsReceiverMap[input.OldPubkey];
    // Store old mapping for cleanup instead of immediate removal
    State.PendingRemovalReceiverMap[input.OldPubkey] = new PendingRemoval {
        Receiver = profitReceiver,
        RemovalTerm = GetCurrentTermNumber().Add(2) // Remove after next distribution
    };
    State.ProfitsReceiverMap[input.NewPubkey] = profitReceiver;
    return new Empty();
}
```

Then clean up expired entries during `UpdateBasicMinerRewardWeights`.

**Fix 2: Store Beneficiary Address Explicitly**
When adding beneficiaries, store the actual address used:
```csharp
State.BeneficiaryAddressMap[termNumber][pubkey] = GetProfitsReceiver(pubkey);
```

Then use this stored address for removal instead of recalculating it.

**Fix 3: Use Sub-Scheme Approach**
Leverage the existing `CanRemoveBeneficiaryDirectly` mechanism for BasicReward scheme, though this may have broader implications for the reward distribution design.

**Test Cases:**
1. Set custom profit receiver for candidate A
2. Candidate A mines for term T (earns BasicReward)
3. Replace A with B during term T+1
4. Complete term T+1 distribution
5. Verify TotalShares in BasicReward scheme is correct
6. Verify all miners receive correct reward proportions

### Proof of Concept

**Initial State:**
- Candidate with pubkey "A" announces election
- Admin sets custom profit receiver: `SetProfitsReceiver(pubkey="A", receiver=AddressX)`
- `State.ProfitsReceiverMap["A"] = AddressX`

**Term T Execution:**
1. A becomes a miner and produces blocks
2. At end of term T (during term T+1 start):
   - `Release()` → `UpdateBasicMinerRewardWeights()` called
   - `AddBeneficiaries` adds AddressX with shares based on A's performance
   - BasicReward scheme: `TotalShares = N`, includes AddressX with X shares

**Replacement During Term T+1:**
3. Admin calls `ReplaceCandidatePubkey(oldPubkey="A", newPubkey="B")`
4. Election contract calls `Treasury.ReplaceCandidateProfitsReceiver("A", "B")`
5. Line 636 executes: `State.ProfitsReceiverMap.Remove("A")` 
6. Mapping for "A" is NOW DELETED
7. `State.ProfitsReceiverMap["B"] = AddressX`

**Term T+1 Distribution (Start of Term T+2):**
8. `Release()` → `UpdateBasicMinerRewardWeights([term T, term T+1])`
9. Line 780: `RemoveBeneficiaries` called with miners from term T (includes "A")
10. `GetAddressesFromCandidatePubkeys(["A", ...])` called
11. `GetProfitsReceiver("A")` called but mapping is GONE
12. Returns `Address.FromPublicKey("A")` (wrong address, not AddressX)
13. Profit contract's `RemoveBeneficiary(beneficiary=AddressFromPubkey("A"))` called
14. Line 233: Looks up `State.ProfitDetailsMap[BasicRewardHash][AddressFromPubkey("A")]`
15. Returns null (actual beneficiary is AddressX, not AddressFromPubkey("A"))
16. Line 235: Returns empty, no shares removed
17. Line 260: `TotalShares.Sub(0)` → TotalShares unchanged

**Expected vs Actual:**
- **Expected:** TotalShares decremented by X, AddressX removed
- **Actual:** TotalShares remains N, AddressX still in scheme with X shares
- **Result:** All term T+1 and future distributions use inflated TotalShares, diluting all miners' rewards

**Success Condition:**
Query `GetScheme(BasicRewardHash).TotalShares` before and after the replacement-distribution cycle. If TotalShares doesn't decrease by the removed miner's shares, the vulnerability is confirmed.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L56-68)
```csharp
        for (var i = 0; i < 7; i++)
        {
            var index = i;
            Context.LogDebug(() => profitItemNameList[index]);
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-629)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L631-639)
```csharp
    public override Empty ReplaceCandidateProfitsReceiver(ReplaceCandidateProfitsReceiverInput input)
    {
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            "No permission");
        var profitReceiver = State.ProfitsReceiverMap[input.OldPubkey];
        State.ProfitsReceiverMap.Remove(input.OldPubkey);
        State.ProfitsReceiverMap[input.NewPubkey] = profitReceiver;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-787)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-260)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-257)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }

        var rankingList = State.DataCentersRankingList.Value;
        //the profit receiver is not exist but candidate in the data center ranking list
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }

        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }

        //     For CandidateVotes and CandidateInformation, just replace value of origin pubkey.
        var candidateVotes = State.CandidateVotes[input.OldPubkey];
        if (candidateVotes != null)
        {
            candidateVotes.Pubkey = newPubkeyBytes;
            State.CandidateVotes[input.NewPubkey] = candidateVotes;
            State.CandidateVotes.Remove(input.OldPubkey);
        }

        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
        }

        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;

        ReplaceCandidateProfitsReceiver(input.OldPubkey, input.NewPubkey);
        
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Election.Tests/Full/BackupSubsidyTests.cs (L273-340)
```csharp
    public async Task SetProfitsReceiver_ReplaceCandidatePubkey_Check_BackupSubsidy()
    {
        var announceElectionKeyPair = ValidationDataCenterKeyPairs.First();
        var candidateAdmin = ValidationDataCenterKeyPairs.Last();
        var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
        var profitReceiver = ValidationDataCenterKeyPairs.Skip(2).First();

        var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
        await AnnounceElectionAsync(announceElectionKeyPair, candidateAdminAddress);

        {
            var candidateAdminStub =
                GetTester<TreasuryContractImplContainer.TreasuryContractImplStub>(TreasuryContractAddress,
                    candidateAdmin);
            await candidateAdminStub.SetProfitsReceiver.SendAsync(
                new Treasury.SetProfitsReceiverInput
                {
                    Pubkey = announceElectionKeyPair.PublicKey.ToHex(),
                    ProfitsReceiverAddress = Address.FromPublicKey(profitReceiver.PublicKey)
                });
            var getProfitReceiver = await GetProfitReceiver(announceElectionKeyPair.PublicKey.ToHex());
            getProfitReceiver.ShouldBe(Address.FromPublicKey(profitReceiver.PublicKey));
            // Check backup subsidy
            var profitReceiverBackShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(profitReceiver.PublicKey));
            profitReceiverBackShare.Details.Count.ShouldBe(1);
            profitReceiverBackShare.Details.First().Shares.ShouldBe(1);
            profitReceiverBackShare.Details.First().IsWeightRemoved.ShouldBeFalse();

            var oldCandidateShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(announceElectionKeyPair.PublicKey));
            oldCandidateShare.Details.Count.ShouldBe(1);
            oldCandidateShare.Details.First().Shares.ShouldBe(1);
            oldCandidateShare.Details.First().IsWeightRemoved.ShouldBeTrue();
        }
        // ReplaceCandidatePubkey
        {
            var candidateAdminStub =
                GetTester<ElectionContractImplContainer.ElectionContractImplStub>(ElectionContractAddress,
                    candidateAdmin);
            await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
            {
                OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
                NewPubkey = newKeyPair.PublicKey.ToHex()
            });
        }
        // Check profit receiver and profit details
        {
            var getProfitReceiver = await GetProfitReceiver(newKeyPair.PublicKey.ToHex());
            getProfitReceiver.ShouldBe(Address.FromPublicKey(profitReceiver.PublicKey));

            var oldCandidateShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(announceElectionKeyPair.PublicKey));
            oldCandidateShare.Details.Count.ShouldBe(1);
            oldCandidateShare.Details.First().Shares.ShouldBe(1);
            oldCandidateShare.Details.First().IsWeightRemoved.ShouldBeTrue();

            var newCandidateShare = await GetBackupSubsidyProfitDetails(Address.FromPublicKey(newKeyPair.PublicKey));
            newCandidateShare.ShouldBe(new ProfitDetails());
            
            var profitReceiverBackShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(profitReceiver.PublicKey));
            profitReceiverBackShare.Details.Count.ShouldBe(2);
            profitReceiverBackShare.Details.First().IsWeightRemoved.ShouldBeTrue();
            profitReceiverBackShare.Details.Last().IsWeightRemoved.ShouldBeFalse();
            profitReceiverBackShare.Details.First().Id.ShouldNotBe(profitReceiverBackShare.Details.Last().Id);
        }
    }
```
