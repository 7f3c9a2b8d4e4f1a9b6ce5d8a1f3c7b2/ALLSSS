### Title
Method Fee Controller Validation Bypass via Fake Contract Implementation

### Summary
The `CheckOrganizationExist` validation in `ChangeMethodFeeController` can be bypassed by providing a malicious contract address that implements a fake `ValidateOrganizationExist` method returning true. This allows setting an arbitrary address as the method fee controller without proper governance organization validation, breaking the intended defense-in-depth protection.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` method which validates new method fee controller authority: [1](#0-0) 

The method calls `ValidateOrganizationExist` on an arbitrary contract address using a string method name obtained via `nameof()`. There is **no verification** that the provided `ContractAddress` is actually a legitimate governance contract (Parliament, Association, or Referendum). [2](#0-1) 

An attacker can deploy a malicious contract with a method signature matching `ValidateOrganizationExist(Address) returns (BoolValue)` that always returns true, then propose changing the controller to reference this fake contract. The legitimate governance contracts implement this method by checking state storage: [3](#0-2) 

But no validation exists to ensure the called contract is one of these legitimate governance contracts. The same vulnerable pattern appears in the Genesis contract: [4](#0-3) 

And is used in critical controller changes: [5](#0-4) 

### Impact Explanation

This vulnerability allows bypassing the organization existence validation, enabling:

1. **Governance Model Violation**: Setting a non-governance address (even an EOA) as the controller's `OwnerAddress`, completely bypassing the multi-signature/voting governance model
2. **Future Governance Compromise**: The fake controller can change method fees without legitimate governance approval, affecting transaction costs across the entire token system
3. **Defense-in-Depth Failure**: The check exists specifically to prevent invalid controllers even if proposals are maliciously crafted; this bypass removes that safety layer
4. **Wide Impact**: Affects multiple critical contracts (MultiToken, Genesis) managing method fees, contract deployment, and code checking permissions

The severity is critical because method fee control impacts all token operations, and contract deployment control affects the entire smart contract ecosystem security.

### Likelihood Explanation

**Reachable Entry Point**: The `ChangeMethodFeeController` method is publicly callable through governance proposals [2](#0-1) 

**Attacker Capabilities Required**:
1. Deploy a malicious contract with `ValidateOrganizationExist` returning true (trivial, no special permissions needed)
2. Create and get approved a governance proposal to call `ChangeMethodFeeController` with malicious `AuthorityInfo`

**Execution Practicality**: While requiring governance proposal approval, this is exactly the scenario the validation check is meant to defend against. The check provides defense-in-depth to ensure that even malicious/buggy proposals cannot set invalid controllers. Tests demonstrate the intended protection: [6](#0-5) 

**Feasibility**: High - the bypass is trivial (single fake method), and governance compromise or proposal bugs could enable exploitation. The validation's purpose is to prevent exactly this scenario.

### Recommendation

**Immediate Fix**: Validate that `ContractAddress` is one of the three legitimate governance contracts before calling `ValidateOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(
        SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(
        SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(
        SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Contract address must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply Fix To**: All contracts using this pattern:
- `TokenContract_ACS1_MethodFeeProvider.cs`
- `BasicContractZero_Helper.cs` (used in contract deployment/code check controllers)
- All other ACS1 implementations

**Test Cases**: Add tests verifying that providing a non-governance contract address is rejected with appropriate error message.

### Proof of Concept

**Step 1 - Initial State**:
- MultiToken contract has legitimate Parliament organization as method fee controller
- Current controller: `{ContractAddress: ParliamentContract, OwnerAddress: DefaultOrg}`

**Step 2 - Deploy Malicious Contract**:
```csharp
public class FakeGovernanceContract : SmartContract
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

**Step 3 - Create Malicious Proposal**:
Create proposal to call `ChangeMethodFeeController` with:
```
AuthorityInfo {
    ContractAddress = FakeGovernanceContract.Address,
    OwnerAddress = AttackerControlledAddress
}
```

**Step 4 - Governance Approves** (simulating compromised/buggy governance)

**Step 5 - Release Proposal**:
- Sender = legitimate organization (passes line 27 check)
- `CheckOrganizationExist` calls `FakeGovernanceContract.ValidateOrganizationExist(AttackerControlledAddress)`
- Returns true (passes line 28 check)
- New controller set to attacker-controlled addresses

**Expected Result**: Transaction should fail with "Invalid authority input"  
**Actual Result**: Transaction succeeds, method fee controller set to non-governance address

**Success Condition**: `GetMethodFeeController()` returns `AuthorityInfo` with fake contract address, allowing future method fee changes without legitimate governance approval.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ACS1_ImplementTest.cs (L91-100)
```csharp
    public async Task ChangeMethodFeeController_With_Invalid_Organization_Test()
    {
        var releaseResult = await ExecuteProposalForParliamentTransactionWithException(
            TokenConverterContractAddress, nameof(DefaultStub.ChangeMethodFeeController), new AuthorityInfo
            {
                OwnerAddress = DefaultSender,
                ContractAddress = ParliamentContractAddress
            });
        releaseResult.Error.ShouldContain("Invalid authority input");
    }
```
