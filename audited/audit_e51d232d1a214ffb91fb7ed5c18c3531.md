# Audit Report

## Title
Front-Running Attack on ProposeNewContract Enables Contract Deployment Denial-of-Service

## Summary
An attacker can front-run legitimate contract deployment proposals by predicting the deterministic `proposedContractInputHash` and submitting the proposal first. This blocks the legitimate deployer for up to 72 hours (default expiration period) since only the original proposer can release an approved contract, and duplicate proposals are rejected.

## Finding Description

The vulnerability exists in the Genesis contract's `ProposeNewContract` workflow through a combination of design flaws:

**1. Missing Authorization Check**

The proposer authority validation is commented out, allowing anyone to call `ProposeNewContract`: [1](#0-0) 

**2. Deterministic Hash Calculation**

The `proposedContractInputHash` is computed deterministically from the `ContractDeploymentInput` using `HashHelper.ComputeFrom(input)`, making it predictable for public/standard contracts: [2](#0-1) 

**3. Duplicate Proposal Prevention Without Authorization**

The `RegisterContractProposingData` function prevents duplicate proposals but doesn't validate if the caller is authorized. It simply rejects any proposal with the same hash that hasn't expired: [3](#0-2) 

**4. Proposer-Locked Release Mechanism**

Only the original proposer can call `ReleaseApprovedContract` to advance the proposal, giving exclusive control to whoever submitted first: [4](#0-3) 

**5. Long Expiration Period**

The default expiration is 259,200 seconds (72 hours), providing a substantial DoS window: [5](#0-4) 

**Attack Flow:**

1. Attacker monitors mempool or predicts contract deployment (e.g., standard token contract)
2. Attacker computes the same `proposedContractInputHash` and calls `ProposeNewContract` first
3. Legitimate deployer's transaction reverts with "Already proposed."
4. Even if the deployment controller approves the proposal, only the attacker can call `ReleaseApprovedContract`
5. If the attacker abandons the proposal, the deployment is blocked for 72 hours

The test suite confirms this behavior - attempting to propose the same contract twice fails with "Already proposed" and a different sender cannot release the contract: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This vulnerability enables **denial-of-service attacks on critical contract deployment operations**:

- **Operational Impact**: Legitimate contract deployments are blocked for 72 hours per attack iteration
- **Business Disruption**: Protocol launches, upgrades, and time-sensitive deployments can be significantly delayed
- **Griefing Potential**: Competitors can strategically delay rival protocol deployments
- **No Direct Fund Loss**: While no funds are stolen, the operational impact is significant

The attack is most effective against:
- Public/standard contract implementations (ERC20-like tokens)
- Open-source protocols with known deployment parameters
- Projects with announced deployment schedules

**Mitigation Factor**: The optional `ContractOperation` field with signature verification can prevent this attack, but it is not enforced and may not be used for all deployments.

## Likelihood Explanation

**Likelihood: Medium-High (for public contracts without ContractOperation)**

The attack is highly feasible due to:

1. **Low Technical Barrier**: 
   - Single transaction execution
   - Standard front-running techniques
   - No complex state manipulation required

2. **Attacker Capabilities**:
   - Mempool monitoring (standard blockchain capability)
   - Hash computation from public parameters
   - Minimal gas cost (only transaction fees)

3. **Realistic Preconditions**:
   - Target contract bytecode is known (public/standard contracts)
   - Deployment does NOT use `ContractOperation` with signature
   - Attacker has mempool visibility or advance knowledge

4. **No Effective Countermeasures**:
   - No on-chain cancellation mechanism
   - No cleanup for expired proposals
   - Legitimate deployer must wait full 72-hour period

The probability is **Medium-High** for deployments without `ContractOperation` signatures and **Low** for those using proper signature verification.

## Recommendation

**Short-term Fix: Uncomment and Properly Implement Authorization**

Restore the commented-out authorization check in `ProposeNewContract` to validate proposer authority:

```csharp
public override Hash ProposeNewContract(ContractDeploymentInput input)
{
    AssertDeploymentProposerAuthority(Context.Sender); // RESTORE THIS CHECK
    var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
    // ... rest of the function
}
```

**Long-term Improvements:**

1. **Enforce ContractOperation for Non-System Contracts**: Require signature verification via `ContractOperation` for all non-system contract deployments to prevent hash collision attacks

2. **Add Proposal Cancellation Mechanism**: Allow the deployment controller to cancel malicious proposals before expiration

3. **Implement Cleanup Function**: Add a method to remove expired proposal data, similar to Parliament/Association contracts

4. **Reduce Default Expiration**: Consider reducing the 72-hour default to a more reasonable timeframe (e.g., 24 hours) to minimize DoS windows

5. **Add Proposer Whitelisting**: Implement a proposer whitelist for contract deployments on production chains, similar to the Parliament contract's proposer authority

## Proof of Concept

```csharp
[Fact]
public async Task FrontRunning_ProposeNewContract_DoS_Attack()
{
    // Prepare legitimate contract deployment input
    var contractDeploymentInput = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
    };
    
    // ATTACKER: Front-runs the proposal
    var attackerProposalResult = await AttackerTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract), 
        contractDeploymentInput);
    attackerProposalResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // VICTIM: Attempts to propose the same contract
    var victimProposalResult = await VictimTester.ExecuteContractWithMiningAsync(
        BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract), 
        contractDeploymentInput);
    
    // VERIFY: Victim's transaction fails with "Already proposed"
    victimProposalResult.Status.ShouldBe(TransactionResultStatus.Failed);
    victimProposalResult.Error.ShouldContain("Already proposed.");
    
    // VERIFY: Deployment is blocked for 72 hours unless attacker releases it
    // Even after approval, only attacker can call ReleaseApprovedContract
}
```

**Notes:**
- This vulnerability is confirmed by existing test cases that validate the "Already proposed" error and proposer-restricted release mechanism
- The commented-out authorization check indicates this may have been a deliberate design decision for permissionless deployments, but it creates a griefing vector
- The optional `ContractOperation` field provides protection but is not enforced, leaving deployments vulnerable when not used
- The same vulnerability pattern exists in `ProposeUpdateContract` for contract updates

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-128)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L277-290)
```csharp
    public override Empty ReleaseApprovedContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.Proposed &&
            contractProposingInput.Proposer == Context.Sender, "Invalid contract proposing status.");
        contractProposingInput.Status = ContractProposingInputStatus.Approved;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
            input.ProposalId.ToByteString());
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L175-178)
```csharp
    private Hash CalculateHashFromInput(IMessage input)
    {
        return HashHelper.ComputeFrom(input);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L137-152)
```csharp
        {
            // wrong sender
            var releaseApprovedContractWithWrongSenderTx = await Tester.GenerateTransactionAsync(
                BasicContractZeroAddress,
                nameof(BasicContractZero.ReleaseApprovedContract), AnotherMinerKeyPair, new ReleaseContractInput
                {
                    ProposalId = proposalId,
                    ProposedContractInputHash = proposedContractInputHash
                });
            var blockReturnSet = await Tester.MineAsync(new List<Transaction>
                { releaseApprovedContractWithWrongSenderTx });
            var noPermissionProposingTxResult =
                blockReturnSet.TransactionResultMap[releaseApprovedContractWithWrongSenderTx.GetHash()];
            noPermissionProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            noPermissionProposingTxResult.Error.ShouldContain("Invalid contract proposing status.");
        }
```
