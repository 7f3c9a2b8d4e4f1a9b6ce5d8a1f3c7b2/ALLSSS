### Title
Authorization Bypass Allows Any Contract to Permanently Lock User Tokens Without Approval

### Summary
The `Lock()` function contains an authorization mismatch where the access control check uses `Context.Origin` while the virtual address computation uses `Context.Sender`. This allows any malicious contract to lock a user's tokens into a virtual address controlled by that contract whenever the user initiates a transaction, effectively enabling token theft without requiring approval. [1](#0-0) 

### Finding Description

The vulnerability exists in the `Lock()` function where two critical operations use different address sources:

**Authorization Check:** The function validates that either the caller is in a whitelist OR the transaction origin equals the target address. [1](#0-0) 

**Virtual Address Computation:** The virtual address that holds locked tokens is computed using `Context.Sender` (the immediate caller), not `Context.Origin`. [2](#0-1) 

The whitelist check only permits Election and Vote contracts: [3](#0-2) 

**Exploitation Path:**
1. User calls MaliciousContract for any reason
2. MaliciousContract calls `TokenContract.Lock(address=User, ...)`
3. Authorization passes because `Context.Origin` (User) == `input.Address` (User)
4. Tokens are transferred to virtual address: `Hash(MaliciousContract || User || lockId)`
5. To unlock, `Context.Sender` must be MaliciousContract (same computation in `Unlock()`): [4](#0-3) 

6. User cannot unlock directly—their `Context.Sender` would be User, not MaliciousContract

**Why Existing Protections Fail:**
The allowance mechanism only deducts if allowance exists but does NOT require it when `Context.Origin == input.Address`: [5](#0-4) 

The `DoTransfer` function performs the transfer without additional authorization checks beyond balance verification: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- Any contract a user interacts with can permanently lock ALL of the user's tokens of any symbol
- Locked tokens become irrecoverable if the malicious contract refuses to unlock them
- No limit on the amount that can be locked (subject only to user's balance)

**Affected Users:**
- Any user who calls a contract (malicious or compromised) that exploits this vulnerability
- Users have no indication that calling a contract grants it permission to lock their tokens

**Severity Justification:**
- HIGH severity: Enables direct token theft without requiring approval
- Users expect contracts need explicit approval via `Approve()` to access their tokens
- The attack surface includes ANY contract interaction, not just token-specific operations

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker deploys a malicious contract (low cost)
- Contract can offer legitimate functionality while silently locking user tokens
- Social engineering or wrapping existing functionality makes user interaction realistic

**Attack Complexity:**
- Simple: Single contract deployment, standard function call pattern
- No special timing, state conditions, or oracle manipulation required
- Example implementation: [7](#0-6) 

**Feasibility Conditions:**
- User must call the attacker's contract (via direct call or through aggregator/router patterns)
- No additional approvals or permissions needed
- Works with any token symbol

**Detection Constraints:**
- The test suite validates this behavior as working correctly, not as a vulnerability: [8](#0-7) 
- Existing tests don't validate the security implications of contracts locking user tokens

**Probability:** HIGH - Contract interactions are common, and users cannot easily audit every contract they interact with.

### Recommendation

**Immediate Fix:**
Require explicit allowance when a contract (non-whitelisted address) attempts to lock tokens on behalf of another address. Modify the authorization logic:

```csharp
// At line 201, change to:
if (!IsInLockWhiteList(Context.Sender))
{
    Assert(Context.Origin == input.Address, 
        "Lock behaviour should be initialed by origin address.");
    
    // ADDED: Require and deduct allowance for non-whitelisted contracts
    var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
    Assert(allowance >= input.Amount, 
        "Insufficient allowance for lock operation.");
    State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
}
```

Remove the conditional allowance deduction at lines 204-206 since it's now mandatory above.

**Alternative Fix:**
Change virtual address computation to use `Context.Origin` instead of `Context.Sender` when `Context.Origin == input.Address`, ensuring consistency:

```csharp
// At line 208-210, change to:
var addressForVirtual = IsInLockWhiteList(Context.Sender) 
    ? Context.Sender 
    : Context.Origin;
var fromVirtualAddress = HashHelper.ComputeFrom(
    addressForVirtual.Value.Concat(input.Address.Value).Concat(input.LockId.Value).ToArray());
```

**Test Cases to Add:**
1. Test that non-whitelisted contracts cannot lock tokens without allowance
2. Test that contracts with insufficient allowance cannot lock tokens
3. Test that users can unlock tokens they locked through contracts (if using Alternative Fix)

### Proof of Concept

**Initial State:**
- User has 1000 ELF tokens
- MaliciousContract deployed at address M
- User has NOT approved any allowance to M

**Attack Steps:**

1. User calls `MaliciousContract.SomeFunction()` 
   - Transaction sender: User
   - Context.Origin = User

2. Inside `MaliciousContract.SomeFunction()`:
   ```
   TokenContract.Lock({
     Address: User,
     Symbol: "ELF", 
     Amount: 1000,
     LockId: Hash("stolen"),
     Usage: "malicious"
   })
   ```
   
3. In `TokenContract.Lock()`:
   - Context.Origin = User
   - Context.Sender = MaliciousContract (M)
   - input.Address = User
   - Check passes: User == User ✓
   - Virtual address = Hash(M || User || Hash("stolen"))
   - Transfer 1000 ELF from User to virtual address

4. User attempts to unlock:
   ```
   TokenContract.Unlock({
     Address: User,
     Symbol: "ELF",
     Amount: 1000, 
     LockId: Hash("stolen"),
     Usage: "recover"
   })
   ```
   - Context.Sender = User
   - Computes virtual address = Hash(User || User || Hash("stolen"))
   - Different from Hash(M || User || Hash("stolen"))
   - Transaction fails: insufficient balance in wrong virtual address

**Expected Result:** Lock should fail due to missing allowance

**Actual Result:** User's 1000 ELF tokens permanently locked in virtual address controlled by MaliciousContract

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L201-202)
```csharp
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L204-206)
```csharp
        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-210)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-235)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L378-381)
```csharp
    private bool IsInLockWhiteList(Address address)
    {
        return address == GetElectionContractAddress() || address == GetVoteContractAddress();
    }
```

**File:** test/AElf.Contracts.TestContract.BasicFunction/BasicContract_Action.cs (L65-80)
```csharp
    public override Empty LockToken(LockTokenInput input)
    {
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        State.TokenContract.Lock.Send(new LockInput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            Amount = input.Amount,
            LockId = input.LockId,
            Usage = input.Usage
        });

        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenApplicationTests.cs (L991-1067)
```csharp
    public async Task MultiTokenContract_LockAndUnLock_Test()
    {
        await CreateTokenAndIssue();

        var beforeBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = SymbolForTest
        })).Balance;

        var lockId = HashHelper.ComputeFrom("lockId");

        // Lock.
        var lockTokenResult = (await BasicFunctionContractStub.LockToken.SendAsync(new LockTokenInput
        {
            Address = DefaultAddress,
            Amount = Amount,
            Symbol = SymbolForTest,
            LockId = lockId,
            Usage = "Testing."
        })).TransactionResult;
        lockTokenResult.Status.ShouldBe(TransactionResultStatus.Mined);
        var transferred = new Transferred();
        transferred.MergeFrom(lockTokenResult.Logs.First(l => l.Name == nameof(Transferred)));
        // Check balance of user after locking.
        {
            var result = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = DefaultAddress,
                Symbol = SymbolForTest
            });
            result.Balance.ShouldBe(beforeBalance - Amount);
        }

        // Check locked amount
        {
            var amount = await BasicFunctionContractStub.GetLockedAmount.CallAsync(new GetLockedTokenAmountInput
            {
                Symbol = SymbolForTest,
                Address = DefaultAddress,
                LockId = lockId
            });
            amount.Amount.ShouldBe(Amount);
        }

        // Unlock.
        var unlockResult = (await BasicFunctionContractStub.UnlockToken.SendAsync(new UnlockTokenInput
        {
            Address = DefaultAddress,
            Amount = Amount,
            Symbol = SymbolForTest,
            LockId = lockId,
            Usage = "Testing."
        })).TransactionResult;
        unlockResult.Status.ShouldBe(TransactionResultStatus.Mined);

        // Check balance of user after unlocking.
        {
            var result = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
            {
                Owner = DefaultAddress,
                Symbol = SymbolForTest
            });
            result.Balance.ShouldBe(beforeBalance);
        }

        //Check amount of lock address after unlocking
        {
            var amount = await BasicFunctionContractStub.GetLockedAmount.CallAsync(new GetLockedTokenAmountInput
            {
                Symbol = SymbolForTest,
                Address = DefaultAddress,
                LockId = lockId
            });
            amount.Amount.ShouldBe(0);
        }
    }
```
