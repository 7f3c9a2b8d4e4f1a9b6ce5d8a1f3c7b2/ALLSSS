### Title
NullReferenceException in ReleaseCrossChainIndexingProposal Due to Uninitialized State

### Summary
The `ReleaseCrossChainIndexingProposal` method can be invoked by any current miner before the CrossChain contract is properly initialized, causing a NullReferenceException when the code attempts to access `State.IndexingPendingProposal.Value.ChainIndexingProposalCollections`. This creates a denial-of-service condition for critical cross-chain indexing functionality.

### Finding Description

The vulnerability exists in the interaction between multiple functions that handle cross-chain indexing proposals:

**State Initialization:**
`State.IndexingPendingProposal` is initialized only in the `Initialize` method, which sets it to a new `ProposedCrossChainIndexing` instance. [1](#0-0) 

**Vulnerable Entry Point:**
The `ReleaseCrossChainIndexingProposal` method performs authorization by checking if the caller is a current miner through an external consensus contract call. This check does not depend on local contract initialization state. [2](#0-1) 

The authorization check calls the consensus contract externally, which can succeed even if the CrossChain contract is uninitialized: [3](#0-2) 

**Null Dereference Path:**
After authorization, `ReleaseCrossChainIndexingProposal` calls `ReleaseIndexingProposal`, which in turn calls `TryGetIndexingProposalWithStatus`. This function directly dereferences `State.IndexingPendingProposal.Value` without checking for null: [4](#0-3) 

The same method also calls `RecordCrossChainData`, which contains additional unguarded dereferences: [5](#0-4) 

**Root Cause:**
Multiple helper functions dereference `State.IndexingPendingProposal.Value` without null checks:
- `TryGetIndexingProposal` (line 485-486)
- `TryGetIndexingProposalWithStatus` (line 492-493)  
- `ResetChainIndexingProposal` (line 501-502)
- `SetCrossChainIndexingProposalStatus` (line 510-511) [6](#0-5) 

In contrast, the `GetIndexingProposalStatus` view method and `ClearCrossChainIndexingProposalIfExpired` properly handle the null case: [7](#0-6) [8](#0-7) 

Note that `ProposeCrossChainIndexing` is safe because it calls `ClearCrossChainIndexingProposalIfExpired` first, which initializes the state if null. However, `ReleaseCrossChainIndexingProposal` does not perform this initialization.

### Impact Explanation

**Operational Impact - DoS of Critical Cross-Chain Functionality:**
- The `ReleaseCrossChainIndexingProposal` method becomes completely unusable, throwing NullReferenceException on every invocation
- Miners cannot release pending cross-chain indexing proposals, blocking the entire cross-chain data indexing workflow
- Parent chain and side chain block data cannot be properly indexed and recorded on the blockchain
- This prevents cross-chain transaction verification and merkle proof validation, effectively breaking cross-chain interoperability

**Affected Parties:**
- All miners attempting to perform their indexing duties
- Users relying on cross-chain transactions and asset transfers
- Side chains depending on parent chain data indexing

**Severity Justification:**
This is a **High severity** vulnerability because:
1. It causes complete DoS of essential cross-chain indexing functionality
2. Cross-chain indexing is a core protocol operation required for blockchain interoperability
3. While the transaction reverts (no state corruption), the functionality remains broken until proper initialization
4. The impact extends beyond a single transaction to affect ongoing cross-chain operations

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current miner (or wait for their miner turn)
- No special permissions beyond standard miner rights required
- No need to compromise any privileged accounts

**Attack Complexity:**
- Very low complexity: single transaction call with any valid chainId list
- No complex setup or multi-step exploitation required

**Feasible Preconditions:**
The vulnerability requires the contract to be in an uninitialized state, which can occur in several realistic scenarios:
1. **Deployment Window**: Between contract deployment and `Initialize` call execution
2. **Race Condition**: If a miner transaction reaches the contract before the initialization transaction
3. **Deployment Error**: If initialization transaction fails or is delayed for any reason

**Economic Rationality:**
- No economic cost to trigger (standard transaction fee only)
- Could be triggered accidentally by a miner checking proposal status
- Intentional exploitation has minimal cost

**Detection and Operational Constraints:**
- The vulnerability is easily detectable after first occurrence (transaction failure logs)
- However, it blocks operations until initialization, creating operational disruption
- In production deployments, contracts should be initialized immediately, but there's no enforcement mechanism

**Probability Assessment:**
- **Medium to High** likelihood in scenarios with improper deployment procedures
- **Low** likelihood in properly managed deployments with immediate initialization
- Overall assessment: **Medium** likelihood due to reliance on operational discipline

### Recommendation

**Code-Level Mitigation:**

Add defensive null checks and initialization in all helper functions that access `State.IndexingPendingProposal.Value`:

1. **In `TryGetIndexingProposal` and `TryGetIndexingProposalWithStatus`:**
   ```csharp
   private bool TryGetIndexingProposalWithStatus(int chainId, CrossChainIndexingProposalStatus status,
       out ChainIndexingProposal proposal)
   {
       var proposedIndexingProposal = State.IndexingPendingProposal.Value;
       if (proposedIndexingProposal == null)
       {
           proposal = null;
           return false;
       }
       if (!proposedIndexingProposal.ChainIndexingProposalCollections.TryGetValue(chainId, out proposal))
           return false;
       return proposal.Status == status;
   }
   ```

2. **In `ResetChainIndexingProposal` and `SetCrossChainIndexingProposalStatus`:**
   Add initialization guard similar to `ClearCrossChainIndexingProposalIfExpired`

3. **Add initialization check in `ReleaseCrossChainIndexingProposal`:**
   Call `ClearCrossChainIndexingProposalIfExpired()` at the beginning of the method

**Invariant Checks:**
- Assert that `State.Initialized.Value == true` in all critical cross-chain methods
- Or call `ClearCrossChainIndexingProposalIfExpired()` at entry points to ensure state initialization

**Test Cases:**
- Test calling `ReleaseCrossChainIndexingProposal` before `Initialize` - should fail gracefully
- Test calling all cross-chain proposal methods in uninitialized state
- Verify proper error messages instead of NullReferenceException
- Test initialization race conditions with concurrent transactions

### Proof of Concept

**Required Initial State:**
- CrossChain contract deployed to blockchain
- `Initialize` method has NOT been called yet
- `State.IndexingPendingProposal.Value` is null (default value)
- Test account is registered as a current miner in the consensus contract

**Exploitation Steps:**

1. **Deploy contract** without calling Initialize
   - State: `State.Initialized.Value = false`
   - State: `State.IndexingPendingProposal.Value = null`

2. **As a current miner, invoke ReleaseCrossChainIndexingProposal:**
   ```
   Input: ReleaseCrossChainIndexingProposalInput {
       ChainIdList = [123456]  // any chain ID
   }
   Sender: [current miner address]
   ```

3. **Execution Flow:**
   - Line 297: `AssertAddressIsCurrentMiner(Context.Sender)` → **PASSES** (checks external consensus contract)
   - Line 298: `Assert(input.ChainIdList.Count > 0, ...)` → **PASSES**
   - Line 299: `ReleaseIndexingProposal(input.ChainIdList)` called
   - Line 301-303: `TryGetIndexingProposalWithStatus(123456, Pending, out ...)` called
   - Line 492: `var proposedIndexingProposal = State.IndexingPendingProposal.Value;` → **proposedIndexingProposal = null**
   - Line 493: `proposedIndexingProposal.ChainIndexingProposalCollections.TryGetValue(...)` → **NullReferenceException**

**Expected vs Actual Result:**
- **Expected**: Method should either initialize state gracefully or return clear error message about uninitialized contract
- **Actual**: NullReferenceException thrown, transaction reverts with exception, functionality completely blocked

**Success Condition:**
Transaction fails with NullReferenceException, demonstrating the vulnerability. The cross-chain indexing release functionality is rendered inoperable until contract initialization is completed.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L19-19)
```csharp
        State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-329)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L483-514)
```csharp
    private bool TryGetIndexingProposal(int chainId, out ChainIndexingProposal proposal)
    {
        var proposedIndexingProposal = State.IndexingPendingProposal.Value;
        return proposedIndexingProposal.ChainIndexingProposalCollections.TryGetValue(chainId, out proposal);
    }

    private bool TryGetIndexingProposalWithStatus(int chainId, CrossChainIndexingProposalStatus status,
        out ChainIndexingProposal proposal)
    {
        var proposedIndexingProposal = State.IndexingPendingProposal.Value;
        if (!proposedIndexingProposal.ChainIndexingProposalCollections.TryGetValue(chainId, out proposal))
            return false;
        return proposal.Status == status;
    }

    private void ResetChainIndexingProposal(int chainId)
    {
        // clear pending proposal
        var proposedIndexingProposal = State.IndexingPendingProposal.Value;
        proposedIndexingProposal.ChainIndexingProposalCollections.Remove(chainId);
        State.IndexingPendingProposal.Value = proposedIndexingProposal;
    }

    private void SetCrossChainIndexingProposalStatus(ChainIndexingProposal crossChainIndexingProposal,
        CrossChainIndexingProposalStatus status)
    {
        crossChainIndexingProposal.Status = status;
        var proposedIndexingProposal = State.IndexingPendingProposal.Value;
        proposedIndexingProposal.ChainIndexingProposalCollections[crossChainIndexingProposal.ChainId] =
            crossChainIndexingProposal;
        State.IndexingPendingProposal.Value = proposedIndexingProposal;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L559-566)
```csharp
    private void ClearCrossChainIndexingProposalIfExpired()
    {
        var crossChainIndexingProposal = State.IndexingPendingProposal.Value;
        if (crossChainIndexingProposal == null)
        {
            State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();
            return;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L161-166)
```csharp
    public override GetIndexingProposalStatusOutput GetIndexingProposalStatus(Empty input)
    {
        var res = new GetIndexingProposalStatusOutput();
        var pendingCrossChainIndexingProposal = State.IndexingPendingProposal.Value;
        if (pendingCrossChainIndexingProposal == null)
            return res;
```
