# Audit Report

## Title
Dictionary Access Vulnerability in Consensus Block Production Causes Chain Halt via Miner Pubkey Replacement Race Condition

## Summary
The AEDPoS consensus contract contains unprotected dictionary accesses to `RealTimeMinersInformation` during block production. When a candidate admin replaces an active miner's pubkey via `ReplaceCandidatePubkey`, the consensus contract removes the old pubkey from the current round information. However, when that miner attempts to produce their next block, the code directly accesses the dictionary without checking key existence, causing a `KeyNotFoundException` that prevents block production and disrupts consensus.

## Finding Description

The vulnerability exists in multiple block production code paths that lack defensive key existence checks before accessing the `RealTimeMinersInformation` dictionary.

**Primary vulnerable location in `GetConsensusExtraDataToPublishOutValue`:** [1](#0-0) 

These lines directly access `currentRound.RealTimeMinersInformation[pubkey]` three times without verifying the key exists. The only validation is an empty pubkey check at line 18, which doesn't protect against missing keys.

**Attack mechanism via pubkey replacement:**

The Election Contract allows candidate admins to replace miner pubkeys at any time: [2](#0-1) 

This triggers `RecordCandidateReplacement` in the consensus contract, which removes the old pubkey from the current round: [3](#0-2) 

Critically, line 142 removes the old pubkey from `RealTimeMinersInformation`, making it unavailable for subsequent dictionary accesses.

**Additional vulnerable locations:**

The same unprotected dictionary access pattern exists in:

`GetConsensusExtraDataForTinyBlock`: [4](#0-3) 

`GetUpdateValueRound`: [5](#0-4) 

`GetTinyBlockRound`: [6](#0-5) 

**Evidence of coding oversight - inconsistent defensive checks:**

The `NextRound` behavior HAS proper key existence validation: [7](#0-6) 

The `NextTerm` behavior also has defensive checks: [8](#0-7) 

This inconsistency between code paths proves the missing checks in UpdateValue and TinyBlock behaviors are unintentional oversights, not design decisions.

**Race condition window:**

Block production involves two separate phases:

1. `GetConsensusCommand` validates the miner is in the current round: [9](#0-8) 

2. Later, `GetConsensusExtraData` is called to generate block header data: [10](#0-9) 

Between these calls, a `ReplaceCandidatePubkey` transaction can execute in another miner's block, removing the target pubkey from the round information. When the affected miner subsequently calls `GetConsensusExtraData`, the unprotected dictionary access causes a crash.

## Impact Explanation

**Consensus Disruption**: When a miner's block production crashes with `KeyNotFoundException`, that time slot is permanently lost. The miner cannot produce their scheduled block, breaking the expected block production cadence.

**Chain Halt Risk**: In networks with few active miners or during consensus transitions, losing even one miner's block production capability could stall the chain. If multiple candidate admins coordinate replacements, they could systematically prevent multiple miners from producing blocks, effectively halting consensus until manual intervention.

**Affected Parties**:
- All blockchain users experience transaction confirmation delays
- Miners lose their block rewards for missed slots
- DApps depending on predictable block times experience failures
- Network availability is compromised

**Severity Justification**: This violates the critical consensus invariant of "miner schedule integrity" and enables operational DoS of the consensus mechanism. The ability to prevent block production on-demand qualifies this as Critical severity, as it directly threatens chain availability.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must control a candidate admin role. While this is a privileged position, candidate admins are NOT part of the core trusted set (genesis keys, consensus system contracts, Parliament default organization). Candidate admins are set when candidates announce election: [11](#0-10) 

**Attack Complexity**: The attack is straightforward:
1. Monitor when target miner receives their mining command (observable on-chain)
2. Submit `ReplaceCandidatePubkey` transaction with timing to execute before the miner produces their block
3. The miner's node crashes when attempting to access the removed pubkey

**Feasibility Conditions**:
- No rate limiting on `ReplaceCandidatePubkey` calls
- Transaction can be included in any block before the target miner's time slot
- Multiple candidate admins could coordinate to affect multiple miners simultaneously
- The race window is predictable from consensus commands

**Detection**: While the attack leaves evidence in on-chain events, detection is reactive. By the time the replacement is detected, block production has already failed. Automated monitoring could identify patterns but cannot prevent the crash.

**Probability Assessment**: MEDIUM-HIGH. Candidate admins have legitimate access to this functionality, and the timing window is predictable from public consensus information. A determined attacker with admin access can reliably trigger this vulnerability.

## Recommendation

Add defensive key existence checks before all dictionary accesses to `RealTimeMinersInformation`. Follow the pattern already used in `NextRound` and `NextTerm` behaviors:

**For `GetConsensusExtraDataToPublishOutValue`**: Add check before line 58:
```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = currentRound,
        Behaviour = triggerInformation.Behaviour
    };
```

**For `GetConsensusExtraDataForTinyBlock`**: Add check before line 158:
```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    return new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = currentRound,
        Behaviour = triggerInformation.Behaviour
    };
```

**For `GetUpdateValueRound` and `GetTinyBlockRound`**: Add checks at the method start:
```csharp
if (!RealTimeMinersInformation.ContainsKey(pubkey))
    return new Round { RoundNumber = RoundNumber };
```

Alternatively, consider preventing pubkey replacement for miners in the current active round, only allowing replacements to take effect in the next round.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceMinerPubkeyDuringActiveRound_CausesBlockProductionFailure()
{
    // Setup: Create initial miners and start consensus
    var initialMiners = new[] { "miner1", "miner2", "miner3" };
    await InitializeConsensus(initialMiners);
    
    // Miner1 becomes a candidate with a candidate admin
    var candidateAdmin = Accounts[5].Address;
    await ElectionContractStub.AnnounceElection.SendAsync(candidateAdmin);
    
    // Advance to a round where miner1 is actively mining
    await ProduceBlocks(10);
    
    // Attack: Admin replaces miner1's pubkey while they're in active mining rotation
    var replacementTx = await ElectionContractStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = "miner1",
            NewPubkey = "miner1_new"
        });
    
    // Verify replacement occurred
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.False(currentRound.RealTimeMinersInformation.ContainsKey("miner1"));
    Assert.True(currentRound.RealTimeMinersInformation.ContainsKey("miner1_new"));
    
    // Trigger: Miner1's node attempts to get consensus extra data for block production
    var consensusTrigger = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFromUtf8("miner1"),
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    // Expected: KeyNotFoundException when accessing RealTimeMinersInformation["miner1"]
    var exception = await Assert.ThrowsAsync<KeyNotFoundException>(async () =>
    {
        await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            consensusTrigger.ToByteString().ToBase64());
    });
    
    // Result: Block production fails, time slot is lost, consensus is disrupted
    Assert.Contains("miner1", exception.Message);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-143)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-13)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-60)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-58)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-103)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
```
