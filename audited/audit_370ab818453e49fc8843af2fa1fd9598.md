# Audit Report

## Title
Memory Exhaustion DoS via Unbounded RealTimeMinersInformation Dictionary in Consensus Validation

## Summary
The AEDPoS consensus validation process does not validate the size of the `ProvidedRound.RealTimeMinersInformation` dictionary before performing memory-intensive materialization operations. An elected miner can craft a block with consensus extra data containing an excessively large Round object, causing memory exhaustion on all validating nodes and resulting in network-wide denial of service.

## Finding Description

When a block is validated, the `ValidateConsensusBeforeExecution` method parses the consensus header information without any size constraints on the Round object's miner dictionary: [1](#0-0) 

The parsed `extraData.Round` becomes the `ProvidedRound` in the validation context: [2](#0-1) 

During validation of new rounds, `TimeSlotValidationProvider` unconditionally calls `CheckRoundTimeSlots()`: [3](#0-2) 

The critical vulnerability occurs in `CheckRoundTimeSlots()`, which materializes ALL values from the `RealTimeMinersInformation` dictionary into memory and sorts them: [4](#0-3) 

Additional materialization occurs in `NextRoundMiningOrderValidationProvider` for NextRound behavior: [5](#0-4) 

And in `RoundTerminateValidationProvider`: [6](#0-5) 

**Root Cause:** There is no validation comparing `ProvidedRound.RealTimeMinersInformation.Count` against `BaseRound.RealTimeMinersInformation.Count` or reasonable bounds. The only check is that the sender exists in the BaseRound: [7](#0-6) 

Each `MinerInRound` is a complex protobuf structure with multiple fields including maps and repeated timestamps: [8](#0-7) 

The network message size limit is 100MB, which allows for tens of thousands of miner entries: [9](#0-8) 

## Impact Explanation

**Concrete Harm:**
- **Memory Exhaustion**: Materializing hundreds of thousands of `MinerInRound` objects causes OutOfMemoryException or severe memory pressure
- **Network-Wide DoS**: All nodes validating the malicious block experience simultaneous memory exhaustion
- **Consensus Disruption**: Nodes cannot process blocks, halting chain progression
- **Resource Starvation**: Even without OutOfMemoryException, excessive allocation and sorting operations degrade all node performance

**Affected Parties:**
- All full nodes performing block validation
- Block producers attempting to continue consensus
- Overall network availability and liveness

This represents a high-impact consensus availability attack that can be executed with a single malicious block from any elected miner.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an elected miner (one of ~17-21 initially)
- Can sign blocks and include arbitrary consensus extra data
- Needs to craft only one malicious block to trigger DoS

**Attack Complexity:**
- Low - simply populate the `RealTimeMinersInformation` protobuf map with excessive entries (e.g., 100,000+)
- No complex state manipulation required
- No precise timing requirements
- The malicious block propagates normally through the network

**Feasibility:**
- Attacker must be elected as a miner (requires community support/stake)
- Once elected, execution is straightforward
- No network-level protections prevent oversized Round objects in block headers
- The 5MB transaction limit does not apply to block header extra data

**Detection Difficulty:**
- The attack appears as a valid block until validation begins
- Memory exhaustion occurs during validation processing
- Limited forensic traces beyond the oversized consensus data

Given these factors, the likelihood is **Medium-High** for a malicious elected miner, as execution is trivial once miner status is obtained.

## Recommendation

Implement size validation before materialization operations:

```csharp
// In ValidateBeforeExecution, after line 59
if (extraData.Behaviour == AElfConsensusBehaviour.NextRound || 
    extraData.Behaviour == AElfConsensusBehaviour.NextTerm)
{
    // Validate ProvidedRound miner count matches expected bounds
    if (extraData.Round.RealTimeMinersInformation.Count != baseRound.RealTimeMinersInformation.Count)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = $"Invalid miner count in provided round. Expected: {baseRound.RealTimeMinersInformation.Count}, Got: {extraData.Round.RealTimeMinersInformation.Count}" 
        };
    }
}

// For new rounds in same term, allow small growth but bound it
const int MaxMinerCountGrowth = 10; // Reasonable limit for miner list changes
if (extraData.Round.RealTimeMinersInformation.Count > baseRound.RealTimeMinersInformation.Count + MaxMinerCountGrowth)
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = "Excessive miner count in provided round exceeds maximum allowed growth" 
    };
}
```

Additionally, add defensive bounds checking in `CheckRoundTimeSlots()`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    const int MaxReasonableMinerCount = 1000; // Defensive upper bound
    if (RealTimeMinersInformation.Count > MaxReasonableMinerCount)
    {
        return new ValidationResult { Message = $"Miner count {RealTimeMinersInformation.Count} exceeds maximum allowed." };
    }
    
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    // ... rest of validation
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MemoryExhaustionAttack_ExcessiveMinersInNextRound()
{
    // Setup: Become an elected miner
    var maliciousMiner = InitialCoreDataCenterKeyPairs[0];
    
    // Create a malicious Round with excessive miner entries
    var maliciousRound = new Round
    {
        RoundNumber = 2,
        TermNumber = 1
    };
    
    // Add 100,000 bogus miners (attack payload)
    for (int i = 0; i < 100000; i++)
    {
        var fakePubkey = $"fake_miner_{i}";
        maliciousRound.RealTimeMinersInformation[fakePubkey] = new MinerInRound
        {
            Order = i + 1,
            ExpectedMiningTime = TimestampHelper.GetUtcNow().AddSeconds(i * 4),
            Pubkey = fakePubkey
        };
    }
    
    // Create consensus header information with malicious round
    var maliciousHeaderInfo = new AElfConsensusHeaderInformation
    {
        SenderPubkey = ByteString.CopyFrom(maliciousMiner.PublicKey),
        Round = maliciousRound,
        Behaviour = AElfConsensusBehaviour.NextRound
    };
    
    // Attempt validation - this should cause memory exhaustion
    var validationResult = await AEDPoSContractStub.ValidateConsensusBeforeExecution.CallAsync(
        new BytesValue { Value = maliciousHeaderInfo.ToByteString() }
    );
    
    // In the vulnerable code, this would materialize all 100,000 MinerInRound objects
    // causing OutOfMemoryException or severe memory pressure
    // The test demonstrates the attack is executable
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation for consensus data structures. While the AEDPoS protocol expects a small, stable miner set (~17-21 miners), the validation logic does not enforce this constraint before performing expensive operations on attacker-controlled data. The 100MB network message limit provides sufficient room for an attack payload while remaining within protocol bounds, making this a realistic denial-of-service vector for malicious elected miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-38)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** src/AElf.OS.Network.Grpc/GrpcConstants.cs (L28-29)
```csharp
    public const int DefaultMaxReceiveMessageLength = 100 * 1024 * 1024;
    public const int DefaultMaxSendMessageLength = 100 * 1024 * 1024;
```
