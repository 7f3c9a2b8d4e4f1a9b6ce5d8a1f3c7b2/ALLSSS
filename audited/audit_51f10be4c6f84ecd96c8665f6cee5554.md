### Title
Missing Validation Allows Consensus DoS via Zero FinalOrderOfNextRound Values

### Summary
The `ProcessUpdateValue` method accepts `UpdateValueInput` with arbitrary `SupposedOrderOfNextRound` values (including 0) without validation, allowing malicious miners to corrupt the consensus state. While `NextRoundMiningOrderValidationProvider` detects this corruption and blocks round transitions, this creates a denial-of-service condition with no built-in recovery mechanism. The validation at NextRound acts as a fail-safe but enables a DoS attack rather than preventing invalid state from entering the system.

### Finding Description

**Root Cause:**
In `ProcessUpdateValue`, the `SupposedOrderOfNextRound` value from `UpdateValueInput` is directly assigned to both `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` without any validation that it falls within the valid range [1, minersCount]: [1](#0-0) 

Additionally, `TuneOrderInformation` can set arbitrary `FinalOrderOfNextRound` values for any miner without validation: [2](#0-1) 

**Why Protections Fail:**
The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are present and that `PreviousInValue` is correct - it does NOT check `FinalOrderOfNextRound` values: [3](#0-2) 

**Detection at NextRound:**
The issue is only detected when `NextRoundMiningOrderValidationProvider` validates the round transition. It checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count of miners with non-null `OutValue`: [4](#0-3) 

If all miners have `FinalOrderOfNextRound = 0` but have valid `OutValue`, `distinctCount` will be 0 while the OutValue count is positive, causing validation to fail and blocking the NextRound transition.

**Expected vs Actual Behavior:**
By design, `ApplyNormalConsensusData` always calculates `FinalOrderOfNextRound` as `GetAbsModulus(sigNum, minersCount) + 1`, which guarantees values >= 1: [5](#0-4) [6](#0-5) 

However, miners control the `UpdateValueInput` they submit, and nothing prevents them from providing values outside this expected range.

### Impact Explanation

**Consensus DoS:**
If miners collude or a single malicious miner exploits `TuneOrderInformation` to set all miners' `FinalOrderOfNextRound` to 0:
1. All UpdateValue transactions are accepted during the current round
2. When any miner attempts to trigger NextRound, validation fails
3. The blockchain cannot progress to the next round
4. Block production halts, requiring governance intervention or manual recovery

**Severity:**
Medium severity due to:
- **Direct Impact**: Complete consensus halt - no new blocks can be produced
- **Recovery Difficulty**: No built-in mechanism to correct corrupted `FinalOrderOfNextRound` values
- **Collusion Requirement**: Requires multiple miners to participate OR single miner with ability to manipulate TuneOrderInformation for others

**Affected Parties:**
- All network participants experience service interruption
- DApps and users cannot submit transactions
- Economic activity on the chain stops

### Likelihood Explanation

**Attack Feasibility:**
- **Entry Point**: The `UpdateValue` method is the standard public entry point for miners producing blocks
- **Attacker Capabilities**: Miners can modify their node software to generate malicious `UpdateValueInput` with `SupposedOrderOfNextRound = 0` or malicious `TuneOrderInformation`
- **Collusion Requirement**: 
  - Full DoS requires all/most miners to provide zero values, OR
  - Single miner could potentially manipulate via `TuneOrderInformation` if they can include entries for other miners
- **Detection**: The attack is only detected at NextRound, after invalid data has entered the state

**Complexity:**
- Low technical complexity - requires only node software modification
- Coordination complexity depends on whether TuneOrderInformation can be exploited unilaterally

**Economic Rationality:**
- Miners have economic incentive to maintain chain operation
- However, malicious miners or cartel could use this for extortion or competitive attack
- Attack cost is low (just producing blocks with modified data)

**Overall Likelihood**: Medium - practical to execute but requires miner participation

### Recommendation

**Immediate Fix:**
Add validation in `ProcessUpdateValue` to enforce valid `FinalOrderOfNextRound` range:

```csharp
private void ProcessUpdateValue(UpdateValueInput updateValueInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    var minersCount = currentRound.RealTimeMinersInformation.Count;
    
    // Validate SupposedOrderOfNextRound is in valid range
    Assert(updateValueInput.SupposedOrderOfNextRound >= 1 && 
           updateValueInput.SupposedOrderOfNextRound <= minersCount,
           "Invalid SupposedOrderOfNextRound value.");
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    // ... rest of method
    
    // Validate TuneOrderInformation values
    foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
    {
        Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
               $"Invalid FinalOrderOfNextRound value in TuneOrderInformation for {tuneOrder.Key}.");
        currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
    }
    // ... rest of method
}
```

**Additional Validation:**
Add validation in `UpdateValueValidationProvider` to verify `SupposedOrderOfNextRound` matches the expected value calculated from the signature: [7](#0-6) 

**Test Cases:**
1. Test UpdateValue with `SupposedOrderOfNextRound = 0` - should fail
2. Test UpdateValue with `SupposedOrderOfNextRound > minersCount` - should fail
3. Test TuneOrderInformation with invalid values - should fail
4. Test legitimate conflict resolution via TuneOrderInformation - should succeed

### Proof of Concept

**Initial State:**
- Blockchain operating normally with N miners
- Current round in progress with some miners having produced blocks

**Attack Sequence:**

1. **Malicious miner modifies node software** to generate `UpdateValueInput`:
   ```
   UpdateValueInput {
       OutValue: [valid hash],
       Signature: [valid signature],
       SupposedOrderOfNextRound: 0,  // INVALID!
       TuneOrderInformation: {
           "miner1": 0,
           "miner2": 0,
           ...
       }
   }
   ```

2. **Miner produces block with UpdateValue** transaction containing this input

3. **Transaction executes successfully** because `ProcessUpdateValue` has no validation:
   - Sets malicious miner's `FinalOrderOfNextRound = 0`
   - Applies `TuneOrderInformation` to set other miners' `FinalOrderOfNextRound = 0`
   - State is now corrupted

4. **Subsequent UpdateValue transactions** from honest miners may preserve or overwrite these zeros depending on their `TuneOrderInformation`

5. **When any miner attempts NextRound**:
   - `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` executes
   - `distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0).Distinct().Count()` = 0
   - `OutValue count = providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null)` = N (positive)
   - Validation fails with "Invalid FinalOrderOfNextRound."
   - NextRound block is rejected

**Expected Result**: UpdateValue should reject invalid `SupposedOrderOfNextRound` values

**Actual Result**: UpdateValue accepts invalid values, corrupting state and blocking NextRound transition permanently

**Success Condition**: Chain cannot progress to next round until manual intervention (governance action or hard fork)

### Notes

This is NOT intended defensive behavior - it represents a missing validation vulnerability. While the `NextRoundMiningOrderValidationProvider` acts as a safety check preventing corrupt round generation, the proper design would validate inputs at the UpdateValue stage to prevent invalid state from entering the system. The current design enables a DoS attack vector where the validation mechanism itself becomes the attack surface by halting chain progression rather than rejecting invalid inputs upfront.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L8-20)
```csharp
public class UpdateValueValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```
