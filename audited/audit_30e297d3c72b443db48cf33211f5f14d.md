### Title
Infinite Loop in GenerateSymbolNumber() Causes DOS on NFT Protocol Creation Due to Collision Handling Flaw

### Summary
The `GenerateSymbolNumber()` method contains a critical flaw where the random hash is computed only once before entering a collision-checking loop. When a generated number collides with an existing protocol symbol, the loop repeatedly checks the same number until AElf's branch count limit (15,000) is reached, causing transaction failure and preventing legitimate protocol creation.

### Finding Description

**Exact Code Location:** [1](#0-0) [2](#0-1) 

**Root Cause:**

The `GenerateSymbolNumber()` method computes `randomHash` once before the collision-checking loop: [3](#0-2) 

The do-while loop then uses this static hash to generate a number, checking if it collides: [4](#0-3) 

Since `ConvertHashToInt64()` is deterministic, passing the same `randomHash` with the same range parameters always produces the same `randomNumber`. If `State.IsCreatedMap[randomNumber]` is true (number already exists), the loop iterates indefinitely with the identical number until AElf's branch count observer terminates execution. [5](#0-4) 

**Execution Path:**

1. Public `Create()` method called by any user: [6](#0-5) 

2. `GetSymbol()` invokes `GenerateSymbolNumber()`: [7](#0-6) 

3. On collision, loop runs until branch count limit triggers failure: [8](#0-7) 

**Why Existing Protections Fail:**

The `NumberMinLength` constant of 9 provides 900 million combinations (100,000,000 to 999,999,999): [1](#0-0) 

However, the `GetCurrentNumberLength()` mechanism for expanding the number space doesn't help because: [9](#0-8) 

The flag only increments when `upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value`, which requires the protocol count to reach specific thresholds. The collision-checking loop doesn't regenerate the random hash to find an available number, rendering space expansion ineffective for collision resolution.

### Impact Explanation

**Concrete Harm:**
- **DOS Attack Surface**: Any user attempting to create an NFT protocol will experience transaction failure if their deterministically generated number collides with an existing protocol symbol
- **Permanent Degradation**: As protocol count increases, collision probability rises according to the birthday paradox (~30,000 protocols = significant collision risk for 900M space)
- **No Recovery Mechanism**: Victims cannot retry with different parameters since randomness is tied to block height and sender address
- **Protocol Unusability**: Critical NFT protocol creation functionality becomes unreliable and eventually unusable

**Who is Affected:**
- All legitimate users attempting to create NFT protocols after collision threshold
- NFT platform operators relying on protocol creation
- DApp developers building on AElf NFT infrastructure

**Severity Justification:**
HIGH severity due to:
- Public, permissionless attack vector
- Inevitable collision as protocol count grows
- No workaround or recovery mechanism
- Permanent operational DOS of core functionality

### Likelihood Explanation

**Attacker Capabilities:**
- Requires only the ability to call the public `Create()` method repeatedly
- No special permissions or privileged access needed
- Standard transaction gas costs apply

**Attack Complexity:**
- LOW: Simply invoke `Create()` with valid parameters multiple times
- Birthday paradox: √(900,000,000) ≈ 30,000 protocols needed for 50% collision probability
- Collision becomes inevitable over time as legitimate protocols accumulate

**Feasibility Conditions:**
- `Create()` method has only a chain ID check (must be mainchain): [10](#0-9) 

- No rate limiting or permission checks beyond chain validation
- Random generation is deterministic based on `Context.CurrentHeight` and `Context.Sender`

**Detection/Operational Constraints:**
- Attack transactions appear legitimate (valid protocol creations)
- Collision-induced failures manifest as "branch count exceeded" errors
- No on-chain mechanism to detect or prevent collision-based DOS

**Probability Reasoning:**
- MEDIUM-HIGH probability as protocol ecosystem matures
- Deterministic randomness makes collision predictable for sophisticated attackers
- Natural accumulation of legitimate protocols eventually triggers condition

### Recommendation

**Code-Level Mitigation:**

Regenerate `randomHash` inside the collision-checking loop by incorporating an iteration counter:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
    {
        Value = Context.CurrentHeight.Sub(1)
    }.ToBytesValue());
    
    long randomNumber;
    var attemptCount = 0;
    const int maxAttempts = 100; // Reasonable retry limit
    
    do
    {
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attemptCount) // Add iteration entropy
        );
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        attemptCount++;
        
        Assert(attemptCount < maxAttempts, "Failed to generate unique symbol number after max attempts.");
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Alternative Solution:**

Increment `NftProtocolNumberFlag` on each protocol creation to dynamically track usage and expand space proactively before collision probability becomes significant.

**Invariant Checks:**
- Add assertion ensuring collision resolution terminates within bounded iterations
- Implement protocol count tracking to trigger space expansion before birthday paradox threshold
- Add state validation to detect when number space utilization exceeds safe thresholds (e.g., 50%)

**Test Cases:**
1. Create protocols until collision occurs, verify new hash generation succeeds
2. Simulate near-capacity conditions (high protocol count) and validate reliable symbol generation
3. Test assertion triggers when max attempts exceeded
4. Verify branch count observer doesn't terminate before assertion

### Proof of Concept

**Initial State:**
- NFT contract deployed on AElf mainchain
- Multiple existing protocols already created for the same NFT type (e.g., "Art")

**Attack Sequence:**

1. **Setup Phase**: Attacker or legitimate ecosystem accumulates protocols over time:
   ```
   for i = 1 to 30,000:
       Call Create(CreateInput{NftType: "Art", ...})
   ```

2. **Collision Trigger**: Next user attempts protocol creation:
   ```
   Call Create(CreateInput{NftType: "Art", ProtocolName: "NewArtwork", ...})
   ```

3. **Execution Behavior**:
   - `GenerateSymbolNumber()` computes random hash based on current block height and sender
   - `ConvertHashToInt64()` produces number N (e.g., 123456789)
   - If `State.IsCreatedMap[123456789] == true` (collision)
   - Loop executes: iteration 1-15,000 checking same number 123456789
   - Branch count observer terminates execution at iteration 15,000

4. **Result**:
   - **Expected**: Protocol created with unique symbol
   - **Actual**: Transaction fails with "branch count exceeded" error
   - Protocol creation impossible for this user at this block height

**Success Condition:**
Demonstrate that after sufficient protocols exist for an NFT type, a `Create()` call with colliding random number causes transaction failure, proving DOS condition.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-27)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L15-15)
```text
- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```
