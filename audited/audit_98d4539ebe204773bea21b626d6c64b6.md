### Title
Permissive Authorization Check Allows Anyone to Propose Updates to Non-Whitelisted Proposer Contracts

### Summary
When a contract is deployed by a proposer not in the deployment controller whitelist, the contract's author is set to `Context.Self` (the Genesis contract). Due to a flawed permission check in `AssertAuthorityByContractInfo`, ANY user can then propose updates to such contracts, breaking the expected ownership model where only the original deployer should have proposal rights. This does NOT make contracts immutable; rather, it makes them excessively mutable and subject to governance spam.

### Finding Description

The vulnerability exists in the interaction between two functions:

1. **`DecideNonSystemContractAuthor`** [1](#0-0)  determines the contract author during deployment. When the proposer is not in the deployment controller whitelist, it returns `Context.Self` (the Genesis contract address) as the author.

2. **`AssertAuthorityByContractInfo`** [2](#0-1)  checks permissions using the condition: `contractInfo.Author == Context.Self || address == contractInfo.Author`. When a contract's author IS `Context.Self`, the first condition evaluates to true regardless of the sender.

**Execution Flow:**
- A user calls `DeploySmartContract` [3](#0-2)  which invokes `DecideNonSystemContractAuthor` to determine the author
- If the original proposer is not whitelisted, the contract is deployed with `author = Context.Self`
- Later, when ANY user calls `ProposeUpdateContract` [4](#0-3) , the permission check at line 183 passes because `contractInfo.Author == Context.Self` evaluates to true
- This allows unlimited users to propose updates to the contract

The author cannot be changed because `SetContractAuthor` [5](#0-4)  requires `Context.Sender == info.Author`, which is impossible when the author is the Genesis contract address.

### Impact Explanation

**Contrary to the question's premise, contracts do NOT become immutable.** Instead, they become **excessively mutable**:

1. **Loss of Exclusive Control**: The original deployer loses exclusive rights to propose contract updates, despite going through the governance process to deploy the contract
2. **Governance Spam**: Any user can create update proposals for these contracts, potentially flooding governance with conflicting or malicious proposals
3. **Ownership Confusion**: The contract appears to have no individual owner, creating ambiguity about who is responsible for maintaining it
4. **Competitive Proposals**: Multiple parties can simultaneously propose different updates, creating governance conflicts and potential for manipulation

**Affected Parties**: Any contract deployer who is not in the deployment controller whitelist loses the expected exclusive control over their deployed contract.

**Severity Justification**: Medium - While updates still require governance approval (preventing direct exploitation), the loss of exclusive proposal rights and potential for governance spam represents a significant deviation from expected authorization semantics and could impact governance efficiency.

### Likelihood Explanation

**Attacker Capabilities**: Any address can exploit this - no special privileges required.

**Attack Complexity**: Low - simply call `ProposeUpdateContract` for any contract whose author is `Context.Self`.

**Feasibility Conditions**: 
- Contract must have been deployed by a proposer not in the deployment controller whitelist
- `ContractDeploymentAuthorityRequired` must be enabled

**Execution Practicality**: Highly practical - the public method `ProposeUpdateContract` is directly accessible, and checking contract ownership is trivial.

**Probability**: High for contracts deployed by non-whitelisted users, as this happens automatically during deployment.

### Recommendation

**Fix the Permission Check:**

Modify `AssertAuthorityByContractInfo` to disallow public proposal rights when the author is `Context.Self`:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    // Only allow the contract author to propose updates
    // Do NOT grant universal access when author is Context.Self
    Assert(address == contractInfo.Author, "No permission.");
}
```

**Alternative Fix:**

If the intent is for non-whitelisted proposer contracts to be community-governed, explicitly document this behavior and consider:
1. Setting the author to a specific governance organization address instead of `Context.Self`
2. Adding a flag to `ContractInfo` indicating community-owned contracts
3. Requiring special permissions to propose updates to community-owned contracts

**Add Validation:**
Add a check in `DecideNonSystemContractAuthor` to ensure proposers understand the implications when they're not whitelisted, or reject deployment entirely if not whitelisted.

**Test Cases:**
1. Deploy contract with non-whitelisted proposer, verify only that proposer can propose updates
2. Attempt update proposal from different address, verify it fails with "No permission"
3. Test that whitelisted proposers' contracts maintain expected exclusive control

### Proof of Concept

**Initial State:**
- Chain initialized with Parliament governance
- User A is NOT in the deployment controller whitelist
- `ContractDeploymentAuthorityRequired` is enabled

**Attack Steps:**

1. **User A deploys a contract:**
   - Call `ProposeNewContract` with contract code
   - Governance approves the proposal
   - `DeploySmartContract` is executed
   - Result: Contract deployed with `author = Context.Self` (Genesis contract)

2. **User B (attacker) proposes an update:**
   - Call `ProposeUpdateContract` with the deployed contract address and new code
   - The check `AssertAuthorityByContractInfo(info, Context.Sender)` passes because `info.Author == Context.Self` evaluates to true
   - Result: User B successfully creates an update proposal despite not being the original deployer

3. **User C, D, E also create proposals:**
   - Any number of users can repeat step 2
   - Result: Multiple conflicting proposals for the same contract

**Expected vs Actual:**
- **Expected**: Only User A (original deployer) can propose updates
- **Actual**: ANY user can propose updates

**Success Condition**: Update proposal from User B succeeds without "No permission" error, proving unauthorized users can propose updates to contracts deployed by non-whitelisted proposers.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-185)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-322)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```
