### Title
Batch Option Removal Orphans Active Votes and Corrupts Voting Results

### Summary
The `RemoveOptions()` function allows sponsors to remove multiple voting options simultaneously without invalidating existing votes for those options or cleaning up vote tallies. This creates a critical data inconsistency where `VotingResult.results` contains vote counts for options that no longer exist in `VotingItem.options`, corrupting voting integrity and orphaning voter tokens.

### Finding Description

The `RemoveOptions()` function only removes options from the `VotingItem.options` list without handling existing votes: [1](#0-0) 

**Root Cause:** The function performs three operations:
1. Validates sponsor permission
2. Checks options exist and removes them from `votingItem.Options`
3. Persists the updated voting item

However, it completely ignores existing voting data:

**Missing Cleanups:**
- **VotingRecords**: Each vote stores an `option` field that becomes orphaned when the option is removed [2](#0-1) 

- **VotingResults**: The `results` map (option → vote count) retains entries for removed options, and `votes_amount`/`voters_count` include these orphaned votes [3](#0-2) 

- **Token Locks**: Voters who locked tokens for removed options cannot recover them until voting ends, even though their option no longer exists

**Why Existing Validations Fail:**

The `Vote()` function validates that options exist: [4](#0-3) 

This prevents **new** votes for removed options (line 381 assertion), but does nothing about **existing** votes that were cast before removal.

**Real-World Usage:**

The Election contract demonstrates this pattern when candidates quit: [5](#0-4) 

While `RemoveOption` (singular) is used here, the `RemoveOptions` (plural) function enables batch removal, amplifying the vulnerability's impact.

### Impact Explanation

**1. Voting Result Corruption:**
When election results are retrieved, they include votes for non-existent options: [6](#0-5) 

The `ElectionResult.Results` dictionary contains vote counts for candidates that are no longer in `VotingItem.options`, creating a fundamental data inconsistency.

**2. Inflated Vote Totals:**
The `votes_amount` field includes all votes cast for removed options, making total vote counts artificially high and percentage calculations incorrect.

**3. Orphaned Locked Tokens:**
Voters who cast votes with `IsLockToken=true` have their tokens locked until the voting period ends, even though their chosen option was removed. They cannot withdraw or change their vote because the option no longer exists in the validation list.

**4. Sponsor Manipulation:**
A malicious or compromised sponsor can:
- Remove losing options to improve the appearance of their preferred option
- Remove competitive options to reduce voter choice
- Remove multiple options in a single transaction to maximize disruption
- Strategically orphan large vote blocks before snapshots

**5. Democratic Process Integrity:**
The core purpose of the voting system—to accurately reflect voter preferences—is violated when options can be removed mid-vote without vote invalidation.

**Severity Justification:** HIGH - This corrupts the fundamental integrity of the voting system, affects all voters who chose removed options, and can be exploited to manipulate election outcomes.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Sponsor role for the voting item (legitimate but could be compromised)
- No additional privileges needed

**Attack Complexity:**
- Single transaction: `RemoveOptions(votingItemId, [option1, option2, ...])`
- No complex state manipulation required
- No timing dependencies

**Feasibility Conditions:**
- Voting activity must be active
- Options to remove must exist
- Sponsor authentication required (but this is the legitimate role with this permission)

**Detection Constraints:**
- No events emitted when options are removed
- Silent corruption of voting data
- Results only appear corrupted when queried

**Probability Reasoning:**
The attack is **highly practical** because:
1. The `RemoveOptions` function is intended for legitimate use (e.g., candidates quitting elections)
2. Sponsors may use this without realizing votes are orphaned
3. Batch removal capability amplifies accidental or malicious misuse
4. No warnings or protections exist in the contract

Even without malicious intent, the lack of vote cleanup creates data corruption during normal operations when options are legitimately removed.

### Recommendation

**Code-Level Mitigation:**

Add vote cleanup logic to `RemoveOptions()`:

```csharp
public override Empty RemoveOptions(RemoveOptionsInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // Validate all options exist first
    foreach (var option in input.Options)
    {
        Assert(votingItem.Options.Contains(option), "Option doesn't exist.");
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    }
    
    // Clean up existing votes for removed options
    var votingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
    var votingResult = State.VotingResults[votingResultHash];
    
    foreach (var option in input.Options)
    {
        // Remove vote counts from results
        if (votingResult.Results.ContainsKey(option))
        {
            var removedVotes = votingResult.Results[option];
            votingResult.VotesAmount = votingResult.VotesAmount.Sub(removedVotes);
            votingResult.Results.Remove(option);
        }
        
        votingItem.Options.Remove(option);
    }
    
    State.VotingResults[votingResultHash] = votingResult;
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    
    // Emit event for transparency
    Context.Fire(new OptionsRemoved 
    { 
        VotingItemId = input.VotingItemId, 
        Options = { input.Options } 
    });
    
    return new Empty();
}
```

**Invariant Checks to Add:**
1. Assert that `VotingResult.results` keys are a subset of `VotingItem.options`
2. Add validation in `GetVotingResult` to filter out orphaned options
3. Prevent option removal if current snapshot has active votes for those options

**Test Cases:**
1. Test removing options with existing votes
2. Verify vote counts are adjusted correctly
3. Test batch removal of multiple voted options
4. Verify `votes_amount` is recalculated properly
5. Test that voters can withdraw after their option is removed
6. Verify election results don't include removed candidates

### Proof of Concept

**Initial State:**
1. Sponsor creates voting item with options ["Alice", "Bob", "Charlie", "David"]
2. IsLockToken = true, requiring token locks

**Transaction Sequence:**

Step 1: Users cast votes
- Voter1 votes 1000 for "Alice"
- Voter2 votes 800 for "Bob"  
- Voter3 votes 600 for "Charlie"
- Voter4 votes 400 for "David"

Step 2: Query initial results
```
VotingResult.results = {Alice: 1000, Bob: 800, Charlie: 600, David: 400}
VotingResult.votes_amount = 2800
VotingItem.options = ["Alice", "Bob", "Charlie", "David"]
```

Step 3: Sponsor removes options
```
RemoveOptions(votingItemId, ["Bob", "Charlie"])
```

**Expected Result (Secure):**
- VotingResult.results = {Alice: 1000, David: 400}
- VotingResult.votes_amount = 1400
- Votes for Bob and Charlie invalidated
- Voter2 and Voter3 can withdraw their tokens

**Actual Result (Vulnerable):**
- VotingResult.results = {Alice: 1000, Bob: 800, Charlie: 600, David: 400}
- VotingResult.votes_amount = 2800
- VotingItem.options = ["Alice", "David"]
- **Data corruption**: Results contain Bob and Charlie with 1400 votes, but they're not in options list
- **Orphaned tokens**: Voter2 and Voter3's tokens remain locked for non-existent options
- **Integrity violation**: Total votes include removed options, percentage calculations are wrong

**Success Condition:**
Query `GetVotingResult()` and observe that `results` map contains entries for "Bob" and "Charlie" even though `GetVotingItem().options` only contains ["Alice", "David"], confirming the data corruption.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L326-339)
```csharp
    public override Empty RemoveOptions(RemoveOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options)
        {
            Assert(votingItem.Options.Contains(option), "Option doesn't exist.");
            Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
            votingItem.Options.Remove(option);
        }

        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```

**File:** protobuf/vote_contract.proto (L186-205)
```text
message VotingRecord {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The address of voter.
    aelf.Address voter = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The amount of vote.
    int64 amount = 4;
    // The time of withdraw.
    google.protobuf.Timestamp withdraw_timestamp = 5;
    // The time of vote.
    google.protobuf.Timestamp vote_timestamp = 6;
    // Whether the vote had been withdrawn.
    bool is_withdrawn = 7;
    // The option voted.
    string option = 8;
    // Whether vote others.
    bool is_change_target = 9;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L257-261)
```csharp
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L102-115)
```csharp
    public override ElectionResult GetElectionResult(GetElectionResultInput input)
    {
        var votingResult = State.VoteContract.GetVotingResult.Call(new GetVotingResultInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            SnapshotNumber = input.TermNumber
        });

        var result = new ElectionResult
        {
            TermNumber = input.TermNumber,
            IsActive = input.TermNumber == State.CurrentTermNumber.Value,
            Results = { votingResult.Results }
        };
```
