### Title
Missing Duplicate Call Prevention in ApplyNormalConsensusData Allows Mining Order Manipulation

### Summary
The `ApplyNormalConsensusData()` function lacks validation to prevent a miner from calling `UpdateValue` multiple times within a single round. This allows a malicious miner to overwrite their `SupposedOrderOfNextRound` and manipulate their mining position in the next round by submitting multiple UpdateValue transactions during their time slot.

### Finding Description

The root cause is the absence of duplicate call prevention across multiple layers:

**1. ApplyNormalConsensusData overwrites without checking:** [1](#0-0) [2](#0-1) 

The function unconditionally overwrites `OutValue`, `Signature`, `SupposedOrderOfNextRound`, and `FinalOrderOfNextRound` without verifying if these values were already set in the current round.

**2. Order calculation depends on signature value:** [3](#0-2) 

Different signature values yield different mining orders, creating the manipulation vector.

**3. ProcessUpdateValue lacks duplicate call check:** [4](#0-3) 

The execution path similarly overwrites values without validation.

**4. UpdateValueValidationProvider only checks data validity:** [5](#0-4) 

The validator only ensures the provided `OutValue` and `Signature` are non-null, not whether `OutValue` was already set in state.

**5. Consensus behavior logic is advisory, not enforced:** [6](#0-5) 

While the system expects `UpdateValue` only when `OutValue` is null, this is guidance for honest miners. The validation layer does not enforce this constraint.

**6. Time slot validation allows multiple calls:** [7](#0-6) 

The validator only checks that mining time is within the time slot, not whether `UpdateValue` was already called.

**7. Block-level protection insufficient:** [8](#0-7) 

This only prevents multiple consensus transactions per block, not per round. A miner producing multiple blocks within their time slot can call `UpdateValue` in each.

### Impact Explanation

**Consensus Integrity Violation:**
A malicious miner can manipulate the mining schedule by choosing a favorable `SupposedOrderOfNextRound` value. This breaks the fairness assumption of the AEDPoS consensus mechanism where mining order should be deterministic based on the protocol rules.

**Attack Impact:**
- Attacker gains ability to position themselves favorably in the next round's mining sequence
- Can potentially increase block rewards by mining more blocks
- Undermines randomness and fairness of miner rotation
- All network participants are affected as the consensus schedule integrity is compromised

**Severity Justification:**
This is HIGH severity because it directly impacts consensus mechanism correctness, violating the critical invariant of "miner schedule integrity" specified in the audit requirements.

### Likelihood Explanation

**Attacker Capabilities:**
A malicious miner with control over their node software can:
1. Produce multiple blocks during their time slot (system allows "tiny blocks")
2. Craft custom `UpdateValue` transactions instead of using auto-generated ones
3. Submit `UpdateValue` for tiny blocks instead of `UpdateTinyBlockInformation`

**Attack Complexity:**
- MODERATE: Requires node software modification to bypass `GenerateConsensusTransactions`
- Miner must be able to produce blocks fast enough to create multiple blocks within their time slot
- Different block heights can lead to different signature calculations via the fake previous in value path [9](#0-8) 

**Feasibility:**
The attack is FEASIBLE because:
- No validation explicitly requires `OutValue == null` before accepting `UpdateValue`
- No validation enforces "tiny blocks must use `UpdateTinyBlockInformation`, not `UpdateValue`"
- Time slot validation and VRF checks constrain but don't prevent the attack
- A sophisticated attacker can satisfy validation requirements while calling `UpdateValue` multiple times

**Detection:**
Difficult to detect as both transactions appear valid individually; requires monitoring for multiple `UpdateValue` calls from same miner in same round.

### Recommendation

**1. Add explicit duplicate call prevention in validation:**

Add a check in `UpdateValueValidationProvider` or create a new validation provider:
```csharp
// Check that OutValue must be null for the first UpdateValue call
if (validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey].OutValue != null)
{
    return new ValidationResult { 
        Success = false, 
        Message = "UpdateValue already called this round. OutValue is already set." 
    };
}
```

**2. Add state-based enforcement in ProcessUpdateValue:**

Before line 244 in `ProcessUpdateValue`, add:
```csharp
Assert(minerInRound.OutValue == null || minerInRound.OutValue == Hash.Empty, 
    "UpdateValue can only be called once per round.");
```

**3. Enforce behavior consistency:**

Add validation that if `OutValue != null`, the behavior must be `TinyBlock`, not `UpdateValue`.

**4. Add test cases:**
- Test attempting second `UpdateValue` call with different signature in same round
- Verify rejection with appropriate error message
- Test that tiny blocks correctly use `UpdateTinyBlockInformation`

### Proof of Concept

**Initial State:**
- Current round N with miner A in time slot
- Miner A's `OutValue` = null initially

**Attack Steps:**
1. Miner A produces block at height H during their time slot
2. Transaction: `UpdateValue(signature1)` where signature1 leads to `supposedOrderOfNextRound` = 5
3. State after execution: miner A's `OutValue` = O1, `Signature` = S1, `SupposedOrderOfNextRound` = 5
4. Miner A produces second block at height H+1 (still within time slot, as "tiny block")
5. Instead of `UpdateTinyBlockInformation`, miner crafts `UpdateValue(signature2)` where signature2 leads to `supposedOrderOfNextRound` = 1
6. Validation checks time slot (passes), checks data validity (passes), but does NOT check if `OutValue` already set
7. Execution: `ProcessUpdateValue` overwrites: `Signature` = S2, `SupposedOrderOfNextRound` = 1 (overwrites 5)

**Expected Result:** Second `UpdateValue` should be rejected with "UpdateValue already called this round"

**Actual Result:** Second `UpdateValue` executes successfully, overwriting the mining order from 5 to 1, giving miner A a favorable position

**Success Condition:** Miner A's `SupposedOrderOfNextRound` in round N+1 is 1 instead of the originally calculated 5, demonstrating successful order manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L12-16)
```csharp
        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-32)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-96)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
```
