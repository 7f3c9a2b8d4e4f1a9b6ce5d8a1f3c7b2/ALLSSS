### Title
Missing Null Check in RegisterForProfits Causes DoS When Scheme State is Invalid

### Summary
The `RegisterForProfits` function retrieves a scheme's virtual address without validating that the scheme exists or that the virtual address is valid. If the ProfitContract returns null for the scheme or the virtual address is empty/invalid, the registration will fail with either a NullReferenceException or "Invalid input address" error, permanently preventing users from registering for profits on that scheme.

### Finding Description

In `RegisterForProfits`, when the auto-distribute threshold feature is enabled, the code retrieves the scheme from ProfitContract and immediately accesses its VirtualAddress field without any null or validity checks: [1](#0-0) 

The retrieved `virtualAddress` is then used in a `GetBalance` call: [2](#0-1) 

**Root Cause**: No validation that `originScheme` is non-null before accessing `.VirtualAddress`, and no validation that the virtual address is valid before using it.

**Why Existing Protections Fail**: While `GetValidScheme` is called earlier to validate the TokenHolder scheme exists, it does not guarantee that:
1. The underlying Profit scheme still exists in ProfitContract state
2. The scheme's VirtualAddress was properly initialized
3. There's no state corruption or inconsistency

The `GetBalance` method validates addresses: [3](#0-2) 

The `AssertValidInputAddress` check will fail if the address is null or empty: [4](#0-3) 

### Impact Explanation

**Operational DoS Impact**: Users cannot register for profits on schemes with invalid state. This completely blocks the profit-sharing functionality for affected schemes.

**Affected Parties**: 
- All users attempting to register for profits on schemes with AutoDistributeThreshold configured
- Existing TokenHolder profit scheme participants who cannot increase their stakes

**Severity Justification**: Medium severity because:
- Functionality is completely broken for affected schemes
- No direct fund loss, but users cannot earn expected profits
- Requires abnormal state (corruption/inconsistency) to trigger
- Affects a specific feature subset (auto-distribute threshold)

### Likelihood Explanation

**Likelihood**: Low under normal operation, but possible in edge cases.

**Feasible Scenarios**:
1. **State Corruption**: ProfitContract state becomes inconsistent (e.g., scheme data partially lost)
2. **Upgrade Issues**: Schemes created before VirtualAddress field was added might have default/empty values
3. **Race Conditions**: `GetManagingSchemeIds` returns a stale schemeId that no longer corresponds to a valid scheme
4. **Implementation Bugs**: If ProfitContract's scheme creation had a bug that didn't properly set VirtualAddress

**Attack Complexity**: Not directly exploitable by attackers, but represents a robustness failure. The vulnerability manifests when state integrity is compromised.

**Detection**: Transaction will revert with either NullReferenceException (line 182) or "Invalid input address" (GetBalance call), making the issue immediately visible but providing unclear error context.

### Recommendation

**Add Defensive Checks**: Insert validation after retrieving the scheme and before using the virtual address:

```csharp
var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
Assert(originScheme != null, "Profit scheme not found.");
Assert(originScheme.VirtualAddress != null && 
       !originScheme.VirtualAddress.Value.IsNullOrEmpty(), 
       "Invalid scheme virtual address.");
var virtualAddress = originScheme.VirtualAddress;
```

**Invariant Check**: Ensure scheme exists and has valid virtual address before proceeding with auto-distribute logic.

**Test Cases**: 
1. Test RegisterForProfits when underlying Profit scheme is missing
2. Test RegisterForProfits when VirtualAddress is default/empty
3. Test graceful failure with clear error messages

### Proof of Concept

**Required Initial State**:
1. TokenHolder scheme exists with AutoDistributeThreshold configured
2. Underlying Profit scheme is missing from ProfitContract state OR has empty VirtualAddress

**Transaction Steps**:
1. User calls `RegisterForProfits(RegisterForProfitsInput { SchemeManager = manager, Amount = 1000 })`
2. Code reaches auto-distribute check at line 179 (threshold is set)
3. Line 181: `GetScheme.Call(scheme.SchemeId)` returns null or scheme with empty VirtualAddress
4. Line 182: Accesses `originScheme.VirtualAddress` 
   - If null: NullReferenceException thrown
   - If empty: Continues to line 186
5. Line 186-190: `GetBalance` call with empty virtualAddress
6. GetBalance → GetBalance(address, symbol) → AssertValidInputAddress
7. Assert fails: "Invalid input address."

**Expected Result**: Registration succeeds or fails with clear error message

**Actual Result**: Transaction reverts with either NullReferenceException or "Invalid input address" error, permanently blocking registration for that scheme

**Success Condition**: Any subsequent RegisterForProfits call for the same scheme will fail the same way, creating a permanent DoS condition for that scheme's registration functionality.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L181-182)
```csharp
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L186-190)
```csharp
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```
