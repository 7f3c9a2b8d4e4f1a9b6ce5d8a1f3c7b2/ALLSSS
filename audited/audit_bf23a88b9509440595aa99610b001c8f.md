### Title
Future Period Profit Information Leak Enables Front-Running of Beneficiary Registration

### Summary
The `GetDistributedProfitsInfo()` view method lacks validation to prevent querying future periods, allowing anyone to see pre-allocated profits before they are distributed. Combined with the public `RegisterForProfits()` method in TokenHolder contract, this enables users to front-run by registering as beneficiaries after seeing large future profit allocations, gaining unfair advantages over existing beneficiaries.

### Finding Description

The `GetDistributedProfitsInfo()` function in ViewMethods.cs accepts any period value without validating it against the scheme's current period: [1](#0-0) 

The function simply retrieves `DistributedProfitsInfo` from state for any provided period, returning either the stored data or a default value with `TotalShares = -1`. There is no check ensuring `input.Period <= scheme.CurrentPeriod`.

This becomes exploitable because the `ContributeProfits()` method explicitly allows contributions to future periods: [2](#0-1) 

When contributing to future periods (line 684 validates `input.Period >= scheme.CurrentPeriod`), the method stores `DistributedProfitsInfo` with the contributed amounts in `amounts_map`, while `is_released` remains false and `total_shares` is not yet set. This pre-allocated profit information is immediately visible to anyone querying that future period.

Test cases confirm this behavior is intentional for contributions but the information leak is unprotected: [3](#0-2) 

The attack vector becomes practical through the public `RegisterForProfits()` method in TokenHolder contract: [4](#0-3) 

When a new beneficiary is added, their `StartPeriod` is set based on the current period plus any delay: [5](#0-4) 

If `DelayDistributePeriodCount` is 0 or small (and it has no default value set, defaulting to 0), new beneficiaries can participate in future periods that already have visible pre-allocated profits.

### Impact Explanation

**Information Asymmetry and Reward Misallocation:**
- Users monitoring `GetDistributedProfitsInfo()` for future periods gain unfair knowledge of upcoming profit distributions
- They can strategically time their entry via `RegisterForProfits()` to maximize gains from pre-allocated periods
- Existing beneficiaries who contributed to the scheme early are diluted by late entrants who registered only after seeing guaranteed future profits

**Concrete Scenario:**
1. Period 50 has 1,000,000 ELF pre-allocated via `ContributeProfits()` when current period is 5
2. Attacker queries period 50 and sees the allocation
3. Attacker locks tokens via `RegisterForProfits()` at period 5 (with 0 delay)
4. When period 50 arrives, attacker receives proportional share: `(attacker_shares / total_shares) * 1,000,000`
5. Original beneficiaries receive less than intended due to dilution

**Affected Parties:**
- Early beneficiaries who staked without knowledge of future allocations
- Scheme managers who intended profits for specific beneficiary sets
- Overall protocol fairness and trustworthiness

### Likelihood Explanation

**High Likelihood Under Common Configurations:**

**Reachable Entry Points:**
- `GetDistributedProfitsInfo()` is a public view method (no restrictions)
- `RegisterForProfits()` is a public method (anyone can call)
- `ContributeProfits()` allows future period allocations by design

**Feasible Preconditions:**
- Scheme must use `DelayDistributePeriodCount = 0` or small values (this is the default as no initialization logic sets a minimum)
- Future period contributions must be used (explicitly allowed and tested functionality)
- Attacker needs capital to lock tokens, but this is recoverable after claiming profits

**Attack Complexity:**
- Low: Only requires calling two public methods and monitoring state
- No special privileges needed
- No complex transaction ordering required

**Economic Rationality:**
- If pre-allocated profits are large (e.g., 1M tokens), locking capital is justified
- Lock period risk is offset by guaranteed profit visibility
- Net positive expected value for attacker

**Detection Constraints:**
- View method calls are typically not logged
- Attack appears as legitimate beneficiary registration
- No on-chain signals distinguish front-runners from organic users

### Recommendation

**Primary Fix - Add Period Validation:**
Modify `GetDistributedProfitsInfo()` to validate the queried period:

```csharp
public override DistributedProfitsInfo GetDistributedProfitsInfo(SchemePeriod input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    
    // Only allow querying current or past periods that have been distributed
    Assert(input.Period <= scheme.CurrentPeriod, 
        "Cannot query future periods that have not been distributed yet.");
    
    var releasedProfitsVirtualAddress = GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
    var info = State.DistributedProfitsMap[releasedProfitsVirtualAddress];
    
    // Only return info if the period has been released
    if (info != null && !info.IsReleased)
    {
        return new DistributedProfitsInfo { TotalShares = -1 };
    }
    
    return info ?? new DistributedProfitsInfo { TotalShares = -1 };
}
```

**Alternative/Complementary Mitigations:**

1. **Enforce Minimum Delay Period:** Set a minimum non-zero value for `DelayDistributePeriodCount` in `CreateScheme()` to prevent immediate participation in future periods

2. **Restrict Future Contributions:** Consider whether future period contributions are necessary, or limit how far in advance contributions can be made

3. **Add Access Control:** If future period visibility is required for managers, add role-based access control to `GetDistributedProfitsInfo()`

**Test Cases to Add:**
- Verify `GetDistributedProfitsInfo()` reverts when querying `period > CurrentPeriod`
- Verify `GetDistributedProfitsInfo()` returns empty data for unreleased future periods
- Test that beneficiaries registered after contributions cannot claim pre-allocated profits from periods before their `StartPeriod`

### Proof of Concept

**Initial State:**
- Profit scheme exists with `SchemeId = 0x123`, `CurrentPeriod = 5`, `DelayDistributePeriodCount = 0`
- Existing beneficiaries have 1000 total shares

**Attack Sequence:**

1. **Pre-allocation Transaction (by manager or user):**
   ```
   ContributeProfits(
     SchemeId: 0x123,
     Amount: 1000000,
     Symbol: "ELF",
     Period: 50  // Future period
   )
   ```
   Result: `State.DistributedProfitsMap[virtualAddress_period50]` now contains `{amounts_map: {ELF: 1000000}, is_released: false}`

2. **Information Leak (by attacker):**
   ```
   GetDistributedProfitsInfo(
     SchemeId: 0x123,
     Period: 50
   )
   ```
   Result: Returns `{amounts_map: {ELF: 1000000}, total_shares: 0, is_released: false}`
   
   **Expected:** Should revert or return empty for unreleased future periods
   **Actual:** Leaks pre-allocated amount of 1,000,000 ELF

3. **Front-running (by attacker at period 5):**
   ```
   RegisterForProfits(
     SchemeManager: manager_address,
     Amount: 1000  // Lock 1000 tokens
   )
   ```
   Result: Attacker added as beneficiary with `StartPeriod = 5`, `Shares = 1000`

4. **Exploitation (when CurrentPeriod reaches 50):**
   ```
   DistributeProfits(
     SchemeId: 0x123,
     Period: 50,
     AmountsMap: {ELF: X}  // Additional amount from general ledger
   )
   ```
   Result: Total distributed = 1,000,000 + X ELF
   
   Attacker receives: `(1000 / 2000) * (1,000,000 + X) = ~500,000 ELF`
   Original beneficiaries: `(1000 / 2000) * (1,000,000 + X) = ~500,000 ELF`

**Success Condition:**
Attacker successfully captured 50% of pre-allocated profits by exploiting information leak, despite only joining at the same time as the contribution. Without the information leak, the attacker would not have known to register at that timing.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L37-44)
```csharp
    public override DistributedProfitsInfo GetDistributedProfitsInfo(SchemePeriod input)
    {
        var releasedProfitsVirtualAddress = GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
        return State.DistributedProfitsMap[releasedProfitsVirtualAddress] ?? new DistributedProfitsInfo
        {
            TotalShares = -1
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-712)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** test/AElf.Contracts.Profit.Tests/ProfitTests.cs (L148-158)
```csharp
            var distributedProfitsInfo = await creator.GetDistributedProfitsInfo.CallAsync(
                new SchemePeriod
                {
                    SchemeId = schemeId,
                    Period = 1
                });
            distributedProfitsInfo.AmountsMap[ProfitContractTestConstants.NativeTokenSymbol]
                .ShouldBe(distributingAmount);
            // total_Shares is 0 before releasing.
            distributedProfitsInfo.TotalShares.ShouldBe(0);
            distributedProfitsInfo.IsReleased.ShouldBe(false);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```
