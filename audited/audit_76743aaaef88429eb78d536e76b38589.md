### Title
Missing Symbol Validation in CreateScheme Allows Creation of Unusable TokenHolder Profit Schemes

### Summary
The `CreateScheme` function in TokenHolderContract fails to validate that the input symbol is non-empty and corresponds to a valid token. This allows creation of schemes with invalid symbols, which cause all subsequent `RegisterForProfits` calls to fail when they attempt to lock tokens, rendering the scheme permanently unusable and wasting users' transaction fees.

### Finding Description
The `CreateScheme` function directly stores the provided symbol without any validation: [1](#0-0) 

The function accepts a `CreateTokenHolderProfitSchemeInput` with a symbol field defined as: [2](#0-1) 

When users attempt to register for profits using `RegisterForProfits`, the function retrieves the scheme and attempts to lock tokens using the stored symbol: [3](#0-2) 

The MultiToken contract's `Lock` method validates the symbol and will fail with an assertion error if the symbol is empty, whitespace, or refers to a non-existent token: [4](#0-3) 

The `AssertValidToken` method checks whether the token exists: [5](#0-4) 

**Root Cause**: CreateScheme lacks input validation to ensure the symbol is valid before storing it in the scheme state.

**Why Existing Protections Fail**: While the Lock method properly validates symbols, this validation occurs too late—after the scheme has already been created and users have attempted to register. The scheme cannot be modified or fixed once created.

### Impact Explanation
**Operational DoS**: Schemes created with invalid symbols become permanently unusable. All users attempting to call `RegisterForProfits` will have their transactions fail with assertion errors from the Lock method.

**Resource Waste**: Users who attempt to register for profits with such schemes will waste transaction fees for failed transactions. They must pay gas costs even though the transaction ultimately fails during the lock operation.

**Affected Parties**: 
- Scheme managers who make input errors lose the ability to run a functional profit distribution scheme
- Users attempting to participate in such schemes waste gas fees on failed registration attempts
- The ecosystem suffers from unusable profit distribution infrastructure

**Severity Justification**: Medium severity because while it doesn't enable fund theft or system-wide failures, it creates a permanent DoS condition for individual schemes and wastes user resources. The impact is amplified by the fact that schemes cannot be updated or corrected once created.

### Likelihood Explanation
**Reachable Entry Point**: `CreateScheme` is a public method callable by any address without special permissions.

**Feasible Preconditions**: No special preconditions required. Any user can create a scheme for themselves as the manager.

**Execution Practicality**: Extremely simple to trigger—either accidentally through:
- Typo in symbol name (e.g., "ELF" vs "EFL")
- Empty string submission
- Using a symbol for a token not yet created

Or intentionally by a malicious actor to waste users' gas fees.

**Attack Complexity**: Very low. Simply call CreateScheme with an empty or invalid symbol string.

**Detection Constraints**: The issue only becomes apparent when users attempt to register. The scheme appears valid when queried, making it difficult for users to detect the problem before attempting registration.

**Probability**: Medium—while not economically rational as a targeted attack (scheme managers harm their own schemes), it's highly likely to occur through honest mistakes during scheme creation, especially in environments with multiple tokens or custom token deployments.

### Recommendation
Add symbol validation in the `CreateScheme` function before storing the scheme:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Validate symbol is not empty
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid symbol: cannot be empty.");
    
    // Validate token exists
    if (State.TokenContract.Value == null)
        State.TokenContract.Value = 
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = input.Symbol 
    });
    Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), 
        $"Token not found: {input.Symbol}");
    
    // Existing code continues...
}
```

**Test Cases to Add**:
1. Test creating scheme with empty string symbol—should fail
2. Test creating scheme with whitespace-only symbol—should fail  
3. Test creating scheme with non-existent token symbol—should fail
4. Test creating scheme with valid token symbol—should succeed

### Proof of Concept
**Initial State**: 
- Token "ELF" exists and is valid
- Token "INVALID" does not exist

**Attack Sequence**:
1. Attacker (or honest user) calls `CreateScheme` with:
   ```
   CreateTokenHolderProfitSchemeInput {
     Symbol = "",  // or "INVALID" or "   "
     MinimumLockMinutes = 1440
   }
   ```
   
2. Transaction succeeds, scheme is created and stored with invalid symbol

3. Victim user calls `RegisterForProfits` with:
   ```
   RegisterForProfitsInput {
     SchemeManager = [attacker_address],
     Amount = 1000
   }
   ```

4. Transaction reaches Lock call at line 159-165 of RegisterForProfits

5. MultiToken Lock method assertion fails at line 197 with "Invalid input symbol." or line 207 with "Token is not found."

6. User's transaction fails, gas fees are consumed, registration does not complete

**Expected Result**: CreateScheme should validate symbol and reject invalid symbols before creating the scheme

**Actual Result**: Scheme is created with invalid symbol, causing all subsequent RegisterForProfits calls to fail permanently

**Success Condition**: Multiple users attempt to register and all fail, wasting cumulative gas fees while the scheme remains unusable indefinitely

### Notes
The test suite does not include negative test cases for invalid symbols in CreateScheme: [6](#0-5) 

All existing tests use valid token symbols like "APP", "ELF", and "TEST", indicating this validation gap was not caught during testing.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-165)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L197-207)
```csharp
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-37)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L33-59)
```csharp
    [Fact]
    public async Task CreateTokenHolderProfitSchemeTest()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "APP"
        });

        {
            var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
            tokenHolderProfitScheme.Period.ShouldBe(0);
            tokenHolderProfitScheme.Symbol.ShouldBe("APP");
            tokenHolderProfitScheme.SchemeId.ShouldBeNull();
        }

        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 1
        });

        {
            var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
            tokenHolderProfitScheme.SchemeId.ShouldNotBeNull();
        }
    }
```
