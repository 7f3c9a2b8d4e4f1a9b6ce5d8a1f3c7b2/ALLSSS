### Title
NextRoundMiningOrderValidationProvider Fails to Detect Duplicate Mining Orders Due to Incorrect Round Validation and Ineffective Distinct() Call

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` contains two critical bugs that completely disable validation of duplicate `FinalOrderOfNextRound` values. First, it validates the wrong round (next round instead of current round), where `FinalOrderOfNextRound` is always 0. Second, even if the correct round were checked, calling `Distinct()` on `MinerInRound` objects fails to detect miners with duplicate order values. This allows malicious miners to create duplicate mining orders via `TuneOrderInformation`, breaking consensus integrity.

### Finding Description

The validation function attempts to ensure unique `FinalOrderOfNextRound` values: [1](#0-0) 

**Bug #1: Validates Wrong Round**

The validation checks `validationContext.ProvidedRound`, which for `NextRound` behavior contains the NEXT round's data structure: [2](#0-1) 

However, when generating the next round, new `MinerInRound` objects are created that do NOT copy `FinalOrderOfNextRound` values: [3](#0-2) 

In the next round, all miners have `FinalOrderOfNextRound = 0` (default) and `OutValue = null`, so the validation always checks `0 == 0` and passes. The validation should check `BaseRound` (current round) instead: [4](#0-3) 

**Bug #2: Distinct() on Wrong Type**

Even if Bug #1 were fixed, `Distinct()` operates on `MinerInRound` objects. Protobuf-generated classes implement value-based equality that compares ALL fields. Two miners with identical `FinalOrderOfNextRound` but different `Pubkey` or other fields are NOT considered duplicates. The validation should call `.Select(m => m.FinalOrderOfNextRound).Distinct()` to check order values.

**Attack Vector**

During `UpdateValue`, malicious miners can inject arbitrary `TuneOrderInformation` to assign duplicate orders: [5](#0-4) 

This code applies tuning WITHOUT any duplicate validation. The broken `NextRoundMiningOrderValidationProvider` fails to catch the duplicates, and `GenerateNextRoundInformation` orders miners by the corrupted values: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Breach (Critical)**

This vulnerability breaks the fundamental consensus invariant that mining orders must be unique. When `OrderBy()` processes duplicate `FinalOrderOfNextRound` values, the resulting order is undefined, leading to:

1. **Invalid Round Generation**: Miners may be skipped or assigned incorrect time slots
2. **Consensus Failure**: The next round may fail to produce blocks correctly
3. **DoS Attack**: An attacker can repeatedly corrupt mining orders, preventing proper block production
4. **Unfair Block Production**: Malicious miners can manipulate who produces blocks and when, potentially monopolizing block rewards

The attack affects ALL miners in the network and undermines the AEDPoS consensus mechanism's reliability. This violates the critical invariant: "Correct round transitions and miner schedule integrity."

### Likelihood Explanation

**High Likelihood - Easily Exploitable**

- **Reachable Entry Point**: Any miner can call `UpdateValue` with crafted `TuneOrderInformation` [7](#0-6) 

- **Minimal Preconditions**: Attacker only needs to be a current miner producing blocks
- **No Detection**: The broken validation ensures duplicates go undetected
- **Repeatable**: Attack can be executed in every round
- **Economic Viability**: Cost is negligible (normal block production cost), benefit is manipulating consensus

The validation is used during `NextRound` transitions: [8](#0-7) 

But provides zero protection due to both bugs.

### Recommendation

**Immediate Fix Required**

1. **Fix Bug #1**: Change validation to check `BaseRound` instead of `ProvidedRound`
2. **Fix Bug #2**: Extract `FinalOrderOfNextRound` values before calling `Distinct()`

Corrected implementation:
```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Fix Bug #1
    
    var minersWithOrder = baseRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .ToList();
    
    var distinctOrderCount = minersWithOrder
        .Select(m => m.FinalOrderOfNextRound) // Fix Bug #2
        .Distinct()
        .Count();
    
    var minersWhoMined = baseRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null);
    
    if (distinctOrderCount != minersWhoMined || distinctOrderCount != minersWithOrder.Count)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound - duplicates or count mismatch.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

3. **Add Validation in ProcessUpdateValue**: Validate `TuneOrderInformation` before applying:
   - Ensure all values are within valid range (1 to miner count)
   - Ensure no duplicate values
   - Ensure only existing miners are tuned

4. **Add Test Cases**: Create tests that verify duplicate order detection and rejection

### Proof of Concept

**Initial State**:
- Round 10 with 5 miners (A, B, C, D, E) who all produced blocks
- Miner A is next to produce a block with `UpdateValue`

**Attack Steps**:

1. Miner A crafts malicious `UpdateValueInput` with:
   ```
   TuneOrderInformation = {
     "MinerB": 1,
     "MinerC": 1,  // Duplicate!
     "MinerD": 2,
     "MinerE": 3
   }
   ```

2. Miner A's `UpdateValue` transaction executes:
   - Line 259-260 applies tuning without validation
   - Current round now has: B.FinalOrderOfNextRound=1, C.FinalOrderOfNextRound=1 (duplicate)

3. Extra block producer triggers `NextRound`:
   - `NextRoundMiningOrderValidationProvider` runs but checks next round where all FinalOrderOfNextRound=0
   - Validation passes: `0 == 0` âœ“

4. `GenerateNextRoundInformation` executes:
   - Line 26: `OrderBy(m => m.FinalOrderOfNextRound)` with duplicate values
   - Undefined ordering behavior - may skip Miner B or C

**Expected Result**: Validation should reject duplicate orders

**Actual Result**: Duplicate orders accepted, next round generation corrupted, consensus integrity compromised

**Notes**

The investigation revealed that `MinerInRound` is a protobuf-generated class that DOES implement value-based `Equals()`. However, this is irrelevant because the validation has two more fundamental bugs that render it completely ineffective. The validation checks the wrong round (where orders are always 0) and even if it checked the right round, comparing entire `MinerInRound` objects instead of their `FinalOrderOfNextRound` values fails to detect duplicates.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-22)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```
