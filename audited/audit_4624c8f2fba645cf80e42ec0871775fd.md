### Title
Replacement Miner Can Manipulate Mining Order Through Arbitrary PreviousInValue Injection

### Summary
When a replacement miner appears for the first time (replacing an evil miner), they can provide an arbitrary `PreviousInValue` in their trigger information that bypasses validation and is used to calculate their signature. Since the signature directly determines mining order in the next round, attackers can brute-force offline to find a value that places them first in the mining sequence, gaining unfair advantage and additional block rewards.

### Finding Description

**Location:** `GetConsensusExtraDataToPublishOutValue()` function in `AEDPoSContract_GetConsensusBlockExtraData.cs`

**Root Cause:** 
The validation logic for `PreviousInValue` only applies when a miner existed in the previous round. For replacement miners appearing for the first time, the validation is completely bypassed. [1](#0-0) 

When a miner provides `triggerInformation.PreviousInValue` (non-null, non-empty), the code attempts validation at lines 80-82. However, this validation only executes if `previousRound.RealTimeMinersInformation.ContainsKey(pubkey)` is true. For replacement miners who didn't exist in the previous round, this condition is false, causing the code to skip directly to the else block (lines 87-90) where the arbitrary value is accepted without any validation. [2](#0-1) 

The validation provider confirms this bypass: line 40 returns `true` immediately if the miner doesn't exist in the previous round, skipping all subsequent validation checks.

**Why Protections Fail:**
The intended design assumes replacement miners would fall through to lines 104-107 where a deterministic `fakePreviousInValue` is computed. However, an attacker can circumvent this by proactively providing a `PreviousInValue` in their trigger information, which causes the code to take the earlier path (lines 74-93) where validation is bypassed for new miners. [3](#0-2) 

The arbitrary `PreviousInValue` is then used to calculate the signature via `previousRound.CalculateSignature()`. [4](#0-3) 

The `CalculateSignature` function XORs the provided value with all signatures from the previous round, producing a signature value that appears legitimate but was actually crafted by the attacker. [5](#0-4) 

This signature directly determines the miner's order in the next round through modular arithmetic (line 21: `supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1`), allowing the attacker to manipulate their position.

### Impact Explanation

**Concrete Harm:**
1. **Mining Order Manipulation:** Attacker can choose their mining position in the next round, including order 1 (mining first)
2. **Extra Block Producer Selection:** In the first round of a new term, the first miner becomes the extra block producer, entitled to mine an additional block
3. **Reward Misallocation:** Extra blocks translate directly to additional mining rewards, creating unfair economic advantage
4. **Consensus Integrity Violation:** Breaks the randomness and fairness guarantees of the AEDPoS consensus mechanism

**Who Is Affected:**
- Honest miners lose fair competition for mining positions and associated rewards
- The protocol suffers from compromised consensus randomness
- Token holders face dilution from unfairly allocated mining rewards

**Severity Justification:** HIGH
- Direct financial impact through reward theft
- Breaks critical consensus invariant (miner schedule integrity)
- Exploitable with reasonable attacker capabilities
- No detection mechanism exists

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Must be selected as a replacement miner (replaces an evil miner who missed time slots)
2. Must be able to modify trigger information provided to consensus contract (achievable by modifying node software) [6](#0-5) 

The trigger information is constructed client-side by the miner's node. A malicious miner can modify their `AEDPoSTriggerInformationProvider` to inject crafted values.

**Attack Complexity:** LOW
- Brute-forcing favorable signatures requires only simple XOR operations and modular arithmetic
- All previous round signatures are publicly available on-chain
- Attacker can compute offline without time pressure
- Example: For 21 miners, attacker needs ~10-11 attempts on average to find order 1

**Feasibility Conditions:**
- Requires waiting to become a replacement miner (occurs when other miners are marked as evil)
- No special permissions beyond being an authorized candidate
- No timing constraints (can compute before their mining slot)

**Detection/Operational Constraints:**
- No validation exists to detect manipulated signatures for replacement miners
- Attack is indistinguishable from legitimate consensus data
- No on-chain mechanism to verify the randomness of PreviousInValue for new miners

**Probability:** MEDIUM-HIGH
Replacement of evil miners is a regular occurrence in the consensus protocol, providing repeated exploitation opportunities.

### Recommendation

**Immediate Fix:**
Add explicit validation for replacement miners in `GetConsensusExtraDataToPublishOutValue()`:

```csharp
// After line 75, add validation for replacement miners
if (triggerInformation.PreviousInValue != null &&
    triggerInformation.PreviousInValue != Hash.Empty)
{
    if (!previousRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Replacement miner should not provide PreviousInValue
        // Force them to use the deterministic fakePreviousInValue
        Context.LogDebug(() => "Replacement miner cannot provide arbitrary PreviousInValue");
        triggerInformation.PreviousInValue = Hash.Empty;
    }
    // ... existing validation code ...
}
```

**Invariant to Enforce:**
Replacement miners (those not in previous round) MUST use the deterministic `fakePreviousInValue` computed from `HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()))`. They MUST NOT be allowed to provide custom PreviousInValue values.

**Alternative Mitigation:**
Modify the validation provider to reject any PreviousInValue from miners who didn't exist in the previous round:

```csharp
// In UpdateValueValidationProvider.cs, line 40:
if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
{
    // Replacement miners must not have PreviousInValue set
    return extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null ||
           extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == Hash.Empty;
}
```

**Test Cases:**
1. Verify replacement miner with provided PreviousInValue is rejected
2. Verify replacement miner with null/empty PreviousInValue uses deterministic fake value
3. Verify existing miner with invalid PreviousInValue is rejected (existing behavior)
4. Verify signature calculation produces expected mining order distribution

### Proof of Concept

**Initial State:**
- Current round N has miner list [A, B, C, D, E]
- Miner E is marked as evil (missed time slots)
- Round N+1 will replace E with new miner X
- All signatures from round N are public on-chain

**Attack Steps:**

1. **Offline Computation:**
```
previousSignatures = XOR(sig_A, sig_B, sig_C, sig_D, sig_E) from round N
minersCount = 5

for testValue in range(0, 2^256):
    signature = XOR(testValue, previousSignatures)
    order = (signature % 5) + 1
    if order == 1:
        attackValue = testValue
        break
```

2. **Modified Trigger Information:**
Attacker modifies their node to provide:
```
AElfConsensusTriggerInformation {
    Pubkey = X's public key,
    InValue = <newly generated random value>,
    PreviousInValue = attackValue,  // <-- Crafted value
    Behaviour = UpdateValue
}
```

3. **Block Production:**
    - Attacker mines their block in round N+1 with crafted trigger info
    - Contract accepts PreviousInValue without validation (line 89)
    - Signature calculated as `XOR(attackValue, previousSignatures)` (line 92)
    - ApplyNormalConsensusData sets `SupposedOrderOfNextRound = 1` (lines 21, 42)

**Expected vs Actual Result:**

**Expected:** Replacement miner receives random/unpredictable mining order based on deterministic `fakePreviousInValue = Hash(pubkey + height)`

**Actual:** Replacement miner achieves order 1 in round N+2, mining first and potentially becoming extra block producer

**Success Condition:** 
In round N+2, miner X has `FinalOrderOfNextRound = 1` and mines before all other miners, demonstrating successful manipulation of mining order through arbitrary PreviousInValue injection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-93)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L41-75)
```csharp
    public BytesValue GetTriggerInformationForBlockHeaderExtraData(BytesValue consensusCommandBytes)
    {
        if (consensusCommandBytes == null)
            return new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                Behaviour = AElfConsensusBehaviour.UpdateValue
            }.ToBytesValue();

        var command = consensusCommandBytes.ToConsensusCommand();
        var hint = command.Hint.ToAElfConsensusHint();

        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
        }

        return new AElfConsensusTriggerInformation
        {
            Pubkey = Pubkey,
            Behaviour = hint.Behaviour
        }.ToBytesValue();
    }
```
