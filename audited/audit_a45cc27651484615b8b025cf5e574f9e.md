### Title
Consensus DoS via Non-Consecutive Miner Order Values in Round Validation

### Summary
The `CheckRoundTimeSlots()` validation function fails to verify that miner `Order` values are consecutive integers starting from 1. An attacker (extra block producer or valid miner) can submit a `NextRoundInput` with non-consecutive orders (e.g., 1, 10, 100) that passes validation but causes `IndexOutOfRangeException` when `GetMiningInterval()` is subsequently called, resulting in complete consensus halt.

### Finding Description

The root cause lies in insufficient validation within the `CheckRoundTimeSlots()` method: [1](#0-0) 

This method orders miners by their `Order` field and validates timestamps using array indexing, but crucially does NOT validate that `Order` values are the consecutive sequence 1, 2, 3, ..., N. It only checks that timestamps exist and intervals are consistent between adjacent array positions.

The vulnerability manifests when `GetMiningInterval()` is called on a malformed round: [2](#0-1) 

This method explicitly filters for miners with `Order == 1` or `Order == 2`, then accesses `firstTwoMiners[1]` without verifying the list contains two elements. If no miner has `Order == 2`, this throws `IndexOutOfRangeException`.

The attack path flows through the public `NextRound` method: [3](#0-2) 

Validation occurs via `TimeSlotValidationProvider`: [4](#0-3) 

For new rounds (line 14-18), only `CheckRoundTimeSlots()` is called. For existing rounds (line 20-30), `CheckMinerTimeSlot()` is called, which invokes `GetMiningInterval()`: [5](#0-4) 

Once the malformed round is accepted and stored: [6](#0-5) 

The stored malformed round becomes the `BaseRound` for subsequent block validations, triggering the exception.

### Impact Explanation

**Concrete Harm**: Complete consensus halt. Once a malformed round is stored, all subsequent block production attempts in that round fail validation with `IndexOutOfRangeException`, preventing any blocks from being produced or transactions from being processed.

**Protocol Damage**: The blockchain becomes non-operational. No new blocks can be added, no transactions can be executed, and the chain cannot progress until manual intervention (likely requiring emergency upgrades or chain rollback).

**Affected Parties**: All network participants - miners cannot produce blocks, users cannot submit transactions, dApps become non-functional, and the entire ecosystem is disrupted.

**Severity Justification**: HIGH - This is a complete denial-of-service vulnerability affecting the core consensus mechanism. It requires only a single malicious transaction from a valid miner (specifically the extra block producer) to permanently halt the chain within one round transition.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be a valid miner with permission to call `NextRound()` - specifically, they must be the extra block producer of the current round. This is not a completely open attack (requires being a miner), but is realistic given that:
1. Multiple miners exist in the network
2. The extra block producer role rotates among miners
3. A compromised or malicious miner can execute this attack

**Attack Complexity**: LOW - The attacker simply needs to:
1. Generate a valid `NextRoundInput` via `GenerateConsensusTransactions` (view method)
2. Modify the `Order` values to be non-consecutive (e.g., change orders from [1,2,3] to [1,10,100])
3. Keep all `ExpectedMiningTime` values in ascending order to pass timestamp validation
4. Submit the modified input to `NextRound()`

**Feasibility Conditions**: 
- Attacker must be the designated extra block producer for the current round
- No additional economic cost beyond normal transaction fees
- Single transaction execution required

**Detection Constraints**: The attack is stealthy - the malicious round passes validation and is stored successfully. The consensus DoS only manifests when the next block attempts validation, making forensic analysis difficult.

**Probability**: MEDIUM-HIGH - While requiring miner-level access, the attack is trivial to execute once that access is obtained, and the impact is immediate and severe.

### Recommendation

**Code-Level Mitigation**: Add explicit validation in `CheckRoundTimeSlots()` to ensure `Order` values form a consecutive sequence from 1 to N:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    // NEW: Validate Order values are consecutive starting from 1
    for (var i = 0; i < miners.Count; i++)
    {
        if (miners[i].Order != i + 1)
            return new ValidationResult { Message = $"Invalid miner order sequence. Expected {i + 1}, got {miners[i].Order}" };
    }

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
    
    // ... rest of existing validation
}
```

**Invariant Checks**: 
1. All `Order` values in `RealTimeMinersInformation` must be unique
2. `Order` values must be exactly the set {1, 2, 3, ..., N} where N is the miner count
3. No gaps or duplicates allowed in the sequence

**Test Cases**:
1. Test `NextRoundInput` with non-consecutive orders (e.g., [1, 10, 100])
2. Test with duplicate orders (e.g., [1, 2, 2, 3])
3. Test with orders not starting from 1 (e.g., [2, 3, 4])
4. Test with negative or zero orders
5. Verify all cases are rejected during validation

### Proof of Concept

**Required Initial State**:
- Active AEDPoS consensus with N miners (e.g., N=3)
- Attacker is the extra block producer of current round R
- Current round has properly ordered miners with Order values [1, 2, 3]

**Attack Steps**:
1. Attacker calls view method to generate proper `NextRoundInput` for round R+1
2. Attacker modifies the returned `NextRoundInput`:
   - Miner A: Order = 1, ExpectedMiningTime = T
   - Miner B: Order = 10, ExpectedMiningTime = T + 4000ms
   - Miner C: Order = 100, ExpectedMiningTime = T + 8000ms
3. Attacker submits modified `NextRoundInput` to `NextRound()`
4. Validation executes `CheckRoundTimeSlots()`:
   - Sorts by Order: [Miner A (Order=1), Miner B (Order=10), Miner C (Order=100)]
   - Uses array indices to validate timestamps
   - Validation PASSES
5. Malformed round R+1 is stored to state
6. Next miner attempts to produce block in round R+1 via `UpdateValue()`
7. Validation calls `CheckMinerTimeSlot()` on BaseRound (R+1)
8. `GetMiningInterval()` filters for "Order == 1 || Order == 2"
9. Only Miner A (Order=1) matches, `firstTwoMiners` has 1 element
10. Code attempts `firstTwoMiners[1]` â†’ `IndexOutOfRangeException`
11. Block validation fails

**Expected vs Actual**:
- Expected: Validation rejects non-consecutive Order values
- Actual: Validation passes, consensus halts on subsequent block

**Success Condition**: After step 10, no further blocks can be produced in round R+1, and consensus is permanently halted until manual intervention.

### Notes

The vulnerability specifically targets the gap between validation logic (which uses sorted array indices) and consumption logic (which assumes specific Order values exist). The `GenerateNextRoundInformation` method internally generates correct consecutive orders, but this is bypassed when miners directly submit `NextRoundInput` parameters. The same vulnerability potentially affects `NextTermInput` through identical validation paths.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```
