### Title
Integer Overflow in GetBaseFeeDictionary Allows Fee Bypass via LINQ Sum() Wrapping

### Summary
When multiple `MethodFee` entries with the same symbol are set via `SetMethodFee`, their `BasicFee` values are summed using LINQ's `Sum()` method. If these values exceed `Int64.MaxValue`, the unprotected LINQ operation wraps to a negative value. The fee charging logic then treats this negative amount as "satisfied by allowance," adds zero to the transaction bill, and skips the actual balance deduction, allowing transactions to execute with zero fees charged.

### Finding Description

**Vulnerable Code Flow:**

1. **SetMethodFee accepts multiple fees per symbol** [1](#0-0) 

2. **GetBaseFeeDictionary sums BasicFee values using LINQ Sum()** [2](#0-1) 

3. **SafeMath IL Patcher only patches contract module, not framework methods** [3](#0-2)  and [4](#0-3) 

The IL patcher iterates only through `module.GetAllTypes()` in the contract module. LINQ's `Sum()` is in `System.Linq.Enumerable` (framework assembly), so its internal Add operations are NOT patched with overflow checks.

4. **Negative amounts pass TryToChargeUserBaseFee checks** [5](#0-4) 

When `amount` is negative (e.g., -2), the condition `existingAllowance >= amount` evaluates to `0 >= -2` which is TRUE, causing the method to return success.

5. **ChargeBaseFee adds zero to the bill for negative amounts** [6](#0-5) 

When `existingAllowance > amountToChargeBaseFee` (i.e., `0 > -2`), it adds the negative amount to allowance bill and **zero** to the fee bill.

6. **ModifyBalance skips charging for zero/negative amounts** [7](#0-6) 

The condition `if (amount <= 0) continue;` skips the actual balance deduction when amount is zero or negative.

**Root Cause:** The `GroupBy().Sum()` pattern in GetBaseFeeDictionary uses LINQ's Sum() which performs unchecked arithmetic. Since the SafeMath IL patcher only patches the contract module and not referenced framework assemblies, overflow silently wraps to negative values instead of throwing an exception.

### Impact Explanation

**Direct Fund Impact:**
- **Complete fee bypass**: Any method configured with overflowing fees can be called with ZERO transaction fees charged
- **System-wide revenue loss**: If applied to high-volume methods (e.g., `Transfer`, `Approve`), the blockchain loses ALL transaction fee revenue for those methods
- **Economic model breakdown**: Transaction fees fund consensus rewards, treasury, and network sustainability

**Affected Parties:**
- **Network validators**: Loss of expected fee rewards
- **Treasury**: Loss of fee-based funding
- **Token economics**: Inflation not offset by burn/fees

**Severity:** HIGH - This bypasses a critical invariant (token supply & fees) and enables unlimited free transactions for any method with maliciously configured fees.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Authority to call `SetMethodFee` on target contract
- Default controller is Parliament's default organization requiring 2/3 Block Producer approval [8](#0-7) 

**Attack Scenarios:**
1. **Malicious governance**: Compromised Block Producer supermajority or collusion
2. **Initial deployment attack**: Deployer sets malicious fees before transferring control
3. **Side chain attack**: Side chain governance may have weaker security assumptions

**Execution Complexity:** LOW
- Simply set two `MethodFee` entries with same symbol, each with `BasicFee = Int64.MaxValue`
- `Int64.MaxValue + Int64.MaxValue = -2` (wraps to negative)
- No additional exploitation steps needed

**Detection:** DIFFICULT
- Fees appear "set" in contract state
- Only manifests during actual fee charging
- Transaction logs show successful execution but zero fees charged
- Requires analysis of `TransactionFeeCharged` events to detect anomaly

### Recommendation

**Immediate Fix:**

Add overflow validation in `SetMethodFee` to prevent summing to overflow:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    
    // NEW: Validate no overflow when summing duplicate symbols
    var feesBySymbol = input.Fees.GroupBy(f => f.Symbol);
    foreach (var group in feesBySymbol)
    {
        long total = 0;
        foreach (var fee in group)
        {
            Assert(total <= long.MaxValue - fee.BasicFee, 
                   $"Total fees for symbol {group.Key} would overflow Int64.MaxValue");
            total = total.Add(fee.BasicFee); // Use SafeMath
        }
    }
    
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
           "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

**Alternative Fix:**

Replace LINQ Sum() with SafeMath accumulation in GetBaseFeeDictionary:

```csharp
private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
{
    var result = new Dictionary<string, long>();
    foreach (var fee in methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol)))
    {
        if (!result.ContainsKey(fee.Symbol))
            result[fee.Symbol] = 0;
        result[fee.Symbol] = result[fee.Symbol].Add(fee.BasicFee); // SafeMath throws on overflow
    }
    return result;
}
```

**Test Cases:**

1. Test setting multiple fees with same symbol that sum to `Int64.MaxValue + 1`
2. Verify SetMethodFee rejects with overflow error
3. Test fee charging behavior with maximum safe values
4. Add regression test for Set_Repeat_Token_Test with overflow values

### Proof of Concept

**Initial State:**
- Parliament governance has 2/3 BP control over SetMethodFee
- Target contract (e.g., MultiToken) has default method fees

**Attack Steps:**

1. **Create malicious proposal:**
   ```
   CreateProposal {
     ToAddress: MultiTokenContract,
     MethodName: "SetMethodFee",
     Params: MethodFees {
       MethodName: "Transfer",
       Fees: [
         MethodFee { Symbol: "ELF", BasicFee: 9223372036854775807 }, // Int64.MaxValue
         MethodFee { Symbol: "ELF", BasicFee: 9223372036854775807 }  // Int64.MaxValue
       ]
     }
   }
   ```

2. **Get BP approval and release proposal** [1](#0-0) 

3. **User calls Transfer:**
   - `ChargeTransactionFees` invoked pre-execution
   - `GetBaseFeeDictionary` computes: `9223372036854775807 + 9223372036854775807 = -2` (overflow wrap)
   - `TryToChargeUserBaseFee` sees negative amount, evaluates `0 >= -2` â†’ TRUE
   - `ChargeBaseFee` adds 0 to bill
   - `ModifyBalance` skips deduction (`0 <= 0`)
   - Transfer executes successfully with ZERO fees charged

**Expected Result:** Transfer should fail due to overflow exception or charge correct fees

**Actual Result:** Transfer succeeds with zero fees charged, user balance unchanged except for transfer amount

**Success Condition:** `TransactionFeeCharged` event shows Amount = 0, user balance reduction equals only transfer amount (no fee deduction)

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-255)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L358-364)
```csharp
        // Succeed to charge, freeAllowance first.
        if (existingAllowance > amountToChargeBaseFee)
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee);
            // free fee allowance has covered fee, add 0 for size fee
            bill.FeesMap.Add(symbolToChargeBaseFee, 0);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L772-777)
```csharp
            // allowance is enough to cover the base fee
            if (existingAllowance >= amount)
            {
                symbolOfValidBalance = symbol;
                return true;
            }
```

**File:** src/AElf.CSharp.CodeOps/Patchers/Module/SafeMath/Patcher.cs (L14-47)
```csharp
    // Replace unchecked math OpCodes with checked OpCodes (overflow throws exception)
    private static readonly Dictionary<OpCode, OpCode> PlainToCheckedOpCodes = new()
    {
        {OpCodes.Add, OpCodes.Add_Ovf},
        {OpCodes.Sub, OpCodes.Sub_Ovf},
        {OpCodes.Mul, OpCodes.Mul_Ovf}
    };

    public bool SystemContactIgnored => false;

    public void Patch(ModuleDefinition module)
    {
        foreach (var method in module.GetAllTypes().SelectMany(t => t.Methods))
        {
            PatchMethod(method);
        }
    }

    private void PatchMethod(MethodDefinition method)
    {
        if (!method.HasBody)
            return;

        var processor = method.Body.GetILProcessor();
        processor.Body.SimplifyMacros();
        // Note: We have to convert it to List before iterating, otherwise it will be problematic when we iterate while rewriting
        var instructions = method.Body.Instructions.Where(i => PlainToCheckedOpCodes.ContainsKey(i.OpCode)).ToList();
        foreach (var instruction in instructions)
        {
            var checkedInstruction = processor.Create(PlainToCheckedOpCodes[instruction.OpCode]);
            processor.Replace(instruction, checkedInstruction);
        }
        processor.Body.OptimizeMacros();
    }
```

**File:** src/AElf.CSharp.CodeOps/CSharpContractPatcher.cs (L19-26)
```csharp
    public byte[] Patch(byte[] code, bool isSystemContract)
    {
        var assemblyDef = AssemblyDefinition.ReadAssembly(new MemoryStream(code));
        Patch(assemblyDef.MainModule, isSystemContract);
        var newCode = new MemoryStream();
        assemblyDef.Write(newCode);
        return newCode.ToArray();
    }
```
