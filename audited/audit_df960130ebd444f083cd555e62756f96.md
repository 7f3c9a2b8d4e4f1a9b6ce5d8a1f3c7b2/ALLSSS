### Title
Governance Bypass via Malicious Contract in ChangeMethodFeeController - Cross-Contract Validation Vulnerability

### Summary
The `ChangeMethodFeeController` function in the Configuration contract (and all ACS1-implementing contracts) accepts an arbitrary contract address for organization validation without verifying it is a legitimate governance contract. An attacker controlling the current governance organization can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, then pass a proposal to set this as the new controller with an EOA as `OwnerAddress`, permanently bypassing all governance requirements for method fee management.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The `CheckOrganizationExist` helper method makes a cross-contract call to an untrusted address provided by the caller: [2](#0-1) 

The function calls `ValidateOrganizationExist` on `authorityInfo.ContractAddress` without validating that this address is one of the legitimate system governance contracts (Parliament, Association, or Referendum). The legitimate implementations simply check state storage: [3](#0-2) [4](#0-3) 

**Why Protections Fail**: 

1. Line 26 only validates the caller is the current controller's `OwnerAddress`, which is satisfied when executing through a governance proposal
2. Line 27-28 only validates that the organization "exists" according to the provided contract, but doesn't validate the contract itself is legitimate
3. The system has validation methods available (`ValidateSystemContractAddress` in Genesis contract and `GetSystemContractNameToAddressMapping`) but they are not used here: [5](#0-4) [6](#0-5) 

**Attack Execution Path**:

1. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` that always returns `new BoolValue { Value = true }`
2. Attacker controls or compromises the current governance organization (e.g., Parliament's default organization)
3. Creates a governance proposal to call `ChangeMethodFeeController` with:
   - `ContractAddress`: malicious contract address
   - `OwnerAddress`: attacker's EOA (externally owned account)
4. Proposal is approved and released through normal governance
5. Malicious contract's `ValidateOrganizationExist` returns `true`, validation passes
6. Controller is set to the fake authority (line 30)
7. Attacker can now directly call `SetMethodFee` (line 17 only checks `Context.Sender == OwnerAddress`): [7](#0-6) 

### Impact Explanation

**Governance Bypass**: Once the controller is set to an EOA-based fake authority, the attacker gains permanent control over method fee configuration without requiring any governance approval.

**Direct Harm**:
- Attacker can set arbitrary transaction fees for all contract methods, potentially:
  - Setting fees to maximum values causing DoS of critical contract functions
  - Setting fees to zero for exploitation of fee-dependent security mechanisms
  - Extracting economic value through asymmetric fee structures

**System-Wide Scope**: This vulnerability affects ALL ACS1-implementing contracts across the system:
- Configuration contract (audited file)
- MultiToken contract: [8](#0-7) 
- Parliament, Association, Referendum governance contracts
- Consensus, Economic, CrossChain, Election, Profit, Treasury, TokenConverter, TokenHolder, Vote contracts (all implement same vulnerable pattern)

**Persistence**: The attacker maintains control indefinitely unless they voluntarily transfer it, as they control both the validation contract and the owner address.

**Affected Parties**: All protocol users, as method fees affect every transaction interaction with the compromised contracts.

### Likelihood Explanation

**Preconditions**:
- Attacker must initially control or compromise the current governance organization (e.g., gain majority in Parliament default organization)
- This is the primary barrier but is within realistic threat models (governance attacks, insider threats, or gradual accumulation of voting power)

**Execution Complexity**: LOW
- Deploy malicious contract (trivial - any contract with single function returning `true`)
- Create governance proposal (standard process)
- Pass proposal through compromised governance (already assumed in precondition)
- No complex timing, race conditions, or multi-step coordination required

**Detection Difficulty**: HIGH
- Proposal appears as legitimate governance action to change controller
- No on-chain mechanism validates contract legitimacy
- Tests only verify invalid organization addresses, not invalid contract addresses: [9](#0-8) 

**Economic Rationality**: 
- Attack cost: Contract deployment + governance process costs (low)
- Attack benefit: Permanent control over fee structures affecting all users (high)
- Risk/reward ratio strongly favors exploitation

**Feasibility Assessment**: Once governance is compromised (the realistic precondition), execution is straightforward and virtually guaranteed to succeed due to lack of contract address validation.

### Recommendation

**Immediate Fix**: Add validation that `ContractAddress` is a legitimate governance contract before making the cross-contract call.

**Code-Level Mitigation**:

Modify `CheckOrganizationExist` method to validate the contract address:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate the contract address is a known governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isParliament = authorityInfo.ContractAddress == systemContracts[SmartContractConstants.ParliamentContractSystemHashName];
    var isAssociation = authorityInfo.ContractAddress == systemContracts[SmartContractConstants.AssociationContractSystemHashName];
    var isReferendum = authorityInfo.ContractAddress == systemContracts[SmartContractConstants.ReferendumContractSystemHashName];
    
    Assert(isParliament || isAssociation || isReferendum, "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant to Enforce**: `AuthorityInfo.ContractAddress` MUST be one of the three system governance contracts (Parliament, Association, or Referendum) for all controller changes.

**Required Test Cases**:
1. Test `ChangeMethodFeeController` with non-governance contract address (should fail)
2. Test `ChangeMethodFeeController` with random address (should fail)
3. Test `ChangeMethodFeeController` with EOA address (should fail)
4. Verify only Parliament, Association, and Referendum addresses are accepted

**Apply Fix System-Wide**: This same validation must be added to all ACS1-implementing contracts (Token, Consensus, Parliament, Association, Referendum, Economic, CrossChain, Election, Profit, Treasury, TokenConverter, TokenHolder, Vote contracts).

### Proof of Concept

**Initial State**:
- Configuration contract deployed with default controller (Parliament default organization)
- Attacker controls majority of Parliament default organization members

**Attack Steps**:

1. **Deploy Malicious Contract**:
```csharp
public class MaliciousGovernance : MaliciousGovernanceContainer.MaliciousGovernanceBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Proposal**: Call Parliament's `CreateProposal` to propose calling Configuration's `ChangeMethodFeeController` with:
```
AuthorityInfo {
    ContractAddress: <malicious_contract_address>,
    OwnerAddress: <attacker_EOA>
}
```

3. **Approve Proposal**: Use controlled Parliament members to approve proposal

4. **Release Proposal**: Execute `Release` - triggers `ChangeMethodFeeController`

5. **Verify Bypass**: Direct call from attacker's EOA to `SetMethodFee` succeeds without governance:
```
ConfigurationContract.SetMethodFee(new MethodFees { ... })
// Sender: attacker_EOA
// Expected: Transaction fails (governance required)
// Actual: Transaction succeeds (governance bypassed)
```

**Success Condition**: Attacker can directly set method fees without creating/approving any governance proposals, demonstrating permanent governance bypass.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L11-21)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L23-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L72-77)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L196-203)
```csharp
    private void AssertSystemContractOrLockWhiteListAddress(string symbol)
    {
        var symbolState = State.LockWhiteLists[symbol];
        var isInWhiteList = symbolState != null && symbolState[Context.Sender];
        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Values;
        var isSystemContractAddress = systemContractAddresses.Contains(Context.Sender);
        Assert(isInWhiteList || isSystemContractAddress, "No Permission.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** test/AElf.Contracts.Configuration.Tests/ConfigurationContractTest.cs (L284-299)
```csharp
        // Invalid organization address
        var methodFeeController = await GetMethodFeeController(ConfigurationContractAddress);
        const string proposalCreationMethodName =
            nameof(MethodFeeProviderContractContainer.MethodFeeProviderContractStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = SampleAddress.AddressList[4],
                ContractAddress = methodFeeController.ContractAddress
            });
        await ApproveWithMinersAsync(proposalId);
        var txResult2 = await ReleaseProposalAsync(proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Failed);
        txResult2.Error.Contains("Invalid authority input.").ShouldBeTrue();
    }
```
