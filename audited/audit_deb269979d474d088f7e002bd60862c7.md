### Title
ProposerWhiteList Size Not Bounded - Denial of Service on Proposal Creation

### Summary
The Association contract does not enforce a maximum size limit on `ProposerWhiteList` during organization creation, allowing an attacker to create an organization with thousands of addresses (up to ~14,000 before hitting branch count limits). This causes the `Contains()` authorization check in `CreateProposal` to perform expensive O(n) linear searches, potentially causing legitimate proposers to hit execution limits or experience severe performance degradation when creating proposals.

### Finding Description

The vulnerability exists in the organization validation logic at: [1](#0-0) 

The `Validate()` method only checks that `ProposerWhiteList` is not empty and contains no duplicates, but does not enforce any maximum size: [2](#0-1) 

When `CreateProposal` is called, it invokes: [3](#0-2) 

Which calls the authorization check: [4](#0-3) 

The `Contains()` method performs a linear O(n) search through the entire list: [5](#0-4) 

**Why existing protections fail:**

1. **Transaction size limit (5MB)** allows ~150,000 addresses to fit in a single transaction [6](#0-5) 

2. **Branch counter (15,000 limit)** prevents extremely large lists during `AnyDuplicate()` validation at creation time, but an attacker can use ~10,000-14,000 addresses to stay under this limit [7](#0-6) 

3. The `AnyDuplicate()` check uses `GroupBy()` which counts toward the branch limit, constraining organization creation to ~14,000 addresses maximum: [8](#0-7) 

4. However, this still allows creation of organizations with 10,000+ addresses in the whitelist, making every subsequent `CreateProposal` call extremely expensive.

### Impact Explanation

**Operational Impact - Governance DoS:**
- Legitimate proposers authorized in the whitelist cannot effectively create proposals
- Each `CreateProposal` call must iterate through potentially 10,000+ addresses
- If the proposer's address is near the end of the list, the transaction may hit the 15,000 branch count limit and fail
- Even if within limits, the expensive O(n) operation causes severe performance degradation

**Who is affected:**
- All legitimate proposers in organizations with bloated whitelists
- Governance processes that depend on these organizations
- The organization itself becomes effectively unusable for proposal creation

**Severity justification:**
Medium severity because:
- Direct DoS of governance functionality
- Affects proposal creation (core governance operation)
- Limited to ~10,000-14,000 addresses (not millions) due to branch counter
- Attacker cost is relatively low (one organization creation transaction)
- No fund theft, but breaks governance operations

### Likelihood Explanation

**Attacker capabilities required:**
- Ability to call `CreateOrganization` (public method, no restrictions)
- Ability to generate 10,000-14,000 unique addresses (trivial)
- Pay transaction fee for organization creation with large input

**Attack complexity:** LOW
1. Generate 10,000-14,000 unique addresses
2. Create organization with these addresses in `ProposerWhiteList`
3. Include one or more legitimate users in the whitelist
4. Legitimate users cannot create proposals efficiently

**Feasibility conditions:**
- No special permissions required
- Works on any Association organization
- Constrained by branch counter (cannot exceed ~14,000 addresses)
- Transaction size limit allows up to ~150,000 addresses, but branch counter during validation prevents this

**Economic rationality:**
- Cost: Single organization creation transaction fee
- Benefit: DoS legitimate governance operations
- Griefing attack with minimal cost to attacker

**Probability:** HIGH
The attack is straightforward and requires no special privileges. The only constraint is the branch counter during organization creation.

### Recommendation

**Immediate fix:**
Add a maximum size constraint for `ProposerWhiteList` in the `Validate()` method:

```csharp
private bool Validate(Organization organization)
{
    const int MaxProposerWhiteListSize = 100; // Reasonable limit
    const int MaxOrganizationMemberListSize = 100; // Reasonable limit
    
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.Count() > MaxProposerWhiteListSize ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.Count() > MaxOrganizationMemberListSize ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    // ... rest of validation
}
```

**Alternative optimization:**
Replace linear search with hash-based lookup by storing `ProposerWhiteList` in a different data structure during organization creation, though this requires state schema changes.

**Test cases to add:**
1. Test organization creation with 1,000+ addresses in ProposerWhiteList (should fail)
2. Test CreateProposal performance with various whitelist sizes
3. Verify branch counter behavior with large whitelist iterations

### Proof of Concept

**Initial state:**
- Attacker has sufficient tokens for transaction fees
- Attacker can generate 12,000 unique addresses

**Attack steps:**

1. Attacker generates 12,000 unique addresses + includes legitimate proposer address
2. Attacker calls `CreateOrganization` with:
   - `ProposerWhiteList`: 12,001 addresses (12,000 fake + 1 legitimate)
   - `OrganizationMemberList`: 3 addresses (minimal required)
   - Valid thresholds

3. Organization creation succeeds (under 15,000 branch limit for `AnyDuplicate()` check)

4. Legitimate proposer (whose address is at position 12,000) attempts to call `CreateProposal`

5. `AssertIsAuthorizedProposer()` calls `Contains()` which iterates through 12,000 addresses

**Expected result:**
Proposal created successfully

**Actual result:**
- Transaction takes excessive computational resources
- May fail if approaching 15,000 branch count limit
- Even if successful, creates significant griefing/performance issues
- If proposer is near end of list and combined with other operations, could exceed branch limit

**Success condition:**
Transaction either fails with `RuntimeBranchThresholdExceededException` or completes with abnormally high execution cost, demonstrating DoS condition.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-111)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L19-22)
```csharp
    public static bool AnyDuplicate(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Proposers.GroupBy(p => p).Any(g => g.Count() > 1);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L29-32)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L13-15)
```text
- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```
