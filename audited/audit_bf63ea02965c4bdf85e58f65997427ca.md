# Audit Report

## Title
Emergency Response Organization Thresholds Require Higher Than Intended Approval Rate Due to Integer Rounding

## Summary
The hardcoded emergency response organization thresholds use fixed-point arithmetic with the value 9000 (intended to represent 90%), but integer rounding in the approval calculation formula causes the actual requirement to be 94.12% for the default 17-member parliament. For parliaments smaller than 10 members, it requires 100% approval, eliminating fault tolerance entirely. This design flaw reduces the system's ability to respond to security emergencies.

## Finding Description

The emergency response organization is created with hardcoded approval thresholds: [1](#0-0) 

The threshold system uses fixed-point arithmetic where 10000 represents 100%: [2](#0-1) 

The approval check formula creates the rounding issue: [3](#0-2) 

**Root Cause:** The formula `approvedMemberCount * 10000 >= 9000 * parliamentMembers.Count` requires ceiling behavior for approval counts. For 17 members: `approvedMemberCount >= 153000 / 10000 = 15.3`, which rounds up to 16 (94.12%), not 15 (88.24%).

**Mathematical Proof:**
- **17 members (default)**: Requires 16/17 = 94.12% instead of 90%
- **9 members**: Requires 9/9 = 100% instead of 90%
- **5 members**: Requires 5/5 = 100% instead of 90%

The default parliament size is 17 miners: [4](#0-3) 

Parliament members are the current miner list: [5](#0-4) 

The validation method fails to detect this issue because it only checks threshold sum constraints, not actual percentage behavior: [6](#0-5) 

**Cannot Self-Correct:** Changing thresholds requires the organization to approve changes to itself, creating a circular dependency: [7](#0-6) 

The emergency organization can only be created once: [8](#0-7) 

## Impact Explanation

**High Severity - Governance Availability Degradation**

The emergency response organization is used for critical security operations, specifically removing malicious nodes: [9](#0-8) 

**Concrete Harms:**
1. **Default Configuration (17 members)**: Requires 94.12% approval instead of intended 90%, reducing fault tolerance from 1.7 dissenting/offline members to just 1 member. If 2 miners are unavailable during an emergency (11.8% unavailability), critical security responses are blocked.

2. **Small Parliaments (<10 members)**: Require unanimous approval (100%), creating single points of failure where one offline/dissenting node blocks all emergency actions.

3. **Emergency Response Degradation**: During security incidents requiring rapid malicious node removal, the higher threshold increases response time and may allow attackers to remain active longer than intended.

4. **Irreversible**: The circular dependency (requiring approval under broken thresholds to fix thresholds) and single-creation constraint prevent correction without a network upgrade.

**Who is Affected:**
- Network operators responding to security incidents
- Honest miners attempting to remove compromised nodes
- Overall blockchain security during active attacks

## Likelihood Explanation

**Certainty: 100%** - This is a deterministic design flaw, not an attack scenario.

**Triggering Conditions:**
- Automatically manifests when emergency organization is created
- Default 17-member parliament guarantees 94.12% requirement
- No attacker action needed
- No preconditions beyond normal operation

**Real-World Scenario:** 
A node is compromised and begins malicious behavior. The emergency response organization creates a proposal to remove it via `RemoveEvilNode`. Of the 17 parliament members, 15 vote to approve (88.2% support). However, the proposal fails because 16 approvals (94.12%) are required. The compromised node (potentially one of the 17 members) remains active, continuing malicious activity that should have been stopped at the intended 90% threshold.

## Recommendation

**Option 1: Adjust Threshold Values**
Change the emergency organization thresholds to account for the ceiling behavior. For a 17-member parliament to achieve actual 90% behavior, use threshold value 8823 (requires 15/17 = 88.24%, close to 90%).

**Option 2: Change Comparison Operator**
Modify the approval check to use strict greater-than (`>`) instead of greater-than-or-equal (`>=`) with adjusted threshold values to achieve proper rounding behavior.

**Option 3: Enhanced Validation**
Add validation in the `Validate()` method to check that thresholds produce expected percentage behavior for common parliament sizes (e.g., 3, 5, 7, 9, 11, 13, 15, 17, 19) and warn if ceiling effects cause significant deviation from intended percentages.

**Immediate Mitigation:**
Document this behavior and adjust operational expectations for emergency response procedures to account for the actual 94.12% requirement for 17-member parliaments.

## Proof of Concept

```csharp
// Mathematical proof demonstrating the rounding issue
// For 17-member parliament with MinimalApprovalThreshold = 9000:

int approvedMemberCount = 15;  // 88.2% of 17
int parliamentMembersCount = 17;
int minimalApprovalThreshold = 9000;
int abstractVoteTotal = 10000;

// Current formula from CheckEnoughVoteAndApprovals:
bool isApprovalEnough = approvedMemberCount * abstractVoteTotal >= 
                       minimalApprovalThreshold * parliamentMembersCount;
// Result: 15 * 10000 = 150000 < 153000 (9000 * 17) → FALSE

approvedMemberCount = 16;  // 94.12% of 17
isApprovalEnough = approvedMemberCount * abstractVoteTotal >= 
                  minimalApprovalThreshold * parliamentMembersCount;
// Result: 16 * 10000 = 160000 >= 153000 → TRUE

// This proves that despite 9000 representing "90%", 
// the actual requirement is 16/17 = 94.12%
```

**Test demonstrating the issue exists in test suite:** [10](#0-9) 

Note that the test calls `Approve` for ALL parliament members (line 160), implicitly acknowledging that near-unanimous approval is needed for the emergency organization despite the nominal 90% threshold.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L83-86)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-159)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L203-210)
```csharp
    public override Empty CreateEmergencyResponseOrganization(Empty input)
    {
        Assert(State.EmergencyResponseOrganizationAddress.Value == null,
            "Emergency Response Organization already exists.");
        AssertSenderAddressWith(State.DefaultOrganizationAddress.Value);
        CreateEmergencyResponseOrganization();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Economic.AEDPoSExtension.Tests/EvilNodeRelatedTests.cs (L150-165)
```csharp

```
