### Title
Division by Zero in Consensus Miner Count Calculation Due to Insufficient MinerIncreaseInterval Validation

### Summary
The `SetMinerIncreaseInterval()` function contains a backwards validation check that allows the `MinerIncreaseInterval` to be set to zero or negative values through governance action. This causes deterministic division-by-zero exceptions in critical consensus operations, resulting in complete blockchain halt during round processing and term transitions.

### Finding Description

The root cause is an incorrect validation assertion in the `SetMinerIncreaseInterval()` function: [1](#0-0) 

The assertion at line 61 checks `input.Value <= State.MinerIncreaseInterval.Value`, which only enforces that new values must be less than or equal to the current value. This allows the interval to be **decreased** indefinitely, including to zero or negative values, but provides no lower bound validation.

The `MinerIncreaseInterval` is initialized with a default value of 31,536,000 seconds (1 year): [2](#0-1) [3](#0-2) 

Once set to zero through governance, the value is used as a divisor in two critical locations:

**Location 1 - Public view method:** [4](#0-3) 

**Location 2 - Internal consensus calculation:** [5](#0-4) 

The `Div()` extension method throws `DivideByZeroException` when the divisor is zero: [6](#0-5) [7](#0-6) 

These division operations are called during critical consensus operations:

**During first round processing:** [8](#0-7) 

**During term transitions:** [9](#0-8) 

**During miner count updates:** [10](#0-9) 

### Impact Explanation

**Complete Blockchain Halt (Critical DoS)**

When `MinerIncreaseInterval` is set to zero, the blockchain becomes completely non-functional:

1. **Consensus Operations Fail**: All round processing and term transitions throw `DivideByZeroException`, preventing block production
2. **No Recovery Mechanism**: Once set to zero, the value cannot be increased due to the backwards validation check
3. **Permanent State**: The blockchain enters an unrecoverable failed state requiring hard fork or chain restart
4. **All Users Affected**: No transactions can be processed, all network participants are impacted

The severity is **CRITICAL** because:
- Zero tolerance for failure in consensus systems
- Complete operational disruption
- No automatic recovery path
- Affects entire network simultaneously

### Likelihood Explanation

**Medium-High Likelihood**

**Attacker Capabilities Required:**
- Control or influence over Parliament governance voting
- Ability to create and pass a proposal through the default Parliament organization [11](#0-10) 

**Attack Complexity: Low**
1. Create Parliament proposal calling `SetMinerIncreaseInterval(0)`
2. Obtain sufficient votes for approval
3. Execute the proposal
4. Wait for next consensus operation (automatic)

**Feasibility Conditions:**
- Governance compromise through social engineering, voting manipulation, or malicious proposal approval
- Accidental misconfiguration by well-intentioned governance actors
- Test configurations accidentally deployed to production

Existing tests demonstrate the validation failure: [12](#0-11) 

The test shows values can only be decreased (line 127 tries to increase and fails, line 140 decreases and succeeds), but never validates against zero.

**Detection/Prevention:**
- No runtime validation prevents zero value
- No monitoring alerts on dangerous parameter changes
- Silent state corruption until consensus operation triggers

### Recommendation

**Immediate Fix: Add Lower Bound Validation**

Replace the backwards check with proper validation in `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    
    // FIX: Validate input is positive and reasonable
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value >= AEDPoSContractConstants.MinimumMinerIncreaseInterval, 
        "Miner increase interval below minimum threshold.");
    
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

**Additional Safeguards:**

1. Define minimum interval constant (e.g., 1 day = 86,400 seconds)
2. Add validation in `GetAutoIncreasedMinersCount()` and `GetMinersCount()` as defense-in-depth:
   ```csharp
   Assert(State.MinerIncreaseInterval.Value > 0, "Invalid miner increase interval state.");
   ```

3. Add regression test case:
   ```csharp
   [Fact]
   public async Task SetMinerIncreaseInterval_ShouldReject_ZeroValue()
   {
       var result = await ConsensusStub.SetMinerIncreaseInterval.SendWithExceptionAsync(
           new Int64Value { Value = 0 });
       result.TransactionResult.Error.ShouldContain("must be positive");
   }
   ```

### Proof of Concept

**Initial State:**
- `State.MinerIncreaseInterval.Value = 31536000` (default from initialization)
- Blockchain operating normally
- Parliament governance active

**Attack Sequence:**

**Step 1:** Create malicious Parliament proposal
```
CreateProposalInput {
    ToAddress: ConsensusContract,
    ContractMethodName: "SetMinerIncreaseInterval",
    Params: Int64Value { Value: 0 },
    OrganizationAddress: DefaultParliamentOrganization
}
```

**Step 2:** Proposal passes governance approval and executes
- Validation at line 61 passes: `0 <= 31536000` ✓
- `State.MinerIncreaseInterval.Value` is set to `0`

**Step 3:** Next consensus operation triggers crash
- Block production calls `ProcessConsensusInformation()`
- Line 128 calls `GetMinersCount(nextRound)`
- Line 390 executes `.Div(State.MinerIncreaseInterval.Value)` → `.Div(0)`
- `DivideByZeroException` thrown

**Expected Result:** Proposal rejected with "Miner increase interval must be positive"

**Actual Result:** Proposal succeeds, blockchain halts with division by zero exception on next consensus operation

**Success Condition:** Blockchain unable to produce new blocks, all nodes crash on consensus calculation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L22-26)
```csharp
        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L31-43)
```csharp
    private void RequiredMaximumMinersCountControllerSet()
    {
        if (State.MaximumMinersCountController.Value != null) return;
        EnsureParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MaximumMinersCountController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L56-64)
```csharp
    public override Empty SetMinerIncreaseInterval(Int64Value input)
    {
        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set miner increase interval.");
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
        State.MinerIncreaseInterval.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/ConsensusOptions.cs (L13-13)
```csharp
    public long MinerIncreaseInterval { get; set; } = 31536000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L31-31)
```csharp
        State.MinerIncreaseInterval.Value = input.MinerIncreaseInterval;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L386-390)
```csharp
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L50-51)
```csharp
        Should.Throw<DivideByZeroException>(() => { number1.Div(0); });
        Should.Throw<DivideByZeroException>(() => { number2.Div(0); });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L128-135)
```csharp
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L53-61)
```csharp
    private void UpdateMinersCountToElectionContract(Round input)
    {
        var minersCount = GetMinersCount(input);
        if (minersCount != 0 && State.ElectionContract.Value != null)
            State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
            {
                MinersCount = minersCount
            });
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L109-147)
```csharp
    public async Task SetMinerIncreaseIntervalTest()
    {
        InitialContracts();
        await BlockMiningService.MineBlockToNextTermAsync();

        InitialAcs3Stubs();
        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput());
        var minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        
        var defaultOrganizationAddress =
            await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());

        var transactionResult = await ParliamentReachAnAgreementWithExceptionAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = minerIncreaseInterval.Value + 1
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        transactionResult.Error.ShouldContain("Invalid interval");
        var newMinerIncreaseInterval = minerIncreaseInterval.Value - 1;
        await ParliamentReachAnAgreementAsync(new CreateProposalInput
        {
            ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
            ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
            Params = new Int64Value
            {
                Value = newMinerIncreaseInterval
            }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
            OrganizationAddress = defaultOrganizationAddress
        });
        minerIncreaseInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
        minerIncreaseInterval.Value.ShouldBe(newMinerIncreaseInterval);
    }
```
