### Title
Critical Consensus DoS via Integer Division Precision Loss in Mining Interval Validation

### Summary
The `TinyBlockSlotInterval` property uses integer division `MiningInterval.Div(8)` which results in 0 for values 1-7ms, causing all derived mining limits to become 0ms. The validation in `CheckRoundTimeSlots()` only enforces `MiningInterval > 0` rather than `>= 8`, allowing malicious miners to inject rounds with sub-8ms intervals during `NextRound` transitions. This permanently bricks the chain by giving miners 0ms execution time for all subsequent blocks.

### Finding Description

The vulnerability originates in the `TinyBlockSlotInterval` calculation that divides `MiningInterval` by 8: [1](#0-0) 

The `Div` method performs standard integer division, truncating any remainder: [2](#0-1) 

When `MiningInterval` is 1-7ms, `TinyBlockSlotInterval` becomes 0. This cascades to all mining limits becoming 0: [3](#0-2) [4](#0-3) 

**Validation Failure**: The `CheckRoundTimeSlots()` method only validates that mining interval is greater than 0, not greater than or equal to 8: [5](#0-4) 

**Attack Path**: A malicious miner can exploit this during their round-transition turn:

1. The `NextRound` method accepts miner-provided `NextRoundInput`: [6](#0-5) 

2. The only permission check verifies the sender is in the miner list: [7](#0-6) 

3. Round validation uses `TimeSlotValidationProvider` which calls the insufficient `CheckRoundTimeSlots()`: [8](#0-7) 

4. The malicious round is stored without additional validation: [9](#0-8) 

5. Future rounds inherit the broken interval via `GetMiningInterval()`: [10](#0-9) [11](#0-10) 

### Impact Explanation

**Complete Chain Denial of Service**: When mining limits reach 0ms, the mining service immediately cancels or provides near-zero timeout for block execution: [12](#0-11) 

The 0ms limit is passed to block execution as a cancellation token: [13](#0-12) 

**Concrete Damage**:
- All miners receive 0ms to execute transactions, causing immediate cancellation
- Blocks can only contain minimal system transactions, no user transactions
- Network throughput drops to zero - chain becomes unusable
- **Permanent damage**: No self-recovery mechanism exists; future rounds inherit the broken 1-7ms interval
- Requires emergency intervention: hard fork or chain restart from backup
- All staked assets, locked tokens, and in-flight transactions frozen

**Affected Parties**: All network participants - miners cannot produce valid blocks, users cannot transact, dApps cease functioning.

### Likelihood Explanation

**Attack Complexity: LOW**
- Requires only being an active miner (one of the elected block producers)
- Can execute during any `NextRound` transition when it's attacker's turn
- Simple execution: manually construct `NextRoundInput` with `ExpectedMiningTime` values 5ms apart instead of default 4000ms
- No special cryptographic operations or complex state manipulation needed

**Feasibility: HIGH**
- Entry point is public consensus method accessible to all miners
- Precondition is realistic: attacker just needs to be elected as miner
- No economic barriers - attack cost is minimal (single transaction gas)
- Attack succeeds immediately upon transaction execution

**Detection Limitations**:
- Attack is detectable (sudden drop to zero user transactions)
- Attacker identity is known (transaction sender)
- However, damage occurs atomically - by the time it's detected, chain is already bricked
- Post-detection doesn't prevent impact

**Probability: HIGH** - Any of the typically 17-21 mainchain miners can execute this attack at any time.

### Recommendation

**Immediate Fix**: Strengthen validation in `CheckRoundTimeSlots()` to enforce minimum mining interval:

```csharp
// In contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs
public ValidationResult CheckRoundTimeSlots()
{
    // ... existing code ...
    
    var baseMiningInterval = 
        (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    
    // CRITICAL: Enforce minimum interval to prevent division-by-zero in TinyBlockSlotInterval
    const int minimumMiningInterval = 8; // TinyBlocksCount from CommandStrategyBase
    if (baseMiningInterval < minimumMiningInterval)
        return new ValidationResult { 
            Message = $"Mining interval must be at least {minimumMiningInterval}ms to support tiny blocks.\n{this}" 
        };
    
    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
    
    // ... rest of validation ...
}
```

**Defense in Depth**: Add validation in `ProcessNextRound` before accepting new round:

```csharp
// In contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Validate round structure before processing
    var validationResult = nextRound.CheckRoundTimeSlots();
    Assert(validationResult.Success, $"Invalid round structure: {validationResult.Message}");
    
    // ... rest of method ...
}
```

**Test Cases**:
1. Attempt `NextRound` with 7ms intervals → should fail validation
2. Attempt `NextRound` with 8ms intervals → should succeed
3. Verify `TinyBlockSlotInterval` calculation for edge cases (8, 9, 15, 16ms)
4. Integration test: confirm mining limits never reach 0 under any valid scenario

### Proof of Concept

**Initial State**:
- Chain running with normal 4000ms mining interval
- Attacker is elected miner with order position for round transition

**Attack Sequence**:

1. **Attacker waits for their NextRound turn** (when they produce the last block of current round)

2. **Attacker crafts malicious `NextRoundInput`**:
   - Set all miners' `ExpectedMiningTime` with 5ms intervals
   - Example: Miner1: T+5ms, Miner2: T+10ms, Miner3: T+15ms, etc.
   - Other fields copied from legitimate round data

3. **Attacker submits transaction**: `NextRound(maliciousInput)`
   - Transaction includes valid random number and signature
   - Passes `PreCheck()` - attacker is valid miner
   - Passes `CheckRoundTimeSlots()` - 5 > 0 ✓
   - Malicious round stored

4. **Chain Effect**:
   - All subsequent consensus commands calculate: `TinyBlockSlotInterval = 5 / 8 = 0`
   - Mining limits: `DefaultBlockMiningLimit = 0 * 3/5 = 0`
   - All miners get 0ms execution time
   - Cancellation tokens immediately trigger or have microsecond timeouts

**Expected Result**: Normal chain operation with 4000ms intervals and ~300ms mining limits

**Actual Result**: 
- Chain frozen with 0ms mining limits
- No user transactions can execute
- Only consensus system transactions succeed (with minimal execution)
- Chain requires emergency hard fork to recover

**Success Condition**: Chain state shows `round.GetMiningInterval() = 5` and all subsequent blocks contain zero user transactions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-42)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L49-49)
```csharp
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L54-54)
```csharp
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L21-24)
```csharp
    public static int Div(this int a, int b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L50-62)
```csharp
            using var cts = new CancellationTokenSource();
            var expirationTime = blockTime + requestMiningDto.BlockExecutionTime;
            if (expirationTime < TimestampHelper.GetUtcNow())
            {
                cts.Cancel();
            }
            else
            {
                var ts = (expirationTime - TimestampHelper.GetUtcNow()).ToTimeSpan();
                if (ts.TotalMilliseconds > int.MaxValue) ts = TimeSpan.FromMilliseconds(int.MaxValue);

                cts.CancelAfter(ts);
            }
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L77-78)
```csharp
            var blockExecutedSet = await _blockExecutingService.ExecuteBlockAsync(block.Header,
                systemTransactions, pending, cts.Token);
```
