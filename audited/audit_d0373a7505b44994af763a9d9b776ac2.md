### Title
Insufficient Miner Count Enforcement Allows Network to Operate Below Security Threshold

### Summary
The `GetVictories()` function in the Election contract can return fewer miners than the configured `MinersCount` when there are insufficient candidates with votes and available backups. This causes the consensus system to operate with reduced Byzantine fault tolerance and decentralization, violating the security assumptions encoded in `MinersCount`. Additionally, a coding bug artificially limits the backup pool by using `currentMiners.Count` instead of `backups.Count`.

### Finding Description

The vulnerability exists in the `GetVictories()` method which determines the miner list for the next consensus term. [1](#0-0) 

**Root Cause 1 - Artificial Backup Limitation (Line 72):**
When valid candidates are insufficient (`diff > 0`), the code builds a backup list from `currentMiners` and `InitialMiners`, then takes `Math.Min(diff, currentMiners.Count)` backups. This uses `currentMiners.Count` instead of `backups.Count`, artificially capping the number of backups even when more are available from the combined pool.

**Root Cause 2 - No Minimum Enforcement:**
The function returns whatever miners are available without validating against a minimum viable count. If `validCandidates.Count + backups.Count < MinersCount`, the system proceeds with fewer miners.

**Execution Flow:**
The consensus contract calls this during term transitions: [2](#0-1) [3](#0-2) 

The returned miner list is directly used to generate the new round without validation: [4](#0-3) 

**Why Existing Protections Fail:**
- `GenerateFirstRoundOfNewTerm` accepts any miner count without minimum validation
- `SolitaryMinerDetection` only catches extreme cases (single miner operating alone for 2+ rounds)
- No validation enforces that actual miner count meets `MinersCount` security requirements [5](#0-4) 

### Impact Explanation

**Consensus Security Degradation:**
- Byzantine fault tolerance requires 2/3 + 1 honest miners. With fewer total miners, the system can tolerate fewer Byzantine nodes
- Example: MinersCount = 17 (expects tolerance of 5 Byzantine nodes), but actual = 14 miners (tolerates only 4 Byzantine nodes)
- This 20% reduction in fault tolerance violates the security model [6](#0-5) 

**Quantified Harm:**
- Network operates with fewer miners than governance-approved security threshold
- Reduced decentralization makes consensus attacks more feasible
- Critical consensus operations (term changes, secret sharing) may fail to reach 2/3 majority more easily

**Who Is Affected:**
- Entire network security is compromised
- Stakeholders who voted expecting `MinersCount`-level security
- Applications relying on consensus finality guarantees

**Severity Justification:**
Critical because it directly undermines the fundamental security property (Byzantine fault tolerance) that the consensus mechanism is designed to provide.

### Likelihood Explanation

**Feasible Preconditions:**
1. `MinersCount` increases through auto-increment mechanism based on blockchain age [7](#0-6) 

2. Insufficient candidates announce election or receive votes (depends on governance incentives)
3. The backup pool (`currentMiners` + `InitialMiners`) cannot fill the gap

**Execution Practicality:**
- Happens automatically during term transitions via `TryToGetVictories`
- No active attack required - natural system progression
- Becomes more likely as blockchain ages and `MinersCount` increases while candidate pool stagnates

**Attack Complexity:**
Low - occurs through passive conditions rather than active exploitation. An adversary could discourage candidate participation through economic or social means, but direct exploitation is not required.

**Detection Constraints:**
The network continues operating normally, making this degradation difficult to detect without monitoring actual vs. expected miner counts.

**Probability:**
Medium to High over long timescales. Early in blockchain lifecycle, `InitialMiners` provide sufficient buffer. As `MinersCount` grows and initial miner influence decreases, the vulnerability becomes more likely.

### Recommendation

**Code-Level Mitigation:**

1. **Fix the backup limitation bug (Line 72):**
   Change `Math.Min(diff, currentMiners.Count)` to `Math.Min(diff, backups.Count)` to utilize all available backups

2. **Add minimum viable miner validation:**
   In `GenerateFirstRoundOfNextTerm` or `TryToGetVictories`, enforce:
   ```
   Assert(victories.Pubkeys.Count >= GetMinimumViableMinersCount(), 
          "Insufficient miners for consensus security");
   ```
   Where `GetMinimumViableMinersCount()` returns a governance-configurable absolute minimum (e.g., 5 or 7).

3. **Alternative: Cap MinersCount growth:**
   In `UpdateMinersCount`, validate:
   ```
   var availablePool = GetMaxPossibleMiners(); // valid candidates + current + initial
   Assert(input.MinersCount <= availablePool, 
          "MinersCount exceeds available miner pool");
   ```

**Invariant Checks:**
- `victories.Count >= MinimumViableMinersCount` before term transition
- `victories.Count >= (2/3 * expected security threshold)` to maintain Byzantine tolerance
- Emit warning events when actual miner count falls below `MinersCount`

**Test Cases:**
- Test with `validCandidates = 2`, `currentMiners = 5`, `InitialMiners = 3`, `MinersCount = 15`
- Verify backup selection uses full pool (not capped at `currentMiners.Count`)
- Test rejection when available miners < minimum viable count
- Test with `MinersCount` auto-increasing beyond available pool capacity

### Proof of Concept

**Initial State:**
- Blockchain age: 180 days (MinersCount auto-increased to 17)
- State.MinersCount.Value = 17
- Previous term had 10 miners (currentMiners.Count = 10)
- State.InitialMiners.Value = 5 initial miners
- Only 4 candidates announced and received votes (validCandidates.Count = 4)
- Assume 2 of validCandidates overlap with currentMiners

**Transaction Steps:**
1. Consensus contract calls `State.ElectionContract.GetVictories.Call(new Empty())` during term transition
2. GetVictories executes:
   - validCandidates = 4 (with votes)
   - diff = 17 - 4 = 13 (need 13 more)
   - backups from currentMiners = 8 (10 - 2 overlapping)
   - backups after adding InitialMiners (assuming 3 not in backups) = 11 total
   - **Bug triggers:** Takes Math.Min(13, 10) = 10 from backups (instead of taking all 11)
   - Returns: 4 validCandidates + 10 backups = 14 miners

3. Consensus contract calls `victories.GenerateFirstRoundOfNewTerm()` with 14 miners
4. New term begins with 14 miners instead of 17

**Expected vs Actual Result:**
- **Expected:** System should either (a) include all 15 available miners (4 + 11), or (b) reject term transition for insufficient miners
- **Actual:** System operates with 14 miners, reducing Byzantine tolerance from 5 to 4 nodes (17â†’14 = 18% reduction)

**Success Condition:**
Query `GetCurrentMinerList()` after term transition returns only 14 miners despite MinersCount = 17, confirming the network operates below security threshold.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L76-88)
```csharp

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```
