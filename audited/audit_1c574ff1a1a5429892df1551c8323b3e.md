# Audit Report

## Title
Missing Authorization Validation in NextTerm Allows Unauthorized Miner List Installation and Premature Term Transitions

## Summary
The AEDPoS consensus contract's `NextTerm` transaction execution path lacks critical validation of (1) whether term transition timing conditions (`NeedToChangeTerm`) are met, and (2) whether the provided miner list matches election results from `GetVictories()`. This allows any current miner to bypass election-based governance by installing an arbitrary miner list and forcing premature term transitions.

## Finding Description

The vulnerability stems from a critical gap between consensus command generation and execution validation.

**Normal Honest Flow:**
During legitimate consensus operation, `GetConsensusCommand` determines when to transition terms by invoking `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` [1](#0-0) , which calls `NeedToChangeTerm()` to verify timing conditions based on blockchain age and period [2](#0-1) . When legitimate NextTerm is required, `GetConsensusExtraDataForNextTerm` invokes `GenerateFirstRoundOfNextTerm` [3](#0-2) , which retrieves the proper miner list from the Election contract via `State.ElectionContract.GetVictories.Call()` [4](#0-3) .

**Attack Flow:**
However, when `ValidateBeforeExecution` processes a NextTerm behavior, it only adds `RoundTerminateValidationProvider` [5](#0-4) . This provider performs minimal validation - it only verifies that the term number increments by exactly 1 [6](#0-5) .

**Critical Missing Validations:**
The validation logic does NOT check:
1. Whether `NeedToChangeTerm()` timing conditions are satisfied (blockchain age vs period threshold)
2. Whether the miner list in the input matches `GetVictories()` election results

During execution, `ProcessNextTerm` directly installs the miner list from the transaction input without any validation [7](#0-6) . The `PreCheck()` authorization only verifies the sender is in the current OR previous round's miner list [8](#0-7) , which is insufficient - it doesn't validate whether this specific term transition is authorized.

**Exploitation Steps:**
1. Attacker (current miner) waits for their time slot
2. Crafts consensus extra data with `AElfConsensusBehaviour.NextTerm` behavior
3. Includes fraudulent Round with arbitrary miner list (e.g., only attacker's pubkey, or excluding competitors)
4. Sets `TermNumber = CurrentTermNumber + 1`
5. Validation passes because it only checks term number increment
6. Fraudulent miner list gets installed via `SetMinerList()` [9](#0-8) 
7. Treasury releases and election snapshots execute based on fraudulent term [10](#0-9) 

## Impact Explanation

**Consensus Integrity Compromise (HIGH):**
- **Complete Governance Bypass**: The election-based governance mechanism becomes meaningless if any current miner can install their own miner list, completely bypassing token holder voting
- **Unauthorized Miner Control**: Attacker can install themselves as sole miner or exclude competitors, gaining total control over block production
- **Reward Misallocation**: Mining rewards and treasury distributions occur based on the fraudulent term transition

**Economic Damage:**
- Attacker captures all future mining rewards
- Can censor transactions from competitors or specific users
- Controls network progression and state transitions

**Protocol Integrity:**
- Election snapshots taken with corrupted state
- Treasury periods advanced prematurely
- Miner performance tracking becomes unreliable
- Chain's fundamental assumption of election-based miner selection is violated

This represents a critical failure of the consensus mechanism's security model where decentralized miner selection is a core invariant.

## Likelihood Explanation

**Attacker Capabilities: REALISTIC**
- Must be in current round's miner list (one of typically 17-21 miners)
- Must be able to construct valid Round structure (straightforward - can copy from legitimate rounds)
- Must have their time slot (happens regularly in rotation)

**Attack Complexity: LOW**
- No race conditions or precise timing requirements
- No complex cryptographic operations needed
- No dependency on external system failures
- Straightforward transaction submission

**Detection Difficulty: HIGH**
- Attack appears as valid consensus operation to all validators
- Validation logic passes successfully since it only checks term number increment
- Other nodes would accept the fraudulent term transition as legitimate
- No obvious anomaly in standard monitoring

**Economic Rationality: STRONG**
If attacker controls miner list, they gain:
- All future mining rewards
- Transaction censorship capability
- Network control
- Benefits far exceed any cost of being a current miner

**Preconditions: MINIMAL**
- Attacker must already be a miner (but there are multiple miners, so one could be malicious)
- No additional trust assumptions required
- No complex chain state dependencies

## Recommendation

Add comprehensive validation in `ValidateBeforeExecution` for NextTerm behavior:

1. **Validate Timing Conditions**: Check that `NeedToChangeTerm()` actually returns true before allowing NextTerm:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new NextTermTimingValidationProvider()); // NEW
    validationProviders.Add(new MinerListValidationProvider()); // NEW
    break;
```

2. **Create NextTermTimingValidationProvider**: Verify blockchain age and period requirements match `NeedToChangeTerm()` logic

3. **Create MinerListValidationProvider**: Compare provided miner list against `State.ElectionContract.GetVictories()` results to ensure it matches election outcomes

4. **Add validation in ProcessNextTerm**: Before installing miner list, verify it matches expected election results as defense-in-depth

## Proof of Concept

```csharp
[Fact]
public async Task Exploit_UnauthorizedNextTerm_InstallFraudulentMinerList()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = await InitializeConsensusWithMiners(3);
    var attackerMiner = legitimateMiners[0];
    
    // Attacker is currently a valid miner
    var currentRound = await GetCurrentRound();
    Assert.Contains(attackerMiner.PublicKey, currentRound.RealTimeMinersInformation.Keys);
    
    // Get current term number
    var currentTerm = await ConsensusStub.GetCurrentTermNumber.CallAsync(new Empty());
    
    // Craft fraudulent NextTerm with only attacker as miner
    var fraudulentRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentTerm.Value + 1,
        RealTimeMinersInformation = 
        {
            { attackerMiner.PublicKey, new MinerInRound { ... } } // Only attacker
        }
    };
    
    // Submit NextTerm transaction with fraudulent miner list
    var result = await attackerMiner.NextTerm(fraudulentRound);
    
    // Validation should FAIL but currently PASSES
    Assert.True(result.Status == TransactionResultStatus.Mined); // VULNERABILITY: This succeeds
    
    // Verify fraudulent miner list was installed
    var newMinerList = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    Assert.Single(newMinerList.Pubkeys); // Only attacker remains
    Assert.Equal(attackerMiner.PublicKey, newMinerList.Pubkeys[0].ToHex());
    
    // Other legitimate miners have been excluded
    Assert.DoesNotContain(legitimateMiners[1].PublicKey, newMinerList.Pubkeys.Select(p => p.ToHex()));
    Assert.DoesNotContain(legitimateMiners[2].PublicKey, newMinerList.Pubkeys.Select(p => p.ToHex()));
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-223)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-218)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
