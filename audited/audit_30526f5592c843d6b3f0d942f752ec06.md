# Audit Report

## Title
Missing Pubkey Field Validation in Round Transitions Enables LIB Consensus Manipulation

## Summary
The `NextRound` and `NextTerm` methods accept externally-controlled round data without validating that `MinerInRound.Pubkey` field values match their dictionary keys or are non-empty. A malicious extra block producer can submit round data where dictionary keys are valid pubkeys but corresponding `MinerInRound.Pubkey` fields are empty strings, causing those miners to be incorrectly excluded from Last Irreversible Block (LIB) consensus calculations. This breaks Byzantine Fault Tolerance assumptions and persists across subsequent rounds.

## Finding Description

The vulnerability exists because the consensus contract accepts round transition data from external input without validating the consistency between dictionary keys and `MinerInRound.Pubkey` field values.

**Root Cause - Unchecked Data Conversion:**

The `ToRound()` method performs blind copying of `RealTimeMinersInformation` without validation: [1](#0-0) 

The protobuf definition allows dictionary keys to differ from `MinerInRound.pubkey` field values with no structural constraint: [2](#0-1) [3](#0-2) 

**Validation Bypass:**

All existing validation providers check dictionary keys but NOT the `Pubkey` field values:

1. `MiningPermissionValidationProvider` checks if sender exists in dictionary keys: [4](#0-3) 

2. `IsInMinerList` (used in PreCheck) also only checks dictionary keys: [5](#0-4) 

3. `NextRoundMiningOrderValidationProvider` only validates order counts: [6](#0-5) 

4. `RoundTerminateValidationProvider` only checks round/term numbers and InValues: [7](#0-6) 

The validation service runs all providers but none validate `Pubkey` field values: [8](#0-7) 

**LIB Manipulation:**

The LIB calculation filters miners by their `Pubkey` field value, NOT dictionary keys: [9](#0-8) 

When `GetSortedImpliedIrreversibleBlockHeights` receives a list of mined miners' pubkeys (actual hex strings), it performs `specificPublicKeys.Contains(i.Pubkey)`. If `i.Pubkey` is an empty string while `specificPublicKeys` contains valid hex pubkeys, the `Contains()` check returns false, excluding that miner from the heights array used for LIB calculation: [10](#0-9) 

**Persistence Mechanism:**

The vulnerability persists because `GenerateNextRoundInformation` explicitly copies the `Pubkey` field from the current round to the next: [11](#0-10) [12](#0-11) 

**Attack Path:**

1. Attacker becomes a miner (via Election contract staking/voting)
2. Attacker gets selected as extra block producer (1/N probability per round)
3. Attacker crafts malicious `NextRoundInput` where:
   - Dictionary keys: `"04abc..."`, `"04def..."` (valid pubkeys)
   - Victim `MinerInRound.Pubkey` fields: `""` (empty string)
   - Attacker's own `MinerInRound.Pubkey`: `"04abc..."` (valid)
4. Attacker calls public `NextRound` method with malicious input
5. All validations pass (they only check dictionary keys)
6. Malicious round is stored via `ProcessNextRound`: [13](#0-12) 
7. LIB calculations now exclude miners with empty `Pubkey` fields
8. Effect persists across subsequent rounds until `NextTerm` regenerates from Election contract

## Impact Explanation

**Critical Consensus Integrity Breach:**

The Last Irreversible Block (LIB) is a fundamental consensus primitive that determines transaction finality. The LIB height is calculated using Byzantine Fault Tolerance logic where the irreversible height is determined by taking the `(count-1)/3` position in sorted implied heights from miners who have mined blocks.

By excluding miners with manipulated empty `Pubkey` fields from this calculation, an attacker can:

1. **Delay Finality**: Exclude miners reporting higher implied irreversible block heights, causing the LIB to advance more slowly than it should
2. **Accelerate Finality Inappropriately**: Exclude miners reporting lower implied heights, causing premature finality
3. **Break BFT Assumptions**: If more than 1/3 of miners are excluded, the `(count-1)/3` formula operates on an incorrect subset, violating the 2f+1 consensus requirement

**Affected Parties:**
- All network participants relying on LIB for transaction finality guarantees
- Cross-chain bridges and indexing systems depending on confirmed irreversible block heights
- DApps and smart contracts that require finality assurances
- Economic systems (DEXs, lending protocols) that need settlement guarantees

**Severity Justification:**
This is a HIGH severity issue because LIB manipulation undermines the entire security model of the blockchain. Transaction finality is the cornerstone of blockchain integrity - without reliable finality, double-spend attacks become possible and cross-chain operations become unsafe.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an active miner in the current round (achievable by staking tokens and receiving votes through the Election contract)
- Must be selected as the extra block producer (probability 1/N where N is the number of miners, typically 1/17 to 1/23 per round)

**Attack Execution:**
Once selected as extra block producer, the attacker has complete control over the `NextRoundInput` they submit. The attack succeeds with 100% certainty because:
1. No validation checks `Pubkey` field values
2. The protobuf structure allows arbitrary mismatches between map keys and field values
3. The malicious round data is accepted and stored in contract state

**Persistence:**
The attack has automatic persistence because `GenerateNextRoundInformation` copies the `Pubkey` field values to subsequent rounds. This means a single successful attack affects multiple rounds until a `NextTerm` transition regenerates miner data from the Election contract.

**Detection Difficulty:**
- External observers see miners continuing to produce blocks (dictionary keys remain valid)
- LIB manipulation appears as legitimate consensus behavior
- Requires monitoring internal round state data to detect

**Overall Probability:** Medium-High

While the attacker must wait for extra block producer selection, this happens regularly in normal operation. Once achieved, the attack succeeds with certainty and persists automatically, making this a realistic and dangerous threat.

## Recommendation

Add validation in the `NextRound` and `NextTerm` processing logic to ensure `MinerInRound.Pubkey` field values match their dictionary keys and are non-empty.

**Recommended Fix:**

Add a new validation provider `PubkeyConsistencyValidationProvider`:

```csharp
public class PubkeyConsistencyValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound ?? validationContext.ExtraData.Round;
        
        if (providedRound == null)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        foreach (var minerEntry in providedRound.RealTimeMinersInformation)
        {
            var dictionaryKey = minerEntry.Key;
            var pubkeyField = minerEntry.Value.Pubkey;
            
            // Validate pubkey field is not null or empty
            if (string.IsNullOrEmpty(pubkeyField))
            {
                validationResult.Message = $"MinerInRound.Pubkey field is null or empty for dictionary key: {dictionaryKey}";
                return validationResult;
            }
            
            // Validate pubkey field matches dictionary key
            if (dictionaryKey != pubkeyField)
            {
                validationResult.Message = $"MinerInRound.Pubkey field '{pubkeyField}' does not match dictionary key '{dictionaryKey}'";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this provider to the validation pipeline in `AEDPoSContract_Validation.cs` for both `NextRound` and `NextTerm` behaviors:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new PubkeyConsistencyValidationProvider());
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new PubkeyConsistencyValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

## Proof of Concept

```csharp
[Fact]
public async Task PubkeyMismatch_Should_Fail_NextRound_Validation()
{
    // Setup: Get current round with valid miners
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
    
    // Create malicious NextRoundInput with mismatched pubkey field
    var maliciousRound = new Round
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
        RealTimeMinersInformation = { }
    };
    
    // Add miner with valid dictionary key but EMPTY Pubkey field
    foreach (var key in minerKeys)
    {
        maliciousRound.RealTimeMinersInformation[key] = new MinerInRound
        {
            Pubkey = "", // EMPTY - this is the vulnerability
            Order = 1,
            ExpectedMiningTime = TimestampHelper.GetUtcNow()
        };
    }
    
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = maliciousRound.RoundNumber,
        TermNumber = maliciousRound.TermNumber,
        RealTimeMinersInformation = { maliciousRound.RealTimeMinersInformation },
        RandomNumber = ByteString.CopyFromUtf8("random")
    };
    
    // Execute: Attempt NextRound with malicious input
    // WITHOUT the fix, this would succeed and corrupt LIB calculations
    // WITH the fix, this should fail validation
    var result = await AEDPoSContractStub.NextRound.SendAsync(maliciousInput);
    
    // Verify: Check if miners with empty Pubkey fields are excluded from LIB calculation
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var sortedHeights = updatedRound.GetSortedImpliedIrreversibleBlockHeights(minerKeys);
    
    // Without fix: sortedHeights.Count < minerKeys.Count (miners excluded)
    // With fix: Transaction should have been rejected
    sortedHeights.Count.ShouldBeLessThan(minerKeys.Count); // Demonstrates the vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
