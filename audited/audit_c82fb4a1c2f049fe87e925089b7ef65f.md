### Title
LIB Height Can Decrease During NextRound and NextTerm Transitions Due to Missing Validation

### Summary
The `LibInformationValidationProvider` is only applied for `UpdateValue` consensus behavior, not for `NextRound` or `NextTerm` behaviors. Additionally, the integrity hash validation excludes `ConfirmedIrreversibleBlockHeight` from its calculation. This allows a malicious miner to provide a NextRound or NextTerm block with a decreased LIB height, which will be saved to state without validation, violating the critical invariant that LIB can only move forward.

### Finding Description

The vulnerability exists in the consensus validation flow with three interconnected issues:

**Issue 1: LibInformationValidationProvider Not Applied for NextRound/NextTerm** [1](#0-0) 

The `LibInformationValidationProvider` is only added for `UpdateValue` behavior (line 82), but not for `NextRound` or `NextTerm` behaviors. This means LIB backward movement is not checked during round/term transitions.

**Issue 2: Hash Validation Excludes ConfirmedIrreversibleBlockHeight** [2](#0-1) 

The `GetCheckableRound` method used for hash calculation only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`. It explicitly excludes `ConfirmedIrreversibleBlockHeight` from the hash, allowing this field to be modified without detection.

**Issue 3: NextRound/NextTerm Processing Saves Provided LIB Without Validation** [3](#0-2) [4](#0-3) 

Both `ProcessNextRound` and `ProcessNextTerm` convert the input to a Round and save it directly via `AddRoundInformation` without validating LIB values.

**Execution Path:**
1. Malicious miner calls `GetConsensusExtraData` to obtain legitimate nextRound with current `ConfirmedIrreversibleBlockHeight = 1000` [5](#0-4) 

2. The nextRound is generated with LIB copied from current round [6](#0-5) 

3. Miner modifies the Round object in extra data to set `ConfirmedIrreversibleBlockHeight = 500`

4. Validation passes because:
   - `LibInformationValidationProvider` is not applied for NextRound
   - Hash validation passes because `ConfirmedIrreversibleBlockHeight` is not in the hash

5. `ProcessNextRound` saves the manipulated Round to state with decreased LIB

### Impact Explanation

**Consensus/Cross-Chain Integrity Violation:**
- LIB represents the height below which blocks are considered irreversible and finalized
- Decreasing LIB violates the fundamental finality guarantee of the blockchain
- Previously finalized blocks become reversible, enabling chain reorganizations beyond the finality point

**Cross-Chain Impact:**
- Cross-chain operations rely on LIB for security guarantees [7](#0-6) 
- Decreasing LIB could invalidate cross-chain merkle proofs and indexing heights
- Could enable double-spending attacks across chains if transactions were confirmed based on old LIB

**Economic Impact:**
- Token holders and applications relying on finality guarantees face security risks
- Treasury distributions, profit calculations, and dividend settlements based on LIB could be compromised

**Severity: Critical** - Breaks core consensus invariant that LIB must monotonically increase, affecting entire blockchain finality model.

### Likelihood Explanation

**Attacker Capabilities:**
- Any elected miner in the consensus miner list can execute this attack
- Requires ability to produce NextRound or NextTerm blocks during assigned time slots
- No special privileges beyond normal miner status required

**Attack Complexity:**
- Low - Simply modify `ConfirmedIrreversibleBlockHeight` field in Round object before block production
- No complex cryptographic manipulation or state race conditions needed
- Attack is deterministic and reproducible

**Feasibility Conditions:**
- Attacker must be scheduled to produce the NextRound or NextTerm block
- This occurs regularly in normal consensus operation (every round transition)
- No unusual blockchain state or timing requirements

**Detection/Operational Constraints:**
- Modification is not detectable through existing validation mechanisms
- No alerts or logs would indicate LIB manipulation
- Attack succeeds silently unless external monitoring tracks LIB progression

**Probability: High** - Any malicious miner can execute during their scheduled NextRound/NextTerm block production with 100% success rate.

### Recommendation

**Immediate Fix:**

1. **Apply LibInformationValidationProvider to NextRound and NextTerm behaviors:** [8](#0-7) 

Add `LibInformationValidationProvider` to the validation list for both `NextRound` and `NextTerm` cases.

2. **Include ConfirmedIrreversibleBlockHeight in hash calculation:** [9](#0-8) 

Modify `GetCheckableRound` to include `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` in the Round object used for hash computation.

3. **Add explicit LIB monotonicity check in ProcessNextRound and ProcessNextTerm:**

Before calling `AddRoundInformation`, verify:
```
Assert(nextRound.ConfirmedIrreversibleBlockHeight >= currentRound.ConfirmedIrreversibleBlockHeight, 
       "LIB height cannot decrease");
Assert(nextRound.ConfirmedIrreversibleBlockRoundNumber >= currentRound.ConfirmedIrreversibleBlockRoundNumber,
       "LIB round number cannot decrease");
```

4. **Test Cases:**
    - Verify NextRound block with decreased LIB is rejected
    - Verify NextTerm block with decreased LIB is rejected  
    - Verify hash validation detects LIB field tampering
    - Verify legitimate LIB increases pass all validations

### Proof of Concept

**Required Initial State:**
- Blockchain running with multiple elected miners
- Current round N with `ConfirmedIrreversibleBlockHeight = 1000`, `ConfirmedIrreversibleBlockRoundNumber = 950`
- Malicious miner M scheduled to produce NextRound block

**Attack Steps:**

1. Malicious miner M calls `GetConsensusCommand` to determine NextRound behavior is required [10](#0-9) 

2. Miner M calls `GetConsensusExtraData` which returns legitimate nextRound with:
   - `RoundNumber = N+1`
   - `ConfirmedIrreversibleBlockHeight = 1000` (copied from current round)

3. Before submitting block, miner M modifies the Round object in extra data:
   - Set `ConfirmedIrreversibleBlockHeight = 500` (decreased)
   - Set `ConfirmedIrreversibleBlockRoundNumber = 450` (decreased)

4. Block is validated by `ValidateBeforeExecution`:
   - `LibInformationValidationProvider` is NOT applied (only for UpdateValue)
   - Other validators pass (round number, term number checks pass)

5. Block is executed via `GenerateConsensusTransactions`: [11](#0-10) 

6. `ProcessNextRound` is called, which saves the Round with decreased LIB to state [12](#0-11) 

7. `ValidateConsensusAfterExecution` hash check passes because `ConfirmedIrreversibleBlockHeight` is not in the hash

**Expected vs Actual Result:**
- **Expected:** Block rejected, LIB remains at 1000
- **Actual:** Block accepted, LIB decreased to 500, violating finality guarantees

**Success Condition:** Query `State.Rounds[N+1].ConfirmedIrreversibleBlockHeight` returns 500 instead of maintaining/increasing from 1000.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```
