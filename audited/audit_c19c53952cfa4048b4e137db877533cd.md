# Audit Report

## Title
BurnProfits Unconditionally Overwrites DistributedProfitsMap Causing Loss of Pre-Contributed Profits

## Summary
The `BurnProfits` function creates a new `DistributedProfitsInfo` object and unconditionally overwrites existing state without preserving pre-contributed profits. When users contribute tokens to future periods via `ContributeProfits` and the scheme later has zero `totalShares` at distribution time, `BurnProfits` destroys the accounting record while tokens remain locked in period-specific virtual addresses, making them permanently unclaimable.

## Finding Description

The vulnerability exists in how `BurnProfits` handles periods that already have pre-contributed profits.

When users contribute to future periods, `ContributeProfits` validates the period is valid [1](#0-0) , generates a period-specific virtual address [2](#0-1) , and transfers tokens there [3](#0-2) . The contribution is recorded in `DistributedProfitsMap` [4](#0-3) .

When `DistributeProfits` is later called for that period with `totalShares <= 0`, it invokes `BurnProfits` [5](#0-4) .

The critical flaw is in `BurnProfits` implementation: it creates a **brand new** `DistributedProfitsInfo` object [6](#0-5)  without reading any existing state. It then burns tokens from the scheme's **general ledger** [7](#0-6) , not from the period-specific address where pre-contributions were deposited. Finally, it unconditionally overwrites the state [8](#0-7) , destroying all records of previously contributed profits.

In contrast, the normal distribution path via `UpdateDistributedProfits` correctly reads existing state [9](#0-8)  and checks the period-specific address balance [10](#0-9) .

After `BurnProfits` sets `IsReleased=true`, future contributions to that period are blocked [11](#0-10) .

When users try to claim profits via `ClaimProfits`, the calculation depends entirely on `DistributedProfitsMap` [12](#0-11) . With the accounting destroyed, the contributed tokens become permanently unrecoverable despite remaining in the period-specific virtual address.

## Impact Explanation

**High Severity - Permanent Loss of User Funds:**

1. **Complete Fund Loss:** Tokens contributed to future periods become permanently locked in period-specific virtual addresses with no recovery mechanism. The accounting in `DistributedProfitsMap` is destroyed, and `ClaimProfits` cannot retrieve these funds.

2. **Quantified Damage:** The impact scales linearly with contribution amounts. If 10,000 ELF tokens are contributed to period 5, and the scheme has zero beneficiaries when period 5 arrives, all 10,000 ELF become permanently locked.

3. **Affected Parties:**
   - Users who contribute profits to future periods expecting normal distribution
   - Scheme managers who inadvertently trigger this by removing all beneficiaries during scheme wind-down
   - The overall protocol, as tokens become permanently stuck in virtual addresses

4. **No Recovery Path:** Once `BurnProfits` executes, there is no mechanism to recover the contributed funds. The virtual address still holds the tokens, but all accounting is lost.

## Likelihood Explanation

**Medium Likelihood - Triggered Through Normal Operations:**

1. **Public Entry Point:** `ContributeProfits` is a public method callable by any user with token allowance, requiring no special privileges for the contribution step.

2. **Realistic Preconditions:**
   - Profit scheme exists and accepts contributions (common scenario)
   - User contributes to a future period (explicitly allowed by the contract, validated at line 684)
   - By the time that period arrives, all beneficiaries have been removed via `RemoveBeneficiary`, resulting in `totalShares = 0`
   - Scheme manager calls `DistributeProfits` for the period

3. **Natural Occurrence:** This scenario occurs when:
   - A scheme is being wound down and beneficiaries are systematically removed
   - Users had previously contributed to future periods expecting normal operation
   - The timing gap between contribution and distribution allows legitimate beneficiary changes

4. **No Attack Cost:** Beyond the initial contribution (which could be small), there's no additional cost to trigger the vulnerability. The loss occurs through legitimate contract operations.

5. **Detection Difficulty:** Both `ContributeProfits` and `RemoveBeneficiary` are legitimate operations. The fund loss only becomes apparent when users attempt to claim profits, potentially much later.

## Recommendation

Modify `BurnProfits` to preserve existing period-specific contributions before overwriting state:

```csharp
private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
    Address profitsReceivingVirtualAddress)
{
    scheme.CurrentPeriod = period.Add(1);

    // Read existing state to preserve pre-contributions
    var distributedProfitsInfo = State.DistributedProfitsMap[profitsReceivingVirtualAddress] 
        ?? new DistributedProfitsInfo();
    
    distributedProfitsInfo.IsReleased = true;
    
    // Get balance from period-specific address to account for pre-contributions
    foreach (var profits in profitsMap)
    {
        var symbol = profits.Key;
        var amount = profits.Value;
        if (amount > 0)
        {
            // Check general ledger balance
            var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = scheme.VirtualAddress,
                Symbol = symbol
            });
            if (balanceOfToken.Balance >= amount)
            {
                // Burn from general ledger
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                
                // Update amounts (preserve existing if any, subtract burned amount)
                var currentAmount = distributedProfitsInfo.AmountsMap.ContainsKey(symbol) 
                    ? distributedProfitsInfo.AmountsMap[symbol] 
                    : 0;
                distributedProfitsInfo.AmountsMap[symbol] = currentAmount - amount;
            }
        }
    }
    
    // Check period-specific address for pre-contributions not in profitsMap
    var periodBalance = State.TokenContract.GetBalance.Call(new GetBalanceInput
    {
        Owner = profitsReceivingVirtualAddress,
        Symbol = symbol
    }).Balance;
    
    if (periodBalance > 0 && !distributedProfitsInfo.AmountsMap.ContainsKey(symbol))
    {
        // Preserve pre-contribution accounting
        distributedProfitsInfo.AmountsMap[symbol] = periodBalance;
    }

    State.SchemeInfos[scheme.SchemeId] = scheme;
    State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
    return new Empty();
}
```

Alternatively, prevent `BurnProfits` from being called on periods that have pre-existing contributions, or ensure period-specific balances are also burned/returned to contributors.

## Proof of Concept

```csharp
[Fact]
public async Task BurnProfits_DestroysPreContributedProfits_PermanentFundLoss()
{
    // 1. Setup: Create scheme
    var creator = Creators[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 100
    });
    
    var schemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds;
    var schemeId = schemeIds.First();
    
    // 2. User contributes 10,000 tokens to FUTURE period 5
    const long contributionAmount = 10_000;
    const long futurePeriod = 5;
    
    await ProfitContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Symbol = "ELF",
        Amount = contributionAmount,
        Period = futurePeriod
    });
    
    // Verify tokens are in period-specific address
    var periodAddress = await ProfitContractStub.GetSchemeAddress.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = futurePeriod });
    var periodBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = periodAddress, Symbol = "ELF" })).Balance;
    periodBalance.ShouldBe(contributionAmount);
    
    // Verify accounting exists
    var distributedInfo = await ProfitContractStub.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = futurePeriod });
    distributedInfo.AmountsMap["ELF"].ShouldBe(contributionAmount);
    
    // 3. Advance to period 5 (simulate by calling DistributeProfits for periods 1-4)
    // Note: In real scenario, scheme would have beneficiaries initially, then removed
    for (long period = 1; period < futurePeriod; period++)
    {
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = period
        });
    }
    
    // 4. Now at period 5 with zero totalShares, call DistributeProfits
    // This triggers BurnProfits which OVERWRITES the accounting
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = futurePeriod
    });
    
    // 5. VULNERABILITY: Tokens still in period address but accounting is destroyed
    var periodBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = periodAddress, Symbol = "ELF" })).Balance;
    periodBalanceAfter.ShouldBe(contributionAmount); // Tokens still there!
    
    var distributedInfoAfter = await ProfitContractStub.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = futurePeriod });
    
    // Accounting shows negative or zero instead of the 10,000 contribution
    distributedInfoAfter.AmountsMap.ContainsKey("ELF").ShouldBeFalse(); 
    // OR distributedInfoAfter.AmountsMap["ELF"].ShouldBeLessThan(0); // Negative value
    
    // RESULT: 10,000 ELF permanently locked with no way to claim
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L522-525)
```csharp
        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L532-545)
```csharp
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L556-556)
```csharp
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L563-565)
```csharp
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L574-579)
```csharp
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L684-684)
```csharp
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L685-686)
```csharp
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L688-712)
```csharp
            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L867-874)
```csharp
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```
