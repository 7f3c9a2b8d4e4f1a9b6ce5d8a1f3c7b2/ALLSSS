### Title
Negative TotalShares in Cached Delay Values Causes Incorrect Profit Distribution Calculations

### Summary
The `RemoveBeneficiary` function incorrectly subtracts removed shares from `CachedDelayTotalShares` entries that were captured before those beneficiaries were added, causing cached total shares to become negative. When these negative values are later used in `SafeCalculateProfits` during profit distribution, the division by a negative denominator produces arithmetically incorrect results, leading to profit miscalculation and potential fund misallocation.

### Finding Description
In schemes with `DelayDistributePeriodCount > 0`, the profit distribution system caches historical total shares snapshots for future use. [1](#0-0) 

When `RemoveBeneficiary` is called, it attempts to update these cached future values by subtracting the removed shares. [2](#0-1) 

The root cause is that the code subtracts shares from cached periods indiscriminately, even when those cached snapshots were taken BEFORE the beneficiary being removed was added. The loop iterates through `[removedMinPeriod, removedMinPeriod + DelayDistributePeriodCount)` and subtracts from any cached entry found, without validating whether that cached value should include those shares.

For example:
- Period 1: Snapshot taken with TotalShares=100 (only Alice), cached for period 3
- Period 2: Bob added with 60 shares, TotalShares=160
- Period 2: Both removed (160 shares) → Cache[3] = 100 - 160 = **-60**

When period 3 arrives, this negative cached value is retrieved and stored in `DistributedProfitsInfo.TotalShares`. [3](#0-2) 

The existing check at line 868 only validates `TotalShares == 0`, not negative values. [4](#0-3) 

The `SafeCalculateProfits` function then divides by this negative value, producing incorrect results. [5](#0-4) 

### Impact Explanation
**Direct Fund Impact**: When beneficiaries claim profits, the calculation `(totalAmount * shares) / totalShares` with negative `totalShares` produces arithmetically inverted results. For example, with totalAmount=1000, shares=50, totalShares=-60: result = (1000 * 50) / (-60) = -833.

This causes:
1. **Negative profit amounts**: Transfers will fail or revert, denying legitimate beneficiaries their earned profits
2. **Incorrect profit ratios**: Even if signs align coincidentally, the magnitude is wrong, misallocating funds between beneficiaries
3. **Protocol accounting corruption**: Total distributed amounts won't match the actual token balances, breaking invariants

The vulnerability affects all beneficiaries in schemes using delayed distribution (common in staking/reward systems), with the magnitude proportional to the mismatch between cached and removed shares.

### Likelihood Explanation
**High Likelihood**: This vulnerability requires:
1. A scheme with `DelayDistributePeriodCount > 0` (documented feature used in production)
2. Adding beneficiaries in one period, then removing them (or others) before the cached snapshot is used
3. The removed shares exceeding the cached snapshot value

These conditions occur naturally during normal operations:
- Election/staking schemes commonly use delay distribution (3+ periods)
- Users frequently join and leave schemes (unstaking, vote changes)
- The timing window spans multiple periods, making collisions likely

**Attack Complexity**: LOW - No special privileges needed beyond being a scheme manager (authorized role). The exploit occurs through normal contract operations, not requiring transaction manipulation or re-entrancy. A manager could intentionally trigger this by:
1. Distributing profits with delay
2. Adding then removing large numbers of beneficiaries
3. Waiting for the cached period to arrive

**Detection**: Difficult - negative TotalShares in cached values aren't exposed in events or view functions until actual distribution occurs, at which point the corruption has already happened.

### Recommendation
Add validation in `RemoveBeneficiary` to prevent negative cached values:

```csharp
if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
{
    var currentCached = scheme.CachedDelayTotalShares[removedPeriod];
    var newCached = currentCached.Sub(removedShares);
    Assert(newCached >= 0, $"Cannot reduce cached shares below zero for period {removedPeriod}");
    scheme.CachedDelayTotalShares[removedPeriod] = newCached;
}
```

Additionally, add a safety check in `ProfitAllPeriods` before using cached shares:

```csharp
if (distributedProfitsInformation == null || 
    distributedProfitsInformation.TotalShares <= 0 ||  // Changed from == 0
    !distributedProfitsInformation.AmountsMap.Any() ||
    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
    continue;
```

Add comprehensive test cases covering:
- Adding/removing beneficiaries across delay periods
- Removing more shares than existed in cached snapshots
- Validating cached values remain non-negative throughout

### Proof of Concept
**Initial State**: Create scheme with DelayDistributePeriodCount = 2

**Transaction Sequence**:
1. Period 1: `AddBeneficiary(Alice, 100 shares)` → TotalShares = 100
2. Period 1: `DistributeProfits(1000 tokens, period=1)` → CachedDelayTotalShares[3] = 100, burns tokens (delay not elapsed)
3. Period 2: `AddBeneficiary(Bob, 60 shares)` → TotalShares = 160  
4. Period 2: `RemoveBeneficiary(Alice)` → Removes 100 shares, subtracts from Cache[3]: **100 - 100 = 0**
5. Period 2: `RemoveBeneficiary(Bob)` → Removes 60 shares, subtracts from Cache[3]: **0 - 60 = -60** ⚠️
6. Period 3: `DistributeProfits(1000 tokens, period=3)` → Retrieves Cache[3] = -60, stores in DistributedProfitsInfo.TotalShares = **-60**
7. Period 4: `ClaimProfits(Alice, 50 shares)` → Calls SafeCalculateProfits(50, 1000, -60) = **(1000 * 50) / -60 = -833** ⚠️

**Expected Result**: Profit calculation should use non-negative TotalShares reflecting actual scheme state

**Actual Result**: SafeCalculateProfits returns negative value due to division by negative TotalShares, causing either transfer failure or fund misallocation

**Success Condition**: GetDistributedProfitsInfo for period 3 shows TotalShares = -60, demonstrating the cached value corruption

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L866-871)
```csharp
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
