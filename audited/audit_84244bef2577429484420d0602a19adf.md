### Title
Insufficient Amount Validation in Parliament Contract Allows Zero Method Fees

### Summary
The `AssertValidToken` function in Parliament contract validates method fee amounts using `amount >= 0`, allowing zero values to pass validation. This is inconsistent with the Token contract's stricter validation (`amount > 0`) and contradicts test expectations. While a proper mechanism exists for free methods (IsSizeFeeFree flag), setting BasicFee to zero provides an alternate, unvalidated bypass of fee collection. [1](#0-0) 

### Finding Description

The Parliament contract's `AssertValidToken` function uses insufficient validation that allows zero method fees: [2](#0-1) 

This contrasts with the Token contract's stricter validation that explicitly rejects zero amounts: [3](#0-2) 

The Token contract uses `AssertValidSymbolAndAmount` which checks `amount > 0`, properly rejecting zero values. Test cases confirm zero should fail: [4](#0-3) 

The same validation gap exists in other governance contracts (Association, Genesis, Configuration, etc.) that also use `amount >= 0`: [5](#0-4) 

When method fees are set via `SetMethodFee`, the validation is called but zero passes through: [6](#0-5) 

During fee charging, zero amounts are effectively skipped without balance modification: [7](#0-6) 

### Impact Explanation

Governance can set method fees to exactly zero for Parliament contract methods, resulting in:

1. **Fee Bypass**: Users calling governance methods (CreateProposal, Approve, Release, etc.) incur zero transaction fees for the base fee component
2. **Revenue Loss**: Block producers lose legitimate method fee revenue from governance operations
3. **Inconsistent Protocol Behavior**: Different validation standards across contracts create unpredictable fee enforcement

The proper mechanism for free methods exists through the IsSizeFeeFree flag with empty fee lists: [8](#0-7) 

Setting BasicFee=0 provides an unvalidated alternate path that bypasses the intended fee architecture. While not directly exploitable for fund theft, it undermines the protocol's fee collection invariant.

### Likelihood Explanation

This requires MethodFeeController (Parliament governance by default) to call SetMethodFee with zero amounts: [9](#0-8) 

Exploitation scenarios:
- **Governance Error**: Mistaken proposal setting fees to zero
- **Governance Compromise**: Malicious proposal exploiting validation gap
- **Configuration Drift**: Unintended zero values during fee updates

The attack complexity is low (single transaction), but requires privileged access. However, the validation inconsistency itself represents a security weakness regardless of governance trust assumptions.

### Recommendation

1. **Align Validation**: Change all `AssertValidToken` implementations to match Token contract's stricter check:
   ```
   Assert(amount > 0, "Invalid amount.");
   ```
   Apply this fix to: Parliament, Association, Genesis, Configuration, Referendum, and other ACS1 implementing contracts.

2. **Add Regression Tests**: Create test cases verifying zero amount rejection across all contracts implementing ACS1:
   - Test SetMethodFee with BasicFee=0 expects "Invalid amount" error
   - Verify consistent validation across all governance contracts

3. **Document Fee Architecture**: Clarify that zero fees are not supported, and free methods must use IsSizeFeeFree flag with empty Fees list.

### Proof of Concept

**Initial State:**
- Parliament contract deployed with default MethodFeeController (Parliament default organization)
- Method fee for "CreateProposal" set to 100 ELF

**Exploit Steps:**

1. Governance creates proposal to call Parliament.SetMethodFee with:
   ```
   MethodName: "CreateProposal"
   Fees: [{ Symbol: "ELF", BasicFee: 0 }]
   ```

2. Proposal approved and released by governance

3. Result: AssertValidToken allows zero (amount >= 0 passes)

4. Users calling CreateProposal now pay zero base fee

**Expected vs Actual:**
- Expected: SetMethodFee rejects zero with "Invalid amount" (like Token contract)
- Actual: SetMethodFee accepts zero, fee charging bypassed

**Verification:**
Compare behavior with Token contract attempting same operation - Token contract properly rejects zero while Parliament contract accepts it, confirming validation inconsistency.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L80-89)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L180-193)
```csharp
        // invalid fee
        {
            var basicFee = 0;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Invalid amount");
        }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L76-85)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-255)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```
