# Audit Report

## Title
Mining Order Collision via Unchecked TuneOrderInformation Allows Time Slot Conflicts and Consensus Disruption

## Summary
The AEDPoS consensus contract allows malicious miners to inject colliding `FinalOrderOfNextRound` values through the `TuneOrderInformation` field without validation, causing multiple miners to be assigned identical mining time slots in subsequent rounds. This breaks the fundamental consensus invariant of unique time slot assignment per miner.

## Finding Description

The vulnerability exists in the consensus round update flow where order collision validation is completely missing for `UpdateValue` behavior.

**Root Cause:**

The `ProcessUpdateValue` method directly applies `TuneOrderInformation` from consensus extra data without validating uniqueness of `FinalOrderOfNextRound` values: [1](#0-0) 

These values are blindly written to state for all affected miners with no collision checks.

**Missing Validation:**

For `UpdateValue` behavior, the validation pipeline only includes `UpdateValueValidationProvider` and `LibInformationValidationProvider`: [2](#0-1) 

The `UpdateValueValidationProvider` only validates that OutValue/Signature are filled and that PreviousInValue is correct - it performs no order collision checks: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` exists but is only used for `NextRound` behavior, not `UpdateValue`: [4](#0-3) 

**How Legitimate Collision Resolution is Bypassed:**

Normal flow uses collision resolution in `ApplyNormalConsensusData`: [5](#0-4) 

However, this only applies when honest miners generate consensus extra data. A malicious miner can:

1. Generate legitimate consensus extra data with collision-resolved orders
2. Modify the `Round` object in consensus extra data to inject colliding `FinalOrderOfNextRound` values
3. Include this modified data in their block header

During validation, `RecoverFromUpdateValue` directly overwrites the `FinalOrderOfNextRound` values from the provided Round: [6](#0-5) 

The simplified Round in consensus extra data includes `FinalOrderOfNextRound` for all miners: [7](#0-6) 

**Direct Impact on Next Round Generation:**

When the next round is generated, miners' `Order` values are directly assigned from their `FinalOrderOfNextRound`: [8](#0-7) 

Multiple miners with identical `FinalOrderOfNextRound` values will receive:
- Identical `Order` values (line 28, 32)
- Identical `ExpectedMiningTime` values (line 33)

This creates a time slot collision where multiple miners believe they should mine at exactly the same time.

## Impact Explanation

**HIGH Severity - Consensus Integrity Violation:**

- **Broken Invariant:** The core consensus mechanism requires each miner to have a unique time slot. This vulnerability allows multiple miners to be assigned the same time slot, breaking this fundamental guarantee.

- **Consensus Disruption:** When multiple miners have identical `ExpectedMiningTime` values, both will attempt to mine at the same time, creating race conditions and potential consensus stalls.

- **No Recovery Mechanism:** Once colliding orders are written to state via `ProcessUpdateValue`, they persist until the next term transition. The network may fail to make progress during this period.

- **Blockchain Availability Impact:** Critical miners being assigned duplicate slots can prevent block production entirely if they're unable to coordinate who should actually mine.

- **Exploit Scope:** Any active miner can execute this attack, affecting all subsequent rounds until term transition.

## Likelihood Explanation

**HIGH Likelihood:**

**Attacker Requirements:**
- Must be an active miner (block producer) in the current consensus set
- Requires modified node software to craft malicious consensus extra data
- No additional governance permissions or key compromise needed

**Attack Complexity:**
- Straightforward technical execution - simply modify the `FinalOrderOfNextRound` values in the Round object before including in block header
- No complex cryptographic operations required
- No timing constraints or race conditions to exploit
- Single malicious block can inject colliding orders

**Feasibility:**
- Being in the active miner set is the intended precondition for participating in consensus
- Modifying consensus extra data before signing the block header is trivial with custom node software
- The malicious data passes all existing validations
- Attack persists across multiple rounds until term transition

**Detection:**
- Malicious input appears structurally valid to all existing validation providers
- Collision only becomes apparent when next round is generated
- No automated on-chain detection or rejection mechanism exists

## Recommendation

Add order collision validation to the `UpdateValueValidationProvider` or create a dedicated validator for `UpdateValue` behavior:

```csharp
// Add to UpdateValueValidationProvider.ValidateHeaderInformation or create new provider
private bool ValidateFinalOrdersAreDistinct(ConsensusValidationContext validationContext)
{
    var providedRound = validationContext.ProvidedRound;
    var finalOrders = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound)
        .ToList();
    
    var distinctCount = finalOrders.Distinct().Count();
    return distinctCount == finalOrders.Count;
}
```

Then add this validation to the pipeline for `UpdateValue` behavior in `AEDPoSContract_Validation.cs`:

```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider());
    validationProviders.Add(new FinalOrderCollisionValidationProvider()); // NEW
    break;
```

This ensures that any attempt to inject colliding `FinalOrderOfNextRound` values is rejected during validation before the malicious state can be written.

## Proof of Concept

A complete proof of concept would require:

1. Set up an AElf test environment with multiple miners
2. Modify one miner's node to craft a malicious `UpdateValueInput`:
   - Generate legitimate consensus extra data
   - Modify the Round to set multiple miners' `FinalOrderOfNextRound` to the same value (e.g., both MinerA and MinerB â†’ order 1)
   - Include this in a block and sign it
3. Submit the block for validation
4. Observe that validation passes despite the collision
5. Generate the next round and verify that multiple miners have identical `Order` and `ExpectedMiningTime` values
6. Attempt block production and observe the resulting time slot conflicts

The vulnerability is confirmed by tracing the code paths showing that no validation prevents this scenario, and `GenerateNextRoundInformation` directly assigns colliding orders without deduplication.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
