### Title
Retroactive Threshold Changes Enable Governance Denial-of-Service Attack

### Summary
The `ChangeOrganizationThreshold()` function allows modification of voting thresholds that retroactively affect all existing active proposals. An attacker can exploit this by creating a proposal to raise thresholds significantly, then after its approval, all pending legitimate proposals that had already gathered sufficient votes under the old threshold become permanently unreleasable, resulting in governance denial-of-service.

### Finding Description

**Root Cause:**

The vulnerability exists because proposal release thresholds are not stored with proposals at creation time. Instead, the `Release()` function dynamically fetches the current threshold from the organization state at release time. [1](#0-0) 

When `Release()` is called, it invokes `IsReleaseThresholdReached()` which reads the current threshold from the organization: [2](#0-1) 

The `ProposalInfo` structure does not store the threshold that was active when the proposal was created: [3](#0-2) 

**Why Protections Fail:**

The `ChangeOrganizationThreshold()` function modifies the threshold in-place and only validates that the new threshold values are structurally valid (positive numbers, proper relationships), but does not check whether this change would invalidate existing proposals: [4](#0-3) 

The validation function only checks structural correctness of the new threshold, not its impact on pending proposals: [5](#0-4) 

**Execution Path:**

1. Organization has threshold (e.g., MinimalApprovalThreshold = 10,000 tokens)
2. Legitimate Proposal A created and gathers 10,500 tokens approval (passes threshold)
3. Attacker (in proposer whitelist) creates Proposal B calling `ChangeOrganizationThreshold` with MinimalApprovalThreshold = 1,000,000 tokens
4. Proposal B gets approved under current threshold and is released
5. Threshold now permanently raised to 1,000,000 tokens
6. Proposal A can no longer be released despite having passed original threshold

### Impact Explanation

**Concrete Harm:**

This vulnerability enables a governance denial-of-service attack that can:

- **Block Legitimate Proposals**: Any pending proposals that had gathered sufficient votes under the old threshold become permanently unreleasable, even though they met the requirements at the time
- **Prevent Critical Operations**: Can block time-sensitive governance actions such as security upgrades, emergency fund releases, or protocol parameter adjustments
- **Hostage Governance**: Attacker can demand concessions to lower thresholds back, holding the governance system hostage

**Affected Parties:**

- All organization members whose legitimate proposals become blocked
- The entire protocol if critical governance decisions are prevented
- Token holders who participated in voting on now-blocked proposals

**Severity Justification: HIGH**

This is HIGH severity because it:
- Directly compromises the critical governance invariant (organization thresholds must protect, not harm legitimate proposals)
- Can cause operational DoS of the governance system
- Has concrete, demonstrable impact verified by existing tests
- Affects all three governance contracts (Referendum, Association, Parliament)

### Likelihood Explanation

**Attacker Capabilities Required:**

1. Be in the organization's proposer whitelist (common for organization members)
2. Accumulate sufficient tokens/votes to pass ONE malicious proposal under current threshold
3. Execute the standard proposal creation and approval process

**Attack Complexity: LOW**

The attack is straightforward:
- Uses standard proposal mechanisms
- No special technical knowledge required
- Single malicious proposal execution needed

**Feasibility Conditions:**

- **Token Accumulation**: Attacker can gradually accumulate tokens over time or collude with other members
- **Low Participation Periods**: Easier to pass malicious proposals during periods of low voter participation
- **Economic Rationality**: Cost of acquiring tokens for one proposal approval may be justified by benefit of blocking competing proposals or extracting ransom

**Detection/Operational Constraints:**

- Malicious threshold-change proposals are difficult to distinguish from legitimate governance improvements
- Once executed, damage is immediate and irreversible for affected proposals
- No time-lock or review period on threshold changes

**Probability: MEDIUM to HIGH**

Given that organization members can typically propose and vote, and threshold changes are legitimate governance functions, the attack is practically feasible.

### Recommendation

**Code-Level Mitigation:**

1. **Store Threshold at Proposal Creation**: Modify `ProposalInfo` to store the threshold that was active when the proposal was created:

```protobuf
message ProposalInfo {
    // ... existing fields ...
    ProposalReleaseThreshold creation_threshold = 14;
}
```

2. **Check Against Creation Threshold**: Modify `Release()` to use the stored threshold instead of current threshold:

```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    var organization = State.Organizations[proposal.OrganizationAddress];
    
    // Use threshold from proposal creation time
    var thresholdToCheck = proposal.CreationThreshold ?? organization.ProposalReleaseThreshold;
    Assert(IsReleaseThresholdReached(proposal, thresholdToCheck), "Not approved.");
    
    // ... rest of release logic
}
```

3. **Add Invariant Check**: Add assertion to prevent threshold changes that would invalidate existing proposals with sufficient votes.

**Test Cases to Prevent Regression:**

- Create proposal under threshold T1
- Gather sufficient votes under T1
- Change threshold to T2 > T1
- Verify proposal can still be released (should pass under T1)
- Create new proposal under T2
- Verify new proposal requires T2 (not T1)

### Proof of Concept

**Test Evidence:**

The existing test suite already demonstrates this vulnerability: [6](#0-5) 

**Exploit Sequence:**

1. **Initial State**: 
   - Organization with MinimalApprovalThreshold = 5000 tokens
   - Proposal A created and approved with 5000 tokens
   - Proposal A shows `ToBeReleased = true`

2. **Attack Execution**:
   - Attacker creates Proposal B to change threshold to 20000 tokens
   - Proposal B approved under current threshold (5000 tokens)
   - Proposal B released, executing `ChangeOrganizationThreshold()`

3. **Result**:
   - Threshold now 20000 tokens
   - Proposal A still has only 5000 approval tokens
   - Proposal A now shows `ToBeReleased = false`
   - Proposal A can NEVER be released despite having met original requirements

**Success Condition**: 

The test at lines 758-759 explicitly verifies that after threshold change, the same proposal's `ToBeReleased` status changes from `true` to `false`, confirming the retroactive effect and demonstrating the vulnerability.

### Notes

This vulnerability affects all three governance contracts identically:
- Referendum contract: [4](#0-3) 
- Association contract: [7](#0-6) 
- Parliament contract: [8](#0-7) 

All three contracts should be patched with the same mitigation strategy to prevent this governance attack vector.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** protobuf/referendum_contract.proto (L81-108)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // The count of approved.
    int64 approval_count = 8;
    // The count of rejected.
    int64 rejection_count = 9;
    // The count of abstained.
    int64 abstention_count = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L700-760)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        var minimalApproveThreshold = 5000;
        var minimalVoteThreshold = 5000;
        var maximalRejectionThreshold = 10000;
        var maximalAbstentionThreshold = 10000;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, new[] { DefaultSender });
        var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
        var keyPair = Accounts[3].KeyPair;
        await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, proposalId);
        await ApproveAsync(Accounts[3].KeyPair, proposalId);
        var proposal = await ReferendumContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();

        // invalid sender
        {
            var ret =
                await ReferendumContractStub.ChangeOrganizationThreshold.SendWithExceptionAsync(
                    new ProposalReleaseThreshold());
            ret.TransactionResult.Error.ShouldContain("Organization not found");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 20000
            };

            var changeProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                proposalReleaseThresholdInput,
                nameof(ReferendumContractStub.ChangeOrganizationThreshold), organizationAddress,
                ReferendumContractAddress);
            await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, changeProposalId);
            await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
            var referendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var result = await referendumContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 20000,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var changeProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                proposalReleaseThresholdInput,
                nameof(ReferendumContractStub.ChangeOrganizationThreshold), organizationAddress,
                ReferendumContractAddress);
            await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, changeProposalId);
            await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
            var referendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var result = await referendumContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await referendumContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-215)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```
