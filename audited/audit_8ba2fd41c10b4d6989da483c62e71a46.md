### Title
Metadata Desynchronization Between NFT Contract and MultiToken Contract

### Summary
The NFT contract stores a static copy of metadata at protocol creation time, while the MultiToken contract can update its ExternalInfo after token creation through authorized methods. This creates a permanent desynchronization where the NFT contract's metadata becomes stale, affecting protocol queries and newly minted NFT metadata inheritance.

### Finding Description

During NFT protocol creation, the NFT contract creates a token in the MultiToken contract and stores a copy of the metadata locally: [1](#0-0) 

The `tokenExternalInfo` is passed to the MultiToken contract at line 34 and simultaneously copied to the NFT contract's state at line 46. However, the MultiToken contract provides methods that can update the ExternalInfo after token creation:

1. **ExtendSeedExpirationTime** - Updates the `__seed_exp_time` key: [2](#0-1) 

2. **SetSymbolAlias** - Updates the `aelf_token_alias` key: [3](#0-2) 

Both methods modify `tokenInfo.ExternalInfo.Value` and save it back to `State.TokenInfos`, but there is no mechanism to propagate these updates to the NFT contract's `State.NftProtocolMap[symbol].Metadata`.

The NFT contract has no method to update protocol-level metadata after creation. All writes to `NftProtocolMap` only update non-metadata fields like Supply and Issued: [4](#0-3) 

### Impact Explanation

The desynchronization creates three concrete operational impacts:

1. **Stale Protocol Queries**: The `GetNFTProtocolInfo` view method returns outdated metadata: [5](#0-4) 

2. **Inherited Stale Metadata**: Newly minted NFTs inherit metadata from the protocol's stale copy: [6](#0-5) 

3. **Cross-Contract Inconsistency**: dApps querying both contracts receive conflicting metadata, potentially causing integration issues or display errors.

The severity is LOW because:
- No funds are at risk
- Only specific metadata keys are affected (`__seed_exp_time`, `aelf_token_alias`)
- Core NFT operations (minting, transferring, burning) remain functional
- The desync requires legitimate owner/issuer actions

### Likelihood Explanation

The desynchronization occurs through normal operational flows:

**Preconditions:**
- NFT protocol must be created via the Create or CrossChainCreate method
- Token owner or issuer must call MultiToken methods that update ExternalInfo

**Execution Path:**
1. Owner/issuer creates NFT protocol through `NFTContract.Create`
2. Owner/issuer later calls `MultiToken.SetSymbolAlias` to set a token alias (requires owner or issuer permission as checked at line 760)
3. MultiToken's ExternalInfo is updated but NFT contract's Metadata remains unchanged
4. Any subsequent calls to `GetNFTProtocolInfo` return stale metadata

**Probability:** MEDIUM
- Requires owner/issuer to perform legitimate operations
- `SetSymbolAlias` is a documented feature for NFT collections
- `ExtendSeedExpirationTime` is used for SEED NFT management
- No attack required - occurs during normal protocol lifecycle

### Recommendation

**Implement Metadata Synchronization Mechanism:**

1. Add a view method in MultiToken contract to fetch current ExternalInfo
2. Add an update method in NFT contract:
```
public override Empty SyncProtocolMetadata(StringValue input)
{
    var protocolInfo = State.NftProtocolMap[input.Value];
    Assert(protocolInfo != null, "Protocol not found");
    
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = input.Value 
    });
    
    protocolInfo.Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } };
    State.NftProtocolMap[input.Value] = protocolInfo;
    
    return new Empty();
}
```

3. Alternatively, modify `GetNFTProtocolInfo` to fetch metadata from MultiToken contract in real-time rather than returning cached copy

4. Add integration tests that verify metadata consistency after MultiToken ExternalInfo updates

### Proof of Concept

**Initial State:**
- NFT protocol "SG123456" created with empty custom metadata
- Protocol stored in NFT contract with Metadata containing only reserved keys

**Transaction Sequence:**
1. Owner calls `MultiToken.SetSymbolAlias` with Symbol="SG123456-1", Alias="SG"
2. MultiToken updates `tokenInfo.ExternalInfo.Value["aelf_token_alias"]` to `{"SG123456-1":"SG"}`
3. Owner calls `NFTContract.GetNFTProtocolInfo` with input.Value="SG123456"

**Expected Result:**
- NFT protocol metadata should include the `aelf_token_alias` key with the alias mapping

**Actual Result:**
- NFT protocol metadata does NOT include the `aelf_token_alias` key
- The metadata remains as originally set during protocol creation
- MultiToken contract has the updated ExternalInfo, but NFT contract has stale Metadata

**Success Condition:**
The desynchronization is confirmed when `State.TokenInfos["SG123456"].ExternalInfo` contains the alias key but `State.NftProtocolMap["SG123456"].Metadata` does not.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L21-46)
```csharp
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L95-98)
```csharp
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L408-413)
```csharp
        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L9-12)
```csharp
    public override NFTProtocolInfo GetNFTProtocolInfo(StringValue input)
    {
        return State.NftProtocolMap[input.Value];
    }
```
