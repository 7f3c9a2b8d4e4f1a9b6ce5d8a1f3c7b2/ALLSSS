### Title
Inconsistent Time Slot Validation Allows Consensus Disruption via Non-Uniform Mining Intervals

### Summary
The `CheckRoundTimeSlots` validation permits mining intervals up to 2x the base interval, while `GetMiningInterval` only examines the first two miners. A malicious miner can exploit this discrepancy to inject round data with non-uniform intervals that pass validation but break downstream consensus logic, causing block production gaps and time slot calculation errors.

### Finding Description

**Root Cause:**

The validation logic in `CheckRoundTimeSlots` uses a tolerance check that permits intervals to differ by up to `baseMiningInterval` from the base: [1](#0-0) 

This condition `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval` only fails when the difference **exceeds** the base interval. An interval exactly 2x the base (difference equals base) passes validation.

Meanwhile, `GetMiningInterval` only examines miners with `Order == 1 || Order == 2`: [2](#0-1) 

This creates a mismatch: validation checks all consecutive pairs, but the returned interval only reflects the first two miners.

**Exploitation Path:**

1. A malicious miner crafts a `NextRoundInput` with non-uniform intervals (e.g., Orders 1-2: 4000ms, Orders 2-3: 4000ms, Orders 3-4: 8000ms)
2. The round passes `CheckRoundTimeSlots` validation called via `TimeSlotValidationProvider`: [3](#0-2) 

3. `ProcessNextRound` accepts the malicious round after `PreCheck` verifies the sender is a valid miner: [4](#0-3) 

4. The round is stored with inconsistent intervals, but `GetMiningInterval()` returns only the first interval (4000ms)

**Why Protections Fail:**

The `PreCheck` only verifies miner list membership, not round data integrity: [5](#0-4) 

No verification exists that the submitted round matches the canonical `GenerateNextRoundInformation` output, which always produces uniform intervals: [6](#0-5) 

### Impact Explanation

**Consensus Disruption:**

Downstream logic assumes uniform intervals based on `GetMiningInterval()`, causing critical failures:

1. **IsCurrentMiner Time Window Calculation** - Uses `GetMiningInterval()` to determine if current time is within a miner's slot: [7](#0-6) 

For a miner with actual 8000ms interval but `GetMiningInterval()` returning 4000ms, the check creates a 4000ms gap where NO miner is considered current, halting block production.

2. **IsTimeSlotPassed Premature Expiration** - Marks time slots as passed 4000ms too early: [8](#0-7) 

3. **ArrangeAbnormalMiningTime Incorrect Scheduling** - Calculates wrong future mining times: [9](#0-8) 

**Severity:** High - Complete consensus DoS possible, affecting all network participants. Block production halts during gap periods, violating the "miner schedule integrity" invariant.

### Likelihood Explanation

**Attacker Requirements:**
- Must be a valid miner in current or previous round (to pass `PreCheck`)
- Can submit raw `NextRound` transaction with crafted `NextRoundInput`

**Attack Complexity:** Low
- Validation bypass is deterministic (tolerance boundary at 2x)
- No special timing or race conditions required
- Single transaction execution

**Feasibility:** High
- Any miner can craft malicious round data
- Validation occurs in `TimeSlotValidationProvider` before execution: [10](#0-9) 

- No additional authorization beyond miner status

**Detection Constraints:** Difficult to detect proactively - appears as valid round data until downstream functions fail

### Recommendation

**Immediate Fix:**

Strengthen `CheckRoundTimeSlots` to enforce strict equality (or tight tolerance, e.g., ±10ms for clock drift):

```
// Replace line 53 condition
if (Math.Abs(miningInterval - baseMiningInterval) > TOLERANCE_MS) // e.g., 100ms
    return new ValidationResult { Message = "Time slots must be uniform." };
```

**Additional Protection:**

Add a cross-check in `ProcessNextRound` to verify the submitted round matches canonical generation:

```
// In ProcessNextRound after line 114
Round expectedRound;
currentRound.GenerateNextRoundInformation(Context.CurrentBlockTime, 
    GetBlockchainStartTimestamp(), out expectedRound);
Assert(nextRound.GetMiningInterval() == expectedRound.GetMiningInterval(), 
    "Mining interval mismatch.");
```

**Invariant Enforcement:**

Add unit test verifying all consecutive mining intervals are equal within tolerance when `CheckRoundTimeSlots` passes.

### Proof of Concept

**Initial State:**
- 4 miners in current round with uniform 4000ms intervals
- Attacker is Miner A (Order 1 in next round)

**Attack Sequence:**

1. Attacker crafts malicious `NextRoundInput`:
   - Miner A (Order 1): ExpectedMiningTime = T
   - Miner B (Order 2): ExpectedMiningTime = T + 4000ms
   - Miner C (Order 3): ExpectedMiningTime = T + 8000ms  
   - Miner D (Order 4): ExpectedMiningTime = T + 16000ms (8000ms interval!)

2. Submit `NextRound` transaction with crafted input

3. **Validation passes**:
   - `baseMiningInterval` = 4000ms (Order 1→2)
   - Order 2→3: 4000ms, diff = 0 ≤ 4000 ✓
   - Order 3→4: 8000ms, diff = 4000 ≤ 4000 ✓ (boundary case!)

4. **Consensus disruption**:
   - `GetMiningInterval()` returns 4000ms
   - At time T + 12000ms (4000ms after Miner C's expected time):
     - `IsCurrentMiner(C)` returns false (outside 4000ms window)
     - `IsCurrentMiner(D)` returns false (not yet at T + 16000ms)
     - **NO MINER CAN PRODUCE BLOCKS for 4000ms gap**

**Expected Result:** Round rejected or uniform intervals enforced

**Actual Result:** Malicious round accepted, consensus halted during gap periods

### Notes

The legitimate `GenerateNextRoundInformation` always produces uniform intervals using `miningInterval.Mul(order)`, making this purely an injection attack exploiting inadequate validation, not a logic flaw in normal round generation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L49-55)
```csharp
        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L85-90)
```csharp
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L17-18)
```csharp
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-36)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L157-167)
```csharp
        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L22-36)
```csharp
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L70-71)
```csharp
            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),
```
