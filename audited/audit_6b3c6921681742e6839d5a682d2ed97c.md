### Title
Input Collision Vulnerability in Token Hash Calculation Allows Cross-Protocol Balance Manipulation

### Summary
The NFT contract's token hash calculation concatenates symbol and tokenId strings without a delimiter, enabling different (symbol, tokenId) pairs to produce identical hashes. [1](#0-0)  This causes multiple distinct tokens to share the same storage slots for balances, allowances, and metadata, potentially enabling unauthorized token transfers and balance confusion.

### Finding Description

The root cause lies in the `CalculateTokenHash` function which computes token identifiers by simple string concatenation without delimiters. [1](#0-0) 

**Input Collision Examples:**
- Symbol="AR123456789", tokenId=0 → hash("AR1234567890")  
- Symbol="AR1234567", tokenId=890 → hash("AR1234567890")

Both produce identical hashes despite representing different tokens.

**Affected State Mappings:**
All critical state storage uses this colliding tokenHash as the key:
- `State.BalanceMap[tokenHash]` - shared balances [2](#0-1) 
- `State.AllowanceMap[tokenHash]` - shared allowances [3](#0-2) 
- `State.NftInfoMap[tokenHash]` - shared metadata [4](#0-3) 

**Exploitation Path:**
1. Attacker identifies valuable token at symbol="AR123456789", tokenId=0
2. Attacker creates token "AR1234567" in MultiToken contract (requires seed NFT or whitelist) [5](#0-4) 
3. Attacker calls `CrossChainCreate` to register protocol in NFT contract [6](#0-5) 
4. Attacker mints tokens with tokenId=890, sharing the tokenHash
5. Transfer operations use the shared balance pool: [7](#0-6) 

The vulnerability affects not just view functions but all state-modifying operations including Transfer, TransferFrom, Approve, Burn, and Recast.

### Impact Explanation

**Direct Fund Impact:**
- Attackers can transfer tokens from the shared balance pool that they don't legitimately own
- Victims holding tokens in colliding protocols lose control over their balances
- Balance queries return incorrect aggregated values across different protocols [8](#0-7) 

**Quantified Damage:**
- Arbitrary token amounts can be stolen from the shared balance
- All NFTs with colliding tokenHashes are affected simultaneously
- Protocol reputation damage when users discover balance inconsistencies

**Affected Parties:**
- Holders of NFTs in any protocol susceptible to collision
- Protocols with symbols that can be exploited (e.g., variable-length numeric suffixes)
- Secondary markets relying on accurate balance information

**Severity Justification:**  
HIGH - Direct token theft is possible. While exploitation requires seed NFT acquisition or whitelist access, the fundamental design flaw enables theft of arbitrary amounts once collision conditions are met. The impact extends beyond the specific function questioned to all balance-dependent operations.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Create colliding token in MultiToken contract via:
   - Option A: Acquire seed NFT for target symbol [9](#0-8) 
   - Option B: Be in create whitelist (trusted role - reduces likelihood)
2. Call `CrossChainCreate` in NFT contract (permissionless once token exists)
3. Mint tokens with calculated tokenId to produce collision
4. Execute transfer operations

**Attack Complexity:**
- MEDIUM: Requires understanding of string concatenation vulnerability
- Mathematical calculation to determine collision parameters is straightforward
- No cryptographic attack needed (this is input collision, not hash collision)

**Feasibility Conditions:**
- Seed NFT market must allow acquisition of specific symbol seeds
- If seed NFTs for arbitrary symbols are tradeable/purchasable: HIGH feasibility
- If seed NFTs are tightly controlled: LOW feasibility  
- Natural accidental collisions: VERY LOW (but non-zero with many protocols)

**Detection Constraints:**
- Collision is observable on-chain through duplicate tokenHashes
- However, identifying vulnerability before exploitation requires code analysis
- No automatic runtime detection mechanism exists

**Probability Assessment:**
MEDIUM overall - While preconditions exist, the core vulnerability is exploitable given sufficient resources for seed NFT acquisition. The permanent nature of the flaw means probability increases over time as more protocols deploy.

### Recommendation

**Immediate Mitigation:**
Modify `CalculateTokenHash` to use structured encoding with delimiter:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Use protobuf message or explicit delimiter
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
    // OR use proper structured encoding:
    // return HashHelper.ComputeFrom(
    //     new CalculateTokenHashInput { Symbol = symbol, TokenId = tokenId }
    // );
}
``` [1](#0-0) 

**Invariant Checks:**
Add validation in `CrossChainCreate` to prevent symbols that could collide with existing tokenHashes:
- Check symbol format matches expected pattern (e.g., [2-letter][9+digits])
- Validate minimum digit count in numeric suffix
- Reject symbols with lengths that could produce collisions

**Testing Requirements:**
1. Unit test: Verify different (symbol, tokenId) pairs produce different hashes
2. Integration test: Attempt collision attack scenario
3. Fuzzing: Test various symbol/tokenId combinations for collisions

### Proof of Concept

**Initial State:**
- Protocol "AR123456789" exists with valuable NFT at tokenId=0
- User Alice owns 100 units at State.BalanceMap[hash("AR1234567890")][Alice]

**Attack Steps:**
1. Attacker acquires seed NFT for symbol "AR1234567"
2. Attacker calls MultiToken.Create(symbol="AR1234567", ...)
3. Attacker calls NFT.CrossChainCreate(symbol="AR1234567")  
4. Attacker mints NFT with symbol="AR1234567", tokenId=890
5. Both tokens now share tokenHash = hash("AR1234567890")

**Expected vs Actual:**
- Expected: Separate balances for symbol="AR123456789":0 and symbol="AR1234567":890
- Actual: Single shared balance at State.BalanceMap[hash("AR1234567890")]

**Success Condition:**
Attacker calls Transfer(symbol="AR1234567", tokenId=890, amount=50) successfully transfers 50 units from the shared pool, reducing Alice's effective balance despite Alice never approving or owning tokens from protocol "AR1234567".

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-308)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
        Context.Fire(new Approved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L20-30)
```csharp
    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L44-52)
```csharp
    public override GetBalanceOutput GetBalanceByTokenHash(GetBalanceByTokenHashInput input)
    {
        return new GetBalanceOutput
        {
            Owner = input.Owner,
            Balance = State.BalanceMap[input.TokenHash][input.Owner],
            TokenHash = input.TokenHash
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-66)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-109)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

```
