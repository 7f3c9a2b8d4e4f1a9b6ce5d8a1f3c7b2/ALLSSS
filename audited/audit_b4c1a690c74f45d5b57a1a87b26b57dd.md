# Audit Report

## Title
Missing Validation of Other Miners' PreviousInValue Allows Mining Order Manipulation

## Summary
The AEDPoS consensus contract fails to validate `PreviousInValue` entries for other miners submitted via the `miners_previous_in_values` field in `UpdateValueInput`. This allows a malicious miner to corrupt the stored `PreviousInValue` for other miners, which is subsequently used to calculate signatures and determine mining order when those miners miss their time slots, breaking consensus determinism.

## Finding Description

The vulnerability exists in a validation gap in the consensus update flow. The `ValidatePreviousInValue` method only validates the **sender's** `PreviousInValue`, checking that the hash of their previous in value matches their previous out value. [1](#0-0) 

However, when a miner submits `UpdateValueInput`, they can provide `PreviousInValue` for **all miners** via the `miners_previous_in_values` map field. The legitimate usage populates this field from current state. [2](#0-1) 

These unvalidated values are then **unconditionally written to state** in the `PerformSecretSharing` method without any validation against the miners' actual previous round outputs. [3](#0-2) 

When miners miss their time slots, `SupplyCurrentRoundInformation` is called during round transitions. It retrieves the `PreviousInValue` from state for miners who didn't produce blocks. [4](#0-3) 

This potentially corrupted value is used to calculate their signature. [5](#0-4) 

The signature then determines the mining order for the next round through a modulo operation on the signature value. [6](#0-5) 

**Attack Flow:**
1. Secret sharing is enabled on the network
2. Miner B misses their time slot in the current round
3. Malicious Miner A produces their block and submits `UpdateValueInput` with a fake `PreviousInValue` for Miner B in the `miners_previous_in_values` map
4. The validation only checks Miner A's `PreviousInValue`, allowing the fake value for Miner B to pass
5. The fake value is written to state for Miner B
6. When `NextRound` is called, `SupplyCurrentRoundInformation` retrieves the corrupted value
7. A signature is calculated using the fake value
8. The signature determines Miner B's mining order in the next round via modulo operation

## Impact Explanation

**HIGH Impact** - This vulnerability breaks fundamental consensus guarantees:

1. **Consensus Determinism Violation**: Mining order should be deterministically derived from each miner's actual cryptographic commitments (InValue/OutValue chains). By allowing arbitrary manipulation of `PreviousInValue`, the attacker breaks this invariant.

2. **Mining Order Manipulation**: The attacker can control victim miners' positions in the next round's mining schedule, potentially positioning themselves or allies for extra block production opportunities or strategic timing advantages.

3. **Unfair Block Reward Distribution**: By manipulating mining order, the attacker can influence who becomes the extra block producer or affect the overall distribution of block production opportunities, leading to unfair reward accumulation.

4. **Protocol Integrity**: The secret sharing mechanism in AEDPoS relies on the integrity of these values for proper random number generation and consensus operation. Corrupting them undermines the protocol's security model.

While the impact is limited to miners who miss time slots (miners who produce blocks validate their own `PreviousInValue`), network conditions naturally cause missed slots, making this exploitable in practice.

## Likelihood Explanation

**MODERATE Likelihood**

**Attacker Requirements:**
- Must be an authorized miner in the current consensus set
- Secret sharing must be enabled (checked via configuration)

**Attack Complexity: LOW**
- Wait for another miner to miss their time slot
- Submit manipulated `miners_previous_in_values` in their own `UpdateValueInput`
- No special cryptographic attacks or complex timing required

**Realistic Preconditions:**
- Missed time slots occur naturally due to network latency, node failures, or high load
- Secret sharing is a standard feature of AEDPoS consensus
- Multiple miners in the consensus set means opportunities for exploitation

**Detection Difficulty:**
- The manipulation is not caught by validation since only the sender's value is checked
- Victim miners would need to actively monitor on-chain state and compare with their expected values
- No automatic detection mechanism exists

The combination of realistic preconditions and low attack complexity makes this vulnerability moderately likely to be exploited in production environments.

## Recommendation

Add validation for all entries in the `miners_previous_in_values` map, not just the sender's value. Modify the `ValidatePreviousInValue` method or add a new validation step in `PerformSecretSharing` to verify each miner's `PreviousInValue` against their previous round's `OutValue`:

```csharp
// In PerformSecretSharing method, before line 295:
foreach (var previousInValue in input.MinersPreviousInValues)
{
    // Validate each miner's PreviousInValue
    if (TryToGetPreviousRoundInformation(out var prevRound) && 
        prevRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
    {
        var previousOutValue = prevRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
        if (previousOutValue != null && previousInValue.Value != Hash.Empty)
        {
            Assert(HashHelper.ComputeFrom(previousInValue.Value) == previousOutValue, 
                $"Invalid PreviousInValue for miner {previousInValue.Key}");
        }
    }
    
    round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
}
```

This ensures that all `PreviousInValue` entries, not just the sender's, are cryptographically validated against the previous round's commitments.

## Proof of Concept

A proof of concept would require setting up a multi-node AEDPoS network with secret sharing enabled, then:

1. Configure 3+ miners (A, B, C)
2. Run consensus rounds until miner B misses a time slot
3. Have malicious miner A submit `UpdateValue` with corrupted `PreviousInValue` for B
4. Observe that the transaction succeeds and B's state is corrupted
5. Trigger round transition and verify B's mining order is manipulated based on the fake value

The test would demonstrate that miner A can successfully write arbitrary `PreviousInValue` for miner B, which then affects B's mining order calculation in the subsequent round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-191)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L199-199)
```csharp
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
