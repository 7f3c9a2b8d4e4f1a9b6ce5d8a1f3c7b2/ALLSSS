### Title
Missing Event Emission in MethodFeeController Changes Enables Silent Governance Takeovers

### Summary
The `ChangeMethodFeeController()` function in the TokenHolder contract updates the critical `MethodFeeController` state without emitting any event, creating a silent governance attack vector. This lack of audit trail prevents real-time monitoring, forensic analysis, and stakeholder notification, allowing malicious controller changes to go undetected until damage is done.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` function which updates the governance controller without event emission: [1](#0-0) 

After validating authorization and organization existence (lines 24-27), the function updates `State.MethodFeeController.Value` at line 29 and immediately returns without firing any event. This creates a complete absence of on-chain audit trail for controller changes.

**Root Cause:** Missing `Context.Fire()` event emission after state modification.

**Why Existing Protections Fail:**
- Authorization checks at line 25 only prevent unauthorized changes but don't create audit trails
- The `CheckOrganizationExist()` validation at line 26 verifies the new controller exists but doesn't log the change
- No event is defined in the ACS1 standard for controller changes [2](#0-1) 

**Comparison with Security Best Practice:**
The CrossChain contract demonstrates the proper pattern by emitting events for controller changes: [3](#0-2) 

Note how line 69 fires a `CrossChainIndexingControllerChanged` event immediately after state update at line 68. This pattern is repeated for all controller changes in that contract: [4](#0-3) 

The event definitions exist in the CrossChain proto: [5](#0-4) 

However, no such event exists for MethodFeeController changes across any ACS1 implementation (TokenHolder, MultiToken, Parliament, Treasury, etc.). [6](#0-5) [7](#0-6) 

### Impact Explanation

**Harm Mechanism:**
1. **Governance Transparency Loss:** Controller changes occur without any on-chain record, violating transparency principles for critical governance operations
2. **Monitoring Failure:** Off-chain monitoring systems and indexers cannot detect controller changes in real-time, eliminating early warning capabilities
3. **Forensic Analysis Impairment:** After a security incident, investigators cannot trace when/how controller changes occurred without manually querying state at each block
4. **Stakeholder Blindness:** Token holders and governance participants have no notification mechanism for controller changes

**Attack Scenario:**
1. Attacker submits governance proposal to change MethodFeeController to their controlled organization
2. Through social engineering, low participation, or other means, proposal gets approved
3. Proposal execution changes controller silently (no event emission)
4. No monitoring systems alert stakeholders
5. Attacker's organization now controls method fee settings
6. Attacker can manipulate fees to extract value or DoS the contract
7. By the time manual inspection discovers the change, damage is done and evidence trail is incomplete

**Affected Parties:**
- Contract users whose fees can be manipulated
- Governance participants who lose visibility into controller changes
- Security monitoring services that cannot track governance state
- Protocol operators investigating security incidents

**Severity Justification (Medium):**
- Impact: High governance transparency loss, enables stealthy attacks, impairs security monitoring
- Likelihood: Medium - requires governance approval but lack of detection significantly increases success probability of malicious proposals
- Not Critical because authorization checks still function, but defense-in-depth is compromised

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to submit and get approved a governance proposal (Parliament/Association/Referendum)
- Standard governance participation - no privilege escalation needed

**Attack Complexity:**
- Low technical complexity: Standard governance proposal execution
- Moderate social complexity: Must get proposal approved by governance

**Feasibility Conditions:**
- Governance participation is open per ACS3 standards
- Low voter turnout or attention to proposals increases success likelihood
- No technical barriers beyond normal governance process

**Detection/Operational Constraints:**
- **Critical Issue:** Without events, no automated detection possible
- Manual state queries required at each block to track changes
- Existing monitoring infrastructure cannot alert on controller changes
- Test frameworks don't verify event emission: [8](#0-7) 

Note lines 33-46 test controller change functionality but never check for event emission.

**Probability Reasoning:**
The absence of event emission transforms a detectable governance action into a silent one, significantly increasing the probability that malicious controller changes succeed undetected. This shifts the security model from "defense with monitoring" to "defense without visibility."

### Recommendation

**Code-Level Mitigation:**

1. **Define Event in ACS1 Standard:**
Add to `protobuf/acs1.proto`:
```protobuf
message MethodFeeControllerChanged {
    option (aelf.is_event) = true;
    // The new controller authority
    AuthorityInfo authority_info = 1;
}
```

2. **Emit Event in Implementation:**
Update `ChangeMethodFeeController()` in all ACS1 implementations:
```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    
    // ADD THIS:
    Context.Fire(new MethodFeeControllerChanged
    {
        AuthorityInfo = input
    });
    
    return new Empty();
}
```

3. **Add Test Coverage:**
Verify event emission in test cases:
```csharp
var result = await TokenHolderContractStub.ChangeMethodFeeController.SendAsync(input);
result.TransactionResult.Logs.Should().Contain(
    l => l.Name == nameof(MethodFeeControllerChanged));
```

4. **Apply to All Affected Contracts:**
    - TokenHolder
    - MultiToken  
    - Parliament
    - Association
    - Referendum
    - Treasury
    - Profit
    - Configuration
    - Election
    - Vote
    - Consensus (AEDPoS)
    - CrossChain (for consistency with existing pattern)
    - Economic
    - Genesis

**Invariant to Enforce:**
Every controller/authority state change MUST emit a corresponding event containing the new authority information.

### Proof of Concept

**Initial State:**
- TokenHolder contract deployed with default Parliament controller
- Default controller has address `DEFAULT_PARLIAMENT_ORG`

**Attack Sequence:**

1. **Setup:** Attacker creates controlled organization
```
attackerOrg = await Parliament.CreateOrganization(maliciousThreshold)
```

2. **Propose Controller Change:** Submit governance proposal
```
proposalId = await CreateProposal(
    targetContract: TokenHolderContract,
    method: "ChangeMethodFeeController",
    params: new AuthorityInfo {
        OwnerAddress: attackerOrg,
        ContractAddress: ParliamentContract
    }
)
```

3. **Execute Proposal:** Get approved and released
```
await ApproveProposal(proposalId)
await ReleaseProposal(proposalId)
```

4. **Verify Silent Change:**
```
// State changed but NO event emitted
var newController = await TokenHolder.GetMethodFeeController()
Assert(newController.OwnerAddress == attackerOrg)

// Check transaction logs - EXPECTED: MethodFeeControllerChanged event
// ACTUAL: No such event exists in logs
var logs = releaseResult.TransactionResult.Logs
Assert(logs.All(l => l.Name != "MethodFeeControllerChanged")) // Passes - proves vulnerability
```

5. **Demonstrate Monitoring Failure:**
```
// Off-chain indexer processing blocks
foreach(block in blockchain) {
    foreach(tx in block.Transactions) {
        foreach(log in tx.Logs) {
            if(log.Name == "MethodFeeControllerChanged") {
                AlertStakeholders() // NEVER TRIGGERED
            }
        }
    }
}
```

**Success Condition:** 
Controller change executes successfully with proper authorization but produces zero events, making it invisible to monitoring systems. The attacker's organization now controls method fees without any stakeholder notification or audit trail.

---

**Notes:**
This vulnerability affects all contracts implementing ACS1 (Transaction Fee Standard) across the AElf ecosystem. The issue is systemic rather than isolated to TokenHolder. The CrossChain contract demonstrates the correct security pattern that should be adopted blockchain-wide. This finding has broader implications for governance transparency and security monitoring infrastructure.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** protobuf/acs1.proto (L19-38)
```text
service MethodFeeProviderContract {
    
    // Set the method fees for the specified method. Note that this will override all fees of the method.
    rpc SetMethodFee (MethodFees) returns (google.protobuf.Empty) {
    }

    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
    
    // Query method fee information by method name.
    rpc GetMethodFee (google.protobuf.StringValue) returns (MethodFees) {
        option (aelf.is_view) = true;
    }

    // Query the method fee controller.
    rpc GetMethodFeeController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-74)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L76-86)
```csharp
    public override Empty ChangeSideChainLifetimeController(AuthorityInfo input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);
        Assert(ValidateAuthorityInfoExists(input), "Invalid authority input.");
        State.SideChainLifetimeController.Value = input;
        Context.Fire(new SideChainLifetimeControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
    }
```

**File:** protobuf/cross_chain_contract.proto (L249-253)
```text
message CrossChainIndexingControllerChanged{
    option (aelf.is_event) = true;
    // The changed controller of indexing.
    AuthorityInfo authority_info = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/ACS1_ImplementTest.cs (L15-47)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult =
            await ParliamentContractStub.CreateOrganization.SendAsync(
                new CreateOrganizationInput
                {
                    ProposalReleaseThreshold = new ProposalReleaseThreshold
                    {
                        MinimalApprovalThreshold = 1000,
                        MinimalVoteThreshold = 1000
                    }
                });
        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.TransactionResult.ReturnValue);

        var methodFeeController = await TokenHolderContractStub.GetMethodFeeController.CallAsync(new Empty());
        var defaultOrganization = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
        methodFeeController.OwnerAddress.ShouldBe(defaultOrganization);

        const string proposalCreationMethodName = nameof(TokenHolderContractStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(TokenHolderContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentContractAddress
            });
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await TokenHolderContractStub.GetMethodFeeController.CallAsync(new Empty());
        newMethodFeeController.OwnerAddress.ShouldBe(organizationAddress);
    }
```
