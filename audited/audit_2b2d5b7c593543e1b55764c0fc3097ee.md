### Title
Retroactive Vote Invalidation via Strategic Member Removal in Association Governance

### Summary
The Association contract's vote counting mechanism filters votes against the current organization member list, allowing votes from previously removed members to be retroactively invalidated. An attacker can manipulate governance outcomes by creating a proposal to remove members who have already voted, causing their votes to no longer count toward threshold calculations even though they were valid members when they voted.

### Finding Description

The vulnerability exists in how the Association contract counts votes when determining if a proposal meets its release threshold.

When members vote on a proposal, their addresses are stored in the proposal's `approvals`, `rejections`, or `abstentions` lists: [1](#0-0) 

The voting methods (`Approve`, `Reject`, `Abstain`) add the voter's address to these lists after validating current membership: [2](#0-1) 

However, when checking if a proposal can be released, the `IsReleaseThresholdReached` method counts votes by filtering against the **current** organization member list: [3](#0-2) 

Specifically, the vote counting uses `.Count(organization.OrganizationMemberList.Contains)` which only counts votes from addresses that are **currently** in the member list: [4](#0-3) [5](#0-4) 

The `Contains()` method simply checks current membership: [6](#0-5) 

The `RemoveMember` method can be called through the organization's proposal mechanism to remove any member: [7](#0-6) 

**Root Cause**: The vote counting logic checks membership at vote counting time rather than at vote casting time. This creates a temporal inconsistency where valid votes can be retroactively invalidated.

**Why Existing Protections Fail**: While `AssertIsAuthorizedOrganizationMember` validates membership when voting, there is no mechanism to preserve vote validity after a member is removed. The stored vote lists contain addresses without any timestamp or membership snapshot, allowing them to be filtered out later.

### Impact Explanation

**Concrete Harm**:
- **Governance Manipulation**: Attackers can block legitimate proposals by removing members who approved them, causing approval counts to fall below thresholds
- **Vote Invalidation**: Members who voted in good faith have their votes retroactively nullified without consent
- **Proposal Blocking**: Proposals that met release thresholds can be prevented from execution by strategically removing approvers
- **Proposal Forcing**: Malicious proposals can be pushed through by removing members who rejected them

**Attack Scenario**:
1. Organization has 5 members with threshold requiring 3 approvals
2. Proposal P1 receives 3 approvals from members A, B, C (meets threshold)
3. Attacker creates Proposal P2 to remove member A via `RemoveMember`
4. Proposal P2 passes with votes from B, C, and others
5. P2 executes, removing A from organization
6. When P1 is evaluated, only 2 approvals count (B and C), falling below threshold
7. P1 can no longer be released despite having met requirements when voted

**Who Is Affected**: All Association-based organizations using the governance mechanism, including any multi-signature wallets or DAOs built on this contract.

**Severity Justification**: HIGH - This directly undermines the integrity of the governance system, allowing manipulation of proposal outcomes through retroactive vote invalidation. It violates the fundamental invariant that approved proposals should remain approved unless explicitly changed through proper governance processes.

### Likelihood Explanation

**Attacker Capabilities**: Only requires ability to create proposals and coordinate votes - standard governance participation. No special privileges beyond being an authorized proposer and having sufficient member support.

**Attack Complexity**: Medium - Requires:
1. Creating a member removal proposal concurrent with target proposal
2. Coordinating sufficient votes to pass the removal proposal
3. Timing the removal before target proposal is released

**Feasibility Conditions**:
- Multiple active proposals can exist simultaneously (verified in code)
- RemoveMember is a standard governance action callable via proposals
- No time locks or delays prevent immediate removal
- Vote recounting happens on every `GetProposal` call and during `Release`

**Detection Constraints**: Difficult to detect as member management is a legitimate governance function. The attack leaves no obvious trace distinguishing it from normal organizational restructuring.

**Economic Rationality**: Cost is comparable to any governance action (transaction fees + coordination). Benefit is control over high-value proposals (treasury transfers, permission changes, etc.).

**Probability**: HIGH - The attack vector is straightforward, requires no special setup, and can be executed through normal contract operations.

### Recommendation

**Code-Level Mitigation**:

Option 1 (Recommended): Snapshot membership at vote time by storing voter validity
- Modify `ProposalInfo` to store `valid_voters` set representing members at vote time
- Update vote counting to check against this snapshot rather than current membership
- Preserve historical vote validity regardless of future membership changes

Option 2: Lock membership during active proposals
- Prevent `RemoveMember` when removed member has voted on any non-expired proposal
- Add validation in `RemoveMember` to check all active proposals
- Fail removal attempt if it would affect pending votes

Option 3: Separate vote invalidation mechanism
- Add explicit `InvalidateVote` governance action requiring separate proposal
- Make vote invalidation an intentional, transparent process
- Log all vote invalidations for audit trail

**Invariant Checks to Add**:
```
// In IsReleaseThresholdReached:
Assert: All counted votes were cast by addresses that were valid members at vote time
Assert: Vote counts cannot decrease due to membership changes alone

// In RemoveMember:
Assert: Removal does not affect any active proposal outcomes OR
Assert: Explicit approval required to invalidate existing votes
```

**Test Cases**:
1. Test member removal after voting - verify votes still count
2. Test concurrent proposals with overlapping membership changes
3. Test threshold calculations remain stable across membership changes
4. Test that proposals meeting threshold cannot fall below without explicit vote changes

### Proof of Concept

**Initial State**:
- Organization created with members: Alice, Bob, Carol, Dave, Eve
- ProposalReleaseThreshold: MinimalApprovalThreshold = 3, MinimalVoteThreshold = 4

**Transaction Sequence**:

1. **Create Proposal P1** (legitimate fund transfer)
   - Proposer: Alice
   - Action: Transfer funds from organization
   - Expected: Proposal created successfully

2. **Vote on P1**
   - Alice calls `Approve(P1)` → Success
   - Bob calls `Approve(P1)` → Success  
   - Carol calls `Approve(P1)` → Success
   - Dave calls `Reject(P1)` → Success
   - Call `GetProposal(P1)` → Returns `ToBeReleased = true` (3 approvals, 4 votes)

3. **Create Proposal P2** (malicious member removal)
   - Proposer: Bob
   - Action: `RemoveMember(Alice)`
   - Expected: Proposal created successfully

4. **Vote on P2**
   - Bob calls `Approve(P2)` → Success
   - Carol calls `Approve(P2)` → Success
   - Eve calls `Approve(P2)` → Success
   - Call `GetProposal(P2)` → Returns `ToBeReleased = true`

5. **Release P2**
   - Bob calls `Release(P2)` → Success
   - Alice removed from organization
   - Event `MemberRemoved(Alice)` emitted

6. **Attempt to Release P1**
   - Call `GetProposal(P1)` → Returns `ToBeReleased = false` (only 2 approvals counted now: Bob and Carol)
   - Alice calls `Release(P1)` → **FAILS** with "Not approved"

**Expected Result**: P1 should be releasable since it had 3 approvals when threshold was checked

**Actual Result**: P1 is no longer releasable because Alice's approval no longer counts after her removal, demonstrating retroactive vote invalidation

**Success Condition**: The attack succeeds if a proposal that previously met release threshold becomes non-releasable solely due to removing a member who had voted on it.

### Citations

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-59)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
