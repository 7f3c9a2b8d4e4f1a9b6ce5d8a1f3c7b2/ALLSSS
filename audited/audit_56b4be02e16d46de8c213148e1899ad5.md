# Audit Report

## Title
Parliament Governance DoS via Forced Managed Pubkey Accumulation

## Summary
The `AnnounceElectionFor` method in the Election contract allows any caller to designate an arbitrary address as admin without permission checks, enabling attackers to force accumulation of managed pubkeys in Parliament members' accounts. Since the Parliament contract explicitly rejects admins with multiple managed pubkeys from voting, attackers can permanently lock out Parliament members from all governance operations at a cost of 200,000 tokens per victim.

## Finding Description

**Root Cause - Missing Authorization Check:**

The `AnnounceElectionFor` method accepts an admin address parameter and directly assigns it without validating caller authorization. [1](#0-0) 

The method unconditionally adds the candidate's pubkey to the specified admin's `ManagedCandidatePubkeysMap` regardless of whether the caller has permission to designate that admin: [2](#0-1) 

The input structure allows the admin field to be any address: [3](#0-2) 

**Why Existing Protections Fail:**

The private `AnnounceElection` helper only validates that the pubkey is not an initial miner, not already a candidate, and not banned - but contains NO validation that the caller controls or owns the pubkey being announced: [4](#0-3) 

The only cost is the lock fee paid by the attacker (not the victim): [5](#0-4) 

The lock amount is 100,000 tokens: [6](#0-5) 

**Parliament Rejection Logic:**

The Parliament contract's `GetAndCheckActualParliamentMemberAddress` method explicitly throws an exception when an admin manages multiple pubkeys: [7](#0-6) 

This validation occurs when retrieving managed pubkeys from the Election contract: [8](#0-7) 

**Complete Denial of Service:**

All three Parliament voting methods invoke `GetAndCheckActualParliamentMemberAddress`:
- Approve method: [9](#0-8) 
- Reject method: [10](#0-9) 
- Abstain method: [11](#0-10) 

**Attack Execution:**
1. Attacker generates two arbitrary pubkeys (pubkey1, pubkey2) - doesn't need to control them
2. Calls `AnnounceElectionFor(pubkey1, victimParliamentMemberAddress)` - pays 100,000 tokens
3. Calls `AnnounceElectionFor(pubkey2, victimParliamentMemberAddress)` - pays 100,000 tokens
4. Victim's `ManagedCandidatePubkeysMap` now contains 2+ entries
5. When victim attempts to vote on any proposal, transaction reverts with "Admin with multiple managed pubkeys cannot handle proposal"
6. Attack persists indefinitely until candidates quit (which attacker can prevent by never calling QuitElection)

## Impact Explanation

**Direct Governance Impact:**
- Parliament members (current miners) are completely locked out from voting on proposals, effectively removing them from governance participation
- The attack breaks the fundamental invariant that authorized Parliament members must be able to vote on proposals
- Multiple Parliament members can be targeted simultaneously with independent attacks

**Quantified Damage:**
- Cost per victim: 200,000 tokens (2 candidates × 100,000 tokens each)
- To compromise majority governance (N/2 Parliament members): N/2 × 200,000 tokens
- With typical mainnet having ~20 miners: ~2,000,000 tokens to DoS half of Parliament
- This attack cost is economically feasible for determined attackers seeking to:
  - Block specific governance proposals
  - Destabilize network governance
  - Gain competitive mining advantages

**Affected Parties:**
- Current Parliament members whose addresses are publicly visible on-chain
- Future Parliament members who could be pre-emptively targeted
- The entire AElf governance system if sufficient members are compromised
- Any protocol changes or upgrades requiring Parliament approval

**Severity Justification:**
HIGH severity because this is a feasible governance DoS with concrete economic cost, enabling permanent denial of voting rights to critical governance participants without requiring any privileged access.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Sufficient token balance to pay lock fees (200,000 tokens per victim)
- Ability to generate arbitrary public keys (no private key control needed)
- Knowledge of target Parliament member addresses (publicly available on-chain via GetCurrentMinerList)
- No special privileges or system access required

**Attack Complexity:**
- LOW complexity: Two simple method calls per victim
- No timing dependencies or race conditions
- No need to compromise existing accounts or keys
- No coordination with other attackers required
- Attack can be executed immediately on current contract state

**Detection and Prevention:**
- Victims only discover the attack when attempting to vote (reactive, not preventive)
- No clear on-chain indicators that distinguish malicious from legitimate candidate announcements
- No existing mechanism for victims to remove unwanted managed pubkeys
- Attack persists until both candidates call QuitElection (which attacker controls)

**Economic Feasibility:**
The 200,000 token cost per victim is economically rational for attackers with objectives such as:
- Preventing specific high-value governance decisions (contract upgrades, economic parameter changes)
- Causing network instability for competitive advantage
- Shorting opportunities during governance chaos
- Extortion (demand payment to call QuitElection)

**Probability Assessment:**
HIGH probability given:
- Public availability of target addresses
- Reasonable attack cost relative to potential gains
- No technical barriers to execution
- Immediate and persistent impact

## Recommendation

**Immediate Fix:**

Add authorization check to `AnnounceElectionFor` to ensure only the pubkey owner or existing admin can designate an admin:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    var address = Address.FromPublicKey(pubkeyBytes);
    
    // NEW: Verify caller authorization
    var existingAdmin = State.CandidateAdmins[pubkey];
    if (existingAdmin != null && input.Admin != null)
    {
        // Only existing admin can change admin
        Assert(Context.Sender == existingAdmin, "Only current admin can change admin.");
    }
    else if (input.Admin != null && input.Admin != Context.Sender)
    {
        // For new candidates, require signature from the candidate's address
        Assert(Context.Sender == address, 
            "Only candidate can designate admin, or sponsor must be admin.");
    }
    
    AnnounceElection(pubkeyBytes);
    var admin = input.Admin ?? Context.Sender;
    State.CandidateAdmins[pubkey] = admin;
    var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
    managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
    State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
    
    LockCandidateNativeToken();
    AddCandidateAsOption(pubkey);
    
    if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
    {
        State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
        RegisterCandidateToSubsidyProfitScheme(pubkey);
    }
    
    State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
    return new Empty();
}
```

**Additional Hardening:**

1. Add a method for admins to remove managed pubkeys they didn't authorize
2. Add event emissions for admin changes with clear indication of who initiated
3. Consider rate limiting or cooldown periods for admin changes
4. Add maximum limit on managed pubkeys per admin address

## Proof of Concept

```csharp
[Fact]
public async Task ParliamentMemberDoS_ViaForcedManagedPubkeys()
{
    // Setup: Get a current Parliament member address (miner)
    var minerList = await AEDPoSContractStub.GetCurrentMinerList.CallAsync(new Empty());
    var victimMinerPubkey = minerList.Pubkeys.First();
    var victimAddress = Address.FromPublicKey(victimMinerPubkey.ToByteArray());
    
    // Attacker generates two arbitrary pubkeys (doesn't need to control them)
    var attackerPubkey1 = CryptoHelper.GenerateKeyPair().PublicKey.ToHex();
    var attackerPubkey2 = CryptoHelper.GenerateKeyPair().PublicKey.ToHex();
    
    // Attacker approves token spending for lock fees
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ElectionContractAddress,
        Symbol = "ELF",
        Amount = 200_000_00000000 // 200k tokens for 2 candidates
    });
    
    // Attack Step 1: Force first pubkey onto victim's managed list
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = attackerPubkey1,
        Admin = victimAddress // Victim's address without their consent
    });
    
    // Attack Step 2: Force second pubkey onto victim's managed list
    await ElectionContractStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = attackerPubkey2,
        Admin = victimAddress // Victim's address without their consent
    });
    
    // Verify victim now has multiple managed pubkeys
    var managedPubkeys = await ElectionContractStub.GetManagedPubkeys.CallAsync(victimAddress);
    Assert.Equal(2, managedPubkeys.Value.Count);
    
    // Create a test proposal for victim to vote on
    var proposalId = await CreateTestProposal();
    
    // Victim attempts to vote on proposal as Parliament member
    // This should FAIL with "Admin with multiple managed pubkeys cannot handle proposal"
    var victimStub = GetParliamentContractStub(victimMinerPubkey);
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await victimStub.Approve.SendAsync(proposalId);
    });
    
    Assert.Contains("Admin with multiple managed pubkeys cannot handle proposal", 
        exception.Message);
    
    // Verify: Victim is permanently locked out from all Parliament voting
    await Assert.ThrowsAsync<Exception>(async () => 
        await victimStub.Reject.SendAsync(proposalId));
    await Assert.ThrowsAsync<Exception>(async () => 
        await victimStub.Abstain.SendAsync(proposalId));
}
```

**Notes:**
- The vulnerability allows complete denial of Parliament voting rights for 200,000 tokens per victim
- Attack requires no special privileges and can target any Parliament member
- Victims cannot self-remediate without calling QuitElection on candidates they don't control
- The design flaw is in assuming only legitimate candidate owners will use AnnounceElectionFor
- Parliament's multi-pubkey rejection is a security feature being weaponized due to missing authorization in Election contract

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L127-127)
```csharp
        var admin = input.Admin ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L129-131)
```csharp
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** protobuf/election_contract.proto (L519-522)
```text
message AnnounceElectionForInput {
    string pubkey = 1;
    aelf.Address admin = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L129-130)
```csharp
        var managedPubkey = State.ElectionContract.GetManagedPubkeys.Call(Context.Sender);
        if (!managedPubkey.Value.Any()) throw new AssertionException("Unauthorized sender.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L132-133)
```csharp
        if (managedPubkey.Value.Count > 1)
            throw new AssertionException("Admin with multiple managed pubkeys cannot handle proposal.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L80-80)
```csharp
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L98-98)
```csharp
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L116-116)
```csharp
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
```
