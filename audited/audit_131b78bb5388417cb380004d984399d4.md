### Title
Byzantine Miners Can Fork Consensus Through Unchecked OutValue Manipulation

### Summary
The `UpdateValueValidationProvider` validates OutValue fields in isolation without cross-miner consistency checks, allowing Byzantine miners to produce multiple blocks with different OutValues at the same height. Since mining order for the next round is derived from Signature values (which depend on OutValues), this creates forks with divergent mining schedules that may persist rather than resolve naturally through fork choice rules.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The validation only checks that OutValue and Signature are filled, and that PreviousInValue matches the previous round's OutValue. There is no verification that the OutValue is consistent with what other miners have recorded or agreed upon.

**Validation Flow:** [2](#0-1) 

When validating UpdateValue behavior, the system adds `UpdateValueValidationProvider` but performs no cross-miner consensus checks.

**Post-Execution Validation Weakness:** [3](#0-2) 

The `ValidateConsensusAfterExecution` method recovers the round using the OutValue from the block header itself, then compares it with the current round that was just updated using that same OutValue. This is circular validation that cannot detect inconsistencies across different nodes.

**Exploitation Mechanism:**

A Byzantine miner produces two different blocks at the same height with different OutValues (OutValue1 in Block A, OutValue2 in Block B). The OutValue directly affects the Signature calculation: [4](#0-3) 

Different OutValues produce different Signatures, which determine different mining orders: [5](#0-4) 

The mining order calculation converts the Signature to an integer modulo the miner count, creating `SupposedOrderOfNextRound`. Different Signatures yield different orders for the next round.

**Mining Schedule Divergence:**

When generating the next round, miners are assigned time slots based on their order: [6](#0-5) 

Nodes following Block A will have different ExpectedMiningTimes than nodes following Block B. During time slot validation, each fork enforces its own schedule: [7](#0-6) 

This means at any given time slot, Fork A expects Miner X while Fork B expects Miner Y. Both forks can grow independently with different active miners.

### Impact Explanation

**Consensus Integrity Compromise:**
The attack creates persistent blockchain forks with incompatible mining schedules. Unlike normal forks that resolve through longest-chain rules, these forks have different "correct" miners at each time slot, allowing both to grow simultaneously.

**Affected Parties:**
- All network participants experience consensus split
- Miners follow different forks based on their network view
- Users may see different transaction finality states
- Cross-chain operations become unreliable due to divergent states

**Severity Justification:**
HIGH severity due to fundamental consensus integrity violation. While the system has Last Irreversible Block (LIB) mechanisms: [8](#0-7) 

The LIB calculation occurs independently within each fork's state, providing no cross-fork resolution. The critical invariant "miner schedule integrity" is violated, potentially causing network split until manual intervention.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an elected miner in the active miner set
- Requires ability to broadcast different blocks to different network segments
- Must sustain network partition or targeted block propagation

**Attack Complexity:**
MEDIUM - The attacker needs to:
1. Be elected as a miner (requires stake/votes)
2. Produce two valid blocks with different OutValues at same height
3. Successfully deliver different blocks to different node groups
4. Maintain the split through subsequent rounds

**Feasibility Conditions:**
The attack is feasible because:
- Miners have full control over their InValue selection
- OutValue = Hash(InValue), so arbitrary values are valid
- No validation prevents a miner from using different InValues for different blocks
- Block propagation delays or network segmentation can cause node groups to receive different blocks first

**Detection Constraints:**
While block synchronization includes peer verification: [9](#0-8) 

This 2/3 peer check occurs during block sync for irreversible blocks, but doesn't prevent the initial fork creation or enforce real-time consensus validation of OutValue consistency.

### Recommendation

**Immediate Mitigation:**
Add cross-miner OutValue verification to `UpdateValueValidationProvider`:

1. Store a commitment to OutValue (hash of OutValue) before block production
2. Validate that the revealed OutValue matches the committed hash
3. Implement threshold signature or verifiable random function (VRF) for OutValue generation
4. Add consensus round validation that checks OutValue consistency across miners before accepting blocks

**Code-Level Fix:**
Modify `UpdateValueValidationProvider.ValidateHeaderInformation()` to:
```
- Query previous blocks to check if this miner published different OutValues
- Validate OutValue against a verifiable computation (VRF or threshold signature)
- Require 2/3 miner signatures attesting to the OutValue before acceptance
```

**Invariant Check:**
Add assertion: "For each miner in each round, there exists exactly one valid OutValue accepted by the network"

**Test Cases:**
1. Test that producing two blocks with different OutValues at same height is rejected
2. Verify that nodes reject blocks with OutValues inconsistent with network consensus
3. Simulate Byzantine miner attempting fork and confirm rejection before state divergence

### Proof of Concept

**Initial State:**
- Network with N elected miners
- Byzantine miner M is scheduled to produce block at height H
- Network is running normally with connected peers

**Attack Steps:**

1. **Block Production**: Miner M generates two different secrets:
   - InValue1 → OutValue1 = Hash(InValue1)
   - InValue2 → OutValue2 = Hash(InValue2)

2. **Fork Creation**: Miner M produces two valid blocks at height H:
   - Block A with consensus data containing OutValue1, broadcasts to Group 1 nodes
   - Block B with consensus data containing OutValue2, broadcasts to Group 2 nodes

3. **Validation Passes**: Both groups validate their respective blocks:
   - UpdateValueValidationProvider checks OutValue is non-empty ✓
   - ValidatePreviousInValue checks PreviousInValue matches previous OutValue ✓
   - No cross-miner validation ✓

4. **State Divergence**: 
   - Group 1 stores OutValue1, calculates Signature1, determines mining order Order1 for round H+1
   - Group 2 stores OutValue2, calculates Signature2, determines mining order Order2 for round H+1
   - Order1 ≠ Order2

5. **Persistent Fork**: In round H+1:
   - Group 1 expects Miner X at time T based on Order1
   - Group 2 expects Miner Y at time T based on Order2
   - Both miners produce blocks on their respective forks
   - Forks continue diverging with different mining schedules

**Expected Result**: Network rejects inconsistent OutValues through cross-miner validation

**Actual Result**: Both forks accepted, network splits with divergent consensus states

**Success Condition**: Persistent fork with different mining orders observable through querying `GetCurrentRoundInformation` on nodes in each group, showing different `FinalOrderOfNextRound` values for miners in round H+1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-82)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-101)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-22)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** src/AElf.OS/BlockSync/Application/BlockDownloadService.cs (L158-178)
```csharp
    private async Task<bool?> CheckIrreversibleBlockHashAsync(Hash blockHash, long blockHeight)
    {
        var peers = _networkService.GetPeers(false)
            .Where(p => p.SyncState == SyncState.Finished &&
                        p.LastKnownLibHeight >= blockHeight)
            .ToList();

        if (peers.Count < PeerCheckMinimumCount) return null;

        var taskList = peers.Select(async peer =>
            await _networkService.GetBlocksAsync(blockHash, 1, peer.Pubkey));

        var hashCheckResult = await Task.WhenAll(taskList);

        var confirmCount = 2 * peers.Count() / 3 + 1;
        var result = hashCheckResult.Where(r => r.Success)
            .GroupBy(a => a.Payload != null && a.Payload.Count == 1)
            .FirstOrDefault(group => group.Count() >= confirmCount);

        return result?.Key;
    }
```
