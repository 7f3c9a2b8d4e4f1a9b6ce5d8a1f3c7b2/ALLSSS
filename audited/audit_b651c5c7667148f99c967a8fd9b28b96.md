### Title
Referendum Organizations Can Be Created With Zero Maximal Thresholds Enabling Governance DoS

### Summary
The Referendum contract's organization validation allows `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` to be set to 0, without ensuring proposals can mathematically pass. This enables creation of organizations where any single token holder voting to reject or abstain can permanently block all proposals, causing complete governance DoS with no recovery mechanism.

### Finding Description

The vulnerability exists in the referendum organization validation logic that permits zero values for maximal thresholds without proper feasibility checks. [1](#0-0) 

The validation only checks that these thresholds are `>= 0`, allowing them to be exactly 0. When proposals are evaluated for release, the threshold comparison uses strict greater-than: [2](#0-1) 

With zero thresholds, `proposal.RejectionCount > 0` or `proposal.AbstentionCount > 0` evaluates to true with any single rejection/abstention vote, causing immediate proposal failure.

Unlike Association and Parliament contracts which validate that `MaximalAbstentionThreshold + MinimalApprovalThreshold <= memberCount` to ensure proposals can pass: [3](#0-2) [4](#0-3) 

Referendum completely lacks this feasibility validation, despite having unrestricted voting where any token holder can participate: [5](#0-4) 

The organization creation is public with no access restrictions: [6](#0-5) 

### Impact Explanation

**Operational Impact - Complete Governance DoS:**
- Any Referendum organization created with zero maximal thresholds becomes permanently dysfunctional
- A single token holder with minimum allowance (1 token) can block all proposals by voting to reject or abstain
- The organization cannot recover because fixing thresholds requires passing a `ChangeOrganizationThreshold` proposal, which is itself blocked
- This affects any governance-critical operations managed by the organization (treasury releases, configuration changes, cross-chain operations)

**Attack Vectors:**
1. **Malicious Organization Creation**: Attacker creates an organization with deceptively reasonable parameters but sets maximal thresholds to 0, then promotes its use
2. **Accidental Misconfiguration**: Legitimate users unknowingly create unusable organizations
3. **Governance Capture**: In existing organizations that change thresholds to 0, any dissident can prevent all future actions

**Scope of Damage:**
- Complete loss of governance functionality for affected organizations
- No on-chain recovery mechanism exists
- Impacts all dependent contracts/systems relying on the organization for approvals

### Likelihood Explanation

**Reachable Entry Point:** The `CreateOrganization` method is public with no authorization requirements, executable by any user.

**Feasible Preconditions:**
- Attacker creates organization with `MaximalRejectionThreshold = 0` or `MaximalAbstentionThreshold = 0`
- Sets reasonable `MinimalApprovalThreshold` and `MinimalVoteThreshold` to appear legitimate
- Any token holder can vote by calling `Approve`, `Reject`, or `Abstain` with token allowance

**Execution Practicality:**
- Zero-cost to create a misconfigured organization
- Voting requires only token allowance, verified here: [7](#0-6) 

- No special privileges required beyond token ownership
- Attack is undetectable until proposals start failing

**Economic Rationality:**
- Near-zero cost to execute (only transaction fees)
- High impact for disrupting competitor DAOs or protocol governance
- Can be used for extortion (threaten to vote against unless paid)

**Likelihood:** HIGH - The validation gap makes this trivially exploitable, with real-world evidence of zero thresholds being used: [8](#0-7) 

### Recommendation

**Immediate Fix:** Add feasibility validation to `Referendum_Helper.cs` similar to Association and Parliament:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Add this validation to ensure proposals can pass:
    // For Referendum, since token supply is unbounded, we should ensure
    // that MaximalThresholds don't make proposals impossible to pass
    var impossibleToPass = 
        (proposalReleaseThreshold.MaximalRejectionThreshold == 0 && 
         proposalReleaseThreshold.MinimalApprovalThreshold > 0) ||
        (proposalReleaseThreshold.MaximalAbstentionThreshold == 0 && 
         proposalReleaseThreshold.MinimalApprovalThreshold > 0);
         
    return !impossibleToPass &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

**Alternative Approach:** Require minimum thresholds that allow some margin:
```csharp
proposalReleaseThreshold.MaximalAbstentionThreshold > 0 &&
proposalReleaseThreshold.MaximalRejectionThreshold > 0
```

**Testing:** Add regression test cases for:
1. Organization creation with zero maximal thresholds (should fail)
2. Proposals with minimal rejection/abstention when thresholds are at minimum safe values
3. Verification that legitimate unanimous-approval scenarios still work with proper threshold settings

### Proof of Concept

**Initial State:**
- Token "VOTE" exists with total supply distributed among multiple holders
- Attacker creates Referendum organization via `CreateOrganization`

**Attack Steps:**

1. **Create Vulnerable Organization:**
   - `TokenSymbol: "VOTE"`
   - `MinimalApprovalThreshold: 10000`
   - `MinimalVoteThreshold: 10000`
   - `MaximalRejectionThreshold: 0` ← Vulnerability trigger
   - `MaximalAbstentionThreshold: 0` ← Vulnerability trigger
   - `ProposerWhiteList: [user1, user2, user3]`

2. **Organization Passes Validation:** 
   - The validation at lines 98-101 accepts this configuration

3. **Create Legitimate Proposal:**
   - User1 creates proposal to transfer treasury funds
   - Proposal enters pending state

4. **Accumulate Approvals:**
   - 15000 tokens worth of approvals are collected
   - Meets MinimalApprovalThreshold (10000) ✓
   - Meets MinimalVoteThreshold (10000) ✓

5. **Execute DoS Attack:**
   - Attacker (or any disgruntled token holder) sets 1 token allowance
   - Calls `Reject` on the proposal
   - `proposal.RejectionCount = 1`

6. **Proposal Permanently Blocked:**
   - `IsReleaseThresholdReached` evaluates: `1 > 0` → true (rejected)
   - Release attempt fails with "Not approved" assertion
   - No amount of additional approvals can overcome single rejection

**Expected Result:** Proposal passes with 15000 approvals vs 1 rejection

**Actual Result:** Proposal permanently blocked by 1 token rejection

**Success Condition:** Organization governance is completely non-functional, cannot pass any proposals

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L20-26)
```csharp
        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L141-152)
```csharp
    private long GetAllowance(Address owner, string tokenSymbol, Hash proposalId)
    {
        RequireTokenContractStateSet();
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = owner,
            Spender = GetProposalVirtualAddress(proposalId),
            Symbol = tokenSymbol
        }).Allowance;
        Assert(allowance > 0, "Allowance not enough.");
        return allowance;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L75-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L149-154)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-28)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L85-97)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.RejectionCount = proposal.RejectionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Reject);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L143-149)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```
