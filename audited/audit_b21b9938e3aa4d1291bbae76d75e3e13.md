# Audit Report

## Title
Side Chain Disposal with Outstanding Debt Allows Indexing Fee Theft

## Summary
The `DisposeSideChain` function permits disposal of side chains in `IndexingFeeDebt` status without settling outstanding debts to indexers. The `UnlockTokenAndResource` helper only returns remaining balance to the chain proposer, permanently erasing legitimate fee claims recorded in `ArrearsInfo`.

## Finding Description

When a side chain's locked token balance depletes during indexing operations, the system transitions it to `IndexingFeeDebt` status and records unpaid amounts in the `ArrearsInfo` mapping. [1](#0-0) 

The `DisposeSideChain` function performs only a negative status check, asserting that status is not `Terminated`, which allows chains in `IndexingFeeDebt` status to pass through. [2](#0-1) 

During disposal, `UnlockTokenAndResource` is called to return locked tokens. This function retrieves the remaining balance and transfers it to the proposer, but completely ignores any debts recorded in `ArrearsInfo`. [3](#0-2) 

The proper debt settlement pattern exists in the `Recharge` function, which iterates through `ArrearsInfo`, pays each creditor their owed amount, and then clears the debt records. [4](#0-3) 

The `SideChainStatus` enum defines `INDEXING_FEE_DEBT = 2` as a valid intermediate state between `ACTIVE` and `TERMINATED`. [5](#0-4) 

The `ArrearsInfo` field stores creditor addresses (base64-encoded) mapped to debt amounts, which are summed to calculate total outstanding debt. [6](#0-5) [7](#0-6) 

## Impact Explanation

**Direct Financial Loss:**
Indexers who proposed side chain block data permanently lose unpaid indexing fees recorded in `ArrearsInfo`. Each indexing operation performed after balance depletion creates debt that becomes unrecoverable once the chain is disposed.

**Economic Model Violation:**
The cross-chain indexing system relies on miners being compensated per block indexed. When disposal erases debts without payment, it breaks the fundamental trust that indexers will receive fees for work performed.

**Protocol Invariant Break:**
The contract maintains `ArrearsInfo` specifically to track legitimate claims. Allowing these claims to be erased without settlement violates the invariant that debt records must be honored before chain termination.

The impact is quantified as the sum of all values in `ArrearsInfo` at disposal time, with each indexed block during debt period adding `IndexingPrice` to the total unpaid amount.

## Likelihood Explanation

**Execution Path:**
The vulnerability is triggered through normal contract operations via Parliament governance. A chain proposer can create a side chain with minimal locked tokens, operate until debt accumulates, then propose disposal through governance channels.

**Realistic Preconditions:**
This scenario naturally occurs for underfunded side chains. The system is designed to allow chains to continue operating in debt status, expecting eventual recharge. However, disposal is also a legitimate governance action for chains no longer needed.

**No Technical Barriers:**
All steps use public contract methods with appropriate authorization. The governance approval process is standard Parliament operation. No exploit techniques or special privileges are required beyond normal governance participation.

**Economic Feasibility:**
When accumulated debt exceeds the cost of side chain creation plus governance fees, avoiding debt through disposal becomes profitable. This creates a perverse incentive structure where underfunding chains and disposing them is economically rational.

## Recommendation

Modify the status check in `DisposeSideChain` to only allow disposal of `ACTIVE` chains:

Change line 229 from:
```
Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");
```

To:
```
Assert(info.SideChainStatus == SideChainStatus.Active, "Can only dispose active side chains. Chains with debt must be recharged first.");
```

This ensures that any chain with outstanding debts in `ArrearsInfo` must go through the `Recharge` flow (which properly settles debts) before disposal can proceed.

Alternatively, add debt settlement logic to `UnlockTokenAndResource` before returning balance, following the pattern used in `Recharge`.

## Proof of Concept

The existing test suite demonstrates that chains enter `IndexingFeeDebt` status when balance depletes during indexing. [8](#0-7) 

A proof-of-concept test would:
1. Create a side chain with `lockedToken = 2` and `indexingPrice = 1`
2. Index 3 blocks (consuming 2 tokens normally, accumulating 1 token debt)
3. Verify chain status becomes `IndexingFeeDebt` with `ArrearsInfo` recording the debt
4. Call `DisposeSideChain` via governance proposal
5. Verify disposal succeeds and chain status becomes `Terminated`
6. Verify `ArrearsInfo` debts were never paid to the indexer
7. Verify indexer's balance did not increase by the owed amount

This demonstrates that disposal of a chain in debt status permanently erases legitimate fee claims without compensation.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L73-86)
```csharp
    private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
    {
        // unlock token
        var chainId = sideChainInfo.SideChainId;
        var balance = GetSideChainIndexingFeeDeposit(chainId);
        if (balance <= 0)
            return;
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L846-851)
```csharp
                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L191-211)
```csharp
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L229-229)
```csharp
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");
```

**File:** protobuf/cross_chain_contract.proto (L189-199)
```text
enum SideChainStatus
{
    // Currently no meaning.
    FATAL = 0;
    // The side chain is being indexed.
    ACTIVE = 1;
    // The side chain is in debt for indexing fee.
    INDEXING_FEE_DEBT = 2;
    // The side chain is disposed.
    TERMINATED = 3;
}
```

**File:** protobuf/cross_chain_contract.proto (L216-217)
```text
    // creditor and amounts for the chain indexing fee debt 
    map<string, int64> arrears_info = 8;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L95-98)
```csharp
        return new Int64Value
        {
            Value = sideChainInfo.ArrearsInfo.Values.Sum()
        };
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L1131-1250)
```csharp
    public async Task Release_IndexingSideChain_IndexingFeeDebt()
    {
        var parentChainId = 123;
        long lockedToken = 2;
        long indexingPrice = 1;
        long parentChainHeightOfCreation = 10;

        // transfer token
        var transferTx = await TokenContractStub.Transfer.SendAsync(new TransferInput
        {
            Amount = 1000,
            Symbol = "ELF",
            To = AnotherSender
        });

        var sideChainId =
            await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId, lockedToken,
                indexingPrice, AnotherKeyPair);

        var balanceBeforeIndexing = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });

        var fakeSideChainBlockHash = HashHelper.ComputeFrom("sideChainBlockHash");
        var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("txMerkleTreeRoot");
        var sideChainBlockData1 =
            CreateSideChainBlockData(fakeSideChainBlockHash, 1, sideChainId, fakeTxMerkleTreeRoot);
        var sideChainBlockData2 =
            CreateSideChainBlockData(fakeSideChainBlockHash, 2, sideChainId, fakeTxMerkleTreeRoot);
        var sideChainBlockData3 =
            CreateSideChainBlockData(fakeSideChainBlockHash, 3, sideChainId, fakeTxMerkleTreeRoot);

        var crossChainBlockData = new CrossChainBlockData
        {
            SideChainBlockDataList = { sideChainBlockData1, sideChainBlockData2, sideChainBlockData3 }
        };

        var txRes =
            await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
        txRes.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        var proposalId = ProposalCreated.Parser
            .ParseFrom(txRes.TransactionResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;
        Assert.NotNull(proposalId);
        await ApproveWithMinersAsync(proposalId);

        {
            var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value
            {
                Value = sideChainId
            });
            chainStatus.Status.ShouldBe(SideChainStatus.Active);
        }

        var releaseResult = await CrossChainContractStub.ReleaseCrossChainIndexingProposal.SendAsync(
            new ReleaseCrossChainIndexingProposalInput
            {
                ChainIdList = { sideChainId }
            });
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        {
            var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value
            {
                Value = sideChainId
            });
            chainStatus.Status.ShouldBe(SideChainStatus.IndexingFeeDebt);
        }

        var sideChainIndexedHeight =
            (await CrossChainContractStub.GetSideChainHeight.CallAsync(new Int32Value { Value = sideChainId }))
            .Value;
        sideChainIndexedHeight.ShouldBe(crossChainBlockData.SideChainBlockDataList.Last().Height);

        var balanceAfterIndexing = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });
        balanceAfterIndexing.Balance.ShouldBe(balanceBeforeIndexing.Balance + lockedToken);

        // recharge
        var arrearsAmount = crossChainBlockData.SideChainBlockDataList.Count - lockedToken;
        var rechargeAmount = arrearsAmount + indexingPrice;
        // approve allowance
        await ApproveBalanceAsync(rechargeAmount, AnotherKeyPair);

        var crossChainContractStub = GetCrossChainContractStub(AnotherKeyPair);

        {
            var rechargeTxFailed = await crossChainContractStub.Recharge.SendWithExceptionAsync(new RechargeInput
            {
                ChainId = sideChainId,
                Amount = rechargeAmount - 1
            });
            rechargeTxFailed.TransactionResult.Error.ShouldContain("Indexing fee recharging not enough.");
        }

        var rechargeTx = await crossChainContractStub.Recharge.SendAsync(new RechargeInput
        {
            ChainId = sideChainId,
            Amount = rechargeAmount
        });
        rechargeTx.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var balanceAfterRecharge = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });
        balanceAfterRecharge.Balance.ShouldBe(balanceAfterIndexing.Balance + arrearsAmount);

        {
            var chainStatus = await CrossChainContractStub.GetChainStatus.CallAsync(new Int32Value
            {
                Value = sideChainId
            });
            chainStatus.Status.ShouldBe(SideChainStatus.Active);
```
