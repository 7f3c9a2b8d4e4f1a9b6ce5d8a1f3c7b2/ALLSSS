### Title
Double Voting Vulnerability in Delegated Voting Mode Allows Unlimited Vote Inflation

### Summary
The Vote contract's `Vote()` function lacks validation to prevent reusing the same `VoteId` in delegated voting mode (IsLockToken=false). A malicious sponsor can call `Vote()` multiple times with identical `VoteId` values, causing each call to increment the voting results while only storing the final voting record, enabling unlimited vote count inflation without any token backing.

### Finding Description

The vulnerability exists in the `Vote()` function where votes are processed and recorded. [1](#0-0) 

In non-quadratic voting mode, the vote amount is directly taken from user input without quadratic calculation. [2](#0-1) 

The critical issue occurs at line 117 where the voting record is stored by overwriting any existing record with the same VoteId, without first checking if that VoteId already exists. [3](#0-2) 

Subsequently, `UpdateVotingResult()` is called which unconditionally adds the vote amount to the results, increments the voters count, and adds to the total votes amount - regardless of whether this VoteId was previously used. [4](#0-3) 

For delegated voting items (IsLockToken=false), the validation logic only requires that the sponsor is the caller and that VoteId is non-null - there is no uniqueness check. [5](#0-4) 

Since no tokens are locked when IsLockToken=false, the sponsor can repeatedly call Vote() with the same VoteId using different amounts, and each call will add to the voting results. [6](#0-5) 

### Impact Explanation

**Direct Governance Manipulation**: A malicious sponsor can completely manipulate voting outcomes by artificially inflating vote counts for any option without possessing corresponding tokens. For example:
- First call: Vote(VoteId="X", Amount=1000, Option="A") → Results["A"] = 1000
- Second call: Vote(VoteId="X", Amount=2000, Option="B") → Results["B"] = 2000  
- Third call: Vote(VoteId="X", Amount=3000, Option="C") → Results["C"] = 3000
- Total votes counted: 6000, but only one record exists with amount 3000

**Severity Justification**: This is Critical because:
1. Any sponsor of a delegated voting item can exploit this
2. Vote counts can be inflated arbitrarily without limit
3. No tokens are required to back the inflated votes
4. Voting results become completely unreliable and manipulable
5. Affects any contract using the Vote contract for delegated voting scenarios

### Likelihood Explanation

**High Exploitability**: 
- The attack requires only that the malicious actor be the sponsor of a voting item with IsLockToken=false
- The sponsor has complete control over VoteId and Amount parameters in delegated voting
- No special privileges or complex state manipulation required
- The exploit can be executed in straightforward sequential transactions

**Feasibility**: 
- Any contract can register a voting item by calling the public `Register()` function
- The sponsor role is assigned to the transaction sender during registration
- Delegated voting (IsLockToken=false) is a documented and intentional feature for higher-level contracts
- No economic cost since no tokens need to be locked

**Detection Constraints**: 
- The inflated vote counts appear legitimate in the VotingResult state
- Only forensic analysis of VotingRecords vs VotingResults would reveal the discrepancy
- The vulnerability is inherent to the contract logic, not an implementation bug

### Recommendation

**Primary Fix**: Add a duplicate VoteId check in the `Vote()` function before processing the vote:

```csharp
// In Vote() function, after line 92 (AssertValidVoteInput):
Assert(State.VotingRecords[input.VoteId] == null, "Vote already exists.");
```

This matches the pattern used in the Election contract. [7](#0-6) 

**Invariant to Enforce**: 
- Each VoteId must map to exactly one VotingRecord throughout the voting item's lifetime
- The sum of all VotingRecord amounts for a voting item should equal VotingResult.VotesAmount

**Test Cases**:
1. Attempt to vote twice with the same VoteId in delegated voting - should revert
2. Verify VotingResult.VotesAmount equals sum of all unique VotingRecords
3. Test that VotersCount accurately reflects unique votes, not duplicate VoteIds

### Proof of Concept

**Initial State**:
- Malicious contract MC registers a voting item with IsLockToken=false, options ["A", "B"]
- MC is now the sponsor

**Attack Sequence**:

Transaction 1:
```
MC calls Vote(
  VotingItemId = votingItemId,
  Voter = Alice,
  VoteId = Hash("duplicate_vote"),
  Amount = 1000,
  Option = "A"
)
```
- State.VotingRecords[Hash("duplicate_vote")] = VotingRecord(amount=1000, option="A")
- VotingResult.Results["A"] = 1000
- VotingResult.VotesAmount = 1000

Transaction 2:
```
MC calls Vote(
  VotingItemId = votingItemId,
  Voter = Bob,
  VoteId = Hash("duplicate_vote"),  // SAME VoteId
  Amount = 2000,
  Option = "B"
)
```
- State.VotingRecords[Hash("duplicate_vote")] = VotingRecord(amount=2000, option="B") [OVERWRITTEN]
- VotingResult.Results["B"] = 2000 [ADDED AGAIN]
- VotingResult.VotesAmount = 3000 [ACCUMULATED]

**Expected Result**: Second transaction should revert with "Vote already exists."

**Actual Result**: 
- Total votes counted: 3000
- Actual voting records: 1 (with amount 2000)
- Discrepancy: 1000 phantom votes for option "A"

The sponsor can repeat this indefinitely, inflating vote counts without limit or token backing.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-144)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }

        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;

        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
        UpdateVotedItems(input.VoteId, votingRecord.Voter, votingItem);

        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });

        Context.Fire(new Voted
        {
            VoteId = input.VoteId,
            VotingItemId = votingRecord.VotingItemId,
            Voter = votingRecord.Voter,
            Amount = votingRecord.Amount,
            Option = votingRecord.Option,
            SnapshotNumber = votingRecord.SnapshotNumber,
            VoteTimestamp = votingRecord.VoteTimestamp
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```
