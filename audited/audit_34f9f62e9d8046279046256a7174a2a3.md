# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Insufficient Alternative Candidates

## Summary
The consensus contract's miner replacement mechanism fails to replace all evil miners when the candidate pool is exhausted. The replacement loop only iterates for the count of available alternatives, leaving unreplaced evil miners in the active miner set. This compromises consensus integrity by retaining offline or malicious miners who won't produce blocks.

## Finding Description

The vulnerability exists in the coordination between the Election and Consensus contracts during evil miner replacement.

When evil miners are detected (miners who have missed 4,320 time slots over 3 days), [1](#0-0)  they are marked as banned in the Election contract's `BannedPubkeyMap`. [2](#0-1) 

During next round generation, the consensus contract calls `GetMinerReplacementInformation` to obtain replacement candidates. [3](#0-2)  This function attempts to find alternatives from two sources: the previous term's election snapshot and initial miners as fallback. [4](#0-3) 

The critical flaw occurs when alternative candidates are insufficient. The fallback logic filters initial miners to exclude those already banned or currently serving, but this filtering happens **before** the `.Take()` operation. [5](#0-4)  This means if many initial miners are already banned, fewer alternatives than needed will be returned.

The consensus contract's replacement loop then only iterates for the count of alternatives provided: [6](#0-5)  Using index `i` to pair alternatives with evil miners, only the first N evil miners (where N = `AlternativeCandidatePubkeys.Count`) get replaced via the remove/add operations. [7](#0-6)  The remaining evil miners stay in `currentRound.RealTimeMinersInformation` with their assigned time slots, but being offline/evil, they won't produce blocks.

## Impact Explanation

**HIGH severity** - This vulnerability directly compromises the consensus layer's miner schedule integrity:

- **Consensus Degradation:** Unreplaced evil miners occupy time slots but won't produce blocks. In a scenario with 21 miners where 10 become evil but only 3 get replaced, 7 non-functional miners remain active, reducing effective block production by ~33%.

- **Network Liveness Risk:** If sufficient unreplaced evil miners remain, the network may fail to achieve the 2/3+ majority needed for block finalization, potentially causing consensus stalls that halt all transaction processing and state transitions.

- **Affected Parties:** All network participants (validators, users, dApps), treasury/reward distribution systems, and cross-chain operations that depend on reliable consensus.

The severity is HIGH rather than CRITICAL because funds aren't directly at risk, but the operational impact on network availability is severe and affects all protocol functionality.

## Likelihood Explanation

**MEDIUM-HIGH probability** - The vulnerability can trigger under realistic conditions:

**Trigger Conditions:**
1. Multiple miners going offline for 3+ days (detected threshold: 4,320 missed slots [8](#0-7) )
2. Depleted candidate pool from low election participation
3. Initial miners already serving or previously banned

**Execution Complexity:** MEDIUM - No special permissions required. Natural network stress (infrastructure failures, coordinated DDoS attacks) can cause multiple miners to go offline simultaneously. An adversary could amplify this by disincentivizing election participation.

**Detection:** The replacement flow executes automatically during round generation [9](#0-8)  without requiring governance approval, making it difficult to prevent once conditions are met.

The probability increases over time as mature networks develop stable miner sets, naturally shrinking the available candidate pool for emergency replacements.

## Recommendation

Modify the replacement loop to handle all evil miners, not just those with available alternatives:

```csharp
// In GenerateNextRoundInformation, replace the existing loop with:
var replacementCount = Math.Min(
    minerReplacementInformation.AlternativeCandidatePubkeys.Count,
    minerReplacementInformation.EvilMinerPubkeys.Count
);

// Process replacements with available alternatives
for (var i = 0; i < replacementCount; i++)
{
    // ... existing replacement logic
}

// Remove remaining evil miners without replacements
for (var i = replacementCount; i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
{
    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
    
    UpdateCandidateInformation(evilMinerPubkey,
        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
    
    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
    isMinerListChanged = true;
}
```

Additionally, consider implementing an emergency governance mechanism to rapidly onboard backup miners when the candidate pool is critically low.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a network with 21 miners where 15 are from the initial miner set
2. Having 10 miners miss blocks for 3+ days to trigger evil detection
3. Ensuring the candidate pool has only 3 available alternatives (with remaining initial miners already banned or serving)
4. Observing that `GetMinerReplacementInformation` returns 3 alternatives for 10 evil miners
5. Verifying the replacement loop only processes 3 iterations, leaving 7 evil miners in `RealTimeMinersInformation`
6. Confirming these 7 miners still have assigned time slots but produce no blocks, degrading consensus capacity

The test would validate that `currentRound.RealTimeMinersInformation.Count` remains higher than expected and includes miners with `State.BannedPubkeyMap[pubkey] == true`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L363-392)
```csharp
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-343)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
