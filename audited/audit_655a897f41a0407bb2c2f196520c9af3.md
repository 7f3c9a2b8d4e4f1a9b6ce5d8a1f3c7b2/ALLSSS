### Title
Incomplete Debt Repayment Logic Allows Unbounded Debt Accumulation for Side Chain Creators

### Summary
The `PayRental()` function uses strict inequality (`>`) instead of (`>=`) when checking if the creator's balance can cover existing debt, preventing any debt repayment when balance equals or is less than the debt amount. This causes side chain rental debt to accumulate unboundedly even when the creator has partial funds available, creating a debt spiral where payments only increase future debt without reducing past debt.

### Finding Description

The vulnerability exists in the `PayRental()` method's debt repayment logic: [1](#0-0) 

**Root Cause:** The condition at line 1051 uses strict inequality (`availableBalance > owningRental`) instead of `>=`. This creates two critical failure scenarios:

**Scenario 1 - Balance Equals Debt:**
When a creator's balance exactly equals their debt (e.g., balance = 100, debt = 100, rental = 80):
- Line 1051 evaluates FALSE (100 > 100 is false)
- Debt repayment block (lines 1053-1057) is completely skipped
- Only current rental is paid (line 1064)
- Result: Balance = 20, Debt = 100 (unchanged)
- The creator had exactly enough to clear debt but it wasn't paid

**Scenario 2 - Balance Less Than Debt:**
When balance is less than debt (e.g., balance = 50, debt = 100, rental = 80):
- Line 1051 evaluates FALSE (50 > 100 is false)
- Debt repayment block is skipped
- Insufficient balance for rental, enters failure branch (line 1067)
- Lines 1070-1075 donate entire balance (50) but apply none to old debt
- New debt calculation: `own = rental - availableBalance = 80 - 50 = 30`
- Line 1075: `State.OwningRental[symbol] = 100 + 30 = 130`
- Result: Balance = 0, Debt = 130
- The creator paid 50, but debt grew from 100 to 130 instead of reducing to 50 [2](#0-1) 

**Note:** The specific scenario mentioned in the question (balance > debt but insufficient for full rental) actually works correctly because it enters the debt repayment block and properly calculates the remaining shortfall.

The existing test case validates this broken behavior: [3](#0-2) 

This test confirms that when issuing only 1 token against a debt of 400, the final debt becomes 799 (400 old + 400 new - 1 paid), proving no partial debt reduction occurs.

### Impact Explanation

**Direct Financial Impact:**
- Side chain creators accumulate unbounded debt when their balance falls to or below existing debt levels
- Once balance ≤ debt, creators enter a debt spiral where all payments increase future debt without reducing past debt
- Even when adding funds, if new balance ≤ accumulated debt, the debt continues growing

**Affected Parties:**
- Side chain creators who must pay rental fees for resources (CPU, RAM, DISK, NET)
- The consensus contract expects proper rental collection but receives incorrect amounts

**Severity Justification:**
This is a **Medium-High** severity issue because:
1. It causes direct financial loss to side chain creators
2. Debt can grow unboundedly, making it mathematically impossible to repay
3. Affects automatic system operations (rental collection)
4. No recovery mechanism exists once trapped in debt spiral
5. However, it requires the creator's balance to drop below/equal debt first (not immediate exploit)

### Likelihood Explanation

**Reachable Entry Point:**
The `PayRental()` function is called automatically by `DonateResourceToken()`: [4](#0-3) 

`DonateResourceToken()` is a system transaction generated automatically by the blockchain, requiring no attacker interaction.

**Attack Complexity:**
This is **not an attack** but an inherent logic flaw that triggers in normal operations:
- No malicious action required
- Occurs automatically when creator balance naturally drops below debt
- Happens during routine rental fee collection every minute

**Feasibility Conditions:**
Highly feasible - only requires:
1. Side chain creator's balance to drop to or below accumulated debt (common during low-balance periods)
2. Time to pass (rental fees charged every minute)
3. No manual intervention to add funds exceeding debt

**Probability:**
**HIGH** - This will eventually occur for any side chain that:
- Experiences temporary low balances
- Has accumulated any rental debt
- Continues operating normally

The automatic nature of rental collection (every minute) means this affects any side chain creator who doesn't maintain balance strictly greater than debt at all times.

### Recommendation

**Code-Level Mitigation:**

Change line 1051 from strict inequality to inclusive inequality and implement partial debt repayment:

```csharp
// Current (vulnerable):
if (availableBalance > owningRental)

// Fixed version:
if (owningRental > 0 && availableBalance > 0)
{
    var debtPayment = Math.Min(availableBalance, owningRental);
    donates = debtPayment;
    availableBalance = availableBalance.Sub(debtPayment);
    State.OwningRental[symbol] = owningRental.Sub(debtPayment);
}
```

This ensures:
1. Any available balance contributes to debt reduction (even partial)
2. Debt is reduced proportionally to payment
3. Remaining balance is then applied to current rental

**Invariant Checks:**
Add assertion: `State.OwningRental[symbol]` should never increase when `availableBalance > 0` at the start of `PayRental()`

**Test Cases:**
Add tests for:
1. `balance == debt`: Verify debt is fully cleared
2. `balance < debt`: Verify debt is partially reduced by balance amount
3. `0 < balance < debt < rental`: Verify all balance goes to debt reduction
4. Edge case: `balance = 1, debt = 1000, rental = 500`: Verify debt becomes 999, not 1499

### Proof of Concept

**Initial State:**
- Side chain creator has 100 CPU tokens
- Accumulated debt: 100 CPU
- Resource configuration: 4 CPU units
- Rental price: 100 tokens per unit per minute
- Current period rental: 4 × 100 = 400 CPU

**Execution Steps:**

1. **Block N:** `DonateResourceToken()` is called (automatic system transaction)
2. **PayRental() executes:**
   - Line 1044: `availableBalance = 100`
   - Line 1047: `owningRental = 100`
   - Line 1051: `if (100 > 100)` → **FALSE** (debt repayment skipped)
   - Line 1061: `rental = 400`
   - Line 1062: `if (100 >= 400)` → **FALSE** (enter failure branch)
   - Line 1070: `donates = 100` (all balance donated)
   - Line 1071: Creator balance set to 0
   - Line 1074: `own = 400 - 100 = 300`
   - Line 1075: `State.OwningRental["CPU"] = 100 + 300 = 400`

**Expected Result:**
- Old debt: 100
- Payment: 100
- New debt should be: 100 - 100 + 400 = 400 (debt reduced by payment)

**Actual Result:**
- Old debt: 100
- Payment: 100
- New debt: 400 (no debt reduction, payment only covered new rental shortfall)
- **Debt increased by 300 instead of staying constant**

**Success Condition for Exploit:**
The vulnerability is demonstrated when `State.OwningRental["CPU"]` increases from 100 to 400 despite a payment of 100 tokens, proving zero debt reduction occurred.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L948-950)
```csharp
        {
            PayRental();
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1047-1058)
```csharp
            var owningRental = State.OwningRental[symbol];
            if (owningRental > 0)
            {
                // If Creator own this symbol and current balance can cover the debt, pay the debt at first.
                if (availableBalance > owningRental)
                {
                    donates = owningRental;
                    // Need to update available balance,
                    // cause existing balance not necessary equals to available balance.
                    availableBalance = availableBalance.Sub(owningRental);
                    State.OwningRental[symbol] = 0;
                }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1067-1076)
```csharp
            else // Fail
            {
                // Donate all existing balance. Directly reset the donates.
                donates = GetBalance(creator, symbol);
                State.Balances[creator][symbol] = 0;

                // Update owning rental to record a new debt.
                var own = rental.Sub(availableBalance);
                State.OwningRental[symbol] = State.OwningRental[symbol].Add(own);

```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainSideChainRentFeeTest.cs (L173-205)
```csharp
    public async Task PayDebtTest_NotEnough()
    {
        await OwnResourceTest();

        // Charge
        foreach (var symbol in Symbols)
            await TokenContractStub.Issue.SendAsync(new IssueInput
            {
                Symbol = symbol,
                To = Creator,
                Amount = 1
            });

        await DelayOneMinuteAsync();

        var owningRental = await TokenContractStub.GetOwningRental.CallAsync(new Empty());
        owningRental.ResourceAmount["CPU"].ShouldBe(CpuAmount * Rental * 2 - 1);
        owningRental.ResourceAmount["RAM"].ShouldBe(RamAmount * Rental * 2 - 1);
        owningRental.ResourceAmount["DISK"].ShouldBe(DiskAmount * Rental * 2 - 1);
        owningRental.ResourceAmount["NET"].ShouldBe(NetAmount * Rental * 2 - 1);

        // Check balance before mining
        {
            var cpuBalance = await GetCreatorBalanceOfAsync("CPU");
            cpuBalance.ShouldBe(0);
            var ramBalance = await GetCreatorBalanceOfAsync("RAM");
            ramBalance.ShouldBe(0);
            var diskBalance = await GetCreatorBalanceOfAsync("DISK");
            diskBalance.ShouldBe(0);
            var netBalance = await GetCreatorBalanceOfAsync("NET");
            netBalance.ShouldBe(0);
        }
    }
```
