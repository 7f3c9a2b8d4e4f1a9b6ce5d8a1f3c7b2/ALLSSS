# Audit Report

## Title
Removed Proposers Retain Proposal Release Authority in Governance Contracts

## Summary
The Association, Parliament, and Referendum governance contracts fail to re-validate proposer whitelist membership when releasing proposals. Proposers removed from the whitelist after creating proposals can still execute those proposals once approved, violating the security model that whitelist removal should revoke all governance permissions.

## Finding Description

This vulnerability exists in the proposal release authorization logic across all three governance contracts.

**At Proposal Creation:**

When a user creates a proposal in the Association contract, the `CreateProposal` method validates the proposer is in the ProposerWhiteList [1](#0-0) . This check is performed by `AssertIsAuthorizedProposer` which verifies whitelist membership [2](#0-1) . The proposal then permanently stores the proposer's address [3](#0-2) .

**Whitelist Modification:**

Organizations can remove proposers from the whitelist via `ChangeOrganizationProposerWhiteList`, which updates the organization's ProposerWhiteList [4](#0-3) .

**At Proposal Release:**

When releasing a proposal, the `Release` method only verifies that the caller matches the originally stored proposer address, with no re-validation of ProposerWhiteList membership [5](#0-4) . Specifically, line 186 only checks `Context.Sender == proposalInfo.Proposer` without consulting the current whitelist state.

**Affected Contracts:**

This pattern is consistent across all three governance contracts:
- Parliament contract exhibits the same behavior [6](#0-5) 
- Referendum contract exhibits the same behavior [7](#0-6) 

The security invariant violation occurs because whitelist removal is expected to revoke ALL governance permissions, but the Release authorization check creates an exception that allows removed proposers to retain partial control.

## Impact Explanation

**Governance Authority Bypass:**
Organizations remove proposers from whitelists to revoke their authority, typically due to security concerns (compromised accounts), organizational changes, or loss of trust. Despite removal, these proposers retain the ability to execute approved proposals, creating a persistent attack surface.

**Attack Scenarios:**
1. **Malicious Batch Proposals**: A proposer creates multiple proposals, some approved without thorough review. After removal for suspicious behavior, they can still release approved malicious proposals.
2. **Compromised Accounts**: If a proposer's account is compromised after proposal approval but before release, the attacker can execute proposals at strategically chosen times (e.g., when treasury balances peak, during governance transitions).
3. **Timing Manipulation**: Removed proposers can delay release execution to exploit specific blockchain states.

**Impact Assessment: Medium**
- Direct unauthorized proposal execution after privilege revocation
- Violates governance security model and access control invariants
- Constraint: Proposals must meet approval thresholds, limiting immediate exploitation
- Scope: System-wide across all three governance contracts

## Likelihood Explanation

**Attacker Prerequisites:**
- Must initially be authorized proposer (realistic - whitelists include multiple members)
- Must create proposals that achieve approval thresholds (requires member support but feasible)
- Must be subsequently removed from whitelist (common in governance evolution)

**Execution Complexity:**
- Low - straightforward sequence: create proposal → obtain approval → get removed → call Release()
- No complex state manipulation or precise timing required
- Entry point is publicly accessible Release() method

**Realistic Preconditions:**
- Organizations frequently adjust proposer whitelists for security and operational reasons
- Proposal approval occurs through standard voting mechanisms
- Long proposal expiration periods create extended windows for exploitation
- No special privileges needed beyond initial whitelist membership

**Likelihood Assessment: Medium**
The vulnerability has medium likelihood because all preconditions represent normal governance operations. Risk increases in organizations with frequent whitelist changes, multiple concurrent proposals, and limited proposal review processes.

## Recommendation

Add whitelist re-validation in the `Release` method for all three governance contracts. The fix should verify that the caller is currently in the ProposerWhiteList before allowing proposal execution.

**For Association Contract:**
```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // Add whitelist re-validation
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(organization.ProposerWhiteList.Contains(Context.Sender), 
        "Proposer removed from whitelist.");
    
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    // ... rest of method
}
```

Apply the same pattern to Parliament and Referendum contracts, using their respective whitelist validation mechanisms [8](#0-7) [9](#0-8) .

## Proof of Concept

```csharp
// Scenario: Proposer removed from whitelist can still release approved proposals
[Fact]
public async Task RemovedProposer_CanStillReleaseApprovedProposal_Test()
{
    // 1. Setup organization with proposer Alice in whitelist
    var organizationAddress = await CreateOrganizationWithProposer(AliceAddress);
    
    // 2. Alice creates a proposal (whitelist check passes)
    var proposalId = await AssociationContractStub.CreateProposal.SendAsync(
        new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ContractMethodName = "Transfer",
            ToAddress = TokenContractAddress,
            Params = new TransferInput { To = BobAddress, Amount = 100 }.ToByteString(),
            ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1)
        });
    
    // 3. Organization members approve the proposal
    await ApproveProposal(proposalId.Output, organizationAddress);
    
    // 4. Organization removes Alice from proposer whitelist
    await RemoveProposerFromWhitelist(organizationAddress, AliceAddress);
    
    // 5. Alice (now removed) attempts to release the approved proposal
    var releaseResult = await AssociationContractStub.Release.SendAsync(proposalId.Output);
    
    // Expected: Transaction should fail because Alice is no longer in whitelist
    // Actual: Transaction succeeds - Alice can still release the proposal
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed); // This assertion FAILS
}
```

The test demonstrates that a removed proposer can successfully release approved proposals, confirming the authorization bypass vulnerability.

## Notes

This vulnerability represents a gap between the intended security model (whitelist removal revokes ALL permissions) and the actual implementation (whitelist removal leaves a loophole for proposal release). While the approval threshold requirement provides some protection, it does not address the core issue that removed users should have no governance authority whatsoever. The vulnerability affects critical governance infrastructure and should be addressed to maintain the integrity of the authorization model across all three governance contracts.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L157-157)
```csharp
            Proposer = Context.Sender,
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
