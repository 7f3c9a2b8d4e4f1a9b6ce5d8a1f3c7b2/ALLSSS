### Title
Ambiguous Profit Detail Matching Causes Incorrect Vote Extension Due to Inconsistent Fallback Logic

### Summary
The Election contract's `GetProfitDetailByElectionVotingRecord()` and Profit contract's `FixProfitDetail()` use inconsistent fallback logic when matching profit details by shares for old votes (where Id is null). When multiple votes have identical weights, the Election contract uses `LastOrDefault` to validate existence, but the Profit contract uses `OrderBy(StartPeriod).FirstOrDefault` to perform the actual update, causing the wrong profit detail to be extended.

### Finding Description

The vulnerability exists in the interaction between two contracts when handling old-system votes (before profit detail IDs were introduced):

**Election Contract - Existence Check:** [1](#0-0) 

The Election contract uses `LastOrDefault` to find profit details matching by Shares when the Id-based lookup fails.

**Profit Contract - Actual Modification:** [2](#0-1) 

The Profit contract uses `OrderBy(d => d.StartPeriod).FirstOrDefault` to find profit details matching by Shares when the Id-based lookup fails.

**Root Cause:**
The contracts use different LINQ methods to select from multiple profit details with identical Shares:
- Election: `LastOrDefault` returns the last element in the collection
- Profit: `OrderBy(StartPeriod).FirstOrDefault` returns the element with the earliest StartPeriod

**Why Protections Fail:**
Two votes with identical amounts and lock times will have identical weights: [3](#0-2) 

The weight calculation is deterministic based on amount and lock time. Multiple votes with the same parameters create profit details with identical Shares but different StartPeriods. The code comments acknowledge backward compatibility for old votes: [4](#0-3) [5](#0-4) 

**Execution Path:**
1. `ChangeVotingOption()` is called with `IsResetVotingTime=true` [6](#0-5) 

2. `ExtendVoterWelfareProfits()` retrieves and validates the profit detail [7](#0-6) 

3. `FixProfitDetail()` is called to update the period [8](#0-7) 

### Impact Explanation

**Direct Fund Impact:**
- Users can extend the profit distribution period of Vote A by calling `ChangeVotingOption` on Vote B (both having identical weights)
- Vote A receives extended profit distributions it should not be entitled to
- Vote B's profit period remains unchanged when it should be extended
- This enables selective manipulation of which votes receive profit benefits, allowing users to maximize returns on votes that would otherwise expire

**Affected Parties:**
- Users with multiple old-system votes having identical weights can exploit this
- Other profit scheme beneficiaries receive diluted distributions due to incorrect share periods
- The protocol's profit distribution integrity is compromised

**Severity Justification:**
HIGH severity because:
1. Leads to direct financial gain through manipulated profit distributions
2. Results in incorrect profit settlements affecting the entire welfare scheme
3. Exploitable by any user with old votes having matching weights
4. No authorization bypass required - uses normal contract functions
5. Difficult to detect as the state corruption appears as legitimate vote extensions

### Likelihood Explanation

**Attacker Capabilities:**
- Any user who created multiple votes with identical amounts and lock times in the old system (before profit detail IDs)
- No special permissions required
- Only needs to call `ChangeVotingOption`, a standard public method

**Attack Complexity:**
LOW - The exploit sequence is straightforward:
1. User must have 2+ old votes (Id=null) with identical Weight
2. Call `ChangeVotingOption` on the later vote with `IsResetVotingTime=true`
3. System extends the earlier vote's profit period instead

**Feasibility Conditions:**
- Old-system votes (Id=null) must still exist in the system
- Multiple votes from the same user must have identical weights (same amount and lock time)
- This is realistic as users commonly vote with standardized amounts (e.g., 1000 tokens for 365 days) [9](#0-8) 

The test suite demonstrates three votes with identical parameters, confirming this scenario is expected behavior.

**Detection/Operational Constraints:**
- Difficult to detect as both contracts execute successfully
- No error thrown - the wrong profit detail is silently modified
- Appears as legitimate vote extension in system logs

**Probability:**
MEDIUM-HIGH - While it requires old-system votes, many production systems likely have legacy data. Users voting with common parameters (round numbers, standard lock periods) will naturally create duplicate weights.

### Recommendation

**Code-Level Mitigation:**

1. **Align fallback logic** - Use consistent ordering in both contracts:
```
// In ElectionContract_Elector.cs line 181, change to:
profitDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
    .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
```

2. **Add validation in FixProfitDetail** to ensure the found detail's characteristics match expectations:
```
// In ProfitContract.cs after line 289, add:
Assert(fixingDetail.Shares == input.BeneficiaryShare.Shares, 
    "Profit detail shares mismatch");
```

3. **Implement strict matching** - When ProfitDetailId is provided but Id lookup fails, require exact shares match with only one candidate:
```
if (input.ProfitDetailId != null && fixingDetail == null)
{
    var candidates = profitDetails.Details.Where(d => d.Shares == input.BeneficiaryShare.Shares).ToList();
    Assert(candidates.Count == 1, "Ambiguous profit detail match - multiple details with same shares");
    fixingDetail = candidates.Single();
}
```

**Invariant Checks:**
- Assert that when extending a vote's profit, the retrieved profit detail's StartPeriod is consistent with the vote's creation time
- Log warnings when fallback matching is used and multiple matches exist

**Test Cases:**
1. Test with 2+ old votes having identical weights, verify correct profit detail is extended
2. Test that `LastOrDefault` and `FirstOrDefault` return the same detail when weights match
3. Test migration scenario where old votes (Id=null) are updated with proper IDs
4. Add integration test that verifies profit distribution correctness after changing voting options for duplicate-weight votes

### Proof of Concept

**Required Initial State:**
- System contains old-system profit scheme (before Id feature)
- User Alice has:
  - Vote A: 1000 tokens, 365 days lock, created at Period P, Weight W, profit detail with (Id=null, Shares=W, StartPeriod=P)
  - Vote B: 1000 tokens, 365 days lock, created at Period P+5, Weight W, profit detail with (Id=null, Shares=W, StartPeriod=P+5)

**Transaction Steps:**
1. Alice calls `ElectionContract.ChangeVotingOption`:
   - VoteId = Vote B's Hash
   - CandidatePubkey = (any valid candidate)
   - IsResetVotingTime = true

2. Internal execution:
   - `ExtendVoterWelfareProfits(VoteB_Hash)` called
   - `GetProfitDetailByElectionVotingRecord(VoteB_Record)` called:
     - FirstOrDefault(Id == VoteB_Hash) → returns null (old system)
     - LastOrDefault(Shares == W) → returns Vote B's profit detail ✓
   - Validation passes
   - `ProfitContract.FixProfitDetail` called with:
     - ProfitDetailId = VoteB_Hash
     - Shares = W
     - EndPeriod = NewEndPeriod
   - In FixProfitDetail:
     - SingleOrDefault(Id == VoteB_Hash) → returns null (old system)
     - OrderBy(StartPeriod).FirstOrDefault(Shares == W) → returns Vote A's detail (P < P+5)
     - **Vote A's EndPeriod updated to NewEndPeriod** ✗

**Expected vs Actual Result:**
- Expected: Vote B's profit detail EndPeriod extended to NewEndPeriod
- Actual: Vote A's profit detail EndPeriod extended to NewEndPeriod
- Vote B's profit detail remains unchanged

**Success Condition:**
Query profit details after execution:
- Vote A's detail has EndPeriod = NewEndPeriod (incorrectly extended)
- Vote B's detail has EndPeriod = OriginalEndPeriod (incorrectly unchanged)

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-38)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L140-159)
```csharp
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L176-182)
```csharp
        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L280-289)
```csharp
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L352-352)
```csharp
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
```

**File:** test/AElf.Contracts.Election.Tests/Full/ChangeVotingOptionTests.cs (L21-26)
```csharp
        // Voter 1 votes 3 times.
        for (var i = 0; i < 3; i++)
        {
            await VoteToCandidateAsync(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400,
                10);
        }
```
