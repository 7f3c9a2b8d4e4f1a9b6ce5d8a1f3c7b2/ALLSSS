### Title
NFT Type Removal Breaks Cross-Chain Protocol Synchronization

### Summary
The NFT contract allows Parliament to remove NFT types from the registry via `RemoveNFTType`, but existing protocols created with those types remain on the mainchain. When attempting to synchronize these protocols to side chains via `CrossChainCreate`, the operation fails because the method looks up the removed type in the registry and throws an assertion error, causing a denial-of-service for cross-chain NFT functionality.

### Finding Description

The NFT contract maintains a registry of NFT types with three state mappings: `NFTTypes` (short name → full name), `NFTTypeFullNameMap` (short name → full name), and `NFTTypeShortNameMap` (full name → short name). [1](#0-0) 

Parliament can remove NFT types through the `RemoveNFTType` method, which removes entries from all three state mappings. [2](#0-1) 

**Root Cause:**

When `CrossChainCreate` is called to synchronize an NFT protocol to a side chain, it extracts the 2-character short name from the symbol (e.g., "AR" from "AR123456") and attempts to look it up in `NFTTypeFullNameMap`. [3](#0-2) 

If the type was previously removed by Parliament, the lookup returns null and the method throws an assertion error: "Full name of {shortName} not found. Use AddNFTType to add this new pair."

**Why Protection Fails:**

The `InitialNFTTypeNameMap()` helper is called at the start of `CrossChainCreate`, but it returns early if `State.NFTTypes.Value` is not null. [4](#0-3)  Since `RemoveNFTType` only removes entries from the map (leaving it non-null), the initialization doesn't restore the removed type.

**Execution Path:**

1. User creates NFT protocol on mainchain with type "Art" → symbol "AR123456" is generated [5](#0-4) 
2. Protocol info is stored with `nftType = "Art"` [6](#0-5) 
3. Parliament calls `RemoveNFTType("AR")` → removes "AR" from all mappings [7](#0-6) 
4. Token is cross-chain created on side chain via MultiToken contract (succeeds)
5. User/system calls `CrossChainCreate("AR123456")` on side chain
6. Method extracts "AR" and looks it up → returns null → assertion fails

### Impact Explanation

**Harm:** NFT protocols created on the mainchain before type removal cannot be synchronized to side chains. The `CrossChainCreate` method will revert with an assertion error, preventing the NFT protocol info from being created on the side chain.

**Protocol Damage:** While the MultiToken contract may successfully create the token on the side chain, the NFT-specific protocol information (including minter lists, metadata, and NFT type) will not exist. This breaks NFT-specific operations like minting, burning, and NFT info queries on side chains.

**Affected Users:** All users who created NFT protocols using a type that was subsequently removed by Parliament. Side chain users cannot access NFT functionality for these protocols.

**Severity Justification:** This is a **Medium severity** denial-of-service vulnerability because:
- It requires Parliament governance action (high barrier)
- Impact is limited to cross-chain synchronization (mainchain protocols continue functioning)
- It breaks a core feature (cross-chain NFT support) for affected protocols
- Recovery requires Parliament to re-add the type via `AddNFTType`

### Likelihood Explanation

**Governance Action Required:** The vulnerability requires Parliament to approve and execute `RemoveNFTType`, which needs miner consensus through the default Parliament organization. [8](#0-7) 

**Realistic Scenario:** Parliament might legitimately deprecate obsolete or unused NFT types for cleanup purposes without realizing that:
1. Existing protocols on mainchain use those types
2. Cross-chain synchronization will fail for those protocols
3. No validation exists to prevent removing types that are in use

**Attack Complexity:** Low - single governance transaction execution.

**Feasibility Conditions:** 
- Parliament approves type removal (requires miner consensus)
- At least one NFT protocol exists using the removed type
- User attempts to synchronize that protocol to a side chain

**Detection Constraints:** The issue only manifests when attempting cross-chain synchronization after type removal. There are no tests covering this scenario, and the error message suggests adding the type back as a solution.

**Probability:** Medium-to-High for inadvertent breakage during legitimate governance cleanup operations.

### Recommendation

**Code-Level Mitigation:**

1. **Add validation in `RemoveNFTType`** to prevent removing types that are currently in use:
   - Iterate through `NftProtocolMap` or maintain a usage counter
   - Reject removal if any protocols use the type
   - Example check: Assert no protocols exist with symbol prefix matching the short name

2. **Modify `CrossChainCreate` to be resilient** to missing types:
   - Instead of looking up the type in the registry, extract it from the token's `ExternalInfo` metadata where the full type name is stored [9](#0-8) 
   - The mainchain already stores the NFT type in token metadata with key `NftTypeMetadataKey`
   - Use this stored value directly: `var nftTypeFullName = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];`
   - This decouples cross-chain synchronization from the registry state

**Invariant Check:**
- Maintain: "NFT types used by existing protocols cannot be removed from the registry"
- OR: "CrossChainCreate must succeed for any protocol that was successfully created on the source chain"

**Test Cases:**
1. Create protocol with type "Art" → Remove "AR" type → Verify CrossChainCreate fails
2. Create protocol with type "Art" → Remove "AR" type → Re-add "AR" → Verify CrossChainCreate succeeds
3. Test that RemoveNFTType rejects removal when protocols use that type (after fix)
4. Test CrossChainCreate extracts type from token metadata (after fix)

### Proof of Concept

**Required Initial State:**
- NFT contract deployed on mainchain and side chain
- MultiToken contract set up for cross-chain operations
- Parliament default organization configured

**Transaction Steps:**

1. **On Mainchain - Create Protocol:**
   ```
   NFTContract.Create({
     nft_type: "Art",
     protocol_name: "ArtCollection",
     total_supply: 1000000,
     ...
   })
   → Returns symbol "AR123456"
   ```

2. **On Mainchain - Parliament Removes Type:**
   ```
   Parliament proposes and executes:
   NFTContract.RemoveNFTType("AR")
   → Fires NFTTypeRemoved event
   → State.NFTTypeFullNameMap["AR"] = null
   ```

3. **Cross-Chain Token Sync (Succeeds):**
   ```
   MultiToken.CrossChainCreateToken("AR123456", ...)
   → Token created on side chain (no NFT type check)
   ```

4. **On Side Chain - Attempt Protocol Sync (Fails):**
   ```
   NFTContract.CrossChainCreate({ symbol: "AR123456" })
   → Extracts "AR" from symbol
   → Looks up State.NFTTypeFullNameMap["AR"]
   → Returns null
   → Throws: "Full name of AR not found. Use AddNFTType to add this new pair."
   ```

**Expected vs Actual Result:**
- **Expected:** Cross-chain NFT protocol synchronization succeeds, allowing side chain users to interact with the NFT protocol
- **Actual:** CrossChainCreate reverts with assertion error, NFT protocol cannot be used on side chain despite token existing in MultiToken contract

**Success Condition:** The assertion failure at line 91-93 of `CrossChainCreate` demonstrates the denial-of-service condition.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-40)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-42)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

```
