### Title
Missing Upper Bound Validation in SetMethodFee Allows Governance-Controlled DOS of Critical Chain Operations

### Summary
The `SetMethodFee()` function in Genesis and TokenContract lacks upper bound validation on fee amounts, only checking for non-negative values. This allows a compromised or malicious Parliament governance to set astronomical fees (e.g., `BasicFee = long.MaxValue - 1`) for critical methods like token transfers, effectively DOS'ing the entire chain by making these operations unusable for all users until governance reverts the change.

### Finding Description
The vulnerability exists in the fee validation logic across multiple contracts implementing the ACS1 standard:

**Genesis Contract Fee Validation:** [1](#0-0) 

The `AssertValidToken` validation only checks for non-negative amounts: [2](#0-1) 

**TokenContract Fee Validation:** [3](#0-2) 

The validation chain leads to `AssertValidSymbolAndAmount` which only checks for positive values: [4](#0-3) 

**Fee Charging Enforcement:**
When a transaction is executed, the `ChargeTransactionFees` pre-execution plugin attempts to charge fees: [5](#0-4) 

If charging fails (due to insufficient balance for astronomical fees), the plugin stops execution: [6](#0-5) 

This results in transaction failure with error "Pre-Error: Transaction fee not enough": [7](#0-6) 

**Authorization Control:**
The controller defaults to Parliament's default organization: [8](#0-7) 

### Impact Explanation
**Critical Operational DOS:**
- If astronomical fees (e.g., `BasicFee = long.MaxValue - 1 = 9,223,372,036,854,775,806`) are set on critical methods like `Transfer` in TokenContract or any method in Genesis contract, ALL users will fail the fee charging step during pre-execution
- Users cannot possibly have balances approaching `long.MaxValue` to pay such fees, causing 100% transaction failure rate
- Affected operations include: token transfers, governance actions, cross-chain operations, consensus participation, and any contract method with configured fees

**Chain-Wide Impact:**
- All users are affected equally - no one can execute the DOS'd methods
- Chain functionality is effectively halted for those operations
- Only recoverable through another Parliament proposal to reduce fees, requiring governance coordination during crisis

**Severity Justification:**
- **CRITICAL** severity because it can halt core chain operations (token transfers, governance)
- No technical barrier once governance control is obtained
- Affects entire user base simultaneously
- Recovery requires governance action during compromised state

### Likelihood Explanation
**Attacker Capabilities Required:**
- Must compromise or control Parliament's default organization
- Requires 66.67% miner approval to pass malicious proposal
- This represents significant but achievable governance compromise

**Attack Complexity:**
1. Create Parliament proposal calling `SetMethodFee` with astronomical values
2. Get proposal approved by compromised/malicious miners (66.67% threshold)
3. Release proposal to execute the fee change
4. All subsequent user transactions to affected methods fail at fee charging stage

**Feasibility Assessment:**
- Technically straightforward once governance control achieved
- No cryptographic or consensus-level attacks needed
- Attack leaves clear on-chain evidence (proposal + fee configuration change)
- Executable within standard governance timeframes

**Detection & Operational Constraints:**
- Easily detectable once executed (all transactions fail)
- Reversible only through another governance proposal
- During attack, governance may be DOS'd if fees set on governance methods
- Creates circular dependency if recovery methods are also DOS'd

**Likelihood Rating: MEDIUM**
- Requires significant governance compromise (not trivial)
- But no additional technical barriers once governance obtained
- Historical governance attacks on blockchain systems demonstrate this is within threat model

### Recommendation
**Code-Level Mitigation:**
Add maximum fee validation in `SetMethodFee()` implementations. Recommended approach:

1. **Define Maximum Fee Constant:** Add a reasonable maximum fee based on token economics (e.g., 1% of total supply or a fixed reasonable maximum like `1_000_000_00000000` for 8-decimal tokens)

2. **Add Validation in AssertValidToken:** Modify validation in both Genesis and TokenContract:
```
Assert(amount >= 0 && amount <= MAX_METHOD_FEE, "Invalid amount.");
```

3. **Consider Total Supply Check:** Optionally validate against token's total supply:
```
var tokenInfo = GetTokenInfo(symbol);
Assert(amount <= tokenInfo.TotalSupply / 100, "Fee exceeds 1% of total supply.");
```

**Locations to Update:** [2](#0-1) [9](#0-8) [4](#0-3) 

**Test Cases to Add:**
1. Test setting `BasicFee = long.MaxValue` (should fail)
2. Test setting `BasicFee = MAX_METHOD_FEE + 1` (should fail)
3. Test setting reasonable high fees below threshold (should succeed)
4. Test that existing fee charging logic works with maximum valid fees

### Proof of Concept
**Initial State:**
- Parliament default organization controls method fee controller
- Token contract has normal fee configuration (e.g., Transfer costs 0.1 ELF)
- Users have normal token balances (e.g., 1,000 ELF)

**Attack Steps:**
1. Attacker compromises 67% of Parliament miners
2. Create malicious proposal:
   - Target: TokenContract address
   - Method: `SetMethodFee`
   - Parameters: `MethodFees{ MethodName: "Transfer", Fees: [{ Symbol: "ELF", BasicFee: 9223372036854775806 }] }`
3. Compromised miners approve proposal
4. Attacker releases proposal - fee change executes successfully
5. Any user attempting token transfer:
   - Pre-execution: `ChargeTransactionFees` called
   - Fee charging attempts to deduct 9,223,372,036,854,775,806 ELF
   - User balance insufficient (e.g., 1,000 ELF << required amount)
   - Charging returns `{ Success: false, ChargingInformation: "Transaction fee not enough." }`
   - Plugin's `IsStopExecuting` returns `true`
   - Main transaction never executes
   - Transaction fails with "Pre-Error: Transaction fee not enough."

**Expected vs Actual Result:**
- **Expected (with fix):** `SetMethodFee` should reject astronomical fee with "Invalid amount" error
- **Actual (current):** `SetMethodFee` succeeds, all subsequent user transactions fail at fee charging

**Success Condition:**
Attack succeeds when legitimate users can no longer execute the targeted method (e.g., Transfer) due to unpayable fees, while governance retains ability to revert through new proposal.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L59-71)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        RequireParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L73-82)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-53)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }

        // Record tx fee bill during current charging process.
        var bill = new TransactionFeeBill();
        var allowanceBill = new TransactionFreeFeeAllowanceBill();
        var fromAddress = Context.Sender;
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L328-332)
```csharp
        var dummy = await userTestContractStub.DummyMethod
            .SendWithExceptionAsync(new Empty()); // This will deduct the fee
        dummy.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        dummy.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
        var transactionFeeDic = dummy.TransactionResult.GetChargedTransactionFees();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L97-106)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```
