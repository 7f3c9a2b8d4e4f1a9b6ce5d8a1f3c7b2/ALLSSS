# Audit Report

## Title
Insufficient Precision in Natural Logarithm Series Causes Transaction Failures and Pricing Errors for Large Token Purchases

## Summary
The `Ln()` function in BancorHelper uses a Taylor series with only 20 iterations, creating mathematical constraints that cause transaction failures when users attempt to purchase ≥50% of connector balance, and precision errors of ~1-2% for purchases in the 40-50% range. The `Buy()` function lacks validation to prevent these issues.

## Finding Description

The `Ln()` function implements natural logarithm using Taylor series expansion with a mathematical constraint requiring `0 < a < 2` [1](#0-0) . The function uses `_LOOPS = 20` iterations [2](#0-1) .

In `GetAmountToPayFromReturn()`, the code calculates `x = bt / (bt - a)` where `bt` is toConnectorBalance and `a` is amountToReceive [3](#0-2) . When a user attempts to buy `a ≥ bt/2`, then `x ≥ 2`, which violates the `Ln()` constraint and causes the transaction to fail.

The `Buy()` function directly calls `GetAmountToPayFromReturn()` without validating that the requested amount is within acceptable bounds [4](#0-3) . The `PayLimit` check occurs after the calculation, so it cannot prevent the mathematical constraint violation [5](#0-4) .

For purchases approaching but not exceeding the 50% threshold (40-49% range), the Taylor series with 20 iterations produces ~1-2% precision errors. For example, buying 49% of balance results in `x ≈ 1.96`, giving internal series argument `|1-x| ≈ 0.96`, with error approximating `(0.96)^21/21 ≈ 0.02` or 2%.

The balance calculation includes virtual balance [6](#0-5) , which can amplify the issue when virtual balances are enabled.

## Impact Explanation

**Transaction Failure Impact (≥50% purchases):**
- Users attempting to buy ≥50% of connector balance experience transaction failure with "must be 0 < a < 2" exception
- This creates a denial-of-service condition, wasting user gas
- Since connector balance includes virtual balance, the threshold may trigger unexpectedly

**Pricing Precision Impact (40-50% purchases):**
- Users buying 40-49% of connector balance pay or receive ~1-2% incorrect amounts
- For a 1,000,000 token purchase at 45% of balance, the error could be ±10,000-20,000 tokens
- When users overpay due to precision errors, excess funds enter connector balances, skewing reserve ratios
- This violates the Bancor pricing invariant

**Severity: LOW** because:
- Error is bounded and predictable (~1-2% maximum)
- No direct fund theft mechanism
- Workaround exists: split large transactions
- Natural economic incentives (slippage concerns) discourage such large single transactions
- Failure mode is explicit exception rather than silent corruption

## Likelihood Explanation

**Required Conditions:**
- Sufficient funds to purchase 40-50% of connector balance
- No special privileges required - public `Buy()` function
- User unaware of the 50% limitation

**Probability Assessment:**
- **Issue 1 (≥50% failure):** Low probability - most users naturally split large orders for slippage management
- **Issue 2 (40-50% precision):** Very low probability - requires specific circumstances where a user wants exactly 40-49% in a single transaction
- Natural market dynamics discourage single large transactions
- However, large institutional buyers or whales could realistically encounter this

The likelihood is low but the trigger path is feasible and realistic for large buyers.

## Recommendation

Add validation in the `Buy()` function to check purchase size before calling `GetAmountToPayFromReturn()`:

```csharp
public override Empty Buy(BuyInput input)
{
    var toConnector = State.Connectors[input.Symbol];
    Assert(toConnector != null, "[Buy]Can't find to connector.");
    Assert(toConnector.IsPurchaseEnabled, "can't purchase");
    Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
    var fromConnector = State.Connectors[toConnector.RelatedSymbol];
    Assert(fromConnector != null, "[Buy]Can't find from connector.");
    
    // Add validation to prevent mathematical constraint violations
    var toBalance = GetSelfBalance(toConnector);
    Assert(input.Amount < toBalance / 2, 
        "Purchase amount must be less than 50% of connector balance. Please split into multiple transactions.");
    
    var amountToPay = BancorHelper.GetAmountToPayFromReturn(
        GetSelfBalance(fromConnector), GetWeight(fromConnector),
        toBalance, GetWeight(toConnector),
        input.Amount);
    // ... rest of function
}
```

Alternatively, increase `_LOOPS` to 40-50 iterations for better precision, or implement a more sophisticated logarithm approximation method that handles larger inputs.

## Proof of Concept

```csharp
[Fact]
public async Task Buy_Large_Amount_Causes_Transaction_Failure()
{
    // Setup: Create connector with balance
    await InitializeTokenConverterContract();
    var connectorBalance = 1000000L;
    
    // Attempt to buy exactly 50% of connector balance
    var attemptedPurchase = connectorBalance / 2;
    
    // This will throw InvalidValueException: "must be 0 < a < 2"
    var buyResult = await DefaultStub.Buy.SendAsync(
        new BuyInput
        {
            Symbol = WriteConnector.Symbol,
            Amount = attemptedPurchase,
            PayLimit = long.MaxValue
        });
    
    // Verify transaction failed due to mathematical constraint
    buyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    buyResult.TransactionResult.Error.ShouldContain("must be 0 < a < 2");
}

[Fact]
public async Task Buy_Large_Amount_45_Percent_Has_Precision_Error()
{
    // Setup connector
    await InitializeTokenConverterContract();
    var connectorBalance = 1000000L;
    
    // Buy 45% of balance - within limits but precision is degraded
    var attemptedPurchase = (long)(connectorBalance * 0.45);
    
    // Calculate expected price with high precision
    var expectedPrice = CalculateExactBancorPrice(attemptedPurchase);
    
    // Get actual price from contract
    var actualAmountToPay = BancorHelper.GetAmountToPayFromReturn(
        fromConnectorBalance, fromWeight,
        connectorBalance, toWeight,
        attemptedPurchase);
    
    // Verify precision error is approximately 1-2%
    var error = Math.Abs(actualAmountToPay - expectedPrice) / expectedPrice;
    error.ShouldBeGreaterThan(0.01); // Greater than 1%
    error.ShouldBeLessThan(0.025); // Less than 2.5%
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L98-98)
```csharp
    private const int _LOOPS = 20; // Max = 20
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L127-127)
```csharp
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-389)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
```
