# Audit Report

## Title
Missing Term Period Validation Allows Premature Term Transitions

## Summary
The AEDPoS consensus contract lacks validation to verify that the configured term period has elapsed before allowing term transitions. The timing check (`NeedToChangeTerm`) only occurs during local consensus command generation but is never re-validated during block validation or execution, enabling a malicious miner to force premature term changes with significant economic consequences.

## Finding Description

The vulnerability exists across the complete validation and execution flow of NextTerm consensus behavior:

**Root Cause - Timing Check Only in Command Generation:**
The `NeedToChangeTerm()` method determines whether a term transition should occur based on elapsed time. It checks if at least 2/3 of miners have timestamps indicating the `periodSeconds` duration has passed. [1](#0-0) 

However, this timing validation only occurs in the local command generation logic: [2](#0-1) 

**Missing Validation During Block Validation:**
When `ValidateBeforeExecution` processes a NextTerm behavior, it only adds `RoundTerminateValidationProvider` to the validation provider list: [3](#0-2) 

The `RoundTerminateValidationProvider.ValidationForNextTerm()` only validates numeric increments of round and term numbers - it performs NO timing verification: [4](#0-3) 

Similarly, `TimeSlotValidationProvider` only validates internal consistency of mining intervals within a round, not whether the term period has elapsed: [5](#0-4) 

**Missing Validation During Execution:**
During `ProcessNextTerm` execution, the only term validation is `TryToUpdateTermNumber`, which again only checks numeric increment: [6](#0-5) [7](#0-6) 

**Attack Vector:**
A malicious miner can:
1. Modify their node software to bypass the `NeedToChangeTerm()` check in `GetConsensusBehaviourToTerminateCurrentRound()`
2. Generate consensus extra data with NextTerm behavior by calling `GetConsensusExtraDataForNextTerm()`, which creates a valid Round structure with incremented term/round numbers: [8](#0-7) [9](#0-8) 

3. The block will pass all validation checks since no validator checks whether `periodSeconds` time has actually elapsed
4. Term transition executes successfully with all economic side effects

## Impact Explanation

**Consensus Integrity Compromise:**
Attackers can arbitrarily accelerate term transitions, breaking the fundamental timing invariant of the consensus mechanism (default 7-day term schedule with `periodSeconds = 604800`).

**Economic Impact - Premature Operations:**
Term transitions trigger critical economic operations that become exploitable when executed prematurely:

1. **Early Mining Reward Donations:** Mining rewards calculated and donated to Treasury ahead of schedule: [10](#0-9) 

2. **Early Treasury Releases:** Treasury funds distributed before the scheduled time, using the premature term number as period number: [11](#0-10) 

3. **Election Snapshot Timing Manipulation:** Snapshots taken at incorrect times, affecting staking reward calculations: [12](#0-11) 

**Affected Parties:**
All network participants suffer from disrupted economic schedules, incorrect reward distribution timing, and potential manipulation of election outcomes through snapshot timing control. Treasury beneficiaries receive funds prematurely, potentially enabling front-running strategies coordinated with governance proposals.

## Likelihood Explanation

**Attacker Capabilities:**
Requires being in the current miner list, which is realistic as miners are elected through staking mechanisms. A compromised or malicious miner node represents a valid threat model in Byzantine consensus systems. No additional privileges beyond standard miner status are needed.

**Attack Complexity:**
Moderate - the attacker must:
- Modify their node software to override the local `GetConsensusBehaviourToTerminateCurrentRound()` decision
- Understand the Round generation logic to create structurally valid NextTermInput
- Does NOT require breaking cryptography, manipulating block timestamps beyond normal tolerances, or complex state manipulation

**Execution Practicality:**
High - the attack path is straightforward:
1. Miner produces block during their normal time slot (e.g., day 3 of 7-day term)
2. Modified node forces NextTerm behavior in consensus extra data generation
3. Block passes all validation checks (only numeric increments validated)
4. Term changes 4 days early with all economic effects triggered immediately

**Detection Difficulty:**
The block appears structurally valid to all validators. Detection requires off-chain monitoring of term transition frequency against the expected schedule based on blockchain start timestamp and configured period seconds.

**Economic Rationality:**
Attack cost is zero (already a miner with block production rights). Potential benefits include:
- Manipulating treasury release timing for front-running opportunities
- Coordinating with governance proposals timed to specific terms
- Disrupting competitor staking reward calculations through snapshot manipulation

## Recommendation

Add timing validation to the block validation and/or execution flow:

**Option 1: Validation-Time Check**
Modify `RoundTerminateValidationProvider.ValidationForNextTerm()` to verify the term period has elapsed:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD: Verify timing constraint
    var blockchainStartTimestamp = /* retrieve from state */;
    var periodSeconds = /* retrieve from state */;
    var currentTermNumber = validationContext.CurrentTermNumber;
    
    if (!extraData.Round.NeedToChangeTerm(blockchainStartTimestamp, currentTermNumber, periodSeconds))
        return new ValidationResult { Message = "Term period has not elapsed - premature term transition." };
    
    return new ValidationResult { Success = true };
}
```

**Option 2: Execution-Time Check**
Modify `TryToUpdateTermNumber()` to validate timing:

```csharp
private bool TryToUpdateTermNumber(long termNumber)
{
    var oldTermNumber = State.CurrentTermNumber.Value;
    if (termNumber != 1 && oldTermNumber + 1 != termNumber) 
        return false;

    // ADD: Verify term period has elapsed
    if (termNumber != 1)
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var blockchainStartTimestamp = State.BlockchainStartTimestamp.Value;
        var periodSeconds = State.PeriodSeconds.Value;
        
        if (!currentRound.NeedToChangeTerm(blockchainStartTimestamp, oldTermNumber, periodSeconds))
            return false;
    }

    State.CurrentTermNumber.Value = termNumber;
    return true;
}
```

**Recommended Approach:** Implement validation-time check (Option 1) as the primary defense, since rejecting invalid blocks before execution is more efficient and provides clearer feedback to the network.

## Proof of Concept

```csharp
[Fact]
public async Task PrematureTermTransition_ShouldFail_ButPasses()
{
    // Setup: Initialize consensus with 7-day term period
    const long termPeriodSeconds = 604800; // 7 days
    await InitializeConsensus(termPeriodSeconds);
    
    // Advance to day 3 of current term (less than 7 days)
    var currentTime = TimestampHelper.GetUtcNow();
    await ProduceNormalBlocks(currentTime.AddSeconds(3 * 86400)); // 3 days passed
    
    var currentTermNumber = await GetCurrentTermNumber();
    var currentRoundNumber = await GetCurrentRoundNumber();
    
    // Attack: Malicious miner crafts NextTerm block
    var maliciousMinerKeyPair = InitialCoreDataCenterKeyPairs[0];
    
    // Generate NextTerm input (bypassing NeedToChangeTerm check)
    var victories = await GetVictories();
    var nextTermRound = victories.GenerateFirstRoundOfNewTerm(
        4000, 
        currentTime.AddSeconds(3 * 86400),
        currentRoundNumber,
        currentTermNumber);
    
    var nextTermInput = new NextTermInput
    {
        RoundNumber = nextTermRound.RoundNumber,
        TermNumber = nextTermRound.TermNumber,
        RealTimeMinersInformation = { nextTermRound.RealTimeMinersInformation }
    };
    
    // Execute premature NextTerm transaction
    var result = await ExecuteContractWithMiningAsync(
        ConsensusContractAddress,
        nameof(ConsensusContract.NextTerm),
        nextTermInput);
    
    // EXPECTED: Transaction should fail due to timing validation
    // ACTUAL: Transaction succeeds, term changes prematurely
    result.Status.ShouldBe(TransactionResultStatus.Failed); // This will FAIL
    
    var newTermNumber = await GetCurrentTermNumber();
    newTermNumber.ShouldBe(currentTermNumber); // This will FAIL - term actually incremented
    
    // Verify premature term transition occurred
    newTermNumber.ShouldBe(currentTermNumber + 1); // This PASSES - proving vulnerability
}
```

## Notes

The vulnerability stems from an architectural decision to separate timing logic (command generation) from validation logic (block validation/execution). The `NeedToChangeTerm` method exists and correctly implements the timing check, but it's only invoked during local consensus behavior determination, never during the critical validation phase where Byzantine actors could be introducing malicious blocks.

The `TimeSlotValidationProvider` validates that miners respect their assigned time slots within a round but does not validate term-level timing constraints. The `RoundTerminateValidationProvider` validates structural properties (numeric increments) but lacks any awareness of time-based constraints.

This is particularly severe because term transitions trigger multiple irreversible economic operations (treasury releases, reward donations, election snapshots) that assume the timing invariant holds. Breaking this invariant allows attackers to manipulate the economic schedule of the entire network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-243)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }

    /// <summary>
    ///     If periodSeconds == 7:
    ///     1, 1, 1 => 0 != 1 - 1 => false
    ///     1, 2, 1 => 0 != 1 - 1 => false
    ///     1, 8, 1 => 1 != 1 - 1 => true => term number will be 2
    ///     1, 9, 2 => 1 != 2 - 1 => false
    ///     1, 15, 2 => 2 != 2 - 1 => true => term number will be 3.
    /// </summary>
    /// <param name="blockchainStartTimestamp"></param>
    /// <param name="termNumber"></param>
    /// <param name="blockProducedTimestamp"></param>
    /// <param name="periodSeconds"></param>
    /// <returns></returns>
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-174)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-203)
```csharp
        if (DonateMiningReward(previousRound))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L205-211)
```csharp
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```
