### Title
Missing Negative Amount Validation in Transaction Fee Free Allowances Configuration Causes User Overcharging

### Summary
The `ConfigTransactionFeeFreeAllowances()` function validates that `threshold >= 0` and `refresh_seconds >= 0` but fails to validate that allowance amounts in `TransactionFeeFreeAllowances.Value` are non-negative. When negative allowance amounts are configured, users are overcharged during fee deduction because the fee calculation subtracts the negative allowance value, effectively adding it to the charged amount instead of reducing it.

### Finding Description

The vulnerability exists in the `ConfigTransactionFeeFreeAllowances()` function which validates configuration inputs but omits validation for the allowance amounts themselves. [1](#0-0) 

These lines validate that `threshold` and `refresh_seconds` are non-negative, but no such check exists for the `Amount` field in each `TransactionFeeFreeAllowance` object. [2](#0-1) 

The allowances are added to the configuration without validating that `allowance.Amount >= 0`. [3](#0-2) 

The protobuf definition shows `amount` is `int64`, which can be negative.

When users trigger a refresh, negative allowances are cloned into their state: [4](#0-3) 

During fee charging, `GetFreeFeeAllowanceAmount()` sums all allowances including negative values: [5](#0-4) 

In `ChargeBaseFee()`, when the calculated `existingAllowance` is negative and less than the fee amount, the else branch executes: [6](#0-5) 

Line 368 performs: `amountToChargeBaseFee.Sub(existingAllowance)`. When `existingAllowance` is negative (e.g., -100), this becomes: `50 - (-100) = 150`, causing the user to be charged 150 tokens instead of the actual 50 token fee.

Finally, the overcharged amount is deducted from the user's balance: [7](#0-6) 

### Impact Explanation

**Direct Fund Loss**: Users are overcharged by the absolute value of the negative allowance amount. For example, if a user should pay 50 ELF but has a -100 ELF allowance configured, they are charged 150 ELF instead, losing an extra 100 ELF.

**Denial of Service**: Users with sufficient balance for the actual fee but insufficient balance for the inflated charge will have their transactions fail, preventing them from using the system even though they should have enough funds.

**Scope**: All users whose balance meets the configured threshold are affected when allowances refresh. The impact scales with the magnitude of negative allowances and the frequency of fee-paying transactions.

**Severity Justification**: HIGH - This causes direct and quantifiable fund loss from users without their consent or awareness, violating the critical invariant of correct fee deduction paths.

### Likelihood Explanation

**Entry Point**: The `ConfigTransactionFeeFreeAllowances()` function is a public method accessible to the parliament controller. [8](#0-7) 

**Attacker Capabilities**: Requires parliament controller authorization. While this is a trusted role, input validation should prevent configuration errors or malicious actions that directly harm users.

**Attack Complexity**: LOW - Simply call `ConfigTransactionFeeFreeAllowances()` with negative amount values. No complex state manipulation or timing requirements.

**Feasibility Conditions**: 
- Parliament controller makes a configuration (either maliciously or through error)
- Users' balances meet the threshold, triggering allowance refresh
- Users execute fee-paying transactions

**Detection/Operational Constraints**: The overcharging may not be immediately obvious to users as transaction fees vary. Configuration errors could occur during routine fee structure updates.

**Probability**: MEDIUM-HIGH for accidental misconfiguration, MEDIUM for malicious exploitation (requires trusted role compromise). The missing validation represents a clear defensive gap regardless of trust assumptions.

### Recommendation

Add validation to ensure all allowance amounts are non-negative:

```csharp
foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
{
    Assert(allowance.Amount >= 0, $"Invalid allowance amount for symbol {allowance.Symbol}");
    config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
}
```

Insert this check between lines 1252-1255 in `ConfigTransactionFeeFreeAllowances()`.

**Invariant to enforce**: `∀ allowance ∈ TransactionFeeFreeAllowances.Value: allowance.Amount >= 0`

**Test case to add**: Extend the existing test to verify negative allowance amounts are rejected: [9](#0-8) 

Add a test case that attempts to configure an allowance with `Amount = -1` and verifies it fails with "Invalid allowance amount" error.

### Proof of Concept

**Initial State**:
- Parliament controller is authorized
- Token ELF exists and is configured as primary token
- User has balance of 200 ELF
- Actual transaction fee for a method is 50 ELF

**Attack Sequence**:

1. Parliament controller calls `ConfigTransactionFeeFreeAllowances()`:
```
ConfigTransactionFeeFreeAllowancesInput {
    Value = [{
        Symbol = "ELF",
        TransactionFeeFreeAllowances = {
            Value = [{
                Symbol = "ELF",
                Amount = -100  // Negative amount
            }]
        },
        Threshold = 100,
        RefreshSeconds = 3600
    }]
}
```

2. User with 200 ELF balance triggers allowance refresh (automatically during fee charging)
   - User's state: `TransactionFeeFreeAllowances[user][ELF] = {ELF: -100}`

3. User executes a transaction with 50 ELF fee
   - `GetFreeFeeAllowanceAmount()` returns: -100
   - `ChargeBaseFee()` calculates: `bill = 50 - (-100) = 150`
   - User is charged: 150 ELF

**Expected Result**: User should be charged 50 ELF (with 0 allowance benefit if negative allowances are invalid)

**Actual Result**: User is charged 150 ELF, losing an additional 100 ELF beyond the legitimate fee

**Success Condition**: User's balance decreases by 150 ELF instead of 50 ELF, demonstrating the overcharging vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-255)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L316-318)
```csharp
            State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol] = Context.CurrentBlockTime;
            State.TransactionFeeFreeAllowances[address][symbol] =
                State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L365-369)
```csharp
        else
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            bill.FeesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee.Sub(existingAllowance));
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1224-1227)
```csharp
    public override Empty ConfigTransactionFeeFreeAllowances(ConfigTransactionFeeFreeAllowancesInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input.Value != null && input.Value.Count > 0, "Invalid input");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1241-1242)
```csharp
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1252-1255)
```csharp
            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
            }
```

**File:** protobuf/token_contract_impl.proto (L356-359)
```text
message TransactionFeeFreeAllowance {
    string symbol = 1;
    int64 amount = 2;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest_FreeAllowance.cs (L377-465)
```csharp
    public async Task ConfigTransactionFeeFreeAllowances_InvalidInput_Test()
    {
        var message = await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendWithExceptionAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance()
                }
            });
        message.TransactionResult.Error.ShouldContain("Invalid input symbol");

        message = await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendWithExceptionAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = "TEST"
                    }
                }
            });
        message.TransactionResult.Error.ShouldContain("Symbol TEST not exist");

        message = await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendWithExceptionAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol
                    }
                }
            });
        message.TransactionResult.Error.ShouldContain("Invalid input allowances");

        message = await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendWithExceptionAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        Threshold = -1
                    }
                }
            });
        message.TransactionResult.Error.ShouldContain("Invalid input threshold");

        message = await TokenContractImplStub.ConfigTransactionFeeFreeAllowances.SendWithExceptionAsync(
            new ConfigTransactionFeeFreeAllowancesInput
            {
                Value =
                {
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        Threshold = 1_00000000,
                        RefreshSeconds = -1
                    }
                }
            });
        message.TransactionResult.Error.ShouldContain("Invalid input refresh seconds");
    }
```
