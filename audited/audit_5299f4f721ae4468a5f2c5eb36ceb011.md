### Title
Unauthorized Candidate Registration via AnnounceElectionFor() Enables Griefing and Temporary DataCentersRankingList DoS

### Summary
The `AnnounceElectionFor()` function lacks permission validation, allowing any caller to register arbitrary public keys as election candidates without authorization from the key owners. This violates authorization invariants and enables attackers to fill the DataCentersRankingList with unauthorized candidates, temporarily preventing legitimate candidates from receiving automatic subsidy benefits until they accumulate votes.

### Finding Description

The `AnnounceElectionFor()` function accepts an `AnnounceElectionForInput` containing a target public key and optional admin address, then registers that public key as a candidate without verifying that the caller has permission from the key owner. [1](#0-0) 

The internal `AnnounceElection()` method only validates that the public key is not an initial miner and not already a candidate, but performs no ownership or authorization check: [2](#0-1) 

This contrasts with the regular `AnnounceElection()` function which uses `Context.RecoverPublicKey()` to ensure the transaction sender owns the private key being registered: [3](#0-2) 

The attacker locks their own tokens (100,000 ELF per candidate) and sets themselves as the admin: [4](#0-3) 

When candidates are registered and the DataCentersRankingList has available space (capacity = `minersCount * 5`), they are automatically added with 0 initial votes: [5](#0-4) 

The victim cannot quit the election because only the admin (set to the attacker) has permission to call `QuitElection()`: [6](#0-5) 

The victim also cannot change the admin via `SetCandidateAdmin()` since an admin is already set and only the current admin can modify it (unless Parliament intervenes): [7](#0-6) 

### Impact Explanation

**Primary Impact - Authorization Violation (HIGH):**
- Any attacker can register arbitrary public keys as candidates without permission, violating the fundamental principle that users control their own identity and participation
- Victims' public keys are permanently associated with election candidacy in the contract state and voting system without consent
- Privacy and reputation damage as keys are publicly listed as candidates
- Victims have no practical recourse except slow Parliament governance intervention

**Secondary Impact - Temporary DoS (MEDIUM):**
- For a system with 5 miners, an attacker can fill all 25 slots in the DataCentersRankingList with unauthorized candidates (each having 0 votes)
- Legitimate candidates who register after the list is full do not receive automatic subsidy profit scheme benefits
- Cost: 2,500,000 ELF (25 candidates Ã— 100,000 ELF each)
- Mitigation: Fake candidates with 0 votes can be replaced when legitimate candidates receive votes through the `TryToBecomeAValidationDataCenter()` mechanism: [8](#0-7) 

However, until replacement occurs, fake candidates receive subsidy benefits and legitimate candidates suffer an initial economic disadvantage.

**Tertiary Impact - Griefing:**
- Attacker can continuously register and quit fake candidates to disrupt the election system
- Since tokens are fully recoverable, the attack can be repeated at minimal cost

### Likelihood Explanation

**High Likelihood:**
- Entry point is a public function accessible to any caller
- No special permissions or preconditions required beyond holding 100,000 ELF per fake candidate
- Attack execution is straightforward: call `AnnounceElectionFor()` with arbitrary public keys
- Economic cost (2,500,000 ELF to fill 25 slots) is feasible for motivated attackers, especially since tokens are fully recoverable by quitting the candidates
- Attacker maintains control as admin and can reclaim all locked tokens at will
- No detection mechanism exists to prevent or identify unauthorized registrations
- Test suite confirms the basic functionality works as described: [9](#0-8) 

### Recommendation

**Immediate Fix:**
Add authorization validation to `AnnounceElectionFor()` requiring one of the following:
1. A signature from the target public key proving consent
2. Prior authorization stored in contract state from the key owner
3. Restrict the function to governance/Parliament control only

**Code-level mitigation:**
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    // Add signature verification or authorization check
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
    var address = Address.FromPublicKey(pubkeyBytes);
    
    // Option 1: Require authorization from target address
    Assert(State.CandidateRegistrationAuthorizations[address][Context.Sender] == true,
        "Sender not authorized to register this candidate.");
    
    // OR Option 2: Require Parliament approval
    Assert(Context.Sender == GetParliamentDefaultAddress(), 
        "Only Parliament can register candidates on behalf of others.");
    
    // ... rest of existing logic
}
```

Add a new authorization management function:
```csharp
public override Empty AuthorizeCandidateRegistration(Address authorizedCaller)
{
    State.CandidateRegistrationAuthorizations[Context.Sender][authorizedCaller] = true;
    return new Empty();
}
```

**Test cases:**
- Verify `AnnounceElectionFor()` fails when caller lacks authorization from target public key
- Verify victim can revoke authorization
- Verify authorized callers can successfully register candidates
- Verify unauthorized registrations are prevented

### Proof of Concept

**Initial State:**
- System has 5 miners, allowing 25 candidates in DataCentersRankingList
- Attacker has 2,500,000 ELF balance
- Victim's public key: `VICTIM_PUBKEY`

**Attack Steps:**

1. Attacker calls `AnnounceElectionFor()` 25 times with different arbitrary public keys (including victim's):
```
Input: { Pubkey: "VICTIM_PUBKEY", Admin: attacker_address }
Result: Victim registered as candidate without permission
```

2. Verify unauthorized registration:
```
GetCandidateInformation(VICTIM_PUBKEY)
Returns: CandidateInformation { Pubkey: VICTIM_PUBKEY, IsCurrentCandidate: true }
```

3. Verify DataCentersRankingList is filled:
```
GetDataCenterRankingList()
Returns: 25 candidates with 0 votes each
```

4. Verify victim cannot quit:
```
Victim calls QuitElection(VICTIM_PUBKEY)
Result: Transaction fails with "Only admin can quit election."
```

5. Verify victim cannot change admin:
```
Victim calls SetCandidateAdmin({ Pubkey: VICTIM_PUBKEY, Admin: victim_address })
Result: Transaction fails with "No permission."
```

**Expected Result:** The function should reject unauthorized registration attempts
**Actual Result:** Arbitrary public keys are registered as candidates without owner permission, DataCentersRankingList is filled with 0-vote candidates, and victims have no recourse to remove their unauthorized candidacy

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L35-39)
```csharp
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L469-490)
```csharp
    private void TryToBecomeAValidationDataCenter(VoteMinerInput input, long candidateVotesAmount,
        DataCenterRankingList rankingList)
    {
        var minimumVotes = candidateVotesAmount;
        var minimumVotesCandidate = input.CandidatePubkey;
        var replaceWillHappen = false;
        foreach (var pubkeyToVotesAmount in rankingList.DataCenters.OrderBy(x => x.Value))
            if (pubkeyToVotesAmount.Value < minimumVotes)
            {
                replaceWillHappen = true;
                minimumVotesCandidate = pubkeyToVotesAmount.Key;
                break;
            }

        if (replaceWillHappen)
        {
            State.DataCentersRankingList.Value.DataCenters.Remove(minimumVotesCandidate);
            State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                candidateVotesAmount);
            NotifyProfitReplaceCandidateInDataCenter(minimumVotesCandidate, input.CandidatePubkey);
        }
    }
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L15-49)
```csharp
    [Fact]
    public async Task ElectionContract_AnnounceElectionFor_State_Test()
    {
        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        // Execute AnnounceElectionFor.
        var electionStub = GetElectionContractTester(sponsorKeyPair);
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });

        var balanceAfterAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
        balanceAfterAnnouncing.ShouldBe(balanceBeforeAnnouncing - ElectionContractConstants.LockTokenForElection);

        var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = MinerElectionVotingItemId
        });
        votingItem.Options.Count.ShouldBe(1);
        votingItem.Options.ShouldContain(candidatesKeyPair.PublicKey.ToHex());
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.ContainsKey(candidatesKeyPair.PublicKey.ToHex()).ShouldBeTrue();
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            SchemeId = subsidy,
            Beneficiary = Address.FromPublicKey(candidatesKeyPair.PublicKey)
        });
        profitDetail.Details.Count.ShouldBe(1);
    }
```
