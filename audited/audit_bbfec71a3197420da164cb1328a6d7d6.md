# Audit Report

## Title
InitialMiners Duplicate Entry Vulnerability Leading to Consensus Failure

## Summary
The `ReplaceCandidatePubkey()` function in the Election Contract fails to validate whether the new pubkey already exists in `InitialMiners` when performing replacements. Since initial miners exist in `InitialMiners` but are prohibited from being in `Candidates`, an admin can replace one initial miner with another initial miner's pubkey, creating duplicate entries. This causes consensus round generation to fail with a Dictionary exception when multiple evil miners need replacement, resulting in a network-wide denial of service.

## Finding Description

The vulnerability exists in the `ReplaceCandidatePubkey()` function which performs validation and state updates across two separate lists: `Candidates` and `InitialMiners`. [1](#0-0) 

The validation only checks if the new pubkey exists in the `Candidates` list, but does not verify if it already exists in `InitialMiners`. This creates a critical gap because initial miners are architecturally separated from candidates.

During initialization, `InitialMiners` is populated with genesis miners while `Candidates` starts empty: [2](#0-1) 

Initial miners are explicitly forbidden from announcing election and thus cannot be added to `Candidates`: [3](#0-2) 

When replacing an initial miner, the code removes the old pubkey from `InitialMiners` and adds the new pubkey WITHOUT checking if the new pubkey already exists: [4](#0-3) 

**Attack Scenario:**
1. Initial state: `InitialMiners = ["PubkeyA", "PubkeyB", "PubkeyC"]`
2. Admin calls `ReplaceCandidatePubkey(OldPubkey="PubkeyB", NewPubkey="PubkeyA")`
3. Validation passes because "PubkeyA" is not in `Candidates`
4. Result: `InitialMiners = ["PubkeyA", "PubkeyC", "PubkeyA"]` (duplicate!)

When consensus later needs to replace evil miners, `GetMinerReplacementInformation()` iterates through `InitialMiners` to select alternatives: [5](#0-4) 

Notice there is no `.Distinct()` call, so duplicates pass through. If multiple evil miners need replacement, the duplicate pubkey will be returned multiple times in the alternatives list.

During consensus round generation, the replacement logic attempts to add each alternative to `RealTimeMinersInformation`: [6](#0-5) 

The `RealTimeMinersInformation` is a `map<string, MinerInRound>` in protobuf: [7](#0-6) 

In C#, protobuf maps compile to Dictionary-like structures. When attempting to add the same key twice, the `Add()` method throws an `ArgumentException`, causing consensus round generation to fail completely.

## Impact Explanation

This vulnerability breaks the **consensus availability guarantee** of the AElf blockchain. When the consensus contract attempts to replace multiple evil miners and encounters a duplicate pubkey in the alternatives list, the transaction fails with an unhandled exception. This prevents:

1. **Round progression**: No new consensus rounds can be generated
2. **Block production**: Miners cannot produce new blocks
3. **Transaction finalization**: The entire network halts

The impact is **Critical** because:
- The entire network is affected (not just individual users)
- Requires manual intervention to resolve (cannot self-heal)
- Blockchain becomes completely non-functional until the duplicate is removed
- All network participants lose access to the blockchain

## Likelihood Explanation

The likelihood is **Medium-High** because:

**Required Privilege**: Admin for an initial miner (normal operational role, not a security compromise)

**Attack Complexity**: Low - A single transaction with straightforward parameters creates the vulnerability

**Preconditions**: 
- Multiple initial miners must exist (standard in production networks)
- Evil miners must later be detected for the consensus failure to manifest

**Detection Difficulty**: The duplicate entry is created silently without errors or events. The issue only surfaces later during consensus operations, making it difficult to detect proactively.

**Accidental Trigger**: This could realistically occur accidentally if an admin attempts to consolidate initial miners without understanding the constraint, or maliciously by a compromised admin seeking to disrupt consensus.

## Recommendation

Add validation to check if the new pubkey already exists in `InitialMiners` before performing the replacement:

```csharp
// In ReplaceCandidatePubkey(), after line 191, add:
if (initialMiners.Value.Contains(newPubkeyBytes))
{
    Assert(false, "New pubkey is already an initial miner.");
}
```

Alternatively, add deduplication in `GetMinerReplacementInformation()`:

```csharp
// In ViewMethods.cs, line 391, change to:
var selectedInitialMiners = State.InitialMiners.Value.Value
    .Select(k => k.ToHex())
    .Where(k => !State.BannedPubkeyMap[k])
    .Where(k => !input.CurrentMinerList.Contains(k))
    .Distinct()  // Add deduplication
    .Take(takeAmount);
```

## Proof of Concept

```csharp
[Fact]
public async Task InitialMiner_Duplicate_Entry_Causes_Consensus_Failure()
{
    // Setup: Initialize with 3 initial miners
    var initialMinerA = InitialCoreDataCenterKeyPairs[0];
    var initialMinerB = InitialCoreDataCenterKeyPairs[1];
    var initialMinerC = InitialCoreDataCenterKeyPairs[2];
    
    // Get admin for initialMinerB
    var adminB = Address.FromPublicKey(initialMinerB.PublicKey);
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, initialMinerB);
    
    // Attack: Replace initialMinerB with initialMinerA (creating duplicate)
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = initialMinerB.PublicKey.ToHex(),
        NewPubkey = initialMinerA.PublicKey.ToHex()
    });
    
    // Verify: InitialMiners now contains duplicate
    var initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    var countA = initialMiners.Value.Count(p => p.ToHex() == initialMinerA.PublicKey.ToHex());
    countA.ShouldBe(2); // Duplicate confirmed
    
    // Trigger: Simulate evil miner replacement scenario
    // Mark multiple miners as evil to trigger GetMinerReplacementInformation
    var currentMiners = new List<string> { 
        initialMinerA.PublicKey.ToHex(),
        initialMinerB.PublicKey.ToHex(),
        initialMinerC.PublicKey.ToHex()
    };
    
    // This will throw ArgumentException when trying to add duplicate pubkey
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await AEDPoSContractStub.GenerateNextRoundInformation.CallAsync(new Empty());
    });
    
    exception.Message.ShouldContain("An item with the same key has already been added");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L26-38)
```csharp
        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L337-338)
```csharp
                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```
