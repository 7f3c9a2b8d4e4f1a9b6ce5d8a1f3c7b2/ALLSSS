### Title
Arithmetic Overflow in Bancor Formula Causes DoS for Valid Extreme Weight Ratios

### Summary
The `GetReturnFromPaid()` and `GetAmountToPayFromReturn()` functions in BancorHelper use Taylor series approximations with only 20 terms to compute exponential functions. When connector weight ratios approach extreme but valid values (e.g., wf=0.99, wt=0.01, ratio=99), combined with moderate trade sizes, the computation of `Exp(y * Ln(x))` causes arithmetic overflow in the `Pow()` function, resulting in transaction revert and denial of service for legitimate token conversion operations.

### Finding Description

The vulnerability exists in the Bancor pricing calculation path used by both `Buy` and `Sell` operations in the TokenConverter contract. [1](#0-0) 

The function computes `Exp(y * Ln(x))` where `y = wf / wt` (weight ratio) and `x = bf / (bf + a)` (balance ratio). Connector weights are validated to be in the range (0, 1) exclusive: [2](#0-1) 

This allows weight ratios `y = wf / wt` to range from near-zero to near-infinity. For example, wf=0.99 and wt=0.01 creates y=99, which is mathematically valid.

The root cause is in the `Exp()` function's Taylor series implementation: [3](#0-2) 

For large absolute values of `y` (e.g., y = -40 when wf=0.99, wt=0.01, x=0.667), the computation of `Pow(y, 20)` at line 160 requires calculating y^20. For y = -40.14, this equals approximately 1.4 × 10^32, which exceeds C# `decimal` type's maximum value of ±7.9 × 10^28.

Since AElf contracts are required to enable `CheckForOverflowUnderflow=true`: [4](#0-3) 

The overflow causes an `OverflowException`, reverting the transaction and making Buy/Sell operations fail for these valid connector configurations.

The issue affects both entry points: [5](#0-4) [6](#0-5) 

### Impact Explanation

**Operational Impact - DoS of Token Conversion:**
- Certain valid connector weight configurations (e.g., wf=0.99, wt=0.01) become completely unusable when combined with moderate to large trade sizes (≥50% of balance)
- All Buy and Sell operations for affected connector pairs will revert with overflow exception
- Users cannot trade tokens through the TokenConverter for these pairs
- Locked liquidity: tokens deposited in connectors with extreme weight ratios cannot be efficiently traded

**Affected Parties:**
- Token holders attempting to buy/sell through affected connector pairs
- Protocol operations relying on TokenConverter functionality for resource token conversions
- Economic model stability if key connector pairs become dysfunctional

**Severity Justification:**
High severity due to complete denial of service for legitimate token conversion operations. While the issue requires specific connector weight configurations (controlled by governance), once deployed, these configurations are immutable until updated, and normal users suffer the consequences. The mathematical constraints (0 < weight < 1) do not prevent this scenario, making it a latent vulnerability in valid system states.

### Likelihood Explanation

**Reachable Entry Point:** Yes - any user can call `Buy()` or `Sell()` methods on public TokenConverter contract.

**Feasible Preconditions:**
1. Connector pair deployed with extreme weight ratio (e.g., wf=0.99, wt=0.01 or wf=0.01, wt=0.99)
2. User attempts trade size that creates x values resulting in |y * Ln(x)| > ~35

**Execution Practicality:**
- Connector weights are set by governance via `AddPairConnector()` or `UpdateConnector()` and remain static
- No attacker manipulation required - normal trading activity triggers the issue
- Trade size of 50% of connector balance is reasonable for moderate-sized trades
- The overflow occurs during legitimate price calculation

**Attack Complexity:** None - this is a bug triggered by normal operations, not an attack requiring special capabilities.

**Economic Rationality:** N/A - users are attempting legitimate trades, not exploiting for profit.

**Probability:** Medium-High. While extreme weight ratios may be less common in practice, they are mathematically valid and governance may deploy them for specific economic models (e.g., pegged assets or highly asymmetric bonding curves). Once deployed, the issue manifests predictably for certain trade sizes.

### Recommendation

**Immediate Mitigation:**
1. Add input validation to constrain the product `|y * Ln(x)|` before calling `Exp()`:

```csharp
public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
{
    // ... existing validation ...
    
    if (wf == wt)
        return (long)(bt / (bf + a) * a);
    
    var x = bf / (bf + a);
    var y = wf / wt;
    var expInput = y * Ln(x);
    
    // Add bounds check to prevent overflow in Exp()
    Assert(Math.Abs(expInput) <= 30m, "Weight ratio and trade size combination exceeds safe computation bounds.");
    
    return (long)(bt * (decimal.One - Exp(expInput)));
}
```

2. Apply similar validation to `GetAmountToPayFromReturn()`.

**Long-term Solution:**
1. Replace Taylor series approximations with more robust exponential computation methods that handle extreme values
2. Consider using iterative approximation methods or logarithmic transformation techniques
3. Add comprehensive weight ratio validation during connector setup to warn governance of potential numerical issues

**Test Cases:**
1. Test connector pairs with weights (0.99, 0.01) and (0.01, 0.99)
2. Test trade sizes from 10% to 95% of connector balance
3. Verify transactions either succeed or fail gracefully with meaningful error messages
4. Add fuzzing tests for extreme valid weight combinations

### Proof of Concept

**Initial State:**
1. Deploy TokenConverter contract with connector pair:
   - Resource token connector: weight = "0.01", balance = 100,000,000 tokens
   - Base token (ELF) connector: weight = "0.99", balance = 100,000,000 tokens
2. Enable connector pair for trading

**Exploitation Steps:**
1. User calls `Sell()` method:
   - Input: Symbol = ResourceToken, Amount = 50,000,000 (50% of balance)
   - PayLimit = 0 (no limit)

2. Contract executes `BancorHelper.GetReturnFromPaid()`:
   - fromConnectorBalance = 100,000,000
   - fromConnectorWeight = 0.01
   - toConnectorBalance = 100,000,000
   - toConnectorWeight = 0.99
   - paidAmount = 50,000,000

3. Calculation proceeds:
   - x = 100,000,000 / 150,000,000 = 0.6667
   - y = 0.01 / 0.99 ≈ 0.0101 (this direction is safe)
   
**Alternative PoC (triggers overflow):**
1. Same setup but reverse weights:
   - Resource token: weight = "0.99"
   - Base token: weight = "0.01"

2. User calls `Sell()` with Amount = 50,000,000

3. Calculation:
   - x = 0.6667
   - y = 0.99 / 0.01 = 99
   - Ln(0.6667) ≈ -0.4055
   - y * Ln(x) = 99 * (-0.4055) ≈ -40.14

4. `Exp(-40.14)` computation attempts `Pow(-40.14, 20)`:
   - (-40.14)^20 ≈ 1.4 × 10^32
   - Exceeds decimal.MaxValue (7.9 × 10^28)
   - Throws `OverflowException`

**Expected Result:** Transaction succeeds with calculated token return amount.

**Actual Result:** Transaction reverts with `System.OverflowException: Arithmetic operation resulted in an overflow.`

**Success Condition:** Any user attempting legitimate trades on connectors with extreme weight ratios experiences transaction revert, confirming complete DoS of the conversion functionality for those pairs.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```
