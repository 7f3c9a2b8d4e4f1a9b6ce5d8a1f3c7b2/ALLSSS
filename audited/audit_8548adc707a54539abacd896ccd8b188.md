# Audit Report

## Title
MissedTimeSlots Counter Reset at Term Boundaries Allows Malicious Miners to Evade Evil Node Detection

## Summary
The AEDPoS consensus contract resets the `MissedTimeSlots` counter to 0 during term transitions without performing evil miner detection, while detection only occurs during normal round transitions. This allows malicious miners to strategically miss blocks below the 4320-slot threshold and have their counters reset every 7-day term, enabling indefinite evasion of punishment.

## Finding Description

The consensus contract defines a tolerance threshold of 4320 missed time slots (representing 3 days at 1 slot per minute) for detecting evil miners. [1](#0-0) 

The detection mechanism `TryToDetectEvilMiners()` identifies miners whose `MissedTimeSlots` exceeds this threshold. [2](#0-1) 

**Critical Flaw:** Evil miner detection is ONLY performed during normal round transitions in `ProcessNextRound`. [3](#0-2) 

When detected, evil miners are marked with `IsEvilNode = true` in the Election contract, which permanently removes them from the candidate list. [4](#0-3) 

However, during term transitions in `ProcessNextTerm`, the contract:
1. Counts any final missed time slots via `CountMissedTimeSlots()` [5](#0-4) 
2. **Unconditionally resets ALL miners' `MissedTimeSlots` and `ProducedBlocks` to 0** [6](#0-5) 
3. Sends statistics to Election contract (informational only) [7](#0-6) 
4. **Does NOT call `TryToDetectEvilMiners()` before the reset**

The `MissedTimeSlots` counter is incremented when miners fail to produce blocks during round generation. [8](#0-7) 

**Attack Scenario:** A malicious miner can:
- Miss up to 4319 time slots during each 7-day term period (604,800 seconds)
- Avoid detection since they stay below the 4320 threshold
- Have their counter reset to 0 at the term boundary
- Repeat this pattern indefinitely across multiple terms

## Impact Explanation

This vulnerability has severe consensus integrity implications:

**Consensus Reliability Compromise:** With a 7-day term containing ~10,080 time slots (1 slot per minute), a miner can miss 4319 slots (~42.8% of their obligations) per term without punishment, significantly reducing network block production capacity.

**Protocol Invariant Violation:** The system's fundamental security guarantee—that miners exceeding the 4320 missed-slot threshold will be removed—is completely bypassed through this cross-term evasion mechanism.

**Persistent Attacker Advantage:** Malicious miners can remain in the active miner set indefinitely despite consistently poor performance, while honest miners who happen to exceed the threshold in a single term are permanently banned.

**No Economic Penalty:** The attacker maintains their miner status and potential rewards despite reduced participation, creating an unfair advantage and undermining the incentive structure designed to ensure reliable block production.

## Likelihood Explanation

**Attack Complexity:** Trivial - the attacker simply needs to control their own mining node's block production behavior.

**Preconditions:** 
- Attacker must be an elected miner (achievable through normal election process)
- No special permissions required beyond standard miner status
- Term transitions occur automatically every 7 days as configured in the system

**Execution Practicality:**
- The attack is fully deterministic and risk-free
- No coordination with other parties needed
- Term boundary reset is automatic and unavoidable
- No cross-term tracking mechanisms exist to detect the pattern

**Detection Difficulty:** The current implementation provides no way to track cumulative missed slots across term boundaries, making this attack pattern completely invisible to protocol monitoring.

## Recommendation

Add evil miner detection before resetting counters in `ProcessNextTerm`:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();
    CountMissedTimeSlots();
    
    // ADD: Detect evil miners before resetting counters
    if (State.IsMainChain.Value && 
        TryToGetCurrentRoundInformation(out var currentRound) &&
        currentRound.TryToDetectEvilMiners(out var evilMiners))
    {
        foreach (var evilMiner in evilMiners)
        {
            Context.LogDebug(() => $"Evil miner detected at term boundary: {evilMiner}");
            State.ElectionContract.UpdateCandidateInformation.Send(
                new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
        }
    }
    
    // Continue with existing term transition logic...
    Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");
    // ... rest of the method
}
```

Alternatively, implement cumulative cross-term tracking of missed slots to prevent strategic exploitation of term boundaries.

## Proof of Concept

```csharp
[Fact]
public async Task MissedTimeSlots_ResetAtTermBoundary_WithoutDetection()
{
    // Setup: Initialize consensus with 17 miners
    await InitializeContracts();
    
    var maliciousMiner = MissionedECKeyPairs.ValidationDataCenterKeyPairs.First();
    var maliciousMinerPubkey = maliciousMiner.PublicKey.ToHex();
    
    // Step 1: Malicious miner misses 4319 time slots (below threshold of 4320)
    for (int i = 0; i < 4319; i++)
    {
        await BlockMiningService.MineBlockAsync(); // Other miners produce blocks
        // Malicious miner intentionally skips their slots
    }
    
    // Verify missed slots accumulated
    var roundBeforeTerm = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = roundBeforeTerm.RealTimeMinersInformation[maliciousMinerPubkey];
    Assert.True(minerInfo.MissedTimeSlots >= 4319);
    Assert.True(minerInfo.MissedTimeSlots < 4320); // Below threshold
    
    // Step 2: Term transition occurs
    await BlockMiningService.MineBlockToNextTermAsync();
    
    // Step 3: Verify counter was reset without detection
    var roundAfterTerm = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfoAfterReset = roundAfterTerm.RealTimeMinersInformation[maliciousMinerPubkey];
    
    // VULNERABILITY: Counter reset to 0, miner still active
    Assert.Equal(0, minerInfoAfterReset.MissedTimeSlots);
    Assert.True(roundAfterTerm.RealTimeMinersInformation.ContainsKey(maliciousMinerPubkey));
    
    // Verify miner was NOT marked as evil
    var candidateInfo = await ElectionStub.GetCandidateInformation.CallAsync(
        new StringValue { Value = maliciousMinerPubkey });
    Assert.NotNull(candidateInfo); // Still a valid candidate
    
    // Attacker can repeat this pattern every term indefinitely
}
```

## Notes

The vulnerability stems from an architectural oversight where term transitions (which reset performance counters for a fresh start with potentially new miners) do not incorporate the same evil miner detection logic applied during normal round transitions. This creates an exploitable window where miners can strategically time their poor performance to align with term boundaries, effectively bypassing the intended accountability mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L168-168)
```csharp
        CountMissedTimeSlots();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L105-112)
```csharp
            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L52-55)
```csharp
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```
