# Audit Report

## Title
Extra Block Producer Receives Incorrect Mining Time After Order Swap in BreakContinuousMining

## Summary
When the extra block producer (EBP) is assigned to the last order position, `BreakContinuousMining` swaps orders to prevent continuous mining. However, the EBP's mining time calculation uses `GetExtraBlockMiningTime()`, which retrieves the time based on the highest Order value rather than the `IsExtraBlockProducer` flag, causing the EBP to receive an incorrect time slot after the swap.

## Finding Description

The vulnerability stems from an inconsistency in how the extra block producer is identified versus how its mining time is calculated.

**Method Inconsistency:**

`GetExtraBlockProducerInformation()` identifies the EBP by the `IsExtraBlockProducer` flag: [1](#0-0) 

`GetExtraBlockMiningTime()` calculates the extra block time based on the miner with the highest Order value, not the flag: [2](#0-1) 

**Problematic Code Flow:**

During round generation, after the EBP is assigned based on `CalculateNextExtraBlockProducerOrder()`: [3](#0-2) 

If the EBP has the highest order (last position), `BreakContinuousMining` swaps it with the second-to-last miner: [4](#0-3) 

After the swap:
- The EBP retains `IsExtraBlockProducer = true` but now has `Order = N-1`
- A different miner now has `Order = N` (highest) with `IsExtraBlockProducer = false`

When `ArrangeAbnormalMiningTime` is called (by `TerminateRoundCommandStrategy` via `MiningTimeArrangingService`), it checks if the caller is the EBP using the flag, but returns time calculated for the highest Order: [5](#0-4) 

This mismatch causes the EBP (Order N-1) to receive the time slot calculated for the miner with Order N.

**Validation Impact:**

The `IsCurrentMiner` validation uses the same flawed logic, allowing the EBP to mine at the incorrect time: [6](#0-5) 

## Impact Explanation

**Medium Severity** - This affects consensus protocol correctness:

1. **Timing Confusion**: The EBP receives a mining time that doesn't correspond to its actual position after the order swap, creating inconsistency in the consensus schedule

2. **Round Termination Disruption**: The EBP is responsible for terminating rounds via `TerminateRoundCommandStrategy`. The incorrect timing can delay round transitions as the EBP attempts to mine at the wrong time slot

3. **Time Slot Conflicts**: Two miners may believe they have authority over overlapping time slots - the EBP thinks it should mine at the Order N time (via `GetExtraBlockMiningTime()`), while the actual Order N miner also expects to mine at that time

4. **Consensus Validation Issues**: The validation logic in `IsCurrentMiner` allows the EBP to mine at the time calculated for a different miner's order position, potentially causing block rejection or acceptance confusion

While this doesn't lead to fund theft or complete protocol failure, it directly impacts consensus timing integrity and can cause operational disruption. The system can recover in subsequent rounds, but the timing confusion affects network reliability.

## Likelihood Explanation

**High Likelihood** - This occurs deterministically:

- **Trigger Condition**: Happens automatically whenever `CalculateNextExtraBlockProducerOrder()` calculates the EBP to be at the last order position (Order = minersCount) [7](#0-6) 

- **Probability**: The calculation uses `(signature % minerCount) + 1`, giving approximately uniform distribution. For N miners, probability is 1/N per round

- **Example**: With 17 miners (typical AElf setup), this occurs in ~5.88% of rounds

- **Automatic Trigger**: No attacker action required - happens during normal consensus operation as part of round generation

- **Affected Systems**: Every deployed AElf chain using AEDPoS consensus with multiple miners

## Recommendation

The fix should ensure consistency between EBP identification and time calculation. Two approaches:

**Option 1**: Update `GetExtraBlockMiningTime()` to use the `IsExtraBlockProducer` flag:
```csharp
public Timestamp GetExtraBlockMiningTime()
{
    var extraBlockProducer = RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    return extraBlockProducer.ExpectedMiningTime.AddMilliseconds(GetMiningInterval());
}
```

**Option 2**: Update the `IsExtraBlockProducer` flag when swapping in `BreakContinuousMining`:
```csharp
if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
{
    var lastButOneMinerOfNextRound =
        nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
    
    // Swap orders
    lastButOneMinerOfNextRound.Order = minersCount;
    lastMinerOfNextRound.Order = minersCount.Sub(1);
    
    // Swap times
    var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
    lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
    lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
    
    // Swap EBP flag
    lastButOneMinerOfNextRound.IsExtraBlockProducer = true;
    lastMinerOfNextRound.IsExtraBlockProducer = false;
}
```

**Option 1 is recommended** as it makes the code more robust by always using the flag to identify the EBP, ensuring the two identification methods stay consistent regardless of order changes.

## Proof of Concept

The vulnerability can be demonstrated with a test that:
1. Generates a round where `CalculateNextExtraBlockProducerOrder()` returns the last position
2. Calls `BreakContinuousMining()` which performs the swap
3. Verifies that the EBP (identified by flag) has Order N-1
4. Calls `GetExtraBlockMiningTime()` and confirms it returns time based on Order N miner
5. Calls `ArrangeAbnormalMiningTime()` for the EBP and shows it receives the wrong time slot

The mismatch can be observed by comparing:
- `GetExtraBlockProducerInformation().Order` (returns N-1 after swap)
- The order of the miner whose time is returned by `GetExtraBlockMiningTime()` (returns N)

This demonstrates the EBP receives a mining time that doesn't match its actual position in the round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L26-31)
```csharp
        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-67)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-107)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
