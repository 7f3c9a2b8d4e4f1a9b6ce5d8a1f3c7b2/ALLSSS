### Title
Governance Bypass via Unvalidated ContractAddress in ChangeMethodFeeController

### Summary
The `ChangeMethodFeeController` function in the CrossChain contract fails to validate that the provided `ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker who controls the current method fee controller can provide a malicious contract address that always returns `true` for `ValidateOrganizationExist`, effectively bypassing organization validation and establishing permanent control over method fees outside of governance oversight.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method which validates the new authority through the `CheckOrganizationExist` helper function: [1](#0-0) 

The validation logic calls `ValidateOrganizationExist` on the user-provided `ContractAddress`: [2](#0-1) 

**Root Cause:** The code performs no validation that `input.ContractAddress` is actually a legitimate governance contract. It blindly trusts whatever contract address is provided and calls `ValidateOrganizationExist` on it via `Context.Call`. A malicious contract could implement this method to always return `true`, bypassing the intended organization existence check.

**Why Existing Protections Fail:**
1. The sender authorization check only verifies the caller is the current controller owner, not that the new controller is valid [3](#0-2) 

2. Legitimate governance contracts validate organization existence by checking internal state: [4](#0-3) 

3. However, there is no validation that the contract being called is actually Parliament, Association, or Referendum - any deployed contract with a compatible method signature can be used

4. The same vulnerable pattern exists across all system contracts implementing controller changes: [5](#0-4) 

**Execution Path:**
1. Attacker deploys malicious contract with `ValidateOrganizationExist(Address) returns BoolValue { Value = true }`
2. Attacker (as current controller owner) calls `ChangeMethodFeeController` with `AuthorityInfo { OwnerAddress = attacker_address, ContractAddress = malicious_contract }`
3. `CheckOrganizationExist` calls malicious contract, receives `true`
4. Assertion passes, controller is changed to attacker's direct address
5. Attacker now has permanent control, bypassing governance

### Impact Explanation

**Governance Impact:**
- Complete bypass of governance control over method fees for the CrossChain contract
- Attacker can unilaterally set transaction fees without approval from Parliament/Association/Referendum
- Legitimate governance cannot regain control without chain upgrade or emergency intervention

**Operational Impact:**
- **DoS Attack**: Attacker can set extremely high transaction fees (e.g., 1000000 ELF per transaction) making the contract unusable
- **Spam Enablement**: Attacker can set zero fees, enabling spam attacks on cross-chain operations
- **Fee methods affected**: `ProposeCrossChainIndexing`, `ReleaseCrossChainIndexingProposal`, and other cross-chain operations become manipulable

**Persistence Attack:**
The most severe aspect is converting **temporary governance compromise into permanent control**. If an attacker gains temporary control of the governance organization (e.g., through a 51% attack that lasts only a few blocks), they can use this vulnerability to lock themselves as the permanent controller even after losing governance majority.

**Widespread Pattern:**
This identical vulnerability exists in all system contracts using this pattern:
- Genesis contract: `ChangeContractDeploymentController` and `ChangeCodeCheckController` (controls all contract deployments - CRITICAL)
- MultiToken, Profit, Vote, Treasury, TokenConverter, TokenHolder contracts (all method fee controllers)

### Likelihood Explanation

**Attacker Capabilities Required:**
1. **Must be current controller owner**: Requires either:
   - Controlling the current governance organization through legitimate means
   - Temporarily compromising governance (51% attack, insider compromise)
   - Previous exploit that granted controller access

2. **Must deploy malicious contract**: 
   - Mainchain requires governance approval for contract deployment
   - Sidechains may allow permissionless deployment
   - If attacker already compromised governance, they can deploy contracts

**Attack Complexity:** MEDIUM
- Once preconditions are met, the exploit is straightforward (single transaction)
- No complex state manipulation or race conditions required
- Attack leaves clear on-chain evidence but may not be detected immediately

**Feasibility Conditions:**
- **Realistic Scenario**: Temporary governance compromise (51% attack) seeking to maintain control
- **Economic Rationality**: High for sophisticated attackers seeking persistent access
- **Detection**: Controller changes may be monitored, but malicious contract address may not be immediately identified as illegitimate

**Likelihood Assessment:** MEDIUM-HIGH in governance attack scenarios
While the precondition (being controller owner) represents elevated privileges, this is precisely the scenario where governance persistence attacks are most dangerous - converting temporary control into permanent control represents a fundamental governance failure mode.

### Recommendation

**Code-Level Mitigation:**
Add validation in `CheckOrganizationExist` to verify the contract address is a legitimate system governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a known governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var parliamentAddress = systemContracts[SmartContractConstants.ParliamentContractSystemHashName];
    var associationAddress = systemContracts[SmartContractConstants.AssociationContractSystemHashName];
    var referendumAddress = systemContracts[SmartContractConstants.ReferendumContractSystemHashName];
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid contract address. Must be Parliament, Association, or Referendum."
    );
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply to All Contracts:**
This fix must be applied to all contracts with the same pattern:
- CrossChain contract (MethodFeeController)
- Genesis contract (ContractDeploymentController, CodeCheckController) - PRIORITY
- All other system contracts with MethodFeeController

**Test Cases:**
1. **Negative Test**: Attempt to call `ChangeMethodFeeController` with arbitrary contract address - should fail
2. **Negative Test**: Attempt with system contract that isn't a governance contract (e.g., Token contract) - should fail
3. **Positive Test**: Verify legitimate changes between Parliament, Association, Referendum still work
4. **Integration Test**: Verify controller changes through governance proposals work correctly with validation

### Proof of Concept

**Required Initial State:**
1. CrossChain contract deployed with Parliament as default method fee controller
2. Attacker controls governance organization (or is testing as governance)
3. Malicious contract deployed with:
```csharp
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

**Exploit Steps:**

**Step 1**: Deploy malicious contract (requires governance approval or permissionless deployment)
- Contract implements `ValidateOrganizationExist` returning `true` for any input

**Step 2**: Attacker creates proposal in current controller organization to call `ChangeMethodFeeController`
- Parameters: `AuthorityInfo { OwnerAddress = attackerAddress, ContractAddress = maliciousContractAddress }`

**Step 3**: Proposal is approved and released through governance

**Step 4**: Transaction executes:
- Line 27: Sender validation passes (caller is current controller organization)
- Line 28: `CheckOrganizationExist` calls malicious contract
- Malicious contract returns `BoolValue { Value = true }`
- Line 29: Assertion passes
- Line 31: Controller is changed to attacker's direct address with fake organization

**Expected Result**: Transaction should fail with "Invalid authority input" due to unrecognized governance contract

**Actual Result**: Transaction succeeds, controller is changed to attacker's address with malicious contract, bypassing governance validation

**Success Condition**: 
```csharp
var controller = await CrossChainContractStub.GetMethodFeeController.CallAsync(new Empty());
// controller.OwnerAddress == attackerAddress (bypassing governance)
// controller.ContractAddress == maliciousContractAddress (not a legitimate governance contract)
// Attacker can now call SetMethodFee directly without governance approval
```

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L80-85)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```
