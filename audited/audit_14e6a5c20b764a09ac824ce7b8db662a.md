# Audit Report

## Title
Solitary Miner Detection Bypass via Unvalidated SupposedOrderOfNextRound Manipulation

## Summary
The AEDPoS consensus contract's `SolitaryMinerDetection()` safety mechanism can be bypassed by malicious miners who manipulate the `SupposedOrderOfNextRound` field to zero. This field is calculated correctly by honest node software but is never validated during block processing, allowing attackers to exclude themselves from the mined miners list and circumvent the detection logic designed to prevent consensus monopolization.

## Finding Description

The vulnerability exists in the consensus validation and processing flow for the `UpdateValue` behavior. The attack exploits a missing validation step that should verify the `SupposedOrderOfNextRound` field matches its deterministic calculation.

**Attack Flow:**

1. During block production, `ApplyNormalConsensusData()` correctly calculates `SupposedOrderOfNextRound = GetAbsModulus(signature.ToInt64(), minersCount) + 1` [1](#0-0) 

2. However, the malicious miner controls their node software and can modify this value to 0 in both the consensus header's Round object and the `UpdateValueInput` transaction before broadcasting.

3. During validation, `UpdateValueValidationProvider` only checks `OutValue`, `Signature`, and `PreviousInValue` fields [2](#0-1) , with **no validation** of `SupposedOrderOfNextRound`.

4. The value is blindly copied during `RecoverFromUpdateValue()` [3](#0-2)  and stored directly in contract state during `ProcessUpdateValue()` [4](#0-3) .

5. The `SolitaryMinerDetection()` function relies on `GetMinedMiners()` which filters miners where `SupposedOrderOfNextRound != 0` [5](#0-4) .

6. When the detection logic executes [6](#0-5) , it checks previous rounds using `GetMinedMiners()`. Since the malicious miner set their value to 0, they're excluded from the list, causing the check `minedMiners.Count == 1` to fail (count is 0), and `isAlone` becomes FALSE, bypassing the detection.

## Impact Explanation

**HIGH severity** - This vulnerability breaks a critical consensus safety mechanism:

- **Consensus Monopolization:** A malicious miner can continue producing blocks indefinitely even when they should stop, centralizing block production to a single entity.

- **Safety Mechanism Failure:** The `SolitaryMinerDetection()` is specifically designed to prevent single-miner control during temporary network partitions or miner outages. Bypassing it eliminates this safety guarantee.

- **Network Recovery Prevention:** When legitimate miners return online, the malicious miner continues blocking them from participating, preventing natural network recovery.

- **Decentralization Compromise:** The fundamental AEDPoS assumption of distributed block production is violated, degrading network security to a single point of failure.

## Likelihood Explanation

**MEDIUM-HIGH likelihood:**

- **Attacker Capabilities:** Requires being an existing miner in the miner list, which is achievable through the election process. No special privileges beyond normal miner status are needed.

- **Attack Complexity:** LOW - The attacker only needs to modify their node software to set `SupposedOrderOfNextRound = 0` after the legitimate calculation but before broadcasting. No complex timing, cryptographic attacks, or economic costs are involved.

- **Preconditions:** The attack is most effective when other miners are temporarily offline, which is precisely the scenario the solitary miner detection is designed to protect against, making this a realistic attack surface.

- **Detection:** The manipulation is undetectable through normal consensus validation since no validator checks the field's correctness.

## Recommendation

Add validation in `UpdateValueValidationProvider` to verify that `SupposedOrderOfNextRound` matches the expected deterministic calculation:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation()
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    
    if (minerInRound.Signature == null || !minerInRound.Signature.Value.Any())
        return false;
        
    var expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

Then call this validation in the main validation method before returning success.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test network with multiple miners
2. Taking all miners offline except one malicious miner
3. Modifying the malicious miner's node to set `SupposedOrderOfNextRound = 0` in the Round object after `ApplyNormalConsensusData()` completes
4. Having the malicious miner produce blocks for multiple rounds
5. Bringing legitimate miners back online
6. Observing that `SolitaryMinerDetection()` returns false (not alone) instead of true
7. Confirming the malicious miner continues producing blocks indefinitely

The test would verify that:
- `GetMinedMiners()` returns an empty list for rounds where the malicious miner set the value to 0
- `SolitaryMinerDetection()` incorrectly evaluates to false
- The malicious miner is never stopped by the `InvalidConsensusCommand` that should be returned

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-27)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```
