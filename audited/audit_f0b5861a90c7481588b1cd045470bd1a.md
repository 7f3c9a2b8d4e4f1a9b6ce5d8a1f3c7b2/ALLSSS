### Title
Wildcard Allowance Bypass via Hierarchical Fallback Allows Exceeding Approved Limits

### Summary
The `GetAllowance` method in `TokenContract_NFT_Actions.cs` implements a hierarchical fallback mechanism for wildcard allowances (specific → collection wildcard → global wildcard), but fails to consume insufficient intermediate allowances. When a more specific wildcard (e.g., "ABC-*") is insufficient but a less specific wildcard (e.g., "*") is sufficient, the transaction uses the global wildcard while leaving the collection wildcard unconsumed. This allows spenders to transfer the sum of all wildcard levels instead of the maximum, violating the intended allowance semantics and enabling token theft.

### Finding Description

The vulnerability exists in the interaction between `DoTransferFrom` and the private `GetAllowance` method. [1](#0-0) [2](#0-1) 

**Root Cause:**

In `GetAllowance`, when processing NFT transfers, the method checks allowances in this order:
1. Specific symbol allowance (e.g., "ABC-1")
2. NFT collection wildcard (e.g., "ABC-*") via `GetNftCollectionAllSymbolAllowance`
3. Global wildcard (e.g., "*") via `GetAllSymbolAllowance`

The critical flaw occurs at lines 110-112: when the collection wildcard is checked and found insufficient (line 111 condition fails), the code continues to check the global wildcard (line 112) and returns that if sufficient. Crucially, the `allowanceSymbol` out parameter is updated to "*", causing line 94 in `DoTransferFrom` to deduct only from the global wildcard, leaving the collection wildcard completely untouched.

**Why Protections Fail:**

The `GetAvailableAllowance` view method clearly indicates the design intent: [3](#0-2) 

This method uses `Math.Max` (lines 80, 83) to compute the maximum available allowance across all levels, proving that allowances should NOT be additive. However, the private `GetAllowance` implementation doesn't enforce this invariant - it simply finds the first sufficient allowance and ignores all others, even when intermediate allowances could be partially consumed.

### Impact Explanation

**Direct Fund Impact:**
A spender can transfer more tokens than the owner intended to approve. If an owner approves both "ABC-*" = X and "*" = Y where X < Y, the spender can transfer a total of X + Y tokens instead of the intended max(X, Y).

**Concrete Example:**
- Owner approves Spender with "ABC-*" = 20 tokens (collection-specific)
- Owner approves Spender with "*" = 1000 tokens (global)
- Intended maximum: 1000 tokens
- Actual exploitable: 1020 tokens (20 excess)

**Attack Sequence:**
1. Spender transfers 50 of "ABC-1" repeatedly, consuming the "*" allowance (1000 total)
2. After "*" is depleted, Spender transfers 20 of "ABC-1", now consuming "ABC-*"
3. Total transferred: 1020 tokens vs. intended 1000 tokens

**Severity: CRITICAL**
- Breaks core allowance enforcement invariant
- Enables direct token theft from any user who approves multiple wildcard levels
- Affects all NFT collections where users set both collection-specific and global wildcards
- No authorization required beyond standard approval mechanisms

### Likelihood Explanation

**Reachable Entry Point:**
Standard public methods are used: `Approve` and `TransferFrom`. No special privileges required. [4](#0-3) 

**Feasible Preconditions:**
Users can legitimately approve multiple wildcard levels. The `AssertApproveToken` validation explicitly allows wildcard patterns: [5](#0-4) 

The system supports "*" (global wildcard) and "PREFIX-*" (collection wildcard) patterns, and users may set both to manage different authorization levels.

**Execution Practicality:**
The exploit requires only:
1. Victim approves multiple wildcard levels (legitimate use case)
2. Attacker calls `TransferFrom` with amounts that strategically consume allowances

**Attack Complexity:** LOW - straightforward transaction sequence with no timing requirements or special conditions.

**Economic Rationality:** Highly favorable - attacker gains tokens at zero cost except gas fees.

### Recommendation

**Code-Level Mitigation:**

Modify the `GetAllowance` method to properly handle insufficient intermediate allowances. When a more specific allowance is found but insufficient, it should either:

**Option 1 (Preferred):** Consume the most specific available allowance first, then fall back:
```
For NFTs transferring amount N:
- If "ABC-1" allowance >= N: use "ABC-1"
- Else if "ABC-*" allowance > 0: use min("ABC-*", N), then recurse for remainder
- Else if "*" allowance >= N: use "*"
```

**Option 2:** Treat wildcard allowances as truly global - when using "*" for "ABC-1", deduct from both "*" AND "ABC-*" if both exist.

**Option 3:** Prevent setting multiple overlapping wildcard levels by adding validation in `Approve` that checks for existing broader wildcards.

**Invariant Checks to Add:**
1. After `TransferFrom`, assert that the sum of all wildcard allowances doesn't exceed the originally approved maximum
2. In `GetAllowance`, track and consume all checked allowances, not just the final selected one

**Test Cases to Prevent Regression:**
1. Set "ABC-*" = 20, "*" = 1000, verify total transferable is 1000, not 1020
2. Set "ABC-*" = 1000, "*" = 20, verify collection wildcard is preferred
3. Set "ABC-1" = 50, "ABC-*" = 20, "*" = 1000, verify specific allowance is used first
4. Partially consume "*", then verify "ABC-*" cannot be used for amounts already covered by "*"

### Proof of Concept

**Required Initial State:**
- Alice owns 1020 tokens of NFT collection "ABC" (e.g., multiple "ABC-1" tokens)
- Bob is the spender

**Transaction Steps:**

1. Alice approves Bob: `Approve(symbol: "ABC-*", spender: Bob, amount: 20)`
   - State: `Allowances[Alice][Bob]["ABC-*"] = 20`

2. Alice approves Bob: `Approve(symbol: "*", spender: Bob, amount: 1000)`
   - State: `Allowances[Alice][Bob]["*"] = 1000`

3. Bob calls `TransferFrom(from: Alice, to: Bob, symbol: "ABC-1", amount: 50)` repeatedly 20 times
   - Each call: GetAllowance checks "ABC-1" (0) → checks "ABC-*" (20, insufficient for 50) → checks "*" (sufficient)
   - Each deduction: `Allowances[Alice][Bob]["*"] -= 50`
   - After 20 calls: `Allowances[Alice][Bob]["*"] = 0`, `Allowances[Alice][Bob]["ABC-*"] = 20` (unchanged)
   - Total transferred: 1000

4. Bob calls `TransferFrom(from: Alice, to: Bob, symbol: "ABC-1", amount: 20)`
   - GetAllowance checks "ABC-1" (0) → checks "ABC-*" (20, sufficient for 20)
   - Deduction: `Allowances[Alice][Bob]["ABC-*"] = 0`
   - Total transferred: 1020

**Expected Result:** 
Transaction in step 4 should fail with "Insufficient allowance" because the global wildcard of 1000 should already cover all transfers.

**Actual Result:** 
Transaction succeeds. Bob transfers 1020 tokens total despite Alice intending to approve maximum 1000 via the global wildcard.

**Success Condition:** 
Bob's balance increases by 1020, exceeding the intended 1000 maximum, proving the vulnerability allows bypassing allowance limits through unconsumed intermediate wildcards.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L64-87)
```csharp
    public override GetAllowanceOutput GetAvailableAllowance(GetAllowanceInput input)
    {
        var result = new GetAllowanceOutput
        {
            Symbol = input.Symbol,
            Owner = input.Owner,
            Spender = input.Spender,
        };
        var symbol = input.Symbol;
        var allowance = State.Allowances[input.Owner][input.Spender][symbol];
        if (CheckSymbolIdentifier(symbol))
        {
            result.Allowance = allowance;
            return result;
        }
        var symbolType = GetSymbolType(symbol);
        allowance = Math.Max(allowance, GetAllSymbolAllowance(input.Owner,input.Spender,out _));
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            allowance = Math.Max(allowance, GetNftCollectionAllSymbolAllowance(input.Owner, input.Spender, symbol, out _));
        }
        result.Allowance = allowance;
        return result;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L261-268)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        AssertValidInputAddress(input.Spender);
        var actualSymbol = GetActualTokenSymbol(input.Symbol);
        AssertValidApproveTokenAndAmount(actualSymbol, input.Amount);
        Approve(input.Spender, actualSymbol, input.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L54-74)
```csharp
    private void AssertApproveToken(string symbol)
    {
        Assert(!string.IsNullOrEmpty(symbol), "Symbol can not be null.");
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var symbolPrefix = words[0];
        var allSymbolIdentifier = GetAllSymbolIdentifier();
        Assert(symbolPrefix.Length > 0 && (IsValidCreateSymbol(symbolPrefix) || symbolPrefix.Equals(allSymbolIdentifier)), "Invalid symbol.");
        if (words.Length == 1)
        {
            if (!symbolPrefix.Equals(allSymbolIdentifier))
            {
                ValidTokenExists(symbolPrefix);
            }
            return;
        }
        Assert(words.Length == 2, "Invalid symbol length.");
        var itemId = words[1];
        Assert(itemId.Length > 0 && (IsValidItemId(itemId) || itemId.Equals(allSymbolIdentifier)), "Invalid NFT Symbol.");
        var nftSymbol = itemId.Equals(allSymbolIdentifier) ? GetCollectionSymbol(symbolPrefix) : symbol;
        ValidTokenExists(nftSymbol);
    }
```
