### Title
Unverified Secret Sharing Data Allows Malicious Miners to Poison Consensus Random Number Generation

### Summary
The `PerformSecretSharing` function accepts decrypted secret pieces and revealed InValues from miners without cryptographic verification that they correspond to the actual encrypted pieces. A malicious miner can submit arbitrary decrypted values and directly manipulate other miners' PreviousInValue, corrupting the consensus random number generation chain and breaking the integrity of the secret sharing protocol.

### Finding Description

**Vulnerable Code Location:**

The vulnerability exists in the `PerformSecretSharing` function: [1](#0-0) 

**Root Cause:**

The function blindly trusts three critical fields from `UpdateValueInput` without verification:

1. **DecryptedPieces (lines 291-293)**: The function adds decrypted pieces to OTHER miners' records without verifying they were correctly decrypted from the corresponding encrypted pieces.

2. **MinersPreviousInValues (lines 295-296)**: The function directly sets PreviousInValue for other miners without any validation.

The input structure allows miners to submit these unverified fields: [2](#0-1) 

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates the submitting miner's own PreviousInValue through hash verification: [3](#0-2) 

This validation **does not** check:
- Whether DecryptedPieces correspond to EncryptedPieces
- Whether MinersPreviousInValues are legitimately revealed secrets
- Any cryptographic proof of correct decryption

**Execution Path:**

1. Malicious miner calls `UpdateValue` with poisoned data: [4](#0-3) 

2. The poisoned DecryptedPieces are later used in `RevealSharedInValues` to reconstruct secrets: [5](#0-4) 

3. The Shamir Secret Sharing reconstruction blindly accepts the poisoned inputs: [6](#0-5) 

**Contrast with Off-Chain Verification:**

The off-chain `SecretSharingService` properly decrypts and verifies pieces using cryptographic operations: [7](#0-6) 

However, the on-chain contract has no mechanism to verify that the submitted data matches the off-chain computed values.

### Impact Explanation

**Concrete Harm:**

1. **Random Number Generation Corruption**: The consensus protocol relies on InValues for generating random numbers used in miner selection and other consensus operations. The random number is verified via VRF: [8](#0-7) 

However, the underlying InValue chain can be poisoned, undermining the randomness foundation.

2. **Signature Chain Disruption**: Consensus signatures are calculated based on PreviousInValue. Corrupted values break signature verification and consensus integrity.

3. **Secret Sharing Protocol Failure**: The entire security model of Shamir Secret Sharing assumes honest majority. However, even a single malicious miner can poison multiple other miners' decrypted pieces and revealed secrets, requiring far fewer colluding miners to break the protocol.

**Quantified Impact:**
- **Affected Parties**: All miners in the current and subsequent rounds
- **Protocol Damage**: Complete breakdown of consensus random number unpredictability
- **Attack Multiplier**: One malicious miner can poison N-1 other miners' data

**Severity Justification**: HIGH - This directly undermines a critical consensus invariant (correct round transitions and randomness integrity) and can lead to consensus manipulation, unfair miner selection, and potential double-spending risks if block production order becomes predictable.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner (already in the miner list)
- Requires no special privileges beyond normal block production rights
- Can execute attack during any UpdateValue transaction

**Attack Complexity:**
- **LOW**: Simply modify the `decrypted_pieces` and `miners_previous_in_values` fields in UpdateValueInput to arbitrary values
- No cryptographic breaking required
- No need to compromise other miners' private keys

**Feasibility Conditions:**
- Secret sharing must be enabled: [9](#0-8) 

- Attacker must be scheduled to produce blocks (normal miner operation)

**Detection Constraints:**
- **Hard to detect**: Off-chain monitoring would need to independently decrypt all pieces and compare with submitted values
- No on-chain events or logs indicate invalid decryption
- Silent corruption of consensus data

**Probability Assessment**: HIGH - Any malicious miner can execute this attack trivially during normal block production with near certainty of success.

### Recommendation

**Immediate Mitigation:**

1. **Add Cryptographic Verification for DecryptedPieces:**
   - Store a commitment (hash) of encrypted pieces when they are first submitted
   - When decrypted pieces are submitted, verify they can be re-encrypted to match the original commitment
   - Alternative: Use verifiable decryption schemes (e.g., proof of correct decryption)

2. **Validate MinersPreviousInValues:**
   - Before accepting direct InValue revelations via `miners_previous_in_values`, verify that Hash(InValue) equals the stored OutValue from the previous round
   - Add check similar to existing PreviousInValue validation but for OTHER miners:
   ```
   foreach (var previousInValue in input.MinersPreviousInValues)
   {
       if (previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
       {
           var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
           Assert(HashHelper.ComputeFrom(previousInValue.Value) == expectedOutValue, 
                  "Invalid revealed InValue");
       }
   }
   ```

3. **Cross-Verify DecryptedPieces:**
   - When sufficient miners submit decrypted pieces for the same encrypted piece, cross-verify consistency
   - Only accept pieces if they can successfully reconstruct a secret that matches the expected PreviousInValue hash

**Invariant Checks to Add:**
- For each miner M and their revealed InValue: `Hash(M.PreviousInValue) == M.OutValue_from_previous_round`
- For each decrypted piece D from miner A for miner B's secret: `Re-encrypt(D, B.PublicKey) == B.EncryptedPieces[A]` (if feasible)

**Test Cases:**
1. Test that UpdateValue with arbitrary DecryptedPieces is rejected
2. Test that UpdateValue with wrong MinersPreviousInValues (not matching OutValue) is rejected
3. Test that legitimate secret sharing still works after validation is added
4. Test that reconstruction fails gracefully with poisoned pieces detected

### Proof of Concept

**Initial State:**
- Miners A, B, C are in the current miner list
- Round N has completed with each miner having submitted their OutValue
- Secret sharing is enabled
- Miner A's OutValue in round N = Hash(InValue_A) = 0x1234...
- Miner C's OutValue in round N = Hash(InValue_C) = 0x5678...

**Attack Steps:**

**Step 1**: Malicious Miner B produces block in round N+1 with UpdateValue transaction containing:
```
UpdateValueInput {
  out_value: Hash(B.newInValue),  // Legitimate
  signature: B.signature,          // Legitimate
  previous_in_value: B.InValue_from_round_N,  // Legitimate (passes self-check)
  decrypted_pieces: {
    "A": 0xDEADBEEF...,  // ARBITRARY - does not correspond to A's encrypted piece
    "C": 0xCAFEBABE...,  // ARBITRARY - does not correspond to C's encrypted piece
  },
  miners_previous_in_values: {
    "A": 0x9999...,  // ARBITRARY - Hash does NOT equal 0x1234... (A's real OutValue)
    "C": 0x8888...,  // ARBITRARY - Hash does NOT equal 0x5678... (C's real OutValue)
  }
}
```

**Step 2**: Contract executes `PerformSecretSharing`:
- Line 290: Adds B's encrypted pieces (not relevant to attack)
- Lines 291-293: Stores arbitrary decrypted pieces in A and C's records:
  - `round.RealTimeMinersInformation["A"].DecryptedPieces["B"] = 0xDEADBEEF...`
  - `round.RealTimeMinersInformation["C"].DecryptedPieces["B"] = 0xCAFEBABE...`
- Lines 295-296: **Directly overwrites** A and C's PreviousInValue:
  - `round.RealTimeMinersInformation["A"].PreviousInValue = 0x9999...`
  - `round.RealTimeMinersInformation["C"].PreviousInValue = 0x8888...`

**Step 3**: Later, when NextRound is triggered, `RevealSharedInValues` is called:
- Attempts to reconstruct A's InValue using poisoned decrypted pieces (including 0xDEADBEEF from B)
- `DecodeSecret` produces garbage value
- Garbage becomes A's PreviousInValue (if not already set by Step 2)

**Expected vs Actual Result:**

**Expected**: 
- DecryptedPieces should be verified to correspond to encrypted pieces
- MinersPreviousInValues should satisfy: Hash(value) == OutValue_from_previous_round
- Invalid values should cause transaction to fail

**Actual**:
- ✅ Transaction succeeds
- ✅ Arbitrary decrypted pieces are stored
- ✅ Arbitrary PreviousInValues are written
- ❌ No validation performed
- ❌ Consensus random number chain is corrupted

**Success Condition**: After the attack, querying `GetRoundInformation` for round N+1 shows that miners A and C have incorrect PreviousInValue that do not satisfy `Hash(PreviousInValue) == OutValue_from_round_N`, yet the transaction was accepted and processed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-257)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** protobuf/aedpos_contract.proto (L209-216)
```text
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L127-138)
```csharp
            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }
```
