### Title
Parliament Vote Multiplication via Multiple Admin Addresses Controlling Individual Managed Pubkeys

### Summary
An attacker who controls multiple admin addresses, where each address manages exactly one parliament member's pubkey through the Election contract, can vote multiple times on the same proposal by submitting transactions from different addresses. The existing check only prevents a single admin address from managing multiple pubkeys, but does not prevent multiple admin addresses (controlled by the same entity) from each managing one pubkey.

### Finding Description

**Root Cause**: The Parliament contract's `GetAndCheckActualParliamentMemberAddress()` function only validates that a single admin address does not manage more than one pubkey, but fails to prevent an attacker from controlling multiple distinct admin addresses, each managing exactly one parliament member's pubkey. [1](#0-0) 

The check at line 132-133 throws an exception only if `managedPubkey.Value.Count > 1`, meaning a single address managing multiple pubkeys is blocked. However, this does not prevent the following scenario:

1. Attacker controls addresses `addr_X`, `addr_Y`, and `addr_Z`
2. Parliament member Bob sets `addr_X` as his admin via Election contract's `SetCandidateAdmin`
3. Parliament member Charlie sets `addr_Y` as his admin
4. Parliament member David sets `addr_Z` as his admin [2](#0-1) 

The Election contract allows each candidate to independently set their admin, with no restriction preventing different candidates from choosing admin addresses controlled by the same entity. The `ManagedCandidatePubkeysMap` tracks which pubkeys each admin manages: [3](#0-2) 

**Exploitation Path**: When voting on a proposal, the attacker submits multiple transactions:

Transaction 1 (from `addr_X`):
- `Approve()` is called with `Context.Sender = addr_X`
- `GetAndCheckActualParliamentMemberAddress()` returns Bob's address (derived from his pubkey)
- `AssertProposalNotYetVotedByMember()` checks if Bob's address has voted - it hasn't
- Bob's address is added to `proposal.Approvals` [4](#0-3) 

Transaction 2 (from `addr_Y`):
- Same process, but resolves to Charlie's address
- Charlie's address is added to `proposal.Approvals`

Transaction 3 (from `addr_Z`):
- Same process, resolves to David's address
- David's address is added to `proposal.Approvals`

The vote counting logic treats these as three separate valid votes because each resolved to a different parliament member address: [5](#0-4) 

The `AssertProposalNotYetVotedByMember()` check only verifies that each specific parliament member address hasn't voted yet, not that multiple votes are from admins controlled by the same entity: [6](#0-5) 

### Impact Explanation

**Governance Manipulation**: This vulnerability allows an attacker to artificially inflate vote counts on parliament proposals, potentially:
- Forcing proposals to reach approval thresholds they shouldn't meet
- Blocking proposals by inflating rejection/abstention counts
- Manipulating the outcome of critical governance decisions including treasury releases, contract upgrades, consensus parameter changes, and cross-chain configurations

**Quantified Impact**: If an attacker controls admin addresses for N parliament members:
- They can cast N votes on any proposal instead of their legitimate 1 vote
- With default thresholds (66.67% approval required), controlling 3 out of 21 miners gives ~14% voting power instead of ~4.8%, potentially swinging close votes
- In the worst case, if an attacker controls admins for a majority of parliament members, they gain complete control over governance

**Severity**: Critical - this directly violates the governance invariant that each parliament member should cast exactly one vote per proposal. The multiplied votes are counted as legitimate by the threshold calculation logic.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Control multiple distinct addresses (trivial - anyone can generate addresses)
2. Convince or compromise parliament members to set the attacker's different addresses as their admins

**Feasibility Analysis**:
- **Medium-High Likelihood**: In practice, parliament members often delegate admin authority to trusted entities or organizations. A large organization running multiple validator nodes could legitimately have different admin addresses for operational reasons, making this setup appear normal.
- The Election contract's `SetCandidateAdmin` allows each candidate to freely choose their admin with no cross-validation between candidates
- No on-chain mechanism exists to verify that multiple admin addresses aren't controlled by the same entity
- Detection is difficult as transactions appear legitimate (each uses a different address managing exactly one pubkey)

**Attack Complexity**: Low
- No complex timing requirements
- No economic cost beyond transaction fees
- Simple transaction submission from multiple controlled addresses
- Works on any parliament proposal

**Economic Rationality**: Highly rational for high-value governance decisions (e.g., treasury withdrawals, protocol parameter changes)

### Recommendation

**Immediate Mitigation**:
Implement admin address uniqueness enforcement in the Election contract's `SetCandidateAdmin` function:

```csharp
public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
{
    // Existing checks...
    
    // NEW: Ensure the new admin isn't already managing other candidates
    var existingManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin];
    if (existingManagedPubkeys != null && existingManagedPubkeys.Value.Any())
    {
        Assert(existingManagedPubkeys.Value.Count == 1 && 
               existingManagedPubkeys.Value.First().ToHex() == pubkey,
               "Admin address already manages other candidates.");
    }
    
    // Continue with existing logic...
}
```

**Alternative Mitigation** (Parliament contract):
Track all admin addresses that have voted on a proposal and prevent duplicates:

```csharp
public override Empty Approve(Hash input)
{
    var actualSender = Context.Sender; // Store original sender
    var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
    
    // NEW: If voting via admin, ensure this admin hasn't voted on this proposal
    if (actualSender != parliamentMemberAddress)
    {
        Assert(!proposal.AdminVoters.Contains(actualSender), 
               "This admin address has already voted on this proposal.");
        proposal.AdminVoters.Add(actualSender);
    }
    
    // Existing logic...
}
```

**Test Cases**:
1. Test that setting an admin address that already manages another candidate is rejected
2. Test that attempting to vote twice using different admin addresses fails
3. Test that legitimate admin delegation still works (one admin per candidate)

### Proof of Concept

**Initial State**:
- Parliament has members: Bob (pubkey_B, addr_B), Charlie (pubkey_C, addr_C), David (pubkey_D, addr_D), and 18 others
- Proposal P requires 66.67% approval (14 out of 21 members)
- Attacker Alice controls addresses: addr_X, addr_Y, addr_Z

**Setup Phase**:
1. Bob calls `Election.SetCandidateAdmin({ Pubkey: pubkey_B, Admin: addr_X })`
   - Result: `State.ManagedCandidatePubkeysMap[addr_X] = [pubkey_B]`
2. Charlie calls `Election.SetCandidateAdmin({ Pubkey: pubkey_C, Admin: addr_Y })`
   - Result: `State.ManagedCandidatePubkeysMap[addr_Y] = [pubkey_C]`
3. David calls `Election.SetCandidateAdmin({ Pubkey: pubkey_D, Admin: addr_Z })`
   - Result: `State.ManagedCandidatePubkeysMap[addr_Z] = [pubkey_D]`

**Exploitation Phase** (Proposal P with 12 legitimate approvals, needs 2 more):
1. Alice submits transaction from addr_X calling `Parliament.Approve(proposalId_P)`
   - `GetAndCheckActualParliamentMemberAddress()` returns addr_B
   - addr_B added to `proposal.Approvals`
   - Count: 13 approvals

2. Alice submits transaction from addr_Y calling `Parliament.Approve(proposalId_P)`
   - `GetAndCheckActualParliamentMemberAddress()` returns addr_C
   - addr_C added to `proposal.Approvals`
   - Count: 14 approvals

3. Alice submits transaction from addr_Z calling `Parliament.Approve(proposalId_P)`
   - `GetAndCheckActualParliamentMemberAddress()` returns addr_D
   - addr_D added to `proposal.Approvals`
   - Count: 15 approvals

**Result**:
- **Expected**: Proposal requires 14 votes, has 12 + attacker's 1 legitimate vote = 13 (should NOT pass)
- **Actual**: Proposal has 12 + 3 multiplied votes = 15 approvals (PASSES threshold)
- **Success Condition**: `IsReleaseThresholdReached()` returns true, proposal can be released and executed

The attacker successfully manipulated the vote count by 200%, enabling unauthorized proposal execution.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L112-140)
```csharp
    private Address GetAndCheckActualParliamentMemberAddress()
    {
        var currentParliament = GetCurrentMinerList();

        if (currentParliament.Any(r => r.Equals(Context.Sender))) return Context.Sender;

        if (State.ElectionContract.Value == null)
        {
            var electionContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
            if (electionContractAddress == null)
                // Election Contract not deployed - only possible in test environment.
                throw new AssertionException("Unauthorized sender.");

            State.ElectionContract.Value = electionContractAddress;
        }

        var managedPubkey = State.ElectionContract.GetManagedPubkeys.Call(Context.Sender);
        if (!managedPubkey.Value.Any()) throw new AssertionException("Unauthorized sender.");

        if (managedPubkey.Value.Count > 1)
            throw new AssertionException("Admin with multiple managed pubkeys cannot handle proposal.");

        var actualMemberAddress = Address.FromPublicKey(managedPubkey.Value.Single().ToByteArray());
        if (!currentParliament.Any(r => r.Equals(actualMemberAddress)))
            throw new AssertionException("Unauthorized sender.");

        return actualMemberAddress;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L190-199)
```csharp
    private void AssertProposalNotYetVotedByMember(ProposalInfo proposal, Address parliamentMemberAddress)
    {
        Assert(!CheckProposalAlreadyVotedBy(proposal, parliamentMemberAddress), "Already approved.");
    }

    private bool CheckProposalAlreadyVotedBy(ProposalInfo proposal, Address address)
    {
        return proposal.Approvals.Contains(address) || proposal.Rejections.Contains(address) ||
               proposal.Abstentions.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```
