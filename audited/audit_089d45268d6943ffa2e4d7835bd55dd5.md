### Title
Invalid Behaviour Enum Bypass Enables Consensus State Freeze and Chain DOS

### Summary
A malicious miner can craft blocks with invalid/undefined `AElfConsensusBehaviour` enum values (e.g., 999) to bypass recovery logic and behaviour-specific validations. This prevents consensus state updates while still allowing blocks to be committed, enabling a single miner to produce unlimited continuous blocks and completely stall consensus progression, effectively DOSing the entire chain.

### Finding Description

The vulnerability exists in the `ValidateBeforeExecution` method where enum-based recovery and validation logic can be bypassed with invalid enum values. [1](#0-0) 

When `extraData.Behaviour` contains an invalid/undefined enum value (e.g., 5, 999, or any value outside the defined 0-4 range), both conditional recovery statements evaluate to false, causing:
1. **Recovery Skip**: `RecoverFromUpdateValue` and `RecoverFromTinyBlock` are never called, leaving `baseRound` unmodified from its state-fetched value
2. **Validation Provider Skip**: The switch statement at lines 77-92 has no matching case for invalid values, so behaviour-specific validators (UpdateValueValidationProvider, LibInformationValidationProvider, NextRoundMiningOrderValidationProvider, RoundTerminateValidationProvider) are never added to the validation provider list [2](#0-1) 

The protobuf enum definition shows only five valid values (0-4), but protobuf parsers accept any integer value without error: [3](#0-2) 

During transaction generation, invalid behaviour values hit the default case and return an empty transaction list: [4](#0-3) 

With no consensus transaction generated, `ProcessConsensusInformation` never executes, preventing critical state updates: [5](#0-4) 

Specifically, `ResetLatestProviderToTinyBlocksCount` is never called, so the continuous block counter never decrements: [6](#0-5) 

The `ContinuousBlocksValidationProvider` relies on this state being updated to prevent excessive continuous blocks: [7](#0-6) 

Similarly, `TimeSlotValidationProvider` checks `ActualMiningTimes` from the unmodified `BaseRound`, which never gets updated: [8](#0-7) 

### Impact Explanation

**Consensus DOS and Chain Halt:**
- A malicious miner can produce unlimited consecutive blocks within their time slot by repeatedly using invalid behaviour values
- Each block passes basic validation (mining permission, time slot, continuous blocks) because state is never updated to reflect previous blocks
- The consensus state (rounds, terms, LIB heights) never advances, freezing all consensus progression
- Other miners cannot produce blocks as the malicious miner fills all available slots
- Chain becomes completely non-functional as consensus mechanisms are disabled

**Bypass of Critical Security Mechanisms:**
- Continuous block limits bypassed: `LatestPubkeyToTinyBlocksCount` never updated, counter never decrements
- Time slot validation bypassed: `ActualMiningTimes` never recorded in state
- LIB height validation bypassed: `LibInformationValidationProvider` not added for invalid behaviours
- Round/term transition validation bypassed: `RoundTerminateValidationProvider` not added
- UpdateValue data validation bypassed: `UpdateValueValidationProvider` not added

**Severity**: Critical - Complete chain DOS and consensus failure. Single compromised miner can halt entire network indefinitely.

### Likelihood Explanation

**Attack Feasibility: High**

**Entry Point**: Any authorized miner can execute this attack via the block production process, which is a standard miner capability.

**Attack Complexity**: Low
- Attacker needs to be an authorized miner in the current round (normal miner requirement)
- Technical steps: Modify protobuf serialization to set `Behaviour` field to invalid value (e.g., 999)
- No complex timing or coordination required
- Can be executed immediately and repeatedly

**Preconditions**: 
- Attacker controls at least one miner node (realistic for any blockchain with elected/staked miners)
- Miner is in current round's miner list (normal operational state)

**Detection**: Difficult to prevent
- Invalid enum values are accepted by protobuf parsers without error
- Blocks appear valid at the network layer
- No transaction execution occurs, making detection require consensus state monitoring
- Once attack begins, other miners are locked out, making response difficult

**Economic Rationality**: Varies by attacker motivation
- Low cost: Only requires being an existing miner, no additional stake or fees required
- High impact: Complete chain halt affects all users and miners
- Motivations: Competitor attack, ransom, or griefing

### Recommendation

**Immediate Fix**: Add explicit enum validation in `ValidateBeforeExecution`:

```csharp
// In ValidateBeforeExecution, after line 44:
if (extraData.Behaviour != AElfConsensusBehaviour.UpdateValue &&
    extraData.Behaviour != AElfConsensusBehaviour.NextRound &&
    extraData.Behaviour != AElfConsensusBehaviour.NextTerm &&
    extraData.Behaviour != AElfConsensusBehaviour.Nothing &&
    extraData.Behaviour != AElfConsensusBehaviour.TinyBlock)
{
    return new ValidationResult 
    { 
        Success = false, 
        Message = $"Invalid consensus behaviour value: {(int)extraData.Behaviour}" 
    };
}
```

Insert this check at line 45 of `AEDPoSContract_Validation.cs`, before the recovery logic.

**Alternative Approach**: Use a whitelist pattern in the switch statement and return validation failure for the default case.

**Test Cases**:
1. Block with behaviour value 5 (undefined) should fail validation
2. Block with behaviour value 999 should fail validation  
3. Block with behaviour value -1 should fail validation
4. Verify all defined behaviours (0-4) still pass validation correctly

### Proof of Concept

**Initial State**:
- Round 5, miner "MinerA" is authorized and has time slot at blocks 100-110
- `State.LatestPubkeyToTinyBlocksCount.Value` shows "MinerB" with `BlocksCount = 3`
- Current round state has no `ActualMiningTimes` recorded for MinerA in this slot yet

**Attack Sequence**:

**Block 100** (MinerA produces with `Behaviour = 999`):
1. `ValidateConsensusBeforeExecution` called, parses `extraData` with `Behaviour = 999`
2. `ValidateBeforeExecution` line 19: Fetches `baseRound` from state (no ActualMiningTimes for MinerA)
3. Lines 46-50: Both conditions false (`999 != 0` and `999 != 4`), no recovery executed
4. Lines 77-92: Switch has no case for 999, no behaviour-specific validators added
5. Only basic validators run: MiningPermissionValidationProvider (PASS - MinerA is valid), TimeSlotValidationProvider (PASS - no ActualMiningTimes recorded), ContinuousBlocksValidationProvider (PASS - last miner was MinerB)
6. `GenerateTransactionListByExtraData` returns empty `TransactionList` (default case)
7. Block commits with no transaction execution
8. State unchanged: Round, ActualMiningTimes, LatestPubkeyToTinyBlocksCount all remain identical

**Block 101** (MinerA produces with `Behaviour = 999`):
1. `ValidateBeforeExecution` fetches `baseRound` - **STILL** shows no ActualMiningTimes for MinerA (state wasn't updated!)
2. No recovery (same as before)
3. Only basic validators run:
   - MiningPermissionValidationProvider: PASS (MinerA still in list)
   - TimeSlotValidationProvider: PASS (latestActualMiningTime still null/unchanged)
   - ContinuousBlocksValidationProvider: PASS (LatestPubkeyToTinyBlocksCount still shows MinerB)
4. Block commits, no state update

**Blocks 102-N**: Pattern repeats indefinitely

**Expected Result**: Each block after the first should fail validation due to time slot or continuous block limits

**Actual Result**: All blocks pass validation; MinerA produces unlimited continuous blocks; consensus state frozen; other miners unable to participate

**Success Condition**: After 10+ blocks from MinerA with invalid behaviour, verify:
- All blocks committed successfully
- Current round state unchanged from block 99
- `LatestPubkeyToTinyBlocksCount` still shows MinerB
- No other miners able to produce blocks
- Chain effectively halted despite blocks being produced

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** protobuf/aedpos_contract.proto (L321-327)
```text
enum AElfConsensusBehaviour {
    UPDATE_VALUE = 0;
    NEXT_ROUND = 1;
    NEXT_TERM = 2;
    NOTHING = 3;
    TINY_BLOCK = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L135-182)
```csharp
        switch (behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
            case AElfConsensusBehaviour.TinyBlock:
                var minerInRound = round.RealTimeMinersInformation[pubkey.ToHex()];
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateTinyBlockInformation),
                            new TinyBlockInput
                            {
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
                                ProducedBlocks = minerInRound.ProducedBlocks,
                                RoundId = round.RoundIdForValidation,
                                RandomNumber = randomNumber
                            })
                    }
                };
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
            default:
                return new TransactionList();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-87)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }

        var miningInformationUpdated = new MiningInformationUpdated
        {
            // _processingBlockMinerPubkey is set during PreCheck.
            Pubkey = _processingBlockMinerPubkey,
            Behaviour = callerMethodName,
            MiningTime = Context.CurrentBlockTime,
            BlockHeight = Context.CurrentHeight,
            PreviousBlockHash = Context.PreviousBlockHash
        };
        Context.Fire(miningInformationUpdated);
        Context.LogDebug(() => $"Synced mining information: {miningInformationUpdated}");

        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);

        if (TryToGetCurrentRoundInformation(out var currentRound))
            Context.LogDebug(() =>
                $"Current round information:\n{currentRound.ToString(_processingBlockMinerPubkey)}");

        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");

        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();

        // Clear cache.
        _processingBlockMinerPubkey = null;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```
