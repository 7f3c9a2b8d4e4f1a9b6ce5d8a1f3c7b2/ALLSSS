### Title
Token Transfer Callbacks Access Undeclared State Paths Causing Parallel Execution Failures

### Summary
The MultiToken contract supports transfer callbacks similar to ERC777 hooks, where tokens can register callback contracts that are invoked during transfers. However, the `GetResourceInfo` method does not declare state paths for recipient contract modifications that occur during these callbacks. This causes transactions to fail during parallel execution with "Parallel conflict" status and marks the entire TokenContract as non-parallelizable.

### Finding Description

The MultiToken contract implements a callback mechanism for token transfers through the `ExternalInfo` dictionary: [1](#0-0) 

When a token has a transfer callback registered, the `DealWithExternalInfoDuringTransfer` method invokes it via `Context.SendInline()`: [2](#0-1) 

This callback is triggered during the `Transfer` operation: [3](#0-2) 

The critical flaw is in the `GetResourceInfo` implementation for parallel execution. It only declares state paths for the TokenContract itself: [4](#0-3) 

The inline transaction created by `SendInline()` modifies the recipient contract's state, but these state paths are never declared in the parent transaction's `ResourceInfo`. [5](#0-4) 

During parallel execution, the system compares declared paths against actual state accesses: [6](#0-5) 

When transactions access undeclared state paths, they are marked as conflicting and the contract is flagged as non-parallelizable: [7](#0-6) 

Conflicting transactions are marked with `TransactionResultStatus.Conflict`: [8](#0-7) 

These failed transactions' state changes are excluded from the block state: [9](#0-8) 

### Impact Explanation

**Operational Impact - Critical DoS:**
1. Any token transfer involving a token with a registered callback will fail during parallel execution with "Parallel conflict" error
2. Users lose transaction fees for failed transfers
3. The entire TokenContract gets marked as non-parallelizable, forcing all future token operations (for ALL tokens) to execute serially
4. This severely degrades blockchain throughput and increases transaction costs system-wide

**Attack Vector:**
An attacker can create a token with a malicious callback and perform transfers to trigger the non-parallelizable marking. This affects the entire token system, not just the attacker's token.

**Scope:**
- Affects all token transfers for tokens with callbacks (Transfer, TransferFrom, Lock, Unlock operations)
- Cascades to impact ALL token operations once the contract is marked non-parallelizable
- Permanent degradation until contract upgrade or manual intervention

### Likelihood Explanation

**High Likelihood:**
- Entry point is the public `Transfer` method accessible to any user
- Precondition requires only creating a token with ExternalInfo callback (no special permissions needed beyond token creation)
- The callback mechanism is a documented feature, making exploitation straightforward
- No additional economic cost beyond normal token creation and transfer fees
- Automatically triggers during normal token transfer operations

**Detection Difficulty:**
The vulnerability manifests as legitimate "parallel conflict" errors, making it difficult to distinguish from normal execution conflicts. The cascade effect of marking the entire TokenContract non-parallelizable is particularly severe.

### Recommendation

**Immediate Fix:**
Modify `GetResourceInfo` to return `NonParallelizable = true` for transactions involving tokens with callbacks:

1. In `TokenContract_ACS2_StatePathsProvider.cs`, check if the token has `TransferCallbackExternalInfoKey` in its ExternalInfo
2. If callbacks exist, set `resourceInfo.NonParallelizable = true` to indicate the transaction cannot be parallelized
3. This forces serial execution but prevents transaction failures

**Proper Fix:**
Implement a mechanism to declare recipient contract state paths in GetResourceInfo:
1. Parse the callback configuration from token ExternalInfo
2. Determine which state paths the callback will access (requires callback contract introspection or declaration)
3. Include those paths in the WritePaths of the ResourceInfo
4. This allows parallel execution while correctly declaring all state accesses

**Alternative:**
Remove or redesign the callback mechanism to avoid cross-contract state modifications during transfers, or execute callbacks asynchronously outside the transaction's state path scope.

### Proof of Concept

**Setup:**
1. Create a token with ExternalInfo containing `"aelf_transfer_callback"` key pointing to a callback contract
2. The callback contract modifies its own state when invoked

**Execution:**
1. Submit multiple token transfers of this token in a parallel batch
2. Each transfer calls `DealWithExternalInfoDuringTransfer` which invokes the callback via `SendInline()`
3. The callback modifies the callback contract's state (undeclared paths)

**Expected Result:**
Transfers execute successfully with callback state changes applied

**Actual Result:**
- Transactions marked with `TransactionResultStatus.Conflict` 
- Error message: "Parallel conflict"
- State changes discarded
- TokenContract marked as non-parallelizable for future blocks
- All subsequent token operations execute serially, degrading system performance

**Validation:**
Confirmed by documentation stating: "The transaction will be canceled and labeled to 'can not be grouped' when the StatePath mismatchs the method." [10](#0-9)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-38)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L228-237)
```csharp
    public void SendInline(Address toAddress, string methodName, ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = Self,
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L61-71)
```csharp
        foreach (var txnWithResource in txnWithResourceList)
        {
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
            Logger.LogDebug($"Conflict keys:{string.Join(";", actual)}");
            wrongTxnWithResources.Add(txnWithResource);
        }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/ConflictingTransactionsFoundInParallelGroupsEventHandler.cs (L33-49)
```csharp
        var wrongTxWithResources =
            await _conflictingTransactionIdentificationService.IdentifyConflictingTransactionsAsync(
                chainContext, eventData.ExistingSets, eventData.ConflictingSets);

        var wrongTransactionIds = wrongTxWithResources.Select(t => t.Transaction.GetHash()).ToArray();

        var dic = wrongTxWithResources.GroupBy(t => t.Transaction.To)
            .ToDictionary(g => g.Key, g => new NonparallelContractCode
            {
                CodeHash = g.First().TransactionResourceInfo.ContractHash
            });

        await _nonparallelContractCodeProvider.SetNonparallelContractCodeAsync(new BlockIndex
        {
            BlockHash = eventData.BlockHeader.GetHash(),
            BlockHeight = eventData.BlockHeader.Height
        }, dic);
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/LocalParallelTransactionExecutingService.cs (L145-158)
```csharp
    private void ProcessConflictingSets(List<ExecutionReturnSet> conflictingSets)
    {
        foreach (var conflictingSet in conflictingSets)
        {
            var result = new TransactionResult
            {
                TransactionId = conflictingSet.TransactionId,
                Status = TransactionResultStatus.Conflict,
                Error = "Parallel conflict"
            };
            conflictingSet.Status = result.Status;
            conflictingSet.TransactionResult = result;
        }
    }
```

**File:** src/AElf.Kernel.SmartContract/Domain/ExecutionReturnSetCollection.cs (L21-26)
```csharp
        foreach (var returnSet in returnSets)
            if (returnSet.Status == TransactionResultStatus.Mined ||
                returnSet.Status == TransactionResultStatus.Failed)
                Executed.Add(returnSet);
            else if (returnSet.Status == TransactionResultStatus.Conflict) Conflict.Add(returnSet);
    }
```

**File:** docs-sphinx/reference/acs/acs2.rst (L453-454)
```text
Attention: The transaction will be canceled and labeled to “can not be
groupped” when the StatePath mismatchs the method.
```
