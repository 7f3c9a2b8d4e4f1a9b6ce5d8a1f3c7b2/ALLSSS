### Title
State Corruption in InitialProfitSchemeForSideChain Due to Unverified CreateScheme.Send Failure

### Summary
The `InitialProfitSchemeForSideChain` function sets `State.TokenHolderContract.Value` before calling `CreateScheme.Send`, but never verifies that the scheme creation succeeded. If `CreateScheme.Send` fails silently (as AElf's `.Send()` calls are fire-and-forget), the contract enters an inconsistent state where the TokenHolder contract address is set but the profit scheme doesn't exist, causing all subsequent `Donate` and `Release` operations to fail permanently.

### Finding Description

The vulnerability exists in the initialization flow across three contracts:

**In AEDPoSContract:**
The `InitialProfitSchemeForSideChain` function sets the TokenHolder contract address state variable before attempting to create the scheme, with no verification of success: [1](#0-0) 

The critical issue is that line 27 sets `State.TokenHolderContract.Value` unconditionally, then line 28 uses `.Send()` which is a fire-and-forget call that provides no return value or exception on failure.

**In TokenHolderContract:**
The `CreateScheme` method makes a similar pattern error - it calls the ProfitContract's CreateScheme via `.Send()`, then unconditionally sets the TokenHolder's local state: [2](#0-1) 

Note that the `TokenHolderProfitScheme` is created with only `Symbol` and `MinimumLockMinutes` populated (lines 27-32). The critical `SchemeId` and `Period` fields remain null/zero because they should be populated from the ProfitContract's response.

**Failure Detection:**
When `Donate` is subsequently called, it attempts to contribute profits by calling `GetValidScheme`: [3](#0-2) 

The `GetValidScheme` method calls `UpdateTokenHolderProfitScheme` which tries to retrieve the scheme from ProfitContract: [4](#0-3) 

If the scheme was never created in ProfitContract, line 290-293's `GetManagingSchemeIds` returns empty, and the assertion at line 294 fails with "Origin scheme not found."

**Release Function Impact:**
The `Release` function also suffers from this corruption. It calls `GetScheme` which returns the incomplete scheme: [5](#0-4) 

Since the scheme's `Period` was never initialized (remains at default value 0), the calculation `scheme.Period - 1 = -1` at line 108 causes the condition to always evaluate as true, resulting in incorrect release timing logic.

**Root Cause:**
The root cause is the use of `.Send()` for critical initialization operations without any verification mechanism. AElf's `.Send()` method is fire-and-forget and provides no feedback on success or failure, yet the code assumes success and proceeds to set state variables.

### Impact Explanation

**Operational DoS - Side Chain Dividends Pool Permanently Broken:**

1. **All Donations Fail:** Any call to `Donate` will fail with the assertion error "Origin scheme not found" when attempting to contribute profits, preventing users from donating to the side chain dividends pool. [6](#0-5) 

2. **Release Logic Malfunctions:** The `Release` function operates with corrupted state (Period=0), causing incorrect timing calculations and potential failures when attempting to distribute dividends that were never properly tracked.

3. **No Recovery Path:** Once the contract is in this corrupted state during initialization, there is no recovery mechanism. The side chain dividends pool functionality is permanently disabled for the entire chain lifecycle.

4. **Chain Initialization Compromise:** This occurs during chain initialization via `InitialAElfConsensusContract`, affecting the fundamental economic infrastructure of the side chain. [7](#0-6) 

**Severity Justification:** HIGH - This causes permanent operational DoS of a critical economic component (side chain dividends distribution) that cannot be recovered without redeploying the chain.

### Likelihood Explanation

**Realistic Failure Scenarios:**

1. **Resource Exhaustion:** During chain initialization, if the transaction runs out of gas or hits resource limits while executing `CreateScheme.Send`, the operation fails silently.

2. **ProfitContract Assertion Failures:** The ProfitContract's CreateScheme has multiple assertion points that could fail: [8](#0-7) 

The assertion at line 59 could fail if there's a scheme ID collision or if CreateScheme is somehow called multiple times.

3. **Contract State Issues:** If the TokenContract isn't properly initialized when `ValidateContractState` is called (line 46), subsequent operations may fail: [9](#0-8) 

**Probability Assessment:**
While the specific likelihood of CreateScheme failing during normal initialization is low, the vulnerability represents a critical lack of defensive programming. The code makes no attempt to verify success of a critical initialization step, violating basic error handling principles. Any failure (bug in dependent contracts, resource constraints, edge cases in scheme ID generation) would result in permanent chain dysfunction.

**Detection Constraints:**
The failure is silent during initialization - no transaction will revert, no error will be logged. The corruption only becomes apparent when users attempt to interact with the dividends pool post-initialization, at which point it's too late to recover.

### Recommendation

**1. Verify Scheme Creation Success:**

After calling `CreateScheme.Send`, verify that the scheme was actually created by calling `GetScheme` and checking for valid `SchemeId`:

```csharp
private void InitialProfitSchemeForSideChain(long periodSeconds)
{
    var tokenHolderContractAddress =
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName);
    if (tokenHolderContractAddress == null)
    {
        Context.LogDebug(() => "Token Holder Contract not found...");
        return;
    }

    State.TokenHolderContract.Value = tokenHolderContractAddress;
    State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
        MinimumLockMinutes = periodSeconds.Div(60)
    });

    // CRITICAL: Verify scheme was created
    var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
    Assert(scheme != null && scheme.SchemeId != null, 
        "Failed to create side chain dividends pool scheme");

    Context.LogDebug(() => "Side chain dividends pool created.");
}
```

**2. Use Transactional Pattern:**

Consider using `.Call()` instead of `.Send()` where return values indicate success, or implement a two-phase initialization pattern where scheme creation success is verified before setting state.

**3. Add Invariant Checks:**

In `Donate` and `Release` functions, add defensive checks:

```csharp
public override Empty Donate(DonateInput input)
{
    EnsureTokenContractAddressSet();
    
    // Verify scheme exists and is valid
    Assert(State.TokenHolderContract.Value != null, "TokenHolder contract not initialized");
    var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
    Assert(scheme != null && scheme.SchemeId != null, "Side chain dividends scheme not properly initialized");
    
    // ... rest of function
}
```

**4. Test Cases:**

Add regression tests that simulate CreateScheme failures during initialization to ensure proper error handling and state consistency.

### Proof of Concept

**Required Initial State:**
- Side chain initialization in progress
- TokenHolder contract deployed
- ProfitContract deployed but configured to fail CreateScheme (e.g., via mock for testing)

**Transaction Steps:**

1. **Initial State:** Chain initialization begins, `InitialAElfConsensusContract` is called with `IsSideChain = true`

2. **Step 1 - Set TokenHolder Address:** Line 27 executes successfully, `State.TokenHolderContract.Value` is set to the TokenHolder contract address

3. **Step 2 - CreateScheme Fails:** Line 28 calls `CreateScheme.Send` which internally calls ProfitContract.CreateScheme. Assume this fails (e.g., due to "Already exists" assertion or resource limit)

4. **Step 3 - Initialization Completes:** Function returns successfully with no error, contract believes initialization succeeded

5. **Step 4 - User Attempts Donation:** A user calls `Donate` with valid parameters

6. **Expected Result:** Donation succeeds and tokens are added to dividends pool

7. **Actual Result:** Transaction fails at TokenHolderContract.ContributeProfits -> GetValidScheme -> UpdateTokenHolderProfitScheme with assertion error: "Origin scheme not found"

**Success Condition for Exploit:**
The vulnerability is confirmed when `State.TokenHolderContract.Value` is set but subsequent operations fail due to non-existent scheme, demonstrating the contract is in a permanently corrupted state with no recovery path.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L27-32)
```csharp
        State.TokenHolderContract.Value = tokenHolderContractAddress;
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L59-64)
```csharp
        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L105-108)
```csharp
        var scheme = State.TokenHolderContract.GetScheme.Call(Context.Self);
        var isTimeToRelease =
            (Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.PeriodSeconds.Value) > scheme.Period - 1;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-32)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L102-102)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-294)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L35-35)
```csharp
        if (input.IsSideChain) InitialProfitSchemeForSideChain(input.PeriodSeconds);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L46-46)
```csharp
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L51-59)
```csharp
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```
