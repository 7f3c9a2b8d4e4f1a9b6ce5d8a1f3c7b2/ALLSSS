### Title
Threshold Mismatch in Secret Sharing Causes Incorrect InValue Revelation When Miner List Decreases

### Summary
The `RevealSharedInValues()` function uses the current round's miner count to calculate the decoding threshold, but secrets were encoded using the previous round's miner count. When the miner list decreases between rounds, this causes Shamir's Secret Sharing reconstruction to use fewer points than the polynomial degree requires, resulting in incorrect InValue revelation that breaks consensus randomness and security.

### Finding Description

The vulnerability occurs in the threshold calculation mismatch between secret encoding and decoding phases:

**Encoding Phase** (when secrets are created): [1](#0-0) 

The threshold is calculated from `secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count`, which represents the round where the secret is being created.

**Decoding Phase** (when secrets are revealed): [2](#0-1) 

The threshold is calculated from `currentRound.RealTimeMinersInformation.Count`, which may be different from the round where the secret was encoded. [3](#0-2) 

The secret is decoded using `minimumCount` derived from the current round, not the encoding round.

**Root Cause**: When transitioning between rounds with different miner counts, the function retrieves the previous round but calculates the threshold from the current round: [4](#0-3) 

**Why Existing Protections Fail**: The check at line 36 only ensures sufficient decrypted pieces exist (`DecryptedPieces.Count >= minersCount`), but doesn't validate that the decoding threshold matches the encoding threshold: [5](#0-4) 

**Entry Point**: This function is called during round transitions: [6](#0-5) 

### Impact Explanation

**Concrete Harm**: In Shamir's Secret Sharing, using fewer points than the polynomial degree (threshold) results in reconstructing a different polynomial and obtaining an incorrect secret. For example:
- Round 99: 9 miners, secrets encoded with threshold = floor(9 × 2/3) = 6 (degree-5 polynomial)
- Round 100: 3 miners (list decreased), decoding threshold = floor(3 × 2/3) = 2
- Using only 2 points to reconstruct a degree-5 polynomial yields a completely different value

**Protocol Damage**: 
- InValues are critical for consensus randomness (determining miner orders, preventing manipulation)
- Incorrect InValue revelation breaks the cryptographic security guarantees of AEDPoS
- Miners would use wrong InValues for validation, causing consensus failures
- The `PreviousInValue` field would be populated with incorrect data, breaking subsequent round transitions

**Affected Parties**: All miners and the entire consensus mechanism when miner list decreases.

**Severity Justification**: HIGH - Directly compromises consensus integrity, a critical security invariant.

### Likelihood Explanation

**Attacker Capabilities**: No attacker needed - this is a protocol-level bug that triggers automatically during legitimate miner list changes.

**Execution Practicality**: 
- Miner list changes are normal operations in AEDPoS (miner replacement, term transitions)
- The code path is straightforward and occurs during every round transition after a miner count decrease
- No special privileges or preconditions required beyond normal consensus operations

**Feasibility Conditions**:
1. Round N has M miners
2. Round N+1 has fewer miners (M' < M)  
3. When transitioning from N+1 to N+2, secrets from round N are revealed using threshold based on M' instead of M

**Detection**: The mitigation at line 107-108 of `AEDPoSContract_HelpMethods.cs` skips creating NEW secrets when miner list changes, but does NOT skip revealing OLD secrets: [7](#0-6) 

**Probability**: CERTAIN - Occurs automatically whenever miner count decreases between consecutive rounds.

### Recommendation

**Code-Level Mitigation**: Store the encoding threshold with the encrypted pieces or check miner list changes before revelation:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    Context.LogDebug(() => "About to reveal shared in values.");
    
    if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;
    if (!TryToGetPreviousRoundInformation(out var previousRound)) return;
    
    // NEW CHECK: Skip revelation if miner counts differ
    if (currentRound.RealTimeMinersInformation.Count != previousRound.RealTimeMinersInformation.Count)
    {
        Context.LogDebug(() => "Skipping InValue revelation due to miner list count change.");
        return;
    }
    
    // Use previousRound's miner count for threshold calculation
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    var minimumCount = minersCount.Mul(2).Div(3);
    minimumCount = minimumCount == 0 ? 1 : minimumCount;
    
    // ... rest of function
}
```

**Invariant to Add**: Ensure decoding threshold equals encoding threshold by using the source round's miner count.

**Test Cases**: Add tests for secret sharing revelation across rounds with decreasing miner counts (e.g., 9→6→3 miners) and verify InValue correctness.

### Proof of Concept

**Initial State**:
- Round 98: 9 miners active, secrets created with threshold = 6
- Each miner has encrypted/decrypted pieces from all 9 miners

**Exploitation Steps**:
1. Round 99 completes normally with 9 miners
2. Round 100 begins with 3 miners (6 miners removed)
3. Miner A produces block to transition round 100 → 101
4. `GetConsensusExtraDataForNextRound` calls `RevealSharedInValues(currentRound=100, pubkey=A)`
5. Function calculates `minimumCount = floor(3 × 2/3) = 2` from round 100
6. Retrieves round 99 data where secrets were encoded with threshold = 6
7. For miners still active, calls `DecodeSecret(sharedParts, orders, threshold=2)`
8. Lagrange interpolation uses only 2 points to reconstruct degree-5 polynomial

**Expected Result**: InValue should be correctly reconstructed using 6+ points

**Actual Result**: Wrong InValue computed using only 2 points, stored in `PreviousInValue` field

**Success Condition**: Compare revealed InValue against original - they will differ, demonstrating incorrect reconstruction.

### Notes

Note that the original security question asked about `sharedParts.Count != orders.Count` causing issues. My investigation found that both lists are always equal in count since they're derived from the same `DecryptedPieces` dictionary: [8](#0-7) 

Therefore, index out of bounds from count mismatch is NOT possible. However, I identified the more critical threshold mismatch vulnerability described above.

### Citations

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-104)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L19-23)
```csharp
        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-47)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L50-50)
```csharp
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```
