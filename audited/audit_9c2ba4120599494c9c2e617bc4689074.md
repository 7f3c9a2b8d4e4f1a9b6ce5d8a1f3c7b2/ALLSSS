# Audit Report

## Title
Minority Miner Collusion Can Block Term Changes via Strategic Non-Participation in Timestamp Recording

## Summary
The `NeedToChangeTerm` function contains a critical logic flaw where it uses the total miner count as the denominator for the 2/3 consensus threshold but only counts miners who have actually mined blocks in the numerator. This enables >1/3 of colluding miners to indefinitely prevent term changes by refusing to mine, thereby blocking governance-mandated miner rotations.

## Finding Description

The vulnerability exists in the term change detection mechanism. The `NeedToChangeTerm` method determines whether a term change should occur by checking if at least `MinersCountOfConsent` miners have their last mining timestamp cross the term threshold. [1](#0-0) 

The `MinersCountOfConsent` property calculates the required threshold as ⌊totalMiners × 2/3⌋ + 1 using the total number of miners in `RealTimeMinersInformation`: [2](#0-1) 

**Root Cause:** The critical flaw is that `NeedToChangeTerm` filters miners with `.Where(m => m.ActualMiningTimes.Any())`, excluding miners who haven't mined any blocks. This creates a mathematical impossibility: if >1/3 of miners refuse to mine, they won't have `ActualMiningTimes`, making it impossible to reach the 2/3 threshold calculated from the total miner count.

**Concrete Attack Scenario:**
- With 17 total miners: `MinersCountOfConsent = 17 × 2 ÷ 3 + 1 = 12`
- If 6 miners (>1/3) refuse to mine: only 11 miners have `ActualMiningTimes`
- Maximum achievable count: 11 < 12 required
- `NeedToChangeTerm` returns false indefinitely

The consensus behavior provider uses this result to determine whether to trigger `NextTerm` or `NextRound`: [3](#0-2) 

When `NeedToChangeTerm` returns false, the behavior remains `NextRound`, preventing term transitions.

**Why Existing Protections Fail:**

Evil miner detection exists but provides insufficient protection. The threshold for marking miners as evil is 4,320 missed time slots: [4](#0-3) 

This translates to approximately 3 days (60 minutes × 24 hours × 3 days), providing a substantial attack window. Additionally, colluding miners can strategically mine minimal blocks to avoid detection while maintaining sufficient abstention to block term changes. Even when detected, evil miners are only removed during next round generation, after they've already blocked the term change.

## Impact Explanation

**HIGH Severity** - This vulnerability attacks a critical consensus invariant that enables democratic governance in AEDPoS.

**Governance Compromise:** Term changes are the fundamental mechanism for rotating mining power based on election results. Blocking term changes allows incumbent miners to retain exclusive control indefinitely, completely bypassing the election system.

**Quantified Impact:**
- **Timeframe:** Minimum 3-day attack window before evil miner detection triggers
- **Power Retention:** Colluding miners controlling >1/3 positions can prevent any term changes during detection window
- **Economic Impact:** Continued exclusive access to mining rewards (12,500,000 tokens per block initially) that should be distributed to newly elected validators
- **Affected Parties:** All token holders who participated in elections, newly elected miners unable to assume positions, overall network governance integrity

The attack undermines the fundamental trust assumption that election results will be honored, which is critical for a DPoS-based consensus system.

## Likelihood Explanation

**HIGH Likelihood** - The attack is practical and economically rational.

**Attacker Capabilities:** Requires control of >1/3 of current miner positions. With the standard 17-miner configuration, 6+ colluding miners are needed.

**Economic Rationality:** Incumbent miners have strong financial incentive to maintain their positions rather than cede control to elected replacements. Mining rewards provide continuous revenue that incumbents would lose upon term rotation.

**Attack Complexity:** LOW - Execution is trivial:
1. Monitor when `ActualMiningTimes` of miners approach term change threshold
2. Coordinate >1/3 of miners to stop mining
3. Optionally rotate which miners abstain to avoid all being marked as evil simultaneously

**Detection Difficulty:** The attack is indistinguishable from normal network issues or miner downtime for up to 3 days. During this window, term changes remain blocked with no clear on-chain evidence of malicious coordination.

**Feasibility:** PRACTICAL - No sophisticated technical knowledge required beyond simple coordination. The attack can be sustained indefinitely by cycling which miners abstain.

## Recommendation

Modify the `NeedToChangeTerm` logic to base the threshold calculation only on miners who have actually participated in mining, ensuring consistent denominator and numerator:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    var minersWithTimestamps = RealTimeMinersInformation.Values
        .Where(m => m.ActualMiningTimes.Any())
        .ToList();
    
    // Base threshold on actual participants, not total miner list
    var requiredConsent = minersWithTimestamps.Count.Mul(2).Div(3).Add(1);
    
    var countCrossingThreshold = minersWithTimestamps
        .Select(m => m.ActualMiningTimes.Last())
        .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp, t, currentTermNumber, periodSeconds));
    
    return countCrossingThreshold >= requiredConsent;
}
```

Alternatively, implement a maximum term duration that forces term changes regardless of miner participation, or reduce the evil miner detection threshold to limit the attack window.

## Proof of Concept

The following test demonstrates the vulnerability:

```csharp
[Fact]
public async Task TermChangeBlockedByMinorityAbstention()
{
    // Setup: 17 miners, term period = 604800 seconds (7 days)
    var initialMiners = GenerateMinerList(17);
    await InitializeConsensus(initialMiners);
    
    // Simulate 11 miners mining normally throughout the term period
    var activeMinerCount = 11; // 11/17 = 64.7% < 2/3 threshold
    for (int i = 0; i < activeMinerCount; i++)
    {
        await MineBlocksForMiner(initialMiners[i], 100); // Mine past term threshold
    }
    
    // Remaining 6 miners refuse to mine (>1/3 minority)
    // They maintain zero ActualMiningTimes entries
    
    // Advance time past the term change threshold
    await AdvanceTime(TimeSpan.FromDays(8));
    
    // Attempt to get consensus behavior for round termination
    var currentRound = await GetCurrentRound();
    var behaviour = currentRound.NeedToChangeTerm(
        blockchainStartTime, 
        currentTermNumber: 1, 
        periodSeconds: 604800);
    
    // VULNERABILITY: Despite time threshold being crossed and 11 miners 
    // having timestamps past the threshold, NeedToChangeTerm returns false
    // because MinersCountOfConsent = 17 * 2 / 3 + 1 = 12, but only 11 
    // miners have ActualMiningTimes
    Assert.False(behaviour); // Term change blocked!
    
    // Verify consensus behavior remains NextRound instead of NextTerm
    var consensusBehaviour = GetConsensusBehaviour();
    Assert.Equal(AElfConsensusBehaviour.NextRound, consensusBehaviour);
    
    // Term change is indefinitely prevented by minority abstention
}
```

**Notes**

The vulnerability is particularly severe because it requires only minority collusion (>1/3) rather than majority control. The 3-day detection window provides ample time for the attack to succeed, and the rotating abstention strategy allows attackers to sustain the attack indefinitely while avoiding permanent penalties. This fundamentally breaks the governance assumption that elected validators will assume their positions after winning elections.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-35)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
