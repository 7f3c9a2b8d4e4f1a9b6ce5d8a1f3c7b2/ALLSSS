### Title
NFT Type Inconsistency via Unchecked CrossChainCreate Symbol Format

### Summary
The `NFTContract.CrossChainCreate` method extracts NFT type by assuming the first 2 characters of any symbol are a valid type prefix, without validating the symbol format or checking consistency with the token's metadata. Attackers can create tokens via `MultiToken.Create` with arbitrary symbols and NFT metadata keys (which are not validated by the token contract), then call `CrossChainCreate` to register NFT protocols with mismatched type information.

### Finding Description

**Root Cause:**

The NFT contract's `CrossChainCreate` method performs NFT type extraction without proper validation: [1](#0-0) 

This code blindly extracts the first 2 characters of the symbol and maps them to an NFT type, assuming all symbols follow the format generated by the legitimate `Create` method: [2](#0-1) 

The legitimate flow ensures 2-character prefixes via the `AddNFTType` validation: [3](#0-2) 

**Why Protections Fail:**

1. **MultiToken contract doesn't validate NFT metadata keys** - The token contract's reserved keys list excludes NFT-specific keys: [4](#0-3) 

This means NFT-specific constants like `NftTypeMetadataKey` are not protected: [5](#0-4) 

2. **MultiToken.CreateToken accepts arbitrary ExternalInfo** - The CreateToken method directly uses input ExternalInfo without NFT-key validation: [6](#0-5) 

3. **CrossChainCreate has no access control** - Anyone can call this method: [7](#0-6) 

4. **No symbol format validation in CrossChainCreate** - The method doesn't verify that the symbol follows the expected `{2-char prefix}{9+ digit number}` format enforced by `NumberMinLength`: [8](#0-7) 

**Execution Path:**

1. Attacker calls `MultiToken.Create` with:
   - Symbol: "BA123456789" (or any format starting with 2 valid NFT type chars)
   - ExternalInfo: `{"aelf_nft_type": "Art", "aelf_nft_base_uri": "...", "aelf_nft_token_id_reuse": "false"}`
   
2. Token is created successfully with metadata claiming type "Art"

3. Attacker calls `NFTContract.CrossChainCreate` with symbol "BA123456789"

4. CrossChainCreate extracts "BA" → maps to "Badges" (not "Art")

5. NFT protocol is created with `NftType = "Badges"` but token metadata says "Art"

### Impact Explanation

**Data Integrity Violation:**
- NFT protocols are created with type information that contradicts the underlying token's metadata
- The token's `ExternalInfo[NftTypeMetadataKey]` contains one type while the `NFTProtocolInfo.NftType` contains another
- This violates the fundamental invariant that symbol format and metadata must be consistent

**Affected Parties:**
- **Users/dApps** querying protocol info via `GetNFTProtocolInfo` receive incorrect type classification
- **NFT marketplaces** filtering by type may display items in wrong categories
- **Governance** systems relying on NFT type for policy enforcement (if any type-specific rules exist)

**Concrete Harm:**
- Misleading categorization of NFT collections (e.g., "Art" appearing as "Badges")
- Potential bypass of hypothetical type-specific restrictions or policies
- Confusion between on-chain metadata sources leading to inconsistent UI/application behavior
- Loss of trust in NFT type classification system

**Severity: Medium** - While not directly leading to fund loss, this creates data integrity issues that can mislead users and break type-based logic across the ecosystem.

### Likelihood Explanation

**Reachable Entry Point:**
- `MultiToken.Create` - Public method callable by anyone with SEED NFT (or whitelisted addresses)
- `NFTContract.CrossChainCreate` - Public method with no access control

**Attacker Capabilities:**
- Must possess a SEED NFT to create arbitrary tokens (standard requirement)
- No special privileges or compromised keys required
- Basic understanding of contract interfaces

**Attack Complexity:**
- Low - Two simple contract calls
- No timing requirements or race conditions
- No complex state manipulation needed

**Feasibility Conditions:**
- Attacker needs: 1 SEED NFT token (obtainable through normal means)
- Cost: Gas fees + SEED NFT price (economically reasonable)
- Detection: Creates valid tokens and protocols, no anomalous behavior flags

**Probability: High** - The attack is straightforward, requires minimal resources, and leaves the system in a valid but inconsistent state.

### Recommendation

**1. Add Symbol Format Validation in CrossChainCreate:**

In `NFTContract_Create.cs`, add validation before extracting NFT type:
```csharp
// Validate symbol follows expected format: 2-char prefix + numeric suffix
Assert(input.Symbol.Length >= 11, "Invalid NFT protocol symbol length");
var nftTypeShortName = input.Symbol.Substring(0, 2);
var numericPart = input.Symbol.Substring(2);
Assert(long.TryParse(numericPart, out _), "Symbol must have numeric suffix");
```

**2. Add NFT Type Consistency Check:**

Verify that the extracted type matches the token metadata:
```csharp
var metadataType = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
Assert(metadataType == nftTypeFullName, 
    $"NFT type mismatch: metadata={metadataType}, symbol={nftTypeFullName}");
```

**3. Add Access Control to CrossChainCreate:**

Restrict `CrossChainCreate` to authorized cross-chain synchronization addresses:
```csharp
Assert(Context.Sender == State.CrossChainContract.Value || 
       Context.Sender == State.ParliamentDefaultAddress.Value,
       "No permission to cross-chain create NFT protocol");
```

**4. Add NFT Metadata Keys to MultiToken Reserved List:**

Update `TokenContract_Views.cs` to include NFT-specific keys in the reserved list, or add a check in `CreateToken` that rejects NFT metadata keys for non-NFT contract callers.

**5. Regression Test:**

Add test case attempting to create token with mismatched symbol/metadata, then calling `CrossChainCreate` - should fail with appropriate error.

### Proof of Concept

**Initial State:**
- NFT types initialized with standard mappings ("BA" → "Badges", "AR" → "Art")
- Attacker has SEED NFT required for token creation

**Attack Steps:**

1. **Create Malicious Token:**
   ```
   Call: MultiToken.Create
   Parameters:
     Symbol: "BA123456789"
     TokenName: "Art Collection"
     TotalSupply: 10000
     Decimals: 0
     Issuer: AttackerAddress
     ExternalInfo: {
       "aelf_nft_type": "Art",
       "aelf_nft_base_uri": "https://art.example.com/",
       "aelf_nft_token_id_reuse": "false"
     }
   ```
   **Result:** Token created with symbol "BA123456789" and metadata claiming type "Art"

2. **Register NFT Protocol:**
   ```
   Call: NFTContract.CrossChainCreate
   Parameters:
     Symbol: "BA123456789"
   ```
   **Result:** NFT protocol created with:
   - `Symbol: "BA123456789"`
   - `NftType: "Badges"` (extracted from "BA" prefix)
   - But underlying token metadata has: `"aelf_nft_type": "Art"`

3. **Verify Inconsistency:**
   ```
   Call: MultiToken.GetTokenInfo("BA123456789")
   Returns: ExternalInfo["aelf_nft_type"] = "Art"
   
   Call: NFTContract.GetNFTProtocolInfo("BA123456789")
   Returns: NftType = "Badges"
   ```

**Success Condition:** The protocol is created successfully with `NftType` differing from the token's `NftTypeMetadataKey` value, demonstrating the data integrity violation.

**Notes**

This vulnerability arises from the separation of concerns between the MultiToken and NFT contracts without proper interface validation. The `CrossChainCreate` method was designed for legitimate cross-chain synchronization where tokens created via `NFTContract.Create` on mainchain get registered on sidechains. However, the lack of format validation and access control allows it to be abused with tokens created directly via the MultiToken contract. The `NumberMinLength` constant correctly ensures proper format in the legitimate flow, but this protection is bypassed when tokens are created through the alternate path.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-75)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L136-136)
```csharp
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-7)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```
