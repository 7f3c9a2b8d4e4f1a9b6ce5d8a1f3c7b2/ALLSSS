### Title
Governance Bypass via Zero Division Equivalent in Parliament Threshold Calculation

### Summary
When the consensus contract's miner list is empty (count = 0), the Parliament contract's threshold validation logic evaluates `0 >= 0` as TRUE, allowing proposals to be released and executed without any actual votes. This completely bypasses the governance voting mechanism, enabling any authorized proposer to execute their proposals unilaterally when consensus round information is unavailable.

### Finding Description

The vulnerability exists in the threshold calculation logic within `CheckEnoughVoteAndApprovals()` and related validation functions. [1](#0-0) 

The root cause is that when `parliamentMembers.Count` is zero, the approval threshold check becomes:
- `approvedMemberCount * AbstractVoteTotal >= MinimalApprovalThreshold * 0`
- Which evaluates to `0 >= 0` â†’ **TRUE**

Similarly, the vote threshold check in `IsVoteThresholdReached()` also passes: [2](#0-1) 

The rejection and abstention checks both evaluate to FALSE (since `0 > 0` is false), so they don't block the proposal: [3](#0-2) 

The empty miner list originates from the consensus contract, which returns an empty `MinerList` when `TryToGetCurrentRoundInformation` fails: [4](#0-3) 

This occurs when either `State.CurrentRoundNumber.Value` is 0 or the round data at `State.Rounds[roundNumber]` is empty: [5](#0-4) 

The Parliament contract retrieves this empty list without any validation: [6](#0-5) 

The vulnerability is triggered when `Release()` is called, which uses `IsReleaseThresholdReached()` to validate the proposal: [7](#0-6) 

### Impact Explanation

**Critical Governance Bypass**: This vulnerability allows complete circumvention of the Parliament voting mechanism, which is a fundamental security control in AElf's governance system.

**Concrete Harm**:
1. Any authorized proposer can execute their proposals without any miner votes
2. Critical system changes (contract upgrades, parameter modifications, treasury operations) can be performed unilaterally
3. The entire Parliament governance model is rendered ineffective during consensus state issues
4. Multi-signature security guarantees are completely bypassed

**Who is Affected**: 
- All organizations managed by the Parliament contract
- The default Parliament organization that governs system contracts
- The emergency response organization
- Any cross-contract operations that rely on Parliament approval

**Severity Justification**: This violates the critical invariant that "Organization thresholds must be enforced for all proposal executions." The AbstractVoteTotal constant of 10000 is designed to ensure percentage-based thresholds, but with zero members, all math degenerates to `0 >= 0`. [8](#0-7) 

### Likelihood Explanation

**Attacker Capabilities Required**:
- Must be an authorized proposer (whitelist member, parliament member, or default organization)
- Ability to create and monitor proposals
- Timing to call Release() during consensus state unavailability

**Attack Complexity**: Low - Single transaction call to `Release()` when conditions are met

**Feasibility Conditions**: The consensus state becomes unavailable when:
1. **During consensus contract upgrades**: When migrating to a new consensus contract version, there may be periods where round information is not yet initialized
2. **After chain initialization issues**: If consensus isn't fully set up post-genesis
3. **Consensus state corruption**: Bugs in consensus contract that clear or corrupt round data
4. **Deliberate DoS on consensus**: If an attacker can cause consensus to fail to update rounds

**Probability Assessment**: Medium-High
- Consensus contract upgrades occur periodically in production chains
- The window may be brief but predictable during planned upgrades
- An attacker can pre-create proposals and monitor for the vulnerability window
- No additional privileges beyond proposer status are required

### Recommendation

**Immediate Fix**: Add explicit validation that the miner list is not empty before performing threshold calculations.

Add this check at the beginning of `IsReleaseThresholdReached()`:
```csharp
private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
{
    var parliamentMembers = GetCurrentMinerList();
    Assert(parliamentMembers.Count > 0, "Parliament members list cannot be empty.");
    // ... rest of existing logic
}
```

**Additional Safeguards**:
1. Add similar validation in `IsProposalStillPending()` to prevent false status reporting
2. Consider adding a minimum miner count requirement in the consensus contract initialization
3. Implement safeguards during consensus contract upgrades to maintain round continuity
4. Add logging when miner list queries return empty results for monitoring

**Test Cases to Add**:
1. Test `Release()` behavior when consensus returns empty miner list (should fail with clear error)
2. Test proposal status queries with zero miners
3. Test voting functions (`Approve`, `Reject`, `Abstain`) with empty miner list
4. Integration test for consensus contract upgrade scenarios

### Proof of Concept

**Initial State**:
1. Parliament contract is initialized with default organization
2. Consensus contract is operating normally with N miners
3. Proposer creates a valid proposal targeting a critical system function (e.g., token minting, parameter change)

**Attack Sequence**:
1. **Proposal Creation** (Normal Operation):
   - Proposer calls `CreateProposal()` with malicious parameters
   - Proposal is created successfully with ID = P1
   
2. **Wait for Vulnerability Window**:
   - Monitor for consensus contract upgrade or state corruption
   - Detect when `GetCurrentMinerList()` returns empty list
   - This can be verified by querying `GetCurrentRoundInformation()` which would return empty Round

3. **Exploit Execution**:
   - Proposer calls `Release(P1)`
   - `IsReleaseThresholdReached()` is called with empty miner list
   - `IsProposalRejected()`: returns false (0 > 0 is false)
   - `IsProposalAbstained()`: returns false (0 > 0 is false)  
   - `CheckEnoughVoteAndApprovals()`: returns true (0 >= 0 is true)
   - `IsVoteThresholdReached()`: returns true (0 >= 0 is true)
   - Result: Proposal executes WITHOUT any votes

**Expected vs Actual Result**:
- **Expected**: Proposal should fail with "Not approved" or "Invalid parliament state"
- **Actual**: Proposal executes successfully, bypassing all threshold checks

**Success Condition**: The proposal's target transaction executes (e.g., tokens are minted, parameters are changed) despite zero parliament members having voted on it.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-78)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L94-102)
```csharp
    private bool IsVoteThresholdReached(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-144)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```
