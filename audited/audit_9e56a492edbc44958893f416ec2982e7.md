# Audit Report

## Title
Missing Symbol Validation in CreateScheme Allows Creation of Unusable TokenHolder Profit Schemes

## Summary
The `CreateScheme` function in TokenHolderContract fails to validate the input symbol, allowing creation of schemes with invalid or non-existent token symbols. When users attempt to register for profits, the transaction fails during token locking, rendering the scheme permanently unusable and wasting transaction fees.

## Finding Description
The TokenHolder contract's `CreateScheme` method directly stores the input symbol without any validation. [1](#0-0) 

The input is defined as a simple string field with no built-in validation. [2](#0-1) 

When users call `RegisterForProfits`, the function retrieves the scheme and attempts to lock tokens using the stored (unvalidated) symbol. [3](#0-2) 

The MultiToken contract's `Lock` method performs validation that will fail if the symbol is empty, whitespace, or refers to a non-existent token. [4](#0-3) 

The `AssertValidToken` helper method checks symbol format and token existence, throwing an assertion error if the token is not found. [5](#0-4) 

The validation chain includes checking for empty strings and valid symbol format. [6](#0-5) 

**Root Cause**: Input validation is deferred to the Lock operation rather than being performed upfront in CreateScheme. Once a scheme is created with an invalid symbol, it cannot be modified or corrected since no update mechanism exists.

**Security Guarantee Broken**: The protocol should prevent creation of permanently non-functional infrastructure. By allowing invalid schemes to be created, users are led into a trap where they waste gas attempting to interact with unusable schemes.

## Impact Explanation
**Permanent Operational DoS**: Schemes created with invalid symbols become permanently unusable. All attempts to call `RegisterForProfits` will fail with assertion errors from the Lock method's validation. Since there is no `UpdateScheme` or `ModifyScheme` method (confirmed via code search), the scheme cannot be corrected once created.

**Resource Waste**: Users attempting to register for profits with invalid schemes will pay transaction fees for failed transactions. The failure occurs after initial validation passes but before the transaction completes, meaning gas is consumed despite the inevitable failure.

**Ecosystem Impact**: 
- Scheme managers who accidentally use invalid symbols (typos, premature creation before token deployment) lose their ability to run functional profit distribution schemes
- Users who attempt to participate waste gas fees on guaranteed-to-fail registration attempts
- The ecosystem accumulates broken infrastructure that appears valid when queried but fails in practice

**Severity: Medium** - While this does not enable fund theft or system-wide failures, it creates a permanent DoS condition for individual schemes and wastes user resources. The impact is significant because schemes are a key part of the profit distribution infrastructure and cannot be fixed once broken.

## Likelihood Explanation
**Public Entry Point**: The `CreateScheme` method is a public RPC with no special authorization requirements. [7](#0-6) 

**No Preconditions**: Any address can create a scheme for themselves as the manager. The transaction sender automatically becomes the scheme manager, requiring no special permissions or prior setup.

**Trivial to Trigger**: The vulnerability can occur through multiple simple scenarios:
- Empty string: `CreateScheme({Symbol: ""})`
- Typo: `CreateScheme({Symbol: "EFL"})` instead of `"ELF"`
- Non-existent token: `CreateScheme({Symbol: "FUTURE_TOKEN"})` before the token is created
- Invalid format: `CreateScheme({Symbol: "ABC-XYZ-123"})`

**Detection Difficulty**: The issue only becomes apparent when users attempt to register. The scheme appears valid when queried via `GetScheme`, making it difficult for users to detect the problem before attempting registration and wasting gas.

**Probability: Medium** - While not economically rational as a targeted attack (scheme managers harm their own schemes), it is highly likely to occur through honest mistakes, especially in environments with multiple custom tokens or during development/testing phases that transition to production.

## Recommendation
Add symbol validation to the `CreateScheme` method to fail fast before storing invalid data:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation
    Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid token symbol: empty or whitespace.");
    
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    // Verify token exists before creating scheme
    var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = input.Symbol 
    });
    Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), 
           $"Token not found: {input.Symbol}");
    
    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

This ensures that schemes can only be created with valid, existing tokens, preventing the creation of permanently unusable infrastructure.

## Proof of Concept

```csharp
[Fact]
public async Task CreateScheme_WithInvalidSymbol_CausesRegisterForProfits_ToFail()
{
    // Create a scheme with an invalid (non-existent) symbol
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "INVALID_TOKEN", // Token does not exist
        MinimumLockMinutes = 100
    });

    // Verify the scheme was created (but is broken)
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    scheme.Symbol.ShouldBe("INVALID_TOKEN");
    
    // Attempt to register for profits - this will fail
    var result = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            Amount = 100,
            SchemeManager = Starter
        });
    
    // Verify failure occurs during Lock with token validation error
    result.TransactionResult.Error.ShouldContain("Token is not found");
}
```

---

**Notes**: This vulnerability affects the TokenHolder contract's profit distribution mechanism. The validation gap between scheme creation and token locking creates a window for invalid schemes to be stored permanently. While the MultiToken contract properly validates tokens during the Lock operation, this defensive programming is insufficient when CreateScheme allows invalid data to be stored in the first place. The issue is compounded by the immutability of schemes once created.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-165)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** protobuf/token_holder_contract.proto (L19-21)
```text
    // Create a scheme for distributing bonus.
    rpc CreateScheme (CreateTokenHolderProfitSchemeInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L195-207)
```csharp
    public override Empty Lock(LockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Lock behaviour should be initialed by origin address.");

        var allowance = State.Allowances[input.Address][Context.Sender][input.Symbol];
        if (allowance >= input.Amount)
            State.Allowances[input.Address][Context.Sender][input.Symbol] = allowance.Sub(input.Amount);
        AssertValidToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
