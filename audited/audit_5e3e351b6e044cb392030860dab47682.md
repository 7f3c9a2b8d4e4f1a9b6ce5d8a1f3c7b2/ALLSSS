# Audit Report

## Title
VoteId Collision Leading to Permanent Token Lock and Vote Record Corruption

## Summary
The VoteContract generates VoteId without including the VotingItemId, using only the transaction origin and the voting item's VotesAmount counter. When multiple votes on different voting items with identical VotesAmount values occur within the same transaction, they produce the same VoteId, causing the second vote to overwrite the first vote's record while tokens accumulate in the same virtual address. This results in permanent token lock for the overwritten vote amount and corrupted voting state.

## Finding Description

The vulnerability exists in the VoteId generation mechanism within the `AssertValidVoteInput` method. [1](#0-0) 

The VoteId is computed using `Context.GenerateId`, which concatenates the OriginTransactionId, contract address, and the VotesAmount counter. [2](#0-1) 

**Critical Flaw**: The VoteId does NOT include the VotingItemId. Each voting item maintains its own independent VotesAmount counter, retrieved via a hash that includes the VotingItemId. [3](#0-2) 

When two different voting items have the same VotesAmount value and both votes occur in the same transaction (sharing the same OriginTransactionId), they generate identical VoteIds.

**Why Protections Fail:**

1. **No Collision Detection**: The Vote method directly overwrites VotingRecords without checking for existing entries. [4](#0-3) 

   Unlike the Election contract which has explicit collision protection. [5](#0-4) 

2. **Lock Accumulation**: The token contract's Lock mechanism computes a virtual address deterministically from the sender, user address, and LockId. [6](#0-5) 

   When the same LockId (VoteId) is used twice, tokens accumulate in the same virtual address without error.

3. **Shared OriginTransactionId**: All inline calls within a transaction share the same OriginTransactionId, enabling the collision.

**Execution Path:**

1. Attacker deploys a contract that calls `VoteContract.Vote.Send()` twice within the same method
2. First vote on Item A (VotesAmount = X) generates VoteId = Hash(TxId + Contract + X), locks 100 tokens
3. Second vote on Item B (VotesAmount = X) generates identical VoteId, locks 200 tokens to same virtual address
4. Second vote overwrites `State.VotingRecords[VoteId]`, only Item B record survives
5. Virtual address contains 300 tokens total, but only 200 tokens can be unlocked based on surviving record
6. 100 tokens remain permanently locked

## Impact Explanation

**Direct Fund Loss:**
Tokens from the overwritten vote become permanently locked in the virtual address. The surviving VotingRecord only tracks the second vote's amount. [7](#0-6) 

The Unlock method can only withdraw the amount specified in the surviving VotingRecord. [8](#0-7) 

**Example Scenario:**
- Vote 1: 100 tokens on Item A (VotesAmount = 0) → VoteId = Hash(Tx + Contract + 0)
- Vote 2: 200 tokens on Item B (VotesAmount = 0) → VoteId = Hash(Tx + Contract + 0)
- Virtual address receives 300 tokens total
- Only VotingRecord for Item B (200 tokens) exists
- Withdrawal unlocks 200 tokens
- **100 tokens permanently locked**

**Vote Record Corruption:**
The first vote's record is completely lost, causing incorrect vote tallies for Item A. The VotedItemsMap is updated for both items, [9](#0-8)  but only one VotingRecord exists, creating state inconsistency.

**Severity: HIGH** - Direct financial loss with permanent token lock, no recovery mechanism, and corruption of core voting functionality.

## Likelihood Explanation

**Attacker Capabilities:**
- Standard user permissions (no privileged access required)
- Ability to deploy a contract with multiple Vote calls
- Ability to identify voting items with matching VotesAmount

**Attack Complexity: LOW**

1. Identify two voting items with `IsLockToken = true` that have identical VotesAmount values (newly registered items start with VotesAmount = 0)
2. Deploy a contract that makes two `VoteContract.Vote.Send()` calls in sequence
3. Execute transaction - collision occurs automatically

**Feasibility Conditions:**
- **Common scenario**: Newly registered voting items all start with VotesAmount = 0
- **Inline transactions supported**: AElf's SendInline allows multiple Vote calls in one transaction
- **No restrictions**: Any user can vote on multiple items

**Probability: MEDIUM-HIGH** - Preconditions are easily achievable, attack is technically straightforward, and can occur accidentally with legitimate multi-voting contracts.

## Recommendation

Add collision detection in the `AssertValidVoteInput` method before generating the VoteId:

```csharp
input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
Assert(State.VotingRecords[input.VoteId] == null, "Vote already exists.");
```

Alternatively, include the VotingItemId in the VoteId generation to ensure uniqueness:

```csharp
input.VoteId = Context.GenerateId(Context.Self, 
    HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(votingItem.VotingItemId),
        HashHelper.ComputeFrom(votingResult.VotesAmount)
    ).Value);
```

## Proof of Concept

```csharp
[Fact]
public async Task VoteIdCollision_PermanentTokenLock()
{
    // Setup: Create two voting items with VotesAmount = 0
    var itemA = await CreateVotingItem("ItemA");
    var itemB = await CreateVotingItem("ItemB");
    
    // Deploy malicious contract that votes twice in same transaction
    var maliciousContract = await DeployMaliciousVoter();
    
    // Execute: Vote 100 on ItemA and 200 on ItemB in same transaction
    await maliciousContract.VoteTwice(itemA, 100, itemB, 200);
    
    // Verify collision occurred
    var voteIdA = GenerateExpectedVoteId(0); // VotesAmount = 0
    var voteIdB = GenerateExpectedVoteId(0); // VotesAmount = 0
    Assert.Equal(voteIdA, voteIdB); // Same VoteId!
    
    // Verify only one record exists (ItemB overwrote ItemA)
    var record = await VoteContract.GetVotingRecord(voteIdA);
    Assert.Equal(itemB, record.VotingItemId);
    Assert.Equal(200, record.Amount);
    
    // Verify virtual address has 300 tokens total
    var virtualAddr = ComputeVirtualAddress(voteIdA);
    var balance = await TokenContract.GetBalance(virtualAddr);
    Assert.Equal(300, balance);
    
    // Attempt withdrawal - only 200 tokens unlocked
    await VoteContract.Withdraw(voteIdA);
    
    // Verify 100 tokens permanently locked
    var remainingLocked = await TokenContract.GetBalance(virtualAddr);
    Assert.Equal(100, remainingLocked); // PERMANENT LOCK
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L224-231)
```csharp
        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L368-375)
```csharp
    private Hash GetVotingResultHash(Hash votingItemId, long snapshotNumber)
    {
        return new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = snapshotNumber
        }.GetHash();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L392-397)
```csharp
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L139-145)
```csharp
    public Hash GenerateId(Address contractAddress, IEnumerable<byte> bytes)
    {
        var contactedBytes = OriginTransactionId.Value.Concat(contractAddress.Value);
        var enumerable = bytes as byte[] ?? bytes?.ToArray();
        if (enumerable != null)
            contactedBytes = contactedBytes.Concat(enumerable);
        return HashHelper.ComputeFrom(contactedBytes.ToArray());
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L433-433)
```csharp
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-242)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        Context.SendVirtualInline(fromVirtualAddress, Context.Self, nameof(Transfer), new TransferInput
        {
            To = input.Address,
            Symbol = input.Symbol,
            Amount = input.Amount,
            Memo = input.Usage
        });
```
