# Audit Report

## Title
Incorrect Backup Miner Limit Causes Consensus to Operate with Fewer Miners Than Configured

## Summary
The `GetVictories` function in the Election contract uses an incorrect upper bound when selecting backup miners, limiting selection to `currentMiners.Count` instead of the available `backups` list size. This causes the consensus to operate with fewer validators than the governance-configured `MinersCount` when valid candidates are insufficient, undermining network security and governance authority.

## Finding Description

The vulnerability exists in the backup miner selection logic when there are insufficient valid candidates (candidates with votes > 0) to fill the required `MinersCount` positions. [1](#0-0) 

The root cause is at line 72, where the code uses `Math.Min(diff, currentMiners.Count)` to limit backup selection:

**The Logic Flow:**
1. Calculate how many additional miners are needed: `diff = State.MinersCount.Value - validCandidates.Count`
2. Build a `backups` list containing current miners (filtered) plus initial miners (filtered), which can be larger than `currentMiners.Count`
3. Select backups using `.Take(Math.Min(diff, currentMiners.Count))`

**The Bug:**
The code limits backup selection to `currentMiners.Count`, but this is semantically incorrect because:
- The `backups` list may contain more entries than `currentMiners.Count` (includes InitialMiners)
- `diff` represents how many miners we need, not how many current miners exist
- This causes the system to return fewer miners than `State.MinersCount.Value` requires

**Why Protections Fail:**
The consensus contract accepts whatever miner list is returned without validation: [2](#0-1) 

The `GenerateFirstRoundOfNewTerm` method creates a consensus round with whatever miners are provided, without checking if the count matches expectations. [3](#0-2) 

The `SetMinerList` method stores the miner list without count validation: [4](#0-3) 

## Impact Explanation

**Concrete Scenario:**
- Governance increases `MinersCount` to 7 (via consensus contract's `UpdateMinersCount`)
- Only 2 candidates have votes (low participation period)
- Current miner count is 3
- The system calculates: `diff = 7 - 2 = 5` (need 5 more miners)
- Backups available: 3 filtered current miners + 5 filtered initial miners = 8 potential backups
- Bug causes: `Math.Min(5, 3) = 3` backups selected
- Result: Returns only 5 total miners (2 valid + 3 backups) instead of required 7 [5](#0-4) 

**Protocol Impact:**
1. **Consensus Security Degradation**: Operating with 5 miners instead of 7 reduces Byzantine fault tolerance from tolerating 2 malicious nodes to only 1
2. **Governance Violation**: The `MinersCount` parameter set by consensus contract is silently ignored
3. **Network Stability Risk**: Fewer validators increases vulnerability to node failures
4. **Performance Impact**: Longer mining intervals per validator reduces throughput

## Likelihood Explanation

**Triggering Conditions:**
1. `MinersCount` has been increased through governance (natural network growth)
2. Valid candidate count is insufficient: `validCandidates.Count < MinersCount` (occurs during low participation)
3. Current miner count is less than needed backups: `currentMiners.Count < diff` (some miners have left/been replaced)
4. Sufficient `InitialMiners` available (always true as they persist)

**Execution Path:**
The consensus contract automatically calls `GetVictories` during term transitions: [6](#0-5) 

This occurs naturally during consensus operation without any attacker action required. The bug manifests silently - the system continues operating but with reduced validator count, undermining the network's security guarantees.

## Recommendation

Fix the backup selection limit to use the actual `backups` list size instead of `currentMiners.Count`:

**Change line 72 from:**
```csharp
.Take(Math.Min(diff, currentMiners.Count))
```

**To:**
```csharp
.Take(diff)
```

Or if defensive programming is preferred:
```csharp
.Take(Math.Min(diff, backups.Count))
```

The `backups` list is already constructed to contain all available backup miners, so the limit should reflect what's available in that list or simply take what's needed (`diff`).

## Proof of Concept

The existing test suite demonstrates the bug indirectly - test cases for insufficient valid candidates don't verify the total returned miner count matches `MinersCount`: [7](#0-6) 

This test at line 441 only verifies that valid candidates are included, but doesn't check if `victories.Count == MinersCount` as it should.

A proper PoC would:
1. Set `MinersCount` to 7 via `UpdateMinersCount`
2. Have only 2 valid candidates with votes
3. Ensure `currentMiners.Count` is 3
4. Ensure sufficient `InitialMiners` exist (e.g., 5)
5. Call `GetVictories`
6. Assert that the returned count is 7, not 5

The bug causes this assertion to fail, proving the consensus operates with fewer miners than configured.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** test/AElf.Contracts.Election.Tests/GQL/ElectionTests.cs (L404-444)
```csharp
    public async Task<List<string>> ElectionContract_GetVictories_ValidCandidatesNotEnough_Test()
    {
        const int amount = 100;

        await NextRound(BootMinerKeyPair);

        foreach (var keyPair in ValidationDataCenterKeyPairs) await AnnounceElectionAsync(keyPair);

        var candidates = (await ElectionContractStub.GetCandidates.CallAsync(new Empty())).Value;
        foreach (var fullNodesKeyPair in ValidationDataCenterKeyPairs)
            candidates.ShouldContain(ByteString.CopyFrom(fullNodesKeyPair.PublicKey));

        var validCandidates = ValidationDataCenterKeyPairs
            .Take(EconomicContractsTestConstants.InitialCoreDataCenterCount - 1).ToList();
        foreach (var keyPair in validCandidates)
            await VoteToCandidateAsync(VoterKeyPairs[0], keyPair.PublicKey.ToHex(), 100 * 86400, amount);

        foreach (var votedFullNodeKeyPair in ValidationDataCenterKeyPairs.Take(EconomicContractsTestConstants
                     .InitialCoreDataCenterCount - 1))
        {
            var votes = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue
                { Value = votedFullNodeKeyPair.PublicKey.ToHex() });
            votes.ObtainedActiveVotedVotesAmount.ShouldBe(amount);
        }

        foreach (var votedFullNodeKeyPair in ValidationDataCenterKeyPairs.Skip(EconomicContractsTestConstants
                     .InitialCoreDataCenterCount - 1))
        {
            var votes = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue
                { Value = votedFullNodeKeyPair.PublicKey.ToHex() });
            votes.ObtainedActiveVotedVotesAmount.ShouldBe(0);
        }

        var victories = (await ElectionContractStub.GetVictories.CallAsync(new Empty())).Value
            .Select(p => p.ToHex()).ToList();

        // Victories should contain all valid candidates.
        foreach (var validCandidate in validCandidates) victories.ShouldContain(validCandidate.PublicKey.ToHex());

        return victories;
    }
```
