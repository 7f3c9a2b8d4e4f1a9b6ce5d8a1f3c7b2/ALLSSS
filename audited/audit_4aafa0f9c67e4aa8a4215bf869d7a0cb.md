# Audit Report

## Title
Insufficient Validation of PreviousInValue for Non-Sender Miners Allows Consensus State Corruption

## Summary
The AEDPoS consensus contract validates `PreviousInValue` only for the block producer (sender), but not for other miners whose values are included in the block header. A malicious miner can inject arbitrary `PreviousInValue` values for other miners through the `revealed_in_values` field in trigger information, corrupting consensus state and violating the VRF commit-reveal invariant that `Hash(PreviousInValue) == OutValue_previous_round`.

## Finding Description

The vulnerability exists across the consensus data flow where `PreviousInValue` for all miners is propagated without comprehensive validation.

**Injection Point:** In `UpdateLatestSecretPieces()`, a miner can set arbitrary `PreviousInValue` for other miners via the `revealed_in_values` field from trigger information: [1](#0-0) 

The condition only checks if the target miner's `PreviousInValue` is currently empty, which is common for miners who haven't produced blocks yet in the current round.

**Propagation to Block Header:** The injected values are copied into the simplified round that goes into the block header: [2](#0-1) 

**Recovery Without Validation:** During validation, ALL miners' `PreviousInValue` are copied from the block header to the base round: [3](#0-2) 

**Validation Gap:** The validation provider only validates the sender's `PreviousInValue`: [4](#0-3) 

Line 38 explicitly limits validation to `publicKey = validationContext.SenderPubkey`, leaving other miners' values unverified.

**Additional Injection via Transaction Input:** During execution, `PerformSecretSharing()` directly sets `PreviousInValue` from the transaction input without validation: [5](#0-4) 

**Usage of Corrupted Values:** The corrupted `PreviousInValue` is later used to calculate signatures for miners who didn't produce blocks: [6](#0-5) 

If the `PreviousInValue` is corrupted, the calculated signature will be wrong, violating the VRF invariant.

## Impact Explanation

**Consensus Integrity Violation:** The vulnerability breaks the fundamental VRF (Verifiable Random Function) invariant that `Hash(PreviousInValue) == OutValue_previous_round`. A malicious miner can inject `PreviousInValue` values that do NOT hash to the corresponding miner's `OutValue` from the previous round.

**Concrete Harm:**

1. **Signature Corruption**: For miners who miss their time slots, the incorrect `PreviousInValue` is used to calculate their signature through `previousRound.CalculateSignature(previousInValue)`. The signature calculation aggregates all miners' signatures, so corruption propagates: [7](#0-6) 

2. **Secret Sharing Compromise**: The incorrect values propagate through the secret sharing mechanism via `MinersPreviousInValues` which collects all miners' `PreviousInValue`: [8](#0-7) 

3. **State Persistence**: The corrupted values become part of persistent consensus state, affecting subsequent round calculations and miner ordering.

**Affected Parties:** All network participants relying on consensus integrity, miners whose `PreviousInValue` is corrupted, and the random number generation mechanism used for block production schedules.

## Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the current round can exploit this vulnerability
- No special privileges required beyond normal block production rights
- Attack is launched by providing malicious trigger information to their own consensus node

**Attack Complexity:**
LOW - The attacker simply provides malicious `revealed_in_values` in their `AElfConsensusTriggerInformation`. The trigger information is generated by the miner's own node and can be modified before being passed to the contract.

**Feasibility Conditions:**
- Target miner must have `PreviousInValue == Hash.Empty || PreviousInValue == null` (miners who haven't produced blocks yet in current round)
- Secret sharing must be enabled, which is checked via `IsSecretSharingEnabled()`: [9](#0-8) 

**Detection Constraints:**
- No validation prevents this attack
- Corrupted values appear legitimate in block headers
- Only detectable through forensic analysis comparing `PreviousInValue` hashes with previous round's `OutValue`

**Probability: HIGH** - The attack is straightforward, requires no sophisticated techniques, and bypasses all existing validations.

## Recommendation

Add validation for ALL miners' `PreviousInValue` in `UpdateValueValidationProvider.ValidatePreviousInValue()`:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate all miners' PreviousInValue, not just sender
    foreach (var miner in extraData.Round.RealTimeMinersInformation)
    {
        var publicKey = miner.Key;
        
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
            continue;
            
        var previousInValue = miner.Value.PreviousInValue;
        if (previousInValue == null || previousInValue == Hash.Empty) 
            continue;
            
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        
        // Validate Hash(PreviousInValue) == OutValue_previous_round for ALL miners
        if (HashHelper.ComputeFrom(previousInValue) != previousOutValue)
            return false;
    }
    
    return true;
}
```

Additionally, add validation in `UpdateLatestSecretPieces()` before accepting revealed in values, and in `PerformSecretSharing()` before setting miners' `PreviousInValue` from the transaction input.

## Proof of Concept

```csharp
// Test scenario demonstrating the vulnerability:
// 1. Setup a round with multiple miners where some haven't produced blocks yet
// 2. Malicious miner produces a block with corrupted revealed_in_values
// 3. The corrupted PreviousInValue passes validation
// 4. The corrupted value is persisted to state
// 5. When SupplyCurrentRoundInformation() is called, it uses the corrupted value

[Fact]
public async Task MaliciousMiner_CanCorruptOtherMiners_PreviousInValue()
{
    // Arrange: Create round with miners where targetMiner hasn't produced blocks
    var round = GenerateTestRound(minerCount: 3);
    var maliciousMiner = "malicious_miner_pubkey";
    var targetMiner = "target_miner_pubkey"; 
    
    // targetMiner has PreviousInValue == null
    round.RealTimeMinersInformation[targetMiner].PreviousInValue = null;
    
    // Malicious value that does NOT hash to targetMiner's previous OutValue
    var corruptedValue = HashHelper.ComputeFrom("corrupted_data");
    
    // Act: Malicious miner provides corrupted revealed_in_values
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteStringHelper.FromHexString(maliciousMiner),
        RevealedInValues = { { targetMiner, corruptedValue } }
    };
    
    var result = await ConsensusContract.UpdateValue(CreateUpdateValueInput(triggerInfo));
    
    // Assert: Corrupted value is accepted and persisted
    var updatedRound = await ConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var actualPreviousInValue = updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue;
    
    // The corrupted value was accepted
    actualPreviousInValue.ShouldBe(corruptedValue);
    
    // Verify the invariant is violated
    var previousRound = await GetPreviousRound();
    var previousOutValue = previousRound.RealTimeMinersInformation[targetMiner].OutValue;
    
    // Hash(PreviousInValue) should equal OutValue_previous_round, but doesn't
    HashHelper.ComputeFrom(actualPreviousInValue).ShouldNotBe(previousOutValue);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L44-52)
```csharp
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```
