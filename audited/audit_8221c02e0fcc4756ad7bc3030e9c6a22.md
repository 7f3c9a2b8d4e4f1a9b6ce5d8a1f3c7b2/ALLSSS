### Title
Self-Modification Deadlock in Referendum Contract Due to Insufficient Threshold and Whitelist Validation

### Summary
The Referendum contract's `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList` functions can only be called by the organization itself through proposal execution. However, insufficient validation allows organizations to set impossible thresholds or inaccessible whitelists, creating an irrecoverable deadlock where the organization can never modify its own configuration. This permanently disables governance functionality for affected organizations.

### Finding Description

The `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList` functions require `Context.Sender` to equal the organization address: [1](#0-0) [2](#0-1) 

These functions can only be invoked when a proposal is released, which uses `SendVirtualInlineBySystemContract` to set the sender to the organization address: [3](#0-2) 

The validation function has critical gaps: [4](#0-3) 

**Root Cause:** The validation only checks basic constraints (non-empty whitelist, threshold relationships, non-negative values) but does NOT verify:
1. That `MinimalVoteThreshold` or `MinimalApprovalThreshold` are achievable given actual token supply
2. That whitelist addresses are accessible/valid
3. That `MaximalRejectionThreshold` or `MaximalAbstentionThreshold` allow practical governance

The threshold release check enforces strict inequality for rejections: [5](#0-4) 

**Comparison:** The Association contract has superior validation that prevents similar deadlocks: [6](#0-5) 

The Association contract validates that thresholds are achievable against `organizationMemberCount`, but Referendum lacks equivalent checks against token supply.

### Impact Explanation

**Governance Deadlock:** Once an organization sets problematic parameters:
- **Scenario 1 (Impossible Threshold):** Setting `MinimalVoteThreshold = 1,000,000,000,000` when token supply is much lower means no future proposal can ever reach approval threshold. The organization cannot create a corrective proposal because it cannot be approved.

- **Scenario 2 (Zero Rejection Threshold):** Setting `MaximalRejectionThreshold = 0` means any proposal with ≥1 rejection vote fails. In referendum-based governance (democratic voting), achieving zero dissent is practically impossible. Recovery proposals will likely receive at least one rejection, maintaining the deadlock.

- **Scenario 3 (Inaccessible Whitelist):** Setting whitelist to addresses with lost keys or contract addresses with no owners prevents anyone from creating proposals, including corrective ones.

**Who is Affected:** Any Referendum organization that mistakenly or maliciously sets invalid thresholds becomes permanently non-functional. All governance decisions requiring that organization are blocked indefinitely.

**Severity:** HIGH - Complete loss of governance functionality with no recovery mechanism. While not direct fund theft, it permanently disables critical protocol governance paths.

### Likelihood Explanation

**Attacker Capabilities:**
- Malicious actor with proposer rights can intentionally create a deadlock proposal
- Legitimate user can accidentally misconfigure during threshold updates
- No special privileges beyond normal proposer authorization needed

**Attack Complexity:** LOW
1. Create proposal to call `ChangeOrganizationThreshold` with extreme values
2. Get proposal approved (under current reasonable thresholds)
3. Release proposal - organization is now deadlocked

**Feasibility Conditions:**
- Proposal creation requires being in whitelist (normal operation)
- Proposal approval requires meeting current thresholds (achievable before attack)
- No validation prevents setting problematic values

**Detection:** Difficult to prevent proactively. Once parameters are set, the deadlock is immediate and irreversible.

**Probability:** MEDIUM-HIGH
- Accidental misconfiguration during legitimate governance operations
- Malicious actors could weaponize this against governance systems
- No warning or recovery mechanism exists

### Recommendation

**Code-level Mitigation:**

1. **Add Token Supply Validation:** Modify the `Validate` function to check thresholds against actual token metrics:
```
// In Referendum_Helper.cs Validate function
var tokenInfo = GetTokenInfo(organization.TokenSymbol);
var maxPossibleVotes = tokenInfo.Supply; // or circulating supply
Assert(proposalReleaseThreshold.MinimalVoteThreshold <= maxPossibleVotes,
    "MinimalVoteThreshold exceeds possible voting power");
Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= maxPossibleVotes,
    "MinimalApprovalThreshold exceeds possible voting power");
```

2. **Add Feasibility Checks:** Similar to Association contract:
```
Assert(proposalReleaseThreshold.MaximalRejectionThreshold + 
       proposalReleaseThreshold.MinimalApprovalThreshold <= maxPossibleVotes,
    "Rejection and approval thresholds are incompatible");
Assert(proposalReleaseThreshold.MaximalAbstentionThreshold + 
       proposalReleaseThreshold.MinimalApprovalThreshold <= maxPossibleVotes,
    "Abstention and approval thresholds are incompatible");
```

3. **Minimum Threshold Guards:**
```
Assert(proposalReleaseThreshold.MaximalRejectionThreshold > 0 || 
       proposalReleaseThreshold.MinimalVoteThreshold == 1,
    "MaximalRejectionThreshold of 0 creates deadlock risk");
```

4. **Whitelist Address Validation:** Verify addresses in whitelist are not obviously invalid (non-zero, not system addresses, etc.)

**Test Cases:**
- Test setting `MinimalVoteThreshold` > total supply → should fail
- Test setting `MaximalRejectionThreshold = 0` → should fail or require special authorization
- Test recovery after threshold change → verify new proposals can still pass

### Proof of Concept

**Initial State:**
- Referendum organization exists with reasonable thresholds: `MinimalVoteThreshold = 10,000`, `MinimalApprovalThreshold = 10,000`
- Token "ELF" has circulating supply of 100,000
- Proposer whitelist contains Address A and Address B

**Attack Sequence:**

1. **Create Malicious Proposal** (Address A):
   - Target: `ReferendumContract.ChangeOrganizationThreshold`
   - Params: `ProposalReleaseThreshold { MinimalVoteThreshold = 1,000,000,000,000, MinimalApprovalThreshold = 10,000, MaximalRejectionThreshold = 0, MaximalAbstentionThreshold = 0 }`
   - Validation passes (all constraints in `Validate` function satisfied)

2. **Approve Proposal:**
   - Voters approve with 10,000+ tokens (meets current threshold)
   - Proposal reaches approval threshold under current rules

3. **Release Proposal:**
   - `Context.SendVirtualInlineBySystemContract` executes with `Context.Sender = organizationAddress`
   - `ChangeOrganizationThreshold` updates: `MinimalVoteThreshold = 1,000,000,000,000`, `MaximalRejectionThreshold = 0`
   - Validation passes (no check against token supply)

**Result:**
- Organization now requires 1 trillion tokens to vote (impossible with 100K supply)
- Any proposal with ≥1 rejection vote fails (MaximalRejectionThreshold = 0)
- Cannot create corrective proposal because:
  - Impossible to get 1 trillion votes for approval
  - Even if somehow achieved, any single rejection blocks it
- **Organization governance is permanently deadlocked**

**Success Condition:** Organization cannot execute any future proposals, including proposals to restore reasonable thresholds. The `ChangeOrganizationThreshold` function becomes unreachable, confirming permanent deadlock.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
