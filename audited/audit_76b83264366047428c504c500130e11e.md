### Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

### Summary
The `AnnounceElectionFor` function lacks authorization checks, allowing any caller to announce election for arbitrary public keys and assign themselves as admin. This enables attackers to gain permanent administrative control over candidates they don't own, manipulate elections, and prevent legitimate owners from ever registering their public keys as candidates.

### Finding Description

The vulnerability exists in the `AnnounceElectionFor` function which accepts an arbitrary `pubkey` string and `admin` address without verifying that the caller has permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided `admin` parameter (defaulting to `Context.Sender`) as the candidate admin without any consent mechanism: [2](#0-1) 

The internal validation in the `AnnounceElection` method only checks pubkey status (not initial miner, not already announced, not banned) but never validates caller authorization: [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method uses cryptographic signature verification to ensure only the private key owner can announce: [4](#0-3) 

This secure pattern is completely missing from `AnnounceElectionFor`, creating the authorization bypass.

**Why Existing Protections Fail:**

The checks at lines 149-165 only validate pubkey eligibility status, not caller permission. There is no signature verification, ownership proof, or consent mechanism requiring the pubkey owner's approval.

### Impact Explanation

**1. Unauthorized Administrative Control**
An attacker gains full admin privileges over candidates they don't own. Admin control includes:
- Ability to quit election at any time (checked at line 236)
- Ability to replace the candidate's public key
- Ability to set profit receivers [5](#0-4) 

**2. Permanent Registration DoS**
Once a pubkey is announced as a candidate, the legitimate owner can never register it because the check at line 156 prevents re-announcement: [6](#0-5) 

Even after the attacker quits, they can immediately re-announce, creating a persistent griefing attack.

**3. Election Manipulation**
- Attacker can strategically quit elections to manipulate the miner selection process during term changes
- Voters may vote for hijacked candidates believing they're legitimate, locking tokens for candidates controlled by attackers
- The data center ranking system can be manipulated by controlling when candidates participate

**4. Reputation and Trust Damage**
Attackers can register well-known public keys (from other blockchains, public figures, etc.) as candidates under their control, creating confusion and damaging the election system's integrity.

**Severity:** CRITICAL - Breaks fundamental authorization invariant allowing unauthorized control over election candidates and manipulation of the consensus mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
- 100,000 ELF for the candidate lock (returned to attacker when they quit via sponsor map)
- Ability to call a public contract method
- Knowledge of target public key hex strings

**Attack Complexity:** TRIVIAL
- Single transaction call with two parameters: arbitrary pubkey and attacker's address as admin
- No special timing, race conditions, or complex state setup required

**Economic Cost:** MINIMAL
The attacker locks 100,000 ELF but retrieves it when quitting: [7](#0-6) 

The sponsor receives the refund, so the attacker's net cost is zero plus transaction fees.

**Detection Difficulty:** HIGH
The hijacked registration appears legitimate on-chain. Users cannot easily distinguish between legitimate candidate registrations and malicious hijackings without off-chain verification of ownership.

**Probability:** HIGH - The vulnerability is easily discoverable, trivial to exploit, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

### Recommendation

**Primary Fix: Add Authorization Check**

Implement signature verification or require the candidate's private key to sign a consent message. Modify `AnnounceElectionFor` to include:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // NEW: Verify caller authorization
    // Option 1: Require signature from candidate
    Assert(input.CandidateSignature != null, "Candidate consent signature required.");
    var candidateAddress = Address.FromPublicKey(pubkeyBytes);
    var messageHash = HashHelper.ComputeFrom(input);
    Assert(VerifySignature(messageHash, input.CandidateSignature, candidateAddress), 
           "Invalid candidate consent signature.");
    
    // OR Option 2: Require caller to be the candidate themselves
    // Assert(Context.Sender == candidateAddress, 
    //        "Only the candidate can authorize their election announcement.");
    
    // ... rest of function
}
```

**Alternative Fix: Whitelist Authorized Sponsors**

If third-party sponsorship is a design requirement, implement a whitelist or registry where candidates must pre-approve sponsors:

```csharp
// Before announcing
var candidateAddress = Address.FromPublicKey(pubkeyBytes);
Assert(State.AuthorizedSponsors[candidateAddress][Context.Sender], 
       "Caller not authorized to sponsor this candidate.");
```

**Required Test Cases:**

1. Test that unauthorized addresses cannot call `AnnounceElectionFor` for arbitrary pubkeys
2. Test that only candidates or authorized sponsors can announce election
3. Test rejection of duplicate sponsorship attempts
4. Test that legitimate owners can reclaim control if hijacked (recovery mechanism)

### Proof of Concept

**Initial State:**
- Attacker address: `attackerAddress` with 100,000+ ELF balance
- Victim public key: `victimPubkey` (any valid hex string, victim has never announced election)
- Victim has never registered as a candidate

**Attack Sequence:**

**Transaction 1: Hijack Candidate Registration**
```
Caller: attackerAddress
Contract: ElectionContract
Method: AnnounceElectionFor
Input: {
  Pubkey: victimPubkey,
  Admin: attackerAddress
}
```

**Expected (Secure) Result:** Transaction should REVERT with "Unauthorized" or "Signature required"

**Actual (Vulnerable) Result:** Transaction SUCCEEDS
- `State.CandidateAdmins[victimPubkey] = attackerAddress` (line 128)
- `State.ManagedCandidatePubkeysMap[attackerAddress]` includes `victimPubkey` (line 129-131)
- `State.CandidateSponsorMap[victimPubkey] = attackerAddress` (line 140)
- Attacker's 100,000 ELF locked in virtual address
- Victim's pubkey now registered as candidate with attacker as admin

**Transaction 2: Verify Admin Control**
```
Caller: attackerAddress
Contract: ElectionContract  
Method: QuitElection
Input: { Value: victimPubkey }
```

**Result:** Transaction SUCCEEDS (passes admin check at line 236)
- Attacker successfully quits election for victim's pubkey
- Attacker receives 100,000 ELF refund
- Can immediately re-announce to maintain control

**Transaction 3: Victim Attempts Legitimate Registration**
```
Caller: Address.FromPublicKey(victimPubkey_bytes)
Contract: ElectionContract
Method: AnnounceElection
Input: victimAddress
```

**Result:** Transaction REVERTS with "This public key already announced election" (line 157)
- Victim permanently blocked from registering their own pubkey
- Only option is waiting for attacker to quit, then racing to register first

**Success Condition:** Attacker has gained admin control over a candidate pubkey they don't own, can manipulate election participation, and has prevented legitimate registration - all at zero net cost.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-96)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L235-236)
```csharp
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```
