### Title
NFT Token Hash Collision via Insecure String Concatenation Key Generation

### Summary
The NFT contract generates token hashes by concatenating symbol and tokenId strings before hashing, creating collision vulnerability where different (symbol, tokenId) pairs can map to the same state keys. An attacker who creates NFT protocols with strategically chosen short symbols can collide with other NFTs' token hashes, enabling balance manipulation, ownership confusion, and potential NFT theft.

### Finding Description

The root cause is in the `CalculateTokenHash` method which uses simple string concatenation: [1](#0-0) 

This method concatenates the symbol string directly with the tokenId's string representation before hashing. This creates collision opportunities where:
- Protocol A with symbol="AR1" and tokenId=23 → hash("AR123")
- Protocol B with symbol="AR12" and tokenId=3 → hash("AR123")
- Protocol C with symbol="AR" and tokenId=123 → hash("AR123")

All three produce identical token hashes despite representing different NFTs.

The vulnerability is exploitable because while `NFTContract.Create` auto-generates symbols with minimum 11 characters: [2](#0-1) [3](#0-2) 

The `CrossChainCreate` method accepts arbitrary symbols from the Token contract without length validation: [4](#0-3) 

An attacker can create tokens with short symbols (e.g., "AR", "AR1", "AR12") in the Token contract (requiring seed NFT or whitelist access), then register them as NFT protocols via `CrossChainCreate`. The Token contract's symbol validation only requires regex matching and length limits, allowing symbols as short as 1-2 characters: [5](#0-4) 

The collision affects all state maps using tokenHash as key: [6](#0-5) 

### Impact Explanation

When two (symbol, tokenId) pairs produce identical token hashes:

1. **Balance Manipulation**: `BalanceMap[tokenHash][address]` is shared between colliding NFTs, allowing attackers to:
   - Steal balances from victim NFTs by transferring their own colliding NFT
   - Inflate their balance using victim's holdings
   
2. **Metadata Overwrite**: `NftInfoMap[tokenHash]` stores only one NFTInfo, so later mints overwrite earlier NFT metadata, URI, and owner records

3. **Allowance Confusion**: `AllowanceMap[tokenHash][owner][spender]` approvals become ambiguous between colliding NFTs

4. **Assembled Asset Corruption**: `AssembledNftsMap/FtsMap[tokenHash]` for composite NFTs get confused

Concrete scenario:
- Victim creates high-value NFT with auto-generated symbol "AR100000000", tokenId=1
- Attacker creates token "AR10000000" (via seed NFT), registers as NFT protocol  
- Attacker mints tokenId=01 → both hash to "AR1000000001"
- Attacker can now manipulate victim's NFT balance and metadata

Severity: **HIGH** - Direct theft/manipulation of NFT assets and ownership records.

### Likelihood Explanation

**Attack Path:**
1. Attacker acquires seed NFT or whitelist access to call `Token.Create` with custom symbol
2. Create token with short symbol (e.g., "AR1") and required external info (NFT type, base URI, token ID reuse flag)
3. Call `NFT.CrossChainCreate` to register as NFT protocol (no authorization check)
4. Calculate target victim's tokenHash
5. Mint attacker NFT with calculated tokenId to produce collision
6. Execute balance transfers or metadata manipulation

**Feasibility Assessment:**
- **Seed NFT barrier**: Economic cost but publicly acquirable, not a cryptographic or authorization barrier
- **Whitelist access**: Privileged but includes legitimate token creators and multi-sig participants
- **No authorization on CrossChainCreate**: Anyone with valid token can call
- **Deterministic collision**: Attacker can precisely calculate colliding (symbol, tokenId) pairs

**Likelihood: MEDIUM** - Requires token creation capability but multiple acquisition paths exist (economic purchase of seed NFT, insider access, cross-chain scenarios). The fundamental design flaw also enables accidental collisions as symbol policies evolve.

### Recommendation

**Immediate Fix**: Change `CalculateTokenHash` to use structured hashing preventing string boundary ambiguity:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    // Use separate hashing or delimiter that cannot appear in inputs
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

**Additional Mitigations**:
1. Add symbol length validation in `CrossChainCreate` to enforce minimum length matching auto-generated symbols (11 characters minimum)
2. Add authorization check on `CrossChainCreate` requiring Parliament approval or validated cross-chain proof
3. Implement collision detection: before minting, verify `NftInfoMap[tokenHash]` is empty or matches current (symbol, tokenId)
4. Add unit tests verifying no collision between all possible symbol/tokenId combinations within expected ranges

**Regression Prevention**:
- Test case: Create protocols "AR1", "AR12", "AR" and verify minting tokenIds 23, 3, 123 respectively produces distinct token hashes
- Test case: Attempt `CrossChainCreate` with symbols <11 chars and verify rejection
- Invariant check: `GetNFTInfoByTokenHash` should return NFT matching expected (symbol, tokenId) pair

### Proof of Concept

**Setup:**
- Token contract allows creating token with symbol "AR1" (acquire seed NFT "SEED-AR1" and burn it)
- NFT contract has auto-generated protocol with symbol "AR12"

**Attack Steps:**
1. Attacker calls `Token.Create({ Symbol: "AR1", ExternalInfo: {nft_type, base_uri, token_id_reuse} })`
2. Attacker calls `NFT.CrossChainCreate({ Symbol: "AR1" })`
3. Victim mints NFT from protocol "AR12" with tokenId=3 → tokenHash = hash("AR123"), balance[victim]=1
4. Attacker mints NFT from protocol "AR1" with tokenId=23 → tokenHash = hash("AR123"), overwrites balance
5. Attacker calls `Transfer` from "AR1" protocol → manipulates shared balance state

**Expected Result**: Two distinct NFTs with separate balances and metadata

**Actual Result**: Single shared tokenHash causes balance/metadata collision, enabling theft and state corruption

**Success Condition**: `GetBalance(owner=victim, symbol="AR12", tokenId=3)` returns different value after attacker's operations, proving collision affected victim's NFT state.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-90)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L18-21)
```csharp
    private static bool IsValidSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+(-[0-9]+)?$");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-33)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }
```
