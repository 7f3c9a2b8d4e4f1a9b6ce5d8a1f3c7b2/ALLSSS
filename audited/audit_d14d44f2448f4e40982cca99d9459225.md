# Audit Report

## Title
Missing Options Count Validation in Vote Contract Register Method Allows Bypass of MaximumOptionsCount Limit

## Summary
The Vote contract's `Register` method fails to validate the number of options during voting item creation, allowing attackers to bypass the protocol-defined `MaximumOptionsCount` limit of 64. This enables creation of voting items with arbitrarily large option arrays, causing permanent state bloat and potential denial-of-service through excessive storage consumption across all network nodes.

## Finding Description

The Vote contract defines a security constant `MaximumOptionsCount = 64` to limit the number of voting options [1](#0-0) , but this limit is not enforced during the initial registration flow.

The `Register` method directly assigns input options to the VotingItem without any count validation [2](#0-1) . The validation method `AssertValidNewVotingItem` only checks for voting item existence, snapshot number validity, and timestamp constraints, completely omitting options count validation [3](#0-2) .

This inconsistency is evident when comparing with other methods that properly enforce the limit:
- `AddOption` enforces the limit with a strict less-than check [4](#0-3) 
- `AddOptions` enforces it with a less-than-or-equal check after adding options [5](#0-4) 

Additionally, while `AssertOption` validates individual option length limits [6](#0-5) , it is never invoked during registration, allowing bypass of both the count limit (64 options) and individual option length limit (1024 characters per option).

The VotingItems are stored permanently in the contract state [7](#0-6) , meaning this excessive data persists indefinitely across all network nodes.

## Impact Explanation

**Operational Impact - State Bloat and Resource Exhaustion:**

An attacker can create voting items with far more than 64 options (potentially 1000+ options, each up to 1024 characters). Since each option can be 1024 characters and there's no enforcement, a single malicious voting item could store approximately 1MB of data (1000 options × 1024 bytes), compared to the intended ~64KB maximum (64 options × 1024 bytes).

The permanent storage in `State.VotingItems` means this bloat affects all network nodes perpetually. With only a 10 ELF transaction fee per registration [8](#0-7) , an attacker spending 1000 ELF could create 100 such items, resulting in ~100MB of permanent state bloat.

This degrades node performance, increases storage costs network-wide, and could lead to denial-of-service through state exhaustion. The protocol's design invariant (MaximumOptionsCount) exists precisely to prevent such scenarios, but the missing validation renders it ineffective.

## Likelihood Explanation

**High Feasibility:**

The `Register` method is publicly accessible with no access control restrictions. An attacker only needs:
1. ELF tokens for the 10 ELF transaction fee
2. A whitelisted token symbol (ELF itself is whitelisted by default)

Both preconditions are trivially obtainable. The exploit is straightforward: construct a `VotingRegisterInput` with an arbitrarily large options array and call `Register`.

**Economic Viability:**

At 10 ELF per registration, creating 100 voting items with 1000 options each (resulting in ~100MB of permanent bloat) costs only 1000 ELF. During periods of low ELF price or for a sufficiently motivated attacker, this becomes economically rational to execute. The permanent nature of blockchain storage makes this particularly damaging.

**Detection Constraints:**

Standard transaction monitoring would only observe normal `Register` calls. The excessive options count wouldn't be immediately obvious without inspecting transaction data payload sizes, making the attack relatively stealthy until state bloat becomes noticeable.

## Recommendation

Add options count validation in the `AssertValidNewVotingItem` method or directly in the `Register` method before creating the VotingItem:

```csharp
// In AssertValidNewVotingItem or at the start of Register:
Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
    $"The count of options can't be greater than {VoteContractConstants.MaximumOptionsCount}");
```

Additionally, invoke `AssertOption` for each option during registration to enforce individual option length limits:

```csharp
// Before creating the VotingItem:
foreach (var option in input.Options)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
}
```

This ensures consistent enforcement of protocol limits across all entry points (Register, AddOption, AddOptions).

## Proof of Concept

```csharp
// Exploit scenario demonstrating the vulnerability
public void Test_RegisterWithExcessiveOptions()
{
    // Attacker constructs input with 1000 options (far exceeding the limit of 64)
    var maliciousInput = new VotingRegisterInput
    {
        StartTimestamp = Timestamp.FromDateTime(DateTime.UtcNow),
        EndTimestamp = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(7)),
        AcceptedCurrency = "ELF",
        IsLockToken = true,
        TotalSnapshotNumber = 1,
        Options = Enumerable.Range(0, 1000).Select(i => new string('A', 1024)).ToList() // 1000 options of 1024 chars each
    };
    
    // Call Register with 10 ELF fee
    // Expected: Should fail with options count validation error
    // Actual: Succeeds and stores 1MB of data permanently
    voteContract.Register(maliciousInput);
    
    // Result: VotingItem created with 1000 options, violating MaximumOptionsCount=64
    // Impact: ~1MB of permanent state storage per call, multiply by repeated registrations
}
```

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L320-321)
```csharp
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L9-9)
```csharp
    public MappedState<Hash, VotingItem> VotingItems { get; set; }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L47-47)
```csharp
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
```
