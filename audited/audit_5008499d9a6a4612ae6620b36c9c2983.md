# Audit Report

## Title
Approval Count Race Condition: Membership Changes Can Invalidate Legitimately Approved Proposals

## Summary
The Association contract recalculates approval counts using current membership at release time rather than preserving approval validity from when votes were cast. This allows adversaries to retroactively invalidate legitimately approved proposals by removing approving members, creating a governance denial-of-service vector.

## Finding Description

The vulnerability exists in the approval counting mechanism which validates proposal approval status at release time rather than at approval time.

When members approve a proposal via the `Approve` method, their addresses are stored in the proposal's approval list. [1](#0-0) 

However, when a proposal is released, the approval count is recalculated by filtering the stored approvals against the **current** organization membership. [2](#0-1) 

The proposal storage structure stores approvals as an address list without any membership snapshot or timestamp validation. [3](#0-2) 

Organization membership can be dynamically modified through three methods callable by the organization itself:
- `RemoveMember` removes an existing member [4](#0-3) 
- `ChangeMember` replaces one member with another [5](#0-4) 
- `AddMember` adds a new member [6](#0-5) 

When `Release` is called, it asserts that the release threshold is reached. [7](#0-6) 

This triggers `IsReleaseThresholdReached` which calls `CheckEnoughVoteAndApprovals` to verify the approval count meets `MinimalApprovalThreshold`. [8](#0-7) 

The threshold definition specifies the minimum approval count required. [9](#0-8) 

**Attack Sequence:**
1. Proposal A is created and approved by members [Alice, Bob, Carol] - meets MinimalApprovalThreshold of 3
2. Adversary creates Proposal B to remove Alice from the organization
3. Proposal B is quickly approved and released
4. Alice is removed from `OrganizationMemberList`
5. When Proposal A's proposer attempts to release it, `CheckEnoughVoteAndApprovals` recounts approvals
6. Only Bob and Carol are still in the current membership, so `approvedMemberCount = 2`
7. Since `2 < MinimalApprovalThreshold (3)`, the assertion fails with "Not approved"

The validation function at member removal only ensures the organization structure remains valid (thresholds are achievable), but does not protect existing proposal approvals. [10](#0-9) 

## Impact Explanation

**HIGH Severity** - This vulnerability enables governance denial-of-service attacks:

**Operational Impact:**
- Legitimately approved proposals become permanently un-releaseable if approving members are removed
- Critical governance actions (security patches, emergency responses, parameter updates) can be blocked
- The governance invariant "approved proposals remain approved until expiration" is violated

**Attack Scenarios:**
- Adversaries with sufficient voting power can systematically block unfavorable proposals
- In contentious governance situations, competing factions can sabotage each other's proposals
- Accidental member removal during legitimate organizational changes can unintentionally invalidate pending proposals

**Affected Parties:**
- Organizations using Association contracts for multi-sig governance
- Proposal creators whose work is invalidated retroactively
- Systems depending on timely governance execution (e.g., security-critical protocol upgrades)

While this doesn't directly result in fund theft, blocking governance can:
- Prevent emergency responses to other vulnerabilities
- Enable denial-of-service on critical protocol functions
- Undermine trust in the governance system

## Likelihood Explanation

**MEDIUM-HIGH Likelihood:**

**Attacker Requirements:**
- Voting power within the organization to approve member removal proposals
- No external or privileged role required - can be executed by regular organization members

**Attack Complexity:**
- Moderate: requires coordinating two proposals (target proposal + member removal)
- Timing window exists between when a proposal meets its threshold and when the proposer attempts release
- Only the original proposer can call `Release`, providing a predictable attack window [11](#0-10) 

**Feasibility:**
- More likely in organizations with active membership management
- Can occur accidentally during legitimate organizational restructuring
- Probability increases in contentious governance scenarios with competing factions
- No on-chain monitoring mechanisms would detect this as abnormal behavior

**Economic Rationality:**
- Low cost if attacker already has organizational voting power
- High benefit when blocking specific proposals is valuable (e.g., preventing unfavorable governance changes)
- Rational strategy in competitive governance environments

## Recommendation

Implement one of the following solutions:

**Option 1: Snapshot Membership at Approval Time**
Store the organization's member list hash or membership snapshot when each vote is cast. Validate approvals against the membership state at the time of voting, not current membership.

**Option 2: Lock Membership During Active Proposals**
Prevent membership changes (RemoveMember, ChangeMember) when there are active proposals that have received votes. Only allow membership changes after all pending proposals are either released or expired.

**Option 3: Finalize Approval Count**
Once a proposal reaches its approval threshold, mark it as "approved" with a finalized count. Subsequent membership changes should not affect the release eligibility of already-approved proposals.

**Recommended Implementation (Option 1):**
```csharp
// Store membership hash when vote is cast
private void RecordApprovalWithMembership(Hash proposalId, Address approver, Organization organization)
{
    var membershipHash = HashHelper.ComputeFrom(organization.OrganizationMemberList);
    // Store approval with membership snapshot reference
    State.ApprovalMemberships[proposalId][approver] = membershipHash;
}

// Validate approval against historical membership
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var validApprovals = 0;
    foreach (var approver in proposal.Approvals)
    {
        var approvalMembershipHash = State.ApprovalMemberships[proposal.ProposalId][approver];
        // Accept approval if member was valid at approval time
        if (approvalMembershipHash != null || organization.OrganizationMemberList.Contains(approver))
        {
            validApprovals++;
        }
    }
    return validApprovals >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task ApprovalInvalidation_MemberRemoval_ProposalBecomesUnreleaseable()
{
    // Setup: Create organization with 4 members, threshold = 3
    var members = new[] { Alice, Bob, Carol, Dave };
    var organization = await CreateOrganizationAsync(members, minimalApprovalThreshold: 3);
    
    // Step 1: Create Proposal A
    var proposalA = await CreateProposalAsync(organization, Alice);
    
    // Step 2: Alice, Bob, Carol approve Proposal A (meets threshold)
    await ApproveAsync(proposalA, Alice);
    await ApproveAsync(proposalA, Bob);
    await ApproveAsync(proposalA, Carol);
    
    // Verify proposal is ready to release
    var status = await GetProposalAsync(proposalA);
    Assert.True(status.ToBeReleased); // ✓ Meets threshold
    
    // Step 3: Create and execute Proposal B to remove Alice
    var proposalB = await CreateRemoveMemberProposalAsync(organization, Alice);
    await ApproveAsync(proposalB, Bob);
    await ApproveAsync(proposalB, Carol);
    await ApproveAsync(proposalB, Dave);
    await ReleaseProposalAsync(proposalB);
    
    // Step 4: Attempt to release Proposal A
    // Expected: Should succeed (proposal was approved when Alice was a member)
    // Actual: Fails because Alice's approval no longer counts
    var exception = await Assert.ThrowsAsync<AssertionException>(
        async () => await ReleaseProposalAsync(proposalA)
    );
    
    Assert.Contains("Not approved", exception.Message);
    
    // Verify: Only 2 approvals count now (Bob, Carol), below threshold of 3
    var finalStatus = await GetProposalAsync(proposalA);
    Assert.False(finalStatus.ToBeReleased); // ✗ No longer releaseable
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L186-186)
```csharp
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L188-188)
```csharp
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-245)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-263)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-279)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-31)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** protobuf/association_contract.proto (L91-92)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
```

**File:** protobuf/acs3.proto (L128-130)
```text
message ProposalReleaseThreshold {
    // The value for the minimum approval threshold.
    int64 minimal_approval_threshold = 1;
```
