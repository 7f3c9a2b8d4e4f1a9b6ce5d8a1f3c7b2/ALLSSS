### Title
NFT Item ID Leading Zero Bypass Allows Duplicate NFT Creation for Same Logical Item

### Summary
The `IsValidItemId()` function uses the regex pattern `^[0-9]+$` which accepts item IDs with unlimited leading zeros (e.g., "1", "01", "001", "0001"). Since NFT symbols are stored using the exact string as the storage key without normalization, item IDs "COLLECTION-1" and "COLLECTION-00000001" are treated as completely separate NFTs despite representing the same logical item. This violates the fundamental NFT uniqueness invariant and allows unlimited duplicate NFTs to be created for any given item number.

### Finding Description

**Root Cause:**

The validation function `IsValidItemId()` at [1](#0-0)  uses a permissive regex pattern that accepts any sequence of digits without restricting leading zeros.

This validation is called during symbol type determination at [2](#0-1)  where the item ID portion is extracted and validated but never normalized.

**Why Protections Fail:**

When an NFT is created, the symbol is stored directly as the key in state storage at [3](#0-2)  without any normalization of the item ID component.

The uniqueness check in `CheckTokenExists()` at [4](#0-3)  only verifies that the exact symbol string doesn't already exist in `State.TokenInfos[symbol]`. Since "COLLECTION-1" and "COLLECTION-01" are different string keys, both pass the uniqueness check.

The creation flow at [5](#0-4)  proceeds to register both as separate tokens, each with their own `TokenInfo` entry, supply tracking, and balance mappings.

**Execution Path:**

1. User creates NFT collection "TEST-0"
2. User creates NFT "TEST-1" with TotalSupply=1
3. User creates NFT "TEST-01" with TotalSupply=1 (different string, passes all checks)
4. User creates NFT "TEST-001" with TotalSupply=1 (also passes)
5. Each is registered as a completely separate NFT with independent supply and balances

### Impact Explanation

**Direct NFT Supply Inflation:**
Each leading zero variant creates a completely independent NFT with its own TotalSupply, Issued amount, and Supply tracking. If an NFT collection intends item #1 to have TotalSupply=1 (ERC-721 style), an attacker can create "COLLECTION-01", "COLLECTION-001", etc., each with TotalSupply=1, resulting in unlimited "copies" of what should be a unique item.

**Ownership and Authenticity Confusion:**
Multiple users could own different versions ("COLLECTION-1" vs "COLLECTION-00001") of what they believe is the same NFT. Marketplaces and applications that normalize display ("Item #1") would show these as the same item, but they have completely separate on-chain ownership and state.

**Fraud Potential:**
A malicious NFT creator could:
- Sell "COLLECTION-1" as the authentic NFT
- Later mint "COLLECTION-01", "COLLECTION-001", etc. and sell those as well
- Claim each is the "real" item #1 since all pass validation
- Exploit different normalization behaviors across platforms

**Protocol-Wide Impact:**
This affects ALL NFT collections created through the MultiToken contract, as the validation logic at [6](#0-5)  applies universally. The critical NFT uniqueness invariant from section "Token Supply & Fees" is violated.

**Affected Parties:**
- NFT holders who believe they own a unique item
- NFT marketplaces that must handle duplicate "logical" items
- Collection creators whose supply limits are bypassed
- Cross-chain bridges that may normalize differently

### Likelihood Explanation

**Reachable Entry Point:**
The `Create` method is publicly accessible at [7](#0-6)  and routes to NFT creation for symbols matching the NFT pattern.

**Attacker Capabilities:**
An attacker needs only the standard NFT creation permissions:
- For collections without whitelist: ownership of the SEED NFT for the collection prefix (standard requirement shown at [8](#0-7) )
- For whitelisted addresses: no additional requirements

**Execution Practicality:**
The attack is trivial to execute:
1. Obtain normal NFT creation permissions
2. Call `Create` with symbol "COLLECTION-1" (succeeds)
3. Call `Create` with symbol "COLLECTION-01" (also succeeds)
4. Repeat with "COLLECTION-001", "COLLECTION-0001", etc.

No special transaction ordering, timing, or complex state manipulation is required.

**Detection Difficulty:**
The vulnerability is hard to detect because:
- The test suite at [9](#0-8)  lacks test cases for leading zeros
- Visual display typically shows "Item #1" for all variants
- Each variant passes all validation checks successfully
- No events or warnings are emitted

**Economic Rationality:**
The attack cost is identical to creating legitimate NFTs. No additional gas or token costs are required beyond standard NFT creation, making it economically viable even for low-value exploits.

### Recommendation

**Immediate Fix:**
Modify `IsValidItemId()` to reject leading zeros:

```csharp
private bool IsValidItemId(string symbolItemId)
{
    // Reject empty string or pure zeros
    if (string.IsNullOrEmpty(symbolItemId) || symbolItemId.All(c => c == '0'))
        return false;
    
    // Reject leading zeros (except for the single digit "0")
    if (symbolItemId.Length > 1 && symbolItemId[0] == '0')
        return false;
    
    return Regex.IsMatch(symbolItemId, "^[0-9]+$");
}
```

**Alternative Normalization Approach:**
If leading zeros should be allowed but normalized, modify `GetSymbolType()` and all symbol processing to normalize item IDs:

```csharp
private string NormalizeItemId(string itemId)
{
    // Convert to integer and back to remove leading zeros
    if (long.TryParse(itemId, out long numericId))
        return numericId.ToString();
    return itemId;
}
```

Apply normalization before storage at [10](#0-9) 

**Test Cases to Add:**
1. Test that "COLLECTION-01" is rejected (or normalized to "COLLECTION-1")
2. Test that "COLLECTION-001" and "COLLECTION-1" cannot both be created
3. Test edge cases: "COLLECTION-0", "COLLECTION-00", "COLLECTION-000000000000000001"
4. Test across Create, Issue, Transfer, and GetBalance operations

**Invariant Check:**
Add assertion that item IDs in NFT symbols are stored in normalized form (no leading zeros except for "0" itself).

### Proof of Concept

**Initial State:**
- NFT collection "TEST-0" exists
- User has permission to create NFTs in the TEST collection (via SEED NFT or whitelist)

**Transaction Sequence:**

**Step 1:** Create first NFT with item ID "1"
```
Call: TokenContract.Create({
  Symbol: "TEST-1",
  TokenName: "Test Item #1",
  TotalSupply: 1,
  Decimals: 0,
  Issuer: UserAddress,
  Owner: UserAddress,
  IsBurnable: true,
  IssueChainId: CurrentChainId
})
```
**Result:** Transaction succeeds. NFT "TEST-1" is registered in `State.TokenInfos["TEST-1"]`

**Step 2:** Create duplicate NFT with item ID "01"
```
Call: TokenContract.Create({
  Symbol: "TEST-01",
  TokenName: "Test Item #1 (duplicate)",
  TotalSupply: 1,
  Decimals: 0,
  Issuer: UserAddress,
  Owner: UserAddress,
  IsBurnable: true,
  IssueChainId: CurrentChainId
})
```
**Expected Result:** Transaction should FAIL with "Token already exists" or "Invalid item ID format"

**Actual Result:** Transaction SUCCEEDS. NFT "TEST-01" is registered in `State.TokenInfos["TEST-01"]` as a completely separate token

**Step 3:** Verify both exist independently
```
Call: TokenContract.GetTokenInfo({ Symbol: "TEST-1" })
Returns: TokenInfo with Symbol="TEST-1", TotalSupply=1

Call: TokenContract.GetTokenInfo({ Symbol: "TEST-01" })
Returns: TokenInfo with Symbol="TEST-01", TotalSupply=1
```

**Success Condition:**
Both "TEST-1" and "TEST-01" exist as separate, independent NFTs that can be issued, transferred, and traded separately, violating the NFT uniqueness invariant. The same exploit works for "TEST-001", "TEST-0001", "TEST-00000000000001", etc., allowing unlimited duplicates.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L23-26)
```csharp
    private bool IsValidItemId(string symbolItemId)
    {
        return Regex.IsMatch(symbolItemId, "^[0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-116)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }

        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };

        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }

        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
        if (string.IsNullOrEmpty(State.NativeTokenSymbol.Value))
        {
            Assert(Context.Variables.NativeSymbol == input.Symbol, "Invalid native token input.");
            State.NativeTokenSymbol.Value = input.Symbol;
        }

        var systemContractAddresses = Context.GetSystemContractNameToAddressMapping().Select(m => m.Value);
        var isSystemContractAddress = input.LockWhiteList.All(l => systemContractAddresses.Contains(l));
        Assert(isSystemContractAddress, "Addresses in lock white list should be system contract addresses");
        foreach (var address in input.LockWhiteList) State.LockWhiteLists[input.Symbol][address] = true;

        Context.LogDebug(() => $"Token created: {input.Symbol}");

        Context.Fire(new TokenCreated
        {
            Symbol = tokenInfo.Symbol,
            TokenName = tokenInfo.TokenName,
            TotalSupply = tokenInfo.TotalSupply,
            Decimals = tokenInfo.Decimals,
            Issuer = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            ExternalInfo = tokenInfo.ExternalInfo,
            Owner = tokenInfo.Owner
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L15-55)
```csharp
    private Empty CreateNFTInfo(CreateInput input)
    {
        var nftCollectionInfo = AssertNftCollectionExist(input.Symbol);
        input.IssueChainId = input.IssueChainId == 0 ? nftCollectionInfo.IssueChainId : input.IssueChainId;
        Assert(
            input.IssueChainId == nftCollectionInfo.IssueChainId,
            "NFT issue ChainId must be collection's issue chainId");
        if (nftCollectionInfo.ExternalInfo != null && nftCollectionInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.NftCreateChainIdExternalInfoKey,
                out var nftCreateChainId) && long.TryParse(nftCreateChainId, out var nftCreateChainIdLong))
        {
            Assert(nftCreateChainIdLong == Context.ChainId,
                "NFT create ChainId must be collection's NFT create chainId");
        }
        else
        {
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
        }
        
        var owner = nftCollectionInfo.Owner ?? nftCollectionInfo.Issuer;
        Assert(Context.Sender == owner && owner == input.Owner, "NFT owner must be collection's owner");
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }

        return CreateToken(input, SymbolType.Nft);
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/SymbolValidationTest.cs (L7-23)
```csharp
public class SymbolValidationTest
{
    private const string RegexPattern = "^[a-zA-Z0-9]+(-[0-9]+)?$";

    [Theory]
    [InlineData("ELF", true)]
    [InlineData("ELF-", false)]
    [InlineData("ABC-123", true)]
    [InlineData("abc-1", true)]
    [InlineData("ABC-ABC", false)]
    [InlineData("ABC--", false)]
    [InlineData("121-1", true)]
    public void SymbolValidation(string symbol, bool isValid)
    {
        Regex.IsMatch(symbol, RegexPattern).ShouldBe(isValid);
    }
}
```
