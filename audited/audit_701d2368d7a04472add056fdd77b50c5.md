### Title
Missing Validation of Next Round Order Values Allows Consensus Manipulation

### Summary
The `ProcessUpdateValue` function directly assigns `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values from miner-provided `UpdateValueInput` without validating that they match the cryptographically-derived calculation from the miner's signature. A malicious miner can manipulate these order values to control mining slots in the next round, breaking the deterministic consensus ordering that AEDPoS relies upon for fair block production.

### Finding Description

**Root Cause: Unvalidated Direct Assignment**

In `ProcessUpdateValue`, the consensus order values are directly assigned from the miner-provided input without validation: [1](#0-0) 

Additionally, the `TuneOrderInformation` dictionary allows a miner to arbitrarily modify `FinalOrderOfNextRound` for ANY miner in the round: [2](#0-1) 

**Expected Calculation Exists But Not Enforced**

The correct calculation for `SupposedOrderOfNextRound` exists in `ApplyNormalConsensusData`, which derives it from the miner's signature hash and handles conflicts: [3](#0-2) 

This calculation is used when generating block header extra data, but is never validated against the values in `UpdateValueInput`.

**Broken Validation Logic**

The `ValidateConsensusAfterExecution` method attempts validation by comparing the header Round with the state Round after recovery: [4](#0-3) 

However, `RecoverFromUpdateValue` modifies and returns the same state object (`this`): [5](#0-4) 

This causes the validation to compare an object with itself, always resulting in equal hashes and passing validation regardless of whether the order values were manipulated.

The `UpdateValueValidationProvider` only checks that OutValue and Signature are filled, but does not validate the order values: [6](#0-5) 

**Direct Impact on Next Round**

The manipulated `FinalOrderOfNextRound` values are used directly in `GenerateNextRoundInformation` to determine mining order and time slots: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Breach**

A malicious miner can:
- Assign themselves `FinalOrderOfNextRound = 1` to mine first in the next round
- Set competing miners to high order numbers (e.g., 7, 8, 9 in a 10-miner setup) to mine last
- Use `TuneOrderInformation` to manipulate multiple miners' orders simultaneously
- Repeatedly exploit this across rounds to maintain mining advantage

**Concrete Harm**

1. **Block Production Control**: The attacker controls `ExpectedMiningTime` calculation, determining when each miner can produce blocks
2. **Revenue Manipulation**: Mining first provides MEV opportunities and ensures block rewards
3. **Consensus Disruption**: Breaks the fair round-robin schedule, potentially causing honest miners to miss time slots
4. **Chain Stability**: If order manipulation causes timing conflicts, blocks may be rejected or consensus may stall

**Affected Parties**
- All honest miners lose fair mining opportunities
- Users experience degraded chain performance
- The entire network's consensus integrity is compromised

This is a **CRITICAL** severity issue as it directly violates the "miner schedule integrity" invariant and allows consensus manipulation without requiring majority control.

### Likelihood Explanation

**Attacker Capabilities**

The attacker only needs to be an active miner (block producer) in the current round. No special privileges, governance control, or majority stake required.

**Attack Complexity: LOW**

1. Miner calls the public `UpdateValue` method with manipulated `UpdateValueInput`
2. Set own `SupposedOrderOfNextRound` to desired value (e.g., 1)
3. Include `TuneOrderInformation` to modify other miners' orders
4. Block is created and validated (validation passes due to broken logic)
5. State is updated with manipulated values
6. Next round uses these values for mining schedule

**Execution Practicality**

Entry point is the public `UpdateValue` method: [8](#0-7) 

All steps are executable under normal AElf contract semantics. The miner constructs the block locally, including both the header (which could still use honest values) and the transaction payload (with manipulated values).

**Detection Constraints**

The manipulation is difficult to detect because:
- Validation appears to pass successfully
- Order values look legitimate (integers 1-N)
- No events or logs indicate manipulation
- Only becomes apparent when analyzing next round's mining schedule

**Economic Rationality**

Attack cost is minimal (just transaction fees for UpdateValue). Benefit is immediate and recurring (first mining slot in subsequent rounds). The risk/reward is heavily skewed toward exploitation.

### Recommendation

**1. Enforce Cryptographic Validation**

In `ProcessUpdateValue`, calculate the expected `SupposedOrderOfNextRound` from the signature and validate it matches the provided value:

```csharp
// After line 245
var expectedSupposedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), 
    currentRound.RealTimeMinersInformation.Count) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedSupposedOrder,
    "Provided SupposedOrderOfNextRound does not match signature-derived value.");
```

**2. Validate TuneOrderInformation**

Verify that tuning is only applied to resolve actual conflicts detected in the current round state:

```csharp
// After line 258
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    var targetMiner = currentRound.RealTimeMinersInformation[tuneOrder.Key];
    // Only allow tuning if there's an actual conflict
    var hasConflict = currentRound.RealTimeMinersInformation.Values
        .Count(m => m.SupposedOrderOfNextRound == targetMiner.SupposedOrderOfNextRound) > 1;
    Assert(hasConflict || targetMiner.FinalOrderOfNextRound != targetMiner.SupposedOrderOfNextRound,
        "Cannot tune order without conflict.");
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**3. Fix Validation Logic**

In `ValidateConsensusAfterExecution`, clone the state before recovery to enable proper comparison:

```csharp
var originalRound = currentRound.Clone(); // Add Clone() call
if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
    headerInformation.Round = originalRound.RecoverFromUpdateValue(
        headerInformation.Round, headerInformation.SenderPubkey.ToHex());

if (headerInformation.Round.GetHash(isContainPreviousInValue) != 
    currentRound.GetHash(isContainPreviousInValue))
    // ... validation failure logic
```

**4. Add Invariant Checks**

Before adding round information, verify order uniqueness and range:

```csharp
var orders = currentRound.RealTimeMinersInformation.Values
    .Select(m => m.FinalOrderOfNextRound).ToList();
Assert(orders.Distinct().Count() == orders.Count, "Duplicate orders detected.");
Assert(orders.All(o => o >= 1 && o <= currentRound.RealTimeMinersInformation.Count),
    "Order values out of valid range.");
```

**5. Test Cases**

Add regression tests for:
- Miner providing incorrect `SupposedOrderOfNextRound` (should fail)
- Miner attempting to tune orders without conflicts (should fail)  
- Multiple miners with same `FinalOrderOfNextRound` (should fail)
- Order values outside valid range 1-N (should fail)

### Proof of Concept

**Initial State:**
- Round 100 active with 7 miners (pubkeys M1-M7)
- Malicious miner M1 has signature S1 that should calculate to order 5
- Honest orders should be: M1=5, M2=1, M3=2, M4=3, M5=4, M6=6, M7=7

**Attack Steps:**

1. M1 creates block and calls `UpdateValue` with manipulated input:
   - `SupposedOrderOfNextRound = 1` (instead of correct value 5)
   - `TuneOrderInformation = { "M2": 7, "M7": 5 }` (swapping competitors)

2. `ProcessUpdateValue` executes without validation:
   - Sets M1's orders to 1 (instead of 5)
   - Sets M2's FinalOrderOfNextRound to 7 (was 1)
   - Sets M7's FinalOrderOfNextRound to 5 (was 7)

3. Validation passes (compares object with itself)

4. State now has manipulated orders:
   - M1: FinalOrderOfNextRound=1 (manipulated)
   - M2: FinalOrderOfNextRound=7 (manipulated)
   - M3-M6: unchanged
   - M7: FinalOrderOfNextRound=5 (manipulated)

5. When round 101 is generated via `GenerateNextRoundInformation`:
   - M1 gets Order=1, ExpectedMiningTime=T+4000ms (first slot!)
   - M2 gets Order=7, ExpectedMiningTime=T+28000ms (last slot!)
   - M7 gets Order=5, ExpectedMiningTime=T+20000ms

**Expected Result:** M1 should mine 5th (T+20000ms) based on signature

**Actual Result:** M1 mines 1st (T+4000ms), gaining unfair advantage

**Success Condition:** M1 consistently mines first in subsequent rounds by repeating the attack, while honest miners like M2 are pushed to unfavorable slots.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-44)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
