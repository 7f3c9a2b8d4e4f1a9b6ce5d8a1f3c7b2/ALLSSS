# Audit Report

## Title
Parliament Proposal State Inconsistency Due to Dynamic Member List Evaluation

## Summary
The Parliament contract calculates proposal states (rejected/abstained/approved) dynamically using the current parliament member list, which changes between consensus terms. This allows proposals to transition between terminal states without any new votes, enabling rejected proposals to become releasable after parliament expansion or approved proposals to become non-releasable after parliament contraction.

## Finding Description

The vulnerability exists because the Parliament contract does not store a snapshot of parliament membership when proposals are created. The `ProposalInfo` structure only stores individual vote addresses (approvals, rejections, abstentions) but not the member count or member list at creation time. [1](#0-0) 

All proposal state calculations dynamically fetch the current parliament member list from the consensus contract. The `IsReleaseThresholdReached()` function calls `GetCurrentMinerList()` to obtain the current miners, then uses this list for all threshold checks. [2](#0-1) 

The `IsProposalRejected()` function counts how many rejection votes are from current parliament members, then compares this count against the threshold using the current member count: `rejectionMemberCount * AbstractVoteTotal > organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count`. [3](#0-2) 

Similarly, `IsProposalStillPending()` returns false (not pending) when `IsProposalRejected()` or `IsProposalAbstained()` return true, using the current member list. [4](#0-3) 

The `Release()` function only validates that `IsReleaseThresholdReached()` returns true, with no comparison to a membership snapshot. [5](#0-4) 

**Attack Execution Path:**
1. Proposal created with 10 parliament members, rejection threshold at 20%
2. 3 members reject the proposal: `3 * 10000 > 2000 * 10` → `30000 > 20000` → rejected
3. `IsReleaseThresholdReached()` returns false (cannot be released)
4. Consensus term change expands parliament to 20 members
5. Same 3 rejections now: `3 * 10000 > 2000 * 20` → `30000 > 40000` → not rejected
6. If proposal has sufficient approvals, it can now be released despite previous rejection

The parliament member list changes between consensus terms as confirmed by the `GetCurrentMinerList()` implementation which queries the consensus contract for current block producers. [6](#0-5) 

## Impact Explanation

**Governance Integrity Violation:**
This vulnerability breaks the fundamental governance invariant that proposal states should be stable once determined. A proposal explicitly rejected by parliament can later become executable without any new votes, purely due to external membership changes.

**Specific Impacts:**
1. **Governance Bypass**: Proposals rejected by a smaller parliament can become releasable when parliament expands, allowing execution of proposals the original parliament explicitly rejected
2. **Governance Denial of Service**: Proposals approved by a smaller parliament can become non-releasable when parliament expands, preventing execution of legitimately approved proposals  
3. **State Inconsistency**: The `GetProposal()` view function returns different `ToBeReleased` values at different times without any state changes to the proposal itself [7](#0-6) 

**Affected Parties:**
- Parliament members making governance decisions based on unstable proposal states
- Proposers whose proposals can flip between approved and rejected states
- Smart contracts and users relying on governance query functions for decision-making

The impact is classified as **HIGH** because it enables unauthorized execution of rejected governance proposals and breaks critical protocol invariants around governance finality.

## Likelihood Explanation

**Feasibility:**
- Parliament membership changes regularly during consensus term transitions (AEDPoS consensus updates miners every term)
- No special privileges required - any authorized proposer can create proposals
- Natural miner election dynamics create parliament size fluctuations
- Proposals with expiration times spanning multiple consensus terms are vulnerable

**Attack Complexity:**
- Low complexity - attacker creates proposal, waits for voting, then waits for favorable parliament size change
- No need to compromise trusted roles or manipulate consensus
- Attack can be passive (waiting for natural parliament fluctuations) or active (timing proposals around known election results)

**Preconditions:**
- Proposal expiration time must span multiple consensus terms (common for important governance decisions)
- Parliament membership must change significantly enough to cross thresholds
- Existing votes must be close to threshold boundaries

The likelihood is classified as **MEDIUM-HIGH** because parliament membership changes are a natural and frequent occurrence in the AEDPoS consensus system, making this vulnerability exploitable without requiring any abnormal protocol conditions.

## Recommendation

Store a snapshot of the parliament member count at proposal creation time and use this snapshot for all threshold calculations throughout the proposal's lifetime.

**Proposed Fix:**

1. Add a field to `ProposalInfo` to store the parliament member count at creation:
```protobuf
message ProposalInfo {
    // ... existing fields ...
    int32 parliament_member_count_at_creation = 14;
}
```

2. Store the count when creating proposals (in `CreateNewProposal()`):
```csharp
var parliamentMembers = GetCurrentMinerList();
var proposal = new ProposalInfo
{
    // ... existing fields ...
    ParliamentMemberCountAtCreation = parliamentMembers.Count
};
```

3. Modify threshold check functions to use the stored count:
```csharp
private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
    ICollection<Address> parliamentMembers)
{
    var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
    var memberCountToUse = proposal.ParliamentMemberCountAtCreation > 0 
        ? proposal.ParliamentMemberCountAtCreation 
        : parliamentMembers.Count;
    return rejectionMemberCount * AbstractVoteTotal >
           organization.ProposalReleaseThreshold.MaximalRejectionThreshold * memberCountToUse;
}
```

Apply similar changes to `IsProposalAbstained()`, `CheckEnoughVoteAndApprovals()`, and `IsVoteThresholdReached()` functions.

This ensures proposal states remain stable throughout their lifetime regardless of parliament membership changes.

## Proof of Concept

The vulnerability can be demonstrated through the following test scenario:

1. Initialize Parliament contract with 10 members and create an organization with 20% rejection threshold
2. Create a proposal with sufficient expiration time to span term changes
3. Have 3 parliament members reject the proposal (30% rejection rate)
4. Verify `IsReleaseThresholdReached()` returns false (proposal is rejected)
5. Simulate consensus term change by expanding parliament to 20 members
6. Verify `IsReleaseThresholdReached()` now returns different result with same votes
7. Demonstrate that a previously rejected proposal can now be released

The core issue is observable by comparing the result of threshold checks before and after parliament membership changes, with the same set of votes. The mathematical calculation `3 * 10000 > 2000 * memberCount` produces different boolean results (true vs false) when `memberCount` changes from 10 to 20, despite no new votes being cast.

### Citations

**File:** protobuf/parliament_contract.proto (L116-143)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L36-48)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var parliamentMembers = GetCurrentMinerList();
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L50-62)
```csharp
    private bool IsProposalStillPending(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return !CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L225-248)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = Validate(proposal) && IsReleaseThresholdReached(proposal, organization),
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```
