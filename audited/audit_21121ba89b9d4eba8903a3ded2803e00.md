### Title
Snapshot Carryforward Allows Vote Double-Counting Through Withdraw-Revote Cycle

### Summary
The TakeSnapshot() function carries forward VotesAmount from the previous snapshot to the next snapshot, but subsequent Withdraw() operations only update the original snapshot's VotingResult, not future snapshots that already inherited those votes. An attacker can exploit this by voting in snapshot N, waiting for TakeSnapshot(), withdrawing to unlock tokens, then voting again in snapshot N+1 to have their voting power counted twice using a single set of tokens.

### Finding Description

**Root Cause:**

When a vote is cast, the VotingRecord stores the current snapshot number: [1](#0-0) 

When TakeSnapshot() is called, it creates a new VotingResult for the next snapshot and explicitly carries forward the VotersCount and VotesAmount from the previous snapshot: [2](#0-1) 

However, when Withdraw() is called, it retrieves the VotingResult hash using the VotingRecord's original SnapshotNumber (from when the vote was cast): [3](#0-2) 

This means the withdrawal only updates the VotingResult for the snapshot in which the vote was originally cast, not any future snapshots that already carried forward that vote's contribution.

**Why Protections Fail:**

There is no mechanism to propagate withdrawal updates to future snapshots that have already inherited the VotesAmount through carryforward. The VotingResult for each snapshot is independent, and the carryforward happens as a one-time copy operation during TakeSnapshot(). Once copied, future snapshots maintain their own state that is not retroactively adjusted when votes from previous snapshots are withdrawn.

**Execution Path:**

1. Attacker calls Vote() in snapshot N → VotingResult[N].VotesAmount += X, tokens locked
2. Sponsor calls TakeSnapshot() → VotingResult[N+1] created with VotesAmount = VotingResult[N].VotesAmount (includes X)
3. Attacker calls Withdraw() → VotingResult[N].VotesAmount -= X, tokens unlocked, VotingResult[N+1].VotesAmount unchanged
4. Attacker calls Vote() in snapshot N+1 → VotingResult[N+1].VotesAmount += X
5. Final state: VotingResult[N+1].VotesAmount counts X twice (carried forward + new vote)

### Impact Explanation

**Direct Harm:**
- Attackers can multiply their voting power by up to the number of snapshots in a voting item
- With N snapshots, an attacker with X tokens can achieve up to N×X voting power by repeatedly withdrawing and re-voting across snapshot boundaries
- This allows manipulation of voting outcomes in governance decisions, parameter changes, or resource allocation votes

**Quantified Damage:**
- If a voting item has 5 snapshots and an attacker has 1,000 tokens, they can achieve 5,000 effective voting power in the final snapshot
- Only requires gas fees for withdraw and vote transactions; no additional token acquisition needed
- Can determine election results, proposal approvals, or fund distribution decisions

**Affected Parties:**
- All participants in multi-snapshot voting items
- Governance processes relying on accurate vote counts
- Any contract or system depending on Vote contract results for decision-making

**Severity Justification:**
High severity due to direct manipulation of voting outcomes with minimal cost, undermining the fundamental integrity of the voting system and any governance mechanisms that rely on it.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires only basic voter permissions (any user can vote if they have tokens)
- No privileged access needed beyond normal voting rights
- Can execute from any standard account

**Attack Complexity:**
- Low complexity: vote, wait for snapshot, withdraw, vote again
- All operations are standard public functions
- Timing is predictable as TakeSnapshot() is called by the sponsor at known intervals
- Can be automated and repeated across multiple snapshots

**Feasibility Conditions:**
- Voting item must have multiple snapshots (TotalSnapshotNumber > 1)
- Attacker must hold tokens accepted by the voting item
- Requires sponsor to call TakeSnapshot() between exploit steps (normal operation)
- No special state or permission requirements

**Detection/Operational Constraints:**
- Difficult to detect as all transactions appear legitimate
- Each vote has a unique VoteId, making it appear as separate votes
- Withdraw and re-vote patterns may not raise suspicion in multi-snapshot voting
- VotingResult state appears internally consistent within each snapshot

**Probability Reasoning:**
High likelihood of exploitation for any multi-snapshot voting item where stakes are significant, as the attack is straightforward, economically rational (minimal gas cost for potentially large governance influence), and difficult to prevent or detect without code changes.

### Recommendation

**Code-Level Mitigation:**

Modify the TakeSnapshot() function to NOT carry forward VotesAmount and VotersCount. Instead, each snapshot should start fresh, and voters who want their votes to persist must re-vote in each snapshot or the contract should explicitly track and transfer active votes:

Option 1: Reset counts in new snapshots
```
State.VotingResults[currentVotingGoingHash] = new VotingResult
{
    VotingItemId = input.VotingItemId,
    SnapshotNumber = nextSnapshotNumber,
    SnapshotStartTimestamp = Context.CurrentBlockTime,
    VotersCount = 0,  // Start fresh
    VotesAmount = 0   // Start fresh
};
```

Option 2: Track active votes and properly propagate withdrawals to all affected snapshots by maintaining a global active vote registry and updating all future snapshots when a vote is withdrawn.

**Invariant Checks to Add:**

1. Verify that total locked tokens for a voting item equals the sum of VotesAmount across all active (non-withdrawn) VotingRecords
2. Add assertions that VotesAmount in snapshot N+1 ≥ VotesAmount in snapshot N only if new votes were actually cast
3. Implement a tracking mechanism for which VoteIds contribute to each snapshot's results

**Test Cases to Prevent Regression:**

1. Test case: Vote in snapshot 1, take snapshot, withdraw, vote in snapshot 2 → verify snapshot 2 VotesAmount does not double-count
2. Test case: Vote in snapshot 1, take snapshot, verify snapshot 2 starts with zero VotesAmount (if using Option 1)
3. Test case: Multiple withdraw-revote cycles across snapshots → verify final VotesAmount matches actual locked tokens
4. Test case: Concurrent votes and withdrawals around snapshot boundaries → verify consistency

### Proof of Concept

**Required Initial State:**
- Voting item registered with TotalSnapshotNumber = 2 or more
- Attacker has 100 tokens of AcceptedCurrency
- IsLockToken = true for the voting item

**Transaction Steps:**

1. **Initial Vote (Snapshot 1):**
   - Attacker calls `Vote(votingItemId, voterAddress, 100, "OptionA", voteId1)`
   - VotingResult[snapshot 1]: {VotesAmount: 100, Results["OptionA"]: 100}
   - Token lock: 100 tokens locked with voteId1

2. **Sponsor Takes Snapshot:**
   - Sponsor calls `TakeSnapshot(votingItemId, 1)`
   - VotingResult[snapshot 2] created: {VotesAmount: 100, VotersCount: 1} (carried forward)
   - CurrentSnapshotNumber incremented to 2

3. **Withdraw Original Vote:**
   - Attacker calls `Withdraw(voteId1)`
   - VotingResult[snapshot 1]: {VotesAmount: 0} (updated)
   - VotingResult[snapshot 2]: {VotesAmount: 100} (UNCHANGED - vulnerability)
   - Token lock: 100 tokens unlocked

4. **Vote Again (Snapshot 2):**
   - Attacker calls `Vote(votingItemId, voterAddress, 100, "OptionA", voteId2)`
   - VotingResult[snapshot 2]: {VotesAmount: 200, Results["OptionA"]: 100} (100 carried + 100 new)
   - Token lock: 100 tokens locked with voteId2

**Expected vs Actual Result:**

Expected: VotingResult[snapshot 2].VotesAmount should be 100 (only the new vote)

Actual: VotingResult[snapshot 2].VotesAmount is 200 (carried forward 100 + new 100)

**Success Condition:**
Query `GetVotingResult(votingItemId, 2)` returns VotesAmount = 200 while only 100 tokens are actually locked, demonstrating the attacker has achieved 2× voting power using a single set of tokens.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L105-115)
```csharp
        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-222)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```
