# Audit Report

## Title
Missing IsWithdrawn Check Allows Double Withdrawal and Vote Count Manipulation in Delegated Voting

## Summary
The `Withdraw()` function in VoteContract lacks validation to prevent withdrawing an already-withdrawn vote. In delegated voting scenarios (IsLockToken = false), multiple successful withdrawals corrupt vote accounting in both VoteContract and ElectionContract before SafeMath.Sub() eventually reverts on underflow. This critically affects the Election contract's miner selection process.

## Finding Description

**Root Cause:** The `Withdraw()` function in VoteContract processes withdrawal operations without checking if `votingRecord.IsWithdrawn` is already true. [1](#0-0) 

The function sets the IsWithdrawn flag at line 203 but never validates it beforehand. The only validation performed is permission checking at lines 197-200, which verifies the caller is authorized but does not check withdrawal state. [2](#0-1) 

**Two Vulnerability Paths:**

**Path A - IsLockToken = true (Regular Voting):** Protected. Second withdrawal attempts fail at the token unlock operation (lines 224-231) because tokens were already unlocked in the first call, causing the entire transaction to revert.

**Path B - IsLockToken = false (Delegated Voting):** VULNERABLE. The token unlock code (lines 224-231) is skipped entirely when IsLockToken is false. [3](#0-2) 

Each successful withdrawal call:
- Removes from ActiveVotes list (no-op after first removal at line 210)
- Adds to WithdrawnVotes creating duplicates (line 211)
- Decrements `Results[option]` (lines 215-216)
- Decrements `VotesAmount` (line 220) [4](#0-3) 

**Election Contract Vulnerability:** The Election contract registers its voting item with `IsLockToken = false`, making it vulnerable to this attack. [5](#0-4) 

The Election contract's Withdraw method also lacks IsWithdrawn validation. It decrements vote counters (lines 644-646 for voter, lines 656-659 for candidate) without checking if the vote was already withdrawn, then calls VoteContract.Withdraw which further corrupts accounting. [6](#0-5) 

**Why SafeMath Doesn't Prevent This:** While SafeMath.Sub() uses checked arithmetic and throws OverflowException on underflow [7](#0-6) , this only prevents the transaction from succeeding once the counter would go negative. Multiple malicious withdrawals succeed before hitting the underflow threshold, corrupting vote accounting.

**Attack Scenario:**
1. Attacker casts multiple votes totaling 350 tokens (e.g., VoteA: 100, VoteB: 50, VoteC: 200)
2. After lock time expires, attacker calls ElectionContract.Withdraw(VoteA) 
   - ElectionContract: ActiveVotedVotesAmount = 350 - 100 = 250 ✓
   - VoteContract: VotesAmount decremented, Results[option] decremented ✓
3. Attacker calls ElectionContract.Withdraw(VoteA) AGAIN
   - ElectionContract: ActiveVotedVotesAmount = 250 - 100 = 150 ✓ (CORRUPTED)
   - VoteContract: Counters decremented AGAIN ✓ (CORRUPTED)
4. Attacker calls ElectionContract.Withdraw(VoteA) AGAIN
   - ElectionContract: ActiveVotedVotesAmount = 150 - 100 = 50 ✓ (CORRUPTED)
   - VoteContract: Counters decremented AGAIN ✓ (CORRUPTED)
5. Fourth call would trigger underflow (50 - 100 = -50) and revert

By this point, vote accounting has been corrupted three times, incorrectly decrementing:
- Voter's ActiveVotedVotesAmount by 200 extra tokens
- Candidate's ObtainedActiveVotedVotesAmount by 200 extra tokens
- VotingResult's VotesAmount and Results[option] by 200 extra tokens

## Impact Explanation

**Direct Governance Impact:**
- Corrupts critical election metrics: `VotesAmount`, `Results[option]`, `ActiveVotedVotesAmount`, `ObtainedActiveVotedVotesAmount`
- Election contract's miner selection relies on `ObtainedActiveVotedVotesAmount` to rank candidates
- Artificially deflated vote counts could change which candidates are elected as consensus miners
- Affects consensus integrity by manipulating who participates in block production

**Affected Systems:**
- **Election Contract:** Miner election tallies become incorrect, potentially affecting consensus miner selection
- **Voting Results:** Vote counts no longer reflect actual active votes
- **Data Center Rankings:** Corrupted vote amounts affect data center ranking calculations
- **Any delegated voting system:** Any contract using IsLockToken = false is vulnerable

**Severity: HIGH**
- Breaks critical invariant: VotesAmount must equal sum of active votes
- Directly manipulates consensus through election vote corruption
- Simple to execute with only transaction fee costs
- No special privileges required beyond normal voter participation

## Likelihood Explanation

**Attacker Capabilities:** 
- Any voter who has cast votes in the Election contract can exploit this after lock time expires
- No special privileges or setup required beyond normal voting participation

**Attack Complexity: LOW**
- Simply call `Withdraw(voteId)` multiple times with the same vote ID
- No cryptographic exploits or race conditions needed
- Repeatable until underflow occurs

**Feasibility: VERY HIGH**
- Election contract is the primary production contract for miner selection
- All voters have multiple active votes (common voting pattern)
- Lock time expiration is a normal, expected event
- No detection mechanisms in place

**Detection Constraints:**
- Vote counts gradually diverge from actual votes
- May not be immediately obvious until significant corruption
- Event logs show multiple Withdrawn events for same vote ID (detectable post-facto)

**Probability: HIGH** for delegated voting (Election contract), NONE for regular locked token voting (protected by token unlock failure)

## Recommendation

Add IsWithdrawn validation at the start of both VoteContract.Withdraw and ElectionContract.Withdraw:

**VoteContract.Withdraw fix:**
```csharp
public override Empty Withdraw(WithdrawInput input)
{
    var votingRecord = State.VotingRecords[input.VoteId];
    if (votingRecord == null) throw new AssertionException("Voting record not found.");
    
    // ADD THIS CHECK
    Assert(!votingRecord.IsWithdrawn, "Vote already withdrawn.");
    
    var votingItem = State.VotingItems[votingRecord.VotingItemId];
    // ... rest of function
}
```

**ElectionContract.Withdraw fix:**
```csharp
public override Empty Withdraw(Hash input)
{
    var votingRecord = State.VoteContract.GetVotingRecord.Call(input);
    
    // ADD THIS CHECK
    Assert(!votingRecord.IsWithdrawn, "Vote already withdrawn.");
    
    var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
    // ... rest of function
}
```

Alternatively, check if the vote is in ActiveVotingRecordIds before processing:
```csharp
Assert(voterVotes.ActiveVotingRecordIds.Contains(input), "Vote not active or already withdrawn.");
```

## Proof of Concept

```csharp
[Fact]
public async Task DoubleWithdrawal_CorruptsVoteAccounting_Test()
{
    // Setup: Announce candidate and cast multiple votes
    const int voteAmount1 = 100;
    const int voteAmount2 = 200;
    const int lockTime = 7 * 60 * 60 * 24;
    
    var candidateKeyPair = ValidationDataCenterKeyPairs[0];
    await AnnounceElectionAsync(candidateKeyPair);
    var voterKeyPair = VoterKeyPairs[0];
    var candidateStringKey = candidateKeyPair.PublicKey.ToHex();
    
    // Cast two votes from same voter
    var voteResult1 = await VoteToCandidateAsync(voterKeyPair, candidateStringKey, lockTime, voteAmount1);
    var voteId1 = Hash.Parser.ParseFrom(voteResult1.ReturnValue);
    
    var voteResult2 = await VoteToCandidateAsync(voterKeyPair, candidateStringKey, lockTime, voteAmount2);
    var voteId2 = Hash.Parser.ParseFrom(voteResult2.ReturnValue);
    
    // Get initial vote counts
    var candidateVoteBefore = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue { Value = candidateStringKey });
    var initialVoteAmount = candidateVoteBefore.ObtainedActiveVotedVotesAmount;
    initialVoteAmount.ShouldBe(voteAmount1 + voteAmount2);
    
    // Advance time past lock period
    BlockTimeProvider.SetBlockTime(StartTimestamp.AddSeconds(lockTime + 1));
    
    // First withdrawal (legitimate)
    var withdrawResult1 = await WithdrawVotes(voterKeyPair, voteId1);
    withdrawResult1.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var candidateVoteAfterFirst = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue { Value = candidateStringKey });
    candidateVoteAfterFirst.ObtainedActiveVotedVotesAmount.ShouldBe(voteAmount2); // Only vote2 remains
    
    // Second withdrawal of SAME vote (malicious) - should fail but doesn't
    var withdrawResult2 = await WithdrawVotes(voterKeyPair, voteId1);
    withdrawResult2.Status.ShouldBe(TransactionResultStatus.Mined); // BUG: Succeeds!
    
    // Vote counts are now corrupted
    var candidateVoteAfterDouble = await ElectionContractStub.GetCandidateVote.CallAsync(new StringValue { Value = candidateStringKey });
    
    // CORRUPTION: Should be voteAmount2 (200), but is actually 100 due to double withdrawal
    candidateVoteAfterDouble.ObtainedActiveVotedVotesAmount.ShouldBe(voteAmount2 - voteAmount1);
    
    // This proves vote accounting is corrupted by double withdrawal
    candidateVoteAfterDouble.ObtainedActiveVotedVotesAmount.ShouldBeLessThan(voteAmount2);
}
```

## Notes

This vulnerability specifically affects delegated voting scenarios where `IsLockToken = false`. The Election contract, which is critical for consensus miner selection, uses this mode and is therefore vulnerable. Regular voting with `IsLockToken = true` is protected because the token unlock operation would fail on the second withdrawal attempt, causing the entire transaction to revert before any state corruption occurs.

The vulnerability exists in both the VoteContract and ElectionContract, requiring fixes in both locations to fully address the issue.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L191-239)
```csharp
    public override Empty Withdraw(WithdrawInput input)
    {
        var votingRecord = State.VotingRecords[input.VoteId];
        if (votingRecord == null) throw new AssertionException("Voting record not found.");
        var votingItem = State.VotingItems[votingRecord.VotingItemId];

        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");

        // Update VotingRecord.
        votingRecord.IsWithdrawn = true;
        votingRecord.WithdrawTimestamp = Context.CurrentBlockTime;
        State.VotingRecords[input.VoteId] = votingRecord;

        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);

        var votedItems = State.VotedItemsMap[votingRecord.Voter];
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].ActiveVotes.Remove(input.VoteId);
        votedItems.VotedItemVoteIds[votingItem.VotingItemId.ToHex()].WithdrawnVotes.Add(input.VoteId);
        State.VotedItemsMap[votingRecord.Voter] = votedItems;

        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;

        if (votingItem.IsLockToken)
            State.TokenContract.Unlock.Send(new UnlockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                Amount = votingRecord.Amount,
                LockId = input.VoteId
            });

        Context.Fire(new Withdrawn
        {
            VoteId = input.VoteId
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L60-68)
```csharp
        var votingRegisterInput = new VotingRegisterInput
        {
            IsLockToken = false,
            AcceptedCurrency = Context.Variables.NativeSymbol,
            TotalSnapshotNumber = long.MaxValue,
            StartTimestamp = TimestampHelper.MinValue,
            EndTimestamp = TimestampHelper.MaxValue
        };
        State.VoteContract.Register.Send(votingRegisterInput);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-678)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```
