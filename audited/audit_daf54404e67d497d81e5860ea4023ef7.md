### Title
Unauthorized Round Termination by Non-Extra-Block-Producer Miners

### Summary
The consensus behavior determination logic in `ConsensusBehaviourProviderBase` does not verify that a miner is the designated extra block producer before allowing them to generate NextRound/NextTerm commands. Any miner who has completed their normal block production can prematurely terminate the round, violating the intended round progression rules where only the extra block producer should terminate rounds.

### Finding Description

The vulnerability exists in the consensus command generation flow:

**Root Cause Location:**
The `GetConsensusBehaviour()` method returns termination behaviors without verifying the miner's role: [1](#0-0) 

When a miner has already produced their block (`OutValue != null`) and their time slot has passed, the method directly returns `GetConsensusBehaviourToTerminateCurrentRound()` which yields `NextRound` or `NextTerm` behavior, without checking if the miner is the designated extra block producer.

**Strategy Selection Without Validation:**
The `ConsensusCommandProvider` wrapper directly instantiates strategies based on the behavior provided: [2](#0-1) 

The private `GetConsensusCommand` method creates termination strategies for any miner: [3](#0-2) 

**Insufficient Validation:**
The validation system has multiple validators but none check extra block producer authorization:

- `MiningPermissionValidationProvider` only checks miner list membership: [4](#0-3) 

- `TimeSlotValidationProvider` for new rounds only validates time slot spacing, not current miner authorization: [5](#0-4) 

- `RoundTerminateValidationProvider` only checks round/term number increments: [6](#0-5) 

**Execution Path:**
The public entry point accepts any miner's request: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
- Any miner who has completed their normal block can prematurely terminate the round before other miners have their turn
- The round progression rules require that only the designated extra block producer (determined by `CalculateNextExtraBlockProducerOrder`) should produce the terminating block
- Premature termination disrupts the intended mining schedule where each miner gets their allocated time slot

**Operational Disruption:**
- Other miners lose their opportunity to mine blocks in the current round
- The fair rotation of mining responsibilities is compromised
- Mining reward distribution becomes unfair as some miners miss their slots

**Potential Fork Risk:**
- Multiple miners could attempt to terminate the round simultaneously
- Different nodes might accept different terminating blocks
- Consensus could diverge if timing conditions allow competing termination blocks

**Severity:** High - This violates the critical invariant of "correct round transitions and miner schedule integrity"

### Likelihood Explanation

**Attacker Capabilities:**
- Any registered miner in the current round can exploit this
- No special permissions beyond being in the miner list required
- The miner only needs to have produced their normal block first

**Attack Complexity:** 
- Low - The miner simply calls the public `GetConsensusCommand` method after producing their normal block
- The behavior is automatically determined by the `ConsensusBehaviourProviderBase`
- No complex transaction sequences or state manipulation required

**Feasibility Conditions:**
- Miner must be in current round's miner list
- Miner must have already produced their normal block (`OutValue != null`)
- Current time must be past the miner's normal time slot
- The actual extra block producer must not have produced the terminating block yet

**Economic Rationality:**
- Attacker gains unfair advantage by denying other miners their time slots
- Could manipulate which miners participate in round completion
- Minimal cost (just normal block production) for significant disruption

**Probability:** High - This can occur naturally when miners' behavior provider logic triggers inappropriately, or intentionally by malicious miners seeking unfair advantage.

### Recommendation

**Add Extra Block Producer Validation:**

1. In `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`, add a check before returning termination behavior:
   - Verify that the current miner's `IsExtraBlockProducer` flag is true in the current round
   - Only return `GetConsensusBehaviourToTerminateCurrentRound()` if the miner is authorized

2. Add a new validation provider `ExtraBlockProducerValidationProvider` to be used for `NextRound` and `NextTerm` behaviors:
   - Validate that `validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey].IsExtraBlockProducer == true`
   - Register this validator in the switch statement at lines 77-92 of `AEDPoSContract_Validation.cs`

3. Add time slot validation for extra block production:
   - Verify that current block time is within the extra block time slot
   - Use logic similar to `IsCurrentMiner` method to check extra block time slot: [8](#0-7) 

**Test Cases:**
- Non-extra-block-producer attempts to produce NextRound block → should fail validation
- Extra block producer produces NextRound block outside their time slot → should fail validation
- Extra block producer produces NextRound block in correct time slot → should succeed

### Proof of Concept

**Initial State:**
- Round N with 5 miners: A, B, C, D, E
- Miner E is designated as extra block producer
- Each miner has a 4-second time slot
- Current round start time: T0

**Attack Sequence:**

1. **T0+4s**: Miner A produces their normal UpdateValue block successfully
2. **T0+8s**: Miner B produces their normal UpdateValue block successfully  
3. **T0+9s**: Miner B's time slot has passed
4. **T0+9s**: Miner B calls `GetConsensusCommand(BytesValue{B's pubkey})`
5. **Behavior Determination**: `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` executes:
   - Checks: B's `OutValue != null` ✓ (B already mined)
   - Checks: B's time slot passed ✓ (`_isTimeSlotPassed == true`)
   - Returns: `GetConsensusBehaviourToTerminateCurrentRound()` → `NextRound`
6. **Strategy Creation**: `TerminateRoundCommandStrategy` created with `NextRound` behavior
7. **Command Generated**: Consensus command for NextRound returned to Miner B
8. **Block Production**: Miner B produces a NextRound block at T0+9s
9. **Validation**: All validators pass:
   - `MiningPermissionValidationProvider`: B is in miner list ✓
   - `TimeSlotValidationProvider`: New round's time slots are valid ✓
   - `RoundTerminateValidationProvider`: Round number increments by 1 ✓
10. **Block Accepted**: NextRound block is accepted and round terminates

**Expected Result:** Only Miner E (extra block producer) should be able to terminate the round at T0+24s (after all miners have their slots)

**Actual Result:** Miner B successfully terminates the round at T0+9s, causing:
- Miners C, D miss their time slots entirely
- Miner E never gets to produce the extra block
- Round N is prematurely terminated
- Round N+1 starts immediately with incorrect timing

**Success Condition:** The NextRound block produced by non-extra-block-producer Miner B is accepted by the network, violating the round progression rules.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusCommandProvider.cs (L15-18)
```csharp
        public ConsensusCommandProvider(ICommandStrategy commandStrategy)
        {
            _commandStrategy = commandStrategy;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
