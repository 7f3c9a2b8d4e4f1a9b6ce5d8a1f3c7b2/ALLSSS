### Title
Missing Upper Bound Validation for Irreversible Block Heights in LIB Validation

### Summary
The `LibInformationValidationProvider.ValidateHeaderInformation()` method only validates that irreversible block heights do not decrease, but fails to verify they don't exceed the current block height. A malicious miner can inject inflated `ImpliedIrreversibleBlockHeight` values pointing to non-existent future blocks, which pass validation and corrupt consensus contract state, potentially causing consensus instability.

### Finding Description

The vulnerability exists in the `LibInformationValidationProvider` class where validation only checks backward movement of block heights: [1](#0-0) 

The validation logic checks three conditions:
1. That `ConfirmedIrreversibleBlockHeight` doesn't decrease
2. That `ConfirmedIrreversibleBlockRoundNumber` doesn't decrease  
3. That individual miner's `ImpliedIrreversibleBlockHeight` doesn't decrease

**Root Cause:** There is no upper bound validation to ensure these height values are less than or equal to `Context.CurrentHeight`. The code only prevents backward movement, not forward manipulation.

**How Heights Are Set:** During normal consensus data generation, the contract sets: [2](#0-1) 

This correctly uses `Context.CurrentHeight`, but a malicious miner modifying their node can inject arbitrary higher values.

**Processing Flow:** During block execution, the inflated value gets written directly to state: [3](#0-2) 

The LIB calculation then uses these potentially inflated values from miners to compute the confirmed irreversible block: [4](#0-3) 

**Why Existing Protections Fail:**

The `ValidateConsensusAfterExecution` performs hash comparison but this doesn't catch the issue because if both the consensus header and transaction input contain the same inflated value, the hashes will match: [5](#0-4) 

The hash includes `ImpliedIrreversibleBlockHeight` as confirmed by the GetCheckableRound implementation: [6](#0-5) 

The field is NOT cleared during hash computation (only EncryptedPieces, DecryptedPieces, ActualMiningTimes, and optionally PreviousInValue are cleared), so matching inflated values in header and state will produce matching hashes.

### Impact Explanation

**Consensus State Corruption:**
When inflated `ImpliedIrreversibleBlockHeight` values are accepted, the consensus contract's `ConfirmedIrreversibleBlockHeight` can point to blocks that don't exist yet (heights greater than current chain height). This creates a fundamental inconsistency between consensus contract state and actual blockchain state.

**Event Processing Failure:**
The `IrreversibleBlockFoundLogEventProcessor` attempts to retrieve the block hash at the calculated LIB height: [7](#0-6) 

For a future block height, this returns null and the processor exits early. The chain's actual LIB remains unchanged, but the consensus contract state contains the invalid LIB reference.

**Validation Cascade:**
Future blocks will validate against the corrupted `baseRound` containing inflated LIB values. This affects the `LibInformationValidationProvider` which compares new blocks' LIB values against this corrupted baseline, potentially accepting or rejecting blocks incorrectly.

**Consensus Instability:**
The confirmed irreversible block height is used throughout consensus logic including round generation, term transitions, and cross-chain indexing. An inflated value disrupts these mechanisms, potentially causing:
- Incorrect round transition logic
- Invalid cross-chain merkle proofs referencing non-existent blocks
- Desynchronization between consensus participants

**Severity:** Medium - While it requires node modification and potentially collusion, it directly violates the critical invariant of "LIB height rules" under Consensus & Cross-Chain integrity, causing operational impact on consensus flow stability.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to modify consensus contract behavior or node consensus data generation logic
- For individual `ImpliedIrreversibleBlockHeight` manipulation: single malicious miner
- For `ConfirmedIrreversibleBlockHeight` manipulation to exceed current height: requires 2/3 miner collusion based on the LIB calculation algorithm: [8](#0-7) 

**Attack Complexity:** 
- Medium - Requires modifying the node software to inject inflated heights during consensus data generation
- The attack vector is straightforward: change the value set at line 118 of GetConsensusBlockExtraData.cs
- No complex timing or race conditions required

**Feasibility Conditions:**
- Attacker controls miner node(s) with ability to modify consensus behavior
- For maximum impact (ConfirmedIrreversibleBlockHeight corruption): needs coalition of 2/3+ miners
- For proof-of-vulnerability (ImpliedIrreversibleBlockHeight corruption): single miner sufficient

**Detection Constraints:**
- The validation passes all existing checks
- Would only be detected through careful state monitoring comparing consensus contract LIB with actual chain LIB
- No immediate consensus failure occurs, making detection non-trivial

**Economic Rationality:**
- Low cost to execute (software modification only)
- No direct economic gain, primarily a griefing/disruption attack
- Could be used to cause consensus instability before or during other attacks

**Probability Assessment:** Medium likelihood - while requiring node modification, the lack of any upper bound validation makes this a straightforward attack for any miner willing to run modified software.

### Recommendation

**Immediate Fix:**
Add upper bound validation in `LibInformationValidationProvider.ValidateHeaderInformation()`:

1. **Add ImpliedIrreversibleBlockHeight upper bound check:**
   After line 29, add validation that compares each miner's implied height against a reasonable upper bound (current block height or slightly above to account for network delays).

2. **Add ConfirmedIrreversibleBlockHeight upper bound check:**
   In the first validation block (lines 14-21), add a check ensuring `providedRound.ConfirmedIrreversibleBlockHeight <= Context.CurrentHeight`.

3. **Add ConfirmedIrreversibleBlockRoundNumber sanity check:**
   Validate that the round number is not unreasonably far in the future compared to current round.

**Suggested Implementation Pattern:**
```
// After existing backward checks, add:
if (providedRound.ConfirmedIrreversibleBlockHeight > Context.CurrentHeight) {
    validationResult.Message = "LIB height cannot exceed current block height.";
    return validationResult;
}

// For implied heights:
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > Context.CurrentHeight) {
    validationResult.Message = "Implied LIB height cannot exceed current block height.";
    return validationResult;
}
```

**Additional Safeguards:**
- Consider adding block existence validation by checking if a block hash exists at the claimed LIB height
- Add monitoring/alerting when consensus contract LIB significantly diverges from chain LIB
- Add integration test cases that attempt to inject inflated LIB heights and verify they're rejected

**Test Cases to Add:**
1. Attempt to provide `ImpliedIrreversibleBlockHeight` > `Context.CurrentHeight` - should fail validation
2. Attempt to provide `ConfirmedIrreversibleBlockHeight` > `Context.CurrentHeight` - should fail validation
3. Verify that LIB can only reference blocks that actually exist in the chain
4. Test that validation properly handles edge cases around current height

### Proof of Concept

**Initial State:**
- Chain at height 1000
- Current round with valid LIB at height 950
- Attacker controls one miner node

**Attack Steps:**

1. **Modify Miner Node:**
   Modify the consensus data generation to set inflated ImpliedIrreversibleBlockHeight:
   - Change line 118 in `AEDPoSContract_GetConsensusBlockExtraData.cs`
   - Set: `updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight + 100;`
   - This results in ImpliedIrreversibleBlockHeight = 1100 when producing block at height 1000

2. **Produce Block:**
   - Attacker's miner produces a block when their time slot arrives
   - Consensus header contains Round with ImpliedIrreversibleBlockHeight = 1100
   - UpdateValue transaction contains ImpliedIrreversibleBlockHeight = 1100

3. **Validation Passes:**
   - `LibInformationValidationProvider` checks if 1100 < baseRound's implied height (false, as this is first time) - PASSES
   - No check exists for upper bound
   - `ValidateConsensusAfterExecution` hash comparison - PASSES (both header and state have 1100)

4. **State Corruption:**
   - `ProcessUpdateValue` writes ImpliedIrreversibleBlockHeight = 1100 to consensus state
   - Consensus contract state now references future block 1100
   - `IrreversibleBlockFoundLogEventProcessor` fails to find block at height 1100, exits silently
   - Chain's actual LIB remains at 950, but consensus contract believes LIB is higher

**Expected vs Actual Result:**
- **Expected:** Validation should reject any LIB height > current block height
- **Actual:** Inflated LIB height of 1100 is accepted and stored in consensus contract state, creating state inconsistency

**Success Condition:**
Query `GetCurrentRoundInformation()` and observe `RealTimeMinersInformation[attackerPubkey].ImpliedIrreversibleBlockHeight` equals 1100, which is greater than current chain height, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-30)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L63-65)
```csharp
            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```
