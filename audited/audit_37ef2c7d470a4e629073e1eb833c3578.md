# Audit Report

## Title
Unvalidated Decrypted Secret Pieces Enable Secret Sharing Corruption in AEDPoS Consensus

## Summary
The AEDPoS consensus contract accepts and stores decrypted secret pieces from miners without cryptographic validation, allowing malicious miners to inject arbitrary data that corrupts Shamir's Secret Sharing reconstruction. This breaks the Byzantine fault tolerance guarantees of the secret sharing scheme and corrupts the consensus randomness mechanism.

## Finding Description

The vulnerability exists in how the contract processes decrypted secret pieces for Shamir's Secret Sharing reconstruction:

**Vulnerable Storage Path:**
When miners produce blocks with `UpdateValue` behavior, they submit `DecryptedPieces` in their transaction input. The contract stores these pieces without any validation: [1](#0-0) 

The function only checks if the target miner exists in the round but performs NO validation that:
1. The decrypted piece is actually a correct decryption of the corresponding encrypted piece
2. The submitting miner legitimately received an encrypted piece from that target
3. The decrypted data is cryptographically valid

Similarly, in `UpdateLatestSecretPieces`: [2](#0-1) 

**Attack Execution:**
1. Malicious Miner M produces a block in Round N
2. M submits arbitrary garbage data in `UpdateValueInput.DecryptedPieces`, claiming these are decrypted pieces of other miners' secrets
3. These fake pieces are stored in the on-chain Round state
4. When Round N+1 starts, the contract fires `SecretSharingInformation` event with the poisoned Round N data: [3](#0-2) 

5. Honest miners' off-chain `SecretSharingService` receives this event and attempts reconstruction using ALL DecryptedPieces from state (including the fake ones): [4](#0-3) 

6. The Shamir reconstruction produces a WRONG InValue because of the corrupted piece
7. This wrong value gets submitted as a RevealedInValue and set as PreviousInValue without validation: [5](#0-4) 

**Why Existing Protections Fail:**
The only validation that exists checks if a miner's DIRECTLY submitted PreviousInValue matches their previous OutValue: [6](#0-5) 

However, this validation:
- Only applies to the sender's OWN PreviousInValue
- Does NOT validate PreviousInValues set through secret sharing reconstruction (via RevealedInValues)
- Does NOT validate DecryptedPieces against encrypted pieces

## Impact Explanation

**Critical Consensus Integrity Violation:**
The corrupted PreviousInValue is used in signature calculations for consensus randomness: [7](#0-6) 

The signature is computed by XORing the InValue with all miners' signatures, creating the randomness beacon that determines miner ordering and consensus fairness. A corrupted PreviousInValue directly corrupts this randomness chain.

**Secret Sharing Security Breakdown:**
The Shamir Secret Sharing scheme is designed to provide Byzantine fault tolerance - secrets can be reconstructed if 2/3 of miners cooperate honestly. However, this vulnerability allows a SINGLE malicious miner to:
- Inject fake pieces that corrupt reconstruction for ALL targeted miners
- Break the threshold security guarantee (which requires 1/3 Byzantine tolerance)
- Make the secret sharing mechanism unreliable for randomness generation

**Network-Wide DoS:**
When secret sharing is enabled, legitimate miners' InValues cannot be correctly revealed through reconstruction, causing consensus degradation across the entire network.

## Likelihood Explanation

**Attacker Requirements:**
- Must be a miner in the consensus set (achievable through normal election/staking)
- No special privileges beyond normal mining rights
- Secret sharing must be enabled (controlled by configuration)

**Attack Complexity: LOW**
- Simply submit arbitrary bytes in `UpdateValueInput.DecryptedPieces` during normal block production
- No cryptographic operations required by attacker
- No coordination with other parties needed
- Single transaction execution

**Detection Difficulty: HIGH**
- No on-chain validation exists to detect malicious pieces
- Off-chain services decrypt pieces correctly but cannot prevent on-chain corruption
- Detection requires manual analysis comparing revealed InValues against original OutValues
- The attack silently corrupts consensus randomness without obvious failures

**Economic Rationality:**
- Attack cost: Near-zero (normal block production costs)
- Attack impact: Disrupts consensus for entire network
- Risk/reward heavily favors attack execution

## Recommendation

Implement cryptographic validation for decrypted pieces:

1. **Verify Decryption Correctness:** Before storing DecryptedPieces, verify they are correct decryptions of the corresponding EncryptedPieces using the sender's public key
2. **Validate Revealed InValues:** When setting PreviousInValues from RevealedInValues, validate that `Hash(revealedInValue) == previousOutValue` for the target miner
3. **Add Threshold Validation:** Verify that sufficient valid decrypted pieces exist before allowing reconstruction
4. **Implement Piece Authentication:** Add cryptographic signatures or MACs to decrypted pieces to prove they came from legitimate decryption

Modified validation in `UpdateLatestSecretPieces`:
```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        // VALIDATE against OutValue from previous round
        if (TryToGetPreviousRoundInformation(out var prevRound) &&
            prevRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = prevRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
                continue; // Skip invalid revealed value
        }
        
        if ((updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
             updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
            updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

## Proof of Concept

The vulnerability can be demonstrated with this test scenario:

1. Setup: 3 miners in consensus, secret sharing enabled
2. Round N: Honest Miner A produces block, publishes OutValue_A = Hash(InValue_A), shares encrypted pieces
3. Round N: Malicious Miner M produces block, submits `UpdateValueInput` with fake DecryptedPieces[A] = random_garbage
4. Round N: Fake piece stored in state via `PerformSecretSharing` without validation
5. Round N+1: When `AddRoundInformation` fires `SecretSharingInformation` event, it includes Round N with poisoned DecryptedPieces
6. Round N+1: Honest Miner B's off-chain `SecretSharingService.RevealPreviousInValues` reads poisoned pieces from event
7. Round N+1: Reconstruction: `SecretSharingHelper.DecodeSecret(pieces_including_fake_from_M, ...)` produces wrong_InValue ≠ InValue_A
8. Round N+1: Verify: `Hash(wrong_InValue) ≠ OutValue_A` - proves corruption
9. Round N+1: Wrong value submitted as RevealedInValue[A] and set as PreviousInValue without validation
10. Result: Consensus randomness corrupted, secret sharing security broken

The test would verify that the reconstructed InValue does not hash to the original OutValue, proving the secret sharing corruption allows consensus randomness manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L110-115)
```csharp
            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L172-176)
```csharp
            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
