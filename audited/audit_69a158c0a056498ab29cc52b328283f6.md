### Title
Secret Sharing Validation Bypass Allows Mining Order Manipulation

### Summary
The AEDPoS consensus contract fails to validate that reconstructed InValues from secret sharing pieces match the previously published OutValues. A malicious miner can publish an OutValue while providing encrypted pieces of a different value, allowing them to manipulate their mining order in subsequent rounds and undermining the randomness guarantees of the consensus protocol.

### Finding Description

**Root Cause:** Missing validation in secret sharing revelation logic

The vulnerability exists in the `RevealSharedInValues` method where InValues are reconstructed from encrypted/decrypted pieces without validating that the reconstructed value matches the OutValue published in the previous round. [1](#0-0) 

When secret sharing pieces are revealed, the reconstructed InValue is computed from decrypted pieces and directly assigned to `PreviousInValue` without any check that `Hash(reconstructed_InValue) == published_OutValue`.

**Why Existing Protections Fail:**

The `UpdateValueValidationProvider` only validates voluntarily provided PreviousInValues: [2](#0-1) 

This validation has multiple early returns (`return true`) that allow null or empty PreviousInValues to pass. More critically, it only validates PreviousInValues that miners explicitly provide in their UpdateValue transactions, not values set by the `RevealSharedInValues` mechanism.

**Execution Path:**

1. During `UpdateValue`, encrypted pieces are added without validation: [3](#0-2) 

2. During `NextRound`, `RevealSharedInValues` is called to reconstruct InValues: [4](#0-3) 

3. The revealed InValue directly affects signature calculation: [5](#0-4) 

4. The signature determines mining order for the next round: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation:** A malicious miner can manipulate their position in the mining schedule by providing fraudulent encrypted pieces that don't correspond to their published OutValue. This undermines the core randomness mechanism of AEDPoS consensus.

**Specific Harms:**
- **Mining Order Manipulation**: Attacker can influence their `supposedOrderOfNextRound` by controlling the InValue that affects signature calculation
- **Fairness Violation**: The deterministic mining order based on XOR of signatures becomes predictable/manipulable for the attacker
- **Strategic Advantage**: Attacker could gain earlier time slots, enabling them to produce more blocks or perform other strategic actions
- **Protocol Degradation**: If multiple miners exploit this, the consensus mechanism's security assumptions break down

**Severity Justification:** HIGH - This directly compromises consensus integrity, a critical invariant. While it doesn't immediately steal funds, it gives attackers unfair advantages in block production and violates the protocol's randomness guarantees.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the consensus round
- Needs ability to generate and sign UpdateValue transactions
- No special permissions or admin access required

**Attack Complexity:** LOW
1. Generate legitimate InValue and OutValue = Hash(InValue)
2. Create encrypted pieces from a DIFFERENT value (not the InValue that hashes to OutValue)
3. Submit UpdateValue with correct OutValue but fraudulent encrypted pieces
4. Wait for NextRound when pieces are revealed without validation

**Feasibility Conditions:**
- Works whenever secret sharing is enabled [7](#0-6) 

**Detection Difficulty:** HARD - The encrypted pieces appear valid cryptographically, only the semantic relationship to OutValue is incorrect, which requires off-chain monitoring to detect.

**Probability:** HIGH - Any miner can execute this attack at any time with no additional cost beyond normal mining operations.

### Recommendation

**Immediate Fix:** Add validation in `RevealSharedInValues` to verify reconstructed InValues match published OutValues:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL: Validate that revealed InValue matches the published OutValue
var publishedOutValue = anotherMinerInPreviousRound.OutValue;
if (publishedOutValue != null && publishedOutValue != Hash.Empty && 
    revealedInValue != publishedOutValue)
{
    Context.LogDebug(() => $"Revealed InValue {revealedInValue} does not match published OutValue {publishedOutValue} for miner {publicKeyOfAnotherMiner}");
    continue; // Skip setting invalid PreviousInValue
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Additional Validation:** Add similar checks in `UpdateLatestSecretPieces`: [8](#0-7) 

Validate that each revealed InValue matches the corresponding OutValue from the previous round before setting it.

**Test Cases:** Add regression tests that:
1. Verify encrypted pieces that don't correspond to OutValue are rejected
2. Confirm legitimate secret sharing continues to work
3. Test edge cases where miners provide both voluntary PreviousInValue and secret sharing reveals different values

### Proof of Concept

**Initial State:**
- Blockchain at Round N with 5 active miners
- Attacker is Miner A with valid mining rights
- Secret sharing is enabled

**Attack Sequence:**

1. **Round N - Attacker publishes malicious data:**
   - Attacker generates: `InValue_real = Hash("legitimate_secret")`
   - Computes: `OutValue = Hash(InValue_real) = 0xABCD...`
   - BUT encrypts pieces of: `InValue_fake = Hash("different_secret")`
   - Submits UpdateValue with `OutValue = 0xABCD...` and encrypted pieces of `InValue_fake`
   - Transaction succeeds, validation passes

2. **Round N+1 - Manipulation revealed:**
   - NextRound is triggered by any miner
   - `RevealSharedInValues` is called
   - Decrypted pieces reconstruct: `reconstructed = Hash(DecodeSecret(pieces)) = Hash(InValue_fake) = 0x1234...`
   - **No validation occurs:** System doesn't check if `0x1234... == 0xABCD...`
   - `reconstructed` is set as PreviousInValue for Miner A

3. **Round N+1 - Impact on consensus:**
   - Signature calculation: `sig = XOR(PreviousInValue_manipulated, other_signatures)`
   - Mining order: `order = abs(sig.ToInt64()) % 5 + 1`
   - Attacker's order is based on manipulated value, not the legitimate InValue

**Expected Result:** Validation should reject mismatched encrypted pieces

**Actual Result:** Mismatched pieces are accepted, allowing mining order manipulation

**Success Condition:** Attacker successfully sets an arbitrary PreviousInValue that doesn't match their published OutValue, affecting their mining position in Round N+2.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
