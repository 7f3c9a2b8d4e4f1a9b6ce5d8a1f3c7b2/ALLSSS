### Title
Missing Round Number Validation in UpdateValue/TinyBlock Consensus Recovery Allows Cross-Round Data Corruption

### Summary
The consensus validation logic for UpdateValue and TinyBlock behaviors fails to verify that the provided round information matches the current round number before applying recovery operations. An attacker can submit consensus data from a different round with a crafted RoundId, causing the validation to use corrupted state and bypassing critical time slot checks, enabling unauthorized mining outside designated time slots and consensus schedule violations.

### Finding Description

**Root Cause:**

The validation flow in `ValidateBeforeExecution` fetches the current round from state (baseRound) and unconditionally applies recovery from the attacker-provided round data without checking round number consistency. [1](#0-0) 

The recovery functions `RecoverFromUpdateValue` and `RecoverFromTinyBlock` only check if the miner's pubkey exists in both rounds, but never validate that the round numbers match: [2](#0-1) [3](#0-2) 

These recovery operations copy critical consensus data (OutValue, Signature, PreviousInValue, ImpliedIrreversibleBlockHeight, ActualMiningTimes, SupposedOrderOfNextRound, FinalOrderOfNextRound) from the provided round into baseRound, creating a corrupted hybrid state mixing data from different rounds.

**Why Existing Protections Fail:**

1. **No Round Number Check:** The `RoundTerminateValidationProvider` validates round numbers for NextRound/NextTerm behaviors but explicitly skips this check for UpdateValue/TinyBlock: [4](#0-3) 

2. **RoundId Check is Bypassable:** `TimeSlotValidationProvider` checks RoundId (computed as sum of expected mining times), not RoundNumber: [5](#0-4) 

The RoundId property is a computed sum that can be manipulated: [6](#0-5) 

An attacker can craft a Round object with arbitrary ExpectedMiningTimes that sum to match the current round's RoundId, bypassing this check.

3. **Input RoundId Field Never Validated:** Both `UpdateValueInput` and `TinyBlockInput` contain round_id fields intended for validation: [7](#0-6) [8](#0-7) 

However, `ProcessUpdateValue` and `ProcessTinyBlock` never check these fields against the current round: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Consensus Integrity Violation:**

By providing round data from a different round (e.g., round N-1 when current is round N) with matching RoundId, an attacker corrupts the validation state. This enables:

1. **Time Slot Validation Bypass:** The `CheckMinerTimeSlot` validation uses baseRound.ActualMiningTimes, which after recovery contains stale data from the wrong round: [11](#0-10) 

This allows mining outside the designated time slot, breaking the consensus schedule.

2. **Round Ordering Corruption:** Recovery copies SupposedOrderOfNextRound and FinalOrderOfNextRound from the wrong round for all miners, corrupting the mining order calculation for subsequent rounds.

3. **LIB Height Manipulation:** ImpliedIrreversibleBlockHeight from a different round can be injected, affecting irreversible block calculations.

**Severity: High** - Violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity" and enables unauthorized block production that disrupts consensus ordering and fairness.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a miner in multiple consecutive rounds (common for stable validators)
- Can craft arbitrary Round objects in consensus header extra data
- Can compute RoundId values to match target by adjusting ExpectedMiningTimes

**Attack Complexity:**
- Medium: Requires understanding of RoundId calculation and round structure
- No special privileges beyond being a miner
- Can be automated once understood

**Feasibility:**
- High: The attack path is straightforward:
  1. Miner is active in rounds N-1 and N
  2. Craft Round object with RoundNumber = N-1, data from round N-1
  3. Adjust ExpectedMiningTimes so sum equals round N's RoundId
  4. Submit UpdateValue/TinyBlock transaction with crafted round
  5. Validation uses corrupted baseRound, allowing invalid operations
  6. Execute mining operation that would normally fail time slot checks

**Detection:**
- Low detectability: Transaction appears normal, only header validation logic sees the manipulation
- No on-chain evidence of round number mismatch since it's never checked or logged

### Recommendation

**Immediate Fix:**

Add explicit round number validation in `ValidateBeforeExecution` before calling recovery functions:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
{
    if (extraData.Round.RoundNumber != baseRound.RoundNumber)
        return new ValidationResult { Success = false, Message = "Round number mismatch in UpdateValue." };
    baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
}

if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    if (extraData.Round.RoundNumber != baseRound.RoundNumber)
        return new ValidationResult { Success = false, Message = "Round number mismatch in TinyBlock." };
    baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
}
```

**Additional Validations:**

Validate the input.RoundId field in `ProcessUpdateValue` and `ProcessTinyBlock`:

```csharp
// In ProcessUpdateValue
TryToGetCurrentRoundInformation(out var currentRound);
if (updateValueInput.RoundId != 0 && updateValueInput.RoundId != currentRound.RoundId)
    Assert(false, "RoundId mismatch in UpdateValue.");

// In ProcessTinyBlock  
TryToGetCurrentRoundInformation(out var currentRound);
if (tinyBlockInput.RoundId != 0 && tinyBlockInput.RoundId != currentRound.RoundId)
    Assert(false, "RoundId mismatch in TinyBlock.");
```

**Test Cases:**

Add regression tests that:
1. Attempt UpdateValue with round data from previous round - should fail
2. Attempt TinyBlock with round data from future round - should fail
3. Attempt UpdateValue with matching RoundNumber but different RoundId - should fail
4. Verify ActualMiningTimes corruption doesn't occur during validation

### Proof of Concept

**Initial State:**
- Current round: N (RoundNumber = 10, RoundId = 1000)
- Attacker is miner in rounds 9 and 10
- Attacker's time slot in round 10: already passed (time slot validation would normally fail)

**Attack Steps:**

1. **Craft Malicious Round Object:**
   - Copy round 9 structure (RoundNumber = 9)
   - Set attacker's ActualMiningTimes to times from round 9 (within valid range)
   - Adjust all miners' ExpectedMiningTimes so sum = 1000 (matches round 10's RoundId)
   - Include this in AElfConsensusHeaderInformation.Round

2. **Submit UpdateValue Transaction:**
   - Behavior: UpdateValue
   - Consensus header extra data: Contains crafted round from step 1
   - UpdateValueInput: Normal consensus values

3. **Validation Flow:**
   - `ValidateBeforeExecution` fetches baseRound (round 10)
   - Calls `baseRound.RecoverFromUpdateValue(craftedRound, attackerPubkey)`
   - Recovery copies ActualMiningTimes from round 9 into baseRound
   - `TimeSlotValidationProvider.ValidateHeaderInformation` executes
   - RoundId check: craftedRound.RoundId (1000) == baseRound.RoundId (1000) ✓
   - `CheckMinerTimeSlot` uses baseRound.ActualMiningTimes (now contains round 9 data)
   - Time slot validation passes incorrectly ✓
   - Validation succeeds

4. **Expected Result:** Transaction should be rejected due to round number mismatch

5. **Actual Result:** Transaction validates successfully and executes, allowing the attacker to mine outside their designated time slot

**Success Condition:** Attacker successfully produces a block during UpdateValue/TinyBlock despite being outside their valid time slot, proving time slot validation was bypassed via cross-round data corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** protobuf/aedpos_contract.proto (L360-369)
```text
message TinyBlockInput {
    // The round id.
    int64 round_id = 1;
    // The actual mining time.
    google.protobuf.Timestamp actual_mining_time = 2;
    // Count of blocks currently produced
    int64 produced_blocks = 3;
    // The random number.
    bytes random_number = 4;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```
