# Audit Report

## Title
Term Number Regression Attack in NextRound Validation Allows Manipulation of Term Transition Logic

## Summary
The `ValidationForNextRound` method in `RoundTerminateValidationProvider` fails to validate that the `TermNumber` field remains unchanged during NextRound transitions. A malicious miner can submit a NextRound transaction with a manipulated TermNumber, which passes validation and gets stored in state, causing the consensus term transition detection logic to use the incorrect value and malfunction.

## Finding Description

The vulnerability exists in the consensus round validation logic. The `ValidationForNextRound` method only validates two aspects: (1) round number increments by 1, and (2) InValues are null, but **does NOT validate that the TermNumber stays the same**. [1](#0-0) 

In contrast, `ValidationForNextTerm` properly validates the term number increment. [2](#0-1) 

When a NextRound transaction is processed, the Round object (with its embedded TermNumber) is stored directly in state without term number validation. [3](#0-2) 

The `ProcessNextRound` method only updates the round number, not the term number. [4](#0-3) 

This creates an inconsistency: `State.CurrentTermNumber.Value` remains correct, but the Round object's embedded TermNumber can be manipulated.

The critical impact occurs because the consensus behavior provider uses the Round's embedded TermNumber to determine when to trigger term changes. [5](#0-4) 

The `NeedToChangeTerm` method calculates whether it's time to change terms using the Round's TermNumber. [6](#0-5) 

The `IsTimeToChangeTerm` calculation depends on the correct termNumber value. [7](#0-6) 

If a malicious miner manipulates the TermNumber field (e.g., changes from 5 to 3), the term change detection calculation uses the wrong value, causing it to trigger term transitions at incorrect times.

## Impact Explanation

**Consensus Integrity Violation**: A malicious miner can manipulate when term transitions occur by regressing or advancing the TermNumber in NextRound transactions. This breaks the fundamental consensus invariant that term transitions should occur at predictable time intervals.

**Concrete Harm**:

1. **Forced Premature Term Changes**: By decreasing the TermNumber (e.g., from 5 to 3), the attacker makes `IsTimeToChangeTerm` think we're in an earlier term, causing it to trigger a term change earlier than scheduled.

2. **Delayed Legitimate Term Changes**: By increasing the TermNumber, the attacker can prevent term changes from occurring when they should.

3. **Disrupted Elections**: Term changes trigger election snapshots and miner list updates. [8](#0-7)  Manipulating timing affects which candidates become validators.

4. **Reward Misallocation**: Term transitions trigger mining reward distributions and treasury releases tied to term numbers. [9](#0-8) 

5. **Statistics Manipulation**: Miner statistics (produced blocks, missed time slots) are reset at term boundaries. [10](#0-9) 

**Affected Parties**: All network participants, as consensus integrity affects block production, validator selection, and economic rewards.

**Severity Justification**: CRITICAL - This is a consensus-level vulnerability that allows any miner to manipulate the core term transition mechanism, with direct impact on elections, governance, and economic distributions.

## Likelihood Explanation

**Attacker Capabilities**: Any active miner in the validator set can exploit this. The attacker only needs to modify their consensus extra data generation to produce a Round with a manipulated TermNumber.

**Attack Complexity**: LOW
- Attacker generates consensus extra data with custom TermNumber
- Submits NextRound transaction during their time slot
- No complex preconditions or multi-step sequences required

**Feasibility Conditions**: 
- Attacker must be an active miner (has block production rights)
- Must be their turn in the consensus schedule
- Must have access to modify consensus transaction generation code

**Detection Constraints**: The manipulation may not be immediately obvious since `State.CurrentTermNumber.Value` remains correct - only the embedded Round.TermNumber is wrong. This creates subtle inconsistencies that could persist undetected.

**Probability**: HIGH - Any malicious or compromised miner can execute this attack during any of their scheduled blocks, with immediate effect on subsequent term transition logic.

## Recommendation

Add TermNumber validation to the `ValidationForNextRound` method in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // ADD THIS: Validate TermNumber remains unchanged
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Term number must not change during NextRound." };
    
    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

This ensures that during NextRound transitions, the TermNumber field must remain equal to the current round's TermNumber, preventing manipulation.

## Proof of Concept

```csharp
[Fact]
public async Task TermNumberRegressionAttack_ShouldFail()
{
    // Setup: Initialize consensus with term 5, round 100
    var currentRound = new Round 
    { 
        RoundNumber = 100, 
        TermNumber = 5,
        RealTimeMinersInformation = { /* miner data */ }
    };
    
    // Attack: Malicious miner submits NextRound with decreased TermNumber
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = 101,
        TermNumber = 3,  // MANIPULATED: decreased from 5 to 3
        RealTimeMinersInformation = { /* valid miner data with null InValues */ }
    };
    
    // Expected: Validation should REJECT this
    // Actual: ValidationForNextRound ACCEPTS it (only checks round number and InValues)
    var validationResult = await ConsensusStub.NextRound.SendAsync(maliciousNextRound);
    
    // Verify the attack succeeds (vulnerability exists)
    validationResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify manipulated TermNumber is stored
    var storedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    storedRound.TermNumber.ShouldBe(3);  // Manipulated value stored!
    
    // Verify term transition logic now uses wrong TermNumber
    // This causes IsTimeToChangeTerm to calculate with TermNumber=3 instead of 5
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L178-183)
```csharp
        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```
