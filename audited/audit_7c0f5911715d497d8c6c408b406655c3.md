### Title
Incomplete Validation of MinerInRound Fields in NextRound Allows Reward Manipulation and False Evil Miner Detection

### Summary
The consensus validation logic for `NextRound` behavior fails to validate critical `MinerInRound` fields (`ProducedBlocks`, `MissedTimeSlots`, `Order`, `IsExtraBlockProducer`) in the provided Round object. A malicious extra block producer can manipulate these fields to steal mining rewards, falsely mark honest miners as evil, or avoid punishment for their own missed time slots, causing direct economic harm and consensus integrity violations.

### Finding Description

The vulnerability exists in the validation pipeline for `NextRound` consensus behavior. When validating the `ProvidedRound` object within `NextRoundInput`, the system only performs limited checks: [1](#0-0) 

The validation providers check:
1. **RoundTerminateValidationProvider**: Only validates round number increment and that `InValue` fields are null [2](#0-1) 

2. **NextRoundMiningOrderValidationProvider**: Only validates that `FinalOrderOfNextRound` counts match miners with `OutValue` [3](#0-2) 

**Critical Gap**: The `MinerInRound` structure contains 17 fields per miner, but only 3 fields (`InValue`, `OutValue`, `FinalOrderOfNextRound`) are validated for NextRound: [4](#0-3) 

Specifically, the following critical fields are **NOT validated**:
- `produced_blocks` (line 280): Used for reward distribution
- `missed_time_slots` (line 282): Used for evil miner detection  
- `order` (line 268): Determines mining schedule
- `is_extra_block_producer` (line 270): Grants extra block mining rights

During `ProcessNextRound`, the unvalidated input is directly converted and stored: [5](#0-4) 

The `ToRound()` method performs no validation, just field copying: [6](#0-5) 

The manipulated data is then persisted to state without any verification: [7](#0-6) 

### Impact Explanation

**1. Reward Theft via ProducedBlocks Manipulation**

The Treasury contract uses `ProducedBlocks` directly to calculate mining reward shares: [8](#0-7) 

The share calculation penalizes miners with low block production: [9](#0-8) 

An attacker can:
- Inflate their own `ProducedBlocks` to claim maximum rewards
- Deflate competitors' `ProducedBlocks` to reduce their share below the `average/2` threshold (line 837), causing them to receive zero rewards

**Example**: In a 21-miner network, if average production is 100 blocks/term, an attacker could set their value to 200 (doubling their share) and set 10 competitors to 40 (zeroing their rewards), stealing approximately 50% of the reward pool intended for those miners.

**2. False Evil Miner Detection via MissedTimeSlots Manipulation**

The consensus contract uses `MissedTimeSlots` to detect and punish evil miners: [10](#0-9) 

Evil miners detected during NextRound are banned from the Election contract: [11](#0-10) 

An attacker can:
- Inflate competitors' `MissedTimeSlots` to falsely trigger evil miner detection and ban them
- Deflate their own `MissedTimeSlots` to avoid legitimate punishment

**3. Mining Schedule Disruption**

By manipulating `Order` and `IsExtraBlockProducer`, attackers can disrupt the fair mining rotation, potentially creating continuous block production or denying time slots to honest miners.

**Affected Parties**: All network participants suffer from unfair reward distribution, and honest miners can be falsely banned, causing economic loss and network centralization.

### Likelihood Explanation

**Attacker Capabilities**: 
- Attacker must be selected as extra block producer for a round
- This happens regularly in rotation based on deterministic calculation [12](#0-11) 

**Attack Complexity**: LOW
1. Attacker receives legitimate `NextRoundInput` from consensus data generation: [13](#0-12) 

2. Attacker modifies protobuf fields before transaction submission (trivial operation)
3. Submit modified `NextRound` transaction
4. Validation passes all checks (proven by code analysis)
5. Manipulated data persists in state

**Execution Practicality**: The attack is fully executable within AElf contract semantics. The NextRound method is a public entry point that processes user-provided data.

**Economic Rationality**: Attack cost is one transaction gas fee. Potential gain is significant mining rewards over multiple terms. Return on investment is extremely favorable.

**Detection Difficulty**: Requires off-chain monitoring comparing provided values against expected values calculated from previous round state. No automatic on-chain detection exists.

### Recommendation

**Immediate Fix**: Add comprehensive validation of all critical `MinerInRound` fields in `NextRoundInput` against the current round state.

**Implementation in ValidateBeforeExecution for NextRound behavior**:

1. Add a new validation provider `NextRoundMinerDataValidationProvider` that:
   - Validates `ProducedBlocks` matches current round's values (carried forward from `GenerateNextRoundInformation`)
   - Validates `MissedTimeSlots` matches current round's values plus increments for miners who didn't mine
   - Validates `Order` assignments match the expected order calculation
   - Validates `IsExtraBlockProducer` matches the calculated extra block producer

2. Compare provided Round's `RealTimeMinersInformation` against expected values generated from current round:
   ```
   // In new validation provider:
   - Get current round from state
   - Call GenerateNextRoundInformation on current round
   - Compare each miner's ProducedBlocks, MissedTimeSlots, Order, IsExtraBlockProducer
   - Reject if any discrepancies found
   ```

3. Register this provider in the validation pipeline: [14](#0-13) 

**Test Cases**:
- Test NextRound with manipulated ProducedBlocks (should fail validation)
- Test NextRound with manipulated MissedTimeSlots (should fail validation)
- Test NextRound with incorrect Order values (should fail validation)
- Test NextRound with wrong IsExtraBlockProducer flag (should fail validation)
- Test legitimate NextRound still succeeds

### Proof of Concept

**Initial State**:
- Network with 5 miners: A, B, C, D, E
- Current round 10 completed
- Miner E is extra block producer
- Actual block production: A=20, B=20, C=20, D=20, E=19
- Actual missed slots: A=0, B=0, C=0, D=0, E=1

**Attack Sequence**:

1. Honest system generates NextRoundInput for round 11: [15](#0-14) 

2. Attacker E intercepts and modifies before submission:
   - E's ProducedBlocks: 19 → 40 (doubled)
   - B's ProducedBlocks: 20 → 8 (reduced)
   - B's MissedTimeSlots: 0 → 200 (set above threshold)
   - E's MissedTimeSlots: 1 → 0 (hidden)

3. Attacker submits modified NextRound transaction

4. Validation executes but only checks round number and InValue nulls - passes

5. ProcessNextRound stores manipulated data: [16](#0-15) 

**Expected Result**: Validation should reject due to mismatched field values

**Actual Result**: 
- Validation passes
- Manipulated round 11 stored in state
- Miner B marked as evil and banned from network
- At next term transition, E receives inflated reward share while B receives zero
- E avoids punishment for their own missed slot

**Success Condition**: Round 11 in state contains manipulated `ProducedBlocks` and `MissedTimeSlots` values different from legitimate calculation, and B is incorrectly banned while E receives unearned rewards.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L789-821)
```csharp
        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```
