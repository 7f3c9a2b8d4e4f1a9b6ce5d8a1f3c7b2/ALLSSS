### Title
Invalid/Null Addresses in OrganizationMemberList Bypass Validation and Break Voting Thresholds

### Summary
The `CreateOrganization()` function validates that the `OrganizationMemberList` is not empty and contains no duplicates, but fails to validate that individual addresses are non-null and non-empty. This allows creation of organizations with null or default Address instances, which inflates the member count used for threshold calculations while these invalid addresses can never vote, rendering proposals permanently unapprovable.

### Finding Description

The vulnerability exists in the validation logic of the Association contract. The `CreateOrganization()` function creates an organization and validates it using the `Validate()` method: [1](#0-0) 

The `Validate()` function performs several checks on the organization, including checking if the member list is empty or contains duplicates: [2](#0-1) 

However, the validation only calls `Empty()` and `AnyDuplicate()` on the member list. The `Empty()` method simply checks if the count is zero: [3](#0-2) 

**Root Cause**: There is no validation that individual addresses in the `OrganizationMemberList.OrganizationMembers` collection are non-null and have non-empty values. In protobuf3, the Address type is a reference type that can be null, and Address instances can have empty `Value` fields: [4](#0-3) 

The proper validation pattern used elsewhere in the codebase validates both null and empty conditions: [5](#0-4) 

This validation is completely absent from the Association contract's member list validation.

### Impact Explanation

**Operational Impact - DoS of Governance Functions**:

When an organization is created with invalid (null/default) addresses in the member list:

1. The `organizationMemberCount` used in threshold validation includes these invalid addresses, inflating the total count.

2. The voting threshold checks rely on this inflated count: [6](#0-5) 

3. During voting operations (Approve/Reject/Abstain), the authorization check verifies if the sender is in the member list: [7](#0-6) 

4. When counting votes for proposal release, the system counts how many voters are valid members: [8](#0-7) 

**Concrete Impact**: Since null/default addresses cannot correspond to any real `Context.Sender` (no one holds keys for these addresses), they can never vote. If an organization is created with 3 valid members and 2 invalid addresses, setting `MinimalVoteThreshold = 4` will pass validation (4 â‰¤ 5), but proposals can never collect 4 votes since only 3 valid members exist. This permanently disables the organization's ability to pass proposals, effectively DoS-ing the governance mechanism.

**Severity**: Medium - While this doesn't lead to fund theft or unauthorized execution, it causes permanent operational failure of the affected organization's governance, requiring redeployment with a new organization address.

### Likelihood Explanation

**Highly Feasible Attack**:

1. **Reachable Entry Point**: `CreateOrganization()` is a public function callable by any user without special permissions.

2. **Attacker Capabilities**: An attacker only needs to construct a `CreateOrganizationInput` message with a `RepeatedField<Address>` containing null or default Address instances. This is trivial in protobuf3 where reference types can be null.

3. **Execution Practicality**: The attack requires a single transaction with no preconditions. The attacker can create the malicious organization input and submit it directly.

4. **Economic Rationality**: The attack costs only transaction fees (minimal) and can permanently disable an organization, potentially causing significant operational disruption if the organization controls important governance functions.

5. **Detection**: The vulnerability would be difficult to detect before proposals fail, as the organization appears valid with a non-zero member count.

### Recommendation

**Immediate Fix**: Add address validation in the `Validate()` method to check each member address:

Add validation in `contract/AElf.Contracts.Association/Association_Helper.cs` after line 66:

```csharp
// Validate each member address is non-null and non-empty
foreach (var member in organization.OrganizationMemberList.OrganizationMembers)
{
    if (member == null || member.Value.IsNullOrEmpty())
        return false;
}
```

**Additional Validations**: Apply the same validation to:
- `AddMember()` function to prevent adding invalid addresses later
- `ChangeMember()` function to validate the new member address [9](#0-8) 

**Test Cases**: Add regression tests that attempt to:
1. Create organization with null address in member list - should fail
2. Create organization with default Address (empty Value) in member list - should fail
3. Add invalid member to existing organization - should fail
4. Change member to invalid address - should fail

### Proof of Concept

**Initial State**: None required - fresh contract deployment

**Attack Sequence**:
1. Attacker constructs `CreateOrganizationInput` with:
   - `OrganizationMemberList.OrganizationMembers`: [ValidAddress1, ValidAddress2, ValidAddress3, null, DefaultAddress()]
   - `MinimalApprovalThreshold`: 3
   - `MinimalVoteThreshold`: 4 (based on 5 "members")
   - `MaximalAbstentionThreshold`: 1
   - `MaximalRejectionThreshold`: 1

2. Attacker calls `CreateOrganization(input)`

3. **Expected Result**: Transaction should fail with "Invalid organization."

4. **Actual Result**: Transaction succeeds, organization is created with address returned

5. **Verification**: 
   - Create a proposal in the organization
   - Have all 3 valid members approve
   - Attempt to release proposal
   - Result: Release fails with "Not approved" because only 3 votes collected, but `MinimalVoteThreshold` requires 4
   - Proposal is permanently stuck

**Success Condition**: The organization is created but all proposals become unreleasable due to impossible voting thresholds, confirming the DoS vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-58)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L12-15)
```csharp
    public bool Empty()
    {
        return Count() == 0;
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L868-871)
```csharp
        foreach (var address in input.Addresses)
        {
            Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.");
        }
```
