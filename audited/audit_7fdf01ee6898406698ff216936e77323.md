### Title
Stale Merkle Paths from Parent Chain Reorganization Enable Unauthorized Cross-Chain Token Minting

### Summary
The CrossChain contract permanently stores merkle paths and parent chain height bindings without any mechanism to invalidate them upon parent chain reorganization. When the parent chain reorganizes, previously indexed blocks may be discarded, but their merkle paths remain stored and accepted as valid. Attackers can query these stale merkle paths via `GetBoundParentChainHeightAndMerklePathByHeight()` and use them to pass cross-chain verification for transactions that should be rejected, enabling unauthorized token minting through `CrossChainReceiveToken`.

### Finding Description

**Root Cause:**
The CrossChain contract stores merkle paths and parent chain bindings permanently during parent chain block indexing, with no mechanism to detect or handle parent chain reorganizations. [1](#0-0) 

In `IndexParentChainBlockData`, the contract stores merkle paths via `AddIndexedTxRootMerklePathInParentChain` and bindings via `BindParentChainHeight`: [2](#0-1) 

These storage operations are permanent with no deletion or invalidation logic: [3](#0-2) [4](#0-3) 

The validation logic only prevents duplicate indexing but does not check if parent chain blocks are irreversible or handle reorganizations: [5](#0-4) 

**Attack Vector:**
When `GetBoundParentChainHeightAndMerklePathByHeight` is called, it directly returns the stored values without validating they remain valid: [6](#0-5) 

These stale merkle paths are then used in `CrossChainReceiveToken` to verify cross-chain token transfers: [7](#0-6) 

The verification uses the stored parent chain merkle tree root, which corresponds to a discarded block: [8](#0-7) 

**Why Protections Fail:**
There is no mechanism anywhere in the codebase to remove or invalidate stored merkle paths, as confirmed by the absence of any deletion logic for `State.TxRootMerklePathInParentChain` and `State.ChildHeightToParentChainHeight`. While the cross-chain indexing service uses `IrreversibleBlockStateProvider`, it only reads data at LIB for certain operations and does not prevent indexing of non-irreversible blocks or invalidate previously stored data. [9](#0-8) 

### Impact Explanation

**Direct Financial Impact:**
- Attackers can mint unlimited tokens to their addresses by replaying transactions from discarded parent chain blocks
- All cross-chain token transfers become vulnerable once a parent chain reorganization occurs
- The vulnerability affects all tokens that use cross-chain transfers, potentially impacting the entire token economy

**Cross-Chain Integrity Breach:**
- The fundamental security assumption of cross-chain verification (that merkle paths prove inclusion in the canonical chain) is violated
- Transactions that were never included in the canonical parent chain can pass verification
- The side chain accepts "proofs" from a chain state that no longer exists

**Affected Parties:**
- Token holders on side chains receiving unauthorized token mints
- Legitimate cross-chain transfer users whose token supplies are diluted
- The entire cross-chain ecosystem's trust model

**Severity Justification:**
This is HIGH severity because it:
1. Directly enables theft through unauthorized token minting
2. Bypasses the core security mechanism of cross-chain verification
3. Affects the fundamental integrity of cross-chain operations
4. Has concrete, quantifiable financial impact

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required - any user can call public view and action methods
- Attacker only needs to monitor for parent chain reorganizations (a normal blockchain event)
- Once reorganization occurs, exploitation is straightforward

**Attack Complexity:**
- Low complexity: Query `GetBoundParentChainHeightAndMerklePathByHeight` for a height affected by reorganization
- Construct combined merkle path with transaction from discarded block
- Call `CrossChainReceiveToken` with the stale proof
- All steps use standard contract interfaces with no special access needed

**Feasibility Conditions:**
- Parent chain reorganizations are NORMAL blockchain events, especially during:
  - Network partitions or high latency periods
  - Consensus disputes or validator disagreements
  - Protocol upgrades or hard forks
- The longer the delay between parent chain block production and side chain indexing, the higher the reorganization probability
- AElf's own documentation acknowledges reorganizations can occur until blocks reach LIB

**Detection and Operational Constraints:**
- Difficult to detect: Transactions appear valid from side chain's perspective
- No monitoring alerts for stale merkle paths
- Post-exploitation, unauthorized token mints are indistinguishable from legitimate ones
- No rollback mechanism exists once tokens are minted

**Probability Assessment:**
HIGH - Parent chain reorganizations occur naturally in blockchain networks, and once they do, the attack window remains open indefinitely since stored merkle paths are never invalidated.

### Recommendation

**Code-Level Mitigation:**

1. **Add LIB-Only Indexing Constraint:**
Modify `ValidateParentChainBlockData` to reject parent chain blocks that are not yet irreversible. Add a check that compares the parent chain block height against the parent chain's reported LIB: [5](#0-4) 

Add assertion: `Assert(blockData.Height <= parentChainLastIrreversibleBlockHeight, "Cannot index non-irreversible parent chain blocks")`

2. **Add Reorganization Detection:**
Store parent chain block hashes alongside merkle paths. When querying via `GetBoundParentChainHeightAndMerklePathByHeight`, verify the stored block hash matches the current canonical chain: [6](#0-5) 

3. **Implement Merkle Path Invalidation:**
Add a mechanism to invalidate stored merkle paths if a parent chain reorganization is detected. This could be triggered when indexing new parent chain data that conflicts with previously stored data.

**Invariant Checks:**
- Parent chain blocks being indexed MUST be past the parent chain's LIB
- Stored merkle paths MUST correspond to blocks still in the canonical parent chain
- Cross-chain verification MUST fail if the bound parent chain block has been reorganized

**Test Cases:**
1. Test that indexing non-irreversible parent chain blocks is rejected
2. Test that stored merkle paths become invalid after simulated parent chain reorganization
3. Test that `CrossChainReceiveToken` fails when using merkle paths from reorganized blocks
4. Test that the system properly handles legitimate reorganizations without breaking valid cross-chain transfers

### Proof of Concept

**Initial State:**
1. Side chain is at height 500
2. Parent chain is at height 1000, with LIB at height 950
3. Parent chain block 1000 includes side chain block 500's merkle root
4. Side chain indexes parent chain block 1000, storing merkle path for side chain height 500

**Attack Sequence:**

**Step 1 - Parent Chain Reorganization:**
- Parent chain reorganizes, discarding blocks 995-1000
- New canonical chain has different blocks at heights 995-1000
- New block 1000 either doesn't include side chain height 500, or has different merkle tree structure
- Side chain is unaware of reorganization, still has old merkle path stored

**Step 2 - Query Stale Merkle Path:**
```
Call: GetBoundParentChainHeightAndMerklePathByHeight(500)
Returns: 
  - BoundParentChainHeight = 1000 (from discarded block)
  - MerklePathFromParentChain = old merkle path
```

**Step 3 - Create Malicious Transfer:**
- Attacker constructs a `CrossChainTransfer` transaction on side chain at height 500
- Transaction transfers large amount of tokens to attacker's address
- Transaction exists in side chain's merkle tree at height 500

**Step 4 - Execute Attack:**
```
Call: CrossChainReceiveToken({
  FromChainId: sideChainId,
  ParentChainHeight: 1000,
  TransferTransactionBytes: maliciousTransferTx,
  MerklePath: combinedPath (transaction path + stale parent chain path)
})
```

**Expected Result:**
- Verification should fail because parent chain block 1000 was discarded
- Token minting should be rejected

**Actual Result:**
- `VerifyTransaction` retrieves merkle tree root from `State.ParentChainTransactionStatusMerkleTreeRoot[1000]` (OLD root)
- Verification passes because both root and path are from discarded block (they match each other)
- Tokens are minted to attacker's address
- Attack succeeds despite parent chain reorganization

**Success Condition:**
Attacker receives tokens that should not be mintable because the cross-chain proof relies on a parent chain block that no longer exists in the canonical chain.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L27-32)
```csharp
    private void BindParentChainHeight(long childHeight, long parentHeight)
    {
        Assert(State.ChildHeightToParentChainHeight[childHeight] == 0,
            $"Already bound at height {childHeight} with parent chain");
        State.ChildHeightToParentChainHeight[childHeight] = parentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L52-58)
```csharp
    private void AddIndexedTxRootMerklePathInParentChain(long height, MerklePath path)
    {
        var existing = State.TxRootMerklePathInParentChain[height];
        Assert(existing == null,
            $"Merkle path already bound at height {height}.");
        State.TxRootMerklePathInParentChain[height] = path;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L761-807)
```csharp
    private IndexedParentChainBlockData IndexParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        var indexedParentChainBlockData = new IndexedParentChainBlockData
        {
            LocalChainHeight = Context.CurrentHeight
        };
        for (var i = 0; i < parentChainBlockData.Count; i++)
        {
            var blockInfo = parentChainBlockData[i];
            AssertParentChainBlock(parentChainId, currentHeight, blockInfo);
            var parentChainHeight = blockInfo.Height;
            State.ParentChainTransactionStatusMerkleTreeRoot[parentChainHeight] =
                blockInfo.TransactionStatusMerkleTreeRoot;
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }

            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }

            if (blockInfo.CrossChainExtraData != null)
                State.TransactionMerkleTreeRootRecordedInParentChain[parentChainHeight] =
                    blockInfo.CrossChainExtraData.TransactionStatusMerkleTreeRoot;

            indexedParentChainBlockData.ParentChainBlockDataList.Add(blockInfo);
            currentHeight += 1;
        }

        State.CurrentParentChainHeight.Value = currentHeight;
        
        Context.Fire(new ParentChainIndexed
        {
            ChainId = parentChainId,
            IndexedHeight = currentHeight
        });

        return indexedParentChainBlockData;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L19-30)
```csharp
    public override CrossChainMerkleProofContext GetBoundParentChainHeightAndMerklePathByHeight(Int64Value input)
    {
        var boundParentChainHeight = State.ChildHeightToParentChainHeight[input.Value];
        Assert(boundParentChainHeight != 0);
        var merklePath = State.TxRootMerklePathInParentChain[input.Value];
        Assert(merklePath != null);
        return new CrossChainMerkleProofContext
        {
            MerklePathFromParentChain = merklePath,
            BoundParentChainHeight = boundParentChainHeight
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L271-329)
```csharp
    private async Task<List<ParentChainBlockData>> GetNonIndexedParentChainBlockDataAsync(Hash blockHash,
        long blockHeight, HashSet<int> excludeChainIdList)
    {
        var parentChainBlockDataList = new List<ParentChainBlockData>();
        var libExists = await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!libExists)
            return parentChainBlockDataList;

        var crossChainContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
        {
            BlockHash = blockHash,
            BlockHeight = blockHeight
        });

        var returnValue = await _contractReaderFactory.Create(new ContractReaderContext
            {
                BlockHash = blockHash,
                BlockHeight = blockHeight,
                ContractAddress = crossChainContractAddress
            }).GetParentChainId
            .CallAsync(new Empty());
        var parentChainId = returnValue?.Value ?? 0;
        if (parentChainId == 0 || excludeChainIdList.Contains(parentChainId))
            // no configured parent chain
            return parentChainBlockDataList;

        var length = CrossChainConstants.DefaultBlockCacheEntityCount;
        var heightInState = (await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = blockHash,
                BlockHeight = blockHeight,
                ContractAddress = crossChainContractAddress
            }).GetParentChainHeight
            .CallAsync(new Empty())).Value;

        var targetHeight = heightInState + 1;
        Logger.LogDebug($"Target height {targetHeight}");

        var i = 0;
        while (i < length)
        {
            var parentChainBlockData =
                _blockCacheEntityConsumer.Take<ParentChainBlockData>(parentChainId, targetHeight, false);
            if (parentChainBlockData == null || parentChainBlockData.Height != targetHeight)
                // no more available parent chain block info
                break;

            parentChainBlockDataList.Add(parentChainBlockData);
            targetHeight++;
            i++;
        }

        if (parentChainBlockDataList.Count > 0)
            Logger.LogDebug(
                $"Got height [{parentChainBlockDataList.First().Height} - {parentChainBlockDataList.Last().Height} ]" +
                $" from parent chain {ChainHelper.ConvertChainIdToBase58(parentChainId)}.");
        return parentChainBlockDataList;
    }
```
