# Audit Report

## Title
Incomplete Conflict Resolution in Miner Order Assignment Leads to Duplicate Orders and Non-Deterministic Consensus

## Summary
The `ApplyNormalConsensusData()` function's conflict resolution loop contains a critical gap in its search space that prevents it from checking the maximum valid order position. When multiple miners calculate the same `FinalOrderOfNextRound` value equal to `minersCount`, and all lower positions are occupied, the conflict resolution silently fails. This allows duplicate `FinalOrderOfNextRound` values to persist into the next consensus round, violating the fundamental invariant that each miner must have a unique mining order and timeslot.

## Finding Description

The vulnerability exists in the conflict resolution logic that executes when miners produce blocks and their calculated orders conflict with existing assignments. [1](#0-0) 

**Root Cause - Incomplete Search Space:**

The resolution loop iterates from `supposedOrderOfNextRound + 1` to `minersCount * 2 - 1`, using modulo arithmetic to map these values to actual order positions. However, this creates a critical gap: when `supposedOrderOfNextRound` equals the maximum order (`minersCount`), the loop generates positions `1` through `minersCount - 1` but NEVER checks position `minersCount` itself.

**Mathematical Proof (21 miners example):**
- If `supposedOrderOfNextRound = 21` and `minersCount = 21`
- Loop range: `i = 22` to `41` (since `i < 42`)
- For `i = 22`: `maybeNewOrder = 22 % 21 = 1`
- For `i = 23`: `maybeNewOrder = 23 % 21 = 2`
- ...
- For `i = 41`: `maybeNewOrder = 41 % 21 = 20`
- Result: Positions 1-20 checked, position 21 NEVER checked

**Execution Flow to Duplicate Orders:**

1. **Collision Detection**: When a miner produces a block with `supposedOrderOfNextRound = N`, the code finds all miners already assigned that order [2](#0-1) 

2. **Failed Reassignment**: If all positions 1 through N-1 are occupied, the loop completes without reassigning the conflicted miner

3. **Duplicate Assignment**: The current miner is then assigned the same order [3](#0-2) 

4. **Persistence Through Updates**: The duplicate orders are stored in the round state via `ProcessUpdateValue` [4](#0-3) 

5. **Bypass of TuneOrderInformation**: The mechanism that should propagate order adjustments only includes miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound`, excluding both conflicted miners if they remain at their supposed order [5](#0-4) 

6. **Application of Tuning**: The empty tuning information doesn't correct the duplicate [6](#0-5) 

**Why Validation Fails:**

The `NextRoundMiningOrderValidationProvider` checks for distinct miners, not distinct order values. It uses `.Distinct()` on `MinerInRound` objects (which are inherently distinct by their unique public keys), not on their `FinalOrderOfNextRound` field values: [7](#0-6) 

This validation passes even with duplicate order values because each miner object is distinct.

**Propagation to Next Round:**

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound` values, and both miners with duplicate orders receive identical `Order` and `ExpectedMiningTime` assignments: [8](#0-7) 

## Impact Explanation

This vulnerability directly violates the core consensus invariant that each miner must have a unique position in the mining schedule. The consequences are severe:

**Consensus Non-Determinism**: Two miners believe they should produce blocks at exactly the same time, creating a race condition where network propagation timing determines which block is accepted. Different network partitions may accept different blocks, risking temporary chain forks.

**Unfair Miner Penalties**: When both miners attempt to produce at their assigned time, one will inevitably be marked as having "missed" their slot despite acting correctly according to their schedule. This affects their reputation scores and reward distribution.

**Round Transition Instability**: The duplicate orders persist through round boundaries, potentially cascading the issue into subsequent rounds until the miner set changes or the duplicate position naturally resolves.

**Network Validator Confusion**: Different nodes may have different views of which miner should produce at a given time, leading to inconsistent block validation and acceptance across the network.

The impact is **HIGH** because it breaks fundamental consensus guarantees that the entire blockchain's security depends upon. Unlike issues that require malicious actors, this degrades consensus integrity during normal operation.

## Likelihood Explanation

This vulnerability has **MEDIUM-HIGH** likelihood of occurrence:

**No Attacker Required**: The issue triggers through natural hash distribution as miners produce blocks. The birthday paradox makes hash collisions statistically probable with a reasonable number of miners (with 21 miners, collision probability exceeds 50% after ~20 samples).

**Realistic Preconditions**: 
- Requires N-1 positions to be occupied when a collision occurs at position N
- Most likely near end of round when most miners have produced blocks
- Specifically vulnerable at the edge position (order = minersCount)

**Silent Failure**: No error is thrown when conflict resolution fails, making the issue difficult to detect. The duplicate persists through existing validation logic designed to catch such problems.

**Cumulative Risk**: Each round with high miner participation increases the probability. Over many rounds, the likelihood of triggering this condition approaches certainty.

**Operational Context**: Occurs during standard `UpdateValue` consensus behavior, requiring no special execution environment or privileged access.

## Recommendation

Fix the conflict resolution loop to ensure all valid order positions are checked, including the maximum position. The loop should either:

**Option 1 - Full Range Check**: Modify the loop to check all positions from 1 to minersCount:
```csharp
for (var i = 1; i <= minersCount; i++)
{
    var testOrder = (supposedOrderOfNextRound + i - 1) % minersCount + 1;
    if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != testOrder))
    {
        RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = testOrder;
        break;
    }
}
```

**Option 2 - Explicit Validation**: Add validation that explicitly checks for duplicate `FinalOrderOfNextRound` values:
```csharp
var orderCounts = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .GroupBy(m => m.FinalOrderOfNextRound)
    .Where(g => g.Count() > 1);
    
if (orderCounts.Any())
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
    return validationResult;
}
```

**Option 3 - Mandatory Assignment**: Ensure conflict resolution always succeeds by throwing an assertion failure if no free position is found, forcing explicit handling of this error case.

## Proof of Concept

```csharp
// POC: Demonstrate incomplete search space in conflict resolution
public void TestConflictResolutionGap()
{
    // Setup: Create round with 21 miners
    var round = new Round();
    var minersCount = 21;
    
    // Occupy positions 1-20 with different miners
    for (int i = 1; i <= 20; i++)
    {
        var miner = new MinerInRound 
        { 
            Pubkey = $"miner{i}", 
            FinalOrderOfNextRound = i 
        };
        round.RealTimeMinersInformation[$"miner{i}"] = miner;
    }
    
    // Miner A already has position 21
    round.RealTimeMinersInformation["minerA"] = new MinerInRound 
    { 
        Pubkey = "minerA", 
        FinalOrderOfNextRound = 21 
    };
    
    // Miner B calculates supposedOrderOfNextRound = 21 (collision)
    var signature = GenerateSignatureWithOrder21();
    round.ApplyNormalConsensusData("minerB", Hash.Empty, Hash.Empty, signature);
    
    // Verify: Both minerA and minerB now have FinalOrderOfNextRound = 21
    Assert.Equal(21, round.RealTimeMinersInformation["minerA"].FinalOrderOfNextRound);
    Assert.Equal(21, round.RealTimeMinersInformation["minerB"].FinalOrderOfNextRound);
    
    // This violates the consensus invariant of unique orders
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
