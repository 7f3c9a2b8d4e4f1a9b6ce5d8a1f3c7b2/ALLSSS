### Title
ImpliedIrreversibleBlockHeight Validation Bypass Due to Premature State Modification

### Summary
The `LibInformationValidationProvider` validates `ImpliedIrreversibleBlockHeight` after `RecoverFromUpdateValue` or `RecoverFromTinyBlock` has already overwritten the base round state with provided values. This causes the validation to compare the provided value against itself, always passing. Malicious miners can supply arbitrary `ImpliedIrreversibleBlockHeight` values that affect downstream Last Irreversible Block (LIB) height calculations, potentially preventing consensus finality advancement if more than 1/3 of miners collude.

### Finding Description

**Root Cause:**

The validation ordering in `ValidateBeforeExecution` is incorrect. The base round state is modified with provided values before validation occurs. [1](#0-0) 

The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods directly overwrite the `ImpliedIrreversibleBlockHeight` in the base round with the provided value: [2](#0-1) [3](#0-2) 

The `LibInformationValidationProvider` then attempts to validate that the `ImpliedIrreversibleBlockHeight` hasn't decreased: [4](#0-3) 

However, since `baseRound` was already modified, this check compares `providedValue > providedValue`, which always evaluates to false, causing the validation to always pass.

**Why Existing Protections Fail:**

1. The validation context is created with the already-modified `baseRound`: [5](#0-4) 

2. The `MiningPermissionValidationProvider` only checks if the sender is a valid miner, not the validity of the `ImpliedIrreversibleBlockHeight`: [6](#0-5) 

3. When miners generate legitimate consensus data, they set `ImpliedIrreversibleBlockHeight` to `Context.CurrentHeight`: [7](#0-6) 

But there's no validation that the provided value matches this expectation.

**Downstream Impact:**

The malicious `ImpliedIrreversibleBlockHeight` is persisted in the round state during `ProcessUpdateValue`: [8](#0-7) 

This value is then used in LIB calculation in subsequent rounds: [9](#0-8) 

The `LastIrreversibleBlockHeightCalculator` collects `ImpliedIrreversibleBlockHeight` values from miners in the previous round and calculates LIB using a 2/3+1 consensus mechanism: [10](#0-9) 

### Impact Explanation

**Concrete Harm:**
- Malicious miners can submit artificially low `ImpliedIrreversibleBlockHeight` values (e.g., 0 or far in the past)
- If more than 1/3 of miners in a round submit low values, the LIB calculation is dragged down
- The LIB is calculated as the value at index `(count-1)/3` of the sorted list, so 1/3+1 honest values can be overridden by the remaining dishonest values

**Protocol Damage:**
- **Finality Delay**: LIB advancement can be prevented or significantly slowed, delaying transaction finality
- **Cross-Chain Impact**: Cross-chain operations that depend on LIB heights for verification would be blocked or delayed
- **Consensus Integrity**: The consensus view of irreversibility is compromised

**Who Is Affected:**
- All network participants waiting for transaction finality
- Cross-chain bridges and protocols relying on LIB for security
- DApps requiring fast finality guarantees

**Severity Justification: Medium**
- LIB can only increase (not decrease) due to the check at line 272, preventing rollback of already-finalized blocks
- Requires collusion of >1/3 of miners in a round
- No direct fund theft, but impacts operational availability and finality guarantees
- Attack is persistent as long as malicious miners continue participation

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a valid miner in the current round (checked by `MiningPermissionValidationProvider`)
- Must have ability to produce blocks (legitimate mining permission)
- Requires no special privileges beyond being an elected miner

**Attack Complexity:**
- Low technical complexity: simply provide a low `ImpliedIrreversibleBlockHeight` value in `UpdateValueInput` or `TinyBlockInput`
- Single malicious miner can partially impact, >1/3 collusion needed for significant effect
- No complex state manipulation or timing requirements

**Feasibility Conditions:**
- Malicious miners must maintain their position in the miner set
- Attack can be executed repeatedly in each round they mine
- No on-chain detection or slashing mechanism for this behavior

**Economic Rationality:**
- No direct economic cost to execute (no slashing detected in code)
- Could be used for griefing or to advantage competing chains
- May be combined with other attacks to maximize impact

**Probability: Medium-High**
- If even a minority of miners are malicious, they can incrementally slow LIB advancement
- No deterrent mechanism in place
- Attack is undetectable until finality delays become noticeable

### Recommendation

**Code-Level Mitigation:**

1. **Preserve Original State**: Store the original `ImpliedIrreversibleBlockHeight` before calling `RecoverFromUpdateValue`/`RecoverFromTinyBlock`:

```csharp
// In ValidateBeforeExecution, before line 46:
var originalImpliedHeight = baseRound.RealTimeMinersInformation.ContainsKey(extraData.SenderPubkey.ToHex()) 
    ? baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()].ImpliedIrreversibleBlockHeight 
    : 0;

// Modify LibInformationValidationProvider to use stored original value:
if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
    originalImpliedHeight > providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
{
    validationResult.Message = "Incorrect implied lib height.";
    return validationResult;
}
```

2. **Add Upper Bound Validation**: Ensure `ImpliedIrreversibleBlockHeight` cannot exceed current block height:

```csharp
if (providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > validationContext.ExtraData.BlockHeight)
{
    validationResult.Message = "Implied lib height exceeds current height.";
    return validationResult;
}
```

3. **Add Rate Limiting**: Prevent `ImpliedIrreversibleBlockHeight` from decreasing too much between rounds:

```csharp
var maxAllowedDecrease = 100; // Configure based on network parameters
if (originalImpliedHeight > 0 && 
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight < originalImpliedHeight - maxAllowedDecrease)
{
    validationResult.Message = "Implied lib height decreased too much.";
    return validationResult;
}
```

**Test Cases:**

1. Test that validation rejects `ImpliedIrreversibleBlockHeight` values lower than the previous round's value
2. Test that validation rejects values exceeding current block height
3. Test that LIB calculation is unaffected by single malicious miner
4. Test that >1/3 malicious miners with low values do slow LIB advancement (expected behavior requiring protocol-level response)

### Proof of Concept

**Initial State:**
- Network has 7 miners (2/3+1 = 5 for consensus)
- Current block height: 10000
- Previous LIB height: 9500
- Attacker controls 3 miners (>1/3)

**Attack Steps:**

1. **Round N**: Legitimate miners produce blocks with `ImpliedIrreversibleBlockHeight = 10000`

2. **Round N**: Attacker's 3 miners produce blocks with malicious `UpdateValueInput`:
   - Set `ImpliedIrreversibleBlockHeight = 5000` (far in the past)
   - Validation passes because `LibInformationValidationProvider` compares the value against itself after `RecoverFromUpdateValue` modifies `baseRound`

3. **Round N+1**: When honest miner produces block and `ProcessUpdateValue` executes:
   - `LastIrreversibleBlockHeightCalculator` collects: [5000, 5000, 5000, 10000, 10000, 10000, 10000]
   - Sorted list index = (7-1)/3 = 2
   - Calculated LIB = 5000 (instead of expected ~9800)
   - Since `currentRound.ConfirmedIrreversibleBlockHeight (9500) < libHeight (5000)` is false, LIB doesn't update

**Expected Result:**
- LIB should advance to approximately 9800 (based on honest miners' view)

**Actual Result:**
- LIB calculation yields 5000, which is rejected by the monotonicity check
- LIB remains stuck at 9500, failing to advance
- Finality is halted as long as attackers maintain >1/3 participation

**Success Condition:**
- Attacker successfully prevents LIB advancement while remaining undetected by validation logic

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L19-19)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L43-43)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-281)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
