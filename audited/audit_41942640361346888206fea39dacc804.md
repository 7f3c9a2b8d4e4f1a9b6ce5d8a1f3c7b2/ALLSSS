### Title
Missing Validation for Empty Miner List Enables Permanent Blockchain Halt via NextRound/NextTerm

### Summary
The `ContinuousBlocksValidationProvider` checks if `BaseRound.RealTimeMinersInformation.Count != 1` to skip validation for single-miner scenarios, but when Count equals 0, the condition evaluates to true (0 != 1), allowing the validation to pass. No validator checks that the proposed round (ProvidedRound) in NextRound/NextTerm transactions contains a non-empty miner list. A malicious miner can exploit this to submit an empty round, causing permanent blockchain halting since no subsequent miner can pass validation.

### Finding Description

The vulnerability exists in the consensus validation pipeline when processing NextRound or NextTerm behaviors. The critical issue spans multiple files:

**Root Cause in ContinuousBlocksValidationProvider:** [1](#0-0) 

The condition checks `BaseRound.RealTimeMinersInformation.Count != 1`, which evaluates to true when Count is 0 (since 0 != 1). This was intended to skip continuous block validation for single-miner chains, but it inadvertently allows zero-miner scenarios to pass.

**Missing Validation in NextRoundMiningOrderValidationProvider:** [2](#0-1) 

When ProvidedRound is empty, both counts equal zero (distinctCount = 0, miners with OutValue = 0), so the equality check passes.

**Missing Validation in RoundTerminateValidationProvider:** [3](#0-2) 

For empty rounds, `Any(m => m.InValue != null)` returns false (no elements to check), allowing validation to succeed.

**Validation Pipeline Setup:** [4](#0-3) 

All validators check BaseRound (current state) for sender permissions but do not validate that ProvidedRound contains miners.

**Unconditional Storage:** [5](#0-4) 

The empty round is stored unconditionally via `AddRoundInformation(nextRound)` without checking if it contains miners. [6](#0-5) 

**Subsequent Block Failure:** [7](#0-6) 

After the empty round is stored, any subsequent block attempt fails because no miner's pubkey can exist in an empty `RealTimeMinersInformation.Keys` collection.

### Impact Explanation

**Consensus/Cross-Chain Integrity Impact:**
- **Permanent Blockchain Halt:** Once an empty round is stored, the blockchain cannot produce any subsequent blocks. The `MiningPermissionValidationProvider` will reject all miners since `RealTimeMinersInformation.Keys` is empty.
- **Complete DoS:** All consensus operations, transaction processing, and cross-chain communications cease permanently.
- **Recovery Complexity:** Requires emergency hard fork or manual state database intervention to restore miner list and round information.
- **Network-Wide Impact:** Affects all nodes and users of the blockchain, not just specific accounts or contracts.

**Severity Justification:**
This is a **CRITICAL** vulnerability because:
1. It causes permanent, irreversible blockchain halt
2. No automatic recovery mechanism exists
3. Affects entire network consensus layer
4. Requires minimal effort to exploit (single malicious transaction)
5. Violates the critical invariant: "Correct round transitions and miner schedule integrity"

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner in the current round
- Can produce blocks during their assigned time slot
- Has standard block production privileges (no elevated permissions needed)

**Attack Complexity:**
- **Low Complexity:** Attacker simply crafts a `NextRoundInput` or `NextTermInput` with empty `RealTimeMinersInformation` dictionary
- **Single Transaction:** Exploit requires only one malicious call to `NextRound()` or `NextTerm()`
- **No Race Conditions:** Attacker waits for their mining time slot and submits the malicious transaction

**Feasibility Conditions:** [8](#0-7) 

The `NextRound()` method is public and accessible to any miner who passes validation checks.

**Detection/Operational Constraints:**
- **Pre-Execution Detection:** Standard validation does not detect empty miner lists in ProvidedRound
- **Post-Execution:** Blockchain immediately halts, making the attack obvious but recovery difficult
- **Economic Rationality:** A malicious or compromised miner could execute this as a griefing attack with no direct cost beyond reputation loss

**Probability Reasoning:**
- **Realistic Preconditions:** Only requires one of N miners to be malicious or compromised
- **Execution Practicality:** Straightforward exploitation with standard consensus transaction format
- **Likelihood: MEDIUM-HIGH** - While requiring miner access, miners are not assumed to be fully trusted, and the attack is trivial to execute

### Recommendation

**Immediate Fix - Add Empty Miner List Validation:**

Add explicit validation in `RoundTerminateValidationProvider` to reject rounds with zero miners:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // NEW: Reject empty miner lists
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Round must contain at least one miner." };
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Alternative Fix - Update ContinuousBlocksValidationProvider:**

Modify the condition to explicitly handle the zero-miner case:

```csharp
if (validationContext.ProvidedRound.RoundNumber > 2 &&
    validationContext.BaseRound.RealTimeMinersInformation.Count > 1) // Changed from != 1
```

**Invariant Check to Add:**
- Assert that `Round.RealTimeMinersInformation.Count > 0` before storing via `AddRoundInformation()`

**Test Cases:**
1. **Test NextRound with Empty Miners:** Submit `NextRoundInput` with `RealTimeMinersInformation = {}`, verify rejection with error message
2. **Test NextTerm with Empty Miners:** Submit `NextTermInput` with `RealTimeMinersInformation = {}`, verify rejection
3. **Test Single Miner:** Verify legitimate single-miner scenarios still pass validation
4. **Test Zero to One Transition:** Ensure genesis/initialization cannot create zero-miner rounds

### Proof of Concept

**Required Initial State:**
- Blockchain running with N miners (N ≥ 2) in current round R
- Attacker is one of the active miners with valid block production rights
- State.Rounds[R] contains valid miner list with Count > 1

**Transaction Steps:**

1. **Attacker waits for their assigned mining time slot**

2. **Attacker crafts malicious NextRoundInput:**
```protobuf
NextRoundInput {
  round_number: R + 1
  term_number: current_term
  real_time_miners_information: {}  // EMPTY MAP
  round_id_for_validation: <valid_id>
  random_number: <valid_vrf>
  // ... other valid fields
}
```

3. **Attacker calls NextRound(malicious_input) during their time slot**

4. **Validation executes:**
   - MiningPermissionValidationProvider: Checks attacker in BaseRound (R) → **PASSES** (attacker is valid miner in R)
   - ContinuousBlocksValidationProvider: Checks `BaseRound.Count != 1` → **PASSES** (N != 1 is true)
   - NextRoundMiningOrderValidationProvider: Checks `0 == 0` → **PASSES**
   - RoundTerminateValidationProvider: Checks round number and InValues → **PASSES**

5. **ProcessNextRound executes:**
   - `AddRoundInformation(nextRound)` stores empty round at State.Rounds[R+1]
   - Transaction succeeds

6. **Next block attempt by ANY miner:**
   - `TryToGetCurrentRoundInformation()` returns empty BaseRound (R+1)
   - `MiningPermissionValidationProvider` checks if sender in empty `RealTimeMinersInformation.Keys`
   - Validation **FAILS** for all miners

**Expected vs Actual Result:**
- **Expected:** Validation should reject NextRoundInput with empty miners, return error "Round must contain at least one miner"
- **Actual:** Empty round is accepted and stored, blockchain permanently halts

**Success Condition:**
After attacker's transaction is included in block at height H:
- Block H+1 cannot be produced by any miner
- All subsequent consensus transactions fail validation
- Blockchain is permanently halted at height H

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-14)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-20)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
