### Title
Nothing-at-Stake Attack via Reusable Consensus Values in UpdateValue Validation

### Summary
The `NewConsensusInformationFilled()` validation function allows miners to produce multiple competing blocks at the same height using identical OutValue and Signature values. The consensus values are not cryptographically bound to block-specific content (transactions, state root, previous block hash), enabling classic nothing-at-stake attacks where miners can costlessly create competing forks.

### Finding Description

**Root Cause Location:**
The validation in `NewConsensusInformationFilled()` only checks that OutValue and Signature exist and are non-empty, but does not verify their uniqueness or binding to specific block content: [1](#0-0) 

**Vulnerability Chain:**

1. **InValue Generation and Caching**: InValues are generated by signing round information and cached only by round ID, not by block-specific data: [2](#0-1) 

The cache stores InValues indexed only by round ID: [3](#0-2) 

2. **InValue Retrieval**: When generating consensus data, the same cached InValue is retrieved for all blocks in the same round: [4](#0-3) 

3. **Deterministic OutValue Computation**: OutValue is computed deterministically as Hash(InValue): [5](#0-4) 

4. **Deterministic Signature Computation**: Signature is computed by XORing InValue with previous round signatures, depending only on previous round state: [6](#0-5) 

Called during consensus data generation: [7](#0-6) 

5. **No Block Content Binding**: Nowhere in the validation chain are the consensus values (InValue/OutValue/Signature) bound to block-specific content like transaction set, state root, or previous block hash. The validation context only contains round information: [8](#0-7) 

**Why Existing Protections Fail:**

The `ValidatePreviousInValue()` function only checks that the revealed previous InValue correctly hashes to the previous round's OutValue, but this doesn't prevent reuse: [9](#0-8) 

The validation orchestration applies multiple providers, but none check for OutValue uniqueness or block content binding: [10](#0-9) 

### Impact Explanation

**Consensus Integrity Compromise (Critical):**
- Miners can produce unlimited competing blocks at the same height with no economic cost
- All competing blocks pass consensus validation since they use identical, valid OutValue/Signature
- Undermines chain finality as miners can hedge bets on multiple forks simultaneously
- Enables long-range attacks where malicious miners can rewrite history by creating competing chains from any point

**Chain Security Degradation:**
- Network consensus becomes unreliable as miners have no incentive to converge on a single chain
- Block producers can extract maximum value from all possible forks without penalty
- Cross-chain bridges and dependent systems lose security guarantees as irreversible block heights become meaningless

**Affected Parties:**
- All network participants: validators see competing valid chains
- DApp users: transactions may be included in losing forks, causing reversals
- Cross-chain protocols: merkle proofs can be constructed for multiple conflicting states
- Token holders: double-spending becomes feasible through fork manipulation

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker: Any authorized miner in the current round's miner list
- Required access: Normal mining permissions (no privilege escalation needed)
- Required resources: Standard block production infrastructure

**Attack Complexity: Low**
1. Miner receives consensus command for UpdateValue behavior
2. System caches InValue by round ID (automatic)
3. Miner constructs Block A with transaction set X
4. Miner constructs Block B with transaction set Y at same height
5. Both blocks retrieve same InValue from cache
6. Both compute identical OutValue = Hash(InValue)
7. Both compute identical Signature from previous round state
8. Both blocks pass all validation checks
9. Miner broadcasts both blocks to different network segments

**Execution Practicality:**
- No state manipulation required - exploit uses normal consensus flow
- InValue caching is automatic per the design: [11](#0-10) 

- Block production with same consensus values is trivially achievable since validation only checks existence, not uniqueness

**Economic Rationality:**
- Zero additional cost to produce multiple blocks (same computational work)
- High potential reward from hedging on multiple forks
- No slashing or penalty mechanism for producing competing blocks with same consensus values
- Rational miners will exploit this to maximize expected rewards

**Detection Constraints:**
- Competing blocks appear valid to all validators independently
- No on-chain mechanism detects duplicate OutValue usage at same height
- Network topology allows publishing to different segments before detection
- By design, validation is stateless and doesn't track historical OutValue usage

### Recommendation

**Immediate Mitigation:**

1. **Bind Consensus Values to Block Hash**: Modify InValue generation to include the block's previous hash:

```csharp
// In AEDPoSTriggerInformationProvider.GetTriggerInformationForBlockHeaderExtraData
var inValueSeed = HashHelper.ConcatAndCompute(
    Hash.LoadFrom(hint.RoundId.ToBytes()), 
    chainContext.BlockHash  // Include block-specific data
);
var newInValue = _inValueCache.GetOrGenerateInValue(hint.RoundId, inValueSeed);
```

2. **Add OutValue Uniqueness Check**: In `NewConsensusInformationFilled()`, verify OutValue hasn't been used at this height:

```csharp
// In UpdateValueValidationProvider.cs
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Existing checks
    if (minerInRound.OutValue == null || minerInRound.Signature == null ||
        !minerInRound.OutValue.Value.Any() || !minerInRound.Signature.Value.Any())
        return false;
    
    // NEW: Check OutValue uniqueness at this height
    if (State.UsedOutValuesAtHeight[Context.CurrentHeight][minerInRound.OutValue])
        return false;
        
    return true;
}
```

3. **Track Used OutValues**: In `ProcessUpdateValue`, record OutValue usage:

```csharp
// In AEDPoSContract_ProcessConsensusInformation.cs
State.UsedOutValuesAtHeight[Context.CurrentHeight][updateValueInput.OutValue] = true;
```

4. **Add State Cleanup**: Remove old OutValue tracking after sufficient confirmations to prevent unbounded state growth.

**Test Cases:**

1. Test that producing two blocks at same height with same OutValue fails validation (second block rejected)
2. Test that OutValue from height H cannot be reused at height H+1 even if in different rounds
3. Test that block production fails if InValue seed doesn't include previous block hash
4. Test cleanup of OutValue tracking after N blocks

### Proof of Concept

**Initial State:**
- Network at height H, round R with active miner M
- Miner M is authorized in current round's miner list
- InValue for round R already cached in `IInValueCache`

**Attack Sequence:**

**Step 1**: Miner M receives consensus trigger for UpdateValue behavior at height H+1

**Step 2**: Miner M constructs Fork A:
- Includes transaction set {Tx1, Tx2, Tx3}
- Retrieves InValue from cache (indexed by round R)
- Computes OutValue_A = Hash(InValue)
- Computes Signature_A = CalculateSignature(PreviousInValue) 
- Both pass validation per cited code

**Step 3**: Miner M constructs Fork B at same height H+1:
- Includes different transaction set {Tx4, Tx5, Tx6}  
- Retrieves **same** InValue from cache (still indexed by round R)
- Computes OutValue_B = Hash(InValue) = OutValue_A (identical!)
- Computes Signature_B = CalculateSignature(PreviousInValue) = Signature_A (identical!)
- Both pass validation - no check for uniqueness

**Step 4**: Miner M broadcasts:
- Fork A to network segment 1
- Fork B to network segment 2

**Expected Result**: One fork should be rejected due to duplicate consensus values

**Actual Result**: Both blocks pass validation successfully:
- `NewConsensusInformationFilled()` returns true for both (only checks existence)
- `ValidatePreviousInValue()` returns true for both (same previous round state)
- No validator detects the duplicate OutValue usage
- Network splits into competing chains

**Success Condition**: Miner M successfully has competing valid blocks in the network, both referencing the same consensus commitment (OutValue), enabling nothing-at-stake attack where they benefit regardless of which fork is eventually chosen.

### Notes

The vulnerability contradicts the audit prompt's wording - miners cannot produce blocks with "different OutValues" that pass validation. Instead, the actual vulnerability is worse: they can produce multiple competing blocks with **identical** OutValues and Signatures, all of which pass validation. This is because:

1. InValue is cached by round ID only, not bound to specific block content
2. OutValue and Signature are deterministically derived from InValue  
3. No validation checks prevent reusing the same consensus values across competing blocks at the same height

This enables a classic nothing-at-stake attack where miners can costlessly produce competing forks without any penalty or detection mechanism in the consensus validation layer.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L47-50)
```csharp
            var newInValue = await GenerateInValueAsync(secretSharingInformation);
            Logger.LogDebug(
                $"Add in value {newInValue} for round id {secretSharingInformation.CurrentRoundId}");
            _inValueCache.AddInValue(secretSharingInformation.CurrentRoundId, newInValue);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IInValueCache.cs (L18-21)
```csharp
    public void AddInValue(long roundId, Hash inValue)
    {
        _inValues[roundId] = inValue;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L53-68)
```csharp
        if (hint.Behaviour == AElfConsensusBehaviour.UpdateValue)
        {
            var newInValue = _inValueCache.GetInValue(hint.RoundId);
            var previousInValue = _inValueCache.GetInValue(hint.PreviousRoundId);
            Logger.LogDebug($"New in value {newInValue} for round of id {hint.RoundId}");
            Logger.LogDebug($"Previous in value {previousInValue} for round of id {hint.PreviousRoundId}");
            var trigger = new AElfConsensusTriggerInformation
            {
                Pubkey = Pubkey,
                InValue = newInValue,
                PreviousInValue = previousInValue,
                Behaviour = hint.Behaviour
            };

            return trigger.ToBytesValue();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L65-69)
```csharp
        Assert(triggerInformation.InValue != null, "In value should not be null.");

        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L88-93)
```csharp
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```
