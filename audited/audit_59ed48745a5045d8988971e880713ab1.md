### Title
Consensus Reward Distribution Vulnerable to TokenContract Interface Changes

### Summary
The AEDPoS consensus contract references TokenContract methods through compile-time proto definitions without runtime compatibility verification. If TokenContract is upgraded with modified or removed method signatures (GetBalance, Transfer, TransferFrom, Approve, IsTokenAvailableForMethodFee), the consensus contract will fail with method-not-found errors, causing permanent disruption to resource token distribution and side chain dividend pools.

### Finding Description

The consensus contract maintains a reference to TokenContract and invokes multiple methods for reward distribution: [1](#0-0) 

Critical methods called during consensus operations include:

**In DistributeResourceTokensToPreviousMiners():** [2](#0-1) [3](#0-2) 

**In Donate() method:** [4](#0-3) [5](#0-4) [6](#0-5) 

**Root Cause:** At runtime, contract method invocation uses reflection-based handler lookup. When a method doesn't exist, execution fails: [7](#0-6) 

The transaction status becomes SystemError: [8](#0-7) 

**Why Protections Fail:** Contract upgrade validation only checks version numbers, not method signature compatibility: [9](#0-8) 

The UpdateSmartContract mechanism has no cross-contract interface validation: [10](#0-9) 

### Impact Explanation

**Direct Fund Impact:**
- Resource tokens (READ, WRITE, STORAGE, TRAFFIC) intended for main chain miners will remain locked in consensus contract indefinitely
- Side chain dividend pool contributions will fail, preventing token holder profit distribution
- No recovery mechanism exists without redeploying consensus contract

**Operational Impact:**
- Complete failure of `DistributeResourceTokensToPreviousMiners()` called during every cross-chain information update
- Breakdown of side chain dividend pool accepting donations via `Donate()`
- Cascading failures in profit distribution schemes dependent on these flows

**Affected Parties:**
- Main chain miners expecting resource token rewards
- Side chain token holders expecting dividend distributions
- Any contract attempting to donate to side chain dividend pool

**Severity Justification:** High - This breaks core economic incentive mechanisms with no automatic recovery, requiring emergency governance intervention and potential consensus contract redeployment.

### Likelihood Explanation

**Preconditions:**
- TokenContract upgrade approved through Parliament governance
- Upgrade modifies/removes any of: GetBalance, Transfer, TransferFrom, Approve, or IsTokenAvailableForMethodFee
- Consensus contract not upgraded simultaneously

**Execution Practicality:**
TokenContract upgrades are legitimate governance actions. The proto interface defines these methods: [11](#0-10) 

But nothing prevents their modification in future versions. The upgrade process lacks coordination requirements: [12](#0-11) 

**Complexity:** Low - Requires only normal governance process without awareness of dependent contracts.

**Detection:** Post-deployment when consensus operations fail. No pre-deployment validation catches this.

**Probability:** Medium - While not immediately likely, the 5+ methods called by consensus contract increase surface area for breaking changes over the system's lifetime.

### Recommendation

**Immediate Fix:**
1. Implement interface compatibility validation in UpdateSmartContract:
   - Extract method signatures from both old and new contract versions
   - Verify all methods referenced by dependent system contracts remain available
   - Reject upgrades that remove methods still in use

2. Add version pinning to contract references:
   - Store required interface version in ContractReferences state
   - Validate TokenContract upgrade maintains required interface version
   - Require coordinated multi-contract upgrades for breaking changes

3. Implement graceful degradation:
   - Wrap TokenContract calls in try-catch with fallback behavior
   - Emit events for failed distributions to enable manual recovery
   - Maintain queue of failed distributions for retry after upgrade

**Invariant Checks:**
- Before TokenContract upgrade: `ForEach(systemContract => ValidateInterfaceCompatibility(systemContract.requiredMethods, newTokenContract.methods))`
- After any system contract upgrade: Execute test transactions calling all cross-contract methods

**Test Cases:**
- Deploy test scenario where TokenContract removes Transfer method, verify consensus contract distribution fails
- Deploy test scenario with interface compatibility checker, verify upgrade rejection
- Test coordinated multi-contract upgrade path

### Proof of Concept

**Initial State:**
- Consensus contract deployed and referencing TokenContract
- TokenContract v1 with standard interface (GetBalance, Transfer, etc.)
- Miners active, cross-chain updates flowing

**Exploit Steps:**
1. Parliament proposes TokenContract upgrade v2 that renames `Transfer` to `TransferTokens` or removes `IsTokenAvailableForMethodFee`
2. Proposal approved and executed via normal governance (no malicious intent required)
3. Cross-chain contract calls `UpdateInformationFromCrossChain` on consensus contract
4. Consensus contract executes `DistributeResourceTokensToPreviousMiners()`
5. Line attempts: `State.TokenContract.Transfer.Send(...)`
6. Inline transaction created with MethodName="Transfer"
7. Executive.Execute() cannot find handler for "Transfer" in updated TokenContract
8. RuntimeException thrown: "Failed to find handler for Transfer"
9. Transaction trace shows ExecutionStatus.SystemError
10. Resource token distribution permanently fails

**Expected vs Actual:**
- Expected: Miners receive resource tokens after each cross-chain update
- Actual: All distribution transactions fail with SystemError, tokens locked in consensus contract

**Success Condition:** All subsequent attempts to distribute resource tokens fail until consensus contract is upgraded or TokenContract is reverted.

### Notes

This vulnerability represents a **systemic design flaw** in AElf's system contract upgrade architecture rather than a traditional attack vector. The absence of dependency tracking and interface versioning between system contracts creates fragility where legitimate governance actions can inadvertently break critical economic flows.

The issue is particularly severe because:
1. The consensus contract cannot be easily upgraded (requires miner coordination)
2. No automated detection exists before deployment
3. Recovery requires emergency governance intervention
4. Similar risks exist for ALL inter-system-contract dependencies (not just TokenContract)

While the prompt frames this as a backward compatibility question, the real security issue is the lack of architectural safeguards preventing breaking changes. A mature system contract framework should enforce interface stability contracts and require explicit opt-in to breaking changes with coordinated multi-contract deployments.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ContractsReferences.cs (L16-16)
```csharp
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L76-80)
```csharp
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L88-93)
```csharp
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L41-42)
```csharp
        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L44-50)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L52-57)
```csharp
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L133-137)
```csharp
            if (!_callHandlers.TryGetValue(methodName, out var handler))
                throw new RuntimeException(
                    $"Failed to find handler for {methodName}. We have {_callHandlers.Count} handlers: " +
                    string.Join(", ", _callHandlers.Keys.OrderBy(k => k))
                );
```

**File:** test/AElf.Runtime.CSharp.Tests/ExecutiveTests.cs (L48-62)
```csharp
    public async Task Apply_MethodNotExist_Test()
    {
        var executive = CreateExecutive();

        var hostSmartContractBridgeContext = _hostSmartContractBridgeContextService.Create();
        executive.SetHostSmartContractBridgeContext(_hostSmartContractBridgeContextService.Create());

        var transactionContext = CreateTransactionContext();
        transactionContext.Transaction.MethodName = "NotExist";

        await executive.ApplyAsync(transactionContext);
        hostSmartContractBridgeContext.TransactionContext.ShouldBeNull();
        transactionContext.Trace.ExecutionStatus.ShouldBe(ExecutionStatus.SystemError);
        transactionContext.Trace.Error.ShouldContain("Failed to find handler for NotExist");
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/SmartContractService.cs (L77-90)
```csharp
    private bool CheckVersion(string previousContractVersion,string newContractVersion)
    {
        if (newContractVersion.IsNullOrEmpty())
        {
            return false;
        }

        if (previousContractVersion.IsNullOrEmpty())
        {
            return true;
        }

        return  new Version(previousContractVersion) < new Version(newContractVersion);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-127)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

```

**File:** protobuf/token_contract.proto (L170-173)
```text
    // Query the balance at the specified address.
    rpc GetBalance (GetBalanceInput) returns (GetBalanceOutput) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L180-197)
```csharp
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);

        Assert((input.Address == Context.Self || info.SerialNumber > 0) && input.ContractOperation == null ||
               info.SerialNumber == 0 && input.ContractOperation != null, "Not compatible.");

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, info.Version, codeHash);
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            AssertSameDeployer(input.Address, input.ContractOperation.Deployer);
        }
```
