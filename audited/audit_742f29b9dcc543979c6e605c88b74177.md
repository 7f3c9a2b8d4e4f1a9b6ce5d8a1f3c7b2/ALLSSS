### Title
Missing Validation of SupposedOrderOfNextRound Allows Mining Order Manipulation

### Summary
The consensus validation logic fails to verify that `SupposedOrderOfNextRound` values provided by miners match the deterministic calculation from their signatures. Miners can provide arbitrary `SupposedOrderOfNextRound` values during `UpdateValue` operations, which are stored without validation and later used to determine which miners participated in a round. This allows malicious miners to manipulate round participation records and potentially affect next round mining order generation.

### Finding Description

The vulnerability exists across multiple components:

**1. No Validation During UpdateValue**

When miners call `UpdateValue`, they provide `SupposedOrderOfNextRound` directly in the input, which is stored without any validation: [1](#0-0) 

The value should be calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1` as shown in the legitimate calculation: [2](#0-1) 

However, no validation provider checks this calculation. The `UpdateValueValidationProvider` only validates that `OutValue` and `Signature` are present: [3](#0-2) 

**2. Insufficient Validation in NextRoundMiningOrderValidationProvider**

The validation only checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count with `OutValue != null`: [4](#0-3) 

This validation does not:
- Verify `SupposedOrderOfNextRound` correctness based on signatures
- Check if `FinalOrderOfNextRound` values are unique (the `.Distinct()` on line 16 operates on `MinerInRound` objects, not the order values)
- Validate that orders are within valid range (1 to minersCount)

**3. Critical Dependency on SupposedOrderOfNextRound**

The `GetMinedMiners()` method determines which miners participated by checking `SupposedOrderOfNextRound != 0`: [5](#0-4) 

This filtered list is then used to determine mining order in the next round: [6](#0-5) 

**4. Recovery Process Propagates Manipulated Values**

During validation, the `RecoverFromUpdateValue` method copies `SupposedOrderOfNextRound` values from the provided round for ALL miners: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Compromise:**
- Malicious miners can set their `SupposedOrderOfNextRound = 0` to appear as "not mined" even though they produced blocks
- Miners who appear as "not mined" via `GetMinedMiners()` get excluded from priority ordering in the next round and have their `MissedTimeSlots` incremented [8](#0-7) 

**Mining Schedule Manipulation:**
- Attackers can manipulate who is considered an active participant vs. missed-slot miner
- This affects mining order assignment, expected mining times, and penalty tracking
- Honest miners could be unfairly penalized with increased `MissedTimeSlots` counts

**Cross-Round State Corruption:**
- Invalid `SupposedOrderOfNextRound` values persist in state and affect subsequent round transitions
- Evil miner detection logic depends on accurate missed time slot tracking, which can be subverted

### Likelihood Explanation

**Reachable Entry Point:**
The `UpdateValue` method is a standard public consensus operation called by miners during normal block production: [9](#0-8) 

**Attacker Capabilities:**
- Only requires being an active miner in the current round
- Attacker modifies their node to generate consensus extra data with manipulated `SupposedOrderOfNextRound` values
- No special privileges needed beyond normal miner status

**Execution Practicality:**
- Exploit is straightforward: provide incorrect `SupposedOrderOfNextRound` in `UpdateValueInput`
- The manipulated value passes all existing validation checks
- Value is permanently stored in consensus state

**Detection Difficulty:**
- Validators cannot easily detect the manipulation because:
  - The validation logic doesn't check correctness
  - Honest nodes would accept the block as valid
  - The incorrect values look like legitimate data

### Recommendation

**Add SupposedOrderOfNextRound Validation:**

Add a new validation provider or extend `UpdateValueValidationProvider` to verify:

```csharp
// In UpdateValueValidationProvider or new validator
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    if (minerInRound.SupposedOrderOfNextRound == 0) return true; // Not yet set
    
    var signature = minerInRound.Signature;
    if (signature == null) return false;
    
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    var sigNum = signature.ToInt64();
    var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

**Enhance NextRoundMiningOrderValidationProvider:**

Add validation to ensure:
1. All `FinalOrderOfNextRound` values are unique (check the actual values, not object equality)
2. All values are in valid range (1 to minersCount)
3. `SupposedOrderOfNextRound` consistency across the round

**Add State Consistency Check:**

Before storing in `ProcessUpdateValue`, recalculate and verify:

```csharp
// In ProcessUpdateValue
var minersCount = currentRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), minersCount) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, 
    "SupposedOrderOfNextRound does not match signature calculation");
```

### Proof of Concept

**Initial State:**
- Network has N active miners
- Attacker is miner with valid mining slot

**Attack Steps:**

1. **Attacker modifies their node code** to generate UpdateValue with manipulated `SupposedOrderOfNextRound`:
   - Calculate correct signature from InValue/OutValue
   - Set `SupposedOrderOfNextRound = 0` (instead of calculated value)
   - Generate UpdateValueInput with this manipulated value

2. **Attacker produces block** with the manipulated consensus extra data
   - Block passes `UpdateValueValidationProvider` (doesn't check SupposedOrderOfNextRound)
   - Block passes all other validation providers

3. **ProcessUpdateValue executes** and stores the manipulated value:
   - Line 246 stores `SupposedOrderOfNextRound = 0`
   - Line 247 stores `FinalOrderOfNextRound = 0`

4. **NextRound is triggered** by next extra block producer:
   - `GetMinedMiners()` filters by `SupposedOrderOfNextRound != 0`
   - Attacker is excluded (value is 0) despite having produced blocks
   - Attacker's `MissedTimeSlots` is incremented

5. **Impact manifests:**
   - Attacker avoids being tracked as active participant
   - Potentially avoids responsibilities associated with active mining status
   - Corrupts consensus tracking of miner participation

**Expected Result:** Block should be rejected due to invalid `SupposedOrderOfNextRound`

**Actual Result:** Block is accepted, manipulated value is stored, consensus state is corrupted

### Notes

The vulnerability stems from a trust assumption that miners will honestly calculate `SupposedOrderOfNextRound`. While the legitimate code path calculates this value correctly during block production, the validation logic never verifies this calculation. The `.Distinct()` call on line 16 of `NextRoundMiningOrderValidationProvider` appears to be checking for duplicate orders but actually operates on miner objects, making it ineffective. This is a critical gap in the consensus validation that could be exploited to manipulate mining schedules and participation tracking.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-53)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```
