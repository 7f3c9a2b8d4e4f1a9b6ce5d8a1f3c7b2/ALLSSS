### Title
Bidirectional RelatedSymbol Invariant Violation in TokenConverter Causes Inconsistent View Function Results

### Summary
The `MigrateConnectorTokens` function breaks the bidirectional `RelatedSymbol` invariant by updating resource connectors to point to new deposit connector symbols while leaving orphaned old deposit connectors that still reference the resource connectors. This causes `GetPairConnector` to return inconsistent connector pairs depending on which symbol is queried, violating the critical assumption that if connector A.RelatedSymbol=B, then B.RelatedSymbol=A.

### Finding Description

The `MigrateConnectorTokens` function updates connector relationships without maintaining bidirectionality: [1](#0-0) 

**Root Cause**: At line 329, the function updates `State.Connectors[resourceTokenSymbol].RelatedSymbol` to point to the new connector symbol (e.g., from "ntCPU" to "(NT)CPU"). At lines 333-335, it copies the old deposit connector to the new location, but the old connector at `oldConnectorTokenSymbol` remains in state with its original `RelatedSymbol` pointing back to the resource token. This creates a non-bidirectional relationship:
- `Connectors["CPU"].RelatedSymbol = "(NT)CPU"` ✓
- `Connectors["(NT)CPU"].RelatedSymbol = "CPU"` ✓  
- `Connectors["ntCPU"].RelatedSymbol = "CPU"` ✗ (orphaned - CPU no longer points back)

**Why Protections Fail**: The function has no access control validation, allowing any user to call it. Additionally, there is no logic to remove or disable the old connector after migration, and no validation to ensure bidirectionality is maintained.

**Impact on View Functions**: `GetPairConnector` assumes bidirectional relationships: [2](#0-1) 

After migration:
- `GetPairConnector("CPU")` returns `{ResourceConnector: CPU, DepositConnector: (NT)CPU}`
- `GetPairConnector("(NT)CPU")` returns `{ResourceConnector: CPU, DepositConnector: (NT)CPU}`
- `GetPairConnector("ntCPU")` returns `{ResourceConnector: CPU, DepositConnector: ntCPU}` ← **INCONSISTENT**

The function at line 42 retrieves `relatedConnector` using `targetConnector.RelatedSymbol`, assuming this relationship is bidirectional. When querying the orphaned "ntCPU" connector, it returns "CPU" as the resource connector, but "CPU" no longer recognizes "ntCPU" as its pair.

Similarly, `IsSymbolAbleToSell` relies on `GetPairConnector`: [3](#0-2) 

This causes `IsSymbolAbleToSell("ntCPU")` to return true even though "ntCPU" is deprecated, as it retrieves the orphaned deposit connector which still has `IsPurchaseEnabled = true`.

### Impact Explanation

**Harm**: 
1. **Inconsistent View Data**: Off-chain systems (price oracles, DEX aggregators, indexers) querying `GetPairConnector` receive different connector pairs depending on whether they query "CPU", "(NT)CPU", or "ntCPU", leading to incorrect pricing information or trade routing.

2. **Misleading Trading Status**: `IsSymbolAbleToSell` returns true for deprecated orphaned connectors, indicating they are tradeable when they are not intended to be used post-migration.

3. **Failed Transactions with Confusing Errors**: Users attempting to trade with orphaned connector symbols will have transactions fail at the token transfer step, but only after state modifications are attempted, creating poor user experience.

4. **Invariant Violation**: The core assumption that connector relationships are bidirectional is broken, which could affect future contract integrations or upgrades that rely on this invariant.

**Who is Affected**: 
- Off-chain systems relying on view functions for accurate connector pair information
- Users who might interact with orphaned connectors based on misleading view function results
- Future contract integrations assuming bidirectional invariants

**Severity Justification**: While direct fund theft is unlikely (transactions with orphaned connectors fail before funds are transferred), this represents a **Medium-to-High** severity issue due to:
- Critical invariant violation
- Operational impact on ecosystem integrations
- Potential for incorrect pricing data propagation
- No access control allowing any user to trigger the issue

### Likelihood Explanation

**Attacker Capabilities**: Any user can call `MigrateConnectorTokens` as there is no access control check in the function implementation.

**Attack Complexity**: Trivial - single function call with empty input: [4](#0-3) 

**Feasibility Conditions**: 
1. Connectors must exist for resource tokens in the `PayTxFeeSymbolListName` or `PayRentalSymbolListName` lists
2. The connectors must not have been previously migrated (assertion at line 325 prevents re-migration)
3. No authorization required - public callable method

**Detection**: The test suite verifies migration works for intended use cases but does not check for orphaned connector cleanup: [5](#0-4) 

The test only verifies the "Already migrated" assertion but doesn't validate that old connectors are properly cleaned up or that bidirectionality is maintained.

**Probability**: HIGH - The function is publicly callable without restrictions, and the migration is a one-time operation per connector that permanently breaks the invariant.

### Recommendation

**Code-Level Mitigation**:

1. **Add Access Control**: Restrict `MigrateConnectorTokens` to authorized governance:
```csharp
public override Empty MigrateConnectorTokens(Empty input)
{
    AssertPerformedByConnectorController(); // Add this check
    // ... rest of implementation
}
```

2. **Clean Up Orphaned Connectors**: After migration, disable or remove old connectors:
```csharp
// After line 335, add:
if (State.Connectors[oldConnectorTokenSymbol] != null)
{
    var oldConnector = State.Connectors[oldConnectorTokenSymbol];
    oldConnector.IsPurchaseEnabled = false; // Disable trading
    State.Connectors[oldConnectorTokenSymbol] = oldConnector;
    // Or completely remove: State.Connectors.Remove(oldConnectorTokenSymbol);
}
```

3. **Add Bidirectionality Validation**: Add a helper function to verify bidirectional relationships:
```csharp
private void AssertBidirectionalRelatedSymbol(string symbolA, string symbolB)
{
    var connectorA = State.Connectors[symbolA];
    var connectorB = State.Connectors[symbolB];
    Assert(connectorA?.RelatedSymbol == symbolB && connectorB?.RelatedSymbol == symbolA,
        "Connector RelatedSymbol must be bidirectional");
}
```

4. **Test Case for Regression Prevention**: Add test validating orphaned connectors are properly handled:
```csharp
[Fact]
public async Task MigrationShouldNotLeaveOrphanedConnectors()
{
    await MigrateConnectorTokens();
    
    var oldConnector = await GetConnector("ntCPU");
    oldConnector.IsPurchaseEnabled.ShouldBeFalse(); // Should be disabled
    
    // Verify bidirectionality
    var resourceConnector = await GetConnector("CPU");
    var newDepositConnector = await GetConnector(resourceConnector.RelatedSymbol);
    newDepositConnector.RelatedSymbol.ShouldBe("CPU"); // Should point back
}
```

### Proof of Concept

**Initial State** (before migration):
- `Connectors["CPU"]` exists with `RelatedSymbol = "ntCPU"`, `IsPurchaseEnabled = true`
- `Connectors["ntCPU"]` exists with `RelatedSymbol = "CPU"`, `IsPurchaseEnabled = true`, `IsDepositAccount = true`
- Bidirectional invariant holds: CPU ↔ ntCPU

**Exploitation Steps**:
1. Any user calls `MigrateConnectorTokens()` (no authorization required)
2. Function executes migration logic

**Actual Result** (after migration):
- `Connectors["CPU"].RelatedSymbol = "(NT)CPU"` (updated at line 329)
- `Connectors["(NT)CPU"]` created with `RelatedSymbol = "CPU"`, `IsPurchaseEnabled = true` (copied at line 335)
- `Connectors["ntCPU"]` **still exists** with `RelatedSymbol = "CPU"`, `IsPurchaseEnabled = true` (orphaned)

**Invariant Violation Demonstrated**:
- `GetPairConnector("CPU")` → Returns `{ResourceConnector: CPU, DepositConnector: (NT)CPU}`
- `GetPairConnector("ntCPU")` → Returns `{ResourceConnector: CPU, DepositConnector: ntCPU}` 
- **INCONSISTENT**: Same resource connector paired with different deposit connectors depending on query

**Success Condition**: 
The vulnerability is confirmed when:
1. Migration completes without errors
2. Old connector "ntCPU" remains in state with `IsPurchaseEnabled = true`
3. `GetPairConnector` returns different pairs for "CPU" vs "ntCPU"
4. `IsSymbolAbleToSell("ntCPU")` returns true despite being deprecated
5. Bidirectional invariant is violated: `Connectors["CPU"].RelatedSymbol ≠ "ntCPU"` but `Connectors["ntCPU"].RelatedSymbol = "CPU"`

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L311-342)
```csharp
    public override Empty MigrateConnectorTokens(Empty input)
    {
        foreach (var resourceTokenSymbol in Context.Variables.GetStringArray(PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(PayRentalSymbolListName)))
        {
            var newConnectorTokenSymbol = NewNtTokenPrefix.Append(resourceTokenSymbol);

            if (State.Connectors[resourceTokenSymbol] == null)
            {
                continue;
            }

            var oldConnectorTokenSymbol = State.Connectors[resourceTokenSymbol].RelatedSymbol;

            Assert(!oldConnectorTokenSymbol.StartsWith(NewNtTokenPrefix), "Already migrated.");

            // Migrate

            State.Connectors[resourceTokenSymbol].RelatedSymbol = newConnectorTokenSymbol;

            if (State.Connectors[oldConnectorTokenSymbol] != null)
            {
                var connector = State.Connectors[oldConnectorTokenSymbol];
                connector.Symbol = newConnectorTokenSymbol;
                State.Connectors[newConnectorTokenSymbol] = connector;
            }

            State.DepositBalance[newConnectorTokenSymbol] = State.DepositBalance[oldConnectorTokenSymbol];
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L37-54)
```csharp
    public override PairConnector GetPairConnector(TokenSymbol input)
    {
        var targetConnector = State.Connectors[input.Symbol];
        Connector relatedConnector = null;
        if (targetConnector != null)
            relatedConnector = State.Connectors[targetConnector.RelatedSymbol];
        if (targetConnector != null && targetConnector.IsDepositAccount)
            return new PairConnector
            {
                ResourceConnector = relatedConnector,
                DepositConnector = targetConnector
            };
        return new PairConnector
        {
            ResourceConnector = targetConnector,
            DepositConnector = relatedConnector
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L104-108)
```csharp
    public override BoolValue IsSymbolAbleToSell(StringValue input)
    {
        var depositConnector = GetPairConnector(new TokenSymbol { Symbol = input.Value }).DepositConnector;
        return new BoolValue { Value = depositConnector != null && depositConnector.IsPurchaseEnabled };
    }
```

**File:** protobuf/token_converter_contract.proto (L55-56)
```text
    rpc MigrateConnectorTokens (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ConnectorTokenMigrateTest.cs (L142-153)
```csharp
    [Fact]
    public async Task MigrateTwiceTest()
    {
        await CreateWriteToken();
        await InitializeTreasuryContractAsync();
        await InitializeTokenConverterContract();
        await PrepareToBuyAndSell();

        await DefaultStub.MigrateConnectorTokens.SendAsync(new Empty());
        var result = await DefaultStub.MigrateConnectorTokens.SendWithExceptionAsync(new Empty());
        result.TransactionResult.Error.ShouldContain("Already migrated.");
    }
```
