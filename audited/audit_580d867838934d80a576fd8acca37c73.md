### Title
Retroactive Vote Weight Inequality - Early Voters Maintain Inflated Weights After Interest Rate Changes

### Summary
The `SetVoteWeightInterest()` function modifies interest rates that affect vote weight calculations for new votes, but existing votes permanently retain their original weights calculated at creation time. This creates unfair reward distribution where early voters who locked in higher interest rates maintain inflated profit shares indefinitely, while later voters voting with identical parameters receive reduced shares after rate decreases.

### Finding Description

**Root Cause:**
When `SetVoteWeightInterest()` updates interest rates, it only modifies `State.VoteWeightInterestList.Value` without recalculating existing vote weights stored in the profit contract. [1](#0-0) 

**Vote Weight Calculation and Storage:**
Vote weights are calculated once at vote creation using `GetVotesWeight()` with the current interest rates, then permanently stored as "shares" in the profit scheme. [2](#0-1) [3](#0-2) 

The shares are added to the profit contract and used for all future reward distributions: [4](#0-3) [5](#0-4) 

**Why Weights Are Never Updated:**
Even when votes are extended via `ExtendVoterWelfareProfits()`, the `FixProfitDetail` method only updates period information, NOT the shares: [6](#0-5) [7](#0-6) 

The cloned profit detail retains the original shares value - there is no mechanism to update shares based on recalculated weights.

**Reward Distribution Impact:**
Profit distribution uses the formula: `voter_reward = (voter_shares / total_shares) * distributed_profits` [8](#0-7) 

Voters with higher shares receive proportionally more rewards, even if rate changes should have equalized their weights.

### Impact Explanation

**Direct Reward Misallocation:**
- Early voters who locked in higher interest rates maintain permanently inflated profit shares
- Later voters with identical voting parameters (amount, duration) receive reduced shares and rewards
- The disparity persists for entire lock periods (up to `MaximumLockTime`, potentially years)

**Quantified Example:**
1. User A votes 100 tokens for 365 days when interest rate produces weight = 200
2. Governance lowers interest rates via `SetVoteWeightInterest`
3. User B votes 100 tokens for 365 days, now receives weight = 150
4. User A receives 200/(200+150) = 57.1% of welfare rewards
5. User B receives 150/(200+150) = 42.9% of welfare rewards
6. **User A gets 33% more rewards despite identical voting parameters**

**Affected Parties:**
- All voters participating in election governance rewards
- New voters are systematically disadvantaged after rate decreases
- Protocol fairness and economic incentive alignment compromised

**Severity Justification:**
This violates the core invariant of fair profit distribution and creates exploitable economic asymmetries in governance participation.

### Likelihood Explanation

**Highly Practical Attack:**
- **Entry Point**: Public `Vote()` method accessible to all users
- **Trigger**: Governance-controlled `SetVoteWeightInterest()` (legitimate governance action)
- **Attacker Capabilities**: None required beyond normal voting rights
- **No Special Preconditions**: Works with any interest rate decrease

**Exploit Scenarios:**

*Scenario 1 - Malicious Governance:*
1. Malicious controller and allies vote early to lock in high weights
2. Controller proposes and executes `SetVoteWeightInterest` to lower rates
3. Competitors/new voters receive permanently reduced weights
4. Malicious coalition maintains disproportionate governance rewards

*Scenario 2 - Front-Running:*
1. Governance proposes legitimate rate decrease
2. Sophisticated voters front-run the proposal execution
3. Regular users vote after rate change
4. Front-runners maintain inflated weights for full lock period

*Scenario 3 - Natural Occurrence:*
1. Governance legitimately adjusts rates for economic reasons
2. Early voters accidentally maintain advantageous weights
3. New users unknowingly receive worse terms
4. Unfairness emerges without malicious intent

**Detection Difficulty:**
The weight disparity is not visible on-chain without comparing historical interest rates to current vote weights, making it unlikely users detect the unfairness.

**Economic Rationality:**
Zero-cost for voters who happen to vote before rate decreases; pure upside with no downside risk.

### Recommendation

**Immediate Fix - Add Weight Recalculation Mechanism:**

Modify `SetVoteWeightInterest()` to recalculate all active vote weights:

```solidity
public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
{
    AssertPerformedByVoteWeightInterestController();
    Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
    
    // ... existing validation ...
    
    // Store old rates for comparison
    var oldRates = State.VoteWeightInterestList.Value;
    State.VoteWeightInterestList.Value = input;
    
    // Recalculate weights for all active votes
    RecalculateAllActiveVoteWeights();
    
    return new Empty();
}

private void RecalculateAllActiveVoteWeights()
{
    // Iterate through all candidates
    foreach (var candidate in State.Candidates.Value.Value)
    {
        var candidateVotes = State.CandidateVotes[candidate.ToHex()];
        if (candidateVotes == null) continue;
        
        // Update each active vote's weight
        foreach (var voteId in candidateVotes.ObtainedActiveVotingRecordIds)
        {
            var votingRecord = State.VoteContract.GetVotingRecord.Call(voteId);
            var lockSeconds = State.LockTimeMap[voteId];
            var newWeight = GetVotesWeight(votingRecord.Amount, lockSeconds);
            
            // Update profit detail shares
            State.ProfitContract.UpdateBeneficiaryShares.Send(new UpdateBeneficiarySharesInput
            {
                SchemeId = State.WelfareHash.Value,
                Beneficiary = votingRecord.Voter,
                ProfitDetailId = voteId,
                NewShares = newWeight
            });
        }
    }
}
```

**Alternative - Document and Prevent Rate Changes:**

If recalculation is too expensive, either:
1. Make `SetVoteWeightInterest` callable only during initialization (before any votes)
2. Add clear warnings in governance proposals that rate changes don't affect existing votes
3. Implement gradual rate transitions over multiple periods

**Required Profit Contract Enhancement:**

Add `UpdateBeneficiaryShares` method to ProfitContract to update existing shares:

```solidity
public override Empty UpdateBeneficiaryShares(UpdateBeneficiarySharesInput input)
{
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(Context.Sender == scheme.Manager, "Only manager can update shares");
    
    var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];
    var detail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
    Assert(detail != null, "Profit detail not found");
    
    var oldShares = detail.Shares;
    detail.Shares = input.NewShares;
    
    // Update scheme total shares
    scheme.TotalShares = scheme.TotalShares.Sub(oldShares).Add(input.NewShares);
    
    State.SchemeInfos[input.SchemeId] = scheme;
    State.ProfitDetailsMap[input.SchemeId][input.Beneficiary] = profitDetails;
    
    return new Empty();
}
```

**Test Cases to Add:**

1. Vote before rate change, verify weight
2. Change rates via `SetVoteWeightInterest`
3. Verify original vote's weight updated to match new rates
4. Vote after rate change with identical parameters
5. Verify both votes have equal weights and receive equal rewards
6. Test with rate increases and decreases
7. Test with multiple concurrent votes

### Proof of Concept

**Initial State:**
- Default interest rates configured (e.g., 365 days → weight multiplier = 2.0)
- Two users: Alice and Bob, each with 1000 tokens

**Attack Sequence:**

1. **Alice votes early (T=0):**
   - Alice calls `Vote()` with 1000 tokens, 365-day lock
   - `GetVotesWeight(1000, 31536000)` calculates weight = 2000
   - Alice added to welfare scheme with shares = 2000

2. **Governance lowers rates (T=100):**
   - Parliament proposes `SetVoteWeightInterest` with reduced rates
   - New rates: 365 days → weight multiplier = 1.5
   - Proposal executes successfully
   - `State.VoteWeightInterestList.Value` updated
   - **Alice's stored shares remain 2000** (unchanged)

3. **Bob votes late (T=200):**
   - Bob calls `Vote()` with 1000 tokens, 365-day lock
   - `GetVotesWeight(1000, 31536000)` calculates weight = 1500 (new rates)
   - Bob added to welfare scheme with shares = 1500

4. **Profit Distribution (T=300):**
   - Scheme distributes 1000 tokens to welfare beneficiaries
   - Total shares = 2000 + 1500 = 3500
   - Alice receives: (2000/3500) × 1000 = 571.4 tokens
   - Bob receives: (1500/3500) × 1000 = 428.6 tokens

**Expected vs Actual Result:**
- **Expected (Fair):** Both Alice and Bob receive 500 tokens (equal weights)
- **Actual (Unfair):** Alice receives 571.4 tokens, Bob receives 428.6 tokens
- **Discrepancy:** Alice receives 33% more rewards with identical voting parameters

**Success Condition:**
Alice maintains permanently inflated weights until her 365-day lock expires, receiving disproportionate rewards throughout the period while Bob and all subsequent voters are penalized.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L443-443)
```csharp
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L296-305)
```csharp
        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
```

**File:** test/AElf.Contracts.Election.Tests/ProfitShare.cs (L45-56)
```csharp
    public long CalculateProfits(int period, long totalProfits, string voterPubkey)
    {
        var totalShares = GetTotalSharesOfPeriod(period);
        var shareDict = GetSharesOfPeriod(period);
        if (!shareDict.ContainsKey(voterPubkey))
        {
            return 0;
        }

        var voterShares = shareDict[voterPubkey];
        return voterShares * totalProfits / totalShares;
    }
```
