### Title
MEV Extraction Through Transaction Reordering Across Multiple Continuous Blocks

### Summary
The `ValidateHeaderInformation()` function permits miners to produce up to 8 consecutive blocks without enforcing transaction ordering constraints, enabling MEV extraction. A miner controlling multiple continuous blocks can reorder transactions across their block production window to front-run, sandwich, or censor transactions for profit, as the protocol lacks mechanisms to validate transaction ordering against the mempool state.

### Finding Description

The vulnerability exists in the interaction between continuous block production limits and the absence of transaction ordering enforcement:

**Continuous Blocks Validation**: The system allows miners to produce up to 8 consecutive "tiny blocks" under normal conditions. [1](#0-0)  The validation only checks if a miner exceeded this limit by verifying `BlocksCount < 0`. [2](#0-1) 

**Transaction Ordering in Default Implementation**: Transactions are retrieved from the mempool ordered by `EnqueueTime` (FIFO). [3](#0-2)  This ordering is passed through to mining. [4](#0-3) 

**Lack of Protocol Enforcement**: Block validation only verifies that the merkle tree root matches the transaction list in the block body, but does NOT validate transaction ordering against any external reference. [5](#0-4)  The merkle root is calculated from whatever transaction order the miner provides. [6](#0-5) 

**Insufficient MEV Protection**: While the consensus implements secret sharing to prevent miner order prediction, [7](#0-6)  this only prevents knowing which miner will produce future blocks, not transaction reordering within blocks a miner already controls.

**Exploitation Path**: A sophisticated miner can run modified node software that reorders transactions after retrieval from the pool but before block creation. The protocol has no mechanism to detect or prevent this reordering, as blocks are validated based only on their internal consistency (merkle roots, signatures), not their adherence to mempool ordering.

### Impact Explanation

**Direct Fund Impact**: Miners can extract value through multiple MEV attack vectors:
- **Front-running**: Insert transactions ahead of profitable user transactions (DEX swaps, NFT purchases, liquidations)
- **Sandwich attacks**: Place transactions before and after victim transactions to extract slippage
- **Censorship**: Exclude competitor transactions or manipulate market conditions
- **Multi-block coordination**: With 8 consecutive blocks, miners can execute sophisticated attacks spanning multiple blocks, extracting significantly more value than single-block MEV

**Who is Affected**: All users submitting transactions during periods when a miner controls multiple consecutive blocks become potential MEV victims. DeFi protocols, NFT marketplaces, and time-sensitive transactions are particularly vulnerable.

**Severity Justification**: MEDIUM severity because while the impact is HIGH (direct fund theft), the likelihood is MEDIUM (requires custom node software implementation, though technically straightforward for sophisticated mining operations). The 8-block continuous window significantly amplifies potential extraction compared to single-block scenarios.

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the consensus who is selected to produce blocks can execute this attack by running modified node software.

**Attack Complexity**: LOW - The modification required is straightforward:
1. Intercept transaction list after `GetExecutableTransactionSetAsync()` call
2. Implement transaction reordering logic based on MEV opportunity detection
3. Pass reordered list to `MineAsync()`

**Feasibility Conditions**: 
- Miner must be selected for block production (normal consensus operation)
- Miner must run custom node software (requires technical capability but no protocol permission)
- Profitable MEV opportunities must exist in the mempool (common in DeFi environments)

**Detection Constraints**: Extremely difficult to detect on-chain, as reordered blocks appear valid and pass all consensus checks. Off-chain analysis would be required to compare mempool state with final block ordering.

**Probability**: MEDIUM - While requiring custom software development, the economic incentive is strong and the technical barrier is low for professional mining operations. The 8-block window provides sufficient extraction opportunity to justify the development investment.

### Recommendation

**Immediate Mitigations**:

1. **Reduce Continuous Block Limit**: Decrease `MaximumTinyBlocksCount` from 8 to 1-2 blocks to minimize MEV extraction window. [1](#0-0) 

2. **Implement Transaction Ordering Commitment**: Add validation that blocks must include transactions in mempool FIFO order. This requires:
   - Recording transaction pool state at block production time
   - Validating block transaction order against committed pool state
   - Rejecting blocks with arbitrary reordering

3. **Add Transaction Ordering Validation Provider**: Create new `IHeaderInformationValidationProvider` that checks transaction ordering integrity alongside the existing continuous blocks validation.

4. **Enhance BreakContinuousMining**: Strengthen the existing mechanism that prevents same miner from being last in round N and first in round N+1. [8](#0-7) 

**Test Cases**:
- Verify blocks with non-FIFO transaction ordering are rejected
- Test that continuous block limit properly restricts MEV window
- Validate detection of transaction censorship across multiple blocks

### Proof of Concept

**Required Initial State**:
- Miner is selected to produce 8 consecutive blocks
- Mempool contains profitable MEV opportunity (e.g., large DEX swap pending)
- Miner runs custom node software with transaction reordering logic

**Attack Steps**:
1. User submits large DEX swap transaction to mempool (EnqueueTime = T1)
2. Miner's node detects profitable front-running opportunity
3. Miner submits own front-running transaction (EnqueueTime = T2, where T2 > T1)
4. During block production, miner's modified `MinerService.MineAsync()` reorders transactions to place miner's transaction first
5. `BlockExecutingService.ExecuteBlockAsync()` executes reordered list: [Miner's tx, User's tx]
6. Block merkle root is calculated from reordered list and passes validation
7. Miner extracts profit from price movement caused by front-running

**Expected vs Actual Result**:
- **Expected** (FIFO): User's transaction (T1) executes before miner's transaction (T2)
- **Actual** (Reordered): Miner's transaction executes first despite later EnqueueTime

**Success Condition**: Miner's transaction executes before user's transaction in the finalized block, despite having a later `EnqueueTime`, enabling MEV extraction. The block passes all protocol validation checks despite the ordering manipulation.

**Notes**: The 8-block continuous window allows the miner to coordinate even more sophisticated attacks across multiple blocks, such as multi-step arbitrage or complex sandwich attacks that would be impossible with single-block control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-23)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/TxHub.cs (L76-78)
```csharp
        output.Transactions.AddRange(_validatedTransactions.Values.OrderBy(x => x.EnqueueTime)
            .Take(transactionCount)
            .Select(x => x.Transaction));
```

**File:** src/AElf.Kernel/Miner/Application/MinerService.cs (L52-55)
```csharp
            var executableTransactionSet = await _transactionPoolService.GetExecutableTransactionSetAsync(
                previousBlockHash, limit);

            txList.AddRange(executableTransactionSet.Transactions);
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L127-131)
```csharp
        if (block.Body.CalculateMerkleTreeRoot() != block.Header.MerkleTreeRootOfTransactions)
        {
            Logger.LogDebug("Block merkle tree root mismatch");
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L129-131)
```csharp
                MerkleTreeRootOfWorldState = CalculateWorldStateMerkleTreeRoot(blockStateSet),
                MerkleTreeRootOfTransactionStatus = CalculateTransactionStatusMerkleTreeRoot(orderedReturnSets),
                MerkleTreeRootOfTransactions = CalculateTransactionMerkleTreeRoot(allExecutedTransactionIds)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-53)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```
