### Title
Solitary Miner Detection False Positive Causes Denial of Service for Legitimate Miners

### Summary
The `SolitaryMinerDetection()` function contains a logic error that incorrectly marks legitimate miners as solitary at the beginning of each round. When a miner was the only one producing blocks in the previous two rounds (due to temporary network issues or downtime of other miners), they are permanently blocked from mining even when other miners become available again, causing consensus disruption.

### Finding Description

The vulnerability exists in the `SolitaryMinerDetection()` function: [1](#0-0) 

The root cause is at line 75, where `isAlone = minedMinersOfCurrentRound.Count == 0` sets the flag to `true` when no miners have produced blocks in the current round yet. This is a **normal condition at the start of every round**, not evidence of a miner being solitary.

The detection logic flows as follows:
1. At the start of round N, `GetMinedMiners()` returns an empty list (no one has mined yet)
2. Line 75 sets `isAlone = true` 
3. Lines 78-83 check if only this miner produced blocks in round N-1
4. Lines 86-92 check if only this miner produced blocks in round N-2
5. If both checks pass, the function returns `true` [2](#0-1) 

When `SolitaryMinerDetection()` returns `true`, the miner receives `InvalidConsensusCommand`: [3](#0-2) 

This command blocks the miner from producing blocks: [4](#0-3) 

The detection is called from the public entry point: [5](#0-4) 

### Impact Explanation

**Consensus Disruption**: When a legitimate miner is incorrectly marked as solitary and blocked, the consensus mechanism fails to function properly. If this miner has the first time slot in the round, the blockchain cannot progress until their time slot passes.

**Blockchain Halt Risk**: In scenarios where the blocked miner is critical to the current round's progression, the entire blockchain can experience significant delays or halt, affecting all users and applications.

**Scope**: Any miner in a network with >2 miners after round 3 can be affected. The vulnerability triggers deterministically when:
- The miner was the sole producer in rounds N-2 and N-1 (e.g., due to network partition, DDoS attacks on other miners, or temporary infrastructure issues)
- Other miners are now available in round N
- The detection incorrectly treats the empty current round as evidence of continued isolation

**Severity**: Critical - The vulnerability directly violates the "miner schedule integrity" invariant and causes operational DoS of the consensus flow, preventing legitimate block production.

### Likelihood Explanation

**Entry Point**: Reachable through the public `GetConsensusCommand()` ACS4 interface method, called by any miner attempting to produce blocks.

**Preconditions**: 
- Network must have >2 miners (standard production configuration)
- Round number must be >3 (reached within minutes of blockchain operation)
- Target miner must have been the only one producing blocks in the previous 2 consecutive rounds

**Feasibility**: The precondition of one miner being alone for 2 rounds is realistic and can occur naturally through:
- Network partitions isolating subsets of miners
- Temporary infrastructure outages affecting multiple miners simultaneously
- DDoS attacks targeting other miners
- Configuration errors during network setup

**Detection**: The vulnerability is triggered automatically without any malicious action required. Once a miner is in the vulnerable state, the detection **always** returns a false positive at the start of every subsequent round, permanently blocking them.

**Probability**: HIGH - Network disruptions affecting multiple miners simultaneously are common in distributed systems. The deterministic nature means 100% reproduction once conditions are met.

### Recommendation

**Immediate Fix**: Modify the detection logic to exclude the current (incomplete) round from the isolation check:

```csharp
private bool SolitaryMinerDetection(Round currentRound, string pubkey)
{
    var isAlone = false;
    // Skip this detection until 4th round.
    if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
    {
        // Check if only this node mined during previous round
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            var minedMiners = previousRound.GetMinedMiners();
            isAlone = minedMiners.Count == 1 &&
                      minedMiners.Select(m => m.Pubkey).Contains(pubkey);
        }

        // Check one further round back
        if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                out var previousPreviousRound))
        {
            var minedMiners = previousPreviousRound.GetMinedMiners();
            isAlone = minedMiners.Count == 1 &&
                      minedMiners.Select(m => m.Pubkey).Contains(pubkey);
        }
    }

    return isAlone;
}
```

**Key Changes**:
- Remove line 74-75 that checks the current round
- Only examine completed rounds (N-1 and N-2) where all miners have had their opportunity to produce blocks

**Additional Safeguards**:
1. Add a configurable "recovery window" - allow the isolated miner to produce at least one block in the new round before re-evaluating isolation status
2. Implement logging when detection triggers to enable monitoring
3. Add integration tests covering: miner isolation for 2 rounds, followed by other miners coming back online

**Invariant to Enforce**: Solitary detection must only evaluate completed rounds where all scheduled miners have had their time slots, never the current in-progress round.

### Proof of Concept

**Initial State**:
- Blockchain with 5 miners: A, B, C, D, E
- Current round: 5 (after round 4)
- All miners configured and in the miner list

**Attack Sequence**:

1. **Round 3**: Network partition occurs. Miners B, C, D, E experience connectivity issues. Only Miner A produces blocks successfully.
   - Result: Round 3 completes with only Miner A having `SupposedOrderOfNextRound != 0`

2. **Round 4**: Network issues persist. Only Miner A produces blocks.
   - Result: Round 4 completes with only Miner A having mined

3. **Round 5 Begins**: Network partition is resolved. All miners are back online.

4. **Miner A calls `GetConsensusCommand()`**:
   - `SolitaryMinerDetection()` is invoked
   - Line 74: `currentRound.GetMinedMiners()` returns empty list (round just started)
   - Line 75: `isAlone = true` (FALSE POSITIVE - current round is empty for everyone)
   - Line 78-82: Check round 4 → only Miner A mined → `isAlone` stays `true`
   - Line 86-91: Check round 3 → only Miner A mined → `isAlone` stays `true`
   - Returns `true`
   
5. **Result**: Line 24 returns `InvalidConsensusCommand` with `ArrangedMiningTime = int.MaxValue`

**Expected**: Miner A should be allowed to produce blocks since other miners are now available

**Actual**: Miner A is permanently blocked from producing blocks, even though miners B, C, D, E are now ready to participate

**Success Condition**: Miner A receives `InvalidConsensusCommand` and cannot produce blocks, while being a legitimate active miner in a multi-node network.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L20-24)
```csharp
    private ConsensusCommand GetConsensusCommand(AElfConsensusBehaviour behaviour, Round currentRound,
        string pubkey, Timestamp currentBlockTime = null)
    {
        if (SolitaryMinerDetection(currentRound, pubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L66-96)
```csharp
    private bool SolitaryMinerDetection(Round currentRound, string pubkey)
    {
        var isAlone = false;
        // Skip this detection until 4th round.
        if (currentRound.RoundNumber > 3 && currentRound.RealTimeMinersInformation.Count > 2)
        {
            // Not single node.

            var minedMinersOfCurrentRound = currentRound.GetMinedMiners();
            isAlone = minedMinersOfCurrentRound.Count == 0;

            // If only this node mined during previous round, stop mining.
            if (TryToGetPreviousRoundInformation(out var previousRound) && isAlone)
            {
                var minedMiners = previousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }

            // check one further round.
            if (isAlone && TryToGetRoundInformation(previousRound.RoundNumber.Sub(1),
                    out var previousPreviousRound))
            {
                var minedMiners = previousPreviousRound.GetMinedMiners();
                isAlone = minedMiners.Count == 1 &&
                          minedMiners.Select(m => m.Pubkey).Contains(pubkey);
            }
        }

        return isAlone;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusCommandProvider.cs (L23-30)
```csharp
        public static ConsensusCommand InvalidConsensusCommand => new()
        {
            ArrangedMiningTime = new Timestamp { Seconds = int.MaxValue },
            Hint = ByteString.CopyFrom(new AElfConsensusHint
            {
                Behaviour = AElfConsensusBehaviour.Nothing
            }.ToByteArray())
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```
