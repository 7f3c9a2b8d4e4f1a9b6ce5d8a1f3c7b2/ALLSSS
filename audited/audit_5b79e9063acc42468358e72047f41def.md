# Audit Report

## Title
Retroactive Vote Manipulation Through Dynamic Membership Changes in Association Contract

## Summary
The Association contract's vote counting mechanism evaluates votes based on current membership status rather than membership status at the time of voting, enabling retroactive invalidation of votes through membership changes.

## Finding Description

The vulnerability exists in the temporal inconsistency between vote recording and vote counting in the Association contract.

**Vote Recording Phase:**
When members cast votes via `Approve()`, `Reject()`, or `Abstain()`, the contract verifies membership at vote time and records the vote permanently in the proposal's lists. [1](#0-0) 

**Vote Counting Phase:**
When `Release()` is called, it invokes `IsReleaseThresholdReached()` to verify if the proposal can be executed. [2](#0-1) 

The critical flaw lies in the vote counting functions that filter votes against the **current** membership list. The `CheckEnoughVoteAndApprovals()` method counts approvals only from current members: [3](#0-2) 

Similarly, rejection and abstention counts are filtered through current membership: [4](#0-3) 

The `Contains()` method checks against the organization's current member list: [5](#0-4) 

**Membership Manipulation:**
Organizations can modify membership through `AddMember()` and `RemoveMember()` methods callable by the organization address itself (via governance proposals): [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. Organization with 7 members (A, B, C, D, E, F, G) has MinimalApprovalThreshold=4
2. Proposal P1 receives 4 approvals from members A, B, C, D
3. Organization passes separate proposal P2 to remove member B
4. When Release(P1) is attempted, only 3 approvals count (A, C, D remain members)
5. P1 cannot be released despite legitimately meeting the threshold when votes were cast

## Impact Explanation

**Governance Integrity Compromise:**
- Proposals that legitimately reached approval thresholds can be prevented from passing by removing approving members
- Proposals that should fail can be made to pass by removing rejecting members
- Organization members' votes are retroactively invalidated without their knowledge or consent

**Affected Parties:**
- Organization members whose votes are nullified after casting them
- Proposers whose proposals fail due to manipulation
- The entire governance process integrity for Association organizations

**Severity: Medium** - While it requires passing a membership change proposal first (which itself requires threshold votes), such changes are legitimate operations that mask the manipulation. The impact is governance integrity compromise rather than direct fund loss.

## Likelihood Explanation

**Attacker Capabilities:**
An attacker with majority control can pass membership change proposals and systematically manipulate pending proposals through strategic member removal/addition.

**Attack Complexity:**
Low - only requires calling standard `AddMember`/`RemoveMember` through governance proposals. No complex transaction sequences or external dependencies required.

**Detection Constraints:**
- Membership changes appear as legitimate governance actions
- The connection between membership changes and vote invalidation is not transparent
- No events or warnings indicate that existing votes are being invalidated

**Likelihood: Medium-High** - Once an attacker gains governance majority, membership changes are expected operations, making the attack vector unobvious. The lack of vote immutability protection makes this exploitable whenever membership changes occur during active proposal voting periods.

## Recommendation

Implement vote immutability by capturing membership status at the time of voting rather than at release time. Options include:

1. **Snapshot-based approach:** Store a snapshot of the organization's membership list when a proposal is created, and count votes against this snapshot.

2. **Vote weight recording:** Record the voter's "weight" or validity flag at vote time, ensuring votes remain valid regardless of future membership changes.

3. **Membership lock during voting:** Prevent membership changes while proposals have active votes (though this may be too restrictive for governance operations).

The recommended fix is option 1 - storing a membership snapshot per proposal and counting votes against that snapshot at release time.

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
public async Task VoteManipulation_ThroughMembershipChange()
{
    // Setup: Create organization with 7 members, MinimalApprovalThreshold=4
    var members = new[] { MemberA, MemberB, MemberC, MemberD, MemberE, MemberF, MemberG };
    var organizationAddress = await CreateOrganization(members, minimalApprovalThreshold: 4);
    
    // Step 1: Create proposal P1
    var proposalId = await CreateProposal(organizationAddress);
    
    // Step 2: Members A, B, C, D approve proposal P1 (meets threshold of 4)
    await ApproveAs(MemberA, proposalId);
    await ApproveAs(MemberB, proposalId);
    await ApproveAs(MemberC, proposalId);
    await ApproveAs(MemberD, proposalId);
    
    // Verify: Proposal should be releasable
    var canRelease1 = await CanReleaseProposal(proposalId);
    Assert.True(canRelease1); // 4 approvals >= 4 threshold
    
    // Step 3: Organization passes proposal P2 to remove MemberB
    var removeMemberProposalId = await CreateProposalToRemoveMember(organizationAddress, MemberB);
    await ApproveAndRelease(removeMemberProposalId, members.Take(4)); // Pass with A,C,D,E
    
    // Step 4: Attempt to release original proposal P1
    var canRelease2 = await CanReleaseProposal(proposalId);
    Assert.False(canRelease2); // Only 3 approvals count now (A,C,D) < 4 threshold
    
    // Vulnerability confirmed: P1 cannot be released despite legitimately 
    // meeting the threshold when votes were cast
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-246)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
