# Audit Report

## Title
Insufficient Validation of TuneOrderInformation Allows Miner Order Manipulation and Consensus Disruption

## Summary
The `ProcessUpdateValue` function in the AEDPoS consensus contract lacks validation to prevent miners from manipulating their own mining order through the `TuneOrderInformation` field. A malicious miner can override their `FinalOrderOfNextRound` value after it's set, enabling arbitrary position selection in the next consensus round and creating duplicate or invalid order assignments that compromise consensus integrity.

## Finding Description

The `ProcessUpdateValue` function processes consensus updates during normal block production. It first sets the current miner's `FinalOrderOfNextRound` equal to their `SupposedOrderOfNextRound`: [1](#0-0) 

Subsequently, the function unconditionally applies all entries from `TuneOrderInformation` without validating whether the current miner is included: [2](#0-1) 

The `UpdateValueValidationProvider` only validates cryptographic fields (`OutValue`, `Signature`, `PreviousInValue`) and does not check the contents or constraints of `TuneOrderInformation`: [3](#0-2) 

The legitimate use of `TuneOrderInformation` is to propagate order adjustments for OTHER miners who had conflicts, as shown in the extraction logic: [4](#0-3) 

This extraction only includes miners where `FinalOrderOfNextRound != SupposedOrderOfNextRound`, representing conflict resolution. However, nothing in `ProcessUpdateValue` enforces that `TuneOrderInformation` cannot include the current miner's own public key.

**Attack Execution:**
1. A malicious miner modifies their client to construct a custom `UpdateValueInput`
2. Instead of using `ExtractInformationToUpdateConsensus`, they manually add their own public key to `TuneOrderInformation` with an arbitrary order value
3. When `ProcessUpdateValue` executes, line 247 sets their `FinalOrderOfNextRound = SupposedOrderOfNextRound`
4. Immediately after, line 260 overwrites this with the malicious value from `TuneOrderInformation`
5. The manipulated order is stored in the round state

## Impact Explanation

**1. Order Manipulation for Mining Advantage:**
Miners can arbitrarily select their position in the next consensus round, completely bypassing the signature-based randomization mechanism. The `FinalOrderOfNextRound` values directly determine mining order assignment in the next round: [5](#0-4) 

A malicious miner could consistently place themselves in advantageous positions (e.g., first to maximize block rewards and transaction fees) or manipulate timing to front-run other miners' transactions.

**2. Consensus Integrity Violation via Duplicate Orders:**
A malicious miner can set their order to match another miner's existing `FinalOrderOfNextRound`, creating duplicate order assignments. When `GenerateNextRoundInformation` processes these duplicates, multiple miners receive the same `Order` value in the next round, while other order values remain unassigned. This creates gaps in the mining schedule where no miner is assigned to specific time slots, and multiple miners attempt to mine at the same slot.

**3. Consensus State Corruption:**
The `BreakContinuousMining` logic assumes valid order assignments: [6](#0-5) 

With invalid order distributions caused by duplicates, operations like `FirstOrDefault(i => i.Order == minersCount)` may return null or incorrect miners, causing the round generation to produce malformed consensus state. This breaks fundamental consensus invariants about unique time slot assignments and proper scheduling.

## Likelihood Explanation

**Attacker Capabilities:** Any active miner in the current miner list can execute this attack during their scheduled mining turn.

**Attack Complexity:** LOW - The attacker only needs to:
1. Modify their local consensus client code
2. Replace the call to `ExtractInformationToUpdateConsensus` [7](#0-6)  with custom code that includes their own public key in `TuneOrderInformation`
3. Submit the malicious `UpdateValue` transaction during their normal mining turn

**Preconditions:**
- Attacker must be an active miner (publicly known role)
- No special permissions required beyond normal mining rights
- Attack occurs during their legitimately scheduled time slot

**Detection:** The manipulation is difficult to detect because `TuneOrderInformation` is a nested map field not typically audited externally. The order change only becomes apparent when the next round is generated, by which time the malicious state is already persisted.

**Economic Incentives:** The attack cost is minimal (local code modification only), while potential benefits include:
- Consistent favorable positioning for higher block rewards
- Ability to front-run transactions
- Disruption of competing miners
- In extreme cases, denial of service to gain market advantage

## Recommendation

Add validation in `ProcessUpdateValue` to prevent miners from including their own public key in `TuneOrderInformation`:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Prevent self-tuning
    Assert(tuneOrder.Key != _processingBlockMinerPubkey, 
        "Miners cannot tune their own order.");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

Additionally, consider adding validation to detect and reject duplicate `FinalOrderOfNextRound` values before storing the round state, ensuring that all miners have unique order assignments.

## Proof of Concept

A proof of concept would require:
1. Deploying a test AEDPoS consensus contract
2. Setting up a test network with multiple miners
3. Modifying one miner's client to inject their own pubkey into `TuneOrderInformation` with a duplicate or arbitrary order value
4. Observing that the `UpdateValue` transaction succeeds
5. Verifying that the next round generation produces duplicate orders or fails to generate valid mining schedules
6. Demonstrating that consensus progression is disrupted

The vulnerability is confirmed by code analysis showing no validation path prevents self-inclusion in `TuneOrderInformation`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-247)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```
