# Audit Report

## Title
Unauthorized Manager Assignment in CreateScheme Enables Unbounded List Growth DoS Attack

## Summary
The `CreateScheme` function in the Profit contract allows any caller to specify an arbitrary address as the scheme manager without authorization verification. By repeatedly calling `CreateScheme` with unique `Token` values, an attacker can inflate the victim's `ManagingSchemeIds` list to millions of entries, causing permanent denial of service on `ResetManager`, `GetManagingSchemeIds`, and degrading legitimate scheme creation operations.

## Finding Description

The vulnerability exists in the `CreateScheme` function's acceptance of an arbitrary `manager` parameter without verifying the caller has permission from that address. [1](#0-0) 

The function unconditionally adds each new scheme ID to the specified manager's list with no maximum size limit: [2](#0-1) 

The only protection is a duplicate scheme ID check, which an attacker bypasses by providing unique `Token` values in each call. The protobuf specification confirms this parameter exists: [3](#0-2) 

When a `Token` is provided, the scheme ID generation uses it to create unique identifiers: [4](#0-3) 

**Attack Execution:**
1. Attacker repeatedly calls `CreateScheme` with `Manager = VictimAddress` and unique `Token` values
2. Each call generates a unique scheme ID via `GenerateSchemeId`
3. Each scheme ID is appended to `State.ManagingSchemeIds[VictimAddress]` 
4. No maximum limit exists, allowing unbounded growth

## Impact Explanation

**Primary DoS - ResetManager Failure:**

The `ResetManager` function performs O(n) operations on the scheme ID list: [5](#0-4) 

With millions of entries, the `Remove` operation requires scanning the entire protobuf repeated field, and writing the modified list back to state exceeds gas limits. The victim permanently loses the ability to transfer management of their legitimate schemes.

**Secondary DoS - View Function Failure:**

The `GetManagingSchemeIds` view function returns the entire list without pagination: [6](#0-5) 

Large lists exceed response size limits or timeout, preventing queries and breaking off-chain systems that depend on this data.

**Affected Parties:**
- System contracts (Treasury, TokenHolder) managing profit schemes
- DApp developers relying on profit distribution
- Any address can be targeted, causing widespread protocol disruption

## Likelihood Explanation

**Attacker Profile:** Any standard account with gas can execute this attack - no special permissions, stake, or role compromise required.

**Attack Complexity:** Trivial. The attacker loops calling `CreateScheme` with incrementing token values. Each call succeeds and adds to the victim's list.

**Economic Feasibility:** Attack cost equals `CreateScheme` gas cost multiplied by the number of schemes. Even creating 100,000 schemes is economically viable for targeted attacks against high-value system contracts or DApp operators.

**Detection Limitations:** The attack leaves on-chain evidence but no prevention mechanism exists. By detection time, the DoS is already permanent.

## Recommendation

Add authorization validation in `CreateScheme` to ensure only the specified manager can create schemes for themselves:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);
    
    var manager = input.Manager ?? Context.Sender;
    
    // Add authorization check
    if (input.Manager != null)
    {
        Assert(Context.Sender == input.Manager, 
            "Only the manager can create schemes for their address.");
    }
    
    // ... rest of existing code
}
```

Additionally, consider implementing:
- Maximum limit on schemes per manager address
- Pagination for `GetManagingSchemeIds` view function
- Rate limiting on scheme creation

## Proof of Concept

```csharp
[Fact]
public async Task UnauthorizedManagerAssignment_CausesDoS()
{
    // Setup: Get attacker and victim accounts
    var attackerStub = GetProfitContractTester(NormalKeyPair[0]);
    var victimAddress = Address.FromPublicKey(NormalKeyPair[1].PublicKey);
    
    // Attack: Create 1000 schemes with victim as manager (attacker unauthorized)
    for (int i = 0; i < 1000; i++)
    {
        var token = HashHelper.ComputeFrom(i);
        await attackerStub.CreateScheme.SendAsync(new CreateSchemeInput
        {
            Manager = victimAddress,
            Token = token,
            ProfitReceivingDuePeriodCount = 1
        });
    }
    
    // Verify: Victim's list is now bloated
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = victimAddress });
    
    Assert.Equal(1000, schemeIds.SchemeIds.Count);
    
    // Impact: Victim cannot ResetManager due to gas exhaustion
    var victimStub = GetProfitContractTester(NormalKeyPair[1]);
    var firstScheme = schemeIds.SchemeIds[0];
    
    // This will fail with gas exhaustion on large lists
    var result = await victimStub.ResetManager.SendWithExceptionAsync(
        new ResetManagerInput
        {
            SchemeId = firstScheme,
            NewManager = Address.FromPublicKey(NormalKeyPair[2].PublicKey)
        });
    
    // Transaction fails or times out due to O(n) Remove operation
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Failed);
}
```

## Notes

This vulnerability represents a critical availability breach in the Profit contract. The lack of authorization on the `manager` parameter violates the fundamental security principle that only authorized parties should modify an account's state. The attack is particularly severe because:

1. It targets system contracts (Treasury, TokenHolder) that are essential for protocol economics
2. The DoS is permanent once inflicted - no recovery mechanism exists
3. The attack cost is relatively low compared to the damage inflicted
4. Multiple critical operations become unusable simultaneously

The recommended fix should be implemented immediately, and existing chains should consider a governance proposal to clear maliciously inflated scheme lists if any attacks have occurred.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L57-57)
```csharp
        var manager = input.Manager ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L733-735)
```csharp
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L967-968)
```csharp
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
```

**File:** protobuf/profit_contract.proto (L132-132)
```text
    aelf.Hash token = 6;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
