### Title
Multi-Signature Bypass via Proposal Release Timing Window in Association Governance

### Summary
The Association contract allows an authorized proposer to release a proposal immediately upon reaching the minimum approval threshold, without any mandatory delay for other organization members to submit rejections. This enables a malicious proposer to bypass multi-sig protections by front-running rejection votes, allowing unauthorized changes to the CrossChain contract's method fee controller with only a subset of required member consensus.

### Finding Description

The vulnerability exists in the interaction between the CrossChain contract's `ChangeMethodFeeController()` function and the Association governance contract's proposal release mechanism. [1](#0-0) 

The CrossChain contract properly validates that the sender is the current controller's owner address, which would be an Association organization address for multi-sig governance. [2](#0-1) 

However, the Association contract's `Release` function only requires that (1) the caller is the original proposer, and (2) the release threshold is reached. There is no mandatory time delay between proposal creation/approval and release. [3](#0-2) 

The `IsReleaseThresholdReached` check verifies that rejections don't exceed `MaximalRejectionThreshold`, but this protection is ineffective because the proposer can release immediately once `MinimalApprovalThreshold` is met, before other members can submit their rejection votes.

**Root Cause**: No time-lock or mandatory review period exists between reaching approval threshold and proposal execution, creating a race condition where the proposer controls release timing.

**Why Protections Fail**: The rejection mechanism exists but cannot prevent exploitation because:
- The proposer unilaterally controls when to call `Release` after threshold is met
- Other members' rejection transactions can be front-run or simply arrive too late
- No minimum delay enforces a voting window for all members

### Impact Explanation

**Concrete Harm**:
- An attacker who is an authorized proposer in the Association can unilaterally change the CrossChain contract's method fee controller to their own address
- This grants the attacker exclusive control over transaction fee settings for critical cross-chain operations
- The attacker can set excessive fees to extract value from users or set fees to zero to drain fee pools
- Can effectively DoS the CrossChain contract by making fees prohibitively expensive

**Protocol Damage**:
- Breaks the fundamental authorization invariant that multi-sig organizations require N-of-M consensus
- Undermines governance security for all Association-controlled contract parameters
- Affects CrossChain contract operations which are critical for parent/side-chain communication

**Affected Parties**:
- All users of the CrossChain contract who must pay method fees
- The protocol itself loses governance integrity
- Treasury/fee collection mechanisms can be manipulated

**Severity Justification**: HIGH - Bypasses core multi-sig authorization controls, enables unauthorized privilege escalation, and can lead to direct economic exploitation or operational disruption of critical cross-chain infrastructure.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Must be in the Association's proposer whitelist (insider threat model)
2. Must obtain `MinimalApprovalThreshold` approvals (e.g., 3 out of 10 members)

**Attack Complexity**: MEDIUM
- Creating and submitting the malicious proposal is straightforward
- Obtaining minimum approvals is feasible through:
  - Social engineering (disguising intent)
  - Compromising a subset of member keys
  - Exploiting routine approval processes where members don't carefully review
  - Colluding with malicious members

**Execution Practicality**:
- All steps are executable through standard contract calls
- No complex transaction sequencing required
- The proposer simply needs to monitor when approval threshold is met and immediately call `Release`
- Front-running is practical in blockchain environments

**Detection Constraints**:
- The attack appears as legitimate governance activity until the malicious Release occurs
- By the time other members notice and attempt to reject, it may be too late
- No on-chain alerts for suspicious rapid releases

**Probability**: MEDIUM-HIGH for insider threats in organizations with:
- Large member counts where coordination is difficult
- Routine proposal approvals without thorough review
- Asymmetric power where proposer whitelist is smaller than full membership

### Recommendation

**Code-Level Mitigation**:

1. **Implement Mandatory Time-Lock in Association Contract**: Add a configurable minimum delay between proposal creation and earliest possible release time.

```
// Add to Organization struct
Timestamp MinimumReleaseDelay;

// Modify IsReleaseThresholdReached to also check:
if (Context.CurrentBlockTime < proposal.CreatedTime.AddSeconds(organization.MinimumReleaseDelay))
    return false;
```

2. **Add Proposal State Machine**: Introduce explicit states (Created → Voting → Queued → Executable) with enforced time windows between states.

3. **Implement Veto Period**: After approval threshold is met, enforce a mandatory window where rejections can still block execution.

**Invariant Checks**:
- Assert proposal age >= minimum delay before release
- Validate that voting window remains open for configured duration
- Emit events when proposals become executable to alert members

**Test Cases**:
1. Test that proposals cannot be released immediately after creation
2. Test that proposals cannot be released within the minimum delay period even with sufficient approvals
3. Test that rejections submitted during the veto period properly block execution
4. Test that the time-lock can be configured per organization based on sensitivity

### Proof of Concept

**Initial State**:
- CrossChain contract's `MethodFeeController` is set to Association organization address `0xAAA`
- Association organization has 10 members: `[M1, M2, M3, M4, M5, M6, M7, M8, M9, M10]`
- Organization parameters:
  - `MinimalApprovalThreshold = 3`
  - `MaximalRejectionThreshold = 5`
  - `MinimalVoteThreshold = 3`
- Attacker controls member `M1` and is in proposer whitelist
- Attacker also controls their own address `0xATTACKER`

**Transaction Sequence**:

1. **T1 (Block N)**: Attacker as `M1` creates proposal
   - Call: `Association.CreateProposal()`
   - Target: `CrossChainContract.ChangeMethodFeeController(new AuthorityInfo { OwnerAddress = 0xATTACKER })`
   - Proposal ID: `P1`

2. **T2 (Block N+1)**: Three members approve (possibly unaware of true intent)
   - `M1.Approve(P1)` ✓
   - `M2.Approve(P1)` ✓ 
   - `M3.Approve(P1)` ✓
   - State: `approvals = 3`, threshold met

3. **T3 (Block N+2)**: Attacker immediately releases
   - Call: `M1.Release(P1)`
   - Check: `approvals (3) >= MinimalApprovalThreshold (3)` ✓
   - Check: `rejections (0) <= MaximalRejectionThreshold (5)` ✓
   - Execution: Virtual inline call to `CrossChainContract.ChangeMethodFeeController`
   - Result: Controller changed to `0xATTACKER`

4. **T4 (Block N+3 or later)**: Other members attempt to reject but too late
   - `M4.Reject(P1)` → FAILS, proposal already executed and removed
   - `M5.Reject(P1)` → FAILS
   - Six members wanted to reject but never had the opportunity

**Expected vs Actual Result**:
- **Expected**: Multi-sig requires consensus, rejections should be able to block the proposal
- **Actual**: Attacker successfully changed controller with only 3/10 approvals by exploiting timing window

**Success Condition**: 
- `CrossChainContract.GetMethodFeeController()` returns `AuthorityInfo { OwnerAddress = 0xATTACKER }` after T3
- Attacker has unilateral control over method fees
- Multi-sig protection was bypassed

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_ACS1_TransactionFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-191)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-39)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }

    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```
