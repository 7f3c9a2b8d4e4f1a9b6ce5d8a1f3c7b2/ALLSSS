### Title
Refund Amount Mismatch Due to Hardcoded Constant in Lock/Unlock Operations Leading to Fund Loss

### Summary
The Election contract uses the `LockTokenForElection` constant for both locking tokens during `AnnounceElection` and unlocking during `QuitElection`, but does not store the actual locked amount per candidate. If this constant is changed in a contract upgrade, candidates who announced under the old value will receive incorrect refunds under the new value, leading to either complete fund lock-in or partial fund loss.

### Finding Description

The Election contract's candidate deposit mechanism has a critical flaw in its lock/unlock symmetry:

**Lock Operation (AnnounceElection):** [1](#0-0) 

When a candidate announces election, the `LockCandidateNativeToken` method transfers a fixed amount to a virtual address: [2](#0-1) 

**Unlock Operation (QuitElection):**
When quitting, the contract attempts to refund using the CURRENT constant value: [3](#0-2) 

**Missing State Storage:**
The `CandidateInformation` structure only stores the `announcement_transaction_id` (used to derive the virtual address) but NOT the actual locked amount: [4](#0-3) 

**Why Protection Fails:**
The MultiToken contract's `ModifyBalance` function will check if sufficient balance exists at the virtual address: [5](#0-4) 

However, this check creates two failure modes rather than preventing the vulnerability:
- If constant increases: Transaction fails with "Insufficient balance", permanently locking funds
- If constant decreases: Transaction succeeds but only partially refunds, permanently losing the difference

### Impact Explanation

**Direct Fund Loss:**
- **Scenario 1 (Constant Increases)**: If `LockTokenForElection` changes from 100,000 to 200,000 ELF, candidates who locked 100,000 ELF cannot quit because the unlock operation attempts to withdraw 200,000 ELF from a virtual address containing only 100,000 ELF. Their 100,000 ELF deposit becomes permanently locked.

- **Scenario 2 (Constant Decreases)**: If `LockTokenForElection` changes from 100,000 to 50,000 ELF, candidates who locked 100,000 ELF will only receive 50,000 ELF back when quitting. The remaining 50,000 ELF stays permanently locked at the virtual address with no mechanism to retrieve it.

**Who is Affected:**
All candidates who announced election before a constant change are affected. Given the typical election participation, this could impact dozens of candidates and millions of ELF tokens in total.

**Severity Justification:**
Medium severity is appropriate because:
1. Direct financial loss is guaranteed if constant changes
2. Requires governance action (contract upgrade) as precondition
3. Impact scales with number of active candidates and deposit amount
4. No attacker profit mechanism (pure loss scenario)

### Likelihood Explanation

**Feasible Preconditions:**
Contract upgrades that modify economic parameters are realistic governance activities. The constant might be changed to:
- Adjust barrier to entry for candidates
- Align with token price changes
- Rebalance economic incentives

**Execution Path:**
1. Candidate calls `AnnounceElection`, locking amount X based on constant value V1
2. Governance upgrades Election contract, changing constant to V2 (V2 ≠ V1)
3. Candidate calls `QuitElection`, which attempts to unlock amount based on V2
4. Fund mismatch occurs: either insufficient balance error or partial refund

**Attack Complexity:**
No attack required - this is an operational failure that occurs through normal contract usage after a legitimate governance upgrade.

**Probability:**
Medium probability because:
- Contract upgrades are infrequent but realistic
- Economic parameter adjustments are common governance activities
- No inherent protection against constant changes
- Impact is automatic once upgrade occurs

### Recommendation

**Immediate Fix:**
Store the actual locked amount per candidate in the `CandidateInformation` structure:

```protobuf
message CandidateInformation {
    // ... existing fields ...
    // Amount of tokens locked when announcing
    int64 locked_amount = 8;
}
```

Modify `AnnounceElection` to record the locked amount:
```csharp
candidateInformation.LockedAmount = ElectionContractConstants.LockTokenForElection;
```

Modify `QuitElection` to use the stored amount:
```csharp
Amount = candidateInformation.LockedAmount,
```

**Migration Strategy:**
For existing candidates without stored amounts, implement a one-time migration that:
1. Queries virtual address balance for each active candidate
2. Records actual balance as their locked amount
3. Ensures all future operations use stored values

**Test Cases:**
1. Lock with constant V1, upgrade to V2 (V2 > V1), verify unlock uses V1 amount
2. Lock with constant V1, upgrade to V2 (V2 < V1), verify unlock uses V1 amount
3. Lock with V1, verify virtual address balance equals stored amount
4. Multiple lock/unlock cycles with constant changes, verify no fund leakage

### Proof of Concept

**Initial State:**
- `LockTokenForElection` = 100,000 ELF (100_000_00000000)
- Candidate A has 200,000 ELF balance
- Candidate A is not yet announced

**Step 1: Announce Election (Old Constant)**
- Candidate A calls `AnnounceElection`
- 100,000 ELF transferred to virtual address V derived from announcement transaction ID
- Candidate A balance: 100,000 ELF
- Virtual address V balance: 100,000 ELF

**Step 2: Contract Upgrade**
- Governance updates Election contract
- `LockTokenForElection` changed to 150,000 ELF (150_000_00000000)

**Step 3: Attempt to Quit**
- Candidate A calls `QuitElection`
- Contract attempts to transfer 150,000 ELF from virtual address V
- Virtual address V only has 100,000 ELF

**Expected Result:**
Candidate A should receive their original 100,000 ELF deposit back

**Actual Result:**
Transaction fails with "Insufficient balance" error from ModifyBalance. Candidate A's 100,000 ELF remains permanently locked at virtual address V with no recovery mechanism.

**Alternative Scenario (Constant Decreases):**
If Step 2 changes constant to 50,000 ELF instead:
- Step 3 succeeds but only transfers 50,000 ELF back to Candidate A
- 50,000 ELF remains permanently locked at virtual address V
- Candidate A loses 50,000 ELF with no recourse

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L239-249)
```csharp
        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** protobuf/election_contract.proto (L365-380)
```text
message CandidateInformation {
    // Candidate’s public key.
    string pubkey = 1;
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
    // The number of blocks the candidate has produced.
    int64 produced_blocks = 3;
    // The time slot for which the candidate failed to produce blocks.
    int64 missed_time_slots = 4;
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
    // The transaction id when the candidate announced.
    aelf.Hash announcement_transaction_id = 6;
    // Indicate whether the candidate can be elected in the current term.
    bool is_current_candidate = 7;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```
