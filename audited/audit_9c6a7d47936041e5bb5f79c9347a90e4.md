# Audit Report

## Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

## Summary
The `RevealSharedInValues` function reconstructs miners' InValues from DecryptedPieces without validating that the reconstructed secret matches the original OutValue hash. A malicious miner can submit corrupted DecryptedPieces via UpdateValue transactions, causing incorrect PreviousInValue storage that propagates to signature calculations and corrupts consensus state.

## Finding Description

The vulnerability exists in the AEDPoS consensus secret sharing mechanism across multiple components:

**Missing Validation in Secret Reconstruction**: The `RevealSharedInValues` function collects DecryptedPieces from miners and passes them to `SecretSharingHelper.DecodeSecret` for Lagrange interpolation reconstruction. [1](#0-0)  The reconstructed InValue is directly stored as `PreviousInValue` without verifying that `Hash(revealedInValue)` equals the original `OutValue` stored in the previous round.

**Unvalidated DecryptedPieces Acceptance**: When miners submit UpdateValue transactions, `PerformSecretSharing` accepts and stores their DecryptedPieces without any correctness validation. [2](#0-1) 

**Validation Gap**: The existing validation in `UpdateValueValidationProvider` only checks the sender's own PreviousInValue against their previous OutValue, not the revealed PreviousInValues reconstructed for other miners through secret sharing. [3](#0-2) 

**Corrupted Value Usage**: When miners fail to produce blocks, `SupplyCurrentRoundInformation` retrieves the potentially corrupted `PreviousInValue` and uses it to calculate signatures via `CalculateSignature`. [4](#0-3) 

**Impact on Consensus**: The signature calculation XORs the inValue with all miners' signatures, so one corrupted signature affects the collective result used for mining order determination. [5](#0-4)  Mining order is calculated from signatures using modulo arithmetic. [6](#0-5) 

**Attack Vector**: A malicious miner submits UpdateValue with corrupted DecryptedPieces. Since Shamir's Secret Sharing has no error correction, even one corrupted share among the 2/3 threshold produces a completely incorrect reconstruction. [7](#0-6)  The reconstruction always succeeds via Lagrange interpolation regardless of input validity. [8](#0-7) 

## Impact Explanation

**Critical Consensus Integrity Violation**: This vulnerability breaks the core security guarantee of the AEDPoS consensus mechanism - correct round transitions and verifiable randomness. When corrupted DecryptedPieces cause incorrect PreviousInValue reconstruction, subsequent signature calculations become wrong, directly affecting:

1. **Consensus Randomness**: Signatures are combined via XOR to generate randomness for mining order selection. One corrupted signature pollutes the entire result.

2. **Mining Schedule Integrity**: The corrupted signature produces incorrect mining order calculations, potentially allowing attackers to manipulate block production scheduling.

3. **Cryptographic Chain Break**: The InValue→OutValue→Signature chain that ensures consensus unpredictability is broken for affected miners, compromising the Byzantine fault tolerance properties.

All miners and the consensus mechanism are affected because miners who fail to produce blocks have their signatures filled using the corrupted PreviousInValue, propagating the corruption through subsequent rounds.

## Likelihood Explanation

**High Likelihood - Low Complexity Attack**:

**Attacker Requirements**: Any miner in the consensus set can execute this attack, requiring only:
- Miner status (normal operational requirement)
- Ability to submit UpdateValue transactions (standard consensus participation)

**Attack Execution**: The attacker simply provides corrupted byte arrays as DecryptedPieces values when submitting UpdateValue. The attack succeeds because:
- No validation checks DecryptedPieces correctness before storage
- Shamir's Secret Sharing inherently fails completely with any corrupted share
- If the attacker's piece is among the first 2/3 used for reconstruction, the result is guaranteed wrong
- The corruption is silent - no errors are thrown, wrong values are stored normally

**Detection Difficulty**: The attack is difficult to detect because the incorrect PreviousInValue is stored without errors, and corruption only manifests when signatures don't match expected values in subsequent consensus rounds, which could be attributed to other factors.

## Recommendation

Add validation in `RevealSharedInValues` after secret reconstruction to verify correctness:

```csharp
var revealedInValue = HashHelper.ComputeFrom(
    SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Validate reconstructed value against stored OutValue
var expectedOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
if (HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
{
    Context.LogDebug(() => $"Invalid secret reconstruction for miner {publicKeyOfAnotherMiner}");
    continue; // Skip storing invalid reconstruction
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

Additionally, consider implementing cryptographic commitment verification where miners commit to their DecryptedPieces before submission, allowing detection of corrupted shares during reconstruction.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CorruptsDecryptedPieces_CausesWrongPreviousInValue()
{
    // Setup: Initialize consensus with 3 miners in round N
    await InitialAElfConsensusContract();
    var miners = await BootMiner();
    
    // Round N: Miner A produces block with InValue_A and OutValue_A
    var minerA = miners[0];
    var inValueA = HashHelper.ComputeFrom("test_in_value");
    var outValueA = HashHelper.ComputeFrom(inValueA);
    
    // Round N: Create encrypted shares and distribute
    var encryptedPieces = new Dictionary<string, ByteString>();
    // ... (secret sharing setup)
    
    // Round N+1: Attacker (Miner B) submits CORRUPTED DecryptedPieces
    var attackerMiner = miners[1];
    var corruptedPiece = ByteString.CopyFrom(new byte[32]); // Wrong value
    
    var updateValueInput = new UpdateValueInput
    {
        DecryptedPieces = {
            { minerA, corruptedPiece } // Corrupted piece for Miner A
        },
        // ... other fields
    };
    
    await attackerMiner.UpdateValue(updateValueInput);
    
    // Round N+1→N+2: NextRound triggers RevealSharedInValues
    await miners[2].NextRound(new NextRoundInput());
    
    // Verify: PreviousInValue for Miner A is INCORRECT
    var currentRound = await AElfConsensusContract.GetCurrentRoundInformation.CallAsync(new Empty());
    var storedPreviousInValue = currentRound.RealTimeMinersInformation[minerA].PreviousInValue;
    
    // This assertion SHOULD fail but currently passes - vulnerability confirmed
    Assert.NotEqual(inValueA, storedPreviousInValue);
    Assert.NotEqual(outValueA, HashHelper.ComputeFrom(storedPreviousInValue));
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-199)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```
