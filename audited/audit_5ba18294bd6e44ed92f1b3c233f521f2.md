### Title
Unbounded Iteration in RecoverFromUpdateValue Enables Consensus Validation DoS

### Summary
The `RecoverFromUpdateValue()` function iterates over all miners in a provided Round without validating the count beforehand, allowing a malicious miner to submit blocks with consensus extra data containing thousands of miner entries. This forces validation to perform excessive iterations and map accesses before failing, enabling denial-of-service attacks on block validation.

### Finding Description

The vulnerability exists in the `RecoverFromUpdateValue()` method where lines 22-30 iterate over all entries in `providedRound.RealTimeMinersInformation` without any size validation: [1](#0-0) 

The root cause is twofold:

1. **No pre-validation on miner count**: Before the foreach loop executes, there is no check ensuring `providedRound.RealTimeMinersInformation.Count` matches or is reasonably bounded relative to the current round's miner count.

2. **MaximumMinersCount initialized to int.MaxValue**: The system's maximum miner count is set to the maximum 32-bit integer value, providing no practical constraint: [2](#0-1) 

This function is called during block validation in two critical paths:

- In `ValidateBeforeExecution` before validation providers run: [3](#0-2) 

- In `ValidateConsensusAfterExecution` before hash comparison: [4](#0-3) 

The miner list validation that would catch excessive counts only occurs AFTER `RecoverFromUpdateValue` completes: [5](#0-4) 

**Attack Execution Path:**
1. Malicious miner crafts a block with consensus extra data containing a Round with 1,000-10,000 miner entries
2. Block validation begins and calls `ValidateConsensusBeforeExecution`
3. `RecoverFromUpdateValue` starts iterating over all provided miners
4. For each miner key that exists in the current round, three map accesses and assignments occur
5. When a non-existent key is encountered, `KeyNotFoundException` is thrown
6. Block validation fails, but significant computation has already been consumed

### Impact Explanation

**Operational Impact - Consensus Validation DoS:**

A malicious miner can repeatedly submit blocks with inflated miner counts, forcing validators to perform excessive iterations during block validation. Each iteration involves:
- Foreach enumeration overhead
- Map entry access in `providedRound.RealTimeMinersInformation`  
- Attempted map access in `RealTimeMinersInformation[information.Key]`
- Three field assignments if the key exists

If an attacker provides 10,000 miner entries and the first 100 are valid (matching current round), the loop performs approximately 300 map operations (3 per valid miner) before failing on an invalid key.

**Who is Affected:**
- All validators must process the malicious block during validation
- Network consensus can be degraded if multiple miners collude or a single miner repeatedly attacks
- Block processing latency increases, potentially causing missed time slots

**Severity Justification (Medium):**
- Does not compromise consensus integrity (blocks are rejected)
- Does not steal funds or corrupt state
- Can degrade network performance and waste computational resources
- Requires attacker to be an active miner (elevated privilege)
- Repeated attacks could cause cascading validation delays

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a current miner with block production rights (gained through election with sufficient votes)
- Ability to craft block consensus extra data
- No additional privileges beyond being a miner

**Attack Complexity: Low**
The attack is straightforward to execute - simply construct a Round protobuf message with many `RealTimeMinersInformation` entries and include it in block extra data.

**Feasibility Conditions:**
- Attacker is an elected miner (realistic for adversarial actors with stake)
- No transaction fee required (block validation occurs before fee charging)
- Can be repeated on every block production opportunity
- Attack is detectable (validation failures logged) but damage occurs before detection

**Detection/Operational Constraints:**
- Validation failures are logged but attack has already consumed resources
- Miner reputation/stake could be affected if repeatedly producing invalid blocks
- Network monitoring could detect pattern of oversized consensus data

**Probability: Medium**
The attack requires the attacker to be a miner (elevated barrier) but is technically simple to execute and can be repeated. The practical miner count grows slowly (starts at 17, increases by 2 per year per the auto-increase formula), but with `MaximumMinersCount = int.MaxValue`, there's no enforced upper bound: [6](#0-5) [7](#0-6) 

### Recommendation

**Immediate Fix - Add Pre-validation:**

Add a count validation check at the beginning of `RecoverFromUpdateValue` before the foreach loop:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
        !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return this;

    // ADD THIS VALIDATION
    Assert(providedRound.RealTimeMinersInformation.Count == RealTimeMinersInformation.Count,
        "Provided round miner count must match current round miner count");
    
    // ... rest of function
}
```

**Additional Hardening:**

1. **Set reasonable MaximumMinersCount during initialization** instead of `int.MaxValue` (e.g., 1000)

2. **Add early validation in ValidateBeforeExecution** before calling `RecoverFromUpdateValue`:
```csharp
Assert(extraData.Round.RealTimeMinersInformation.Count <= State.MaximumMinersCount.Value,
    "Round exceeds maximum allowed miners");
```

3. **Add test cases** to verify rejection of rounds with:
   - More miners than current round
   - Miners exceeding MaximumMinersCount
   - Non-existent miner keys

### Proof of Concept

**Initial State:**
- Current round has 17 miners (standard initial count)
- `State.MaximumMinersCount.Value = int.MaxValue`
- Attacker is an elected miner with block production rights

**Attack Steps:**

1. Attacker constructs a `Round` message with 10,000 entries in `RealTimeMinersInformation`:
   - First 17 entries use valid current miner public keys
   - Remaining 9,983 entries use fabricated public keys

2. Attacker creates block with this Round in consensus extra data

3. Network validators call `ValidateConsensusBeforeExecution`

4. `RecoverFromUpdateValue` is invoked with the malicious Round

5. Foreach loop begins iterating over 10,000 entries:
   - First 17 iterations succeed (valid keys exist in current round, 51 operations)
   - 18th iteration attempts to access non-existent key
   - `KeyNotFoundException` thrown

**Expected Result:**
Block validation should fail immediately upon detecting miner count mismatch

**Actual Result:**  
Block validation fails only after iterating and performing operations for valid miners, then throwing exception on first invalid miner. The foreach enumeration and map accesses for 10,000 entries consume significant resources before failure.

**Success Condition:**
Attacker successfully forces validators to perform thousands of unnecessary iterations and map access attempts during block validation, degrading network performance without successful block inclusion.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-113)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```
