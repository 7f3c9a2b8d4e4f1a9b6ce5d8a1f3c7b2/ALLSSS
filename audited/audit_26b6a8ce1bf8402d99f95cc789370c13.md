# Audit Report

## Title
Scheme ID Collision Enables Denial of Service on Profit Scheme Creation

## Summary
The `GenerateSchemeId()` function generates scheme IDs using only the scheme count per manager without including the manager's address in the hash. This allows different managers with the same scheme count to generate identical scheme IDs, enabling attackers to front-run and permanently deny service to users attempting to create profit schemes.

## Finding Description

The vulnerability exists in the `GenerateSchemeId()` function where scheme IDs are generated without including the manager address in the hash input. [1](#0-0) 

When no token parameter is provided, the function generates the scheme ID as `Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false))` where `createdSchemeCount` is the count of schemes for that specific manager. The manager address is determined on line 966 but **never included** in the ID generation - only the numeric count is used.

The uniqueness check in `CreateScheme()` prevents duplicate scheme IDs: [2](#0-1) 

**Root Cause:** The hash generation omits any manager-specific identifier, causing:
- Manager A creating their 1st scheme: `Hash(ProfitContract, 0)`
- Manager B creating their 1st scheme: `Hash(ProfitContract, 0)`
- **Result:** Identical scheme IDs → assertion failure → DoS

This breaks the fundamental security guarantee that each manager can independently create their own profit schemes without interference from other users.

**Comparison with other contracts:** Other AElf contracts properly include identifying information to prevent collisions:

Election contract includes candidate public key: [3](#0-2) 

TokenHolder contract includes both scheme manager and sender addresses: [4](#0-3) 

The Profit contract is the only system contract that omits the identifying address from ID generation.

**Affected callers:** System contracts like Treasury and TokenHolder do not provide the token parameter when creating schemes: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Complete Denial of Service:**
- Any attacker can permanently prevent any target user from creating profit schemes
- Once attacker creates their Nth scheme, no other user can create their Nth scheme
- This breaks core functionality of the Profit contract, which is fundamental to the protocol's economics

**Who is Affected:**
- All users calling `CreateScheme` without the optional `token` field (the majority use case)
- Protocol contracts (Treasury, TokenHolder) that depend on profit scheme creation
- Any future integrations expecting reliable scheme creation

**Severity Assessment:** Medium severity because:
- Complete DoS of critical functionality (HIGH impact)
- Trivial to execute with minimal cost (HIGH likelihood)  
- However, a workaround exists via the optional token parameter (mitigating factor)
- The token parameter is undocumented and not enforced, making it an unreliable mitigation

The attack breaks the core invariant that each manager can independently manage their own profit schemes without interference.

## Likelihood Explanation

**Attack Complexity:** Very Low
- Attacker reads target's current scheme count via public `GetManagingSchemeIds` view method
- Attacker front-runs victim's transaction by submitting their own CreateScheme with higher gas
- No special permissions required beyond standard transaction submission [7](#0-6) 

**Attacker Capabilities:**
- Read any manager's scheme count from public state
- Monitor mempool for pending CreateScheme transactions
- Control transaction ordering via gas price (standard front-running)
- Cost is minimal (only gas fees)

**Feasibility:** Highly Practical
- Scheme counts are publicly readable on-chain
- Front-running is well-established attack vector on blockchain systems
- Attack succeeds with 100% certainty once collision occurs
- No rate limiting or additional uniqueness enforcement exists

**Economic Constraints:** Negligible
- Attacker only pays gas fees to create their own schemes
- Can permanently DoS multiple victims with minimal investment
- No penalty mechanism exists for creating colliding scheme IDs

## Recommendation

Include the manager address in the scheme ID generation to ensure uniqueness across different managers:

```csharp
private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
{
    var manager = createSchemeInput.Manager ?? Context.Sender;
    if (createSchemeInput.Token != null)
        return Context.GenerateId(Context.Self, createSchemeInput.Token);
    var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
    // FIX: Include manager address in hash to prevent cross-manager collisions
    return Context.GenerateId(Context.Self, 
        ByteArrayHelper.ConcatArrays(manager.ToByteArray(), createdSchemeCount.ToBytes(false)));
}
```

This ensures that:
- Manager A's 1st scheme: `Hash(ProfitContract, AddressA || 0)`
- Manager B's 1st scheme: `Hash(ProfitContract, AddressB || 0)`
- Result: Unique scheme IDs → no collision possible

This follows the same pattern used successfully in Election and TokenHolder contracts.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeIdCollision_DoS_Test()
{
    // Setup: Two different managers
    var managerA = Accounts[1].Address;
    var managerB = Accounts[2].Address;
    
    // Manager A creates their first scheme successfully
    var resultA = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = managerA,
        IsReleaseAllBalanceEveryTimeByDefault = true
        // Note: No token parameter provided
    });
    resultA.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Manager B attempts to create their first scheme
    // This will FAIL because both have count=0, generating identical scheme IDs
    var resultB = await ProfitContractStub.CreateScheme.SendAsync(new CreateSchemeInput
    {
        Manager = managerB,
        IsReleaseAllBalanceEveryTimeByDefault = true
        // Note: No token parameter provided
    });
    
    // Assert: Manager B is denied service
    resultB.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    resultB.TransactionResult.Error.ShouldContain("Already exists.");
    
    // Vulnerability confirmed: Different managers cannot independently create schemes
    // Manager B is permanently blocked from creating their first scheme
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-59)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L157-158)
```csharp
        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```
