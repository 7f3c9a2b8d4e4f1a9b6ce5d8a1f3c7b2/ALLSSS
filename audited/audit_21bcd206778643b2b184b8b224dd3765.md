### Title
Unauthorized Extra Block Producer Privilege Escalation in Term Transition

### Summary
Any miner can gain the `ExtraBlockProducerOfPreviousRound` privilege by producing the block that triggers a term/round transition, even if they were not the designated extra block producer. This allows them to mine additional blocks immediately at the start of the new term before their scheduled time slot, resulting in unfair block reward allocation and consensus protocol violation.

### Finding Description

The vulnerability exists in two locations where `ExtraBlockProducerOfPreviousRound` is assigned:

1. **Primary Location**: In `GenerateFirstRoundOfNextTerm()`, the code unconditionally sets the sender as the extra block producer of the previous round: [1](#0-0) 

2. **Secondary Location**: In `GetConsensusExtraDataForNextRound()`, the same assignment occurs for NextRound transitions: [2](#0-1) 

**Root Cause**: There is no validation that the sender (`senderPubkey` or `pubkey`) was actually the designated extra block producer (marked with `IsExtraBlockProducer = true`) in the previous round. The code simply assigns this privileged status to whoever produces the NextTerm or NextRound block.

**Why Protections Fail**:

The `PreCheck()` method only validates that the sender is in the current or previous miner list, not that they are the designated extra block producer: [3](#0-2) 

The validation providers (`MiningPermissionValidationProvider`, `TimeSlotValidationProvider`, `RoundTerminateValidationProvider`) only check miner list membership, time slot respect, and round/term number correctness—none verify the extra block producer role: [4](#0-3) [5](#0-4) 

**Privilege Exploitation**: The `ExtraBlockProducerOfPreviousRound` field grants mining privileges before the round officially starts: [6](#0-5) 

This check in `IsCurrentMiner()` allows the miner to produce blocks when `Context.CurrentBlockTime <= currentRound.GetRoundStartTime()`, giving them an unfair head start in the new round.

### Impact Explanation

**Direct Harm**:
- **Unfair Block Reward Allocation**: The attacking miner produces extra blocks beyond their allocated time slot, earning additional block rewards they should not receive. Block rewards are calculated as `minedBlocks * miningRewardPerBlock`, so extra blocks directly increase earnings.
- **Consensus Fairness Violation**: The extra block producer role is specifically assigned (determined by `CalculateNextExtraBlockProducerOrder()` based on cryptographic signatures) to ensure fair distribution. Allowing any miner to claim this privilege undermines the consensus protocol's intended fairness guarantees.

**Affected Parties**:
- Legitimate extra block producers who lose their designated mining opportunity
- Other miners who receive proportionally smaller reward shares
- The overall consensus protocol integrity

**Severity Justification**: HIGH - This directly violates a critical consensus invariant (miner schedule integrity) and causes reward misallocation, meeting the criteria for "Direct Fund Impact: reward misallocation" and "Consensus/Cross-Chain Integrity: invalid round transitions."

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the active miner list can execute this attack. No special privileges beyond normal mining rights are required.

**Attack Complexity**: LOW
1. The attack requires no sophisticated techniques—simply producing a block when term/round transition conditions are met
2. When `NeedToChangeTerm()` returns true (based on two-thirds of miners' mining times reaching the threshold), multiple miners may be eligible to produce blocks: [7](#0-6) 

3. The consensus behavior provider determines NextTerm/NextRound based on round state, not miner role: [8](#0-7) 

**Feasibility Conditions**: 
- Attack window opens whenever term change conditions are met (periodically based on `PeriodSeconds` configuration)
- Multiple miners may be in their time slots or approaching them when this occurs
- First miner to produce a block captures the privilege

**Detection Constraints**: The attack is difficult to detect because:
- It appears as legitimate consensus behavior (valid NextTerm transaction)
- The attacking miner IS a legitimate miner, just claiming undeserved privileges
- No transaction-level anomaly occurs—the issue is in privilege assignment logic

**Probability**: MEDIUM-HIGH - Every term transition (typically every 7 days based on period configuration) presents an opportunity. Rational miners are incentivized to front-run term transitions to capture extra rewards.

### Recommendation

**Code-Level Mitigation**:

1. **Add Extra Block Producer Validation**: Before assigning `ExtraBlockProducerOfPreviousRound`, verify the sender was the designated extra block producer in the previous round:

```csharp
// In GenerateFirstRoundOfNextTerm() at line 254:
var previousExtraBlockProducer = currentRound.RealTimeMinersInformation
    .Single(m => m.Value.IsExtraBlockProducer).Key;
Assert(senderPubkey == previousExtraBlockProducer, 
    "Only the designated extra block producer can trigger term transitions.");
newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

2. **Apply Same Fix to NextRound**: Add identical validation in `GetConsensusExtraDataForNextRound()` at line 178.

3. **Add Validation Provider**: Create a new `ExtraBlockProducerValidationProvider` that validates this requirement during `ValidateBeforeExecution()` for NextTerm and NextRound behaviors.

**Invariant Checks**:
- Assert that `ExtraBlockProducerOfPreviousRound` matches the previous round's designated extra block producer (identified by `IsExtraBlockProducer = true`)
- Verify this in both the consensus command generation path and the transaction execution path

**Test Cases**:
- Test that non-extra-block-producer miners cannot trigger NextTerm/NextRound
- Test that attempting to trigger term transition from wrong miner reverts
- Test that only the designated extra block producer can successfully trigger transitions
- Verify `ExtraBlockProducerOfPreviousRound` is correctly set only for legitimate extra block producers

### Proof of Concept

**Initial State**:
- Current term with N miners (M1, M2, ..., MN)
- M1 is designated as extra block producer (`IsExtraBlockProducer = true`)
- Term change conditions met (`NeedToChangeTerm()` returns true)
- Current time is during M2's normal time slot

**Attack Steps**:
1. M2 (non-extra-block-producer) requests consensus command via `GetConsensusCommand()`
2. `MainChainConsensusBehaviourProvider` returns `AElfConsensusBehaviour.NextTerm` because term change conditions are met
3. M2 produces a block with NextTerm transaction
4. `GenerateFirstRoundOfNextTerm()` is called with `senderPubkey = M2`
5. Line 254 executes: `newRound.ExtraBlockProducerOfPreviousRound = M2` (incorrect!)
6. New term begins with M2 recorded as `ExtraBlockProducerOfPreviousRound`

**Expected Result**: 
- Only M1 (the designated extra block producer) should be able to trigger term transition
- `ExtraBlockProducerOfPreviousRound` should be set to M1

**Actual Result**:
- M2 successfully triggers term transition
- `ExtraBlockProducerOfPreviousRound` is set to M2
- At the start of the new term, M2 can mine blocks before the round officially starts (via `IsCurrentMiner()` check at lines 150-155)
- M2 gains unfair mining advantage and increased block rewards

**Success Condition**: M2 produces extra blocks at the beginning of the new term before their scheduled time slot, as verified by checking their `ActualMiningTimes` contain timestamps `<= currentRound.GetRoundStartTime()`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L149-155)
```csharp
        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
