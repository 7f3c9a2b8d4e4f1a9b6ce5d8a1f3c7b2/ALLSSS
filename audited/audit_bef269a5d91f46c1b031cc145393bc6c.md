### Title
Unvalidated ProducedBlocks Manipulation in NextRound Allows Mining Reward Inflation

### Summary
The `GetMinedBlocks()` function sums `ProducedBlocks` values without validation, and malicious miners can exploit this by submitting inflated values in `NextRoundInput` transactions. These manipulated values persist across rounds and are used to calculate mining rewards at term end, resulting in excessive reward donation to Treasury and unfair distribution to the attacker.

### Finding Description

The vulnerability exists in the round transition mechanism where `ProducedBlocks` values are not validated when miners submit `NextRoundInput`.

**Root Cause**: The `ProcessNextRound()` function accepts `NextRoundInput` from miners and converts it to a `Round` object that includes all `ProducedBlocks` values without comparing them against the stored current round values. [1](#0-0) 

The submitted `NextRoundInput` contains a map of miner information including `ProducedBlocks` for each miner: [2](#0-1) 

Each `MinerInRound` includes the `produced_blocks` field: [3](#0-2) 

**Why Validation Fails**: The validation logic in `RoundTerminateValidationProvider` only checks round number increment and that InValues are null, but does NOT validate `ProducedBlocks` values: [4](#0-3) 

**Persistence Mechanism**: The inflated values persist because `GenerateNextRoundInformation()` copies `ProducedBlocks` from the current round to the next round: [5](#0-4) [6](#0-5) 

**Exploitation at Term End**: When `ProcessNextTerm()` is called, it retrieves the previous round from state and uses the inflated `ProducedBlocks` values to calculate mining rewards: [7](#0-6) 

The `DonateMiningReward()` function uses `GetMinedBlocks()` without any validation or cap: [8](#0-7) 

The vulnerable `GetMinedBlocks()` function simply sums all `ProducedBlocks` values: [9](#0-8) 

### Impact Explanation

**Economic Harm**: The attack inflates total mining rewards donated to Treasury. With `InitialMiningRewardPerBlock` at 12,500,000 base units (12.5 ELF), if an attacker inflates the total block count from 1,000 to 100,000, the excess reward would be approximately (100,000 - 1,000) × 12.5 = 1,237,500 ELF donated to Treasury. [10](#0-9) 

**Unfair Distribution**: The inflated individual miner statistics are sent to the Election contract without validation: [11](#0-10) 

The Election contract accepts these values without validation and adds them to candidate statistics: [12](#0-11) 

This allows the attacker to appear to have produced more blocks, receiving a disproportionate share of mining rewards distributed through the Treasury/Profit system.

**Affected Parties**: All token holders are affected as the protocol inflates its token supply excessively. Honest miners receive reduced relative rewards compared to the attacker.

**Severity Justification**: Medium severity - causes direct economic loss and unfair reward distribution, but requires miner privileges to exploit.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be a miner in the current or previous round's miner list, verified by the `PreCheck()` function: [13](#0-12) 

Typically, the extra block producer for a round would submit the `NextRound` transaction. This is a scheduled, predictable position that rotates among miners.

**Attack Complexity**: Low - the attacker simply needs to modify the `ProducedBlocks` values in the `NextRoundInput` before submitting the transaction. The contract accepts the transaction without comparing the submitted values to stored values.

**Feasibility**: High - once a miner is in position to submit `NextRound`, the attack is straightforward to execute. There are no cryptographic or complex logical barriers.

**Detection Constraints**: The attack is difficult to detect in real-time because the validation logic does not flag inflated `ProducedBlocks` values. The only detection would be manual auditing of round data or noticing excessive Treasury donations.

**Probability**: Medium-High - miners regularly rotate as extra block producers, providing periodic opportunities to exploit this vulnerability. The lack of validation makes successful exploitation highly likely once attempted.

### Recommendation

**Primary Fix**: Add validation in `ProcessNextRound()` to compare submitted `ProducedBlocks` values against the stored current round values before accepting the `NextRoundInput`:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Add validation: compare ProducedBlocks with current round
    TryToGetCurrentRoundInformation(out var currentRound);
    foreach (var minerInfo in nextRound.RealTimeMinersInformation)
    {
        if (currentRound.RealTimeMinersInformation.ContainsKey(minerInfo.Key))
        {
            Assert(
                minerInfo.Value.ProducedBlocks == 
                currentRound.RealTimeMinersInformation[minerInfo.Key].ProducedBlocks,
                $"Invalid ProducedBlocks value for miner {minerInfo.Key}"
            );
        }
    }
    
    // Continue with existing logic...
}
```

**Additional Safeguards**:
1. Add a maximum reasonable blocks per miner per round check (e.g., based on round duration and mining interval)
2. Add a sanity check in `DonateMiningReward()` to cap the total mining reward based on expected blocks per term
3. Log warnings when `GetMinedBlocks()` returns values significantly higher than expected

**Test Cases**:
1. Test that `NextRound` with inflated `ProducedBlocks` is rejected
2. Test that `NextRound` with correctly copied `ProducedBlocks` is accepted
3. Test that mining rewards calculation uses validated data only

### Proof of Concept

**Initial State**:
- Term 1, Round N with Miner A having ProducedBlocks = 100
- Miner B is the extra block producer for Round N
- Total term blocks so far: 1,000

**Attack Steps**:
1. Miner B creates `NextRoundInput` for Round N+1
2. Miner B modifies the `NextRoundInput` to set Miner A's `ProducedBlocks = 100,000` (instead of correct value 100)
3. Miner B submits the `NextRound` transaction with inflated data
4. The transaction passes validation (only checks round number and InValues)
5. The inflated `Round` is stored via `AddRoundInformation()`
6. Subsequent rounds in Term 1 copy the inflated value (via `GenerateNextRoundInformation()`)
7. At end of Term 1, `ProcessNextTerm()` is called
8. `DonateMiningReward()` retrieves previous round from state (with inflated values)
9. `GetMinedBlocks()` returns ~100,000 instead of ~1,000
10. Mining reward calculated: 100,000 × 12,500,000 = 1,250,000,000,000 base units (1,250,000 ELF)
11. Excessive reward donated to Treasury and distributed

**Expected Result**: `NextRound` transaction should be rejected due to `ProducedBlocks` validation failure

**Actual Result**: Transaction succeeds, inflated values persist, and excessive rewards are distributed

**Success Condition**: Mining reward amount significantly exceeds expected amount based on actual blocks produced in the term

### Notes

While the contract correctly increments `ProducedBlocks` during normal block production (ignoring miner-provided values in `UpdateValueInput` and `TinyBlockInput`), it fails to validate these values when accepting round transition data in `NextRound`. This asymmetry creates the vulnerability. The issue is specific to the `ProcessNextRound` path; `ProcessNextTerm` resets `ProducedBlocks` to zero for the new term, but uses the unvalidated previous term data for reward calculation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L198-218)
```csharp
        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L107-141)
```csharp
    private bool DonateMiningReward(Round previousRound)
    {
        if (State.TreasuryContract.Value == null)
        {
            var treasuryContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);
            // Return false if Treasury Contract didn't deployed.
            if (treasuryContractAddress == null) return false;
            State.TreasuryContract.Value = treasuryContractAddress;
        }

        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });

        if (amount > 0)
        {
            State.TreasuryContract.Donate.Send(new DonateInput
            {
                Symbol = Context.Variables.NativeSymbol,
                Amount = amount
            });

            Context.Fire(new MiningRewardGenerated
            {
                TermNumber = previousRound.TermNumber,
                Amount = amount
            });
        }

        Context.LogDebug(() => $"Released {amount} mining rewards.");

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-50)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-119)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
        return new Empty();
```
