### Title
Term Change Detection Failure Due to Unordered ActualMiningTimes Array

### Summary
The `NeedToChangeTerm()` function uses `ActualMiningTimes.Last()` to retrieve what it assumes is each miner's latest mining timestamp, but the `ActualMiningTimes` array is not guaranteed to be chronologically ordered. This causes the function to use incorrect timestamps for term change calculations, potentially delaying term transitions indefinitely and blocking critical governance operations, miner elections, and treasury distributions.

### Finding Description

**Root Cause:**

The `NeedToChangeTerm()` function in `Round.cs` retrieves miners' latest mining times using `.Last()` on the `ActualMiningTimes` array without ensuring chronological order: [1](#0-0) 

The function assumes `Last()` returns the most recent timestamp, but `ActualMiningTimes` is a `repeated google.protobuf.Timestamp` field that stores timestamps in insertion order, not chronological order: [2](#0-1) 

**Why Protections Fail:**

Timestamps are added to `ActualMiningTimes` via simple `.Add()` operations with miner-provided values: [3](#0-2) [4](#0-3) 

The `TimeSlotValidationProvider` validates that the *latest existing* timestamp is within bounds, but explicitly sorts before retrieving it, indicating the developers were aware of potential ordering issues: [5](#0-4) 

However, no validation ensures the *new* timestamp being added is chronologically after previous timestamps. The validation only checks if the latest existing timestamp falls within acceptable bounds, not whether new additions maintain chronological order.

**Inconsistent Usage Pattern:**

The codebase shows inconsistent handling of `ActualMiningTimes`:
- `TimeSlotValidationProvider` uses `OrderBy(t => t).LastOrDefault()` (sorted)
- `NeedToChangeTerm()` uses `Last()` (unsorted)  
- `ExtractInformationToUpdateConsensus()` uses `Last()` (unsorted): [6](#0-5) 

Even logging code explicitly sorts before displaying, confirming the array can be unordered: [7](#0-6) 

### Impact Explanation

**Consensus & Governance Integrity Failure:**

The `NeedToChangeTerm()` function determines whether the consensus should transition from `NextRound` to `NextTerm` behavior, which is a critical governance operation: [8](#0-7) 

When `ActualMiningTimes` becomes unordered (e.g., `[100, 110, 105]` seconds), the function retrieves the last array element (105) instead of the latest timestamp (110). If the true latest timestamp (110) indicates term change should occur but the incorrect timestamp (105) does not, the function returns false when it should return true.

**Concrete Harm:**

Term transitions trigger critical operations in `ProcessNextTerm()`:
1. **Election System Disruption**: New miner elections are blocked, preventing validator set updates: [9](#0-8) 

2. **Treasury Distribution Failure**: Mining rewards and treasury distributions are delayed: [10](#0-9) 

3. **Election Snapshots Missing**: Vote counting and reward allocation snapshots fail to occur: [11](#0-10) 

The function requires `MinersCountOfConsent` (typically 2/3 of miners) to report timestamps indicating term change. If attackers prevent even 1/3 + 1 miners from being counted correctly, term change is permanently blocked, freezing governance and economic operations indefinitely.

### Likelihood Explanation

**Attacker Capabilities:**

Any miner can provide `actual_mining_time` values when producing blocks via `UpdateValue` or `UpdateTinyBlockInformation` methods, which are public consensus operations. The miner controls the timestamp value within their transaction input.

**Attack Execution:**

1. Miner produces block 1 at actual time T1 (e.g., 100s), adds timestamp 100
2. Miner produces block 2 at actual time T3 (e.g., 110s), adds timestamp 110  
3. Miner produces block 3 but provides `actual_mining_time` as T2 (e.g., 105s)
4. If 105 falls within the miner's time slot validation bounds, it passes `TimeSlotValidationProvider` checks
5. Array becomes `[100, 110, 105]` - chronologically unordered
6. `NeedToChangeTerm()` retrieves 105 instead of 110

**Feasibility:**

- **Entry Point**: Public methods `UpdateValue` and `UpdateTinyBlockInformation` accessible to all miners
- **Preconditions**: Miner only needs to control timestamp values within validation bounds (their assigned time slot window)
- **Attack Complexity**: Low - simply provide out-of-order timestamps in consensus transactions
- **Detection**: Difficult - timestamps within valid ranges appear legitimate
- **Economic Cost**: Negligible - normal block production with manipulated timestamp values

**Probability:**

Could occur naturally through clock skew, network delays, or block propagation timing, or deliberately through miner collusion. Only requires preventing 1/3 + 1 miners from accurate timestamp counting to block term changes indefinitely.

### Recommendation

**Immediate Fix:**

Modify `NeedToChangeTerm()` to sort `ActualMiningTimes` before retrieving the latest timestamp, consistent with `TimeSlotValidationProvider`:

```csharp
public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
{
    return RealTimeMinersInformation.Values
               .Where(m => m.ActualMiningTimes.Any())
               .Select(m => m.ActualMiningTimes.OrderBy(t => t).Last())  // Add OrderBy
               .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                   t, currentTermNumber, periodSeconds))
           >= MinersCountOfConsent;
}
```

**Additional Hardening:**

1. Apply the same fix to `ExtractInformationToUpdateConsensus()` and other locations using unsorted `.Last()`: [12](#0-11) 

2. Add validation in `ProcessUpdateValue()` and `ProcessTinyBlock()` to enforce chronological ordering when adding new timestamps:

```csharp
// Before: minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
var latestTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
Assert(latestTime == null || updateValueInput.ActualMiningTime >= latestTime, 
    "Actual mining time must be chronologically after previous mining times");
minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

3. Add regression tests verifying term change detection with unordered `ActualMiningTimes` arrays.

### Proof of Concept

**Initial State:**
- Current term: 1
- Period seconds: 604800 (7 days)
- Blockchain start: timestamp 1000000
- Current time: timestamp 1604800 (just past term boundary)
- 3 miners, MinersCountOfConsent = 2 (2/3 majority required)

**Attack Sequence:**

1. Miner A mines at timestamp 1500000, ActualMiningTimes = `[1500000]`
2. Miner A mines at timestamp 1604900 (past term boundary), ActualMiningTimes = `[1500000, 1604900]`
3. Miner A mines but provides `actual_mining_time = 1600000` (within time slot, passes validation)
4. Miner A's ActualMiningTimes = `[1500000, 1604900, 1600000]`
5. Miner B and C perform similar manipulations

**Expected Result:**
`NeedToChangeTerm()` should detect that miners' latest actual times (1604900) exceed term boundary and return true.

**Actual Result:**
`NeedToChangeTerm()` calls `ActualMiningTimes.Last()` which returns 1600000 (last array element, not latest time). Since 1600000 is before the term boundary, function returns false. Term change is blocked despite miners having actually mined past the boundary.

**Success Condition:**
Term remains at 1 indefinitely, blocking elections, treasury distributions, and governance snapshots that should trigger at term 2.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** protobuf/aedpos_contract.proto (L292-292)
```text
    repeated google.protobuf.Timestamp actual_mining_times = 13;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L170-174)
```csharp
        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L41-41)
```csharp
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLogs.cs (L39-39)
```csharp
            var actualMiningTimes = minerInRound.ActualMiningTimes.OrderBy(t => t).Select(t =>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L31-35)
```csharp
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L157-157)
```csharp
                                ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```
