### Title
DepositBalance Underflow Causes DoS in TokenConverter Sell Operations Due to VirtualBalance Accounting Mismatch

### Summary
The `Sell()` function calculates `amountToReceive` using the combined `VirtualBalance + DepositBalance` for pricing, but only subtracts from `DepositBalance` in the accounting update. When `amountToReceive` exceeds `DepositBalance`, the `SafeMath.Sub()` operation throws an `OverflowException`, causing transaction revert and preventing legitimate sell operations even when the contract holds sufficient tokens.

### Finding Description

The vulnerability exists in the `Sell()` function's balance calculation and accounting logic: [1](#0-0) 

The `GetSelfBalance()` method for deposit account connectors with virtual balance enabled returns the sum of virtual and real balances: [2](#0-1) 

However, the accounting update only subtracts from `DepositBalance`: [3](#0-2) 

The `SafeMath.Sub()` method uses checked arithmetic that throws `OverflowException` on underflow: [4](#0-3) 

**Root Cause**: During initialization, deposit account connectors are configured with large `VirtualBalance` values (10,000,000_00000000) and `DepositBalance` starting at 0: [5](#0-4) [6](#0-5) 

Multiple connector pairs share the same base token (ELF) in the contract's actual balance but maintain separate `DepositBalance` tracking per pair: [7](#0-6) 

### Impact Explanation

**Denial of Service Impact**: Users cannot sell resource tokens on affected pairs even when:
1. The contract holds sufficient total base token balance from other connector pairs
2. The Bancor pricing formula indicates a valid sell operation
3. The token transfer would succeed

**Affected Parties**: Any user attempting to sell tokens on a connector pair where accumulated `DepositBalance` is small relative to the configured `VirtualBalance` (10M+ tokens).

**Protocol Damage**: 
- Temporary lockup of user funds in resource tokens that cannot be converted back
- Breakdown of the Bancor pricing mechanism's liquidity guarantees
- Market inefficiency as sell operations fail unpredictably based on per-pair accounting state

**Severity**: HIGH - Operational DoS preventing core token conversion functionality, though it throws an exception rather than causing silent negative balance or wraparound to `Int64.MaxValue` as the question posited.

### Likelihood Explanation

**Attacker Capabilities**: No special privileges required - any user can call `Sell()` on the public contract.

**Preconditions**:
1. Connector pairs initialized with large `VirtualBalance` (10,000,000_00000000) - this is the DEFAULT configuration
2. Low accumulated `DepositBalance` relative to `VirtualBalance` for a specific pair
3. User attempts to sell sufficient tokens that Bancor formula calculates `amountToReceive > DepositBalance`

**Execution Practicality**: 
- Highly practical in early system lifecycle when `DepositBalance` is still accumulating
- Bancor formula with equal connector weights: `amountToReceive = (sold / (fromBalance + sold)) * toBalance`
- When `toBalance = VirtualBalance + DepositBalance` and `VirtualBalance >> DepositBalance`, even moderate sell amounts can trigger the condition

**Detection**: Transaction reverts with `OverflowException`, making the issue immediately apparent to users but preventing exploitation for fund theft.

**Probability**: MEDIUM-HIGH during early operations, decreasing as `DepositBalance` accumulates over time.

### Recommendation

**Code-Level Mitigation**: Add validation before the subtraction to ensure `amountToReceive` never exceeds the available `DepositBalance`:

```csharp
// In Sell() function, before line 193:
var availableBalance = State.DepositBalance[toConnector.Symbol];
Assert(amountToReceive <= availableBalance, 
    $"Insufficient deposit balance. Required: {amountToReceive}, Available: {availableBalance}");
```

**Alternative Fix**: Modify `GetSelfBalance()` for deposit accounts to return only `DepositBalance` (not including `VirtualBalance`) when used for withdrawal calculations, while still using the combined balance for pricing. This requires separating the "pricing balance" from the "available balance" concept.

**Invariant Check**: Enforce that for deposit account connectors: `DepositBalance >= projected withdrawal amount` before any `Sub()` operation.

**Test Cases**:
1. Test selling with `VirtualBalance=10M`, `DepositBalance=1000`, sell amount that calculates `amountToReceive=5000`
2. Verify proper error message rather than exception
3. Test multi-pair scenarios where one pair has low `DepositBalance` but contract has sufficient total balance

### Proof of Concept

**Initial State**:
- NTWRITE connector: `VirtualBalance = 10,000,000_00000000`, `DepositBalance = 0`
- Contract holds 10,000,000 ELF from other sources (other pairs' deposits)

**Attack Sequence**:
1. User A calls `Buy(WRITE, 1000)`, pays ~1,000 ELF â†’ `DepositBalance[NTWRITE] = 1000`
2. User B attempts `Sell(WRITE, 1,000,000)` (selling large amount)
3. `GetSelfBalance(NTWRITE)` returns `10,000,000 + 1,000 = 10,001,000`
4. Bancor calculates `amountToReceive` based on `toBalance = 10,001,000`
5. If Bancor returns `amountToReceive = 5,000` (within valid range < toBalance)
6. Transfer succeeds (contract has 10M ELF total)
7. `Sub(1000, 5000)` throws `OverflowException`
8. Transaction reverts

**Expected Result**: Sell operation succeeds with appropriate balance deduction
**Actual Result**: Transaction reverts with `OverflowException`, preventing legitimate sell operations

**Notes**

To clarify the specific question: The code does NOT cause "negative balance or wraparound to Int64.MaxValue" as asked. Instead, `SafeMath.Sub()` uses checked arithmetic and throws an `OverflowException` when attempting underflow, causing transaction revert. This is the correct safety behavior, but the underlying design flaw remains - using combined `VirtualBalance + DepositBalance` for pricing calculations while only tracking withdrawals against `DepositBalance` creates an accounting mismatch that causes DoS. The vulnerability is the design flaw leading to DoS, not silent corruption of balance state.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-97)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L20-20)
```csharp
    public const long NativeTokenToResourceBalance = 10_000_000_00000000;
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L240-249)
```csharp
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L19-19)
```csharp
    public MappedState<string, long> DepositBalance { get; set; }
```
