# Audit Report

## Title
Missing Validation for Consensus Behavior Correctness Allows Permanent Prevention of Term Changes

## Summary
The AEDPoS consensus validation does not verify whether a miner's choice between `NextRound` and `NextTerm` behavior is correct. A malicious miner can produce a `NextRound` block when `NextTerm` is required, passing all validations and permanently preventing term changes, which blocks election results from being applied and treasury rewards from being released.

## Finding Description

The AEDPoS consensus mechanism has a critical validation gap that allows malicious miners to prevent term transitions indefinitely.

**Root Cause:**

The `GetConsensusBehaviourToTerminateCurrentRound()` method determines consensus behavior based on `NeedToChangeTerm()`: [1](#0-0) 

The `NeedToChangeTerm()` method checks if at least two-thirds of miners have mining times indicating the term should change: [2](#0-1) 

**Validation Gap:**

When blocks are validated, `ValidateBeforeExecution()` adds `RoundTerminateValidationProvider` for both `NextRound` and `NextTerm` behaviors: [3](#0-2) 

However, `RoundTerminateValidationProvider` only validates structural correctness—it checks round number increments and InValues are null, but does NOT verify the behavior choice is correct: [4](#0-3) 

For `NextTerm`, it additionally checks term number increments: [5](#0-4) 

**Critical Issue:** There is no validation that re-checks `NeedToChangeTerm()` to ensure a miner chose the correct behavior. A malicious miner can produce `NextRound` when `NextTerm` is required, and it will pass all structural validations.

**Execution Flow:**

When the malicious `NextRound` block is accepted, `ProcessNextRound()` executes instead of `ProcessNextTerm()`: [6](#0-5) 

`ProcessNextRound()` does NOT change the term number, while `ProcessNextTerm()` performs critical governance operations including updating miners list, releasing treasury rewards, and taking election snapshots: [7](#0-6) 

## Impact Explanation

**High Severity Impact:**

1. **Governance System Failure**: Election results are never applied during term changes. The miners list is only updated in `ProcessNextTerm()` at line 187-190, which means newly elected miners cannot join and current miners retain their positions indefinitely.

2. **Economic System Disruption**: Treasury rewards are only released in `ProcessNextTerm()` at lines 203-210. Without term transitions, the entire term's mining rewards remain locked, breaking the incentive structure.

3. **Democratic Process Subversion**: The core DPoS principle of periodic democratic rotation is violated. Miners who should be replaced based on election results continue mining indefinitely, centralizing control in the hands of potentially malicious actors.

4. **Irreversible Governance Capture**: Once a malicious miner prevents term changes, the system cannot self-correct. The same miner set continues producing blocks without any mechanism to force term transitions.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Attacker Requirements**: Only requires control of a single miner node. In DPoS systems, obtaining miner status is achievable through elections or by compromising an existing miner's infrastructure.

2. **Attack Simplicity**: The attack requires a trivial code modification—changing the behavior determination to always return `NextRound` instead of `NextTerm`. No cryptographic breaking or complex state manipulation is needed.

3. **Attack Success Rate**: When it's the malicious miner's turn to be the extra block producer (which rotates among all miners), they can deterministically prevent term changes. With multiple compromised miners, term changes can be blocked indefinitely.

4. **Detection Difficulty**: The malicious `NextRound` block appears valid in all structural checks. Only careful monitoring of term change timing would reveal the attack, and by then significant governance damage has occurred.

5. **No Built-in Mitigation**: The system has no fallback mechanism to force term transitions or detect incorrect behavior choices.

## Recommendation

Add validation in `RoundTerminateValidationProvider` to verify the behavior choice matches the term change requirement:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check if term should change but NextRound was chosen
    if (validationContext.BaseRound.NeedToChangeTerm(
        GetBlockchainStartTimestamp(), 
        validationContext.CurrentTermNumber, 
        State.PeriodSeconds.Value))
    {
        return new ValidationResult { 
            Message = "NextTerm behavior required but NextRound provided." 
        };
    }
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}

private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Verify term change is actually required
    if (!validationContext.BaseRound.NeedToChangeTerm(
        GetBlockchainStartTimestamp(), 
        validationContext.CurrentTermNumber, 
        State.PeriodSeconds.Value))
    {
        return new ValidationResult { 
            Message = "NextTerm behavior provided but term change not required." 
        };
    }
    
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
        ? new ValidationResult { Message = "Incorrect term number for next round." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanPreventTermChange_ByProducingNextRoundBlock()
{
    // Setup: Advance time so NeedToChangeTerm() returns true
    var currentRound = await GetCurrentRoundInformation();
    var termDuration = GetTermDuration();
    var blockchainStartTime = await GetBlockchainStartTimestamp();
    
    // Advance time beyond term threshold
    BlockTimeProvider.SetBlockTime(blockchainStartTime.AddSeconds(termDuration + 100));
    
    // Verify NeedToChangeTerm returns true
    var needsTermChange = currentRound.NeedToChangeTerm(
        blockchainStartTime, 
        await GetCurrentTermNumber(), 
        termDuration
    );
    Assert.True(needsTermChange);
    
    // Malicious miner produces NextRound instead of NextTerm
    var maliciousBehavior = AElfConsensusBehaviour.NextRound; // Should be NextTerm!
    var nextRoundBlock = await ProduceBlockWithBehavior(maliciousBehavior);
    
    // Block passes validation (THIS IS THE BUG)
    var validationResult = await ValidateBlock(nextRoundBlock);
    Assert.True(validationResult.Success); // Validation incorrectly passes
    
    // ProcessNextRound executes, term number unchanged
    await ExecuteBlock(nextRoundBlock);
    var termAfter = await GetCurrentTermNumber();
    
    // Term number should have incremented but didn't
    Assert.Equal(await GetCurrentTermNumber(), termAfter); // Term stuck!
    
    // Election results not applied, treasury not released
    var minersListChanged = await HasMinersListChanged();
    var treasuryReleased = await HasTreasuryReleasedForTerm();
    Assert.False(minersListChanged); // Governance broken
    Assert.False(treasuryReleased); // Economics broken
}
```

**Notes:**

This vulnerability represents a fundamental flaw in the consensus validation design. The system validates the **structure** of consensus data (increments, nulls, etc.) but not the **correctness** of behavioral decisions. This allows miners to manipulate the consensus flow in ways that break critical governance and economic invariants. The impact is severe because term transitions are the mechanism by which AElf maintains democratic control and economic incentives—without them, the blockchain becomes a permissioned system controlled by whoever holds miner positions at the time of attack.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L36-44)
```csharp
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```
