### Title
Governance Controller Bypass via Malicious Contract Validation

### Summary
The `CheckOrganizationExist` function blindly calls `ValidateOrganizationExist` on any contract address provided in `AuthorityInfo` without validating that the contract is a legitimate governance contract (Parliament, Association, or Referendum). An attacker who controls the current governance can set a malicious contract that always returns `true`, permanently bypassing all governance requirements for method fee changes and establishing direct control without proposal/approval processes.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` method which performs cross-contract validation: [1](#0-0) 

This method is called during `ChangeMethodFeeController` to validate the new authority: [2](#0-1) 

**Root Cause**: The code assumes `authorityInfo.ContractAddress` points to a legitimate governance contract but performs no validation. It calls `Context.Call` on an arbitrary contract address controlled by the caller. Legitimate governance contracts implement `ValidateOrganizationExist` by checking state: [3](#0-2) [4](#0-3) [5](#0-4) 

However, an attacker can deploy a malicious contract with a `ValidateOrganizationExist` method that always returns `true`, bypassing the validation.

**Why Existing Protections Fail**: 

The authorization check only verifies the caller is the current controller: [6](#0-5) 

But once an attacker gains governance control (even temporarily through a compromised proposal), they can set a fake authority permanently. Tests verify that invalid organizations fail validation: [7](#0-6) 

But this test only validates against legitimate Parliament contracts. No test validates that the `ContractAddress` itself must be a whitelisted governance contract.

**Critical Pattern**: This vulnerability affects ALL system contracts using the same pattern: [8](#0-7) 

The Genesis contract has identical vulnerabilities in `ChangeContractDeploymentController` and `ChangeCodeCheckController`, which control even more critical operations.

### Impact Explanation

**Direct Governance Bypass**: Once the malicious authority is set, the attacker's EOA becomes the `OwnerAddress` and can call `SetMethodFee` directly: [9](#0-8) 

**Concrete Harms**:
1. **Permanent Control**: Attacker maintains control without repeated governance approvals, unlike legitimate governance where each change requires proposal/approval/release
2. **Economic Attacks**: Set method fees to zero (enabling free spam/DoS) or extremely high (pricing out users)
3. **Transparency Loss**: No on-chain proposal/voting trail for fee changes
4. **Multi-Contract Impact**: Same vulnerability in Genesis contract allows bypassing deployment and code check controls, potentially enabling malicious contract deployments

**Affected Parties**: All users of system contracts (TokenConverter, MultiToken, Genesis, Profit, Treasury, Vote, Election, etc.) lose governance protections.

**Severity Justification**: CRITICAL - Complete governance model collapse for method fees and contract deployment controls across entire system.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Initial governance compromise to pass one malicious proposal (requires 2/3 Parliament approval by default): [10](#0-9) 

2. Ability to deploy a malicious contract (possible in most configurations)

**Attack Complexity**: 
- **Medium-Low**: Once governance is compromised (51% attack on block producers, social engineering, etc.), attack is straightforward
- Deploy malicious contract, pass single proposal, gain permanent control
- No sophisticated cryptography or race conditions required

**Feasibility Conditions**:
- Main chain: Requires compromising 2/3 of initial block producers
- Side chains: May have weaker governance thresholds
- Over time: Governance participants may be socially engineered or bribed

**Economic Rationality**: High ROI - single governance compromise yields permanent control worth far more than attack cost.

**Detection Constraints**: Malicious proposal would be visible on-chain during approval period, but may be disguised or rushed through during off-hours.

### Recommendation

**Immediate Fix**: Add whitelist validation for governance contract addresses in `CheckOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a known governance contract
    var isValidGovernanceContract = 
        authorityInfo.ContractAddress == State.ParliamentContract.Value ||
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName) ||
        authorityInfo.ContractAddress == Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(isValidGovernanceContract, "Contract address must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Hardening**:
1. Add `ValidateAuthorityInfo` method that checks both contract type and organization existence
2. Apply fix to ALL affected contracts (Genesis, MultiToken, Profit, Treasury, Vote, Election, etc.)
3. Add integration test attempting to use non-governance contract as authority

**Regression Prevention**: Add test case:
```csharp
[Fact]
public async Task ChangeMethodFeeController_With_NonGovernance_Contract_Test()
{
    var maliciousContract = await DeployMaliciousContractAsync();
    var result = await ExecuteProposalForParliamentTransactionWithException(
        TokenConverterContractAddress, 
        nameof(DefaultStub.ChangeMethodFeeController), 
        new AuthorityInfo
        {
            OwnerAddress = DefaultSender,
            ContractAddress = maliciousContract
        });
    result.Error.ShouldContain("Contract address must be a valid governance contract");
}
```

### Proof of Concept

**Initial State**:
- TokenConverter MethodFeeController = Parliament default organization
- Attacker has compromised governance (2/3 block producer control)

**Attack Sequence**:

1. **Deploy Malicious Contract**:
```csharp
public class MaliciousAuthContract : ContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Malicious Proposal** through compromised Parliament:
```
ToAddress: TokenConverterContract
Method: ChangeMethodFeeController
Params: AuthorityInfo {
    ContractAddress: MaliciousAuthContract,
    OwnerAddress: AttackerEOA
}
```

3. **Approve and Release** proposal with compromised block producers

4. **Verification** - Check new controller:
```
GetMethodFeeController() returns:
{
    ContractAddress: MaliciousAuthContract,
    OwnerAddress: AttackerEOA
}
```

5. **Exploit** - Attacker calls `SetMethodFee` directly from AttackerEOA without governance:
```
TokenConverter.SetMethodFee(new MethodFees {
    MethodName: "Buy",
    Fees: [{ Symbol: "ELF", BasicFee: 0 }] // Free transactions
})
```

**Expected Result**: Transaction should fail with "Contract address must be a valid governance contract"

**Actual Result**: Transaction succeeds, method fees changed without governance, attacker has permanent control

**Success Condition**: `State.MethodFeeController.Value.ContractAddress` points to non-governance contract and `State.MethodFeeController.Value.OwnerAddress` is attacker-controlled EOA

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.TokenConverter.Tests/ACS1_ImplementTest.cs (L91-100)
```csharp
    public async Task ChangeMethodFeeController_With_Invalid_Organization_Test()
    {
        var releaseResult = await ExecuteProposalForParliamentTransactionWithException(
            TokenConverterContractAddress, nameof(DefaultStub.ChangeMethodFeeController), new AuthorityInfo
            {
                OwnerAddress = DefaultSender,
                ContractAddress = ParliamentContractAddress
            });
        releaseResult.Error.ShouldContain("Invalid authority input");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-382)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }

    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```
