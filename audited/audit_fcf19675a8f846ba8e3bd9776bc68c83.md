### Title
Byzantine Miner Can Disrupt Consensus by Providing NextRound with Malformed ExpectedMiningTime Values

### Summary
A Byzantine miner producing a NextRound block can include a Round object with ExpectedMiningTime values set to timestamps in the distant past (e.g., near epoch zero with proper intervals). The CheckRoundTimeSlots validation only verifies that mining intervals are consistent and non-zero, but does not validate that ExpectedMiningTime values are reasonable relative to the current block time. This allows corrupted round data to be accepted and written to state, causing all subsequent miners to have their time slots considered "passed," disrupting normal block production.

### Finding Description

**Root Cause Location:**

The vulnerability exists in the validation logic for NextRound consensus extra data, specifically in the `CheckRoundTimeSlots` method. [1](#0-0) 

This validation method checks:
1. ExpectedMiningTime is not null
2. Mining intervals between consecutive miners are greater than 0  
3. Mining intervals are relatively equal

However, it **does NOT validate** that ExpectedMiningTime values are:
- In the future relative to currentBlockTime
- Within a reasonable range from the current blockchain time
- Greater than the previous round's start time

**Attack Path:**

1. **Byzantine miner produces NextRound block**: When producing a NextRound block, the consensus extra data is generated via GetConsensusExtraDataForNextRound. [2](#0-1) 

2. **Attacker crafts malicious Round data**: Instead of using the legitimately generated Round (which would have ExpectedMiningTime values in the future), the Byzantine miner modifies the consensus extra data to include a Round with ExpectedMiningTime values set to very early timestamps (e.g., Timestamp with Seconds=0, 1, 2, 3... for each miner in order).

3. **Validation passes**: During ValidateConsensusBeforeExecution, the TimeSlotValidationProvider calls CheckRoundTimeSlots for the new round. [3](#0-2) 

Since the attacker used proper intervals (e.g., 1 second apart), the validation passes:
- baseMiningInterval = 1000ms > 0 ✓
- All intervals equal ✓
- ExpectedMiningTime not null ✓

4. **Corrupted round written to state**: The block is executed and ProcessNextRound writes the malicious Round to state. [4](#0-3) 

5. **All miners' time slots marked as passed**: When subsequent miners try to produce blocks, ConsensusBehaviourProvider checks if their time slot has passed using IsTimeSlotPassed. [5](#0-4) 

Since ExpectedMiningTime values are in the distant past (e.g., seconds=0), the check `minerInRound.ExpectedMiningTime + miningInterval < currentBlockTime` returns TRUE for all miners.

6. **Normal mining disrupted**: With _isTimeSlotPassed = true, the ConsensusBehaviourProvider logic prevents normal UpdateValue behavior. [6](#0-5) 

All miners fall through to GetConsensusBehaviourToTerminateCurrentRound, forcing everyone to attempt NextRound/NextTerm behavior instead of normal block production.

### Impact Explanation

**Operational Impact:**
- **Consensus Disruption**: Normal block production (UpdateValue behavior) becomes impossible for all miners once the corrupted round is in state
- **Scheduled Mining Broken**: The carefully orchestrated time slot system that ensures orderly block production is completely bypassed
- **Chaotic Recovery**: All miners simultaneously attempt to produce NextRound blocks, potentially causing confusion and delays
- **Multi-Round Effect**: The ArrangeNormalBlockMiningTime function's Max() logic would consistently return currentBlockTime instead of proper scheduled times [7](#0-6) 

**Who is Affected:**
- All active miners in the consensus round
- The blockchain's ability to maintain predictable block times
- Applications and users expecting consistent block production

**Severity Justification:**
MEDIUM severity because:
- The attack disrupts consensus operations for one or more rounds
- Recovery is possible (miners can produce NextRound blocks with corrected timestamps) but may be chaotic
- Does not result in permanent chain halt or fund theft
- Requires attacker to be an active miner with block production rights

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner in the consensus round
- Must be selected to produce the NextRound extra block
- Can modify consensus extra data in their produced block

**Attack Complexity:**
- LOW - The attack requires only modifying the Round object's ExpectedMiningTime values before including it in the block's consensus extra data
- No complex cryptographic operations or multi-step coordination needed
- The validation gap is straightforward to exploit

**Feasibility Conditions:**
- Attacker must wait until it's their turn to produce the NextRound block
- No special permissions beyond normal miner status required
- Attack can be executed repeatedly whenever the attacker produces a NextRound block

**Detection:**
- The malformed timestamps would be visible in the block's consensus extra data
- Monitoring tools could detect ExpectedMiningTime values that are far in the past
- The resulting disruption (all miners attempting NextRound) would be observable

**Probability:**
MEDIUM - While the attacker needs to be an active miner and wait for their NextRound turn, the validation gap makes the attack reliable once those conditions are met.

### Recommendation

**Immediate Fix:**

Add validation in `CheckRoundTimeSlots` to ensure ExpectedMiningTime values are reasonable relative to the current block time:

```csharp
public ValidationResult CheckRoundTimeSlots(Timestamp currentBlockTime = null)
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
    
    // NEW: Validate ExpectedMiningTime values are in the future
    if (currentBlockTime != null)
    {
        var roundStartTime = miners[0].ExpectedMiningTime;
        if (roundStartTime <= currentBlockTime)
            return new ValidationResult { Message = "Round start time must be in the future." };
    }

    var baseMiningInterval = (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    // ... rest of validation
}
```

Update TimeSlotValidationProvider to pass currentBlockTime: [8](#0-7) 

**Additional Checks:**

1. Validate that the new round's ExpectedMiningTime values are within a reasonable time window (e.g., within next 10 minutes)
2. Verify that the first miner's ExpectedMiningTime is greater than the previous round's end time
3. Add bounds checking to prevent arithmetic overflow in ArrangeAbnormalMiningTime when handling extreme timestamp values [9](#0-8) 

**Test Cases:**

1. Test NextRound block with ExpectedMiningTime = Timestamp.MinValue + intervals (should be rejected)
2. Test NextRound block with ExpectedMiningTime in the past (should be rejected)  
3. Test NextRound block with ExpectedMiningTime too far in the future (should be rejected)
4. Test legitimate NextRound block with proper future timestamps (should pass)

### Proof of Concept

**Initial State:**
- Network running normally with N miners
- Current round R with proper ExpectedMiningTime values
- Byzantine miner M is the designated extra block producer for round R

**Attack Steps:**

1. **Byzantine miner produces malicious NextRound block:**
   - Miner M's turn to produce extra block comes
   - GetConsensusCommand returns NextRound behavior
   - Instead of using legitimately generated Round data, M crafts malicious Round:
     ```
     Miner 1: ExpectedMiningTime = Timestamp{Seconds: 0}
     Miner 2: ExpectedMiningTime = Timestamp{Seconds: 1}  
     Miner 3: ExpectedMiningTime = Timestamp{Seconds: 2}
     ...
     ```
   - M includes this corrupted Round in block's consensus extra data

2. **Block validation:**
   - ValidateConsensusBeforeExecution calls CheckRoundTimeSlots
   - baseMiningInterval = 1 second = 1000ms > 0 ✓
   - All intervals equal ✓
   - **Validation PASSES** (vulnerability)

3. **Block execution:**
   - NextRound transaction executes
   - Corrupted Round written to State.Rounds[R+1]

4. **Next miner attempts to produce:**
   - Miner calls GetConsensusCommand
   - IsTimeSlotPassed(pubkey, currentBlockTime) checks:
     - ExpectedMiningTime = 0 seconds (year 1970)
     - currentBlockTime = ~1.7 billion seconds (year 2024)
     - Returns TRUE (time slot passed)
   - GetConsensusBehaviour returns NextRound/NextTerm (not UpdateValue)
   - **Normal block production BLOCKED**

5. **All miners affected:**
   - Every miner experiences the same issue
   - All try to produce NextRound blocks
   - **Consensus disrupted**

**Expected Result:**
- Miner produces normal UpdateValue block at scheduled time

**Actual Result:**
- Miner receives InvalidConsensusCommand or forced to produce NextRound block
- Scheduled mining disrupted
- Temporary DoS of normal consensus operations

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MiningTimeArrangingService.cs (L17-20)
```csharp
        public static Timestamp ArrangeNormalBlockMiningTime(Round round, string pubkey, Timestamp currentBlockTime)
        {
            return TimestampExtensions.Max(round.GetExpectedMiningTime(pubkey), currentBlockTime);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```
