# Audit Report

## Title
RemoveNFTType Breaks Cross-Chain Synchronization for Active NFT Protocols

## Summary
The `RemoveNFTType()` function fails to validate whether active NFT protocols depend on the NFT type being removed. When Parliament removes an NFT type while protocols with that type's short name prefix exist, subsequent `CrossChainCreate()` calls permanently fail, breaking cross-chain synchronization for all affected protocols.

## Finding Description

The vulnerability exists in the `RemoveNFTType()` function which only performs basic validation before removing NFT type mappings. [1](#0-0) 

The function validates Parliament authorization, checks the short name length (2 characters), and verifies the type exists in the mapping. However, it proceeds to remove entries from both `NFTTypeFullNameMap` and `NFTTypeShortNameMap` without checking if any protocols in `State.NftProtocolMap` use this NFT type.

NFT protocol symbols are generated by concatenating the 2-character short name with a random number. [2](#0-1) 

When protocols are created, they are stored with their full symbol as the key. [3](#0-2) 

The critical breakage occurs in `CrossChainCreate()`, which extracts the 2-character short name from the protocol symbol and looks it up in `NFTTypeFullNameMap`. [4](#0-3) 

Specifically, if the NFT type has been removed, the lookup returns null, causing an assertion failure that prevents cross-chain protocol synchronization.

**Root Cause:** No validation exists to check if protocols with symbols starting with the short name being removed exist in `State.NftProtocolMap`. Blockchain smart contract state mappings don't support efficient prefix-based iteration, making this check architecturally challenging but necessary for data integrity.

**Why Existing Protections Fail:** 
- Parliament authorization only validates governance authority, not operational safety
- Existence check only validates the type is in the mapping, not whether it's actively referenced
- No cross-reference validation between NFT type mappings and protocol storage

## Impact Explanation

**Cross-Chain Integrity Violation:**
- All NFT protocols with the removed type's short name prefix become permanently unable to synchronize to side chains
- `CrossChainCreate()` will fail with assertion: "Full name of {shortName} not found"
- Breaks AElf's fundamental multi-chain architecture guarantee for NFT protocols

**Affected Parties:**
- Protocol creators who issued NFTs with the removed type on the main chain cannot expand to side chains
- Users attempting cross-chain NFT operations face permanent failures
- Side chains cannot receive legitimate NFT protocol synchronization from main chain

**Severity Justification: CRITICAL**
- Permanent operational DoS of cross-chain functionality - no automatic recovery
- Even re-adding the NFT type requires Parliament to manually identify all affected protocols
- Violates the invariant that successfully created protocols should be cross-chain syncable
- No built-in mechanism to detect this issue before governance action is taken

## Likelihood Explanation

**Governance Scenario:** This requires Parliament default organization authority, representing legitimate governance rather than a malicious attacker.

**Attack Complexity: LOW**
- Single transaction: `RemoveNFTType(shortName)`
- No complex preconditions or multi-step exploitation

**Realistic Feasibility:**
- Parliament may legitimately deprecate old NFT type categories as the protocol evolves
- May consolidate naming schemes or remove types that appear unused
- Without tooling to query protocol dependencies, removal appears safe
- Common operational governance pattern in mature protocols

**Probability Assessment: HIGH**
- No visibility provided to Parliament about protocol dependencies on specific NFT types
- Legitimate "cleanup" governance actions performed without awareness of downstream breakage
- Cross-chain synchronization failures may not be immediately detected since they occur during protocol expansion to new chains, not during normal main chain operations

## Recommendation

Add dependency validation to `RemoveNFTType()` to prevent removal of NFT types that are actively used by protocols. Since blockchain state mappings don't support efficient enumeration, implement one of these solutions:

**Solution 1: Usage Counter (Recommended)**
```csharp
// In NFTContractState.cs
public MappedState<string, int> NFTTypeUsageCount { get; set; }

// In Create() method after line 34
State.NFTTypeUsageCount[input.NftType] = State.NFTTypeUsageCount[input.NftType].Add(1);

// In RemoveNFTType() after line 157
var shortName = input.Value;
var usageCount = State.NFTTypeUsageCount[State.NFTTypeFullNameMap[shortName]] ?? 0;
Assert(usageCount == 0, $"Cannot remove NFT type {shortName} - {usageCount} active protocols still use it.");
```

**Solution 2: Deprecation Instead of Removal**
Instead of `RemoveNFTType()`, implement `DeprecateNFTType()` that marks types as deprecated while maintaining mappings for existing protocols. Only prevent new protocol creation with deprecated types.

**Solution 3: Graceful Degradation**
Store NFT type information redundantly in the protocol's token ExternalInfo (already partially done) and modify `CrossChainCreate()` to fall back to this source if the NFT type mapping is missing, logging a warning but allowing synchronization to proceed.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveNFTType_Breaks_CrossChain_Synchronization()
{
    // Step 1: Create an NFT protocol with Art type (short name "AR")
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        NftType = NFTType.Art.ToString(),
        ProtocolName = "ArtProtocol",
        TotalSupply = 1000000,
        IsBurnable = true
    });
    var symbol = createResult.Output.Value;
    symbol.Substring(0, 2).ShouldBe("AR"); // Confirm starts with "AR"

    // Verify protocol exists
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    protocolInfo.Symbol.ShouldBe(symbol);
    protocolInfo.NftType.ShouldBe(NFTType.Art.ToString());

    // Step 2: Parliament removes the "AR" NFT type
    var defaultParliament = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    var proposalId = await CreateProposalAsync(
        NFTContractAddress,
        defaultParliament,
        nameof(NFTContractStub.RemoveNFTType),
        new StringValue { Value = "AR" }
    );
    await ApproveWithMinersAsync(proposalId);
    await ParliamentContractStub.Release.SendAsync(proposalId);

    // Verify NFT type was removed
    var nftTypes = await NFTContractStub.GetNFTTypes.CallAsync(new Empty());
    nftTypes.Value.ContainsKey("AR").ShouldBeFalse();

    // Step 3: Attempt cross-chain synchronization - THIS FAILS
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    exception.Message.ShouldContain("Full name of AR not found");
    // Cross-chain synchronization is permanently broken for this protocol
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```
