# Audit Report

## Title
Missing Input Validation Allows Zero or Negative Lock Periods, Enabling Immediate Token Withdrawal

## Summary
The `CreateScheme()` function in TokenHolderContract accepts `MinimumLockMinutes` parameter without any validation, allowing zero or negative values. This completely bypasses the token lock mechanism, enabling users to withdraw tokens immediately after registration, defeating the core purpose of time-locked profit distribution schemes.

## Finding Description

The vulnerability exists in the `CreateScheme()` function where `input.MinimumLockMinutes` is stored directly into the scheme without any bounds checking or validation. [1](#0-0) 

The `MinimumLockMinutes` parameter is defined as `int64` in the protobuf schema, which permits negative values and zero by design. [2](#0-1) 

The lock period is enforced in the `Withdraw()` function through a timestamp comparison that checks if the unlock time has passed. [3](#0-2) 

The `AddMinutes()` extension method performs simple arithmetic without input validation, multiplying the input by 60 and adding it to the timestamp. [4](#0-3) 

**Attack Mechanism:**
1. Attacker calls `CreateScheme()` with `MinimumLockMinutes = 0` (or negative)
2. Calls `RegisterForProfits()` to lock tokens and record timestamp
3. Immediately calls `Withdraw()` in the next block
4. The assertion `State.LockTimestamp[lockId].AddMinutes(0) < Context.CurrentBlockTime` passes because any subsequent block time is greater than the lock timestamp
5. Tokens are unlocked without any waiting period

**Why Protections Fail:**
- No validation exists in `CreateScheme()` to enforce minimum positive values
- The `Withdraw()` check only validates against the computed unlock time, which can be manipulated at scheme creation
- No system-wide minimum lock period is enforced

## Impact Explanation

**Direct Security Impact:**
- Complete bypass of the token lock mechanism, a critical security feature
- Users can game profit distribution systems by locking/unlocking instantly without actual commitment
- Economic incentive alignment is broken - schemes designed to reward long-term holders become exploitable
- Side chain consensus systems using TokenHolder for validator incentives could be compromised if misconfigured

**Affected Components:**
- Any profit distribution scheme relying on TokenHolder's time-lock guarantees
- Production code in AEDPoS that computes `MinimumLockMinutes` dynamically as `periodSeconds / 60` - if `periodSeconds < 60`, the result is zero [5](#0-4) 

**Severity Justification (High):**
This represents a complete failure of a critical access control mechanism (time-based token locking). While it doesn't directly steal funds from other users, it undermines the economic security model and enables gaming of profit distribution systems that assume token commitment.

## Likelihood Explanation

**Attacker Requirements:**
- Ability to call public contract methods (any account)
- No special privileges needed
- Zero transaction cost beyond gas fees

**Attack Complexity:**
- Trivial: Single function call with zero parameter value
- No timing requirements or complex state manipulation
- Immediately exploitable upon scheme creation

**Real-World Evidence:**
The existing test suite inadvertently demonstrates this vulnerability - it creates a scheme without specifying `MinimumLockMinutes` (defaulting to 0) and successfully withdraws immediately without any waiting period. [6](#0-5) 

**Probability Assessment:**
- High likelihood through either malicious intent or misconfiguration
- Production code already computes this value dynamically, risking zero values
- No detection or prevention mechanisms exist
- Economic rationality favors exploitation (zero-cost parameter manipulation for immediate access)

## Recommendation

Add input validation in `CreateScheme()` to enforce a minimum positive lock period:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation
    Assert(input.MinimumLockMinutes > 0, "Minimum lock minutes must be positive.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

    State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
    {
        Manager = Context.Sender,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        CanRemoveBeneficiaryDirectly = true
    });

    State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
    {
        Symbol = input.Symbol,
        MinimumLockMinutes = input.MinimumLockMinutes,
        AutoDistributeThreshold = { input.AutoDistributeThreshold }
    };

    return new Empty();
}
```

Additionally, ensure AEDPoS initialization code guarantees non-zero values:
```csharp
MinimumLockMinutes = Math.Max(1, periodSeconds.Div(60))
```

## Proof of Concept

The existing test `Withdraw_Test` in the test suite already demonstrates this vulnerability:

1. Creates a scheme without specifying `MinimumLockMinutes` (defaults to 0)
2. Registers for profits, locking tokens
3. Immediately withdraws without waiting
4. Test passes, confirming immediate withdrawal is possible

This can be verified by examining the test which creates a scheme with only the `Symbol` parameter, then successfully withdraws without any time delay. [7](#0-6) 

---

**Notes:**
- This vulnerability affects the core economic security model of TokenHolder-based profit distribution
- While the scheme manager controls their own scheme parameters, the lack of validation enables them to create fundamentally broken schemes that defeat the purpose of the contract
- The issue is exacerbated by production code that may inadvertently create zero-period schemes through integer division

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.CSharp.Core/Extension/TimestampExtensions.cs (L39-42)
```csharp
    public static Timestamp AddMinutes(this Timestamp timestamp, long minutes)
    {
        return timestamp + new Duration { Seconds = minutes.Mul(60) };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L434-459)
```csharp
    public async Task Withdraw_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var beforeUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.Withdraw.SendAsync(Starter);
        var afterUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        afterUnLockBalance.ShouldBe(beforeUnLockBalance.Add(amount));
    }
```
