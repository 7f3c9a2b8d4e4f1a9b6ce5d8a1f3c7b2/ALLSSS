### Title
IndexingFeeDebt Status Locks Remaining Deposits and Enables Unbounded Arrears Accumulation

### Summary
The `IndexSideChainBlockData()` helper function incorrectly sets `lockedToken = 0` when a side chain's status is `IndexingFeeDebt`, completely ignoring any actual balance remaining in the deposit. This causes all subsequent indexing operations to accumulate arrears even when funds are available, allowing miners to inflate debt unboundedly and trapping legitimate deposits that cannot be used until excessive arrears are paid.

### Finding Description

**Root Cause:**

The critical flaw exists in the `lockedToken` calculation at the beginning of `IndexSideChainBlockData()`: [1](#0-0) 

When `SideChainStatus == IndexingFeeDebt`, the code sets `lockedToken = 0` regardless of the actual deposit balance returned by `GetSideChainIndexingFeeDeposit(chainId)`. This balance check is completely bypassed.

**Execution Path:**

The vulnerability is triggered through the standard cross-chain indexing flow:
1. Miner calls `ReleaseCrossChainIndexingProposal()` [2](#0-1) 
2. This invokes `RecordCrossChainData()` [3](#0-2) 
3. Which calls `IndexSideChainBlockData()` for side chains [4](#0-3) 

**Why Protections Fail:**

Inside the indexing loop, the fee deduction logic operates on the local `lockedToken` variable: [5](#0-4) 

When `lockedToken` starts at 0 (due to IndexingFeeDebt status), every block causes `lockedToken` to become negative, triggering arrears accumulation. The actual deposit balance is never consulted after the initial calculation, so available funds remain locked and unusable.

The side chain status is persisted at the end: [6](#0-5) 

Once status is IndexingFeeDebt, subsequent calls continue using `lockedToken = 0`, creating a permanent lock on the remaining deposit.

### Impact Explanation

**Direct Economic Loss:**

1. **Trapped Deposits**: Any balance remaining when a side chain enters IndexingFeeDebt status becomes permanently unusable for indexing fees until the operator calls `Recharge()`. For example, with a 10-token deposit and 3-token indexing price, if 4 blocks are indexed in one call, 9 tokens are transferred but 1 token remains trapped.

2. **Inflated Arrears**: All subsequent indexing adds the full `indexingPrice` to arrears, even though the trapped deposit should cover some blocks. If miners index 10 additional blocks at 3 tokens each, arrears grow by 30 tokens when only 29 tokens should be needed (30 - 1 trapped token).

3. **Exponential Recharge Cost**: The `Recharge()` function requires paying ALL accumulated arrears PLUS enough for at least one future indexing: [7](#0-6) 

**Who Is Affected:**

Side chain operators lose economic value proportional to:
- Trapped deposits (unused balance)
- Excess arrears (difference between actual arrears and what should have been charged)
- Increased recharge costs (must add enough to cover inflated arrears)

**Severity Justification:**

This is HIGH severity because:
- Direct, measurable economic loss
- Unbounded accumulation (no cap on arrears growth)
- Affects operational viability of all side chains that enter debt status
- No automatic recovery mechanism

### Likelihood Explanation

**Attacker Capabilities:**

The exploit requires miner access to call `ReleaseCrossChainIndexingProposal()`, which has miner authorization checks: [8](#0-7) 

However, this is a trusted but realistic capability - miners are protocol participants who could collude or act maliciously for economic gain.

**Attack Complexity:**

The attack is straightforward:
1. Wait for or trigger a side chain to enter IndexingFeeDebt status (happens naturally when deposit runs low)
2. Repeatedly propose and release indexing for that side chain
3. Each indexing call adds full `indexingPrice` to arrears
4. Side chain operator must pay excessive arrears to recharge

**Feasibility Conditions:**

- Side chain must have entered IndexingFeeDebt status (can occur naturally through normal operations)
- Miner must be able to propose indexing (standard miner capability)
- Side chain must have produced blocks to index (normal operation)
- Each proposal-release cycle can occur once per block due to: [9](#0-8) 

**Economic Rationality:**

Miners are incentivized because arrears are owed TO the proposer. By accumulating arrears, miners create future payment obligations owed to themselves. The side chain operator has limited options:
- Pay excessive arrears via Recharge
- Dispose of the side chain (losing all investment)

**Probability Assessment:**

HIGH - The vulnerability activates automatically once any side chain enters IndexingFeeDebt status, which can occur through:
- Natural depletion of initial deposit
- Deliberate timing by reducing deposits
- Temporary cash flow issues by operators

### Recommendation

**Code-Level Mitigation:**

Modify the `lockedToken` calculation to ALWAYS use the actual deposit balance, regardless of status:

```csharp
// In IndexSideChainBlockData() at line 828-830:
// REMOVE the conditional that sets lockedToken = 0
// ALWAYS query actual balance:
var lockedToken = GetSideChainIndexingFeeDeposit(chainId);
```

The status should still transition to IndexingFeeDebt when balance runs out, but the calculation should always start with the actual available balance, not 0.

**Additional Invariant Checks:**

Add assertion after the loop to verify no balance was left unused when arrears accumulated:
```csharp
// After line 876, before persisting state:
if (arrearsAmount > 0)
{
    var remainingBalance = GetSideChainIndexingFeeDeposit(chainId);
    Assert(remainingBalance == 0 || indexingFeeAmount == 0, 
        "Arrears accumulated while balance available");
}
```

**Test Cases:**

Add regression test for the specific scenario:
1. Create side chain with deposit that will be partially consumed
2. Index blocks until status becomes IndexingFeeDebt with remaining balance > 0
3. Verify next indexing call uses remaining balance before accumulating arrears
4. Verify final balance is 0 before any arrears accumulate

### Proof of Concept

**Initial State:**
- Side chain created with 10 token deposit
- Indexing price = 3 tokens per block
- Side chain produces blocks 1-6

**Transaction Step 1 - First Indexing (Triggers IndexingFeeDebt):**
```
Call: ReleaseCrossChainIndexingProposal([blocks 1-4])
State Before:
  - Balance = 10 tokens
  - Status = Active
Processing:
  - lockedToken = 10
  - Block 1: lockedToken = 10 - 3 = 7, indexingFeeAmount = 3
  - Block 2: lockedToken = 7 - 3 = 4, indexingFeeAmount = 6
  - Block 3: lockedToken = 4 - 3 = 1, indexingFeeAmount = 9
  - Block 4: lockedToken = 1 - 3 = -2, arrearsAmount = 3
  - Transfer 9 tokens to proposer
State After:
  - Balance = 1 token (TRAPPED)
  - Status = IndexingFeeDebt
  - Arrears = 3 tokens
```

**Transaction Step 2 - Exploitation (Accumulates Excess Arrears):**
```
Call: ReleaseCrossChainIndexingProposal([blocks 5-6])
State Before:
  - Balance = 1 token (should be usable!)
  - Status = IndexingFeeDebt
Processing:
  - lockedToken = 0 (BUG: ignores 1 token balance!)
  - Block 5: lockedToken = 0 - 3 = -3, arrearsAmount = 3
  - Block 6: lockedToken = -3 - 3 = -6, arrearsAmount = 6
  - Transfer 0 tokens to proposer
State After:
  - Balance = 1 token (still unused!)
  - Status = IndexingFeeDebt
  - Arrears = 9 tokens
```

**Expected vs Actual Result:**

**Expected:** Block 5 should use the 1 remaining token, then block 6 goes into arrears. Total arrears = 3 + 2 = 5 tokens.

**Actual:** Both blocks go entirely into arrears because lockedToken starts at 0. Total arrears = 3 + 6 = 9 tokens. The 1 token deposit is trapped and unusable.

**Success Condition:**

The operator must now recharge with 9 tokens (arrears) + 3 tokens (minimum for next indexing) = 12 tokens, when they should only need 5 + 3 = 8 tokens. The trapped 1 token represents direct economic loss, and the 4-token excess arrears represents the exploitation impact.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L828-830)
```csharp
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L844-855)
```csharp
                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L878-879)
```csharp
            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L895-899)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L206-208)
```csharp
            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
