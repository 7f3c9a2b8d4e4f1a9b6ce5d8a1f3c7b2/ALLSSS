### Title
Consensus Signature Manipulation via Unvalidated PreviousInValue Input

### Summary
The AEDPoS consensus mechanism allows miners to manipulate their signature values by providing arbitrary `PreviousInValue` inputs during block production. The signature calculation uses this unvalidated input, bypassing an ineffective validation check. Since signatures determine mining order in subsequent rounds, malicious miners can gain unfair advantages in block production scheduling.

### Finding Description

The root cause is located in the `GetConsensusExtraDataToPublishOutValue` function where the signature calculation unconditionally uses miner-provided input: [1](#0-0) 

Although there is a validation check that verifies whether the provided `PreviousInValue` hashes to the expected `OutValue`: [2](#0-1) 

This validation only affects what gets stored as `previousInValue` but does **not** prevent the signature calculation at line 92 from using the unvalidated `triggerInformation.PreviousInValue`. The signature calculation occurs outside the conditional block, meaning it always executes with the miner-controlled input.

The calculated signature is then applied to the round state: [3](#0-2) 

This signature directly determines the miner's position in the next round: [4](#0-3) 

The signature is then copied through the round update mechanism without verification: [5](#0-4) 

And propagated during validation: [6](#0-5) 

The `UpdateValueValidationProvider` only checks that the signature is non-null and non-empty, but does **not** verify the signature value is correctly calculated: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation**: Miners can manipulate their mining order in subsequent rounds, violating the consensus mechanism's fairness and unpredictability guarantees. The `SupposedOrderOfNextRound` determines when miners can produce blocks, and favorable positions may provide:
- Earlier block production opportunities in each round
- Increased influence over transaction ordering and inclusion
- Potential timing advantages for MEV or cross-chain operations

**Severity: High** - This directly compromises a critical consensus invariant (miner schedule integrity). While it doesn't lead to direct fund theft, it undermines the fundamental fairness of the consensus mechanism and allows miners to gain systematic advantages over honest participants.

### Likelihood Explanation

**Attacker Capabilities**: Any authorized miner (no additional privileges required).

**Attack Complexity**: Low
1. Miner computes offline the `PreviousInValue` that yields their desired signature/mining order
2. Since `CalculateSignature` uses XOR operations with a fixed component (previous round signatures), miners can algebraically solve for inputs that produce any desired output signature
3. Miner submits this manipulated value when producing their block

**Feasibility**: The attack is practical and cost-effective:
- Entry point is the standard `GetConsensusCommand` -> `GenerateConsensusTransactions` flow
- No economic cost beyond normal block production
- Offline computation is inexpensive
- Success rate is 100% (miner has full control over input)

**Detection**: Difficult to detect as the manipulated values appear as valid consensus data and pass all existing validation checks.

### Recommendation

**Immediate Fix**: Move the signature calculation inside the validation block and use only validated inputs:

```csharp
// In GetConsensusExtraDataToPublishOutValue, lines 74-93
if (triggerInformation.PreviousInValue != null &&
    triggerInformation.PreviousInValue != Hash.Empty)
{
    // Self check.
    if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
        previousRound.RealTimeMinersInformation[pubkey].OutValue)
    {
        previousInValue = Hash.Empty;
        // Use fake value for signature calculation when validation fails
        var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
        signature = previousRound.CalculateSignature(fakePreviousInValue);
    }
    else
    {
        previousInValue = triggerInformation.PreviousInValue;
        // Only use validated input for signature
        signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
    }
}
```

**Additional Validation**: Add signature verification in `UpdateValueValidationProvider` to validate that the provided signature matches the expected calculation based on the miner's legitimate previous in value.

**Test Cases**: Add regression tests that verify:
1. Miners cannot produce blocks with signatures that don't match their legitimate previous in value
2. Attempting to manipulate PreviousInValue results in rejected blocks
3. Signature verification is enforced during consensus validation

### Proof of Concept

**Initial State**: 
- Blockchain at round N with miner M having produced a block in round N-1
- Miner M has legitimate OutValue from round N-1: `OutValue_M_N-1`
- Miner M knows all miners' signatures from round N-1 (public state)

**Attack Steps**:
1. Miner M computes: `FixedPart = XorOfAllMinersSignatures(RoundN-1)`
2. Miner M chooses desired mining order position: `DesiredOrder = 1` (first position)
3. Miner M reverse-engineers desired signature: `DesiredSig = (DesiredOrder - 1) * minersCount`
4. Miner M computes: `MaliciousPreviousInValue = XorReverse(DesiredSig, FixedPart)`
5. Miner M produces block with `triggerInformation.PreviousInValue = MaliciousPreviousInValue`

**Expected Result**: Block should be rejected due to invalid PreviousInValue.

**Actual Result**: 
- Block is accepted
- Signature is calculated as `CalculateSignature(MaliciousPreviousInValue)`
- Miner M gets favorable position in round N+1 based on manipulated signature
- Attack succeeds with miner gaining unfair mining order advantage

**Success Condition**: Miner M's `SupposedOrderOfNextRound` in round N+1 matches their chosen position (order 1), even though their `PreviousInValue` didn't hash to their legitimate `OutValue` from round N-1.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-86)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L13-13)
```csharp
        RealTimeMinersInformation[pubkey].Signature = signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L24-24)
```csharp
                    Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```
