### Title
NFT Alias Symbol Resolution Bypass Causes Undeclared State Path Access in Parallel Execution

### Summary
The ACS2 state path provider declares resource paths using input symbols without resolving NFT aliases, while execution resolves aliases before accessing state. This mismatch causes transactions using NFT aliases to access undeclared state paths (balances, allowances, and NFT collection paths), breaking parallel execution safety guarantees and enabling race conditions.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The `GetResourceInfo` method for `TransferFrom` declares resource paths using `args.Symbol` directly without alias resolution. When an NFT alias is used (e.g., "TP" for "TP-31175"), the system incorrectly identifies it as a `Token` type instead of `Nft` type because aliases lack hyphens: [2](#0-1) 

This causes `AddPathForAllowance` to skip declaring the NFT collection path: [3](#0-2) 

However, during execution, the alias is resolved to the actual NFT symbol before state access: [4](#0-3) [5](#0-4) 

The resolved symbol is then used in `DoTransferFrom`, which accesses the NFT collection allowance path that was never declared: [6](#0-5) [7](#0-6) 

**Alias System Details:**
NFT aliases are validated to match the collection prefix: [8](#0-7) [9](#0-8) 

### Impact Explanation

**Concrete Path Mismatch:**
For NFT "TP-31175" with alias "TP":
- **Declared paths**: `Allowances[from][spender]["TP"]`, `Allowances[from][spender]["*"]`, `Balances[from]["TP"]`, `Balances[to]["TP"]`
- **Accessed paths**: `Allowances[from][spender]["TP-31175"]`, `Allowances[from][spender]["TP-*"]`, `Allowances[from][spender]["*"]`, `Balances[from]["TP-31175"]`, `Balances[to]["TP-31175"]`

Only the global allowance path "*" overlaps. All other accessed paths are undeclared.

**Critical Impacts:**
1. **Race Conditions**: Two transactions using aliases for different NFTs in the same collection (e.g., "ALIAS1"→"ABC-1" and "ALIAS2"→"ABC-2") won't declare the shared collection path "ABC-*", allowing parallel execution when they may modify the same allowance state.

2. **Parallel Execution Violations**: Transactions write to undeclared paths, violating ACS2 guarantees and potentially causing transaction failures or undefined behavior in parallel execution environments.

3. **State Corruption Risk**: Concurrent writes to the same undeclared allowance or balance paths can cause lost updates or inconsistent state.

**Affected Parties**: All users of NFTs with aliases, NFT collection owners, and the parallel execution system's integrity.

### Likelihood Explanation

**Attacker Capabilities:**
- NFT collection owners/issuers can set aliases (requires no special privileges beyond NFT ownership)
- Any user can invoke `Transfer` or `TransferFrom` with an alias

**Attack Complexity**: Low - simply use an alias in a transaction parameter.

**Feasibility Conditions:**
- Aliases are a documented, supported feature as evidenced by test coverage: [10](#0-9) 

- The vulnerability triggers automatically for any transaction using an alias, requiring no special exploitation technique.

**Economic Rationality**: No cost beyond normal transaction fees. The vulnerability is triggered by normal usage of the alias feature.

**Probability**: HIGH - This occurs for 100% of transactions using NFT aliases, which is a legitimate and encouraged use case.

### Recommendation

**Immediate Fix:**
Modify `GetResourceInfo` in `TokenContract_ACS2_StatePathsProvider.cs` to resolve aliases before declaring paths:

1. Add alias resolution at the beginning of each case statement:
```csharp
case nameof(TransferFrom):
{
    var args = TransferFromInput.Parser.ParseFrom(txn.Params);
    var actualSymbol = GetActualTokenSymbol(args.Symbol); // Resolve alias
    // Use actualSymbol for all path declarations instead of args.Symbol
    ...
}
```

2. Ensure `GetActualTokenSymbol` is accessible in the ACS2 provider context or create a similar resolution helper.

3. Apply the same fix to `Transfer` and any other methods that declare paths based on symbol parameters.

**Invariant Checks:**
- Add assertions that declared paths match accessed paths during parallel execution
- Add integration tests that verify alias transactions declare correct paths

**Test Cases:**
- Test `TransferFrom` with NFT alias and verify collection path is declared
- Test parallel execution of two aliased NFT transfers from same collection
- Test that resolved symbol paths match declared paths in ACS2

### Proof of Concept

**Initial State:**
1. NFT Collection "TP-0" exists
2. NFT Item "TP-31175" exists with balance to Alice
3. Alias "TP" is set for "TP-31175": [10](#0-9) 
4. Alice approves Bob to spend collection: `Approve(spender=Bob, symbol="TP-*", amount=1000)`

**Attack Steps:**
1. Bob calls `TransferFrom(from=Alice, to=Charlie, symbol="TP", amount=1)`
2. ACS2 declares paths: `["TP", "*"]` for allowances (missing "TP-*" collection path)
3. Execution resolves "TP" → "TP-31175" and accesses undeclared path `Allowances[Alice][Bob]["TP-*"]`

**Expected Result:** 
Paths declared in ACS2 should match paths accessed during execution.

**Actual Result:**
- Declared: `Allowances[Alice][Bob]["TP"]`, `Balances[Alice]["TP"]`, `Balances[Charlie]["TP"]`
- Accessed: `Allowances[Alice][Bob]["TP-31175"]`, `Allowances[Alice][Bob]["TP-*"]`, `Balances[Alice]["TP-31175"]`, `Balances[Charlie]["TP-31175"]`

**Success Condition:** 
Transaction completes despite accessing undeclared state paths, demonstrating the vulnerability. Parallel execution of two such transactions could cause race conditions on the shared "TP-*" allowance path.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L40-64)
```csharp
            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L71-82)
```csharp
    private void AddPathForAllowance(ResourceInfo resourceInfo, string from, string spender, string symbol)
    {
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender, symbol));
        resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
            GetAllSymbolIdentifier()));
        var symbolType = GetSymbolType(symbol);
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
        {
            resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.Allowances), from, spender,
                GetNftCollectionAllSymbolIdentifier(symbol)));
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-259)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransferFrom(input.From, input.To, Context.Sender, tokenInfo.Symbol, input.Amount, input.Memo);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L738-779)
```csharp
    public override Empty SetSymbolAlias(SetSymbolAliasInput input)
    {
        // Alias setting can only work for NFT Item for now.
        // And the setting exists on the TokenInfo of the NFT Collection.

        // Can only happen on Main Chain.
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "Symbol alias setting only works on MainChain.");

        var collectionSymbol = GetNftCollectionSymbol(input.Symbol, true);

        // For now, token alias can only be set once.
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");

        CheckTokenAlias(input.Alias, collectionSymbol);

        var collectionTokenInfo = GetTokenInfo(collectionSymbol);
        if (collectionTokenInfo == null)
        {
            throw new AssertionException($"NFT Collection {collectionSymbol} not found.");
        }

        Assert(collectionTokenInfo.Owner == Context.Sender || collectionTokenInfo.Issuer == Context.Sender,
            "No permission.");

        collectionTokenInfo.ExternalInfo.Value[TokenContractConstants.TokenAliasExternalInfoKey]
            = $"{{\"{input.Symbol}\":\"{input.Alias}\"}}";

        SetTokenInfo(collectionTokenInfo);

        State.SymbolAliasMap[input.Alias] = input.Symbol;

        Context.LogDebug(() => $"Token alias added: {input.Symbol} -> {input.Alias}");

        Context.Fire(new SymbolAliasAdded
        {
            Symbol = input.Symbol,
            Alias = input.Alias
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/TokenAliasTests.cs (L14-52)
```csharp
    public async Task SetTokenAlias_NFTCollection_Test()
    {
        var symbols = await CreateNftCollectionAndNft();
        await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
        {
            Symbol = symbols[1],
            Alias = "TP"
        });

        {
            // Check TokenInfo of NFT Collection.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = symbols[0]
            });
            tokenInfo.ExternalInfo.Value.ContainsKey(TokenAliasExternalInfoKey);
            tokenInfo.ExternalInfo.Value[TokenAliasExternalInfoKey].ShouldBe("{\"TP-31175\":\"TP\"}");
        }

        {
            // Check TokenInfo of NFT Item.
            var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
            {
                Symbol = "TP"
            });
            tokenInfo.Symbol.ShouldBe(symbols[1]);
        }

        {
            // Check alias.
            var alias = await TokenContractStub.GetTokenAlias.CallAsync(new StringValue { Value = "TP-31175" });
            alias.Value.ShouldBe("TP");
        }

        {
            var alias = await TokenContractStub.GetSymbolByAlias.CallAsync(new StringValue { Value = "TP" });
            alias.Value.ShouldBe("TP-31175");
        }
    }
```
