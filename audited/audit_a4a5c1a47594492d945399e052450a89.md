### Title
Last Irreversible Block (LIB) Advancement Halts in Two-Miner Networks With Single Round Participation Gap

### Summary
In a 2-miner AEDPoS network, the LIB calculation mechanism requires 100% continuous miner participation to advance finality. If either miner misses a single round, the LIB height calculator fails its consensus threshold check and returns zero, preventing any advancement of irreversible block height. This creates a critical liveness vulnerability where normal operational issues (network delays, maintenance) can indefinitely halt blockchain finality.

### Finding Description

The vulnerability exists in the `LastIrreversibleBlockHeightCalculator.Deconstruct()` method which calculates the LIB height based on implied irreversible heights from miners. [1](#0-0) 

For a 2-miner network, `MinersCountOfConsent` is calculated as `(2 * 2 / 3) + 1 = 2`, requiring both miners to participate. [2](#0-1) 

The root cause lies in the design decision to filter previous round data based on miners who participated in the **current** round:

1. Line 24 gets the list of miners who mined in the current round
2. Line 25 uses this list to filter implied heights from the **previous** round
3. Line 26 checks if the count of filtered heights meets `MinersCountOfConsent` [3](#0-2) 

The `GetMinedMiners()` method returns only miners where `SupposedOrderOfNextRound != 0`, meaning only those who successfully mined in that round. [4](#0-3) 

When only 1 of 2 miners mines in the current round, `GetSortedImpliedIrreversibleBlockHeights` can return at most 1 height from the previous round, causing the check `impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent` (1 < 2) to fail, returning `libHeight = 0`. [5](#0-4) 

This logic in `ProcessUpdateValue` shows that when `libHeight = 0`, no `IrreversibleBlockFound` event fires and the LIB remains frozen.

### Impact Explanation

**Concrete Operational Impact:**
- **Finality Halted**: In a 2-miner network, any single missed round by either miner immediately halts LIB advancement, preventing blocks from becoming irreversible
- **Cross-Chain Operations Blocked**: Cross-chain indexing and verification mechanisms depend on LIB heights for merkle path validation and side-chain synchronization
- **State Pruning Disabled**: Block state merging and cleanup operations triggered by LIB advancement cannot proceed, leading to unbounded state growth
- **Persistent Liveness Failure**: Once a gap occurs, recovery requires multiple consecutive rounds of full participation, creating a fragile system

**Affected Parties:**
- Side-chain operators requiring parent chain LIB updates for cross-chain transfers
- Full nodes unable to prune historical state
- Users waiting for transaction finality guarantees
- Cross-chain bridge applications depending on irreversibility confirmation

**Severity Justification**: Medium severity due to operational DoS affecting critical finality guarantees. While the chain continues producing blocks (preserving safety), the complete halt of finality advancement represents a severe liveness failure that undermines the blockchain's core value proposition of irreversibility.

### Likelihood Explanation

**Realistic Exploitability:**
- **No Attacker Required**: This is not an exploit requiring malicious intent—it occurs naturally from operational realities
- **High Probability Events**: Network partitions, scheduled maintenance, node software upgrades, temporary hardware failures, or brief connectivity issues will trigger this condition
- **Minimal Complexity**: A single missed time slot by one miner is sufficient
- **Production Reality**: In any real deployment, expecting 100% continuous uptime from both miners simultaneously is unrealistic

**Feasible Preconditions:**
- Network is configured with exactly 2 miners (valid configuration, no minimum enforced)
- One miner experiences any temporary unavailability (hours, minutes, or even seconds)
- Normal block production continues but LIB calculation enters failure state

**Detection Constraints:**
- Issue may go unnoticed if operators only monitor block height rather than LIB height
- Cross-chain operations would fail, but root cause attribution to 2-miner LIB logic requires deep investigation

**Probability Assessment**: Very High in 2-miner networks. Any network maintenance window or transient issue affecting a single miner will trigger this condition.

### Recommendation

**Code-Level Mitigation:**

1. **Adjust Consensus Threshold for Small Networks**: Modify the `MinersCountOfConsent` calculation or add a special case for n ≤ 3 miners:
   ```
   public int MinersCountOfConsent => 
       RealTimeMinersInformation.Count <= 3 
           ? Math.Max(1, RealTimeMinersInformation.Count.Mul(2).Div(3))
           : RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
   ```

2. **Alternative: Use All Available Heights**: In `Deconstruct()`, consider using all miners' implied heights from the previous round, not just those who mined in the current round:
   ```
   // Instead of filtering by current round's mined miners,
   // use all miners who set implied heights in previous round
   var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(
       _previousRound.GetMinedMiners().Select(m => m.Pubkey).ToList()
   );
   ```

3. **Enforce Minimum Miner Count**: Add validation during initialization to prevent 2-miner networks:
   ```
   Assert(input.MinerList.Count >= 3, "Minimum 3 miners required for safe consensus");
   ```

**Invariant Checks to Add:**
- Monitor LIB advancement rate and alert when LIB falls behind block height by threshold
- Add logging when `impliedIrreversibleHeights.Count < MinersCountOfConsent` to detect condition
- Validate that `MinersCountOfConsent` allows for at least one fault (f ≥ 1 in 3f+1 formula)

**Test Cases to Prevent Regression:**
1. Create test with 2 miners where one misses a round, verify LIB still advances
2. Test recovery scenario after missed rounds in 2-miner network
3. Test that 3+ miner networks handle single miner absence gracefully
4. Add invariant test that LIB advances within reasonable rounds for all miner counts

### Proof of Concept

**Initial State:**
- AEDPoS consensus initialized with 2 miners: Miner A and Miner B
- Current block height: 100
- Current LIB height: 90
- Both miners have been actively participating

**Transaction Steps:**

1. **Round N (Block 100-104)**: Both miners A and B produce blocks successfully
   - Both set their `ImpliedIrreversibleBlockHeight` in UpdateValue transactions
   - Round N completes with full participation

2. **Round N+1 (Block 105-109)**: Only Miner A produces blocks
   - Miner B is temporarily offline (network issue/maintenance)
   - Miner A calls `UpdateValue` at block 105
   - In `ProcessUpdateValue`, `LastIrreversibleBlockHeightCalculator` executes:
     - `currentRound.GetMinedMiners()` returns `[A]` (1 miner)
     - `previousRound.GetSortedImpliedIrreversibleBlockHeights([A])` returns 1 height
     - Check: `1 < 2` (MinersCountOfConsent) → TRUE
     - Returns `libHeight = 0`
     - No `IrreversibleBlockFound` event fired
     - LIB remains at 90

3. **Round N+2 (Block 110-114)**: Both miners A and B resume participation
   - Previous round (N+1) only has Miner A's data
   - Both miners call `UpdateValue`
   - `previousRound.GetSortedImpliedIrreversibleBlockHeights([A,B])` from Round N+1 still returns only 1 height (only A's data exists)
   - Check still fails: `1 < 2`
   - LIB remains stuck at 90

**Expected Result**: LIB should advance to approximately block 95-100 after Round N+1 completes, tolerating Miner B's temporary absence.

**Actual Result**: LIB remains frozen at block 90, unable to advance despite continued block production. Finality is completely halted.

**Success Condition**: The vulnerability is confirmed when a single missed round in a 2-miner network prevents LIB advancement for multiple subsequent rounds, demonstrating the fragile liveness guarantee.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```
