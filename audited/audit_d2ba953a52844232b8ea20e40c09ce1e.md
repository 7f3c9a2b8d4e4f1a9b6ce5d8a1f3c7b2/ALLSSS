### Title
State Corruption in GetValidScheme Enables Unauthorized Profit Scheme Manipulation

### Summary
The `UpdateTokenHolderProfitScheme` function writes scheme data to `State.TokenHolderProfitSchemes[Context.Sender]` instead of the correct manager address, causing scheme data corruption when users interact with schemes they don't manage. [1](#0-0)  This corrupted state enables attackers to add/remove beneficiaries to other users' profit schemes without authorization, directly violating profit distribution invariants and enabling fund theft.

### Finding Description

**Root Cause:**
In `UpdateTokenHolderProfitScheme`, the function writes the updated scheme to the wrong state entry: [2](#0-1) 

The function receives a `manager` parameter but writes to `Context.Sender` instead. This causes scheme data to be written to the wrong address whenever `Context.Sender != manager`.

**Exploitation Path:**
1. `GetValidScheme` is called by multiple public methods with different manager addresses: [3](#0-2) [4](#0-3) [5](#0-4) 

2. When a user calls `RegisterForProfits` with `schemeManager=Alice`, the user's own scheme entry gets overwritten with Alice's scheme data (SchemeId and Period).

3. Subsequently, when the user calls `AddBeneficiary` or `RemoveBeneficiary`, these methods use `GetValidScheme(Context.Sender)`: [6](#0-5) [7](#0-6) 

4. The corrupted entry contains Alice's SchemeId, so these operations target Alice's scheme instead.

**Why Existing Protections Fail:**
The Profit contract's authorization checks explicitly allow the TokenHolder contract to bypass manager verification: [8](#0-7) [9](#0-8) 

When TokenHolder contract calls `AddBeneficiary` on behalf of the attacker, the Profit contract sees `Context.Sender == TokenHolderContract` and allows the operation, even though the attacker is not the scheme manager.

### Impact Explanation

**Direct Fund Impact:**
- Attackers can add themselves as beneficiaries to any scheme with arbitrary share weights, diluting legitimate beneficiaries and stealing proportional profits
- Attackers can remove legitimate beneficiaries from schemes, denying them earned profits
- The corrupted state affects all TokenHolder profit schemes where users have registered for profits from other managers

**Quantified Damage:**
- If scheme has 1000 shares distributed to legitimate beneficiaries, attacker can add 1,000,000 shares for themselves, capturing 99.9% of all future profit distributions
- All accumulated profits in the scheme become accessible to the attacker through `ClaimProfits`

**Affected Parties:**
- All scheme managers whose schemes have external participants registered via `RegisterForProfits`
- All legitimate beneficiaries in such schemes lose their proportional rewards
- The entire TokenHolder profit distribution system integrity is compromised

**Severity Justification: CRITICAL**
- Direct theft of funds through unauthorized beneficiary manipulation
- Affects core profit distribution mechanism
- No special permissions required beyond calling public functions
- State corruption persists and can be exploited repeatedly

### Likelihood Explanation

**Attacker Capabilities:**
- Any user with basic blockchain interaction capability
- Requires no special privileges, governance control, or initial capital beyond transaction fees
- No need to compromise trusted roles

**Attack Complexity:**
- Low: Three simple transactions: RegisterForProfits → AddBeneficiary → ClaimProfits
- No timing dependencies or race conditions required
- State corruption happens automatically as side effect of legitimate operations

**Feasibility Conditions:**
- Target scheme must exist and have been created via TokenHolder contract
- Attacker must have sufficient token balance to call RegisterForProfits (can be minimal amount like 1 token)
- No detection mechanisms exist as all calls appear legitimate

**Economic Rationality:**
- Attack cost: 3 transaction fees (~0.01 ELF typical)
- Potential gain: Proportional to all future profits distributed to scheme (can be millions of tokens)
- Risk/reward ratio: Extremely favorable for attacker

**Probability: HIGH**
The vulnerability is triggered automatically by normal user interactions and requires only basic knowledge of contract interfaces. The state corruption persists indefinitely, providing ongoing exploitation opportunities.

### Recommendation

**Immediate Fix:**
Change line 298 in `UpdateTokenHolderProfitScheme` from:
```
State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```
to:
```
State.TokenHolderProfitSchemes[manager] = scheme;
``` [1](#0-0) 

**Additional Protections:**
1. Add manager authorization checks in `AddBeneficiary` and `RemoveBeneficiary` in TokenHolder contract before calling Profit contract: [10](#0-9) [11](#0-10) 

```csharp
Assert(Context.Sender == scheme.Manager, "Only scheme manager can add/remove beneficiaries.");
```

2. Consider removing the ref parameter and returning the updated scheme instead to avoid confusion about where state writes occur.

**Regression Prevention:**
- Add unit test: Verify that after calling `RegisterForProfits(schemeManager=Alice)`, Bob's scheme entry remains unchanged or null
- Add integration test: Verify that Bob cannot call `AddBeneficiary` to add himself to Alice's scheme after registering for Alice's profits
- Add invariant check: `TokenHolderProfitSchemes[address].Manager == address` for all non-null entries

### Proof of Concept

**Initial State:**
- Alice creates a TokenHolder profit scheme for token "ALICE" with 100 minimum lock minutes
- Alice's scheme has SchemeId = SCHEME_A in the Profit contract
- Alice adds Beneficiary1 and Beneficiary2, each with 1000 shares
- Scheme has accumulated 10,000 ELF tokens ready for distribution

**Attack Sequence:**

**Transaction 1:** Bob registers for Alice's scheme
```
Bob → TokenHolder.RegisterForProfits(
    schemeManager: Alice,
    amount: 1  // Minimal amount
)
```
Result: `State.TokenHolderProfitSchemes[Bob]` now contains `{Symbol: "ALICE", SchemeId: SCHEME_A, Period: 1}`

**Transaction 2:** Bob adds himself as beneficiary with massive shares
```
Bob → TokenHolder.AddBeneficiary(
    beneficiary: Bob,
    shares: 1000000
)
```
Result: `ProfitContract` adds Bob as beneficiary to SCHEME_A with 1,000,000 shares
- Total shares: 1,002,000 (Bob: 1,000,000, Beneficiary1: 1,000, Beneficiary2: 1,000)
- Bob's proportion: 99.8%

**Transaction 3:** Bob claims profits
```
Bob → TokenHolder.ClaimProfits(
    schemeManager: Alice,
    beneficiary: Bob
)
```
Result: Bob receives 9,980 ELF (99.8% of 10,000), while legitimate beneficiaries receive only 10 ELF each

**Expected vs Actual:**
- Expected: Bob should only be able to manage his own scheme entry
- Actual: Bob successfully manipulates Alice's scheme and steals 99.8% of profits
- Success Condition: Bob's token balance increases by ~9,980 ELF, transaction succeeds without revert

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L102-102)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L249-249)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```
