### Title
Hex Case Mismatch in Pubkey Replacement Causes Miner Denial of Service

### Summary
The `RecordCandidateReplacement` method accepts pubkey strings without normalizing hex case before storing them as dictionary keys in `RealTimeMinersInformation`. When a replaced miner attempts to get consensus commands, the system converts their pubkey to lowercase hex, causing a key mismatch if the replacement was stored with uppercase or mixed case. This prevents the affected miner from producing blocks.

### Finding Description

The vulnerability exists in the pubkey replacement flow across two contracts:

**Root Cause Location:** [1](#0-0) 

The `RecordCandidateReplacement` method directly uses `input.NewPubkey` as a dictionary key without normalizing the hex string format. The protobuf definition shows both pubkeys are plain strings: [2](#0-1) 

**Entry Point:** [3](#0-2) 

Candidate admins call `ReplaceCandidatePubkey` with user-provided strings that become the dictionary keys without validation.

**Failure Point:** [4](#0-3) 

When miners request consensus commands, the system converts input bytes to lowercase hex using `ToHex()`, then checks `IsInMinerList()`. Since C# dictionaries use case-sensitive string comparison, if the stored key is uppercase but the lookup uses lowercase, the check fails.

**Dictionary Access:** [5](#0-4) 

**Hex Conversion:** [6](#0-5) 

The `ToHex()` method always produces lowercase hex (characters 'a'-'f' for values 10-15).

**Initial Miner List Creation:** [7](#0-6) 

All initial pubkeys are normalized to lowercase via `ToHex()`, establishing the expected format.

### Impact Explanation

**Direct Harm:**
- The affected miner cannot retrieve valid consensus commands, preventing block production
- Network consensus capacity is reduced by one miner
- The miner loses potential block rewards during the outage period
- If multiple miners are affected, network liveness could be severely impacted

**Affected Parties:**
- The miner whose pubkey was replaced with incorrect hex case
- The blockchain network suffers from reduced consensus participation
- Users experience slower block times if multiple miners are affected

**Severity Justification (Medium):**
- No direct fund theft or permanent loss
- Operational disruption to consensus mechanism
- Can be remediated by replacing the pubkey again with correct format
- Requires admin-level action to trigger, reducing likelihood
- Impact scales with number of affected miners

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a candidate admin authorized to call `ReplaceCandidatePubkey`
- Must provide new pubkey in non-lowercase format (uppercase or mixed case)
- No special technical knowledge beyond basic hex string manipulation

**Attack Complexity:**
- Low complexity: Single transaction with uppercase hex string
- No timing requirements or race conditions
- Deterministic outcome

**Feasibility Conditions:**
- All test cases use `.ToHex()` producing lowercase: [8](#0-7) 

- However, nothing enforces lowercase at the contract level
- Manual API calls or UI inputs could provide uppercase strings
- The validation only checks hex string convertibility, not case: [9](#0-8) 

**Probability Assessment:**
- Moderate probability: Requires deviation from test patterns but no validation prevents it
- Likely accidental rather than malicious (admin mistake)
- Detection would occur immediately when miner fails to produce blocks

### Recommendation

**Code-Level Mitigation:**

Normalize hex strings to lowercase before storing as dictionary keys in `RecordCandidateReplacement`:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize hex format to lowercase
    var oldPubkey = input.OldPubkey.ToLower();
    var newPubkey = input.NewPubkey.ToLower();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(oldPubkey)) return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[oldPubkey];
    realTimeMinerInformation.Pubkey = newPubkey;
    currentRound.RealTimeMinersInformation.Remove(oldPubkey);
    currentRound.RealTimeMinersInformation.Add(newPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == oldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = newPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
    // ... rest of method
}
```

**Invariant Checks:**
- Add assertion that all pubkey dictionary keys match lowercase hex format
- Validate hex case normalization in `ReplaceCandidatePubkey` before calling consensus contract

**Regression Test:**
```csharp
[Fact]
public async Task ReplaceCandidatePubkey_WithUppercaseHex_ShouldWork()
{
    var oldPubkey = initialMiner.PublicKey.ToHex();
    var newPubkey = newMiner.PublicKey.ToHex().ToUpper(); // Uppercase
    
    await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = oldPubkey,
        NewPubkey = newPubkey
    });
    
    // Verify miner can still get consensus commands
    var command = await consensusStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(newMiner.PublicKey) });
    command.ShouldNotBe(ConsensusCommandProvider.InvalidConsensusCommand);
}
```

### Proof of Concept

**Initial State:**
1. Blockchain is running with initial miners whose pubkeys are stored in lowercase hex format in `RealTimeMinersInformation`
2. A miner "Alice" with pubkey "abcd1234..." (lowercase) is actively producing blocks
3. Alice's admin address is authorized to replace her pubkey

**Attack Steps:**

Step 1: Admin calls `ReplaceCandidatePubkey` with uppercase new pubkey:
```
Input: {
  OldPubkey: "abcd1234...",  // lowercase
  NewPubkey: "EFGH5678..."   // UPPERCASE
}
```

Step 2: Election Contract processes and calls `RecordCandidateReplacement`

Step 3: Consensus contract updates `RealTimeMinersInformation`:
- Removes key "abcd1234..."
- Adds key "EFGH5678..." (uppercase as provided)

Step 4: Alice's node attempts to get consensus command:
- Node provides raw public key bytes corresponding to "EFGH5678"
- `GetConsensusCommand` converts to lowercase: "efgh5678..."
- `IsInMinerList("efgh5678...")` returns false (key is "EFGH5678")
- Returns `InvalidConsensusCommand`

**Expected vs Actual Result:**
- **Expected:** Miner can produce blocks with new pubkey regardless of input hex case
- **Actual:** Miner is blocked from producing blocks due to case mismatch

**Success Condition:**
The vulnerability is confirmed when `IsInMinerList` check fails for a legitimately replaced miner whose replacement used non-lowercase hex format, preventing them from receiving consensus commands and producing blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-146)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** protobuf/aedpos_contract.proto (L452-455)
```text
message RecordCandidateReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-27)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L35-35)
```csharp
        protected MinerInRound MinerInRound => CurrentRound.RealTimeMinersInformation[Pubkey];
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L8-32)
```csharp
        public static string ToHex(this ByteString bytes, bool withPrefix = false)
        {
            var offset = withPrefix ? 2 : 0;
            var length = bytes.Length * 2 + offset;
            var c = new char[length];

            byte b;

            if (withPrefix)
            {
                c[0] = '0';
                c[1] = 'x';
            }

            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }

            return new string(c);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-37)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L38-42)
```csharp
        await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
        {
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```
