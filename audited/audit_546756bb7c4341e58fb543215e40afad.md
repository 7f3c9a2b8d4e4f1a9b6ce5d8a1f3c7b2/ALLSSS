### Title
Missing Validation of MerklePath Content Allows Storage of Empty Merkle Paths Leading to Cross-Chain Verification Failure

### Summary
The `AddIndexedTxRootMerklePathInParentChain` function stores MerklePath objects without validating that they contain any merkle path nodes. This allows empty or invalid merkle paths to be stored during parent chain block indexing, which later causes permanent verification failures for cross-chain transactions from affected side chain heights, effectively creating a denial-of-service condition for cross-chain operations. [1](#0-0) 

### Finding Description

The vulnerability exists in the cross-chain indexing flow where parent chain block data is validated and stored:

**1. Missing Validation in Storage Function:**
The `AddIndexedTxRootMerklePathInParentChain` function only checks that no merkle path already exists for a given height, but does not validate that the `path` parameter contains valid merkle path nodes: [1](#0-0) 

**2. Insufficient Pre-Storage Validation:**
The `ValidateParentChainBlockData` function validates parent chain block data before indexing, but only checks that heights haven't been previously indexed - it does NOT validate the content of merkle paths in the `IndexedMerklePath` map: [2](#0-1) 

The validation at lines 731-733 only checks for duplicate storage, not merkle path validity.

**3. Execution Path:**
When parent chain block data is indexed via `IndexParentChainBlockData`, merkle paths from `blockInfo.IndexedMerklePath` are directly stored without content validation: [3](#0-2) 

**4. Verification Failure Mechanism:**
The stored merkle path is later retrieved via `GetBoundParentChainHeightAndMerklePathByHeight`, which only validates non-null but not content: [4](#0-3) 

During cross-chain token transfers, the merkle path nodes are concatenated and used for verification: [5](#0-4) 

If the stored merkle path has empty `MerklePathNodes`, the `ComputeRootWithLeafNode` method returns only the leaf hash without proper merkle tree traversal: [6](#0-5) 

The computed root will not match the expected merkle tree root, causing verification to fail: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**
- Cross-chain token transfers from affected side chain block heights permanently fail with "Cross chain verification failed" error
- Cross-chain operations (token transfers, contract calls) for specific heights are blocked indefinitely
- No recovery mechanism exists to fix stored empty merkle paths - the data is permanently corrupted in contract state

**Affected Parties:**
- Users attempting cross-chain token transfers from indexed side chain blocks with invalid merkle paths
- DApps relying on cross-chain functionality for those specific heights
- Side chain operations depending on parent chain verification

**Severity Justification:**
Medium severity because:
- Impact is permanent DoS of cross-chain functionality for affected heights
- No direct fund theft, but can trap funds if transfers were already initiated
- Requires trusted party error (miner proposing invalid data + governance approval) or software bugs
- Violates defense-in-depth principles by lacking validation of critical cryptographic proof data

### Likelihood Explanation

**Attack Preconditions:**
1. A miner must propose parent chain block data containing empty/invalid merkle paths via `ProposeCrossChainIndexing`: [8](#0-7) 

2. The proposal must pass validation (which doesn't check merkle path content)
3. Governance must approve the proposal
4. A miner must release the proposal via `ReleaseCrossChainIndexingProposal`: [9](#0-8) 

**Realistic Scenarios:**
- **Software Bug**: Parent chain indexing service has a bug that produces empty merkle paths, which miners unknowingly propose
- **Data Corruption**: Network issues or storage corruption causes merkle path data loss before proposal
- **Insufficient Review**: Governance approves proposal without carefully inspecting merkle path content
- **Malicious Compromise**: Compromised miner + governance collude to DoS cross-chain functionality

**Complexity:**
- Moderate complexity - requires multiple steps but no complex cryptographic manipulation
- Does not require breaking consensus or other security assumptions
- Realistic under operational error scenarios (bugs, corruption) rather than pure malicious intent

**Detection:**
- Invalid merkle paths would not be detected until cross-chain transactions attempt verification
- No on-chain validation alerts miners or governance about data quality issues

### Recommendation

**Immediate Fix:**
Add validation in `AddIndexedTxRootMerklePathInParentChain` to ensure merkle paths contain valid data:

```csharp
private void AddIndexedTxRootMerklePathInParentChain(long height, MerklePath path)
{
    var existing = State.TxRootMerklePathInParentChain[height];
    Assert(existing == null, $"Merkle path already bound at height {height}.");
    
    // Add validation for merkle path content
    Assert(path != null, "Merkle path cannot be null.");
    Assert(path.MerklePathNodes != null && path.MerklePathNodes.Count > 0, 
        $"Merkle path must contain at least one node for height {height}.");
    
    // Optionally validate each node has valid hash
    Assert(path.MerklePathNodes.All(node => node?.Hash != null && !node.Hash.Value.IsNullOrEmpty()),
        "All merkle path nodes must have valid hashes.");
    
    State.TxRootMerklePathInParentChain[height] = path;
}
```

**Additional Hardening:**
Add validation in `ValidateParentChainBlockData` to check merkle path content during proposal validation: [10](#0-9) 

**Test Cases:**
1. Test that proposing parent chain block data with empty merkle paths is rejected
2. Test that proposing merkle paths with null nodes is rejected  
3. Test that valid merkle paths with proper node count pass validation
4. Regression test ensuring cross-chain verification works end-to-end with validated merkle paths

### Proof of Concept

**Initial State:**
- Side chain operational with parent chain connection established
- Miner has authority to propose cross-chain indexing
- Governance organization configured and operational

**Attack Steps:**

1. **Malicious Proposal Creation**: Miner crafts `ParentChainBlockData` with empty merkle paths:
```csharp
var parentChainBlockData = new ParentChainBlockData {
    Height = currentHeight + 1,
    ChainId = parentChainId,
    TransactionStatusMerkleTreeRoot = validMerkleRoot,
    IndexedMerklePath = {
        { sideChainHeight, new MerklePath() } // Empty MerklePath with zero nodes
    }
};
```

2. **Proposal Submission**: Miner calls `ProposeCrossChainIndexing` with the crafted data - validation passes because `ValidateParentChainBlockData` doesn't check merkle path content

3. **Governance Approval**: Proposal is approved through Parliament contract (either through insufficient review or compromise)

4. **Data Recording**: Miner calls `ReleaseCrossChainIndexingProposal`, which executes `RecordCrossChainData`, storing the empty merkle path via `AddIndexedTxRootMerklePathInParentChain`

5. **Verification Failure**: User attempts cross-chain token transfer:
```csharp
var merkleProof = await GetBoundParentChainHeightAndMerklePathByHeight(sideChainHeight);
// merkleProof.MerklePathFromParentChain.MerklePathNodes.Count == 0

// Concatenate paths for verification
completePath.MerklePathNodes.AddRange(merkleProof.MerklePathFromParentChain.MerklePathNodes);

// Call CrossChainReceiveToken - verification fails
// ComputeRootWithLeafNode returns wrong root due to empty path
// Assert fails: "Cross chain verification failed."
```

**Expected vs Actual:**
- **Expected**: Invalid merkle paths rejected during proposal validation
- **Actual**: Empty merkle paths stored successfully, causing permanent verification failures

**Success Condition**: 
Cross-chain transactions from affected heights fail with verification error, confirming DoS condition exists.

**Notes**

While this vulnerability requires trusted party error or compromise (miner + governance), it represents a critical gap in defensive validation. The MerklePath structure defined in protobuf can legitimately have empty `merkle_path_nodes` in edge cases (single-node merkle trees), making it essential to validate context-appropriate constraints. The lack of validation violates defense-in-depth principles and leaves the system vulnerable to operational errors, software bugs, or data corruption scenarios that could permanently impact cross-chain functionality.

The finding is particularly relevant because cross-chain operations are critical infrastructure, and merkle path verification is a core security mechanism. Even under the assumption of honest miners and governance, the code should validate cryptographic proof data integrity to prevent accidental corruption from propagating into contract state.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L52-58)
```csharp
    private void AddIndexedTxRootMerklePathInParentChain(long height, MerklePath path)
    {
        var existing = State.TxRootMerklePathInParentChain[height];
        Assert(existing == null,
            $"Merkle path already bound at height {height}.");
        State.TxRootMerklePathInParentChain[height] = path;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L720-743)
```csharp
    private bool ValidateParentChainBlockData(IList<ParentChainBlockData> parentChainBlockData,
        out Dictionary<int, List<ParentChainBlockData>> validatedParentChainBlockData)
    {
        var parentChainId = State.ParentChainId.Value;
        var currentHeight = State.CurrentParentChainHeight.Value;
        validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        foreach (var blockData in parentChainBlockData)
        {
            if (parentChainId != blockData.ChainId || currentHeight + 1 != blockData.Height ||
                blockData.TransactionStatusMerkleTreeRoot == null)
                return false;
            if (blockData.IndexedMerklePath.Any(indexedBlockInfo =>
                    State.ChildHeightToParentChainHeight[indexedBlockInfo.Key] != 0 ||
                    State.TxRootMerklePathInParentChain[indexedBlockInfo.Key] != null))
                return false;

            currentHeight += 1;
        }

        if (parentChainBlockData.Count > 0)
            validatedParentChainBlockData[parentChainId] = parentChainBlockData.ToList();

        return true;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L776-780)
```csharp
            foreach (var indexedBlockInfo in blockInfo.IndexedMerklePath)
            {
                BindParentChainHeight(indexedBlockInfo.Key, parentChainHeight);
                AddIndexedTxRootMerklePathInParentChain(indexedBlockInfo.Key, indexedBlockInfo.Value);
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L19-30)
```csharp
    public override CrossChainMerkleProofContext GetBoundParentChainHeightAndMerklePathByHeight(Int64Value input)
    {
        var boundParentChainHeight = State.ChildHeightToParentChainHeight[input.Value];
        Assert(boundParentChainHeight != 0);
        var merklePath = State.TxRootMerklePathInParentChain[input.Value];
        Assert(merklePath != null);
        return new CrossChainMerkleProofContext
        {
            MerklePathFromParentChain = merklePath,
            BoundParentChainHeight = boundParentChainHeight
        };
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractCrossChainTest.cs (L219-230)
```csharp
        var boundParentChainHeightAndMerklePath =
            await GetBoundParentChainHeightAndMerklePathByHeight(executedSet.Height);

        var crossChainCreateTokenInput = new CrossChainCreateTokenInput
        {
            FromChainId = sideChainId,
            ParentChainHeight = boundParentChainHeightAndMerklePath.BoundParentChainHeight,
            TransactionBytes = tokenValidationTransaction.ToByteString(),
            MerklePath = merklePath
        };
        crossChainCreateTokenInput.MerklePath.MerklePathNodes.AddRange(boundParentChainHeightAndMerklePath
            .MerklePathFromParentChain.MerklePathNodes);
```

**File:** src/AElf.Types/Extensions/MerklePathExtensions.cs (L9-14)
```csharp
        public static Hash ComputeRootWithLeafNode(this MerklePath path, Hash leaf)
        {
            return path.MerklePathNodes.Aggregate(leaf, (current, node) => node.IsLeftChildNode
                ? HashHelper.ConcatAndCompute(node.Hash, current)
                : HashHelper.ConcatAndCompute(current, node.Hash));
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```
