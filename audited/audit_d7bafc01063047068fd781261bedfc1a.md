# Audit Report

## Title
Fee-Free CheckThreshold Method Enables Resource Exhaustion DOS Attack via Unbounded State Reads

## Summary
The `CheckThreshold` method in the MultiToken contract is marked as completely fee-free but lacks input validation on the size of the `symbol_to_threshold` map. This allows attackers to craft transactions with thousands of symbol entries that trigger expensive state reads at zero cost, exploiting the transaction validation layer where nodes pre-execute transactions before rejection, causing sustained resource exhaustion across validator nodes.

## Finding Description

The `CheckThreshold` method is a public RPC method that can be directly invoked by any user. [1](#0-0) 

The method is explicitly marked as completely fee-free in the ACS1 fee provider implementation, returning `IsSizeFeeFree = true` with no method fees configured. [2](#0-1) 

The implementation iterates through every entry in `input.SymbolToThreshold` without any size validation, calling `GetBalance()` for each symbol. [3](#0-2)  When `IsCheckAllowance` is true, additional allowance state reads occur. [4](#0-3) 

The `GetBalance()` method performs expensive state reads from persistent storage. [5](#0-4) 

The protobuf definition places no constraints on the map size, allowing arbitrarily large inputs limited only by transaction size. [6](#0-5) 

The critical attack vector exists in the validation pipeline: `TransactionExecutionValidationProvider` pre-executes all incoming transactions to validate they will succeed before accepting them into the mempool. [7](#0-6)  This validation is **enabled by default** [8](#0-7)  and runs during normal mempool admission (not during sync). [9](#0-8) 

Even though a malicious `CheckThreshold` transaction with thousands of symbols would ultimately fail the assertion and be rejected, the pre-execution itself has already consumed significant validator resources by performing all the state reads. The transaction size limit of 5MB [10](#0-9)  allows an attacker to include thousands of symbol entries, each triggering expensive state operations.

**Attack Flow:**
1. Attacker crafts `CheckThreshold` transaction with 10,000+ symbol entries (within 5MB limit)
2. Transaction submitted to network at **zero cost** (completely fee-free)
3. Each validator node's mempool admission pipeline invokes `TransactionExecutionValidationProvider`
4. Pre-execution iterates through all symbols, performing 10,000+ `GetBalance` state reads
5. Transaction ultimately fails assertion and is rejected
6. Damage is done - validator has consumed significant CPU/IO resources during validation
7. Attacker spams multiple such transactions continuously to exhaust validator resources

## Impact Explanation

**Operational Denial-of-Service of Transaction Validation Infrastructure:**

- **Resource Exhaustion**: Attackers force validator nodes to perform thousands of expensive state reads per malicious transaction during the validation phase, consuming CPU cycles and disk I/O bandwidth at zero cost to the attacker.

- **Network Degradation**: As validators spend resources validating malicious transactions, legitimate transaction validation and inclusion times increase, degrading overall network throughput and user experience.

- **Amplification Factor**: With 10,000 symbols per transaction achievable under the 5MB limit, each malicious transaction triggers 10,000+ state operations. Multiple concurrent attackers can submit hundreds of such transactions to the mempool, creating severe resource pressure.

- **Zero Economic Cost**: The completely fee-free status removes all economic disincentives, making sustained attacks cost-free for attackers while expensive for validators.

**Affected Parties:**
- All validator nodes (forced to execute expensive validation operations)
- Network users (delayed transaction processing times)
- DApp operators (degraded service reliability)

**Severity: Medium** - While this does not compromise funds, consensus integrity, or governance directly, it enables practical operational disruption of the network's transaction processing infrastructure at zero attacker cost, which justifies Medium severity in standard security frameworks.

## Likelihood Explanation

**Attacker Requirements: Minimal**
- No special permissions, tokens, or privileges required
- Only needs standard ability to submit transactions to the network
- Zero financial cost due to fee-free method status
- Standard transaction construction tools sufficient

**Attack Complexity: Low**
- Straightforward to construct large `CheckThresholdInput` with many symbol entries
- No timing dependencies, race conditions, or complex state manipulations required
- Trivially automatable for sustained attacks

**Feasibility: Highly Feasible**
- `CheckThreshold` is a public method directly callable by anyone
- No rate limiting, caller restrictions, or input size validation
- Transaction execution validation is enabled by default on all nodes
- Fee-free status eliminates economic barriers

**Detection vs Prevention Gap:**
- Attacks would be visible in mempool logs and metrics
- However, distinguishing malicious large threshold checks from legitimate ones is challenging
- No protocol-level DOS protection exists for fee-free methods
- Node operators can manually configure but lack automated defenses

**Overall Probability: High** - The combination of zero cost, no input validation, expensive operations per entry, and default-enabled validation creates a practical and economically rational attack vector for adversaries seeking to disrupt network operations.

## Recommendation

**Immediate Mitigation:**
1. Add input validation to limit `SymbolToThreshold` map size in `CheckThreshold`:
   ```csharp
   public override Empty CheckThreshold(CheckThresholdInput input)
   {
       AssertValidInputAddress(input.Sender);
       const int MaxSymbolCount = 10; // Reasonable limit for legitimate use
       Assert(input.SymbolToThreshold.Count <= MaxSymbolCount, 
              $"Symbol count exceeds maximum allowed ({MaxSymbolCount}).");
       
       // ... rest of implementation
   }
   ```

2. Consider charging minimal fees for `CheckThreshold` when called directly (not as pre-plugin) to create economic disincentive for abuse.

**Long-term Solutions:**
1. Implement rate limiting or resource accounting for validation-layer operations
2. Add mempool DOS protection mechanisms that detect and throttle suspicious patterns
3. Consider making transaction execution validation configurable per-method rather than global
4. Review other fee-free methods for similar unbounded iteration vulnerabilities

## Proof of Concept

```csharp
[Fact]
public async Task CheckThreshold_DOS_Attack_Test()
{
    // This test demonstrates the DOS vulnerability by creating a CheckThreshold
    // transaction with a large number of symbols that will trigger thousands
    // of GetBalance state reads during validation, at zero cost to the attacker.
    
    var attackerKeyPair = CryptoHelper.GenerateKeyPair();
    var attackerAddress = Address.FromPublicKey(attackerKeyPair.PublicKey);
    
    // Create input with 10,000 symbol entries (achievable under 5MB limit)
    var maliciousInput = new CheckThresholdInput
    {
        Sender = attackerAddress,
        IsCheckAllowance = false,
        SymbolToThreshold = { }
    };
    
    // Add 10,000 fake symbols - each will trigger a GetBalance state read
    for (int i = 0; i < 10000; i++)
    {
        maliciousInput.SymbolToThreshold.Add($"SYM{i}", 100);
    }
    
    // Verify transaction size is under 5MB limit
    var transaction = TokenContractStub.CheckThreshold.GetTransaction(maliciousInput);
    var transactionSize = transaction.CalculateSize();
    transactionSize.ShouldBeLessThan(5 * 1024 * 1024); // Under 5MB
    
    // This call will fail (as attacker doesn't have tokens) BUT:
    // - During validation, GetBalance will be called 10,000 times
    // - Each call reads from persistent state storage
    // - All this happens at ZERO cost due to fee-free status
    // - Validator resources are exhausted validating this doomed transaction
    
    var exception = await Assert.ThrowsAsync<Exception>(
        async () => await TokenContractStub.CheckThreshold.SendAsync(maliciousInput));
    
    exception.Message.ShouldContain("Cannot meet the calling threshold");
    
    // Attack successful: Validator performed 10,000+ state reads for free,
    // and attacker can repeat this attack indefinitely at zero cost.
}
```

## Notes

**Key Evidence Summary:**
- Fee-free status confirmed: [2](#0-1) 
- Unbounded iteration: [3](#0-2) 
- Validation pre-execution: [11](#0-10) 
- Enabled by default: [8](#0-7) 

The vulnerability is architectural: the combination of (1) fee-free methods, (2) unbounded inputs, (3) expensive operations per input, and (4) pre-execution validation creates a resource exhaustion vector that bypasses normal economic protections against DOS attacks.

### Citations

**File:** protobuf/token_contract.proto (L96-96)
```text
    rpc CheckThreshold (CheckThresholdInput) returns (google.protobuf.Empty) {
```

**File:** protobuf/token_contract.proto (L413-420)
```text
message CheckThresholdInput {
    // The sender of the transaction.
    aelf.Address sender = 1;
    // The threshold to set, Symbol->Threshold.
    map<string, int64> symbol_to_threshold = 2;
    // Whether to check the allowance.
    bool is_check_allowance = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L39-49)
```csharp
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L344-348)
```csharp
        foreach (var symbolToThreshold in input.SymbolToThreshold)
        {
            if (GetBalance(input.Sender, symbolToThreshold.Key) < symbolToThreshold.Value)
                continue;
            meetBalanceSymbolList.Add(symbolToThreshold.Key);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L353-360)
```csharp
            if (input.IsCheckAllowance)
                foreach (var symbol in meetBalanceSymbolList)
                {
                    if (State.Allowances[input.Sender][Context.Sender][symbol] <
                        input.SymbolToThreshold[symbol]) continue;
                    meetThreshold = true;
                    break;
                }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/TransactionExecutionValidationProvider.cs (L29-29)
```csharp
    public bool ValidateWhileSyncing { get; } = false;
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/TransactionExecutionValidationProvider.cs (L31-48)
```csharp
    public async Task<bool> ValidateTransactionAsync(Transaction transaction, IChainContext chainContext)
    {
        if (!_transactionOptions.EnableTransactionExecutionValidation)
            return true;

        var executionReturnSets = await _plainTransactionExecutingService.ExecuteAsync(new TransactionExecutingDto
        {
            Transactions = new[] { transaction },
            BlockHeader = new BlockHeader
            {
                PreviousBlockHash = chainContext.BlockHash,
                Height = chainContext.BlockHeight + 1,
                Time = TimestampHelper.GetUtcNow()
            }
        }, CancellationToken.None);

        var executionValidationResult =
            executionReturnSets.FirstOrDefault()?.Status == TransactionResultStatus.Mined;
```

**File:** src/AElf.Kernel.TransactionPool/TransactionOptions.cs (L19-19)
```csharp
    public bool EnableTransactionExecutionValidation { get; set; } = true;
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```
