### Title
Partial Fee Deduction for Insufficient Balance Causes Irreversible Fund Loss Without Transaction Execution

### Summary
When users attempt transactions with insufficient balance to cover full transaction fees, the fee charging pre-execution plugin deducts all available balance and commits these state changes, but then stops execution before the main transaction runs. Users permanently lose their remaining funds without receiving any service, as the fee collection succeeds while the intended operation never executes.

### Finding Description

The vulnerability exists in the transaction fee charging flow implemented in the MultiToken contract's pre-execution plugin mechanism. The critical issue occurs in the `TryToChargeTransactionFee` method where `ModifyBalance` is called unconditionally regardless of whether sufficient fees could be collected. [1](#0-0) 

When a user has insufficient balance, the `ChargeBaseFee` method populates the transaction bill with whatever balance exists, even though it returns false to indicate charging failure: [2](#0-1) 

The `ModifyBalance` method then deducts these partial fees from the user's account, firing `TransactionFeeCharged` events and permanently modifying state: [3](#0-2) 

The transaction returns `Success = false` with error message "Transaction fee not enough", which causes the `IsStopExecuting` check in the pre-execution plugin to return true: [4](#0-3) 

In the transaction execution service, when the pre-execution plugin succeeds but signals to stop (via `IsStopExecuting`), the state changes from the fee deduction are already committed to both internal and parent state caches before the stop signal is processed: [5](#0-4) 

The main transaction is then marked as `ExecutionStatus.Prefailed` and never executes: [6](#0-5) 

### Impact Explanation

This vulnerability causes direct financial loss to users who attempt transactions without sufficient balance. Users lose all their remaining token balance (which gets charged as partial fees) but receive absolutely no service in return since their intended transaction never executes.

**Concrete impact:**
- **Fund Loss**: Users lose 100% of available balance in the fee token when attempting transactions they cannot afford
- **No Service Delivered**: The Profit contract operations (or any other contract calls) never execute, so users get nothing for their payment
- **Irreversible**: No refund mechanism exists; once state changes are committed in the pre-execution phase, they are permanent
- **Affects All Contracts**: This applies to all AElf smart contract interactions, including critical Profit contract operations like scheme creation, profit distribution, and benefit claims

**Quantified example:** A user with 99,999 ELF attempting a transaction requiring 100,000 ELF loses all 99,999 tokens while their Profit contract operation (e.g., creating a profit scheme, claiming dividends) never executes. [7](#0-6) 

### Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can occur in normal operational scenarios without requiring attacker capabilities:

**Feasible Conditions:**
1. User calculates transaction cost incorrectly
2. Fee prices increase between transaction preparation and submission
3. User has multiple pending transactions that deplete their balance
4. Delegation limits are exhausted but user is unaware
5. Token price volatility affects multi-token fee payment calculations

**Execution Practicality:**
- Entry point is any public contract method with fees configured
- Requires only that `user_balance < required_fee`
- No special permissions or complex transaction sequencing needed
- Affects users interacting with Profit contracts, Treasury, Token operations, and all other fee-charging methods

**Economic Rationality:**
While users would typically avoid this by checking balances first, realistic scenarios include:
- Wallet UI showing outdated balance information
- Concurrent transactions from same account
- Fee configuration changes between estimation and execution
- Users new to the platform unfamiliar with fee charging behavior

**Detection:** The behavior is not easily detectable pre-transaction since fee estimation occurs separately from execution, and transaction simulation may not perfectly match actual execution conditions.

### Recommendation

**Immediate Mitigation:**

1. **Modify the fee charging logic to avoid partial deductions**. In `TryToChargeTransactionFee`, only call `ModifyBalance` when `chargingResult` is true:

```csharp
// Line 118 in TokenContract_Fees.cs
if (chargingResult)
{
    ModifyBalance(fromAddress, bill, allowanceBill);
}
```

2. **Clear the bill when charging fails**. In `ChargeBaseFee`, do not populate the bill with partial amounts when returning false:

```csharp
// Lines 348-355 in TokenContract_Fees.cs
if (!ChargeFirstSufficientToken(...))
{
    Context.LogDebug(() => "Failed to charge first sufficient token.");
    // DO NOT add partial amounts to bill
    return false;
}
```

3. **Add explicit balance verification** before attempting fee deduction. Create a pre-check method that validates sufficient balance exists before any state modifications.

4. **Implement fee estimation endpoint** that accurately calculates total fees (base + size) and returns clear success/failure indication before transaction submission.

**Invariant to Enforce:**
"Fee state modifications SHALL only be committed when sufficient balance exists to execute the intended transaction. If `ChargeTransactionFees` returns `Success = false`, no balance modifications SHALL occur."

**Test Cases:**
1. Verify insufficient balance transactions result in zero fee deduction and original balance preserved
2. Test delegation scenarios where partial charging previously occurred
3. Verify multi-token fee payment with one insufficient token doesn't drain other tokens
4. Confirm fee estimation matches actual charging for various transaction sizes

### Proof of Concept

**Initial State:**
- User account: 99,999 ELF tokens
- Contract method fee requirement: 100,000 ELF (base fee + size fee)
- User wants to call Profit.CreateScheme to create a new profit distribution scheme

**Transaction Steps:**

1. User submits transaction to Profit contract's `CreateScheme` method
2. Pre-execution plugin generates `ChargeTransactionFees` transaction
3. Fee charging logic executes:
   - Calculates required fee: 100,000 ELF
   - User balance: 99,999 ELF  
   - `ChargeFirstSufficientToken` returns false (insufficient)
   - BUT bill is populated with existing balance (99,999 ELF)
   - `ModifyBalance` is called unconditionally
4. User balance modified: 99,999 â†’ 0 ELF
5. `TransactionFeeCharged` event fired for 99,999 ELF
6. Pre-transaction returns `Success = false`
7. `IsStopExecuting` returns true
8. Main transaction execution skipped
9. Transaction result: `Status = Failed`, `Error = "Pre-Error: Transaction fee not enough."`

**Expected Result:** User should either pay full 100,000 ELF and transaction executes, OR pay nothing and transaction fails with clear insufficient balance error.

**Actual Result:** User pays 99,999 ELF (entire balance), profit scheme is NOT created, and user receives error message. User has zero balance and no profit scheme.

**Success Condition for Exploit:** User balance after failed transaction = 0, User's intended Profit contract state (scheme creation) = not executed.

This is demonstrated in the existing test case which validates this behavior as expected, confirming the vulnerability exists by design: [8](#0-7)

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-266)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }

        if (freeAllowancesMap.Map == null || freeAllowancesMap.Map.Count == 0) return;

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount > 0)
            {
                ModifyFreeFeeAllowanceAmount(fromAddress, freeAllowancesMap, symbol, -amount);
            }
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L336-373)
```csharp
    private bool ChargeBaseFee(Dictionary<string, long> methodFeeMap, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {
        Context.LogDebug(() => "ChargeBaseFee Start");
        // Fail to charge
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }

        // Succeed to charge, freeAllowance first.
        if (existingAllowance > amountToChargeBaseFee)
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee);
            // free fee allowance has covered fee, add 0 for size fee
            bill.FeesMap.Add(symbolToChargeBaseFee, 0);
        }
        else
        {
            allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            bill.FeesMap.Add(symbolToChargeBaseFee, amountToChargeBaseFee.Sub(existingAllowance));
        }

        Context.LogDebug(() => "ChargeBaseFee End");
        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L163-178)
```csharp
        try
        {
            #region PreTransaction

            if (singleTxExecutingDto.Depth == 0)
                if (!await ExecutePluginOnPreTransactionStageAsync(executive, txContext,
                        singleTxExecutingDto.CurrentBlockTime,
                        internalChainContext, internalStateCache, cancellationToken))
                {
                    trace.ExecutionStatus = ExecutionStatus.Prefailed;
                    return trace;
                }

            #endregion

            await executive.ApplyAsync(txContext);
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L249-298)
```csharp
    private async Task<bool> ExecutePluginOnPreTransactionStageAsync(IExecutive executive,
        ITransactionContext txContext,
        Timestamp currentBlockTime,
        IChainContext internalChainContext,
        TieredStateCache internalStateCache,
        CancellationToken cancellationToken)
    {
        if (await _featureDisableService.IsFeatureDisabledAsync("TxPlugin", "PrePlugin"))
        {
            return true;
        }

        var trace = txContext.Trace;
        foreach (var plugin in _prePlugins)
        {
            var transactions = await plugin.GetPreTransactionsAsync(executive.Descriptors, txContext);
            foreach (var preTx in transactions)
            {
                var singleTxExecutingDto = new SingleTransactionExecutingDto
                {
                    Depth = 0, //TODO: this 0 means it is possible that pre/post txs could have own pre/post txs
                    ChainContext = internalChainContext,
                    Transaction = preTx,
                    CurrentBlockTime = currentBlockTime,
                    OriginTransactionId = txContext.OriginTransactionId
                };
                var preTrace = await ExecuteOneAsync(singleTxExecutingDto, cancellationToken);
                if (preTrace == null)
                    return false;
                trace.PreTransactions.Add(preTx);
                trace.PreTraces.Add(preTrace);

                if (!preTrace.IsSuccessful()) return false;

                var stateSets = preTrace.GetStateSets().ToList();
                internalStateCache.Update(stateSets);
                var parentStateCache = txContext.StateCache as TieredStateCache;
                parentStateCache?.Update(stateSets);

                if (!plugin.IsStopExecuting(preTrace.ReturnValue, out var error)) continue;

                // If pre-tx fails, still commit the changes, but return false to notice outside to stop the execution.
                preTrace.Error = error;
                preTrace.ExecutionStatus = ExecutionStatus.Executed;
                return false;
            }
        }

        return true;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L306-342)
```csharp
    public async Task ChargeFee_TxFee_FailedTest()
    {
        await DeployTestContractAsync();

        var issueAmount = 99999;
        var tokenContractStub = await GetTokenContractStubAsync();
        await SetPrimaryTokenSymbolAsync(tokenContractStub);

        await tokenContractStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "ELF",
            Amount = issueAmount,
            To = Accounts[1].Address,
            Memo = "Set for token converter."
        });

        var feeAmount = 100000;
        await SetMethodFee_Successful(feeAmount);

        var userTestContractStub =
            GetTester<ContractContainer.ContractStub>(_testContractAddress,
                Accounts[1].KeyPair);
        var dummy = await userTestContractStub.DummyMethod
            .SendWithExceptionAsync(new Empty()); // This will deduct the fee
        dummy.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        dummy.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
        var transactionFeeDic = dummy.TransactionResult.GetChargedTransactionFees();
        await CheckTransactionFeesMapAsync(Accounts[1].Address,transactionFeeDic);

        var afterFee = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = "ELF"
        })).Balance;
        afterFee.ShouldBe(0);
        transactionFeeDic[Accounts[1].Address]["ELF"].ShouldBe(issueAmount);
    }
```
