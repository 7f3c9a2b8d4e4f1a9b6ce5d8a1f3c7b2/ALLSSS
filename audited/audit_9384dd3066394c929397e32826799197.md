### Title
Non-Deterministic Data Center Removal Due to Unstable Sorting with Equal Vote Amounts

### Summary
The `SyncSubsidyInfoAfterReduceMiner()` function uses `OrderBy(x => x.Value).Take(diffCount)` to remove the lowest-ranked data centers when the miner count is reduced. When multiple data centers have equal vote amounts, the underlying MapField iteration order is non-deterministic, causing different blockchain nodes to remove different sets of candidates, leading to state divergence and consensus failure.

### Finding Description

The vulnerable code is located in `SyncSubsidyInfoAfterReduceMiner()`: [1](#0-0) 

The root cause is that `DataCentersRankingList.DataCenters` is a protobuf map (MapField<string, long>) as defined in the protobuf schema: [2](#0-1) 

MapField (dictionary-based) has **non-deterministic iteration order**. Evidence from the codebase shows that when deterministic ordering is required, explicit sorting with secondary keys is used, such as in consensus round generation where `.OrderBy(m => m.Order)` is explicitly applied to MapField values.

When `OrderBy(x => x.Value)` is called on the dictionary:
1. It receives KeyValuePair entries in whatever order the MapField enumerator provides (non-deterministic)
2. Although OrderBy is a stable sort, the **input order is already non-deterministic**
3. For entries with equal values, their relative order after sorting remains non-deterministic
4. Different nodes may enumerate the dictionary in different orders
5. `Take(diffCount)` then selects different sets of candidates on different nodes

This function is called from `UpdateMinersCount()`: [3](#0-2) 

The same vulnerability exists in two other locations:
- Line 368-369 in ElectionContract_Maintainence.cs (investigated function)
- Line 475 in ElectionContract_Elector.cs (finds first minimum without secondary sort) [4](#0-3) 
- Line 741 in ElectionContract_Elector.cs (uses First() without secondary sort) [5](#0-4) 

### Impact Explanation

**State Divergence:** When multiple data centers have equal vote amounts at the removal boundary, different nodes will remove different sets of candidates, causing their blockchain states to diverge. This is a critical consensus failure.

**Incorrect Subsidy Distribution:** The removed candidates are also removed from the subsidy profit scheme via `RemoveBeneficiary()`: [6](#0-5) 

The beneficiary removal affects the Profit contract's subsidy distribution: [7](#0-6) 

**Who is Affected:**
- Blockchain network: consensus integrity compromised
- Data center operators: wrong candidates lose subsidy eligibility
- Token holders: incorrect profit distribution

**Severity Justification - Medium:**
- Requires multiple candidates with exactly equal vote amounts at the removal boundary
- Not guaranteed on every miner count reduction
- But when it occurs, causes immediate consensus failure
- No fund loss, but operational integrity severely impacted

### Likelihood Explanation

**High Likelihood - No Attacker Needed:**

This is a determinism bug, not an attack vector. Equal vote amounts occur naturally:
1. **Newly announced candidates** with 0 votes
2. **Equal votes from different voters** (e.g., two candidates each receiving 1000 tokens from different addresses)
3. **Post-withdrawal states** where multiple candidates end up with the same vote count

**Reachable Entry Point:**
`UpdateMinersCount()` is called by the consensus contract during term transitions when the maximum miner count changes: [8](#0-7) 

**Execution Path:**
1. Governance proposal to reduce miner count passes
2. Consensus contract calls `UpdateMinersCount()`
3. `SyncSubsidyInfoAfterReduceMiner()` executes on all nodes
4. Each node's dictionary iteration order differs
5. Different nodes select different candidates to remove
6. State divergence occurs

**Probability:** High - the data center list can easily have 15-25 candidates (3-5 miners Ã— 5), and having 2-3 candidates with equal votes at the boundary is common in production.

### Recommendation

**Code-Level Mitigation:**
Add a secondary sort key using the candidate's public key (string) to ensure deterministic ordering:

```csharp
var toRemoveList = rankingList.DataCenters
    .OrderBy(x => x.Value)
    .ThenBy(x => x.Key)  // Add secondary sort by pubkey
    .Take(diffCount)
    .ToList();
```

Apply the same fix to the other two locations:

**Line 475 in ElectionContract_Elector.cs:**
```csharp
foreach (var pubkeyToVotesAmount in rankingList.DataCenters
    .OrderBy(x => x.Value)
    .ThenBy(x => x.Key))  // Add secondary sort
```

**Line 741 in ElectionContract_Elector.cs:**
```csharp
var minimumVoteCandidateInDataCenter = list
    .OrderBy(x => x.Value)
    .ThenBy(x => x.Key)  // Add secondary sort
    .First();
```

**Test Cases to Add:**
1. Create 10 data centers with identical vote amounts (e.g., all with 1000 votes)
2. Reduce miner count to trigger removal of 3 data centers
3. Run the same transaction on multiple nodes/test instances
4. Verify all nodes remove the exact same set of candidates (should be the first 3 alphabetically by pubkey)
5. Verify the `DataCentersRankingList` state is identical across all nodes
6. Verify the subsidy beneficiary list matches across all nodes

### Proof of Concept

**Required Initial State:**
- 5 miners (validDataCenterCount = 25)
- 25 data centers in ranking list, where at least 3 have equal vote amounts of 500
  - Candidate A: 500 votes
  - Candidate B: 500 votes  
  - Candidate C: 500 votes
  - Candidates D-Y: varying higher vote amounts

**Transaction Steps:**
1. Governance proposal to reduce miner count from 5 to 4 passes
2. Consensus contract calls `Election.UpdateMinersCount(4)`
3. `SyncSubsidyInfoAfterReduceMiner()` executes:
   - New validDataCenterCount = 20
   - diffCount = 25 - 20 = 5
   - Must remove 5 candidates with lowest votes

**Expected Result (with fix):**
All nodes deterministically remove the same 5 candidates based on:
1. Primary sort: vote amount (ascending)
2. Secondary sort: pubkey (ascending)

**Actual Result (without fix):**
- Node X's dictionary iteration: `[..., A:500, B:500, C:500, ...]`
  - After OrderBy: `[..., A:500, B:500, C:500, ...]`
  - May select A, B, C among the removed candidates
  
- Node Y's dictionary iteration: `[..., C:500, B:500, A:500, ...]`
  - After OrderBy: `[..., C:500, B:500, A:500, ...]`
  - May select C, B, A in different positions among removed candidates

**Success Condition for Bug:**
Different nodes have different `DataCentersRankingList.DataCenters` after the operation, causing state root mismatch and consensus failure.

### Notes

This vulnerability is confirmed by the codebase's own practices - other parts of the consensus code explicitly use secondary sort keys when deterministic ordering is required, demonstrating awareness of dictionary iteration non-determinism. The Election contract failed to apply this pattern consistently in the data center removal logic.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L367-369)
```csharp
        var diffCount = rankingList.DataCenters.Count.Sub(validDataCenterCount);
        var toRemoveList = rankingList.DataCenters.OrderBy(x => x.Value)
            .Take(diffCount).ToList();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L370-374)
```csharp
        foreach (var kv in toRemoveList)
        {
            rankingList.DataCenters.Remove(kv.Key);
            RemoveBeneficiary(kv.Key);
        }
```

**File:** protobuf/election_contract.proto (L460-463)
```text
message DataCenterRankingList {
    // The top n * 5 candidates with vote amount, candidate public key -> vote amount.
    map<string, int64> data_centers = 1;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L475-481)
```csharp
        foreach (var pubkeyToVotesAmount in rankingList.DataCenters.OrderBy(x => x.Value))
            if (pubkeyToVotesAmount.Value < minimumVotes)
            {
                replaceWillHappen = true;
                minimumVotesCandidate = pubkeyToVotesAmount.Key;
                break;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L741-742)
```csharp
        var minimumVoteCandidateInDataCenter = list.OrderBy(x => x.Value).First();
        if (voteAmount <= minimumVoteCandidateInDataCenter.Value) return;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L797-807)
```csharp
    private void RemoveBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var previousSubsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            Beneficiary = beneficiaryAddress,
            ProfitDetailId = previousSubsidyId
        });
    }
```
