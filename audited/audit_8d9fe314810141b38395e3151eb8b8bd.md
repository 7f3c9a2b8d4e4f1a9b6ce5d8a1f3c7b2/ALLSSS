### Title
Inconsistent Comparison Operators Allow Proposals to Pass with Tied Votes at Exact Threshold Boundaries

### Summary
The Parliament contract uses `>=` for approval threshold checks but `>` for rejection/abstention threshold checks, creating a logical inconsistency at exact threshold boundaries. When an organization is configured with `MinimalApprovalThreshold` + `MaximalRejectionThreshold` = `AbstractVoteTotal` (e.g., both at 50%), a proposal receiving exactly 50% approval and 50% rejection will pass, despite having equal support and opposition. This violates governance logic where proposals at the maximum rejection threshold should fail.

### Finding Description

The vulnerability exists in the threshold comparison logic: [1](#0-0) 

The approval check uses `>=` (inclusive), allowing proposals that exactly meet the minimum threshold to pass. [2](#0-1) 

The rejection check uses `>` (strict), requiring rejections to *exceed* the maximum threshold to fail the proposal. [3](#0-2) 

The abstention check also uses `>` (strict), requiring abstentions to *exceed* the maximum threshold.

The validation function allows threshold configurations where the sum equals `AbstractVoteTotal`: [4](#0-3) 

With `AbstractVoteTotal` defined as 10000 (representing 100%): [5](#0-4) 

Parliament members can create organizations with custom thresholds: [6](#0-5) 

### Impact Explanation

**Governance Impact**: Proposals can pass with tied votes (equal approval and rejection), violating the principle that proposals reaching the maximum allowed rejection rate should fail. This allows potentially controversial governance actions to execute despite lacking clear consensus.

**Affected Scenarios**:
- Organizations configured with `MinimalApprovalThreshold = 5000` and `MaximalRejectionThreshold = 5000`
- With 10 parliament members: 5 approvals + 5 rejections → proposal passes
- With any even number of members at 50-50 split → proposal passes

**Severity Justification**: Medium severity because:
1. Requires specific threshold configuration at boundary values
2. Once configured, the issue is deterministic
3. Can affect critical governance decisions (contract upgrades, parameter changes)
4. Violates expected governance semantics

### Likelihood Explanation

**Attacker Capabilities**: Any authorized parliament member or whitelisted proposer can create organizations with custom thresholds.

**Attack Complexity**: Low - simply requires:
1. Creating an organization with boundary thresholds (e.g., both at 5000)
2. Creating a proposal under that organization
3. Obtaining a tied vote naturally or through coordination

**Feasibility Conditions**: 
- The validation logic explicitly allows `MaximalRejectionThreshold + MinimalApprovalThreshold <= AbstractVoteTotal`, permitting boundary configurations
- No additional permissions or exploits required beyond normal parliament operations

**Detection/Operational Constraints**: The issue occurs transparently in normal contract execution and may not be noticed until a controversial tied vote occurs.

**Probability**: Medium-High once boundary threshold configurations exist, as tied votes can occur naturally in divisive governance decisions.

### Recommendation

**Code-Level Mitigation**: Change the comparison operators for rejection and abstention checks from `>` to `>=` to ensure consistency:

In `IsProposalRejected` (line 68), change:
```csharp
return rejectionMemberCount * AbstractVoteTotal >=
       organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
```

In `IsProposalAbstained` (line 76), change:
```csharp
return abstentionMemberCount * AbstractVoteTotal >=
       organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
```

**Invariant Enhancement**: Consider adding validation to prevent configurations where `MinimalApprovalThreshold + MaximalRejectionThreshold = AbstractVoteTotal`, requiring a gap between thresholds:

```csharp
proposalReleaseThreshold.MaximalRejectionThreshold + 
proposalReleaseThreshold.MinimalApprovalThreshold < AbstractVoteTotal
```

**Test Cases**: Add boundary test cases covering:
- Exact 50-50 split with thresholds at 5000
- Verification that tied votes result in rejection
- Edge cases with different parliament member counts

### Proof of Concept

**Required Initial State**:
- Parliament contract deployed with 10 members (or any even number)
- Parliament member account authorized

**Transaction Steps**:
1. Call `CreateOrganization` with:
   - `MinimalApprovalThreshold = 5000` (50%)
   - `MaximalRejectionThreshold = 5000` (50%)
   - `MaximalAbstentionThreshold = 0`
   - `MinimalVoteThreshold = 10000` (100%)

2. Call `CreateProposal` under the newly created organization

3. Have exactly 5 members call `Approve(proposalId)`

4. Have exactly 5 members call `Reject(proposalId)`

5. Call `GetProposal(proposalId)` and observe `ToBeReleased = true`

6. Call `Release(proposalId)` as the proposer

**Expected Result**: Proposal release should fail with "Not approved" error due to tied vote

**Actual Result**: Proposal releases successfully and executes the target transaction, despite having equal approval and rejection votes

**Success Condition**: The proposal passes the release threshold check and executes, demonstrating that tied votes at exact boundaries allow passage when they logically shouldn't.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L72-78)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L50-59)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        Assert(
            ValidateAddressInWhiteList(Context.Sender) || ValidateParliamentMemberAuthority(Context.Sender) ||
            State.DefaultOrganizationAddress.Value == Context.Sender,
            "Unauthorized to create organization.");
        var organizationAddress = CreateNewOrganization(input);

        return organizationAddress;
    }
```
