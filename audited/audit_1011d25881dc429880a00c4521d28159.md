### Title
Null Reference Exception in Round Information Retrieval Methods Causing Consensus DoS

### Summary
The `TryToGetCurrentRoundInformation`, `TryToGetPreviousRoundInformation`, and `TryToGetRoundInformation` methods access the `IsEmpty` property on potentially null `Round` objects without null checking. When `State.Rounds[roundNumber]` is accessed for a non-existent or removed round, it returns `null`, causing a `NullReferenceException` that can crash critical consensus operations and public view methods, leading to blockchain DoS.

### Finding Description

The vulnerability exists in three helper methods that retrieve round information: [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause**: The `MappedState<TKey, TEntity>` indexer returns `SerializationHelper.Deserialize<TEntity>(null)` when a key doesn't exist in state or has been deleted: [4](#0-3) 

For protobuf types like `Round`, the deserializer returns `default(T)` which is `null` for reference types: [5](#0-4) 

Old rounds are actively removed from state to prevent unbounded growth: [6](#0-5) 

**Evidence of Developer Intent**: The codebase contains explicit null checking in `TryToUpdateRoundInformation`, proving developers are aware that `State.Rounds[roundNumber]` can return null: [7](#0-6) 

The missing null checks in the three retrieval methods are inconsistent with this pattern and constitute a bug.

### Impact Explanation

**Critical Consensus Methods Affected**:

1. **Block Production Failure** - `GetConsensusCommand` calls `TryToGetCurrentRoundInformation` and will crash if it throws: [8](#0-7) 

2. **Consensus Validation Failure** - `ValidateBeforeExecution` crashes on exception: [9](#0-8) 

3. **Consensus Processing Failure** - `ProcessConsensusInformation` crashes after processing consensus updates: [10](#0-9) 

**Public Attack Surface**: Anyone can trigger the vulnerability through public view methods: [11](#0-10) 

**Harm**: 
- Blockchain halt: miners cannot produce blocks if `GetConsensusCommand` throws
- Transaction validation failure: blocks cannot be validated if `ValidateBeforeExecution` throws
- Consensus update failure: round transitions fail if `ProcessConsensusInformation` throws
- View method DoS: legitimate queries fail with exceptions

**Affected Parties**: All network participants - validators cannot mine, users cannot query chain state

### Likelihood Explanation

**Attack Complexity**: Trivial

**Exploitation Path #1 - Public View Method**:
1. Attacker identifies current round number (e.g., round 50000)
2. Attacker calls `GetRoundInformation` with round number < (current - 40960), which was removed per the cleanup logic
3. Method calls `TryToGetRoundInformation` with the old round number
4. `State.Rounds[oldRoundNumber]` returns `null`
5. Access to `round.IsEmpty` throws `NullReferenceException`
6. View call fails immediately

**Exploitation Path #2 - Consensus State Inconsistency**:

During `ProcessNextTerm`, the round number is updated before the round information is added: [12](#0-11) 

Between line 174 (round number update) and line 196 (round info added), if any code path calls `TryToGetCurrentRoundInformation`, it will access a non-existent round and throw. This can occur through:
- External contract callbacks during `UpdateMinersCountToElectionContract` (line 176)
- Any reentrant calls during operations on lines 177-195

**Feasibility Conditions**: 
- Path #1: Always possible after 40960 rounds (constant defined in code)
- Path #2: Possible if external contracts make callbacks during consensus updates

**Detection**: Undetectable - appears as legitimate view query or consensus operation [13](#0-12) 

### Recommendation

Add null checks before accessing `IsEmpty` property in all three methods:

```csharp
private bool TryToGetCurrentRoundInformation(out Round round)
{
    round = null;
    if (!TryToGetRoundNumber(out var roundNumber)) return false;
    round = State.Rounds[roundNumber];
    if (round == null) return false;  // ADD THIS CHECK
    return !round.IsEmpty;
}

private bool TryToGetPreviousRoundInformation(out Round previousRound)
{
    previousRound = new Round();
    if (!TryToGetRoundNumber(out var roundNumber)) return false;
    if (roundNumber < 2) return false;
    var targetRoundNumber = roundNumber.Sub(1);
    previousRound = State.Rounds[targetRoundNumber];
    if (previousRound == null) return false;  // ADD THIS CHECK
    return !previousRound.IsEmpty;
}

private bool TryToGetRoundInformation(long roundNumber, out Round round)
{
    round = State.Rounds[roundNumber];
    if (round == null) return false;  // ADD THIS CHECK
    return !round.IsEmpty;
}
```

**Additional Fix for AddRoundInformation**: Add null check before accessing `RoundId`: [14](#0-13) 

Change line 113-114 to:
```csharp
var previousRound = State.Rounds[round.RoundNumber.Sub(1)];
if (previousRound != null)
{
    Context.Fire(new SecretSharingInformation
    {
        CurrentRoundId = round.RoundId,
        PreviousRound = previousRound,
        PreviousRoundId = previousRound.RoundId
    });
}
```

**Test Cases**:
1. Call `GetRoundInformation` with a round number that doesn't exist
2. Call `GetRoundInformation` with a removed old round number
3. Test consensus operations during round transitions with mocked external contract callbacks

### Proof of Concept

**Initial State**:
- Blockchain has progressed past round 50000
- Old rounds (< round 9040) have been removed from state per cleanup logic

**Attack Steps**:

1. Attacker calls public view method `GetRoundInformation` with input `{ Value: 5000 }`
2. Method calls `TryToGetRoundInformation(5000, out var round)`
3. `State.Rounds[5000]` is accessed - round was removed, returns `null`
4. Line 69: `return !round.IsEmpty;` executes
5. Attempting to access `IsEmpty` property on `null` object

**Expected Result**: Method should return `false` and output an empty `Round` object

**Actual Result**: `NullReferenceException` is thrown, transaction/view call fails with error

**Success Condition**: Exception thrown instead of graceful failure, proving DoS vulnerability exists

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L117-124)
```csharp
        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L23-24)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L71-73)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
            Context.LogDebug(() =>
                $"Current round information:\n{currentRound.ToString(_processingBlockMinerPubkey)}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L173-196)
```csharp
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L21-29)
```csharp
    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }

    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
