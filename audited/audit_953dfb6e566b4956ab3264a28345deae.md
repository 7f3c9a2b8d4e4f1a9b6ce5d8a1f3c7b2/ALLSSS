### Title
Missing Round ID Validation Enables Signature Reuse Attack in Consensus UpdateValue

### Summary
The `ProcessUpdateValue` function accepts signatures from `UpdateValueInput` without validating that the provided `round_id` matches the current round. Although the `round_id` field is explicitly documented as ensuring values apply to the correct round, no comparison is performed. This allows miners to replay valid signatures from previous rounds to forge consensus participation and manipulate mining order for subsequent rounds.

### Finding Description
The vulnerability exists across multiple code locations:

**Signature Copy Without Round Binding:**
The signature is copied in `GetUpdateValueRound()` without any round-specific binding. [1](#0-0) 

**Signature Calculation Lacks Round Information:**
The `CalculateSignature` method only XORs the inValue with previous signatures, containing no round number or round ID. [2](#0-1) 

**Missing Round ID Validation in ProcessUpdateValue:**
The `ProcessUpdateValue` method directly assigns the signature from `UpdateValueInput` without any validation that `updateValueInput.RoundId` matches the current round's `RoundId`. [3](#0-2) 

**Unused Round ID Field:**
The `UpdateValueInput` protobuf message includes a `round_id` field explicitly documented as "To ensure the values to update will be apply to correct round by comparing round id", but this comparison never occurs. [4](#0-3) 

**Insufficient Validation:**
The `UpdateValueValidationProvider` only checks that signature and outValue are non-null/non-empty, but does not validate the signature belongs to the current round. [5](#0-4) 

**Public Entry Point:**
The `UpdateValue` method is publicly accessible and delegates to `ProcessConsensusInformation` without round validation. [6](#0-5) 

### Impact Explanation
**Consensus Integrity Violation:** An attacker who is a valid miner can replay signatures from previous rounds to forge consensus participation in the current round. Since the signature value determines the `SupposedOrderOfNextRound` through modulus operation, replaying favorable signatures allows manipulation of mining order. [7](#0-6) 

**Mining Order Manipulation:** The signature directly influences the miner's position in the next round, allowing an attacker to repeatedly use a signature that gives them an advantageous mining slot.

**Random Number Generation Impact:** Signatures contribute to the consensus random number generation system, and replayed signatures can compromise this randomness.

**Severity:** Critical - This violates the fundamental consensus invariant that each round must have unique, fresh consensus data that cannot be replayed from previous rounds.

### Likelihood Explanation
**Reachable Entry Point:** Any authorized miner can call the public `UpdateValue` method with crafted `UpdateValueInput`.

**Feasible Preconditions:** Attacker must be in the current miner list (legitimate miner), and must have previously produced a block with a valid signature in a past round.

**Execution Practicality:** Attack is straightforward:
1. Miner participates normally in round N, generating valid signature_N
2. In round N+1 or later, miner submits UpdateValueInput with signature_N and round_id from round N+1
3. No validation prevents this - the signature is accepted and applied

**Detection Constraints:** The attack is difficult to detect since replayed signatures are cryptographically valid and the miner is authorized. Block validation checks time slots and mining permissions but not signature freshness.

**Economic Rationality:** Cost is minimal (standard transaction fees). Benefit is significant (favorable mining position, potential reward advantages).

**Probability:** High - The vulnerability exists in production code, requires no special conditions beyond being a miner, and has clear exploitation path.

### Recommendation
**Add Round ID Validation in ProcessUpdateValue:**
Add the following check at the start of `ProcessUpdateValue`:
```csharp
Assert(currentRound.RoundId == updateValueInput.RoundId, 
    "Round ID mismatch - signature replay detected.");
```

**Alternative: Include Round ID in Signature Calculation:**
Modify `CalculateSignature` to include round ID in the signature computation:
```csharp
public Hash CalculateSignature(Hash inValue)
{
    var roundIdHash = HashHelper.ComputeFrom(RoundId);
    return HashHelper.XorAndCompute(HashHelper.XorAndCompute(inValue, roundIdHash),
        RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
            (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
}
```

**Invariant Check to Add:**
- Before applying any UpdateValueInput, assert that `input.RoundId == currentRound.RoundId`
- Add similar validation for `TinyBlockInput.RoundId`

**Test Cases:**
1. Test that UpdateValue with mismatched round_id is rejected
2. Test that replaying a valid UpdateValueInput from previous round fails
3. Test that signature from round N cannot be used in round N+1

### Proof of Concept
**Initial State:**
- Blockchain running with AEDPoS consensus
- Attacker is a valid miner in the current miner list
- System is in round N

**Attack Steps:**
1. Attacker produces a block in round N using legitimate UpdateValue
2. Attacker captures the valid signature_N from their UpdateValueInput_N
3. System transitions to round N+1
4. Attacker crafts malicious UpdateValueInput_replay:
   - Signature = signature_N (from previous round)
   - RoundId = round N+1 (current round)
   - Other fields updated for current round
5. Attacker calls `UpdateValue(UpdateValueInput_replay)`
6. `ProcessUpdateValue` executes without checking round_id match
7. Old signature_N is applied to round N+1 state

**Expected Result (Secure System):**
Transaction should fail with "Round ID mismatch" error

**Actual Result (Vulnerable System):**
Transaction succeeds, signature_N is applied to round N+1, attacker's mining order for round N+2 is determined by replayed signature

**Success Condition:**
Check `currentRound.RealTimeMinersInformation[attackerPubkey].Signature` equals signature_N (the replayed signature from previous round) after the attack transaction completes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L24-24)
```csharp
                    Signature = minerInRound.Signature,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L22-33)
```csharp
    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
