### Title
Share Inflation via Negative Amount in RemoveBeneficiary Function

### Summary
The `RemoveBeneficiary` function in TokenHolderContract lacks validation for negative `input.Amount` values. When a negative amount is provided, the subtraction operation `lockedAmount.Sub(input.Amount)` becomes addition, allowing scheme managers to arbitrarily inflate beneficiary shares without locking corresponding tokens, leading to theft of profit distributions from legitimate participants.

### Finding Description

The vulnerability exists in the `RemoveBeneficiary` function where `input.Amount` is used in arithmetic operations without validating it is positive. [1](#0-0) 

At line 85, the condition checks `lockedAmount > input.Amount && input.Amount != 0`, which passes when `input.Amount` is negative (e.g., 1000 > -100 = true). At line 93, the calculation `lockedAmount.Sub(input.Amount)` with a negative input becomes addition: `1000 - (-100) = 1100`, inflating shares instead of reducing them.

The protocol specification explicitly documents that amount should be positive: [2](#0-1) 

The downstream `Profit.AddBeneficiary` validation only checks `shares >= 0`, which does not catch this issue since the inflated value is positive: [3](#0-2) 

Other functions like `ContributeProfits` in both TokenHolder and Profit contracts properly validate positive amounts: [4](#0-3) [5](#0-4) 

### Impact Explanation

**Direct Fund Impact - Dividend Theft:**
- Any user can create a TokenHolder scheme via `CreateScheme`, becoming the manager [6](#0-5) 

- Manager can add themselves as beneficiary with minimal shares (e.g., 100 shares)
- Manager calls `RemoveBeneficiary` on themselves with `amount = -9900`
- Result: shares increase from 100 to 10,000 without locking tokens
- When legitimate users lock 1000 tokens each via `RegisterForProfits`, they get proportional shares [7](#0-6) 

- Profit distribution becomes: Manager receives 10,000/(10,000+users' shares) instead of 100/(100+users' shares)
- Example: With 1000 total user shares and 1100 ELF profits:
  - **Expected**: Manager gets ~9 ELF (100/1100), Users get ~991 ELF
  - **Actual**: Manager gets ~1000 ELF (10000/11000), Users get ~100 ELF
  - **Impact**: Manager steals ~991 ELF from legitimate participants

### Likelihood Explanation

**Highly Practical Attack:**
- **Attacker Capabilities**: Any user can create a scheme and become manager with no special privileges required
- **Attack Complexity**: Trivial - single function call with negative integer parameter
- **Preconditions**: None beyond creating a scheme and waiting for users to register
- **Detection**: Difficult to detect before exploitation since shares are stored in Profit contract
- **Economic Cost**: Zero cost to execute, pure profit from stolen dividends
- **Execution Steps**: 
  1. Call `CreateScheme` (become manager)
  2. Call `AddBeneficiary` for self with small shares
  3. Wait for users to call `RegisterForProfits` and lock tokens
  4. Call `RemoveBeneficiary` with negative amount to inflate shares
  5. Collect disproportionate profits during distribution

No test coverage exists for negative amount validation: [8](#0-7) 

### Recommendation

Add explicit validation for positive amounts at the start of `RemoveBeneficiary`:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    Assert(input.Amount >= 0, "Amount cannot be negative.");
    var scheme = GetValidScheme(Context.Sender);
    // ... rest of function
```

Additionally, update line 85 to explicitly check for positive amounts:
```csharp
if (lockedAmount > input.Amount && input.Amount > 0)
```

**Test Cases to Add:**
1. Test that `RemoveBeneficiary` with negative amount reverts with "Amount cannot be negative."
2. Test that arithmetic with edge values (Int64.MinValue) is handled correctly
3. Integration test verifying shares cannot be inflated through any input combination

### Proof of Concept

**Initial State:**
- Manager creates scheme for token "ELF"
- Manager adds self as beneficiary with 100 shares
- User A calls `RegisterForProfits` locking 1000 ELF → gets 1000 shares
- Total shares: 1100
- Someone contributes 1100 ELF profit

**Exploitation:**
```
1. Manager calls RemoveBeneficiary:
   - input.Beneficiary = Manager's address
   - input.Amount = -9900

2. Function executes:
   - lockedAmount = 100 (current shares)
   - Check: 100 > -9900 && -9900 != 0 → TRUE
   - Calculate: 100.Sub(-9900) = 100 - (-9900) = 10000
   - Manager's new shares: 10000

3. Total shares now: 11000 (10000 manager + 1000 user)

4. Profit Distribution:
   - Manager receives: (10000/11000) * 1100 = 1000 ELF
   - User A receives: (1000/11000) * 1100 = 100 ELF
```

**Expected vs Actual:**
- **Expected**: Manager: 100 ELF, User A: 1000 ELF (proportional to locked tokens)
- **Actual**: Manager: 1000 ELF, User A: 100 ELF (Manager stole 900 ELF)

**Success Condition**: Query `GetProfitDetails` shows Manager with 10,000 shares despite only contributing 100 initially.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** protobuf/token_holder_contract.proto (L27-30)
```text
    // Removes a beneficiary from a scheme.
    // Note: amount > 0: update the weight of the beneficiary, amount = 0: remove the beneficiary.
    rpc RemoveBeneficiary (RemoveTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L657-660)
```csharp
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L156-196)
```csharp
    public async Task RemoveBeneficiary_With_Amount_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF"
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 1000
        });
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds[0];
        var beforeRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var amount = 10;
        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = amount
        });
        var afterRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeIds.SchemeIds[0]);
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
