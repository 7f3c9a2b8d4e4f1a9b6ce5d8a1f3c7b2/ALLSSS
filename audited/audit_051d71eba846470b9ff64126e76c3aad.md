# Audit Report

## Title
Replacement Miner Can Manipulate Mining Order Through Unvalidated PreviousInValue

## Summary
When a replacement miner (not present in the previous round) produces a block, they can provide an arbitrary `PreviousInValue` that bypasses validation and directly influences their mining order in the next round. This allows attackers to choose favorable mining positions offline, gaining unfair advantages over honest miners.

## Finding Description

The AEDPoS consensus contract fails to validate the `PreviousInValue` provided by replacement miners, enabling mining order manipulation.

**Root Cause:**

When a miner not present in the previous round provides consensus data, the contract's validation and processing logic creates an exploitable path:

1. In `GetConsensusExtraDataToPublishOutValue`, when `triggerInformation.PreviousInValue` is provided (non-null, non-empty), the code checks if the miner existed in the previous round. [1](#0-0) 

2. For replacement miners (not in previous round), the check at line 80 fails due to short-circuit evaluation, causing execution to fall through to the else block where the attacker-provided value is accepted without validation. [2](#0-1) 

3. The validation provider explicitly bypasses validation for non-existent miners, returning `true` immediately. [3](#0-2) 

**Impact Chain:**

The manipulated `PreviousInValue` is used to calculate the signature via XOR with all previous round signatures. [4](#0-3) 

This signature directly determines the miner's position in the next round through modular arithmetic. [5](#0-4) 

The `FinalOrderOfNextRound` value becomes the actual mining `Order` when the next round is generated. [6](#0-5) 

## Impact Explanation

This vulnerability breaks consensus fairness by allowing mining order manipulation:

1. **MEV Opportunities**: Position 1 miners see and order transactions first, enabling front-running and sandwich attacks
2. **Unfair Competition**: Attackers gain systematic advantages over honest miners who use legitimate deterministic values
3. **Consensus Predictability**: Mining order should be deterministically derived, not chosen by individual miners

The severity is HIGH because it violates core consensus invariants. While it doesn't directly steal funds or break chain liveness, it fundamentally undermines the fairness guarantees that honest participants rely upon. In blockchain systems, mining order determines economic opportunities, and allowing manipulation creates systematic advantages that compound over time.

## Likelihood Explanation

**Preconditions** (highly realistic):
- Replacement miners occur regularly through automatic evil miner detection or manual replacement via `ReplaceCandidatePubkey`
- No special permissions required beyond being a valid replacement miner

**Attack Complexity** (LOW):
1. Offline: Compute signatures for candidate `PreviousInValue` values
2. Select the value yielding the desired order (e.g., position 1)
3. Modify node software to inject chosen value into trigger information
4. Produce block normally - contract accepts without validation

**Detection Difficulty**: Very high - the manipulated value appears as legitimate consensus data with no baseline to compare against since the miner wasn't in the previous round.

**Economic Rationality**: Cost is negligible (hash computations), while benefits are significant (optimal mining position, MEV opportunities, timing control).

## Recommendation

Add validation for replacement miners' `PreviousInValue`:

```csharp
// In GetConsensusExtraDataToPublishOutValue, replace lines 74-93:
if (triggerInformation.PreviousInValue != null &&
    triggerInformation.PreviousInValue != Hash.Empty)
{
    if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // Existing miner - validate against previous OutValue
        if (HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
            previousRound.RealTimeMinersInformation[pubkey].OutValue)
        {
            Context.LogDebug(() => "Failed to produce block at previous round?");
            previousInValue = Hash.Empty;
        }
        else
        {
            previousInValue = triggerInformation.PreviousInValue;
        }
        signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
    }
    else
    {
        // Replacement miner - MUST use deterministic value, reject provided value
        var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
        previousInValue = Hash.Empty;
        signature = previousRound.CalculateSignature(fakePreviousInValue);
    }
}
```

The fix ensures replacement miners cannot provide arbitrary values, instead forcing them to use the same deterministic calculation that honest nodes use.

## Proof of Concept

```csharp
// Test demonstrating mining order manipulation by replacement miner
[Fact]
public async Task ReplacementMiner_CanManipulateMiningOrder()
{
    // Setup: Create initial round with 5 miners
    var initialMiners = GenerateInitialMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Round 1: All miners produce blocks normally
    await ProduceNormalRound();
    
    // Round 2: Miner at position 3 becomes evil (misses slots)
    var evilMiner = initialMiners[2];
    await SimulateEvilMinerBehavior(evilMiner);
    
    // Replacement miner joins in round 3
    var replacementMiner = GenerateNewMiner();
    await ReplaceEvilMiner(evilMiner, replacementMiner);
    
    // Attack: Replacement miner computes optimal PreviousInValue for position 1
    var currentRound = await GetCurrentRound();
    var previousRound = await GetPreviousRound();
    
    var optimalPreviousInValue = ComputeOptimalPreviousInValue(
        replacementMiner,
        previousRound,
        targetOrder: 1  // Attacker wants position 1 in next round
    );
    
    // Produce block with manipulated PreviousInValue
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(replacementMiner.PublicKey),
        InValue = GenerateRandomHash(),
        PreviousInValue = optimalPreviousInValue,  // Manipulated value
        Behaviour = AElfConsensusBehaviour.UpdateValue
    };
    
    var extraData = await ConsensusContract.GetConsensusBlockExtraData(
        triggerInfo.ToBytesValue()
    );
    
    // Verify: Replacement miner gets position 1 in next round
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(extraData.Value);
    var minerInRound = headerInfo.Round.RealTimeMinersInformation[replacementMiner.PublicKey.ToHex()];
    
    Assert.Equal(1, minerInRound.FinalOrderOfNextRound);
    
    // Generate next round and confirm manipulation persists
    await ProduceNextRound();
    var nextRound = await GetCurrentRound();
    var actualOrder = nextRound.RealTimeMinersInformation[replacementMiner.PublicKey.ToHex()].Order;
    
    Assert.Equal(1, actualOrder);  // Attacker successfully manipulated order
}

private Hash ComputeOptimalPreviousInValue(Miner miner, Round previousRound, int targetOrder)
{
    var minersCount = previousRound.RealTimeMinersInformation.Count;
    
    // Brute force search for PreviousInValue yielding target order
    for (int i = 0; i < 10000; i++)
    {
        var candidateValue = HashHelper.ComputeFrom($"{miner.PublicKey}{i}");
        var signature = previousRound.CalculateSignature(candidateValue);
        var order = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
        
        if (order == targetOrder)
            return candidateValue;
    }
    
    throw new Exception("Failed to find optimal value");
}
```

**Notes**

The vulnerability specifically affects the code path when replacement miners provide a `PreviousInValue`. Honest replacement miners who don't provide this field (letting it be null/empty) will use the deterministic calculation and are not affected. The attack requires miners to modify their node software to inject arbitrary values, which is within the standard threat model for blockchain consensus systems where participants may act adversarially to gain economic advantages.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-92)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L40-40)
```csharp
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
