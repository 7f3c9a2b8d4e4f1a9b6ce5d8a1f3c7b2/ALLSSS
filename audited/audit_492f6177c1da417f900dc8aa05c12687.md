# Audit Report

## Title
Token Supply State Inconsistency After Burn Operations Causes Cross-Chain Transfer DoS

## Summary
The `Burn()` method in the MultiToken contract modifies the local `tokenInfo.Supply` field but fails to persist this change to `State.TokenInfos` by not calling `SetTokenInfo()`. This causes subsequent `GetTokenInfo()` calls to return stale Supply values, leading to incorrect "Total supply exceeded" failures in `CrossChainReceiveToken()` that block legitimate cross-chain token receives after any burn operations.

## Finding Description

The vulnerability exists in the `Burn()` method implementation. The method retrieves `tokenInfo` via `AssertValidToken()`, decrements the local `Supply` field, but critically never calls `SetTokenInfo()` to persist this change back to `State.TokenInfos`. [1](#0-0) 

The `AssertValidToken()` helper retrieves token information from state storage using `GetTokenInfo()`: [2](#0-1) 

The `GetTokenInfo()` method reads directly from `State.TokenInfos`, which stores serialized protobuf messages: [3](#0-2) 

Since protobuf messages in AElf smart contracts are deserialized into new object instances when read from `MappedState`, modifying the local `tokenInfo` object does not automatically persist back to state. The `SetTokenInfo()` helper must be explicitly called to serialize and store the updated object: [4](#0-3) 

This contrasts sharply with the correct implementation in `Issue()`, which properly calls `SetTokenInfo()` after modifying Supply: [5](#0-4) 

Similarly, `CrossChainReceiveToken()` correctly persists Supply updates by calling `SetTokenInfo()`: [6](#0-5) 

The critical impact occurs because `CrossChainReceiveToken()` performs a supply limit check that relies on accurate Supply data from state. After burn operations, it retrieves the stale (non-decremented) Supply value and incorrectly rejects legitimate cross-chain receives.

## Impact Explanation

**Direct Operational Impact - Cross-Chain Transfer DoS:**

After any burn operation, the `CrossChainReceiveToken()` function will incorrectly fail with "Total supply exceeded" error even when the actual circulating supply is well below the limit.

**Concrete Attack Scenario:**
1. Token has `TotalSupply = 1000`, `Supply = 1000` (all tokens issued)
2. User burns 500 tokens via `Burn()` - local supply becomes 500 but state remains 1000
3. User attempts `CrossChainReceiveToken(100)` from another chain
4. `GetTokenInfo()` returns stale `Supply = 1000` from state
5. Check evaluates: `1000 + 100 <= 1000` → **FAILS** with "Total supply exceeded"
6. Should evaluate: `500 + 100 <= 1000` → **PASSES**

**Affected Operations:**
- All cross-chain token receives after any burn operations
- `GetTokenInfo()` view method returns incorrect circulating supply
- Any external contracts or services relying on accurate Supply data

**Severity:** This is a **Medium severity** issue causing operational DoS of the cross-chain transfer functionality, a core protocol feature. While no direct fund loss occurs, it blocks legitimate user operations and disrupts cross-chain interoperability. The issue persists indefinitely until additional tokens are issued (which would accidentally sync the state via `SetTokenInfo()` in `Issue()`).

## Likelihood Explanation

**Attacker Capabilities:** Any user with burnable tokens can trigger this issue simply by calling the public `Burn()` method. No special privileges required. [7](#0-6) 

**Attack Complexity:** Trivial - just burn tokens and attempt cross-chain receive.

**Preconditions:**
- Token must have `IsBurnable = true` (common for many tokens)
- User must have token balance to burn (normal operation)
- Cross-chain functionality must be in use (core AElf feature)

**Execution Steps:**
1. Call `Burn()` with any amount
2. Attempt `CrossChainReceiveToken()`  
3. Observe incorrect "Total supply exceeded" failure

**Detection Evidence:** The existing test suite expects `Supply = 0` after burning, which would fail with current implementation: [8](#0-7) 

**Probability:** High - affects all burnable tokens with cross-chain functionality enabled. Any production deployment with these features would encounter this bug immediately upon the first burn operation.

## Recommendation

Add a `SetTokenInfo(tokenInfo)` call in the `Burn()` method after modifying the Supply field to persist the change to state storage, matching the pattern used in `Issue()` and `CrossChainReceiveToken()`.

**Fixed Code:**
```csharp
private Empty Burn(Address address, string symbol, long amount)
{
    var tokenInfo = AssertValidToken(symbol, amount);
    Assert(tokenInfo.IsBurnable, "The token is not burnable.");
    ModifyBalance(address, symbol, -amount);
    tokenInfo.Supply = tokenInfo.Supply.Sub(amount);
    SetTokenInfo(tokenInfo); // ADD THIS LINE

    Context.Fire(new Burned
    {
        Burner = address,
        Symbol = symbol,
        Amount = amount
    });
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task Burn_DoesNotPersistSupply_BlocksCrossChainReceive()
{
    // Setup: Create token with total supply 1000
    var symbol = "TEST";
    await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = symbol,
        TokenName = "Test Token",
        TotalSupply = 1000,
        Decimals = 0,
        Issuer = DefaultAddress,
        IsBurnable = true
    });
    
    // Issue all tokens
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = symbol,
        Amount = 1000,
        To = DefaultAddress
    });
    
    // Verify Supply = 1000
    var tokenInfo1 = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = symbol });
    tokenInfo1.Supply.ShouldBe(1000);
    
    // Burn 500 tokens
    await TokenContractStub.Burn.SendAsync(new BurnInput
    {
        Symbol = symbol,
        Amount = 500
    });
    
    // BUG: Supply should be 500 but state still shows 1000
    var tokenInfo2 = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = symbol });
    tokenInfo2.Supply.ShouldBe(500); // FAILS - returns 1000 instead
    
    // IMPACT: CrossChainReceiveToken now incorrectly fails
    // because it checks: 1000 + 100 <= 1000 instead of 500 + 100 <= 1000
}
```

**Notes:**

This vulnerability demonstrates a critical state persistence bug in the MultiToken contract. The `Burn()` method's failure to call `SetTokenInfo()` breaks the protocol invariant that the `Supply` field must accurately reflect the circulating token supply. This has immediate operational impact on cross-chain transfers, which are a fundamental feature of the AElf ecosystem.

The bug is particularly insidious because it only manifests when burn and cross-chain operations are both used, which may not be caught by unit tests that focus on individual operations in isolation. The cited test case at line 626 of `NftApplicationTests.cs` explicitly expects the Supply to be updated after burning, confirming that this is the intended behavior that the current implementation fails to achieve.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L154-178)
```csharp
    public override Empty Issue(IssueInput input)
    {
        Assert(input.To != null, "To address not filled.");
        AssertValidMemo(input.Memo);
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Unable to issue token with wrong chainId.");
        Assert(tokenInfo.Issuer == Context.Sender || Context.Sender == Context.GetZeroSmartContractAddress(),
            $"Sender is not allowed to issue token {input.Symbol}.");

        tokenInfo.Issued = tokenInfo.Issued.Add(input.Amount);
        tokenInfo.Supply = tokenInfo.Supply.Add(input.Amount);

        Assert(tokenInfo.Issued <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(input.To, input.Symbol, input.Amount);

        Context.Fire(new Issued
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = input.To,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L318-321)
```csharp
    public override Empty Burn(BurnInput input)
    {
        return Burn(Context.Sender, input.Symbol, input.Amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L323-337)
```csharp
    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L591-638)
```csharp
    public override Empty CrossChainReceiveToken(CrossChainReceiveTokenInput input)
    {
        var transferTransaction = Transaction.Parser.ParseFrom(input.TransferTransactionBytes);
        var transferTransactionId = transferTransaction.GetHash();

        Assert(!State.VerifiedCrossChainTransferTransaction[transferTransactionId],
            "Token already claimed.");

        var crossChainTransferInput =
            CrossChainTransferInput.Parser.ParseFrom(transferTransaction.Params.ToByteArray());
        var symbol = crossChainTransferInput.Symbol;
        var amount = crossChainTransferInput.Amount;
        var receivingAddress = crossChainTransferInput.To;
        var targetChainId = crossChainTransferInput.ToChainId;
        var transferSender = transferTransaction.From;

        var tokenInfo = AssertValidToken(symbol, amount);
        var issueChainId = GetIssueChainId(tokenInfo.Symbol);
        Assert(issueChainId == crossChainTransferInput.IssueChainId, "Incorrect issue chain id.");
        Assert(targetChainId == Context.ChainId, "Unable to claim cross chain token.");
        var registeredTokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        AssertCrossChainTransaction(transferTransaction, registeredTokenContractAddress,
            nameof(CrossChainTransfer));
        Context.LogDebug(() =>
            $"symbol == {tokenInfo.Symbol}, amount == {amount}, receivingAddress == {receivingAddress}, targetChainId == {targetChainId}");

        CrossChainVerify(transferTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);

        State.VerifiedCrossChainTransferTransaction[transferTransactionId] = true;
        tokenInfo.Supply = tokenInfo.Supply.Add(amount);
        Assert(tokenInfo.Supply <= tokenInfo.TotalSupply, "Total supply exceeded");
        SetTokenInfo(tokenInfo);
        ModifyBalance(receivingAddress, tokenInfo.Symbol, amount);

        Context.Fire(new CrossChainReceived
        {
            From = transferSender,
            To = receivingAddress,
            Symbol = tokenInfo.Symbol,
            Amount = amount,
            Memo = crossChainTransferInput.Memo,
            FromChainId = input.FromChainId,
            ParentChainHeight = input.ParentChainHeight,
            IssueChainId = issueChainId,
            TransferTransactionId = transferTransactionId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L418-422)
```csharp
    private void SetTokenInfo(TokenInfo tokenInfo)
    {
        var symbol = tokenInfo.Symbol;
        State.TokenInfos[symbol] = tokenInfo;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/NftApplicationTests.cs (L601-652)
```csharp
    [Fact(DisplayName = "[MultiToken_Nft] 721 nfts Burn Test")]
    public async Task NftIssueAndTransferBurn()
    {
        var symbols = await CreateNftCollectionAndNft(false);
        Assert.True(symbols.Count == 3);
        var symbol = symbols[1];
        var issueRes = await TokenContractStub.Issue.SendAsync(new IssueInput()
        {
            Symbol = symbol,
            Amount = 1,
            To = DefaultAddress,
            Memo = "Issue Nft"
        });
        issueRes.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var res = await TokenContractStub.Burn.SendAsync(new BurnInput
        {
            Amount = 1,
            Symbol = symbol
        });
        res.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput { Symbol = symbols[1] });
        tokenInfo.Issued.ShouldBe(1);
        tokenInfo.TotalSupply.ShouldBe(1);
        tokenInfo.Supply.ShouldBe(0);

        var balance = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultAddress,
            Symbol = symbol
        });
        balance.Balance.ShouldBe(0);

        var result = (await TokenContractStub.Burn.SendWithExceptionAsync(new BurnInput
        {
            Symbol = symbol,
            Amount = 1
        })).TransactionResult;
        result.Status.ShouldBe(TransactionResultStatus.Failed);
        result.Error.ShouldContain("Insufficient balance");

        issueRes = await TokenContractStub.Issue.SendWithExceptionAsync(new IssueInput()
        {
            Symbol = symbol,
            Amount = 1,
            To = DefaultAddress,
            Memo = "Issue Nft"
        });
        issueRes.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
        issueRes.TransactionResult.Error.ShouldContain("Total supply exceeded");
    }
```
