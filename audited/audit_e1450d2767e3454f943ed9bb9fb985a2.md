# Audit Report

## Title
Token Hash Collision Vulnerability Allows NFT Metadata Corruption and Balance Pool Sharing

## Summary
The `CalculateTokenHash()` function concatenates symbol and tokenId strings without a delimiter, enabling cryptographic hash collisions between different (Symbol, TokenId) combinations. As the NFT protocol system scales and generates symbols with increasing digit lengths (9, 10, 11+), distinct (Symbol, TokenId) pairs can produce identical hash values. When protocols have `IsTokenIdReuse=true`, the collision protection check is bypassed, allowing multiple NFTs to share the same storage keys. This corrupts NFT metadata through `State.NftInfoMap[tokenHash]`, creates shared balance pools via `State.BalanceMap[tokenHash]`, and violates NFT uniqueness guarantees.

## Finding Description

**Root Cause - Delimiter-Free Concatenation:**

The hash calculation function performs simple string concatenation without any delimiter or structured encoding: [1](#0-0) 

This creates deterministic collision potential. NFT protocol symbols follow the format of a 2-character type prefix concatenated with an N-digit random number, where N starts at 9 and increases over time: [2](#0-1) [3](#0-2) 

**Collision Example:**
- Symbol="VW100000000" (11 chars: 2-char prefix + 9-digit number), TokenId=123 → "VW100000000123"  
- Symbol="VW1000000001" (12 chars: 2-char prefix + 10-digit number), TokenId=23 → "VW1000000001" + "23" = "VW100000000123"  

Both concatenations produce the identical string "VW100000000123" before hashing, resulting in the same `tokenHash`.

**Insufficient Protection - IsTokenIdReuse Bypass:**

The minting function attempts to prevent duplicate tokenHashes, but this check is bypassed when `IsTokenIdReuse=true`: [4](#0-3) 

When the check is bypassed (IsTokenIdReuse=true AND isTokenIdMustBeUnique=false), the code enters the collision path where it modifies the existing NFTInfo without updating Symbol or TokenId fields: [5](#0-4) 

The NFTInfo retains the Symbol and TokenId from whichever (Symbol, TokenId) pair was minted first, but both colliding pairs access the same storage.

**Exploitation Path - Unvalidated Transfer:**

The Transfer function calculates tokenHash directly from user-provided (symbol, tokenId) without validating that this pair corresponds to an actual existing NFT or matches the stored NFTInfo: [6](#0-5) 

The underlying DoTransfer only checks balance sufficiency, not NFT existence or (symbol, tokenId) pair validity: [7](#0-6) 

This means both colliding (Symbol, TokenId) pairs can be used interchangeably in Transfer, Approve, TransferFrom, and Burn operations, all operating on the shared storage.

## Impact Explanation

**Critical Protocol Invariant Violations:**

1. **NFT Metadata Corruption**: When colliding NFTs are minted with IsTokenIdReuse=true, they share `State.NftInfoMap[tokenHash]`. The second mint updates only Quantity and Minters fields, leaving Symbol/TokenId from the first mint. Queries for (Symbol2, TokenId2) return metadata labeled with (Symbol1, TokenId1), breaking semantic correctness.

2. **Balance Pool Sharing**: Multiple semantically distinct NFTs access the same `State.BalanceMap[tokenHash]` storage. Transferring NFT (Symbol1, TokenId1) modifies the same balance pool as NFT (Symbol2, TokenId2), violating the isolation guarantee that each unique NFT has independent balances.

3. **Broken NFT Uniqueness**: The fundamental protocol guarantee that each (Symbol, TokenId) pair uniquely identifies one NFT is violated. Two different (Symbol, TokenId) combinations become aliases for the same on-chain entity.

4. **Audit Trail Confusion**: Transfer events emit the user-provided (symbol, tokenId) pair, but the actual balance changes occur on the shared tokenHash. An observer sees transfers of NFT (Symbol2, TokenId2) but the balance changes actually belong to NFT (Symbol1, TokenId1)'s metadata record.

5. **Allowance/Approval Corruption**: Approvals are stored in `State.AllowanceMap[tokenHash]`. Approving a spender for (Symbol1, TokenId1) automatically grants approval for (Symbol2, TokenId2) since they share storage: [8](#0-7) 

**Affected Parties:**
- NFT owners whose tokens have colliding hashes experience metadata confusion and unintended balance pool sharing
- NFT marketplaces that rely on (Symbol, TokenId) uniqueness for inventory tracking
- Off-chain indexers and explorers that track NFT ownership and metadata
- dApps building on top of the NFT contract that assume each (Symbol, TokenId) is unique

## Likelihood Explanation

**Attacker Capabilities:**

Anyone can create NFT protocols on the mainchain with arbitrary `IsTokenIdReuse` settings: [9](#0-8) 

**Feasibility Conditions:**

1. **Natural Collision Emergence**: As the protocol scales, the symbol number length increases dynamically from 9 to 10, 11+ digits: [10](#0-9) 

Once both 9-digit and 10-digit symbols coexist in the system, collision pairs naturally exist. For example, any existing Symbol="VW100000000" can collide with a future Symbol="VW1000000001" given appropriate TokenId values.

2. **IsTokenIdReuse Feature**: Legitimate protocols may enable this flag for ERC-1155-style fungible NFTs: [11](#0-10) 

3. **No Input Validation**: All NFT operations (Transfer, Approve, Burn) accept arbitrary (symbol, tokenId) pairs without verifying they match the stored NFTInfo's fields, enabling exploitation once a collision exists.

**Probability Assessment:**
- **High Likelihood**: Collisions become mathematically inevitable as the system scales from 9-digit to 10-digit symbols
- **Deterministic Exploitation**: Once a collision exists, any authorized minter can exploit it
- **Low Detection**: The collision is embedded in the hash function design, not visible in transaction data
- **Economic Feasibility**: Creating protocols is low-cost; searching for collision candidates can be done offline

## Recommendation

**Fix: Use Structured Hashing with Delimiter or Separate Hash Components**

Replace the delimiter-free concatenation with one of these approaches:

**Option 1 - Delimiter-based:**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}|{tokenId}");
}
```

**Option 2 - Separate hash concatenation (preferred):**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(symbol),
        HashHelper.ComputeFrom(tokenId)
    );
}
```

**Option 3 - Protobuf serialization:**
```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    var input = new CalculateTokenHashInput 
    { 
        Symbol = symbol, 
        TokenId = tokenId 
    };
    return HashHelper.ComputeFrom(input);
}
```

All three approaches eliminate the collision by ensuring different (Symbol, TokenId) pairs cannot produce the same pre-hash string.

**Additional Hardening:**

Add validation in Transfer and other operations to verify that user-provided (symbol, tokenId) matches the stored NFTInfo:

```csharp
public override Empty Transfer(TransferInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    var nftInfo = State.NftInfoMap[tokenHash];
    Assert(nftInfo != null && nftInfo.Symbol == input.Symbol && nftInfo.TokenId == input.TokenId, 
        "Invalid NFT: symbol/tokenId mismatch");
    DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
    // ... rest of method
}
```

## Proof of Concept

```csharp
[Fact]
public async Task TestTokenHashCollision()
{
    // Setup: Issue ELF for gas
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 1_00000000_00000000,
        To = DefaultAddress
    });

    // Step 1: Simulate system state where 9-digit symbols exist
    // Create Protocol 1 with symbol ending in 9 digits (e.g., "VW100000000")
    var protocol1Result = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        NftType = NFTType.VirtualWorlds.ToString(),
        ProtocolName = "Protocol1",
        TotalSupply = 1000000,
        IsTokenIdReuse = false
    });
    var symbol1 = protocol1Result.Output.Value; // e.g., "VW100000000"

    // Mint NFT with TokenId=123
    await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol1,
        TokenId = 123,
        Owner = DefaultAddress
    });

    // Step 2: Simulate system scaling to 10-digit symbols
    // Create Protocol 2 with IsTokenIdReuse=true
    var protocol2Result = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        NftType = NFTType.VirtualWorlds.ToString(),
        ProtocolName = "Protocol2",
        TotalSupply = 1000000,
        IsTokenIdReuse = true
    });
    var symbol2 = protocol2Result.Output.Value; // e.g., "VW1000000001"

    // Step 3: Verify collision by calculating hashes
    var hash1 = await NFTContractStub.CalculateTokenHash.CallAsync(new CalculateTokenHashInput
    {
        Symbol = symbol1,
        TokenId = 123
    });

    var hash2 = await NFTContractStub.CalculateTokenHash.CallAsync(new CalculateTokenHashInput
    {
        Symbol = symbol2,
        TokenId = 23
    });

    // If symbols follow collision pattern (e.g., "VW100000000" vs "VW1000000001"),
    // then hash1 should equal hash2
    hash1.ShouldBe(hash2);

    // Step 4: Mint colliding NFT with Protocol 2 (IsTokenIdReuse=true bypasses check)
    await NFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol2,
        TokenId = 23,
        Owner = DefaultAddress
    });

    // Step 5: Verify corruption - both (symbol, tokenId) pairs access same storage
    var balance1 = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = symbol1,
        TokenId = 123,
        Owner = DefaultAddress
    });

    var balance2 = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = symbol2,
        TokenId = 23,
        Owner = DefaultAddress
    });

    // Both balances should be 2 (corrupted - they share the same storage)
    balance1.Balance.ShouldBe(2);
    balance2.Balance.ShouldBe(2);

    // NFTInfo corruption - querying symbol2/tokenId2 returns symbol1/tokenId1 metadata
    var nftInfo = await NFTContractStub.GetNFTInfo.CallAsync(new GetNFTInfoInput
    {
        Symbol = symbol2,
        TokenId = 23
    });
    
    // BUG: NFTInfo still has Symbol=symbol1, TokenId=123 from first mint
    nftInfo.Symbol.ShouldBe(symbol1); // Metadata corruption proof
    nftInfo.TokenId.ShouldBe(123);
}
```

**Notes:**
- The POC demonstrates the collision when symbol generation produces the specific patterns needed
- In practice, the exact collision depends on the random symbol generation, but the mathematical certainty exists once both 9-digit and 10-digit symbols coexist in the system
- The vulnerability is deterministic once collision pairs exist, regardless of how they were generated

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L46-55)
```csharp
    private void DoTransfer(Hash tokenHash, Address from, Address to, long amount)
    {
        if (amount < 0) throw new AssertionException("Invalid transfer amount.");

        if (amount == 0) return;

        Assert(State.BalanceMap[tokenHash][from] >= amount, "Insufficient balance.");
        State.BalanceMap[tokenHash][from] = State.BalanceMap[tokenHash][from].Sub(amount);
        State.BalanceMap[tokenHash][to] = State.BalanceMap[tokenHash][to].Add(amount);
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L295-308)
```csharp
    public override Empty Approve(ApproveInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        State.AllowanceMap[tokenHash][Context.Sender][input.Spender] = input.Amount;
        Context.Fire(new Approved
        {
            Owner = Context.Sender,
            Spender = input.Spender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L433-437)
```csharp
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```
