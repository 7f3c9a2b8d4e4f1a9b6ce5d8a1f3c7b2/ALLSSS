### Title
Missing Validation of Secret-Sharing Reconstructed In-Values Breaks Commit-Reveal Binding Property

### Summary
The `RevealSharedInValues` function reconstructs miners' in-values from decrypted secret shares without verifying that the reconstructed value hashes to the originally committed OutValue. This breaks the fundamental binding property of the commit-reveal scheme, allowing colluding miners to manipulate the revealed values and compromise consensus randomness.

### Finding Description

**Root Cause:**

The AEDPoS consensus uses a commit-reveal scheme where miners commit `OutValue = Hash(InValue)` in one round and reveal `InValue` as `PreviousInValue` in the next round. With secret sharing enabled, other miners can reconstruct a miner's in-value from decrypted pieces. [1](#0-0) 

At these lines, the function reconstructs the in-value using `SecretSharingHelper.DecodeSecret` from decrypted pieces and directly assigns it as `PreviousInValue` **without any validation** that `Hash(revealedInValue) == OutValue` from the previous round.

**Why Existing Protections Fail:**

The only validation that checks the relationship between `PreviousInValue` and `OutValue` is in `UpdateValueValidationProvider`: [2](#0-1) 

However, this validation only checks the **sender's own** `PreviousInValue` (line 38: `var publicKey = validationContext.SenderPubkey`), not the revealed in-values that are reconstructed for **other miners** through secret sharing.

**Execution Path:**

1. Round N-1: Miner A commits `OutValue_A = Hash(InValue_A)` and shares encrypted pieces
2. Round N: Miners provide `DecryptedPieces` in their `UpdateValueInput`: [3](#0-2) 

3. During next round generation, `RevealSharedInValues` is called: [4](#0-3) 

4. The reconstructed value is used without validation, breaking the binding to the original commitment

**Alternative Path:**

Revealed in-values can also be applied through trigger information without validation: [5](#0-4) 

Again, no validation that the revealed value matches the committed hash.

### Impact Explanation

**Consensus Integrity Compromise:**
- The `PreviousInValue` is used to calculate signatures that determine mining order via `CalculateSignature`: [6](#0-5) 

- Manipulated in-values affect the random hash generation used for consensus randomness: [7](#0-6) 

**Severity:** Critical
- Breaks a fundamental cryptographic invariant (commit-reveal binding)
- Enables consensus manipulation through controlled randomness
- Undermines the security assumptions of the entire AEDPoS mechanism

### Likelihood Explanation

**Attacker Capabilities:**
- Requires control of ≥2/3 of miners (threshold for secret reconstruction): [8](#0-7) 

- Colluding miners provide incorrect `DecryptedPieces` via `UpdateValueInput.decrypted_pieces`: [9](#0-8) 

**Feasibility:**
- Attack is practical once Byzantine threshold is reached
- No cryptographic barriers after decryption phase
- Detection requires off-chain verification of reconstruction correctness

**Economic Rationality:**
- High impact (consensus manipulation) justifies coordination costs
- Applicable in scenarios with miner cartels or governance attacks

**Probability:** Medium-High for Byzantine-resistant scenarios, but represents a critical design flaw that violates security assumptions.

### Recommendation

**Required Fix:**

Add validation after reconstructing in-values in `RevealSharedInValues`:

```csharp
// After line 50 in AEDPoSContract_SecretSharing.cs
var committedOutValue = previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue;
Assert(
    HashHelper.ComputeFrom(revealedInValue) == committedOutValue,
    $"Reconstructed in-value does not match committed out-value for {publicKeyOfAnotherMiner}"
);
```

**Additional Checks:**

1. Add similar validation in `UpdateLatestSecretPieces`: [5](#0-4) 

2. Add test cases verifying that incorrect decrypted pieces cause reconstruction to fail validation

3. Consider adding cryptographic proofs of correct decryption to prevent malicious piece provision

### Proof of Concept

**Initial State:**
- 3 miners (A, B, C) with secret sharing enabled
- Round N-1: Miner A commits `OutValue_A = Hash(InValue_A)` and shares encrypted pieces

**Attack Steps:**

1. Round N: Miners B and C (2/3 majority) collude
2. They provide **incorrect** `DecryptedPieces` for Miner A via their `UpdateValueInput`:
   - Instead of correctly decrypting A's pieces, they provide manipulated values
3. When `RevealSharedInValues` executes:
   - It reconstructs using the incorrect pieces from B and C
   - Produces `revealedInValue ≠ InValue_A`
   - **No validation** checks that `Hash(revealedInValue) == OutValue_A`
4. The manipulated value is stored as Miner A's `PreviousInValue`

**Expected Result:** 
- Validation should fail: `Hash(revealedInValue) ≠ OutValue_A`
- Transaction should be rejected

**Actual Result:**
- No validation occurs
- Manipulated `PreviousInValue` is accepted and used for consensus calculations
- Binding property of commit-reveal scheme is broken

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-80)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** protobuf/aedpos_contract.proto (L211-212)
```text
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
```
