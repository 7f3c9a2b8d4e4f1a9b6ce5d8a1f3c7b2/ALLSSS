### Title
No Rollback Mechanism for MainChainCurrentMinerList and MainChainRoundNumber After Main Chain Reorganization

### Summary
The side chain consensus contract lacks any mechanism to detect or rollback changes to `MainChainCurrentMinerList` and `MainChainRoundNumber` if the main chain experiences a reorganization after the side chain has indexed and cached parent chain data. Once these state variables are updated and resource tokens are distributed to miners, there is no way to revert these changes, leading to permanent state corruption and misallocation of funds.

### Finding Description

The vulnerability exists in the cross-chain consensus information synchronization flow between main chain and side chain. The critical code path is: [1](#0-0) 

The `UpdateInformationFromCrossChain` method only validates that the incoming round number is strictly greater than the currently stored value: [2](#0-1) 

This check prevents updates with older round numbers but does NOT verify that the parent chain data is still valid or that the main chain hasn't experienced a reorganization since the data was originally cached.

Before updating the state, the method distributes resource tokens to the previous miners: [3](#0-2) [4](#0-3) 

Then updates the consensus state permanently: [5](#0-4) 

The parent chain data flows through this path:
1. Main chain provides data to side chain via gRPC server, verifying blocks are at or below LIB
2. Side chain caches received `ParentChainBlockData` locally
3. Side chain proposes to index this cached data (proposal/governance delay)
4. CrossChain contract validates the proposal only against local cache: [6](#0-5) 

This validation only checks that proposed data matches what's in the local cache - it does NOT re-query the main chain to verify the data is still current.

5. Upon approval, `IndexParentChainBlockData` extracts consensus data from the cached blocks: [7](#0-6) 

6. This calls `UpdateConsensusInformation` which updates the side chain's view of main chain consensus state.

**Root Cause:** There is no mechanism anywhere in the codebase to:
- Detect that the main chain has experienced a reorganization
- Rollback `MainChainCurrentMinerList` and `MainChainRoundNumber` to correct values
- Recover tokens distributed to miners from orphaned blocks
- Re-validate cached parent chain data against current main chain state

The state variables are only written in `UpdateInformationFromCrossChain` for side chains: [8](#0-7) 

No other method can correct or rollback these values once set.

### Impact Explanation

**Direct Fund Impact:**
Resource tokens (tx fees and rental fees) are distributed to miners based on `MainChainCurrentMinerList`. If this list contains miners from an orphaned main chain branch, tokens are permanently misallocated to incorrect recipients. The distribution logic iterates through the cached miner list and transfers tokens: [9](#0-8) 

These token transfers cannot be automatically reversed.

**Consensus Integrity Impact:**
The side chain uses `MainChainCurrentMinerList` to generate new consensus rounds when the main chain miner list changes: [10](#0-9) 

If the miner list is from an orphaned branch, the side chain's consensus mechanism operates with an invalid miner set, corrupting the entire consensus state.

**Affected Parties:**
- Legitimate miners who should receive rewards but don't
- Side chain operators whose consensus is corrupted
- Users whose transactions are validated by an incorrect miner set

**Severity Justification:** HIGH - Permanent state corruption, irreversible fund misallocation, consensus integrity compromise with no recovery mechanism.

### Likelihood Explanation

**Scenario 1: Main Chain Catastrophic Reorg**
While main chain reorgs affecting LIB (Last Irreversible Block) are theoretically rare, they can occur due to:
- Consensus attacks (51% attack variants)
- Critical consensus bugs
- Network partitions with delayed resolution

When parent chain data is provided to side chains, it's verified to be at or below LIB: [11](#0-10) 

However, with `LibHeightOffsetForCrossChainIndex = 0`: [12](#0-11) 

There is no safety buffer. If a catastrophic reorg affects even the LIB, cached data becomes invalid.

**Scenario 2: Stale Cached Data (More Realistic)**
The more probable scenario involves timing:
1. Main chain block at height H is at LIB, data cached by side chain
2. Significant time passes (hours/days) due to cross-chain indexing proposal and governance approval process
3. Main chain consensus state evolves (many new rounds, potentially different miners)
4. Side chain finally indexes the cached data, which is now outdated
5. `UpdateInformationFromCrossChain` accepts it because round number is higher than stored value
6. Side chain operates with stale consensus information

**Attack Complexity:** No attacker required - this is an operational vulnerability triggered by normal cross-chain operations combined with main chain reorganizations or proposal delays.

**Detection Constraints:** The vulnerability is silent - there's no error, no event, no mechanism to detect that the indexed data has become invalid.

**Probability:** MEDIUM to HIGH
- Catastrophic main chain reorg: Low but non-zero probability
- Stale cached data due to proposal delays: Higher probability
- Combined with no detection/correction mechanism: Guaranteed impact when conditions occur

### Recommendation

**Code-Level Mitigation:**

1. **Add Rollback Mechanism:** Implement an administrative function to reset `MainChainCurrentMinerList` and `MainChainRoundNumber` when reorgs are detected:

```
public override Empty RollbackMainChainConsensusInformation(RollbackInput input)
{
    // Only authorized addresses (e.g., Parliament) can call
    AssertCrossChainControllerPermission();
    Assert(!State.IsMainChain.Value, "Only side chain can rollback.");
    
    State.MainChainRoundNumber.Value = input.TargetRoundNumber;
    State.MainChainCurrentMinerList.Value = input.TargetMinerList;
    
    return new Empty();
}
```

2. **Add Re-validation Before Indexing:** Modify `IndexParentChainBlockData` to optionally re-verify consensus data against current main chain state through a fresh gRPC query before applying updates.

3. **Increase LIB Safety Buffer:** Change `LibHeightOffsetForCrossChainIndex` from 0 to a positive value (e.g., 100 blocks) to add a safety margin.

4. **Add Consensus Data Timestamp:** Include and validate timestamps in consensus extra data to detect stale cached data.

5. **Implement Token Distribution Delay:** Instead of immediately distributing tokens in `DistributeResourceTokensToPreviousMiners`, accumulate them in an escrow that can be clawed back during a rollback window.

**Invariant Checks:**
- Verify consensus data timestamp is within acceptable staleness threshold
- Cross-verify critical consensus updates against multiple data sources
- Implement health checks that compare side chain's view of main chain against actual main chain state

**Test Cases:**
- Test main chain reorg detection and rollback
- Test stale data rejection based on timestamp
- Test token distribution clawback mechanism
- Test governance-authorized rollback execution

### Proof of Concept

**Initial State:**
- Main chain at height 1000, LIB at height 990
- Main chain round number: 100, miner list: [A, B, C]
- Side chain indexed up to main chain height 950

**Exploit Steps:**

1. **Main chain provides data:**
   - Main chain block 990 (at LIB) contains consensus data: round 100, miners [A, B, C]
   - Side chain's gRPC client receives and caches this data
   
2. **Side chain proposes indexing:**
   - Miner proposes to index parent chain blocks 951-990
   - Proposal enters governance process (may take hours/days)
   
3. **Main chain reorganization:**
   - Main chain experiences reorg at height 995
   - New main chain blocks 995-1005 contain different consensus data: round 101, miners [D, E, F]
   - LIB advances to 1000 with new consensus state
   
4. **Side chain indexes stale data:**
   - Proposal approved, `RecordCrossChainData` called
   - `IndexParentChainBlockData` processes cached blocks 951-990
   - At block 990, extracts consensus data: round 100, miners [A, B, C]
   - Calls `UpdateInformationFromCrossChain`
   - Check passes: round 100 > previous round number
   - `DistributeResourceTokensToPreviousMiners` transfers tokens to [A, B, C]
   - Updates: `MainChainRoundNumber = 100`, `MainChainCurrentMinerList = [A, B, C]`

**Expected Result:**
Side chain should have round 101 and miners [D, E, F] (current main chain state)

**Actual Result:**
Side chain has round 100 and miners [A, B, C] (orphaned main chain state)
Tokens distributed to wrong miners
No mechanism to detect or correct this state

**Success Condition:**
Query side chain: `GetMainChainCurrentMinerList()` returns [A, B, C] instead of correct [D, E, F]
No rollback function exists to correct this permanently corrupted state.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataValidationService.cs (L161-166)
```csharp
            if (!parentChainBlockDataList[i].Equals(parentChainBlockData))
            {
                Logger.LogDebug(
                    $"Incorrect parent chain data. Parent chain height: {targetHeight}.");
                return false;
            }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L782-788)
```csharp
            // send consensus data shared from main chain  
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L34-36)
```csharp
    public Int64State MainChainRoundNumber { get; set; }

    public SingletonState<MinerList> MainChainCurrentMinerList { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** src/AElf.CrossChain.Core/Extensions/LocalLibExtensions.cs (L14-15)
```csharp
        if (chain.LastIrreversibleBlockHeight < height + CrossChainConstants.LibHeightOffsetForCrossChainIndex)
            return null;
```

**File:** src/AElf.CrossChain.Core/CrossChainConstants.cs (L7-7)
```csharp
    public const int LibHeightOffsetForCrossChainIndex = 0;
```
