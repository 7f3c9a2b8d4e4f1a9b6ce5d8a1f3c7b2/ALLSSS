### Title
Missing Authorization Check in SetPrimaryTokenSymbol Allows Unauthorized Primary Token Configuration

### Summary
The `SetPrimaryTokenSymbol` function lacks any authorization check, allowing any user to set the chain's primary token symbol if it hasn't been configured during genesis initialization. [1](#0-0)  This could enable an attacker to manipulate the transaction fee system if the chain is improperly initialized or if initialization fails.

### Finding Description

The `SetPrimaryTokenSymbol` function in TokenContract_Actions.cs only validates that (1) the primary token hasn't been set yet, and (2) the provided symbol corresponds to an existing token. [1](#0-0)  There is no authorization check verifying the caller's identity.

In contrast, other sensitive configuration methods in the same contract properly implement authorization using `AssertSenderAddressWith()`. For example: `AddAddressToCreateTokenWhiteList` [2](#0-1) , `RemoveAddressFromCreateTokenWhiteList` [3](#0-2) , and `SetTokenIssuerAndOwnerModificationEnabled` [4](#0-3)  all require Parliament controller authorization.

The primary token symbol is intended to be set during genesis initialization: on the main chain by the Economic contract [5](#0-4) , or on side chains by TokenContractInitializationProvider [6](#0-5) . However, the code does not enforce that initialization occurs or that only authorized system contracts can call this function. If `initializationData` is null, TokenContractInitializationProvider returns an empty method list, leaving the primary token unset. [7](#0-6) 

### Impact Explanation

The primary token symbol directly controls transaction size fee calculations. The fee charging logic uses `State.ChainPrimaryTokenSymbol.Value` to determine which token to charge for transaction size fees. [8](#0-7) [9](#0-8) 

If an attacker sets an arbitrary token as the primary token, they could:
1. **Break the fee system entirely**: Set a non-existent or unusable token, causing all transaction fee charges to fail and blocking all transactions
2. **Enable fee manipulation**: Set a token they control, potentially manipulating fee calculations
3. **Cause chain-wide DoS**: Make it impossible for legitimate users to pay transaction fees, effectively halting the chain

The impact severity is **CRITICAL** as it affects the entire chain's operability and economic model. All users would be unable to execute transactions if fees cannot be properly charged.

### Likelihood Explanation

The exploit requires that `ChainPrimaryTokenSymbol` remains unset after chain initialization, which could occur if:
1. The chain is deployed with incomplete initialization configuration (initializationData is null on side chain)
2. Genesis initialization fails or is interrupted before SetPrimaryTokenSymbol is called
3. The Economic contract initialization fails on main chain [10](#0-9) 
4. A test or development deployment skips proper initialization procedures

While production deployments should follow proper initialization sequences, the code itself provides no enforcement mechanism. The absence of an authorization check violates defensive programming principles - even if "proper configuration" is expected, critical functions should validate caller authority.

The attack complexity is **LOW**: once the precondition exists (unset primary token), an attacker needs only to call SetPrimaryTokenSymbol with any valid token symbol. The attack cost is minimal (one transaction), and detection would be immediate but potentially too late to prevent damage.

### Recommendation

Add authorization check to `SetPrimaryTokenSymbol` to restrict it to system contracts or governance:

```csharp
public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
{
    // Add authorization check
    AssertSenderAddressWith(Context.GetZeroSmartContractAddress());
    // Or alternatively check for Economic contract on main chain
    
    Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
    Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");
    
    State.ChainPrimaryTokenSymbol.Value = input.Symbol;
    Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
    return new Empty();
}
```

The authorization helper method exists in the contract: [11](#0-10) 

Alternative approach: Restrict to Economic contract address or make it callable only during genesis block (height 0).

Add regression tests verifying that unauthorized addresses cannot call SetPrimaryTokenSymbol, similar to existing authorization tests in the codebase.

### Proof of Concept

**Initial State:**
- TokenContract deployed but `ChainPrimaryTokenSymbol` not set during genesis (due to misconfiguration or initialization failure)
- Attacker has created a malicious token "EVIL" or plans to use any existing valid token

**Attack Steps:**
1. Attacker monitors chain state and confirms `GetPrimaryTokenSymbol()` returns null or native symbol only [12](#0-11) 
2. Attacker calls `SetPrimaryTokenSymbol(new SetPrimaryTokenSymbolInput { Symbol = "EVIL" })`
3. Transaction succeeds because there's no authorization check
4. `ChainPrimaryTokenSymbol` is now set to "EVIL"

**Expected vs Actual:**
- **Expected**: Transaction should revert with "Unauthorized behavior" error
- **Actual**: Transaction succeeds, primary token is set to attacker's chosen token [13](#0-12) 

**Success Condition:**
The attack succeeds when `State.ChainPrimaryTokenSymbol.Value` equals the attacker-specified token, and subsequent transaction fee calculations use this malicious token, breaking the fee system for all users.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L139-147)
```csharp
    public override Empty SetPrimaryTokenSymbol(SetPrimaryTokenSymbolInput input)
    {
        Assert(State.ChainPrimaryTokenSymbol.Value == null, "Failed to set primary token symbol.");
        Assert(!string.IsNullOrWhiteSpace(input.Symbol) && GetTokenInfo(input.Symbol) != null, "Invalid input symbol.");

        State.ChainPrimaryTokenSymbol.Value = input.Symbol;
        Context.Fire(new ChainPrimaryTokenSymbolSet { TokenSymbol = input.Symbol });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L462-467)
```csharp
    public override Empty AddAddressToCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap[input] = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L469-474)
```csharp
    public override Empty RemoveAddressFromCreateTokenWhiteList(Address input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        State.CreateTokenWhiteListMap.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L661-669)
```csharp
    public override Empty SetTokenIssuerAndOwnerModificationEnabled(SetTokenIssuerAndOwnerModificationEnabledInput input)
    {
        AssertSenderAddressWith(GetDefaultParliamentController().OwnerAddress);
        Assert(input != null, "Invalid input.");

        State.TokenIssuerAndOwnerModificationDisabled.Value = !input.Enabled;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L16-40)
```csharp
    public override Empty InitialEconomicSystem(InitialEconomicSystemInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Context.LogDebug(() => "Will create tokens.");
        CreateNativeToken(input);
        CreateResourceTokens();
        CreateElectionTokens();

        Context.LogDebug(() => "Finished creating tokens.");

        InitialMiningReward(input.MiningRewardTotalAmount);

        RegisterElectionVotingEvent();
        SetTreasurySchemeIdsToElectionContract();

        InitializeTokenConverterContract();
        State.TokenContract.InitialCoefficients.Send(new Empty());
        State.TokenContract.InitializeAuthorizedController.Send(new Empty());
        State.Initialized.Value = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L66-67)
```csharp
        State.TokenContract.SetPrimaryTokenSymbol.Send(new SetPrimaryTokenSymbolInput
            { Symbol = input.NativeTokenSymbol });
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L24-32)
```csharp
    public virtual List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var methodList = new List<ContractInitializationMethodCall>();
        var initializationData = _tokenContractInitializationDataProvider.GetContractInitializationData();

        // For the main chain, we use the economic contract to initialize the token contract.
        // So no initialization methods are required in here.
        // But for the side chain, which has no economic contract, we need initialize token contract.
        if (initializationData != null)
```

**File:** src/AElf.Kernel.Token/TokenContractInitializationProvider.cs (L85-105)
```csharp
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = chainPrimaryTokenInfo.Symbol
                    }.ToByteString()
                });
            }
            else
            {
                // set primary token with native token 
                methodList.Add(new ContractInitializationMethodCall
                {
                    MethodName = nameof(TokenContractContainer.TokenContractStub.SetPrimaryTokenSymbol),
                    Params = new SetPrimaryTokenSymbolInput
                    {
                        Symbol = nativeTokenInfo.Symbol
                    }.ToByteString()
                });
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L24-32)
```csharp
    public override ChargeTransactionFeesOutput ChargeTransactionFees(ChargeTransactionFeesInput input)
    {
        Context.LogDebug(() => "ChargeTransactionFees Start");
        AssertPermissionAndInput(input);
        // Primary token not created yet.
        if (State.ChainPrimaryTokenSymbol.Value == null)
        {
            return new ChargeTransactionFeesOutput { Success = true };
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L375-390)
```csharp
    private bool ChargeSizeFee(ChargeTransactionFeesInput input, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {

        Context.LogDebug(() => "ChargeSizeFee Start");

        //If delegation != null,from address->delegateeAddress
        // Size Fee is charged in primary token, elf.
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
        //Get primary token balance
        GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
            out var symbolChargedForBaseFee, out var amountChargedForBaseFee, out var amountChargedForBaseAllowance,
            out var availableBalance, out var availableAllowance);
        var txSizeFeeAmount = input.TransactionSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L111-114)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L132-140)
```csharp
    public override StringValue GetPrimaryTokenSymbol(Empty input)
    {
        if (string.IsNullOrWhiteSpace(_primaryTokenSymbol) && State.ChainPrimaryTokenSymbol.Value != null)
            _primaryTokenSymbol = State.ChainPrimaryTokenSymbol.Value;

        return new StringValue
        {
            Value = _primaryTokenSymbol ?? Context.Variables.NativeSymbol
        };
```
