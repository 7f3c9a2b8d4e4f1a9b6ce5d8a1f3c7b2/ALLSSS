### Title
Unvalidated MinersPreviousInValues Allows Consensus DoS via PreviousInValue Poisoning

### Summary
The `PerformSecretSharing()` function unconditionally accepts and applies attacker-supplied `MinersPreviousInValues` without validating their correctness against previous round OutValues. This allows an attacker to poison other miners' `PreviousInValue` fields in the stored round state, causing honest miners' blocks to fail validation and be rejected, resulting in consensus disruption.

### Finding Description

**Root Cause:**

The vulnerability exists in two critical inconsistencies:

1. **Unconditional Overwrite in On-Chain Processing:** [1](#0-0) 

The `PerformSecretSharing()` function unconditionally overwrites any miner's `PreviousInValue` with attacker-supplied values from `input.MinersPreviousInValues`, with no validation that these values are correct (i.e., that `Hash(PreviousInValue) == PreviousOutValue`).

2. **Conditional Set in Off-Chain Block Generation:** [2](#0-1) 

The `ApplyNormalConsensusData()` function only sets `PreviousInValue` if it's currently empty or null. This prevents victim miners from overriding a poisoned value during their block generation.

3. **No Validation of Submitted Values:** [3](#0-2) 

The `UpdateValueValidationProvider` only validates the sender's own `PreviousInValue`, not the `MinersPreviousInValues` for other miners that are being submitted.

**Attack Execution Path:**

1. **Attacker Poisons Round State:**
   - Attacker produces UpdateValue block with malicious `MinersPreviousInValues[VictimMiner] = WrongValue`
   - `ProcessUpdateValue()` calls `PerformSecretSharing()` which unconditionally sets the wrong value
   - The poisoned value is stored on-chain in the round state

2. **Victim Block Generation Fails:** [4](#0-3) 
   
   - Victim miner loads current round from on-chain state (contains poisoned value)
   - Calls `ApplyNormalConsensusData()` with their correct InValue from trigger information
   - The check at lines 14-16 prevents overwriting the poisoned value
   - Victim's block header contains the wrong PreviousInValue

3. **Validation Rejection:**
   - Victim's block undergoes validation
   - The validator checks `Hash(PoisonedValue) == VictimPreviousOutValue`
   - Validation fails because the poisoned value doesn't match
   - Victim's block is rejected

4. **Alternative Impact via SupplyCurrentRoundInformation:** [5](#0-4) 
   
   If the victim doesn't mine, the poisoned value is used to calculate their signature during NextRound transition, further corrupting consensus state.

### Impact Explanation

**Consensus Disruption (HIGH SEVERITY):**
- Any attacker with mining privileges can target specific miners or the entire miner set
- Poisoned `PreviousInValue` causes victim blocks to fail validation and be rejected
- Multiple miners can be targeted simultaneously via the `MinersPreviousInValues` map
- Sustained attacks can prevent block production and halt consensus progression

**Concrete Harm:**
- **Individual Miner DoS:** Victim miner cannot produce valid blocks until the next round/term transition
- **Cascade Effects:** If enough miners are targeted, the network cannot reach consensus
- **Revenue Loss:** Victim miners lose block rewards and transaction fees
- **Network Unavailability:** Prolonged attacks can make the blockchain unusable

**Affected Parties:**
- Individual miners who are targeted
- Token holders who cannot transact
- Applications dependent on the blockchain
- Overall network liveness and security

**Severity Justification:**
This is a HIGH severity vulnerability because it:
- Directly disrupts consensus mechanism integrity
- Can be executed by any miner (low privilege requirement)
- Requires only a single malicious block to target multiple victims
- Has immediate and observable impact on network operation
- No authentication or correctness validation exists for the attack vector

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the current round (achievable through staking/election)
- Must be able to produce at least one UpdateValue block
- No special privileges beyond normal miner status required

**Attack Complexity:**
- **Simple Execution:** Submit UpdateValue with arbitrary `MinersPreviousInValues` entries
- **Low Technical Barrier:** Only requires modifying transaction input data
- **No Timing Constraints:** Can be executed during any UpdateValue block in the round

**Feasibility Conditions:** [6](#0-5) 

The attack is enabled whenever secret sharing is active, which is a core feature of AEDPoS for recovering failed miners' InValues.

**Detection & Operational Constraints:**
- Attack is visible on-chain in transaction data but may not be immediately recognized
- No built-in monitoring or alerting for malicious `MinersPreviousInValues`
- Once executed, requires manual intervention or round/term transition to recover

**Probability Assessment:**
- **HIGH** - All preconditions are easily met
- Attack is deterministic and guaranteed to succeed
- Economic cost is minimal (just transaction fees)
- Benefit could include eliminating competition or disrupting network for ransom/extortion

### Recommendation

**Immediate Mitigation:**

1. **Add Validation for MinersPreviousInValues:**
   Modify `PerformSecretSharing()` to validate each submitted PreviousInValue:
   ```csharp
   foreach (var previousInValue in input.MinersPreviousInValues)
   {
       if (!round.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
           continue;
           
       // Validate against previous round's OutValue
       if (TryToGetPreviousRoundInformation(out var prevRound) &&
           prevRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
       {
           var expectedOutValue = prevRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
           if (expectedOutValue != null && 
               HashHelper.ComputeFrom(previousInValue.Value) != expectedOutValue)
           {
               Context.LogDebug(() => $"Invalid PreviousInValue for {previousInValue.Key}");
               continue; // Skip invalid entries
           }
       }
       
       // Only set if currently empty to prevent overwriting
       if (round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == Hash.Empty ||
           round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue == null)
       {
           round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
       }
   }
   ```

2. **Align Off-Chain and On-Chain Behavior:**
   Make `PerformSecretSharing()` consistent with `UpdateLatestSecretPieces()` by only setting when empty: [7](#0-6) 

3. **Add Invariant Checks:**
   - Assert that `MinersPreviousInValues` entries match recovered secret shares when available
   - Verify submitter has access to required decrypted pieces to reconstruct the InValue
   - Limit number of PreviousInValues that can be revealed per block

**Test Cases:**

1. **Test Malicious MinersPreviousInValues Rejection:**
   - Attacker submits UpdateValue with wrong PreviousInValue for another miner
   - Verify the wrong value is NOT applied to round state
   - Verify attacker's block still succeeds but the malicious data is ignored

2. **Test Legitimate Secret Sharing:**
   - Miner correctly reconstructs another miner's InValue via secret shares
   - Verify the correct value is accepted and applied
   - Verify subsequent validation succeeds

3. **Test Overwrite Protection:**
   - Miner already has PreviousInValue set
   - Another miner tries to set different value via MinersPreviousInValues
   - Verify original value is preserved

### Proof of Concept

**Initial State:**
- Round N-1 completed with MinerB producing block with `OutValue_B = Hash(InValue_B)`
- Round N begins with secret sharing enabled
- AttackerA and MinerB are both active miners

**Attack Steps:**

1. **AttackerA produces malicious UpdateValue block:**
   ```
   Transaction: UpdateValue(UpdateValueInput {
       ... normal fields ...
       MinersPreviousInValues: {
           "MinerB_Pubkey": Hash("malicious_wrong_value")
       }
   })
   ```

2. **On-chain execution:**
   - `ProcessUpdateValue()` called
   - `PerformSecretSharing()` at line 295-296 unconditionally sets:
     `round.RealTimeMinersInformation["MinerB_Pubkey"].PreviousInValue = Hash("malicious_wrong_value")`
   - Round state stored with poisoned value

3. **MinerB attempts to produce block:**
   - Loads round state (contains poisoned value)
   - `ApplyNormalConsensusData()` check at line 14-16 prevents overwrite
   - Block header generated with poisoned PreviousInValue

4. **Validation failure:**
   - `UpdateValueValidationProvider.ValidatePreviousInValue()` executes
   - Checks: `Hash(Hash("malicious_wrong_value")) == OutValue_B`
   - Returns: `false` (validation failed)
   - MinerB's block is **REJECTED**

**Expected vs Actual Result:**
- **Expected:** MinerB's block is accepted with their correct PreviousInValue
- **Actual:** MinerB's block is rejected due to poisoned PreviousInValue from AttackerA

**Success Condition:**
- MinerB receives block rejection error
- MinerB cannot produce valid blocks until poisoned value is cleared (next round/term)
- AttackerA successfully denies MinerB's mining capability with single malicious transaction

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-20)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```
