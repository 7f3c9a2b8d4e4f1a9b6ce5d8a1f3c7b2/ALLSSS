### Title
Quadratic Voting Double-Count Vulnerability via VoteId Reuse in Delegated Voting

### Summary
The `Vote()` function in the Vote contract allows a sponsor to call the function multiple times with the same VoteId for delegated quadratic voting scenarios. This causes the `QuadraticVotesCountMap` to increment repeatedly while `VotingRecords` is overwritten, enabling vote inflation without proper token accounting. The sponsor can artificially multiply vote counts by reusing VoteIds, breaking the fairness guarantees of quadratic voting.

### Finding Description

**Root Cause:**
The `Vote()` function lacks validation to prevent VoteId reuse. For delegated voting (IsLockToken = false), the sponsor provides the VoteId, but there is no check whether this VoteId already exists in `VotingRecords` before incrementing the quadratic vote count. [1](#0-0) 

The `QuadraticVotesCountMap` is incremented at lines 100-101 immediately after validation completes, without checking if the VoteId was previously used. [2](#0-1) 

At line 117, the `VotingRecords` mapping is simply overwritten with the new record, destroying evidence of the previous vote. [3](#0-2) 

Line 119 calls `UpdateVotingResult` which increments the vote count by 1 for quadratic voting on each call, regardless of whether the VoteId is reused.

**Why Protections Fail:**
The validation function `AssertValidVoteInput` only checks basic constraints: [4](#0-3) 

For delegated voting, lines 384-389 only verify that the sponsor is the sender and that VoteId is not null. There is NO check that `State.VotingRecords[input.VoteId]` doesn't already exist or isn't already withdrawn.

**Execution Path:**
1. Sponsor registers voting item with `IsLockToken = false` and `IsQuadratic = true`
2. Sponsor calls `Vote()` with VoteId = X: `QuadraticVotesCountMap[X] = 1`, amount = ticketCost × 1, Results += 1
3. Sponsor calls `Vote()` again with same VoteId = X: `QuadraticVotesCountMap[X] = 2`, amount = ticketCost × 2, Results += 1 (total +2)
4. Repeat step 3 multiple times to inflate vote count
5. Final state: `QuadraticVotesCountMap[X] = N`, but only one `VotingRecords[X]` exists (overwritten), while Results shows N votes

### Impact Explanation

**Direct Governance Impact:**
- **Vote Manipulation**: The sponsor can artificially inflate vote counts for any option by reusing VoteIds, allowing a single "voter" to be counted N times
- **Quadratic Voting Fairness Violation**: Quadratic voting is designed so each additional vote costs more (1x, 2x, 3x, etc.), but this vulnerability allows the sponsor to record multiple votes while only storing the final cost calculation
- **Accounting Inconsistency**: The voting results show N votes, but only one VotingRecord exists, breaking auditability

**Who Is Affected:**
- All voting activities using delegated quadratic voting (IsLockToken = false, IsQuadratic = true)
- Legitimate voters whose votes are diluted by inflated counts
- Decision-making processes that rely on vote tallies

**Severity Justification:**
This is a **Critical** vulnerability because:
1. It completely undermines the integrity of quadratic voting mechanisms
2. The sponsor can arbitrarily manipulate vote outcomes with zero cost
3. No on-chain evidence exists of the manipulation (only one record per VoteId)
4. It affects governance decisions that may control significant protocol resources

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be the sponsor of a delegated voting item
- Attacker can create voting items with `IsLockToken = false` and `IsQuadratic = true`
- No special privileges beyond being a sponsor are required

**Attack Complexity:**
- **Very Low**: Simply call `Vote()` multiple times with the same VoteId
- No complex transaction ordering or timing requirements
- No need to bypass any cryptographic or consensus mechanisms

**Feasibility Conditions:**
- Delegated quadratic voting must be enabled (both flags set appropriately)
- The vulnerability exists in the current code with no mitigating controls [5](#0-4) 

**Economic Rationality:**
- Zero cost attack (no tokens locked for delegated voting)
- High benefit (complete control over vote outcomes)
- No detection mechanism exists on-chain

**Probability:**
High likelihood in any system using delegated quadratic voting, as the sponsor has direct incentive and capability to manipulate outcomes in their favor.

### Recommendation

**Code-Level Mitigation:**
Add a validation check in `AssertValidVoteInput` to prevent VoteId reuse:

```csharp
private VotingItem AssertValidVoteInput(VoteInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
    Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    if (!votingItem.IsLockToken)
    {
        Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
        Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
        Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        
        // ADD THIS CHECK:
        var existingRecord = State.VotingRecords[input.VoteId];
        Assert(existingRecord == null || existingRecord.IsWithdrawn, 
            "Vote Id already exists and has not been withdrawn.");
    }
    else
    {
        // ... existing code
    }
    return votingItem;
}
```

**Invariant Checks:**
1. Each VoteId must map to at most one active (non-withdrawn) VotingRecord
2. For quadratic voting, `QuadraticVotesCountMap[voteId]` should only increment when a new VoteId is created
3. The total of all active votes in Results must equal the sum of votes from non-withdrawn VotingRecords

**Test Cases:**
1. Test that calling `Vote()` twice with the same VoteId for delegated quadratic voting fails
2. Test that the same VoteId can be reused only after withdrawal
3. Test that vote counts match between `VotingRecords` and `Results`
4. Fuzz test with random VoteId reuse patterns to ensure no edge cases exist

### Proof of Concept

**Required Initial State:**
1. Deploy Vote contract
2. Register voting item with parameters:
   - `IsLockToken = false` (delegated voting)
   - `IsQuadratic = true` (quadratic voting enabled)
   - `TicketCost = 100` (example cost per vote)
   - `Options = ["Yes", "No"]`

**Transaction Steps:**
1. **First Vote Call:**
   ```
   Vote(VoteInput {
     VotingItemId: itemId,
     Voter: voterA,
     VoteId: Hash("malicious-id"),
     Option: "Yes",
     Amount: <ignored for quadratic>
   })
   ```
   - State after: `QuadraticVotesCountMap[Hash("malicious-id")] = 1`
   - State after: `VotingRecords[Hash("malicious-id")] = { Amount: 100, Option: "Yes" }`
   - State after: `Results["Yes"] = 1`

2. **Second Vote Call (SAME VoteId):**
   ```
   Vote(VoteInput {
     VotingItemId: itemId,
     Voter: voterA,
     VoteId: Hash("malicious-id"),  // REUSED
     Option: "Yes",
     Amount: <ignored>
   })
   ```
   - State after: `QuadraticVotesCountMap[Hash("malicious-id")] = 2`
   - State after: `VotingRecords[Hash("malicious-id")] = { Amount: 200, Option: "Yes" }` (OVERWRITTEN)
   - State after: `Results["Yes"] = 2` (INCREMENTED AGAIN)

3. **Third Vote Call (SAME VoteId):**
   ```
   Vote(VoteInput {
     VotingItemId: itemId,
     Voter: voterA,
     VoteId: Hash("malicious-id"),  // REUSED AGAIN
     Option: "Yes",
     Amount: <ignored>
   })
   ```
   - State after: `QuadraticVotesCountMap[Hash("malicious-id")] = 3`
   - State after: `VotingRecords[Hash("malicious-id")] = { Amount: 300, Option: "Yes" }` (OVERWRITTEN)
   - State after: `Results["Yes"] = 3` (INCREMENTED AGAIN)

**Expected vs Actual Result:**
- **Expected**: Transaction 2 and 3 should FAIL with "Vote Id already exists"
- **Actual**: All three transactions succeed, inflating the vote count from 1 to 3 while only one VotingRecord exists

**Success Condition:**
The attack succeeds if `Results["Yes"] = 3` while only one entry exists in `VotingRecords` for the VoteId, proving that vote count was manipulated through VoteId reuse.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-103)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```
