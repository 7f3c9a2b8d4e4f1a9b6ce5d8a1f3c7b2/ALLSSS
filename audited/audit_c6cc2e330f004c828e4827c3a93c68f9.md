### Title
Hash Collision in AssembledNftsMap Due to Unseparated String Concatenation in Token Hash Calculation

### Summary
The `CalculateTokenHash` function concatenates NFT symbol and tokenId without a separator, allowing different (symbol, tokenId) pairs to produce identical hash values. This causes hash collisions in `AssembledNftsMap`, where assembled NFT data from one NFT can overwrite another's, leading to permanent loss of assembled assets when users disassemble their NFTs.

### Finding Description

The root cause is in the `CalculateTokenHash` function [1](#0-0) , which directly concatenates symbol and tokenId without any separator before hashing.

NFT protocol symbols follow the format `{2-letter-prefix}{9+-digit-number}` [2](#0-1) , where the minimum number length is 9 digits [3](#0-2) . As more protocols are created, the number length can grow beyond 9 digits [4](#0-3) .

**Collision Example:**
- NFT1: symbol="AR123456789", tokenId=10 → "AR12345678910"
- NFT2: symbol="AR1234567891", tokenId=0 → "AR12345678910"

Both produce identical strings and thus identical hashes.

The `AssembledNftsMap` uses these hashes as keys [5](#0-4) . During assembly, the map entry is written [6](#0-5) , and during disassembly, it's read and removed [7](#0-6) .

When a collision occurs:
1. User A assembles NFT1, storing valuable assembled NFTs at hash H
2. User B (or attacker) assembles NFT2 with same hash H, **overwriting** User A's data
3. User A disassembles NFT1, retrieves User B's assembled data instead of their own
4. User A permanently **loses** their original assembled NFTs

Minters can specify custom tokenIds when minting [8](#0-7) , with only uniqueness validation per symbol [9](#0-8) , but no cross-symbol collision prevention exists.

### Impact Explanation

**Direct Asset Loss:** Users assembling NFTs with valuable components (rare NFTs or fungible tokens) will permanently lose these assets if a hash collision overwrites their `AssembledNftsMap` entry. When they disassemble, they receive the wrong assets or nothing at all.

**Affected Parties:** All users who assemble NFTs are at risk. As the protocol scales with more NFT protocols and minted NFTs, the collision probability increases according to the birthday paradox—with approximately 100,000 NFTs across all protocols, there's a ~50% chance of at least one collision occurring (sqrt of 10^10 symbol space).

**Severity Justification:** HIGH severity due to:
- Permanent, unrecoverable asset loss
- No on-chain mechanism to detect or prevent collisions
- Impact scales with protocol adoption
- Affects core NFT assembly functionality designed for valuable asset combinations

### Likelihood Explanation

**Natural Collision Probability:** Given the symbol space of approximately 10 prefixes × 10^9+ numbers = 10^10 possible combinations, and tokenIds being 64-bit integers, natural collisions become increasingly likely as the system scales. With the birthday paradox, collisions become probable around sqrt(10^10) ≈ 100,000 total NFTs.

**Attacker Capabilities:** An attacker can:
1. Monitor on-chain assembled NFTs to identify high-value targets
2. Create new NFT protocols repeatedly (costs protocol creation fees)
3. Choose custom tokenIds when minting [8](#0-7) 
4. Assemble with minimal value to overwrite victim's data

**Attack Complexity:** For targeted attacks, the attacker must create protocols until obtaining a symbol that produces a collision with the target. With random symbol generation, this requires on average ~10^9 attempts for a specific 10-digit suffix collision, making targeted attacks economically impractical. However, opportunistic attacks exploiting natural collisions or targeting multiple victims simultaneously are feasible.

**Likelihood Assessment:** MEDIUM - While targeted attacks are impractical, natural collisions become increasingly likely with scale, and the lack of any collision detection or prevention makes exploitation inevitable as adoption grows.

### Recommendation

**Code-Level Mitigation:**
Modify `CalculateTokenHash` to include a separator between symbol and tokenId:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}");
}
```

The separator (e.g., `:`, `|`, or `#`) must not be valid in symbols (current regex validation allows only alphanumeric characters [10](#0-9) ).

**Additional Invariant Checks:**
1. Add collision detection: Before storing in `AssembledNftsMap`, verify the entry doesn't already exist or belongs to the same (symbol, tokenId) pair
2. Store (symbol, tokenId) alongside assembled data to validate ownership during disassembly

**Migration Strategy:**
For existing deployed contracts, consider:
1. Adding a new mapping with corrected hash calculation
2. Gradual migration of existing entries
3. Dual-lookup during transition period

**Test Cases:**
1. Verify different (symbol, tokenId) pairs produce different hashes
2. Test boundary cases with maximum-length symbols and various tokenIds
3. Verify no hash collisions possible through string manipulation

### Proof of Concept

**Initial State:**
- Protocol1 created with symbol "AR123456789" (9-digit suffix)
- Protocol2 created with symbol "AR1234567891" (10-digit suffix) - occurs naturally as protocol count grows

**Attack Sequence:**

1. **Victim assembles valuable NFT:**
   - Call `Assemble` with symbol="AR123456789", tokenId=10
   - AssembledNfts contains 5 valuable NFTs worth 1000 ELF total
   - Stored at hash H = Hash("AR12345678910")

2. **Attacker creates collision:**
   - Call `Assemble` with symbol="AR1234567891", tokenId=0
   - AssembledNfts contains 1 worthless NFT worth 0.01 ELF
   - **Overwrites** victim's entry at hash H = Hash("AR12345678910")

3. **Victim disassembles:**
   - Call `Disassemble` with symbol="AR123456789", tokenId=10
   - Retrieves assembledNfts from hash H
   - **Receives attacker's worthless NFT instead of original 5 valuable NFTs**
   - Entry removed from AssembledNftsMap

4. **Attacker disassembles:**
   - Call `Disassemble` with symbol="AR1234567891", tokenId=0
   - Entry already removed by victim
   - Receives nothing (loses their 0.01 ELF NFT)

**Expected Result:** Victim receives their 5 valuable NFTs worth 1000 ELF

**Actual Result:** Victim receives 1 worthless NFT worth 0.01 ELF, permanently losing 999.99 ELF value

**Success Condition:** Transaction succeeds with no revert, but victim's assembled assets are permanently lost due to hash collision overwriting their `AssembledNftsMap` entry.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-176)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-209)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L392-392)
```csharp
        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L395-396)
```csharp
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```
