### Title
Missing Miner List Validation in NextRound Allows Consensus Takeover

### Summary
The `ValidationForNextRound()` function only validates that the round number increments by exactly one and that all `InValue` fields are null, but fails to verify that the miner list in the provided next round matches the current round's miner list. This allows any legitimate miner to inject arbitrary miners and take over consensus during a round transition.

### Finding Description

The vulnerability exists in the validation pipeline for `NextRound` consensus behavior. When a miner produces a block to transition to the next round, the system performs several validations: [1](#0-0) 

The `RoundTerminateValidationProvider` only checks:
1. Round number is exactly incremented by 1 (line 29)
2. All miners' `InValue` fields are null (lines 32-34)

Additionally, the validation pipeline includes: [2](#0-1) 

The `NextRoundMiningOrderValidationProvider` validates: [3](#0-2) 

This validation can be trivially bypassed by setting all miners' `FinalOrderOfNextRound` to 0 and all `OutValue` to null, resulting in 0 == 0 check passing.

**Root Cause**: None of these validations verify that the miner list keys in `extraData.Round.RealTimeMinersInformation` match the miner list in `BaseRound.RealTimeMinersInformation`. In legitimate round generation: [4](#0-3) 

The next round preserves the current round's miner list, only changing orders and timing. However, the validation does not enforce this invariant.

After validation passes, the malicious round is directly stored: [5](#0-4) 

The `ToRound()` conversion copies all fields including the arbitrary miner list: [6](#0-5) 

And `AddRoundInformation` stores it without validation: [7](#0-6) 

### Impact Explanation

**Consensus Takeover**: An attacker can completely replace the legitimate miner list with arbitrary public keys they control, effectively taking over the consensus mechanism. This violates the critical invariant of "miner schedule integrity."

**Concrete Damage**:
- All legitimately elected miners lose their mining rights and block production rewards
- The attacker gains monopoly control over block production
- The attacker can halt the chain by setting invalid mining orders (all Order = 0)
- Democratic election of validators becomes meaningless as results can be overridden
- Governance proposals and cross-chain operations dependent on miner signatures become compromised

**Affected Parties**:
- Legitimate miners lose income and voting power
- Token holders' votes for miner election are nullified
- Users experience potential chain halts or centralization
- DApps relying on decentralized consensus face service disruption

**Severity**: CRITICAL - This represents a complete breakdown of the consensus security model, allowing a single malicious miner to hijack the entire blockchain's validator set.

### Likelihood Explanation

**Attacker Capabilities**: The attacker only needs to be a current legitimate miner in the round. This is a relatively low bar as there are typically multiple miners (e.g., 5-17 in AEDPoS configurations).

**Attack Complexity**: LOW
1. Monitor for round termination conditions
2. Craft a `NextRoundInput` with arbitrary miner list
3. Set `RoundNumber = current + 1`
4. Set all `InValue = null`, `OutValue = null`, `FinalOrderOfNextRound = 0`
5. Submit block during attacker's mining time slot

**Feasibility**: HIGH
- No special privileges needed beyond being a current miner
- No timing constraints beyond normal block production
- No economic cost (attacker earns block rewards)
- No complex cryptographic operations required

**Detection**: The attack is immediately visible on-chain as the miner list changes unexpectedly, but by then the damage is done as the attacker controls the next round.

**Probability**: HIGH - Any of the current miners could execute this attack during any round transition (which occurs regularly, e.g., every ~8 minutes with 17 miners producing 8-second blocks).

### Recommendation

Add miner list consistency validation to `ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var baseRound = validationContext.BaseRound;
    
    // Existing checks
    if (baseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // NEW: Validate miner list consistency
    var baseMiners = baseRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    
    if (baseMiners.Count != providedMiners.Count || 
        !baseMiners.SequenceEqual(providedMiners))
        return new ValidationResult { Message = "Miner list must not change during NextRound transition." };

    // Existing InValue check
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Additional Safeguards**:
1. Validate that miners with `FinalOrderOfNextRound > 0` must have non-null `OutValue` (strengthen NextRoundMiningOrderValidationProvider)
2. Add integration tests that attempt to inject arbitrary miners during NextRound
3. Consider adding a hash-based verification of the miner list between rounds
4. Log miner list changes prominently for monitoring

### Proof of Concept

**Initial State**:
- Current round number: 100
- Current miner list: `["Alice", "Bob", "Charlie", "Dave", "Eve"]`
- Bob is a legitimate miner

**Attack Sequence**:

1. **Bob waits for round termination condition** (e.g., all miners have produced blocks or time slot expires)

2. **Bob crafts malicious NextRoundInput**:
```
NextRoundInput {
    RoundNumber: 101,
    TermNumber: <same as current>,
    RealTimeMinersInformation: {
        "MaliciousPubkey1": { Order: 0, InValue: null, OutValue: null, FinalOrderOfNextRound: 0 },
        "MaliciousPubkey2": { Order: 0, InValue: null, OutValue: null, FinalOrderOfNextRound: 0 },
        "MaliciousPubkey3": { Order: 0, InValue: null, OutValue: null, FinalOrderOfNextRound: 0 }
    }
}
```

3. **Bob submits block with this consensus data during his time slot**

4. **Validation executes**:
   - `MiningPermissionValidationProvider`: Bob ∈ current miner list ✓
   - `TimeSlotValidationProvider`: Bob in correct time slot ✓
   - `NextRoundMiningOrderValidationProvider`: 0 miners with FinalOrderOfNextRound > 0 == 0 miners with OutValue != null ✓
   - `RoundTerminateValidationProvider`: 101 == 100 + 1 ✓, all InValue null ✓

5. **All validations pass, block is accepted**

6. **ProcessNextRound executes**, storing malicious round to `State.Rounds[101]`

**Expected Result**: Validation should reject the block due to miner list mismatch

**Actual Result**: Block is accepted, and Round 101 now has miner list `["MaliciousPubkey1", "MaliciousPubkey2", "MaliciousPubkey3"]` instead of `["Alice", "Bob", "Charlie", "Dave", "Eve"]`

**Success Condition**: Query `State.Rounds[101].RealTimeMinersInformation.Keys` returns the attacker's arbitrary keys, not the original legitimate miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-37)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
