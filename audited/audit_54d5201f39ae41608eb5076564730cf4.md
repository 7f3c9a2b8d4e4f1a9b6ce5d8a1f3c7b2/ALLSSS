# Audit Report

## Title
Missing ProducedBlocks Counter Validation in Next Round Transitions Allows Reward Manipulation

## Summary
The `ValidationForNextRound()` function in `RoundTerminateValidationProvider` fails to validate the integrity of `ProducedBlocks` counters during round transitions. A malicious miner producing a round-terminating block can submit manipulated `ProducedBlocks` values that directly affect Treasury reward distribution, enabling them to inflate their own rewards while penalizing competitors.

## Finding Description

The AEDPoS consensus validation pipeline contains a critical gap in the NextRound transition validation logic. When a miner produces a round-terminating block and submits `NextRoundInput` data, the validation only checks structural properties but completely omits validation of the `ProducedBlocks` field. [1](#0-0) 

The validation explicitly states it checks only "Round Number" and "In Values Should Be Null", with no mention of ProducedBlocks validation.

When generating next round information legitimately, ProducedBlocks values are correctly copied from the current round: [2](#0-1) [3](#0-2) 

However, the miner receives this data from the contract and can modify it before submission. The `ProcessNextRound()` method directly converts the input without any ProducedBlocks validation: [4](#0-3) 

The `ToRound()` conversion is a simple field copy with zero validation: [5](#0-4) 

The manipulated data is then persisted to state: [6](#0-5) 

## Impact Explanation

The ProducedBlocks counters have direct financial impact through the Treasury contract's BasicMinerReward distribution scheme: [7](#0-6) 

The reward calculation uses `CalculateShares()` which implements strict penalty thresholds: [8](#0-7) 

A malicious miner can:
1. **Inflate their own ProducedBlocks** → receive linear shares instead of quadratic penalty
2. **Deflate competitors' ProducedBlocks** → push victims below the 50% threshold (0 shares) or 80% threshold (quadratic penalty)
3. **Manipulate the average** → shift threshold boundaries affecting all miners

The BasicMinerReward scheme receives significant allocation (default 2 out of 4 weight in MinerReward): [9](#0-8) 

This directly misallocates mining rewards across the entire term, transferring value from honest miners to the attacker.

## Likelihood Explanation

This attack is highly feasible:

**Entry Point**: Any legitimate miner producing a round-terminating block (last block producer or extra block producer). This occurs regularly every round.

**Attack Execution**:
1. Miner calls `GetConsensusExtraData()` to receive correct round data from contract
2. Miner modifies `ProducedBlocks` values in the returned `RealTimeMinersInformation`
3. Miner creates custom `NextRoundInput` with manipulated data
4. Miner includes transaction calling `NextRound()` with this input in their block

**Validation Bypass**: The validation pipeline explicitly does NOT check ProducedBlocks: [10](#0-9) 

Only structural validators are invoked - none examine ProducedBlocks integrity.

**Detection Difficulty**: The manipulated values appear structurally valid and pass all existing checks. No cryptographic binding or consensus-level validation prevents the modification.

**Economic Incentive**: High reward (increased mining rewards) for low risk (undetectable manipulation). The attack repeats every round transition throughout a term.

## Recommendation

Add ProducedBlocks validation to the `RoundTerminateValidationProvider` or create a dedicated validation provider that:

1. Verifies each miner's ProducedBlocks in the next round matches their current round value
2. For the block producer triggering NextRound, verify their count increments by exactly 1
3. Ensure no other miners' ProducedBlocks values change unexpectedly

Example fix:
```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var currentRound = validationContext.BaseRound;
    
    // Existing checks
    if (currentRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
        
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate ProducedBlocks integrity
    foreach (var minerInNextRound in extraData.Round.RealTimeMinersInformation)
    {
        if (!currentRound.RealTimeMinersInformation.ContainsKey(minerInNextRound.Key))
            continue; // New miner, skip
            
        var currentProducedBlocks = currentRound.RealTimeMinersInformation[minerInNextRound.Key].ProducedBlocks;
        var nextProducedBlocks = minerInNextRound.Value.ProducedBlocks;
        
        // Block producer increments by 1, others stay the same
        var expectedBlocks = minerInNextRound.Key == extraData.SenderPubkey.ToHex() 
            ? currentProducedBlocks.Add(1) 
            : currentProducedBlocks;
            
        if (nextProducedBlocks != expectedBlocks)
            return new ValidationResult { 
                Message = $"Invalid ProducedBlocks for miner {minerInNextRound.Key}" 
            };
    }
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A complete test demonstrating this vulnerability would:

1. Set up a consensus round with multiple miners having different ProducedBlocks counts
2. Have a malicious miner produce the round-terminating block
3. Modify the NextRoundInput to inflate their ProducedBlocks and deflate a competitor's
4. Verify the manipulated transaction passes validation
5. Verify the manipulated data is persisted to state
6. Advance to term end and verify Treasury distributes rewards based on manipulated values
7. Confirm the attacker receives more rewards than legitimate and victims receive less

The test would show that `ValidateConsensusBeforeExecution` accepts the manipulated input, `ProcessNextRound` stores it, and `UpdateBasicMinerRewardWeights` uses it for reward calculation without any detection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-35)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-55)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L480-488)
```csharp
    private MinerRewardWeightSetting GetDefaultMinerRewardWeightSetting()
    {
        return new MinerRewardWeightSetting
        {
            BasicMinerRewardWeight = 2,
            WelcomeRewardWeight = 1,
            FlexibleRewardWeight = 1
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
