### Title
Incorrect Distinct() Usage Allows Duplicate Mining Orders to Pass Validation in NextRound Transition

### Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method uses `Distinct()` on entire `MinerInRound` objects instead of their `FinalOrderOfNextRound` values when checking for duplicate mining orders. Since `MinerInRound` is a protobuf-generated class that compares all 17 fields for equality, two different miners with the same `FinalOrderOfNextRound` value but different other fields (pubkey, produced_blocks, etc.) will not be detected as duplicates, allowing multiple miners to be assigned the same mining order in the next round.

### Finding Description

The vulnerability exists in the validation logic that checks for duplicate mining orders during round transitions: [1](#0-0) 

The validation calls `.Distinct()` on the collection of `MinerInRound` objects directly, rather than on their `FinalOrderOfNextRound` values. The `MinerInRound` type is defined as a protobuf message with 17 fields: [2](#0-1) 

Protobuf-generated C# classes implement `Equals()` and `GetHashCode()` methods that perform field-by-field comparison across all properties. This means two `MinerInRound` objects are considered equal only if ALL their fields match - including `pubkey`, `order`, `produced_blocks`, `in_value`, `out_value`, and 12 other fields.

**Root Cause:** When checking for duplicate `FinalOrderOfNextRound` values, the code compares entire objects instead of extracting just the order values. Two different miners (MinerA with pubkey="A" and MinerB with pubkey="B") can both have `FinalOrderOfNextRound = 1`, but `MinerA.Equals(MinerB)` returns false because their pubkeys differ, causing `Distinct()` to count them as separate entries.

**Why Protection Fails:** The validation is executed during `NextRound` behavior processing: [3](#0-2) 

The `NextRoundInput` is provided by the block producer and converted to a `Round` object that gets validated: [4](#0-3) 

A malicious miner producing the NextRound block can craft an input where multiple different `MinerInRound` entries share the same `FinalOrderOfNextRound` value. The validation will incorrectly pass because it counts distinct objects rather than distinct order values.

### Impact Explanation

**Consensus Integrity Compromise:**
- Multiple miners can be assigned to the same mining time slot in the next round
- The mining schedule becomes invalid, with overlapping or conflicting orders
- Miners may attempt to produce blocks simultaneously, causing consensus confusion
- A malicious miner could effectively claim multiple time slots by duplicating their order across different miner identities

**Mining Schedule Breakdown:**
The round generation logic relies on unique `FinalOrderOfNextRound` values to assign proper time slots: [5](#0-4) [6](#0-5) 

If duplicate orders exist, the `occupiedOrders` list will not correctly reflect all used slots, causing `ableOrders` to include already-occupied positions. This leads to multiple miners being assigned the same `Order` value and `ExpectedMiningTime`, breaking the fundamental invariant that each miner has a unique time slot.

**Severity:** CRITICAL - This directly violates the "miner schedule integrity" critical invariant and can cause consensus failures.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a valid miner in the current round (required to produce blocks)
- Attacker must be selected to produce the block that triggers `NextRound` behavior
- This occurs naturally in rotation - any miner will eventually get this opportunity

**Attack Complexity:** LOW
- The attacker simply crafts a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values across different miner entries
- No complex timing, no race conditions, no cryptographic breaking required
- The validation logic itself is flawed, so bypassing it requires no special techniques

**Feasibility Conditions:**
- The miner is already authorized to produce blocks (normal operating condition)
- The consensus implementation in `AEDPoSContract` processes the attacker's input: [7](#0-6) 

**Detection/Operational Constraints:**
- The malicious round data gets permanently stored in contract state: [8](#0-7) 

- Subsequent rounds will use this corrupted data as their basis
- Network consensus would break down as multiple miners attempt to mine at the same time

**Probability:** HIGH - Any miner can exploit this during their NextRound block production turn, which occurs regularly in rotation.

### Recommendation

**Code-Level Fix:**
Modify the validation to extract and check `FinalOrderOfNextRound` values directly:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract just the order value
    .Distinct()
    .Count();
```

**Additional Invariant Checks:**
Add a complementary validation to ensure all `FinalOrderOfNextRound` values form a contiguous sequence from 1 to N (where N is the count of miners who mined):

```csharp
var orders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .OrderBy(o => o)
    .ToList();

var minersWhoMined = providedRound.RealTimeMinersInformation.Values
    .Count(m => m.OutValue != null);

// Check for duplicates and proper range
if (orders.Count != orders.Distinct().Count() || 
    orders.Count != minersWhoMined ||
    orders.Min() < 1 || 
    orders.Max() > minersWhoMined)
{
    validationResult.Message = "Invalid FinalOrderOfNextRound values.";
    return validationResult;
}
```

**Test Cases:**
1. Test with duplicate `FinalOrderOfNextRound` values across different miners - should fail validation
2. Test with gaps in order sequence (e.g., [1, 2, 4] missing 3) - should fail validation  
3. Test with valid contiguous orders [1, 2, 3, 4] - should pass validation
4. Test with orders exceeding miner count - should fail validation

### Proof of Concept

**Initial State:**
- 5 miners in the network: A, B, C, D, E
- Current round: miners A, B, C, D successfully produced blocks (OutValue != null)
- Miner E failed to produce a block (OutValue == null)
- Miner E is selected to produce the next block with `NextRound` behavior

**Attack Steps:**

1. Miner E crafts a malicious `NextRoundInput` with the following `RealTimeMinersInformation`:
   - `MinerA`: `Pubkey="A"`, `FinalOrderOfNextRound=1`, `OutValue=Hash(...)`
   - `MinerB`: `Pubkey="B"`, `FinalOrderOfNextRound=1`, `OutValue=Hash(...)` (DUPLICATE ORDER!)
   - `MinerC`: `Pubkey="C"`, `FinalOrderOfNextRound=3`, `OutValue=Hash(...)`
   - `MinerD`: `Pubkey="D"`, `FinalOrderOfNextRound=4`, `OutValue=Hash(...)`
   - `MinerE`: `Pubkey="E"`, `FinalOrderOfNextRound=0`, `OutValue=null`

2. Miner E submits this as the `NextRound` transaction

3. Validation executes:
   ```
   distinctCount = [MinerA, MinerB, MinerC, MinerD].Distinct().Count()
                 = 4  (all four objects are different despite duplicate order)
   
   minersWhoMined = Count(OutValue != null) = 4
   
   4 == 4 → Validation PASSES ✓
   ```

**Expected vs Actual Result:**
- **Expected:** Validation should FAIL because there are duplicate `FinalOrderOfNextRound` values (two miners with order 1)
- **Actual:** Validation PASSES because `Distinct()` compares entire `MinerInRound` objects, not just the order values

**Success Condition:**
The corrupted round is accepted and stored in contract state, with both MinerA and MinerB assigned `Order=1` in the next round, breaking the mining schedule and consensus integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-111)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
