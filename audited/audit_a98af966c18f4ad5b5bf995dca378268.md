### Title
TokenHolder RemoveBeneficiary Allows Scheme Manager to Strip Profit Rights from Locked Token Users

### Summary
The `RemoveBeneficiary` function can be called by the scheme manager on users who registered via `RegisterForProfits`, removing their profit distribution rights while their tokens remain locked for the full `MinimumLockMinutes` period. This breaks the implicit contract where users lock tokens expecting to receive profits for the entire lock duration, causing them to lose all future profit distributions while unable to unlock their principal.

### Finding Description

The vulnerability exists in the `RemoveBeneficiary` function which lacks any validation to protect users who have locked tokens via `RegisterForProfits`. [1](#0-0) 

When users call `RegisterForProfits`, they lock tokens and are added as beneficiaries expecting to receive profits for the lock duration: [2](#0-1) 

The tokens become locked with a `MinimumLockMinutes` constraint, stored in state: [3](#0-2) 

The critical flaw is that `RemoveBeneficiary` only verifies the caller is the scheme manager (via `GetValidScheme(Context.Sender)`) but performs no checks for:
1. Whether the beneficiary has a `lockId` in `State.LockIds[Context.Sender][input.Beneficiary]`
2. Whether the lock period has expired before removing profit rights
3. Any distinction between beneficiaries added via `AddBeneficiary` (no lock) versus `RegisterForProfits` (tokens locked)

When removed, the user cannot claim profits but the `Withdraw` function still enforces the full lock period: [4](#0-3) 

This creates a scenario where the user's commitment (locked tokens) is enforced but the manager's commitment (profit distribution) can be unilaterally broken.

### Impact Explanation

**Direct Financial Loss**: Users who lock tokens via `RegisterForProfits` for `MinimumLockMinutes` expecting profit distributions throughout the lock period can have their profit rights revoked by the scheme manager at any time. The user loses all future profit distributions from removal time until the lock expires, while their tokens remain inaccessible.

**Example Scenario**: 
- User locks 10,000 tokens for 90 days (129,600 minutes) expecting daily profit distributions
- After 1 day, manager calls `RemoveBeneficiary` 
- User has 89 days of locked tokens with zero profit distributions
- User loses all expected profits for 89 days while unable to access their 10,000 tokens

**Affected Parties**: All users who use `RegisterForProfits` to participate in token holder schemes are vulnerable to arbitrary removal by scheme managers.

**Severity**: Critical - This breaks the fundamental trust model where users voluntarily lock tokens in exchange for profits. The asymmetric power allows managers to extract value (user's locked liquidity) while unilaterally terminating the benefit (profit sharing).

### Likelihood Explanation

**Attacker Profile**: The scheme manager (who creates the scheme via `CreateScheme`) has this capability by design.

**Attack Complexity**: Trivial - single function call to `RemoveBeneficiary` with the target beneficiary address.

**Preconditions**: 
- User must have registered via `RegisterForProfits` (normal usage)
- Manager must call `RemoveBeneficiary` before user's lock period expires

**Economic Feasibility**: Highly practical - no special resources needed, just manager authority which is legitimate but can be misused.

**Detection**: Difficult to prevent as this is a legitimate function call from the manager's perspective. Users would only detect after attempting to claim profits and finding they're no longer beneficiaries.

**Probability**: High if manager is malicious, compromised, or makes governance errors. The lack of any protective checks makes this easily executable.

### Recommendation

Add protection for users with locked tokens in the `RemoveBeneficiary` function:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // NEW: Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    if (lockId != null)
    {
        // Beneficiary registered via RegisterForProfits with locked tokens
        var lockTimestamp = State.LockTimestamp[lockId];
        Assert(lockTimestamp.AddMinutes(scheme.MinimumLockMinutes) <= Context.CurrentBlockTime,
            "Cannot remove beneficiary with locked tokens before lock period expires.");
    }
    
    // Existing removal logic...
}
```

**Alternative Approach**: Allow early removal but also unlock tokens proportionally:
```csharp
if (lockId != null)
{
    // If removing during lock period, unlock the tokens
    var lockedAmount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
    {
        Address = input.Beneficiary,
        LockId = lockId,
        Symbol = scheme.Symbol
    }).Amount;
    
    State.TokenContract.Unlock.Send(new UnlockInput
    {
        Address = input.Beneficiary,
        LockId = lockId,
        Amount = lockedAmount,
        Symbol = scheme.Symbol
    });
    
    State.LockIds[Context.Sender].Remove(input.Beneficiary);
}
```

**Test Cases to Add**:
1. Attempt to remove beneficiary with locked tokens before lock expires → should fail or trigger unlock
2. Remove beneficiary with locked tokens after lock expires → should succeed
3. Remove beneficiary added via `AddBeneficiary` (no lock) → should succeed anytime
4. Verify removed RegisterForProfits users cannot claim profits
5. Verify lock period enforcement after removal attempt

### Proof of Concept

**Initial State**:
- Scheme created with `MinimumLockMinutes = 43200` (30 days)
- User has 10,000 ELF tokens approved for TokenHolder contract
- Profit scheme has 1,000 ELF distributed as profits

**Exploit Steps**:

1. **User registers for profits** (T=0):
   ```
   RegisterForProfits({
     SchemeManager: ManagerAddress,
     Amount: 10000
   })
   ```
   - User's 10,000 ELF locked for 30 days
   - User added as beneficiary with 10,000 shares
   - Lock timestamp recorded

2. **User claims initial profits** (T=1 day):
   ```
   ClaimProfits({
     SchemeManager: ManagerAddress,
     Beneficiary: UserAddress
   })
   ```
   - User receives their share of profits successfully

3. **Manager removes user from beneficiaries** (T=2 days):
   ```
   RemoveBeneficiary({
     Beneficiary: UserAddress,
     Amount: 0  // Complete removal
   })
   ```
   - Transaction succeeds (no lock period check)
   - User removed from profit scheme
   - Tokens remain locked for 28 more days

4. **User attempts to claim profits** (T=3 days):
   ```
   ClaimProfits({
     SchemeManager: ManagerAddress,
     Beneficiary: UserAddress
   })
   ```
   - Returns no profits (user is no longer beneficiary)

5. **User attempts early withdrawal** (T=10 days):
   ```
   Withdraw(ManagerAddress)
   ```
   - Transaction fails: "Cannot withdraw" (lock period not expired)

6. **User finally withdraws** (T=31 days):
   ```
   Withdraw(ManagerAddress)
   ```
   - Transaction succeeds
   - User recovers 10,000 ELF principal
   - **User lost 29 days of expected profit distributions**

**Expected Result**: `RemoveBeneficiary` should fail or trigger proportional unlock when called on users with locked tokens before lock period expires.

**Actual Result**: `RemoveBeneficiary` succeeds, user loses all future profits while tokens remain locked for the full duration.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-17)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }

    public MappedState<Hash, Timestamp> LockTimestamp { get; set; }
```
