# Audit Report

## Title
Missing Threshold Sum Validation Allows Creation of Unreleasable Referendum Organizations

## Summary
The Referendum contract's `Validate(Organization)` function fails to validate that the sum of `MinimalApprovalThreshold`, `MaximalRejectionThreshold`, and `MaximalAbstentionThreshold` can satisfy `MinimalVoteThreshold`. This allows creation of organizations where proposals can mathematically never reach the release threshold, causing permanent governance deadlock.

## Finding Description

The Referendum contract's validation function only checks that `MinimalApprovalThreshold <= MinimalVoteThreshold` and that individual thresholds are non-negative, but critically omits validation of the sum relationship. [1](#0-0) 

The proposal release logic requires ALL of these conditions simultaneously:
1. Total votes (Approval + Rejection + Abstention) >= `MinimalVoteThreshold`
2. `RejectionCount` <= `MaximalRejectionThreshold`
3. `AbstentionCount` <= `MaximalAbstentionThreshold`
4. `ApprovalCount` >= `MinimalApprovalThreshold` [2](#0-1) 

If the maximum valid vote combination totals less than `MinimalVoteThreshold`, no proposal can ever pass. For example, setting `MinimalVoteThreshold=1000`, `MinimalApprovalThreshold=500`, `MaximalRejectionThreshold=200`, `MaximalAbstentionThreshold=200` creates an impossible scenario: the maximum allowed total is 500+200+200=900, which cannot reach the required 1000 minimum votes.

In stark contrast, both Association and Parliament contracts include explicit checks preventing this mathematical impossibility. The Association contract validates that `MaximalAbstentionThreshold + MinimalApprovalThreshold <= organizationMemberCount` and similarly for rejection. [3](#0-2) 

The Parliament contract enforces identical constraints: `MaximalAbstentionThreshold + MinimalApprovalThreshold <= AbstractVoteTotal` and the same for rejection. [4](#0-3) 

The flawed validation is called during organization creation via the public `CreateOrganization` method, accepting invalid configurations without error. [5](#0-4) 

The same validation is also used when changing thresholds via `ChangeOrganizationThreshold`, which can only be executed by the organization itself through a proposal, creating a permanent deadlock scenario when thresholds are misconfigured. [6](#0-5) 

## Impact Explanation

**Governance Deadlock**: Any organization created with inconsistent thresholds becomes permanently unable to execute proposals. The `Release` method will always fail the threshold check because the mathematical requirements cannot be satisfied. [7](#0-6) 

**Permanent Lock**: Funds or permissions controlled by such organizations become irretrievable. Since `ChangeOrganizationThreshold` itself requires a passing proposal to execute (it must be called by the organization address), the deadlock cannot be fixed once created.

**Affected Parties**:
- Organization creators who unintentionally misconfigure thresholds
- Token holders who lock tokens for voting via `Approve`, `Reject`, or `Abstain` methods, as their tokens remain locked in unreleasable proposals [8](#0-7) 
- Any contracts or assets controlled by the dysfunctional organization

**Severity Justification**: Medium - causes complete operational DoS of governance functionality but requires configuration error or malicious setup during organization creation (not directly exploitable against existing well-configured organizations).

## Likelihood Explanation

**Reachable Entry Points**: `CreateOrganization` and `CreateOrganizationBySystemContract` are public methods accessible to any caller without special privileges. [9](#0-8) 

**Feasible Preconditions**:
- No authorization required to create referendum organizations
- Simple arithmetic misconfiguration is realistic (users may not understand the mathematical relationship between thresholds)
- No warnings or checks exist to prevent this configuration

**Execution Practicality**: A single transaction creates the broken organization. No complex state manipulation or multiple steps required.

**Detection Constraints**: Users may not realize the configuration is impossible until after creating proposals, locking tokens through allowances and voting, and attempting to release proposalsâ€”by which point tokens are already locked.

## Recommendation

Add sum validation to the `Validate(Organization)` method in `Referendum_Helper.cs`, mirroring the checks in Association and Parliament contracts:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           // Add sum validations:
           proposalReleaseThreshold.MaximalAbstentionThreshold + 
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MaximalRejectionThreshold + 
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_WithImpossibleThresholds_Test()
{
    // Create organization with mathematically impossible thresholds
    // MinimalVoteThreshold = 1000
    // MinimalApprovalThreshold = 500
    // MaximalRejectionThreshold = 200  
    // MaximalAbstentionThreshold = 200
    // Maximum possible votes: 500 + 200 + 200 = 900 < 1000 (IMPOSSIBLE)
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 500,
            MinimalVoteThreshold = 1000,
            MaximalAbstentionThreshold = 200,
            MaximalRejectionThreshold = 200
        },
        ProposerWhiteList = new ProposerWhiteList
        {
            Proposers = { DefaultSender }
        },
        TokenSymbol = "ELF"
    };
    
    // This should fail but currently succeeds
    var transactionResult = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    var organizationAddress = transactionResult.Output;
    
    // Create a proposal
    var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Even with maximum allowed votes in each category, proposal cannot reach MinimalVoteThreshold
    await ApproveAllowanceAsync(Accounts[1].KeyPair, 500, proposalId);
    await ApproveAsync(Accounts[1].KeyPair, proposalId);
    
    await ApproveAllowanceAsync(Accounts[2].KeyPair, 200, proposalId);
    await RejectAsync(Accounts[2].KeyPair, proposalId);
    
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 200, proposalId);
    await AbstainAsync(Accounts[3].KeyPair, proposalId);
    
    // Total votes = 500 + 200 + 200 = 900
    // All thresholds satisfied: Approval=500>=500, Rejection=200<=200, Abstention=200<=200
    // But total 900 < 1000 MinimalVoteThreshold - proposal can NEVER be released
    
    ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved.");
    
    // Tokens are permanently locked - organization is permanently broken
}
```

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L151-154)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-51)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }

    public override Address CreateOrganizationBySystemContract(CreateOrganizationBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
        var organizationAddress = CreateOrganization(input.OrganizationCreationInput);
        if (!string.IsNullOrEmpty(input.OrganizationAddressFeedbackMethod))
            Context.SendInline(Context.Sender, input.OrganizationAddressFeedbackMethod, organizationAddress);

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-113)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.RejectionCount = proposal.RejectionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Reject);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.AbstentionCount = proposal.AbstentionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Abstain);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
