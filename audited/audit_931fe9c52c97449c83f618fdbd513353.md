# Audit Report

## Title
Period Boundary Validation Bypass Causes Permanent Share Dilution in Profit Distribution

## Summary
The `AddBeneficiary` method in the Profit contract fails to validate that `EndPeriod >= StartPeriod` after calculating `StartPeriod` with the delay offset, allowing profit details with inverted period boundaries to be created. These malformed details have their shares permanently added to `TotalShares` but are filtered out during claims, causing irreversible dilution of all legitimate beneficiaries' profit distributions.

## Finding Description

The vulnerability exists in the `AddBeneficiary` method's period validation logic. [1](#0-0) 

When a scheme has `DelayDistributePeriodCount > 0`, the `StartPeriod` is calculated as `scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)` [2](#0-1) , while `EndPeriod` comes from user input. The only validation performed is: [3](#0-2) 

**There is no validation that `EndPeriod >= StartPeriod` after the delay is applied.**

This allows the following scenario when `CurrentPeriod = 100` and `DelayDistributePeriodCount = 1`:
- User provides `EndPeriod = 100` 
- Validation passes: `100 >= 100` âœ“
- But `StartPeriod = 101`, resulting in `StartPeriod > EndPeriod`
- Shares are added to `TotalShares` [4](#0-3) 

During profit claims, the malformed detail is filtered out by the `availableDetails` check: [5](#0-4) 

When `LastProfitPeriod == 0` (never claimed before), the condition `d.EndPeriod >= d.StartPeriod` fails, excluding the detail from `availableDetails`. Share cleanup only occurs for details in `profitDetailsToRemove`: [6](#0-5) 

Since the malformed detail never enters `availableDetails`, it's never added to `profitDetailsToRemove`, and its shares remain in `TotalShares` permanently.

The `FixProfitDetail` method has the same validation gap: [7](#0-6) 

## Impact Explanation

**Direct Fund Impact:**

When orphaned shares remain in `TotalShares`, all future profit distributions use an inflated denominator. The profit calculation uses `SafeCalculateProfits(shares, totalAmount, totalShares)`, causing legitimate beneficiaries to receive proportionally reduced amounts.

**Example scenario:**
- Scheme with Alice (1,000 shares)
- Manager adds Bob with 9,000 shares where `StartPeriod > EndPeriod`
- `TotalShares = 10,000`, but Bob can never claim
- Distribution of 100,000 tokens: Alice receives `(1,000 / 10,000) * 100,000 = 10,000`
- Alice gets only 10% instead of 100%
- Remaining 90,000 tokens stay locked in period virtual addresses indefinitely

**Affected Systems:**

The Citizen Welfare scheme in the Treasury contract is initialized with `DelayDistributePeriodCount = 1`: [8](#0-7) 

This affects the core economic distribution mechanism for citizen welfare rewards in the AElf ecosystem.

## Likelihood Explanation

**Attack Vectors:**

1. **Unintentional Misconfiguration**: Scheme managers may not understand the interaction between `DelayDistributePeriodCount` and `EndPeriod` validation, accidentally creating malformed profit details.

2. **Malicious Manager Exploitation**: A scheme manager can intentionally add beneficiaries with invalid periods to dilute other beneficiaries' shares for their own benefit.

3. **FixProfitDetail Exploitation**: Even after initial setup, managers can use `FixProfitDetail` to modify existing valid details into malformed ones.

**Feasibility:**
- Entry points are public methods accessible to scheme managers
- Precondition: Scheme with `DelayDistributePeriodCount > 0` (common pattern)
- Execution: Single transaction with specific parameter values
- Detection: Difficult without inspecting `ProfitDetailsMap` entries

**Probability:** High for accidental triggers due to non-obvious validation gap; Medium for deliberate exploitation depending on scheme manager trust assumptions.

## Recommendation

Add validation to ensure `EndPeriod >= StartPeriod` after calculating the delayed start period:

```csharp
public override Empty AddBeneficiary(AddBeneficiaryInput input)
{
    AssertValidInput(input);
    if (input.EndPeriod == 0)
        input.EndPeriod = long.MaxValue;

    var schemeId = input.SchemeId;
    var scheme = State.SchemeInfos[schemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(
        Context.Sender == scheme.Manager || Context.Sender ==
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
        "Only manager can add beneficiary.");

    Assert(input.EndPeriod >= scheme.CurrentPeriod,
        $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

    // Calculate the actual start period with delay
    var actualStartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount);
    
    // ADD THIS VALIDATION
    Assert(input.EndPeriod >= actualStartPeriod,
        $"Invalid end period. End Period: {input.EndPeriod} must be >= Start Period: {actualStartPeriod}");

    scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
    State.SchemeInfos[schemeId] = scheme;

    var profitDetail = new ProfitDetail
    {
        StartPeriod = actualStartPeriod,
        EndPeriod = input.EndPeriod,
        Shares = input.BeneficiaryShare.Shares,
        Id = input.ProfitDetailId
    };
    // ... rest of method
}
```

Apply similar validation in `FixProfitDetail` method to prevent modification into invalid states.

## Proof of Concept

```csharp
[Fact]
public async Task ProfitContract_PeriodBoundaryValidationBypass_CausesPermanentShareDilution()
{
    const int delayDistributePeriodCount = 1;
    const long initialAmount = 100_000;
    var creator = Creators[0];
    var alice = Normal[0];
    var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);
    var aliceAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);

    // Create scheme with delay
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = delayDistributePeriodCount
    });

    var schemeIds = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creatorAddress })).SchemeIds;
    var schemeId = schemeIds.First();

    // Add Alice as legitimate beneficiary with 1000 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = aliceAddress, Shares = 1000 },
        EndPeriod = 10
    });

    // Get initial scheme state
    var schemeBefore = await creator.GetScheme.CallAsync(schemeId);
    schemeBefore.CurrentPeriod.ShouldBe(1);
    
    // Add malformed beneficiary: EndPeriod = CurrentPeriod but StartPeriod will be CurrentPeriod + Delay
    // This creates StartPeriod (2) > EndPeriod (1)
    var bobAddress = Address.FromPublicKey(NormalKeyPair[1].PublicKey);
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = bobAddress, Shares = 9000 },
        EndPeriod = 1  // Equal to CurrentPeriod, but StartPeriod will be 2
    });

    // Verify TotalShares includes both Alice and Bob
    var schemeAfter = await creator.GetScheme.CallAsync(schemeId);
    schemeAfter.TotalShares.ShouldBe(10000); // 1000 + 9000

    // Contribute and distribute for period 1
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Spender = ProfitContractAddress,
        Symbol = "ELF",
        Amount = initialAmount
    });
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = initialAmount,
        Symbol = "ELF"
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1
    });

    // Move to period 2 and distribute
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 2,
        AmountsMap = { { "ELF", 0 } }
    });

    // Alice tries to claim - should get profits
    var aliceBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = aliceAddress, Symbol = "ELF" })).Balance;
    
    await GetProfitContractTester(NormalKeyPair[0]).ClaimProfits.SendAsync(
        new ClaimProfitsInput { SchemeId = schemeId });

    var aliceBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = aliceAddress, Symbol = "ELF" })).Balance;
    
    var aliceProfit = aliceBalanceAfter - aliceBalanceBefore;
    
    // Alice should receive only 10% (1000/10000) instead of 100%
    // With 100,000 distributed, Alice gets ~10,000 instead of 100,000
    aliceProfit.ShouldBe(10000); // Diluted!
    
    // Bob cannot claim (StartPeriod > EndPeriod filters him out)
    var bobBalanceBefore = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = bobAddress, Symbol = "ELF" })).Balance;
    
    await GetProfitContractTester(NormalKeyPair[1]).ClaimProfits.SendAsync(
        new ClaimProfitsInput { SchemeId = schemeId });

    var bobBalanceAfter = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput { Owner = bobAddress, Symbol = "ELF" })).Balance;
    
    (bobBalanceAfter - bobBalanceBefore).ShouldBe(0); // Bob gets nothing
    
    // Verify Bob's shares are still in TotalShares (permanent dilution)
    var finalScheme = await creator.GetScheme.CallAsync(schemeId);
    finalScheme.TotalShares.ShouldBe(10000); // Still includes Bob's orphaned 9000 shares
}
```

## Notes

This vulnerability represents a critical flaw in the validation logic that violates the protocol invariant: the sum of all claimable shares should equal `TotalShares`. The missing validation after applying the delay offset creates a permanent inconsistency that cannot be remedied without contract upgrades. The impact is particularly severe for schemes with delayed distribution (like the Citizen Welfare scheme), where such misconfigurations could lock significant portions of distributed rewards indefinitely.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-792)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
        var sharesToRemove =
            profitDetailsToRemove.Aggregate(0L, (current, profitDetail) => current.Add(profitDetail.Shares));
        scheme.TotalShares = scheme.TotalShares.Sub(sharesToRemove);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```
