# Audit Report

## Title
Hex Case Mismatch in Pubkey Replacement Causes Miner Denial of Service

## Summary
The `RecordCandidateReplacement` method in the consensus contract stores replacement pubkeys as raw string dictionary keys without normalizing hex case. When the affected miner later requests consensus commands, their pubkey is converted to lowercase hex via `ToHex()`, causing a dictionary lookup failure due to case-sensitive string comparison. This prevents the miner from producing blocks.

## Finding Description

The vulnerability exists in the pubkey replacement flow across the Election and Consensus contracts:

**Root Cause:** The `RecordCandidateReplacement` method directly uses the raw `input.NewPubkey` string as a dictionary key in `RealTimeMinersInformation` without normalizing the hex case. [1](#0-0) 

The protobuf definition shows pubkeys are plain strings: [2](#0-1) 

**Entry Point:** Candidate admins call `ReplaceCandidatePubkey` which passes the raw user-provided strings to the consensus contract: [3](#0-2) 

**Failure Point:** When miners request consensus commands, the system converts their pubkey bytes to lowercase hex using `ToHex()`, then performs a case-sensitive dictionary lookup via `IsInMinerList()`: [4](#0-3) [5](#0-4) 

**Hex Conversion:** The `ToHex()` method always produces lowercase hex characters ('a'-'f') due to adding `0x20` to the base value: [6](#0-5) 

**Dictionary Type:** The `RealTimeMinersInformation` is defined as a case-sensitive string-keyed map: [7](#0-6) 

**Initial Miner Creation:** All initial pubkeys are normalized to lowercase via `ToHex()`, establishing the expected format: [8](#0-7) 

## Impact Explanation

**Direct Harm:**
- The affected miner cannot retrieve valid consensus commands, completely preventing block production
- Network consensus capacity is permanently reduced by one miner until remediation
- The miner loses all block rewards during the outage period
- If multiple miners are affected, network liveness and block production rate are significantly degraded

**Affected Parties:**
- The miner whose pubkey was replaced with non-lowercase hex cannot participate in consensus
- The blockchain network suffers from reduced consensus participation and potential performance degradation
- Token holders may experience slower transaction confirmations

**Severity Justification (Medium):**
- No direct fund theft or permanent token loss
- Operational disruption to critical consensus mechanism
- Can be remediated by replacing the pubkey again with correct lowercase format
- Requires candidate admin privileges to trigger, limiting attack surface
- Impact severity scales with the number of affected miners

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a candidate admin authorized to call `ReplaceCandidatePubkey` in the Election Contract
- Must provide new pubkey in non-lowercase format (uppercase or mixed case hex string)
- No special technical knowledge beyond basic hex string formatting

**Attack Complexity:**
- Very low complexity: Single transaction with uppercase hex string parameter
- No timing requirements, race conditions, or complex state dependencies
- Deterministic and reproducible outcome

**Feasibility Conditions:**
- All test cases use `.ToHex()` which produces lowercase, so this edge case is not tested: [9](#0-8) 

- The contract validation only checks hex string convertibility (case-insensitive), not case normalization: [10](#0-9) 

- Manual API calls, CLI tools, or UI inputs could easily provide uppercase hex strings
- Nothing in the contract enforces lowercase format

**Probability Assessment:**
- Moderate probability: More likely to occur as accidental admin error than malicious attack
- Would be immediately detected when the affected miner fails to produce blocks
- Natural testing patterns (using `.ToHex()`) mask this vulnerability

## Recommendation

Normalize the pubkey hex string to lowercase before storing it as a dictionary key. Add the following normalization in `RecordCandidateReplacement`:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // Normalize the new pubkey to lowercase to ensure consistency
    var normalizedNewPubkey = input.NewPubkey.ToLower();
    
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = normalizedNewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(normalizedNewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = normalizedNewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = normalizedNewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Alternatively, add validation in `ReplaceCandidatePubkey` to reject non-lowercase hex strings or automatically normalize before sending to consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseHex_CausesConsensusDenialOfService()
{
    // Setup: Create a miner and become a candidate
    var minerKeyPair = ValidationDataCenterKeyPairs.First();
    var candidateAdmin = ValidationDataCenterKeyPairs.Last();
    await AnnounceElectionAsync(minerKeyPair, Address.FromPublicKey(candidateAdmin.PublicKey));
    
    // Elect the miner and start consensus
    await InitialElectionAsync();
    
    // Replace with UPPERCASE hex pubkey
    var newKeyPair = ValidationDataCenterKeyPairs.Skip(1).First();
    var uppercaseNewPubkey = newKeyPair.PublicKey.ToHex().ToUpper(); // Force uppercase
    
    var adminStub = GetTester<ElectionContractImplContainer.ElectionContractImplStub>(
        ElectionContractAddress, candidateAdmin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = minerKeyPair.PublicKey.ToHex(),
        NewPubkey = uppercaseNewPubkey // Uppercase format
    });
    
    // Verify: The new miner cannot get consensus commands
    var consensusStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ConsensusContractAddress, newKeyPair);
    var command = await consensusStub.GetConsensusCommand.CallAsync(
        new BytesValue { Value = ByteString.CopyFrom(newKeyPair.PublicKey) });
    
    // Expected: Returns InvalidConsensusCommand because dictionary lookup fails
    command.NextBlockMiningLeftMilliseconds.ShouldBe(-1); // Invalid command indicator
    
    // Verify: Round information has UPPERCASE key but lookup uses lowercase
    var round = await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    round.RealTimeMinersInformation.Keys.ShouldContain(uppercaseNewPubkey); // Stored uppercase
    round.RealTimeMinersInformation.Keys.ShouldNotContain(newKeyPair.PublicKey.ToHex()); // Lowercase not found
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** protobuf/aedpos_contract.proto (L243-247)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** protobuf/aedpos_contract.proto (L452-455)
```text
message RecordCandidateReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-27)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L38-41)
```csharp
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L38-42)
```csharp
        await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
        {
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-18)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
```
