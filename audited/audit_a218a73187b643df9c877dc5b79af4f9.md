### Title
InitialMiners Duplicate Entry Vulnerability Leading to Consensus Failure

### Summary
The `ReplaceCandidatePubkey()` function validates that the new pubkey is not already a candidate but fails to check if it already exists in `InitialMiners`. Since initial miners exist in `InitialMiners` but not in `Candidates`, replacing one initial miner with another initial miner's pubkey creates duplicate entries in `InitialMiners`, which causes consensus round generation to fail when multiple evil miners need replacement.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The validation on line 191 only checks if `newPubkeyBytes` exists in the `Candidates` list, but does not verify if it already exists in `InitialMiners`. This creates a state inconsistency because:

1. During initialization, `InitialMiners` is populated with genesis miners, but `Candidates` starts empty: [2](#0-1) 

2. Initial miners are explicitly forbidden from announcing election (thus cannot be added to `Candidates`): [3](#0-2) 

3. When replacing an initial miner, the code removes the old pubkey from `InitialMiners` and adds the new pubkey WITHOUT checking if the new pubkey already exists: [4](#0-3) 

**Why Protections Fail:**
The function performs three separate operations (lines 192-197 for Candidates, lines 220-226 for InitialMiners), but the validation only covers the Candidates list. The `IsCurrentCandidateOrInitialMiner` check on line 175 validates the OLD pubkey but doesn't prevent the NEW pubkey from being an existing initial miner.

### Impact Explanation

**Consensus Disruption:**
When `GetMinerReplacementInformation` is called to replace evil miners, it iterates over `InitialMiners` to select alternative candidates: [5](#0-4) 

If `InitialMiners` contains duplicates (e.g., ["A", "B", "C", "A"]), and multiple evil miners need replacement, the duplicate pubkey will be returned multiple times in the alternatives list.

During consensus round generation, the replacement logic attempts to add each alternative to `RealTimeMinersInformation`: [6](#0-5) 

When the same pubkey is added twice (lines 337-338), the C# Dictionary.Add() method throws an `ArgumentException`, causing the consensus round generation to fail. This prevents the blockchain from progressing until the issue is resolved.

**Who Is Affected:**
The entire network is affected as consensus cannot proceed, effectively creating a Denial of Service condition.

### Likelihood Explanation

**Attacker Capabilities:**
The exploit requires admin privileges for an initial miner, which is typically held by the initial miner themselves or a designated admin address set during initialization. This is a standard operational capability, not a privileged compromise.

**Attack Complexity:**
Low - A single call to `ReplaceCandidatePubkey(OldPubkey=InitialMinerB, NewPubkey=InitialMinerA)` creates the duplicate entry. The parameters are straightforward and the function is publicly accessible to authorized admins.

**Feasibility Conditions:**
- At least two initial miners must exist (typical in production)
- The attacker must be the admin for one initial miner (normal operational role)
- No additional preconditions required

**Detection & Operational Constraints:**
The duplicate entry is created silently without any event or error. The issue only manifests later when evil miner replacement occurs during consensus operations. This makes it difficult to detect and prevent proactively.

**Probability:**
Medium-High. This could occur accidentally through legitimate replacement operations by admins who are unaware of the constraint, or maliciously by a compromised admin seeking to disrupt consensus.

### Recommendation

**Code-Level Mitigation:**
Add an additional validation in `ReplaceCandidatePubkey()` before line 220 to check if the new pubkey already exists in `InitialMiners`:

```csharp
var initialMiners = State.InitialMiners.Value;
if (initialMiners.Value.Contains(oldPubkeyBytes))
{
    Assert(!initialMiners.Value.Contains(newPubkeyBytes), 
        "New pubkey is already an initial miner.");
    initialMiners.Value.Remove(oldPubkeyBytes);
    initialMiners.Value.Add(newPubkeyBytes);
    State.InitialMiners.Value = initialMiners;
}
```

**Alternative Mitigation:**
Add deduplication in `GetMinerReplacementInformation()` when selecting from `InitialMiners`:

```csharp
var selectedInitialMiners = State.InitialMiners.Value.Value
    .Select(k => k.ToHex())
    .Distinct()  // Add this
    .Where(k => !State.BannedPubkeyMap[k])
    .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
```

**Test Cases:**
1. Test replacing an initial miner with another existing initial miner's pubkey (should fail)
2. Test that `InitialMiners` never contains duplicates after any replacement operation
3. Test consensus round generation with evil miner replacement when initial miners are available

### Proof of Concept

**Required Initial State:**
- InitialMiners = ["PubkeyA", "PubkeyB", "PubkeyC"]
- Candidates = [] (empty, as initial miners cannot announce election)
- Admin for PubkeyB is set and authorized

**Transaction Steps:**

1. **Create Duplicate Entry:**
   - Call `ReplaceCandidatePubkey(OldPubkey="PubkeyB", NewPubkey="PubkeyA")`
   - Line 175 check passes: PubkeyB is an initial miner ✓
   - Line 191 check passes: PubkeyA is NOT in Candidates ✓
   - Lines 192-197: Skipped (PubkeyB not in Candidates)
   - Lines 220-226: Remove PubkeyB, Add PubkeyA
   - **Result**: InitialMiners = ["PubkeyA", "PubkeyC", "PubkeyA"] - DUPLICATE

2. **Trigger Consensus Failure:**
   - Mark three miners as evil (requiring 3 replacements)
   - Consensus calls `GetMinerReplacementInformation()`
   - Returns alternativeCandidates = ["PubkeyA", "PubkeyC", "PubkeyA"]
   - During `GenerateNextRoundInformation()`:
     - Iteration 1: Remove EvilMiner1, Add "PubkeyA" → Success
     - Iteration 2: Remove EvilMiner2, Add "PubkeyC" → Success
     - Iteration 3: Remove EvilMiner3, Add "PubkeyA" → **EXCEPTION: Key already exists**

**Expected vs Actual Result:**
- Expected: Replacement should fail with proper validation
- Actual: Duplicate created silently, consensus fails later with unhandled exception

**Success Condition:**
InitialMiners contains duplicate entries, and subsequent consensus operations with miner replacement trigger dictionary key collision exceptions, preventing round generation.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L26-43)
```csharp
        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L191-191)
```csharp
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L386-391)
```csharp
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```
