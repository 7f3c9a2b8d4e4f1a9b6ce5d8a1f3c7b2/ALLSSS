### Title
Storage Bomb Attack via Unvalidated Options in Vote Contract Registration

### Summary
The `Register` method in the Vote contract accepts voting options without validating them against the defined `MaximumOptionsCount` (64) and `OptionLengthLimit` (1024) constants. While the AElf state size limit of 128KB provides partial protection, attackers can still bypass the intended 64KB constraint and create thousands of voting items storing approximately 130KB each for only 10 ELF per item, leading to uncontrolled blockchain state growth and potential network degradation.

### Finding Description

The Vote contract defines two constants intended to limit option storage: [1](#0-0) 

However, the `Register` method directly copies input options to the `VotingItem` without any validation: [2](#0-1) 

The validation helper `AssertValidNewVotingItem` only checks timestamps and item uniqueness, but completely ignores the options field: [3](#0-2) 

In contrast, the `AddOption` and `AddOptions` methods properly enforce these limits: [4](#0-3)  and [5](#0-4) 

While the AElf state size limit provides protection at 128KB, this still allows approximately 130KB of data per voting item (accounting for ~164 bytes of VotingItem overhead), which is roughly double the intended 64KB maximum: [6](#0-5) 

### Impact Explanation

**Operational Impact - Blockchain State Bloat:**
- An attacker can create voting items with up to ~130KB of option data instead of the intended 64KB maximum
- At 10 ELF per voting item (the Register transaction fee), attackers can store ~130KB for approximately $5 (assuming ELF = $0.50), equating to roughly $38 per megabyte: [7](#0-6) 
- Creating 10,000 voting items costs 100,000 ELF (~$50,000) but creates approximately 1.3GB of permanent blockchain state
- All full nodes must store this data indefinitely with no cleanup mechanism
- Degraded node performance, increased storage costs, and potential network instability as state grows unmanageably large
- The attack violates the explicit design constraints meant to limit storage consumption

### Likelihood Explanation

**High Likelihood - Easily Exploitable:**
- **Reachable Entry Point**: The `Register` method is publicly accessible to any user with sufficient ELF tokens
- **Minimal Prerequisites**: Attacker only needs ELF tokens (10 ELF per voting item) to pay transaction fees
- **Simple Execution**: 
  1. Create a `VotingRegisterInput` with hundreds of options or extremely long options (up to state size limit)
  2. Call `Register` method
  3. Repeat process thousands of times
- **Economic Feasibility**: The cost-per-byte ratio is extremely favorable for attackers compared to typical blockchain storage costs
- **No Detection/Prevention**: No rate limiting, quotas, or automated cleanup mechanisms exist
- **Permanent Impact**: Voting items persist forever in blockchain state with no expiration or removal functionality

### Recommendation

**Immediate Fix - Add Options Validation in Register Method:**

Add validation in the `Register` method or `AssertValidNewVotingItem` to enforce the defined constants:

```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    // Existing validations...
    
    // Add options validation
    Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    }
    
    // Ensure no duplicate options
    Assert(input.Options.Count == input.Options.Distinct().Count(), "Duplicate options not allowed.");
    
    // Rest of existing code...
}
```

**Additional Recommendations:**
1. Add regression tests that attempt to register voting items with >64 options and >1024 character options
2. Consider implementing voting item expiration or cleanup mechanisms
3. Consider implementing per-user rate limiting or quotas for voting item creation
4. Review if the 10 ELF fee is sufficient deterrent given the storage impact

### Proof of Concept

**Initial State:**
- Attacker has sufficient ELF balance (e.g., 100,000 ELF)
- Token contract has whitelisted the voting currency

**Attack Sequence:**

1. **Create malicious voting input** with options exceeding intended limits:
```
VotingRegisterInput {
    start_timestamp: current_time
    end_timestamp: current_time + 30 days
    accepted_currency: "ELF"
    is_lock_token: true
    total_snapshot_number: 1
    options: [130 options of ~1000 bytes each] // Bypasses 64 option limit
}
```

2. **Call Register method** - Transaction succeeds with 10 ELF fee deducted

3. **Verify storage impact**:
   - Query `GetVotingItem` - Returns voting item with all 130 options stored
   - Actual storage: ~130KB per item (vs intended 64KB maximum)
   
4. **Repeat attack** 10,000 times:
   - Total cost: 100,000 ELF
   - Total storage: ~1.3GB of permanent blockchain state
   - Result: Significant state bloat affecting all network nodes

**Expected Result:** Registration should fail with validation error
**Actual Result:** Registration succeeds, storing approximately double the intended maximum data per item

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-54)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-296)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }

    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-324)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
