### Title
State Path Mismatch in ACS2 Resource Info Due to Inconsistent Address Serialization

### Summary
The `GetResourceInfo` method in `TokenContract_ACS2_StatePathsProvider` uses `Address.ToBase58()` to construct state paths for transaction fee free allowances, while the actual contract execution uses `Address.ToString()` via `MappedState`. This produces different path representations (with vs. without quotes), causing declared resource paths to never match actual accessed paths, forcing all affected transactions to be marked as conflicting and preventing parallel execution.

### Finding Description

The root cause is in two locations:

**Declaration (GetResourceInfo):** [1](#0-0) 

Lines 156 and 158 use `from.ToBase58()` to declare state paths for `TransactionFeeFreeAllowances` and `TransactionFeeFreeAllowancesLastRefreshTimes`.

**Actual Execution (MappedState):** [2](#0-1) 

Line 83 shows that `MappedState` always uses `kv.Key.ToString()` to convert Address keys to strings when building state paths. Lines 95-108 show the same pattern in `LoadKey()` at line 97.

**Address Serialization Difference:** [3](#0-2) 

`Address.ToDiagnosticString()` returns the Base58 representation wrapped in quotes (line 33), which is what `ToString()` calls via protobuf's default implementation. [4](#0-3) 

`Address.ToBase58()` returns the Base58 representation WITHOUT quotes (lines 92-93).

**Actual State Access:** [5](#0-4) 

Lines 311, 316, 317 show the contract accessing `State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol]` and `State.TransactionFeeFreeAllowances[address][symbol]` using Address objects, which triggers the `ToString()` path.

**Validation Failure:** [6](#0-5) 

Lines 63-68 show the validation logic that compares declared paths (`extracted`) with actually accessed paths (`actual`). When paths don't match, transactions are marked as "wrong" and treated as conflicting (lines 69-70).

The path format difference:
- Declared (using ToBase58()): `TransactionFeeFreeAllowances/2DZER7qH.../ELF`
- Actual (using ToString()): `TransactionFeeFreeAllowances/"2DZER7qH..."/ELF`

These never match due to the presence/absence of quote characters around the address.

### Impact Explanation

**Operational DoS:**
Every transaction (Transfer, TransferFrom) that accesses TransactionFeeFreeAllowances state declares incorrect resource paths in `GetResourceInfo`. When the validation compares declared vs. actual paths, it detects a mismatch and marks these transactions as accessing undeclared state. [7](#0-6) 

Lines 33-35 show that `AddPathForTransactionFee` and `AddPathForTransactionFeeFreeAllowance` are called for EVERY Transfer transaction.

**Affected Scope:**
- All Transfer operations (line 33)
- All TransferFrom operations (shown in similar code at lines 40-64)
- Any transaction accessing transaction fee free allowance mechanisms

**Severity:**
The parallel execution engine cannot correctly identify which transactions can run in parallel, as the resource declaration system is fundamentally broken for a core state mechanism. This forces unnecessary serialization or causes transaction conflicts, severely degrading blockchain throughput and performance.

### Likelihood Explanation

**Automatic Trigger:** This vulnerability triggers automatically on every normal token transfer operation. No attacker action needed.

**Entry Points:** [7](#0-6) 

The `Transfer` method (line 15) is a public entry point accessible to all users.

**No Preconditions:** Requires only:
1. Transaction fee free allowances feature is enabled (common configuration)
2. User performs a normal Transfer or TransferFrom

**Detection:** The issue is logged but may not be immediately visible to users as transactions still execute (just not in parallel). However, performance degradation affects all users.

**Probability:** 100% - Happens on every transaction accessing the affected state paths when the fee-free allowance mechanism is active.

### Recommendation

**Immediate Fix:** Replace all `ToBase58()` calls with `ToString()` in the resource path construction: [1](#0-0) 

Change lines 156 and 158 from:
- `from.ToBase58()` â†’ `from.ToString()`

**Consistency Check:** Audit all other usage of address-to-string conversion in state path construction: [8](#0-7) 

Verify that lines 22, 23, 33, 47, 48, 49, 58, 59 correctly use `ToString()` (they do) and ensure all future code follows this pattern.

**Test Cases:** Add integration tests that:
1. Call `GetResourceInfo` on a Transfer transaction
2. Execute the transaction and capture actual state accesses
3. Verify declared paths match actual paths (currently would fail)
4. Ensure `ConflictingTransactionIdentificationService` does not mark valid transactions as conflicting

**Documentation:** Document that `Address.ToString()` MUST be used for all state path construction to match `MappedState` behavior, never `ToBase58()`.

### Proof of Concept

**Initial State:**
- Token contract deployed and initialized
- Transaction fee free allowances feature configured with at least one symbol
- Test address has balance above threshold to qualify for fee-free allowances

**Steps:**
1. Create Transfer transaction from AddressA to AddressB with ELF token
2. Call `GetResourceInfo(transaction)` - it returns paths using `ToBase58()`: `TransactionFeeFreeAllowances/AddressA_Base58/ELF`
3. Execute the transaction - `MappedState` accesses paths using `ToString()`: `TransactionFeeFreeAllowances/"AddressA_Base58"/ELF`
4. Call `ConflictingTransactionIdentificationService.IdentifyConflictingTransactionsAsync()` with the execution results
5. Observe that the transaction is identified as having "wrong resources" because declared path != actual path
6. Log output shows: `"Conflict keys:TransactionFeeFreeAllowances/"AddressA_Base58"/ELF"`

**Expected:** Declared paths should match actual paths, allowing parallel execution

**Actual:** Paths never match due to quote character mismatch, forcing serialization and marking transactions as conflicting

**Success Condition:** After fixing to use `ToString()` consistently, the same test should show zero conflicting transactions and declared paths matching actual paths exactly.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L15-69)
```csharp
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }

            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }

            default:
                return new ResourceInfo { NonParallelizable = true };
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L148-167)
```csharp
    private void AddPathForTransactionFeeFreeAllowance(ResourceInfo resourceInfo, Address from)
    {
        var symbols = State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols;
        if (symbols != null)
        {
            foreach (var symbol in symbols)
            {
                resourceInfo.WritePaths.Add(GetPath(nameof(TokenContractState.TransactionFeeFreeAllowances),
                    from.ToBase58(), symbol));
                resourceInfo.WritePaths.Add(GetPath(
                    nameof(TokenContractState.TransactionFeeFreeAllowancesLastRefreshTimes), from.ToBase58(), symbol));

                var path = GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesConfigMap), symbol);
                if (!resourceInfo.ReadPaths.Contains(path))
                {
                    resourceInfo.ReadPaths.Add(path);
                }
            }
        }
    }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L78-93)
```csharp
    internal override TransactionExecutingStateSet GetChanges()
    {
        var stateSet = new TransactionExecutingStateSet();
        foreach (var kv in Cache)
        {
            var key = GetSubStatePath(kv.Key.ToString()).ToStateKey(Context.Self);
            if (kv.Value.IsDeleted)
                stateSet.Deletes[key] = true;
            else if (!Equals(kv.Value.OriginalValue, kv.Value.Value))
                stateSet.Writes[key] = ByteString.CopyFrom(SerializationHelper.Serialize(kv.Value.Value));

            stateSet.Reads[key] = true;
        }

        return stateSet;
    }
```

**File:** src/AElf.Types/Types/Address.cs (L27-34)
```csharp
        /// <summary>
        ///     Used to override IMessage's default string representation.
        /// </summary>
        /// <returns></returns>
        public string ToDiagnosticString()
        {
            return $@"""{ToBase58()}""";
        }
```

**File:** src/AElf.Types/Types/Address.cs (L79-94)
```csharp
        /// <summary>
        ///     Converts address into base58 representation.
        /// </summary>
        /// <returns></returns>
        /// <exception cref="ArgumentException"></exception>
        public string ToBase58()
        {
            if (_formattedAddress != null)
                return _formattedAddress;

            if (Value.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid address", nameof(Value));

            var pubKeyHash = Base58CheckEncoding.Encode(Value.ToByteArray());
            return _formattedAddress = pubKeyHash;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L308-320)
```csharp
        {
            if (State.Balances[address][symbol] <
                State.TransactionFeeFreeAllowancesConfigMap[symbol].Threshold) continue;
            var lastRefreshTime = State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol];

            if (lastRefreshTime != null && State.TransactionFeeFreeAllowancesConfigMap[symbol].RefreshSeconds >
                (Context.CurrentBlockTime - lastRefreshTime).Seconds) continue;

            State.TransactionFeeFreeAllowancesLastRefreshTimes[address][symbol] = Context.CurrentBlockTime;
            State.TransactionFeeFreeAllowances[address][symbol] =
                State.TransactionFeeFreeAllowancesConfigMap[symbol].FreeAllowances.Clone();
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L46-74)
```csharp
    private async Task<List<TransactionWithResourceInfo>> FindContractOfWrongResourcesAsync(IChainContext chainContext,
        List<ExecutionReturnSet> returnSets)
    {
        var transactionIds = returnSets.Select(rs => rs.TransactionId);
        var transactions = await _blockchainService.GetTransactionsAsync(transactionIds);

        var txnWithResources =
            await _resourceExtractionService.GetResourcesAsync(chainContext, transactions, CancellationToken.None);
        txnWithResources =
            txnWithResources.Where(t => t.TransactionResourceInfo.ParallelType == ParallelType.Parallelizable);

        var txnWithResourceList = txnWithResources.ToList();
        var readOnlyKeys = txnWithResourceList.GetReadOnlyPaths().Select(p => p.ToStateKey()).ToList();
        var returnSetLookup = returnSets.ToDictionary(rs => rs.TransactionId, rs => rs);
        var wrongTxnWithResources = new List<TransactionWithResourceInfo>();
        foreach (var txnWithResource in txnWithResourceList)
        {
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
            Logger.LogDebug($"Conflict keys:{string.Join(";", actual)}");
            wrongTxnWithResources.Add(txnWithResource);
        }

        return wrongTxnWithResources;
    }
```
