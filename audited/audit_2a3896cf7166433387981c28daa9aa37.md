# Audit Report

## Title
Missing Validation of Next Round Mining Order Allows Position Manipulation

## Summary
The AEDPoS consensus contract fails to validate that miners provide correctly calculated `SupposedOrderOfNextRound` values derived from their cryptographic signatures. Miners can submit arbitrary order values in `UpdateValue` transactions, allowing them to manipulate their mining position in subsequent rounds for unfair advantages in block rewards and MEV extraction.

## Finding Description

The AEDPoS consensus mechanism is designed to deterministically calculate each miner's position in the next round using: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. However, the contract accepts miner-provided order values without validating they match this calculation.

**Root Cause:**

When processing consensus updates, `ProcessUpdateValue` directly accepts the `SupposedOrderOfNextRound` from the transaction input without any verification: [1](#0-0) 

The deterministic calculation exists in `ApplyNormalConsensusData`, which correctly computes the order from the signature: [2](#0-1) 

However, this calculated value is only used when the honest mining software generates consensus data - it is not enforced during validation.

**Validation Failures:**

The `UpdateValueValidationProvider` only verifies that `OutValue` and `Signature` fields are present, but does not check if the order matches the signature-based calculation: [3](#0-2) 

The `NextRoundMiningOrderValidationProvider` only validates during `NextRound` behavior (not `UpdateValue`), and only checks counts rather than correctness: [4](#0-3) [5](#0-4) 

During validation recovery, `RecoverFromUpdateValue` blindly copies all miners' order values from the provided round without recalculation: [6](#0-5) 

**Exploitation Path:**

When the next round is generated, miners are ordered by their `FinalOrderOfNextRound` values (which are set from the unvalidated `SupposedOrderOfNextRound`): [7](#0-6) 

A malicious miner can:
1. Generate a block with valid consensus header extra data containing correctly calculated order values
2. Submit an `UpdateValue` transaction with manipulated `SupposedOrderOfNextRound` value
3. The transaction executes and sets the attacker's chosen order value
4. In the next round, this manipulated order determines the miner's position

## Impact Explanation

This vulnerability breaks the cryptographic randomness guarantee of AEDPoS consensus order determination. The impact includes:

**Direct Economic Harm:**
- Miners can position themselves as first producer in the next round, capturing MEV opportunities
- Unfair distribution of block rewards favoring manipulating miners over honest participants
- Manipulation of extra block producer selection, which uses order-based calculations: [8](#0-7) 

**Protocol Integrity:**
- Undermines the deterministic yet unpredictable miner ordering that consensus security relies upon
- Allows strategic miners to consistently obtain favorable positions across multiple rounds
- Could impact Last Irreversible Block (LIB) calculations which depend on proper miner ordering

**Affected Parties:**
- Honest miners experience reduced rewards due to unfair competition
- Network decentralization degraded as consensus becomes predictable and gameable
- Token holders affected by compromised consensus integrity

**Severity: MEDIUM** - While not directly stealing funds, this provides systematic unfair advantages that translate to significant economic benefits over time and fundamentally undermines consensus fairness.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the current round (privileged but not uncommon position)
- Requires ability to modify mining node software to generate custom transaction inputs
- No additional cryptographic keys or governance permissions needed

**Attack Complexity:**
- LOW - Attacker simply provides different `SupposedOrderOfNextRound` value in the `UpdateValue` transaction
- Both block header and transaction are generated by the same miner, providing full control
- The simplified round in the header can contain correct values while the transaction contains manipulated values: [9](#0-8) [10](#0-9) 

**Detection Difficulty:**
- Manipulated orders appear as normal consensus data in blockchain state
- No events or alerts triggered when orders deviate from expected signature-based calculations  
- Would require offline analysis comparing each miner's signature to their reported order value

**Probability: HIGH** - Straightforward exploit with significant economic incentives and low detection risk.

## Recommendation

Add cryptographic validation that the provided `SupposedOrderOfNextRound` matches the deterministic calculation from the signature. Modify `UpdateValueValidationProvider` to include:

```csharp
private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var signature = minerInRound.Signature;
    var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
    
    var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;
    
    return minerInRound.SupposedOrderOfNextRound == expectedOrder;
}
```

Additionally, validate that `TuneOrderInformation` only contains legitimate conflict resolutions where multiple miners calculated the same order from different signatures, rather than arbitrary adjustments.

## Proof of Concept

A test demonstrating the vulnerability would:

1. Deploy consensus contract with multiple test miners
2. Miner A produces a block during round N
3. Miner A calls `UpdateValue` with `SupposedOrderOfNextRound` = 1 (first position) regardless of their actual signature-based calculation
4. Transaction succeeds without validation error
5. When round N+1 is generated via `NextRound`, Miner A is positioned first despite not having the signature that should produce order 1
6. Miner A gains first-mover advantage in round N+1

The test would verify that the contract accepts arbitrary order values and uses them for next round generation, confirming the absence of validation that should enforce signature-based order calculation.

## Notes

The vulnerability exists because the consensus contract assumes miners will honestly calculate their order from their signature when generating `UpdateValue` transactions. The design includes `TuneOrderInformation` for conflict resolution when multiple miners legitimately calculate the same order, but this mechanism does not validate that the initial `SupposedOrderOfNextRound` values themselves are correctly derived from signatures. A malicious miner with modified node software can exploit this trust assumption to gain systematic advantages in consensus participation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L43-44)
```csharp
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
```
