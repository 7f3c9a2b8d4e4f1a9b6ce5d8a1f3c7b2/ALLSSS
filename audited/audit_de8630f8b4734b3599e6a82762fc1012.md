### Title
Arithmetic Inconsistency Between Threshold Validation and Vote Counting Allows Governance Bypass

### Summary
The threshold validation logic in `Validate(Organization)` assumes all votes come from organization members when checking arithmetic constraints, but the vote counting logic in `CheckEnoughVoteAndApprovals` counts total votes without membership filtering while counting approval/rejection/abstention votes with membership filtering. This inconsistency allows organizations to bypass `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` constraints by removing dissenting members after they vote, enabling proposals to pass that should have been rejected.

### Finding Description

The root cause is an arithmetic mismatch between validation and vote counting logic:

**Validation Logic:** [1](#0-0) 

The validation ensures `MaximalAbstentionThreshold + MinimalApprovalThreshold <= organizationMemberCount` and `MaximalRejectionThreshold + MinimalApprovalThreshold <= organizationMemberCount`, assuming all votes come from current organization members.

**Vote Counting Logic - Filtered Counts:** 
- Approvals: [2](#0-1) 
- Rejections: [3](#0-2) 
- Abstentions: [4](#0-3) 

These counts filter by `organization.OrganizationMemberList.Contains`, counting only votes from current members.

**Vote Counting Logic - Unfiltered Count:** [5](#0-4) 

The total vote threshold check does NOT filter by membership, counting all addresses in the vote lists.

**Exploitation Path:**

Members can vote and then be removed via `RemoveMember`: [6](#0-5) 

The `RemoveMember` function removes members from the organization but does not clean up their existing votes on proposals. After removal:
- Their votes still exist in `proposal.Approvals/Rejections/Abstentions` lists
- Their votes still count toward `MinimalVoteThreshold` (unfiltered count)
- Their votes do NOT count toward `MaximalAbstentionThreshold` or `MaximalRejectionThreshold` (filtered counts)

This creates a discrepancy where the validation's arithmetic assumptions are violated during actual vote counting.

### Impact Explanation

**Governance Bypass:** Organizations can manipulate proposal outcomes by strategically removing members who voted against proposals (rejection or abstention) after they vote. This allows proposals to pass that should have been rejected according to the configured thresholds.

**Violation of Critical Invariants:** The "Organization thresholds" invariant is broken. The `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` become meaningless because they can be circumvented by member removal.

**Concrete Harm:** 
- A proposal requiring strict consensus can pass even when sufficient members voted against it
- Multi-signature governance protections are undermined
- Malicious proposals can be forced through by removing dissenting voters
- All organizations using the Association contract are affected

**Severity Justification:** This is HIGH severity because it directly compromises the governance mechanism's integrity, allowing unauthorized execution of proposals that fail legitimate threshold checks.

### Likelihood Explanation

**Attacker Capabilities:** An attacker needs control over an organization (ability to call `RemoveMember`). This is typically achieved through:
- Malicious organization creator setting exploitable thresholds
- Compromised organization via earlier proposal execution
- Legitimate organization admin abusing their privileges

**Attack Complexity:** LOW. The attack requires only:
1. Wait for members to vote on a proposal
2. Call `RemoveMember` for dissenting voters
3. Call `Release` on the proposal

**Feasibility Conditions:** 
- Organization must have `RemoveMember` capability enabled (standard feature)
- Proposal must be active with existing votes
- Attacker must have organization-level permissions

**Detection Constraints:** The attack is difficult to detect because:
- `RemoveMember` is a legitimate operation
- Vote lists are not automatically cleaned up
- The inconsistency only manifests during threshold checking

**Probability:** HIGH for organizations where a single entity or coordinated group controls member management.

### Recommendation

**Fix 1 - Consistent Filtering:** Apply membership filtering to the total vote count to match the other threshold checks:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Fix 2 - Vote Invalidation:** When removing a member, invalidate their votes on active proposals:

```csharp
public override Empty RemoveMember(Address input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    
    // Remove member's votes from all active proposals
    CleanupMemberVotes(Context.Sender, input);
    
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
    Assert(removeResult, "Remove member failed.");
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    // ... rest of function
}
```

**Fix 3 - Validation Enhancement:** Add validation to ensure the sum of all three thresholds is feasible:

```csharp
// Ensure configuration allows proposals to potentially pass
return /* existing checks */ &&
       proposalReleaseThreshold.MaximalAbstentionThreshold +
       proposalReleaseThreshold.MaximalRejectionThreshold +
       proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount * 2;
```

**Test Cases:**
1. Test proposal release after removing abstaining members
2. Test proposal release after removing rejecting members
3. Test that vote counts remain consistent with membership changes
4. Test edge cases with all members voting then being removed

### Proof of Concept

**Initial State:**
- Organization with 10 members: [M1, M2, M3, M4, M5, M6, M7, M8, M9, M10]
- Thresholds: MinimalApprovalThreshold = 5, MaximalAbstentionThreshold = 4, MinimalVoteThreshold = 10

**Transaction Steps:**

1. **Create Proposal:** Proposer creates proposal P1
2. **Vote Phase:**
   - M1-M5 call `Approve(P1)` (5 approvals)
   - M6-M10 call `Abstain(P1)` (5 abstentions)
3. **Check Release (Should Fail):**
   - Approvals: 5 (filtered) >= 5 ✓
   - Abstentions: 5 (filtered) > 4 ✗ (PROPOSAL SHOULD BE ABSTAINED/FAILED)
   - Total: 10 (unfiltered) >= 10 ✓
   - **Expected:** Proposal CANNOT be released
   - **Actual:** Proposal is abstained due to MaximalAbstentionThreshold
4. **Remove Dissenting Members:**
   - Organization calls `RemoveMember(M10)`
   - Current members: [M1, M2, M3, M4, M5, M6, M7, M8, M9]
5. **Check Release Again (Bypasses Threshold):**
   - Approvals: 5 (filtered, all still members) >= 5 ✓
   - Abstentions: 4 (filtered, M10 no longer counts) <= 4 ✓
   - Total: 10 (unfiltered, M10's vote still counts) >= 10 ✓
   - **Expected:** Proposal still cannot be released (5 abstentions > 4)
   - **Actual:** Proposal CAN be released (only 4 abstentions counted)
6. **Release Proposal:** Proposer calls `Release(P1)` - SUCCESS

**Success Condition:** Proposal P1 is executed despite having 5 abstentions when MaximalAbstentionThreshold = 4, demonstrating the arithmetic inconsistency allows governance bypass.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
