### Title
Insufficient Validation of Cross-Chain Consensus Data Enables Denial of Service via Division by Zero

### Summary
The `UpdateInformationFromCrossChain()` function accepts cross-chain consensus information without validating semantic constraints after protobuf deserialization. Protocol Buffers' `ParseFrom()` only validates binary structure, not business logic rules. An attacker can supply consensus data with an empty miner list, which passes all checks and gets stored. On the next cross-chain update, the `DistributeResourceTokensToPreviousMiners()` function attempts division by the miner count, causing a `DivideByZeroException` that halts all future cross-chain consensus updates.

### Finding Description

The vulnerability exists in the cross-chain consensus information update flow: [1](#0-0) 

At this line, `AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value)` deserializes the protobuf binary data. Protocol Buffers deserialization only validates that the binary format is structurally valid—it does NOT enforce semantic constraints like:
- Non-empty miner lists
- Positive round numbers
- Valid miner key formats [2](#0-1) 

The `AElfConsensusHeaderInformation` message contains a `Round` field, which in turn contains: [3](#0-2) 

The `real_time_miners_information` map can be empty, and `round_number` (int64) can be negative or arbitrarily large.

After parsing, the only validation performed is: [4](#0-3) 

This merely checks that the new round number is greater than the stored one—it does NOT validate:
- Whether the round number is positive
- Whether the miner list is non-empty
- Whether miner keys are valid

The vulnerable execution path: [5](#0-4) 

If `consensusInformation.Round.RealTimeMinersInformation.Keys` is empty, this creates a `MinerList` with zero `Pubkeys`.

On subsequent calls, the division by zero occurs: [6](#0-5) 

When `minerList.Count` is 0, the `Div` extension method performs standard C# division: [7](#0-6) 

This throws `DivideByZeroException`, terminating contract execution.

### Impact Explanation

**Operational Impact - Denial of Service (High Severity)**:

1. **Permanent Cross-Chain Update Failure**: Once an empty miner list is stored, ALL subsequent calls to `UpdateInformationFromCrossChain()` will fail with `DivideByZeroException`. The side chain cannot receive any further consensus updates from the main chain.

2. **Consensus State Corruption**: If the empty miner list is used in round generation: [8](#0-7) 

The `GenerateFirstRoundOfNewTerm()` method with an empty miner list produces: [9](#0-8) 

This creates a `Round` with zero miners, breaking side chain consensus entirely—no blocks can be produced.

3. **Cross-Chain Bridge Breakdown**: The side chain loses synchronization with the main chain, breaking the parent-child chain relationship fundamental to AElf's architecture.

4. **Token Distribution Failure**: Resource token distribution to main chain miners (transaction fees, rental fees) becomes permanently disabled.

### Likelihood Explanation

**Likelihood: Medium-High**

**Reachable Entry Point**: [10](#0-9) 

The function is only callable by the CrossChain contract, which forwards parent chain block data: [11](#0-10) [12](#0-11) 

**Attack Prerequisites**:
1. Parent chain must send consensus extra data with an empty miner list (or attacker influences parent chain block production)
2. Side chain miners must propose and approve cross-chain indexing of this malicious data via governance
3. No validation exists in the CrossChain contract to filter invalid consensus data

**Feasibility**:
- If parent chain is compromised or has a bug producing invalid consensus data, the side chain accepts it blindly
- Cross-chain data is indexed through governance proposals, but validators may not detect semantically invalid protobuf data
- The attack is non-reversible—once stored, the side chain remains DoS'd

**Detection Difficulty**: The vulnerability manifests only on the SECOND call after storing invalid data, making it non-obvious during testing with single updates.

### Recommendation

**Immediate Mitigation** - Add semantic validation after protobuf parsing:

```csharp
public override Empty UpdateInformationFromCrossChain(BytesValue input)
{
    Assert(
        Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
        "Only Cross Chain Contract can call this method.");

    Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

    if (input == null || input.Value.IsEmpty) return new Empty();

    var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

    // ADD VALIDATION HERE:
    Assert(consensusInformation.Round != null, "Round information is required.");
    Assert(consensusInformation.Round.RoundNumber > 0, "Round number must be positive.");
    Assert(consensusInformation.Round.RealTimeMinersInformation != null && 
           consensusInformation.Round.RealTimeMinersInformation.Count > 0, 
           "Miner list cannot be empty.");
    
    // Validate miner keys are properly formatted
    foreach (var minerKey in consensusInformation.Round.RealTimeMinersInformation.Keys)
    {
        Assert(!string.IsNullOrEmpty(minerKey), "Miner key cannot be empty.");
        Assert(minerKey.Length == 66 || minerKey.Length == 130, "Invalid miner key length.");
    }

    if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
        return new Empty();

    // ... rest of existing code
}
```

**Additional Protections**:

1. **Defensive Division**: Add a guard before division:
```csharp
if (minerList.Count == 0)
{
    Context.LogDebug(() => "Miner list is empty, skipping distribution.");
    return;
}
var amount = balance.Div(minerList.Count);
```

2. **Round Number Bounds Check**: Validate round numbers are within reasonable bounds (e.g., not jumping by millions).

3. **Cross-Chain Contract Validation**: Add pre-validation in the CrossChain contract before forwarding consensus data.

**Test Cases**:
1. Attempt to update with empty `RealTimeMinersInformation` map (should be rejected)
2. Attempt to update with negative `RoundNumber` (should be rejected)
3. Attempt to update with zero `RoundNumber` (should be rejected)
4. Attempt to update with invalid miner key formats (should be rejected)
5. Verify legitimate updates with valid miner lists continue to work

### Proof of Concept

**Initial State**:
- Side chain initialized with valid consensus state
- `State.MainChainRoundNumber.Value = 1`
- `State.MainChainCurrentMinerList.Value` contains 3 valid miners from initialization

**Attack Sequence**:

**Step 1**: Attacker crafts malicious consensus information:
```csharp
var maliciousHeader = new AElfConsensusHeaderInformation
{
    Round = new Round
    {
        RoundNumber = 2,  // Higher than current, passes validation
        RealTimeMinersInformation = { }  // EMPTY - no miners!
    },
    Behaviour = AElfConsensusBehaviour.NEXT_ROUND
};
```

**Step 2**: Cross-chain contract forwards this to consensus contract (via governance proposal approval):
- Line 43: `ParseFrom()` succeeds—protobuf structure is valid
- Line 46: Check passes—`2 > 1`
- Line 53: `DistributeResourceTokensToPreviousMiners()` uses OLD miner list (3 miners)—succeeds
- Line 55: `State.MainChainRoundNumber.Value = 2`
- Lines 57-61: **Empty miner list stored** in `State.MainChainCurrentMinerList.Value`

**Step 3**: Next legitimate cross-chain update arrives with round 3:
- Line 53: Calls `DistributeResourceTokensToPreviousMiners()`
- Line 72: `minerList = State.MainChainCurrentMinerList.Value.Pubkeys` → empty list
- Line 81: `balance.Div(0)` → **`DivideByZeroException`**
- **Transaction fails, side chain cannot process any more cross-chain consensus updates**

**Expected Result**: Transaction succeeds, consensus state updated
**Actual Result**: `DivideByZeroException`, permanent DoS of cross-chain consensus updates

**Success Condition**: All future `UpdateInformationFromCrossChain()` calls fail until contract upgrade.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-36)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L43-43)
```csharp
        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L46-47)
```csharp
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L57-61)
```csharp
        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L72-81)
```csharp
        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
```

**File:** protobuf/aedpos_contract.proto (L243-247)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** protobuf/aedpos_contract.proto (L303-310)
```text
message AElfConsensusHeaderInformation {
    // The sender public key.
    bytes sender_pubkey = 1;
    // The round information.
    Round round = 2;
    // The behaviour of consensus.
    AElfConsensusBehaviour behaviour = 3;
}
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L290-291)
```csharp
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-44)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-233)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```
