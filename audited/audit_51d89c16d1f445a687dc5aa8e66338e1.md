# Audit Report

## Title
NextTerm Miner List Injection - Arbitrary Consensus Takeover via Unvalidated RealTimeMinersInformation Keys

## Summary
The `ProcessNextTerm` function accepts miner public keys directly from `NextTermInput.RealTimeMinersInformation` without validating them against the Election Contract's `GetVictories` result. A malicious current-term miner can inject arbitrary miner keys during NextTerm block production, completely bypassing the election system and permanently taking over the consensus mechanism.

## Finding Description

The vulnerability exists in the consensus term transition flow where miner keys are extracted from user-controlled input without cross-validation against the authoritative Election Contract.

**Vulnerable Execution Path:**

When a NextTerm block is processed, the `NextTerm` method calls `ProcessConsensusInformation`, which invokes `ProcessNextTerm`. [1](#0-0) 

In `ProcessNextTerm`, the function converts the input to a Round object via `ToRound()`, which simply copies the `RealTimeMinersInformation` dictionary without any validation. [2](#0-1) 

The function then extracts miner public keys directly from this unvalidated data and passes them to `SetMinerList`: [3](#0-2) 

The `SetMinerList` function only validates whether the miner list for this term was previously set, performing NO validation of key authenticity, format, or correspondence with Election Contract results: [4](#0-3) 

**Missing Validation:**

Pre-execution validation for NextTerm behavior only adds `RoundTerminateValidationProvider`, which validates round/term number increments but completely omits miner list validation: [5](#0-4) 

The `RoundTerminateValidationProvider` only checks basic constraints: [6](#0-5) 

Post-execution validation compares the header round hash against the current state, but this is circular validation since the state was just updated FROM the header data: [7](#0-6) 

**Correct Design Intent:**

The system correctly retrieves legitimate election winners via `TryToGetVictories` during consensus extra data GENERATION: [8](#0-7) 

This calls the Election Contract's `GetVictories` to obtain authorized miners: [9](#0-8) 

However, this validation occurs only during data generation (by the honest block producer), NOT during validation or execution by all nodes. A malicious miner can modify their node software to bypass this check and inject arbitrary keys.

**Attack Vector:**

A malicious current-term miner can:
1. Modify their node software to override `GetConsensusExtraDataForNextTerm` or intercept `NextTermInput` creation
2. Replace legitimate election winners with arbitrary public keys (themselves and accomplices)
3. Produce and sign a NextTerm block with the malicious miner list
4. The block passes all validation checks since none verify against the Election Contract
5. The malicious miner list is permanently installed as the official consensus miners

The only access control is that the sender must be in the current/previous round miner list, which the attacker satisfies as a legitimate current miner: [10](#0-9) 

## Impact Explanation

**Critical Consensus Integrity Breach:**

This vulnerability enables complete takeover of the AElf consensus mechanism:

- **Permanent Control**: The attacker can install themselves and accomplices as the exclusive miner set, controlling all future term transitions
- **Election System Bypass**: All token holder votes are nullified; legitimate election winners are permanently excluded from consensus
- **Network Security Collapse**: The entire delegated proof-of-stake security model is compromised

**Secondary Attack Vectors:**

Once controlling consensus, the attacker can:
- **Transaction Censorship**: Block transactions from competitors or specific users
- **Treasury Manipulation**: Control treasury release timing and beneficiaries
- **Governance Attacks**: Manipulate proposal execution timing to bypass safeguards
- **Double-Spending**: Potential chain reorganization attacks with majority miner control
- **Cross-Chain Exploits**: Manipulate cross-chain indexing and merkle root reporting

**Affected Parties:**
- Token holders whose votes become meaningless
- Legitimate candidate nodes excluded from mining
- DApp developers whose applications rely on consensus integrity
- All network participants whose transactions can be censored

## Likelihood Explanation

**Attacker Requirements:**
- Must be a current-term miner (normal operational privilege, no special access needed)
- Requires only the ability to modify their own node software (standard for node operators)
- Can execute during their designated NextTerm block production time slot

**Attack Complexity:**
- **LOW**: Only requires modifying local node software to inject malicious keys
- No cryptographic attacks, timing races, or complex state manipulation needed
- Single malicious block achieves permanent compromise

**Opportunity Windows:**
- Term transitions occur regularly (default: every 7 days on mainchain)
- Any of the ~17 current miners can execute the attack during their NextTerm slot
- Multiple opportunities per year for attack execution

**Detection Ineffectiveness:**
- Pre-execution validation has no Election Contract cross-check
- Post-execution validation performs circular comparison (header vs. state updated from header)
- Off-chain monitoring could detect the mismatch, but by then the malicious state is already committed and accepted by all nodes

**Probability Assessment:**
HIGH - The combination of low technical barriers, regular opportunity windows, and catastrophic impact makes this a high-probability threat.

## Recommendation

Implement strict validation of the miner list against the Election Contract during NextTerm processing:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL FIX: Validate miner list against Election Contract
    if (State.IsMainChain.Value)
    {
        var authorizedMiners = State.ElectionContract.GetVictories.Call(new Empty());
        var providedMiners = nextRound.RealTimeMinersInformation.Keys
            .Select(k => ByteStringHelper.FromHexString(k)).ToHashSet();
        var expectedMiners = authorizedMiners.Value.ToHashSet();
        
        Assert(providedMiners.SetEquals(expectedMiners), 
            "NextTerm miner list does not match Election Contract victories");
    }
    
    // ... rest of ProcessNextTerm implementation
}
```

Additionally, enhance `RoundTerminateValidationProvider` to perform this validation during pre-execution:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // CRITICAL FIX: Validate miner list against Election Contract
    var authorizedMiners = State.ElectionContract.GetVictories.Call(new Empty());
    var providedMiners = extraData.Round.RealTimeMinersInformation.Keys.ToHashSet();
    var expectedMiners = authorizedMiners.Value.Select(b => b.ToHex()).ToHashSet();
    
    if (!providedMiners.SetEquals(expectedMiners))
        return new ValidationResult { Message = "NextTerm miner list does not match Election Contract" };
        
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanInjectArbitraryMinersInNextTerm()
{
    // Setup: Initialize consensus with legitimate miners
    var legitimateMiners = new[] { "miner1_pubkey", "miner2_pubkey", "miner3_pubkey" };
    await InitializeConsensusWithMiners(legitimateMiners);
    
    // Attacker is a current miner
    var attackerPubkey = "miner1_pubkey";
    var accomplicePubkey = "attacker_accomplice_pubkey"; // Not in election winners
    
    // Attacker crafts malicious NextTermInput with arbitrary miners
    var maliciousNextTermInput = new NextTermInput
    {
        TermNumber = 2,
        RoundNumber = 1,
        RealTimeMinersInformation = 
        {
            { attackerPubkey, new MinerInRound { Pubkey = attackerPubkey } },
            { accomplicePubkey, new MinerInRound { Pubkey = accomplicePubkey } }
            // Legitimate election winners excluded!
        }
    };
    
    // Execute malicious NextTerm
    var result = await ConsensusStub.NextTerm.SendAsync(maliciousNextTermInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: Malicious miner list is now installed
    var currentMiners = await ConsensusStub.GetCurrentMinerList.CallAsync(new Empty());
    currentMiners.Pubkeys.Count.ShouldBe(2);
    currentMiners.Pubkeys.ShouldContain(ByteStringHelper.FromHexString(attackerPubkey));
    currentMiners.Pubkeys.ShouldContain(ByteStringHelper.FromHexString(accomplicePubkey));
    
    // The legitimate election winners are excluded - election system bypassed!
    currentMiners.Pubkeys.ShouldNotContain(ByteStringHelper.FromHexString("miner2_pubkey"));
    currentMiners.Pubkeys.ShouldNotContain(ByteStringHelper.FromHexString("miner3_pubkey"));
}
```

**Notes:**

- The vulnerability is in production consensus contract code, specifically the NextTerm term transition logic
- The attack requires only current miner privileges, which are granted through the normal election process
- No validation exists to ensure the provided miner list matches the Election Contract's authoritative result
- Post-execution validation is ineffective due to circular comparison (comparing header against state derived from that same header)
- This breaks the fundamental security guarantee that miners are selected through delegated proof-of-stake elections

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L228-232)
```csharp
        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L274-282)
```csharp
        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
```
