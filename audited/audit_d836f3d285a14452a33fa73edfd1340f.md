### Title
Unvalidated Decrypted Pieces Enable Consensus DoS via Secret Reconstruction Failure

### Summary
The `UpdateLatestSecretPieces` function accepts arbitrary decrypted secret shares from miners without validation, storing them directly into the round state. When `RevealSharedInValues` later uses these shares in `SecretSharingHelper.DecodeSecret` to reconstruct in-values, a malicious miner's invalid shares cause incorrect reconstruction, leading to validation failure and blocking NextRound consensus transitions. [1](#0-0) 

### Finding Description

**Root Cause:**
The `UpdateLatestSecretPieces` function unconditionally stores decrypted secret pieces from `triggerInformation.DecryptedPieces` without any cryptographic validation or integrity checks. [1](#0-0) 

**Attack Path:**
1. During `GetConsensusExtraDataToPublishOutValue`, a malicious authorized miner provides `triggerInformation` containing arbitrary byte arrays in `DecryptedPieces` [2](#0-1) 

2. These unvalidated pieces are stored in `updatedRound.RealTimeMinersInformation[targetMiner].DecryptedPieces[attackerPubkey]`

3. When any miner produces a NextRound block, `RevealSharedInValues` is invoked [3](#0-2) 

4. The function calls `SecretSharingHelper.DecodeSecret` with all collected `DecryptedPieces` to reconstruct each miner's previous in-value [4](#0-3) 

5. With malicious shares included, `DecodeSecret` performs Lagrange interpolation using corrupted data, producing an incorrect reconstructed value [5](#0-4) 

6. The incorrect `PreviousInValue` is set in the round state [6](#0-5) 

7. Validation fails because `Hash(PreviousInValue) ≠ OutValue` from the previous round [7](#0-6) 

**Why Existing Protections Fail:**

The system checks that sufficient pieces exist (count >= minersCount) [8](#0-7)  but never validates the cryptographic correctness or authenticity of the piece contents. The threshold scheme in `DecodeSecret` is designed to handle missing shares, not adversarial shares—a single invalid share among the first `minimumCount` shares selected corrupts the entire reconstruction.

### Impact Explanation

**Consensus Disruption:**
A single Byzantine miner can prevent NextRound transitions, stalling consensus progression indefinitely. The attack succeeds probabilistically with probability ≈ (minimumCount / minersCount), typically ~67% for standard 2/3 threshold configurations with 21 miners.

**Affected Parties:**
- All network participants experience consensus halts
- Block production ceases until the malicious miner is removed
- Random number generation fails, affecting any protocols depending on consensus randomness

**Severity Justification:**
HIGH severity due to:
- Consensus liveness failure (complete DoS)
- Single attacker with miner privileges sufficient
- No on-chain detection or automatic recovery mechanism
- Violates Byzantine fault tolerance assumptions (system should tolerate 1/3 Byzantine miners, but a single one breaks it)

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be an authorized block producer with a valid public key in the current miner list [9](#0-8) . This is a realistic Byzantine scenario that consensus protocols must handle.

**Attack Complexity:**
Low—the attacker simply provides arbitrary byte arrays in `triggerInformation.DecryptedPieces` when producing blocks. No sophisticated cryptographic attack is required.

**Feasibility Conditions:**
- Attacker is an elected block producer (achievable through election process)
- Secret sharing is enabled [10](#0-9) 
- System reaches NextRound transition point

**Detection Constraints:**
The validation failure appears as a legitimate mismatch between `PreviousInValue` and `OutValue`, making it difficult to distinguish from honest node failures or network issues. No on-chain mechanism identifies the source of invalid shares.

**Probability Assessment:**
High likelihood—any elected miner can execute this attack repeatedly with ~67% success rate per attempt.

### Recommendation

**Immediate Fix:**
Add cryptographic validation to `UpdateLatestSecretPieces`:

```csharp
foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
{
    if (!updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
        continue;
    
    // Validate the decrypted piece is within valid range for BigInteger operations
    var pieceValue = new BigInteger(decryptedPiece.Value.ToByteArray());
    Assert(pieceValue >= BigInteger.Zero && pieceValue < SecretSharingConsts.FieldPrime, 
        "Invalid decrypted piece value");
    
    updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] = 
        decryptedPiece.Value;
}
```

**Enhanced Protection:**
In `RevealSharedInValues`, implement verification that reconstructed value matches committed value before setting state:

```csharp
var revealedInValue = 
    HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Only set if it matches the expected OutValue
if (HashHelper.ComputeFrom(anotherMinerInPreviousRound.InValue) == anotherMinerInPreviousRound.OutValue ||
    revealedInValue == anotherMinerInPreviousRound.InValue)
{
    currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
}
```

**Test Cases:**
1. Test with malicious DecryptedPieces containing out-of-range values
2. Test with DecryptedPieces containing zero values
3. Test with DecryptedPieces containing maximum BigInteger values
4. Verify NextRound transitions succeed even with 1/3 Byzantine miners providing invalid shares

### Proof of Concept

**Initial State:**
- Network has 21 elected miners
- Secret sharing is enabled
- Current round N with all miners having produced blocks

**Attack Steps:**

1. **Malicious Miner A produces block in round N:**
   - Calls `GetConsensusExtraData` with `triggerInformation.Behaviour = UpdateValue`
   - Provides `triggerInformation.DecryptedPieces[MinerB] = ByteString.CopyFrom(new byte[32])` (all zeros)
   - Block is accepted and malicious piece stored via `UpdateLatestSecretPieces`

2. **Honest Miner C attempts NextRound transition:**
   - Calls `GetConsensusExtraData` with `triggerInformation.Behaviour = NextRound`
   - `RevealSharedInValues` is invoked
   - `DecodeSecret` uses Miner A's malicious zero-value piece along with honest pieces
   - Lagrange interpolation produces incorrect result for Miner B's `PreviousInValue`

3. **Validation Failure:**
   - `ValidateConsensusBeforeExecution` calls `ValidatePreviousInValue`
   - Check fails: `Hash(incorrect_PreviousInValue) ≠ MinerB.OutValue_from_round_N`
   - Block is rejected with validation error

**Expected vs Actual Result:**
- **Expected:** NextRound transition succeeds, round N+1 begins
- **Actual:** Validation fails, NextRound block rejected, consensus stalled at round N

**Success Condition:**
The attack succeeds when the NextRound block is rejected, observable through transaction result showing validation failure message "Incorrect previous in value" from [11](#0-10)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-50)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L52-52)
```csharp
            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L17-17)
```csharp
            return new ValidationResult { Message = "Incorrect previous in value." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```
