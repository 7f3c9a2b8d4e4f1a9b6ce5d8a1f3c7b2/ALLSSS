### Title
Side Chain Term Number State Inconsistency Due to Missing NextTerm Processing

### Summary
Side chains do not use `NextTerm` behavior when miner lists change, instead always returning `NextRound` from their behavior provider. When the main chain miner list changes, side chains generate a "first round of new term" with incremented `TermNumber` but process it through `ProcessNextRound` instead of `ProcessNextTerm`, causing critical state variables like `State.CurrentTermNumber.Value` to become inconsistent with the actual round data.

### Finding Description

The root cause lies in the different implementations of consensus behavior providers between main and side chains:

**Main Chain Behavior Provider** checks whether a term change is needed: [1](#0-0) 

**Side Chain Behavior Provider** always returns `NextRound`, never checking for term changes: [2](#0-1) 

When a side chain's miner list changes (received from main chain via cross-chain communication), the `GenerateNextRoundInformation` method detects this and generates a "first round of new term": [3](#0-2) 

This generated round has its `TermNumber` incremented: [4](#0-3) 

However, because the side chain behavior provider returns `NextRound`, this round is processed through `ProcessNextRound`: [5](#0-4) 

**Critical Issue**: `ProcessNextRound` does NOT update the term number in state. It only calls `AddRoundInformation` and `TryToUpdateRoundNumber`. The term number update only happens in `ProcessNextTerm`: [6](#0-5) 

Specifically, `TryToUpdateTermNumber` is only called in `ProcessNextTerm`: [7](#0-6) 

### Impact Explanation

This vulnerability creates multiple critical state inconsistencies on side chains:

1. **Term Number Mismatch**: The round stored in `State.Rounds[roundNumber]` contains `TermNumber = N+1`, but `State.CurrentTermNumber.Value` remains at `N`, causing:
   - `GetCurrentTermNumber()` to return incorrect values to external callers [8](#0-7) 
   
2. **Missing Historical Mappings**: `State.FirstRoundNumberOfEachTerm[N+1]` is never set (only set in `ProcessNextTerm` at line 193), breaking queries like: [9](#0-8) 

3. **Miner List Mapping Not Updated**: `State.MinerListMap[N+1]` is never set, as `SetMinerList` is only called in `ProcessNextTerm`: [10](#0-9) 

4. **Validation Context Corruption**: Consensus validation uses the stale term number: [11](#0-10) 

5. **Miner Statistics Not Reset**: Unlike `ProcessNextTerm`, `ProcessNextRound` does not reset `MissedTimeSlots` and `ProducedBlocks`, causing new miners to inherit stale statistics.

**Severity**: Medium - This causes consensus state integrity violations and incorrect data propagation to cross-contract calls, but does not directly result in fund theft. It affects protocol correctness and fairness of miner statistics tracking on all side chains.

### Likelihood Explanation

**Likelihood: High**

- **Reachable Entry Point**: Automatically triggered when main chain updates its miner list via cross-chain communication through `UpdateInformationFromCrossChain`: [12](#0-11) 

- **No Attacker Required**: This is not an attack but an automatic system behavior. Every time the main chain changes its miner list (through elections), all side chains will experience this inconsistency.

- **Feasible Preconditions**: Only requires normal main chain operation where miner lists change periodically through elections.

- **Execution Practicality**: Happens automatically as part of consensus operation, no special steps needed.

- **Detection Difficulty**: The inconsistency is subtle and may not be immediately visible, as blocks continue to be produced, but queries and cross-contract calls will receive incorrect term numbers.

### Recommendation

**Fix 1: Modify Side Chain to Use NextTerm When Miner List Changes**

Update `SideChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` to check if the miner list changed and return `NextTerm` instead of always returning `NextRound`:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Check if this is a term change scenario (miner list changed)
    if (!State.IsMainChain.Value && IsMainChainMinerListChanged(CurrentRound))
    {
        return AElfConsensusBehaviour.NextTerm;
    }
    return AElfConsensusBehaviour.NextRound;
}
```

**Fix 2: Update ProcessNextRound to Handle Term Changes**

Add a check in `ProcessNextRound` to detect when the input round has a different term number and either:
- Assert/reject such inputs, OR
- Call the same term-change logic as `ProcessNextTerm`

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Detect term change
    TryToGetCurrentRoundInformation(out var currentRound);
    if (nextRound.TermNumber != currentRound.TermNumber)
    {
        Assert(false, "Term number mismatch - use NextTerm for term changes");
    }
    
    // ... rest of existing logic
}
```

**Test Cases**:
1. Simulate main chain miner list change on a side chain
2. Verify `State.CurrentTermNumber.Value` is correctly updated
3. Verify `State.FirstRoundNumberOfEachTerm[newTerm]` is set
4. Verify `State.MinerListMap[newTerm]` is populated
5. Verify miner statistics are reset for new term
6. Verify `GetCurrentTermNumber()` returns correct value after miner list change

### Proof of Concept

**Initial State**:
- Side chain running with term number 5
- Main chain performs election, miner list changes
- Cross-chain message delivers new miner list to side chain

**Execution Steps**:
1. Side chain receives `UpdateInformationFromCrossChain` with new miner list
2. `State.MainChainCurrentMinerList.Value` is updated with new miners
3. Consensus continues, eventually a miner calls for next round
4. `GenerateNextRoundInformation` detects `IsMainChainMinerListChanged() == true`
5. Generates round with `TermNumber = 6` (current 5 + 1)
6. Creates `NextRoundInput` with `TermNumber = 6`
7. Calls `NextRound` method â†’ `ProcessNextRound`
8. `ProcessNextRound` stores round with `TermNumber = 6` in `State.Rounds[roundNum]`
9. Updates `State.CurrentRoundNumber.Value` but NOT `State.CurrentTermNumber.Value`

**Expected Result**:
- `State.CurrentTermNumber.Value = 6`
- `State.FirstRoundNumberOfEachTerm[6]` is set
- `State.MinerListMap[6]` contains new miner list

**Actual Result**:
- `State.CurrentTermNumber.Value = 5` (NOT UPDATED)
- `State.FirstRoundNumberOfEachTerm[6]` is NULL
- `State.MinerListMap[6]` is NULL
- `GetCurrentTermNumber()` returns 5 while actual round has term 6

**Success Condition**: 
Query `GetCurrentTermNumber()` immediately after miner list change processes - it returns the old term number (5) despite the current round having term number 6, confirming the state inconsistency.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L16-23)
```csharp
        /// <summary>
        ///     Simply return NEXT_ROUND for side chain.
        /// </summary>
        /// <returns></returns>
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L362-365)
```csharp
    public override Int64Value GetCurrentTermNumber(Empty input)
    {
        return new Int64Value { Value = State.CurrentTermNumber.Value };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-470)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-63)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
```
