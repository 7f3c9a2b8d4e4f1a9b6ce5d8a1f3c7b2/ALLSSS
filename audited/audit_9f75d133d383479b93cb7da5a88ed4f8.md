# Audit Report

## Title
Unauthorized Candidate Admin Control via AnnounceElectionFor with Null Admin and Contract Caller

## Summary
The `AnnounceElectionFor` function allows any caller to announce any public key as an election candidate without the candidate's consent. When the `Admin` parameter is null, the function defaults the admin role to `Context.Sender`, enabling an attacker to deploy an immutable contract that permanently seizes administrative control over a victim's candidacy with no recourse except Parliament intervention.

## Finding Description

The Election contract provides two methods for announcing candidacy: `AnnounceElection` and `AnnounceElectionFor`. The regular `AnnounceElection` method verifies the caller owns the candidate's private key by using `Context.RecoverPublicKey()` [1](#0-0)  and requires an explicit admin address to be provided [2](#0-1) .

However, `AnnounceElectionFor` has two critical flaws:

**1. Missing Consent Verification**: Unlike `AnnounceElection`, this function accepts any public key string without signature validation [3](#0-2) , allowing anyone to announce anyone else as a candidate.

**2. Improper Admin Defaulting**: When `input.Admin` is null, the function defaults to `Context.Sender` as the admin [4](#0-3) . This admin is then stored in the state mappings [5](#0-4) .

**Attack Execution**:
1. Attacker deploys an immutable contract with no admin transfer or quit functions
2. Contract approves 100,000 ELF [6](#0-5)  to the Election contract
3. Contract calls `AnnounceElectionFor` with victim's pubkey and `Admin = null`
4. The contract address becomes the admin
5. Victim's pubkey is now permanently under contract control

**Why Victim Cannot Recover**:
- The private `AnnounceElection` method prevents duplicate announcements [7](#0-6) , so the victim cannot re-announce themselves
- `SetCandidateAdmin` requires the caller to be either the current admin or Parliament [8](#0-7) 
- `QuitElection` requires the caller to be the admin [9](#0-8) 

If the attacker uses an immutable contract, the victim has no recourse except waiting for Parliament governance intervention.

## Impact Explanation

**Authorization Impact**: An attacker gains unauthorized administrative control over any victim's election candidacy. The victim loses the ability to manage their own participation in the election system.

**Operational Impact**:
- **DoS of Self-Announcement**: The victim cannot call `AnnounceElection` for their own public key due to the duplicate candidate check
- **Loss of Control**: The victim cannot quit the election or change the admin without being the current admin or having Parliament approval
- **Permanent Lock**: If executed via an immutable contract, the situation becomes permanent until Parliament intervenes

**Severity: Medium** - While there is no direct fund theft (the attacker's locked 100,000 ELF tokens are refundable when the contract quits [10](#0-9) ), the vulnerability has significant governance and operational impact requiring external governance intervention to resolve.

## Likelihood Explanation

**Attacker Capabilities**:
- Must deploy a smart contract (trivial on AElf)
- Must have 100,000 ELF to lock (modest requirement, fully refundable)
- Must approve tokens to the Election contract (standard operation)

**Attack Complexity**: Very Low
- Single transaction from the malicious contract
- No timing requirements or race conditions
- No complex state manipulation needed

**Feasibility Conditions**:
- Target pubkey must not already be an announced candidate
- Target must not be an initial miner [11](#0-10) 
- These conditions are easily satisfied for most addresses

**Economic Rationality**: High
- Attack cost: Only opportunity cost of locked tokens (100% refundable when contract quits)
- Impact: Permanent control over victim's candidacy
- Detection: Publicly visible on-chain but victim has no technical recourse

**Probability: High** - All preconditions are easily met and the attack is straightforward to execute with minimal cost.

## Recommendation

Add consent verification and require explicit admin specification:

1. **Add signature verification**: Require the candidate to sign a message proving they consent to the announcement
2. **Remove admin defaulting**: Make the admin parameter mandatory, similar to how `AnnounceElection` requires it
3. **Add authorization check**: Verify that either the candidate or an already-authorized admin is calling the function

Example fix for the admin defaulting issue:
```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // Require explicit admin, do not default to Context.Sender
    Assert(input.Admin != null && input.Admin.Value.Any(), 
        "Admin must be explicitly specified.");
    
    AnnounceElection(pubkeyBytes);
    State.CandidateAdmins[pubkey] = input.Admin;
    // ... rest of implementation
}
```

Additionally, consider requiring the candidate's signature to prove consent to being announced.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_UnauthorizedAdminControl_Attack()
{
    // Victim's keypair
    var victimKeyPair = ValidationDataCenterKeyPairs.First();
    var victimPubkey = victimKeyPair.PublicKey.ToHex();
    
    // Attacker's keypair (will deploy contract)
    var attackerKeyPair = ValidationDataCenterKeyPairs.Last();
    
    // Attacker announces victim as candidate with null admin
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimPubkey,
        Admin = null  // Admin defaults to Context.Sender (attacker)
    });
    
    // Verify attacker is now the admin
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimPubkey });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Victim cannot re-announce themselves (duplicate check fails)
    var victimStub = GetElectionContractTester(victimKeyPair);
    var result = await victimStub.AnnounceElection.SendWithExceptionAsync(
        Address.FromPublicKey(victimKeyPair.PublicKey));
    result.TransactionResult.Error.ShouldContain("already announced election");
    
    // Victim cannot change admin (not current admin)
    var changeAdminResult = await victimStub.SetCandidateAdmin.SendWithExceptionAsync(
        new SetCandidateAdminInput
        {
            Pubkey = victimPubkey,
            Admin = Address.FromPublicKey(victimKeyPair.PublicKey)
        });
    changeAdminResult.TransactionResult.Error.ShouldContain("No permission");
    
    // Only attacker can quit, proving complete control
    await attackerStub.QuitElection.SendAsync(new StringValue { Value = victimPubkey });
}
```

This test demonstrates that an attacker can gain permanent administrative control over a victim's candidacy by calling `AnnounceElectionFor` with a null admin parameter, and the victim has no technical recourse to reclaim control.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L95-95)
```csharp
        var recoveredPublicKey = Context.RecoverPublicKey();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L101-101)
```csharp
        Assert(input.Value.Any(), "Admin is needed while announcing election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-126)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L127-127)
```csharp
        var admin = input.Admin ?? Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L128-131)
```csharp
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L149-150)
```csharp
        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-157)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
