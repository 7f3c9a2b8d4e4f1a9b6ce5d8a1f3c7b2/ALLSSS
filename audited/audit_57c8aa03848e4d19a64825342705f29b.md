### Title
Unbounded Loop in GetAllProfitsMap Causes View Call DoS

### Summary
The `GetAllProfitsMap` function iterates through all available profit details without any upper bound limit, unlike the analogous `ClaimProfits` function which caps iterations at 10. When a beneficiary accumulates many profit details (through repeated `AddBeneficiary` calls or over time), view calls can timeout due to excessive computation, preventing users from querying their profit amounts.

### Finding Description

**Exact Code Location:** [1](#0-0) 

**Root Cause:**
The for loop iterates `availableDetails.Count` times without any cap. While `profitableDetailCount` is limited to `ProfitReceivingLimitForEachTime` (10) for calculating claimable profits, the main loop processes ALL available details to calculate total profits: [2](#0-1) 

For each detail, the function calls `ProfitAllPeriods` with `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)` periods, which can span hundreds or thousands of periods. Inside `ProfitAllPeriods`, another loop iterates through each period, reading state and performing calculations: [3](#0-2) 

**Why Protections Fail:**
1. **No limit on profit detail accumulation:** Each call to `AddBeneficiary` adds a new `ProfitDetail` to the beneficiary's list: [4](#0-3) 

2. **Cleanup only removes fully claimed, expired details:** Old details are only removed if they meet strict criteria (fully claimed, not perpetual, and past due period): [5](#0-4) 

3. **Perpetual details never removed:** Details with `EndPeriod = long.MaxValue` are never cleaned up and can accumulate indefinitely.

4. **Contrast with ClaimProfits:** The analogous `ClaimProfits` function correctly limits iteration to `profitableDetailCount` (max 10): [6](#0-5) 

### Impact Explanation

**Harm:**
- **View Method DoS:** Users cannot query their profit amounts via `GetProfitAmount`, `GetAllProfitAmount`, or `GetAllProfitsMap`
- **Indirect Claiming Impact:** Users may be unable to determine profit amounts, potentially preventing them from claiming profits
- **Service Degradation:** Affects all users attempting to query profits for beneficiaries with many accumulated details

**Quantification:**
If a beneficiary has 100 profit details spanning an average of 100 periods each:
- Total iterations: 100 details × 100 periods = 10,000 period iterations
- Each iteration involves state reads (`State.DistributedProfitsMap`) and calculations
- This far exceeds reasonable gas/execution limits for view calls

**Who is Affected:**
- Beneficiaries with many accumulated profit details (through repeated additions or time)
- All users attempting to query such beneficiaries' profit information
- Frontend applications relying on these view methods

**Severity Justification:** Medium
- Impact: Medium (operational DoS, prevents querying essential profit data)
- Likelihood: Medium (can occur through legitimate operations over time or intentional manager actions)

### Likelihood Explanation

**Attacker Capabilities:**
- **Manager Control:** A scheme manager can repeatedly call `AddBeneficiary` for the same beneficiary with different periods/shares [7](#0-6) 
- **Natural Accumulation:** Even without malicious intent, beneficiaries legitimately accumulate details over time through normal operations

**Attack Complexity:**
- Low complexity: Simply call `AddBeneficiary` multiple times
- No special timing or state conditions required
- Works against any beneficiary address

**Feasibility Conditions:**
- Attacker needs manager role of a scheme, OR
- Natural accumulation through legitimate multi-period participation
- No economic barriers (manager calls are permissioned operations)

**Detection/Operational Constraints:**
- View call timeouts would be observable but attributed to "slow queries"
- No state changes recorded, making detection difficult
- Can affect innocent users who legitimately accumulate details

**Probability:** Medium
- Schemes with active multi-period participation will naturally accumulate details
- Long-running schemes are particularly susceptible
- Malicious managers can intentionally trigger the issue

### Recommendation

**Code-Level Mitigation:**
Apply the same iteration limit used in `ClaimProfits` to the main loop in `GetAllProfitsMap`:

```csharp
// Line 125: Change from
for (var i = 0; i < availableDetails.Count; i++)

// To:
var maxDetailsToProcess = Math.Min(availableDetails.Count, ProfitContractConstants.ProfitReceivingLimitForEachTime);
for (var i = 0; i < maxDetailsToProcess; i++)
```

**Alternative Solution:**
Add a separate constant for view method limits if different behavior is needed: [8](#0-7) 

**Invariant Check:**
Add an assertion that the number of profit details processed in a single call does not exceed the configured limit.

**Test Cases:**
1. Create a beneficiary with 50+ profit details and verify view methods complete within timeout limits
2. Test with details spanning 100+ periods each
3. Verify total profit calculation remains accurate with the iteration limit

### Proof of Concept

**Required Initial State:**
1. Create a profit scheme with a manager address
2. Define a beneficiary address

**Transaction Steps:**
1. Manager calls `AddBeneficiary` 100 times for the same beneficiary with different `StartPeriod`/`EndPeriod` values spanning 100 periods each
2. Distribute profits to the scheme over multiple periods
3. Call `GetAllProfitsMap` (or `GetProfitAmount`/`GetAllProfitAmount`) for the beneficiary

**Expected vs Actual Result:**
- Expected: View method returns profit amounts within normal execution limits
- Actual: View method times out or exceeds gas limits due to 10,000+ iterations (100 details × 100 periods)

**Success Condition:**
The view call fails with a timeout or gas exceeded error, preventing the caller from retrieving profit information. This DoS affects the beneficiary's ability to query their owed profits.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-121)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L203-207)
```csharp
        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-777)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-875)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-6)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
```
