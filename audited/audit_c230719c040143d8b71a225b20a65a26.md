### Title
Unauthorized Round Termination Due to Missing Extra Block Producer Authorization Check

### Summary
The `GetConsensusBehaviour()` function contains a fallthrough logic error that allows any miner who has reached their maximum block count to prematurely terminate a consensus round, bypassing the intended restriction that only the designated extra block producer should terminate rounds during the extra block time slot. This enables unauthorized round termination before all miners have participated, disrupting consensus schedule integrity.

### Finding Description

**Root Cause:**

The vulnerability exists in the `GetConsensusBehaviour()` function where a critical authorization check is missing. [1](#0-0) 

When a miner has `OutValue != null` (has mined), `_isTimeSlotPassed == false` (still within their time slot), and `ActualMiningTimes.Count >= _maximumBlocksCount` (reached block limit), but is NOT the extra block producer of the previous round (lines 71-77 condition fails), the function falls through to line 82 calling `GetConsensusBehaviourToTerminateCurrentRound()`. [2](#0-1) 

This returns `NextRound` or `NextTerm` behaviour without verifying:
1. The miner is the designated extra block producer for the current round
2. The current time is within the extra block time slot

**Why Protections Fail:**

The `PreCheck()` authorization only validates that the miner is in the current or previous round's miner list, not that they have authority to terminate rounds. [3](#0-2) 

The `TimeSlotValidationProvider` for NextRound/NextTerm only validates that the new round's time slots are properly distributed via `CheckRoundTimeSlots()`, but does NOT check if the current miner is authorized to terminate the round or if it's the correct time. [4](#0-3) 

The `IsCurrentMiner()` method contains comprehensive checks for extra block producer authorization and time slot validation, but this method is never called in the NextRound/NextTerm execution path. [5](#0-4) 

**Execution Path:**

1. Miner calls `GetConsensusCommand()` [6](#0-5) 
2. `GetConsensusBehaviour()` returns `NextRound` or `NextTerm` due to fallthrough
3. `GetConsensusCommand()` generates consensus command with termination behaviour
4. Miner executes `NextRound()` transaction [7](#0-6) 
5. `ProcessConsensusInformation()` processes the round termination with only weak `PreCheck()` authorization
6. Round terminates prematurely, becoming the extra block producer of the next round [8](#0-7) 

### Impact Explanation

**Consensus Schedule Disruption:**
Unauthorized miners can terminate rounds before the designated extra block producer's time slot, before all miners have had their turns. In AEDPoS, the extra block time slot is scheduled after all regular miners' slots. [9](#0-8) 

**Specific Harms:**
1. **Unfair Block Production Distribution**: Miners who haven't had their turn lose block production opportunities and associated rewards
2. **Extra Block Producer Role Hijacking**: The attacker becomes the extra block producer of the next round, gaining the privilege to terminate that round too
3. **Consensus Timing Manipulation**: Attackers can manipulate round termination timing for strategic advantage (e.g., preventing competing miners from producing blocks, manipulating reward distribution timing)
4. **Chain Stability**: Repeated exploitation disrupts the intended consensus schedule, potentially affecting chain liveness if coordinated

**Affected Parties:**
- Honest miners who lose block production opportunities
- The designated extra block producer who never gets to fulfill their role
- Overall network consensus integrity

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the current round
- Must mine legitimate blocks to reach maximum block count
- No special privileges required beyond being a miner

**Attack Complexity:**
Low. The attacker simply needs to:
1. Mine blocks during their legitimate time slot until reaching `_maximumBlocksCount`
2. While still in their time slot, call `GetConsensusCommand()` 
3. Execute the returned `NextRound` transaction

**Feasibility:**
High. The attack is trivially executable:
- Entry point `GetConsensusCommand()` is publicly callable [10](#0-9) 
- No exceptional conditions required
- Works in any round after a miner has produced their maximum blocks
- No economic barriers beyond normal mining participation

**Detection:**
Difficult to detect as the attacker is legitimately mining blocks; only the premature round termination timing is abnormal.

### Recommendation

**Code-Level Mitigation:**

Add authorization check in `GetConsensusBehaviour()` before line 82:

```csharp
// Before returning round termination behaviour, verify authorization
if (_isTimeSlotPassed)
{
    // Only if time slot passed, allow termination behaviour
    return GetConsensusBehaviourToTerminateCurrentRound();
}

// Check if miner is designated extra block producer for current round
var extraBlockProducer = CurrentRound.RealTimeMinersInformation
    .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
if (extraBlockProducer.Key != _pubkey)
{
    // Not authorized to terminate round
    return AElfConsensusBehaviour.Nothing;
}

// Check if current time is in extra block time slot
var extraBlockMiningTime = CurrentRound.GetExtraBlockMiningTime();
if (_currentBlockTime < extraBlockMiningTime)
{
    // Too early to terminate round
    return AElfConsensusBehaviour.Nothing;
}

return GetConsensusBehaviourToTerminateCurrentRound();
```

**Invariant Checks:**
1. Only the miner with `IsExtraBlockProducer == true` should be able to execute `NextRound`/`NextTerm`
2. Round termination should only occur when current time >= extra block mining time
3. All miners should have opportunity to mine before round termination (or have explicitly missed their slots)

**Test Cases:**
1. Test that non-extra-block-producer miners cannot terminate rounds during their time slots
2. Test that extra block producer can only terminate during extra block time slot
3. Test that premature NextRound transactions are rejected
4. Test that round termination requires proper timing and authorization

### Proof of Concept

**Initial State:**
- Round with 5 miners: A(order=1), B(order=2), C(order=3), D(order=4), E(order=5)
- Miner C has `IsExtraBlockProducer = true`
- Mining interval: 4000ms per slot
- Maximum blocks count: 1
- Current time: Miner B's time slot (not yet passed)

**Attack Steps:**
1. Miner B mines 1 block during their legitimate time slot (reaching `_maximumBlocksCount`)
2. While still in their time slot (_isTimeSlotPassed == false), Miner B calls `GetConsensusCommand(B's pubkey)`
3. `GetConsensusBehaviour()` evaluates:
   - Line 49: `_minerInRound.OutValue != null` (true, B has mined) → skip
   - Line 57: `!_isTimeSlotPassed` (true) → enter else-if
   - Line 60: `ActualMiningTimes.Count < _maximumBlocksCount` (false, count == 1) → skip
   - Lines 71-77: B is not extra block producer of previous round → condition false, skip
   - Falls through to line 82: returns `NextRound`
4. Miner B executes `NextRound` transaction
5. Round terminates with B as sender
6. Miners D, E, and designated extra block producer C never got their turns

**Expected Result:**
Miner B should receive `AElfConsensusBehaviour.Nothing` or be rejected, as they're not authorized to terminate the round.

**Actual Result:**
Miner B successfully terminates the round prematurely, becoming the extra block producer of the next round, while miners D, E, and C lose their block production opportunities in the current round.

**Success Condition:**
Round terminates early with round number incremented, and B is recorded as `ExtraBlockProducerOfPreviousRound` in the new round, demonstrating unauthorized round termination.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```
