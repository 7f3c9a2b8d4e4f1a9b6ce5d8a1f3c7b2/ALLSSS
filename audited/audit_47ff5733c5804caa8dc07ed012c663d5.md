### Title
Authorization Check After Unbounded Loop Enables Resource Exhaustion DoS in SetMethodFee

### Summary
The `SetMethodFee` method in Genesis and 15+ other system contracts performs authorization checks after iterating through an unbounded `input.Fees` array and making expensive cross-contract calls for each entry. An attacker can submit transactions with thousands of fee entries, forcing nodes to execute up to 15,000 cross-contract calls before the transaction fails authorization, enabling a cost-asymmetric DoS attack against critical governance infrastructure.

### Finding Description

The vulnerability exists in the `SetMethodFee` method implementation across multiple ACS1 method fee provider contracts. In the Genesis contract, the foreach loop iterates through `input.Fees` without any count validation: [1](#0-0) 

For each iteration, the method calls `AssertValidToken`, which performs a cross-contract call to the Token contract: [2](#0-1) 

The authorization check only occurs after this loop completes: [3](#0-2) 

**Root Cause:** The authorization validation is placed after the expensive loop operations, allowing unauthorized callers to trigger resource-intensive computations before being rejected.

**Why Existing Protections Fail:**

1. **Execution Observer Limits:** AElf's execution observer enforces branch count and call count limits of 15,000 each: [4](#0-3) 

However, this limit still allows thousands of expensive cross-contract calls before stopping execution.

2. **Transaction Size Limit:** The 5MB transaction size limit allows approximately 100,000+ fee entries: [5](#0-4) 

3. **MethodFees Structure:** The protobuf definition has an unbounded repeated field: [6](#0-5) 

**Widespread Issue:** This same vulnerable pattern exists in 15+ other system contracts including Parliament: [7](#0-6) 

Association: [8](#0-7) 

Even the Profit contract, which has a count validation, checks it AFTER the loop executes: [9](#0-8) 

### Impact Explanation

**Operational DoS Impact:**
- Attacker can submit transactions with 10,000-15,000 fee entries
- Each malicious transaction forces 5,000-15,000 cross-contract calls to the Token contract before failing
- Node resources (CPU, memory, I/O) are exhausted processing these expensive operations
- Critical governance functions (method fee configuration) across all system contracts are targeted simultaneously

**Cost Asymmetry:**
- Transaction fee: Based on transaction size (~500KB = minimal fee)
- Computational cost: Thousands of cross-contract calls with state reads
- Attack multiplier: Attacker can flood mempool with hundreds of such transactions
- Economic rationality: Small cost to attacker, massive cost to node operators

**Affected Systems:**
- Genesis contract (chain initialization and upgrade authority)
- Parliament contract (governance decisions)
- Association contract (multi-sig operations)
- Consensus contract (AEDPoS configuration)
- Economic contract (tokenomics parameters)
- Plus 10+ other critical system contracts

**Severity: HIGH** - Enables network-wide DoS of governance infrastructure with minimal cost to attacker.

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required - any address can submit transactions
- Attack requires only crafting a `MethodFees` message with many entries
- No need to compromise authorized roles

**Attack Complexity:**
- Low - Simple protobuf message construction
- Transaction will be accepted by nodes (passes signature and size validation)
- Pre-execution fee charging completes successfully (based on transaction size)
- Main execution consumes resources before failing authorization check

**Feasibility Conditions:**
- Entry point: Public `SetMethodFee` RPC method in all ACS1 contracts
- Execution guaranteed: Loop executes before authorization check
- Execution observer enforcement documented at 15,000 limit: [10](#0-9) 

**Detection/Operational Constraints:**
- Failed transactions still consume node resources
- No rate limiting on failed authorization attempts
- Multiple contracts can be targeted simultaneously

**Probability: HIGH** - Trivial to execute, economically rational, and difficult to prevent at network layer.

### Recommendation

**Immediate Fix - Move Authorization Check Before Loop:**

Reorder the method to check authorization BEFORE iterating through fees:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    // 1. Check authorization FIRST
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    
    // 2. Validate input size
    Assert(input.Fees.Count <= MaxMethodFeeCount, 
        "Too many fee entries.");
    
    // 3. Then perform expensive operations
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

**Additional Protections:**

1. **Add Count Limit Constant:** Define a reasonable maximum (e.g., 10-50 fee entries) in a constants file
2. **Apply to All Contracts:** Update all 15+ affected contracts with same pattern
3. **Add Input Validation Tests:** Test cases verifying authorization before expensive operations
4. **Consider Rate Limiting:** Add governance-controlled rate limiting for SetMethodFee calls

**Test Cases to Add:**
- Test unauthorized caller with 1 fee entry (should fail immediately without loop execution)
- Test authorized caller with count > limit (should fail before loop)
- Test authorized caller with count at limit (should succeed)
- Performance test measuring execution cost with varying input sizes

### Proof of Concept

**Initial State:**
- Attacker has any valid AElf address with minimal token balance
- Genesis contract deployed at system address
- Method fee controller set to Parliament default organization (not attacker)

**Attack Steps:**

1. **Craft Malicious Transaction:**
```
MethodFees maliciousInput = new MethodFees
{
    MethodName = "SomeMethod",
    Fees = { 
        // Repeat 15,000 times with valid token symbols
        new MethodFee { Symbol = "ELF", BasicFee = 100000000 },
        new MethodFee { Symbol = "USDT", BasicFee = 100000000 },
        // ... 14,998 more entries
    }
};
```

2. **Submit Transaction:**
```
Transaction tx = new Transaction
{
    From = attackerAddress,
    To = genesisContractAddress,
    MethodName = "SetMethodFee",
    Params = maliciousInput.ToByteString()
};
```

3. **Execution Flow:**
   - Transaction passes size validation (< 5MB)
   - Pre-execution charges transaction fee (small, size-based)
   - Main execution begins:
     - Loop iterates 15,000 times
     - Each iteration calls `AssertValidToken`
     - Each `AssertValidToken` makes cross-contract call to Token contract
     - After ~7,500-15,000 calls, execution observer throws exception OR
     - Loop completes, then authorization check fails at line 15
   - Transaction reverts but node has consumed significant resources

**Expected Result:** Transaction succeeds with proper authorization

**Actual Result:** Transaction fails after consuming resources for 5,000-15,000 cross-contract calls, enabling DoS

**Success Condition:** Monitor node CPU/memory usage - each malicious transaction consumes significantly more resources than its transaction fee would justify, with attacker able to submit unlimited such transactions.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L11-11)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L15-15)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L73-82)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** protobuf/acs1.proto (L40-46)
```text
message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L12-15)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L12-15)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L13-16)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L13-15)
```text
- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```
