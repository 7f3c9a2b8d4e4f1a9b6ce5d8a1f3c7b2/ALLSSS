### Title
Missing Null Check in GetSideChainIdAndHeight() Causes NullReferenceException During Reentrancy

### Summary
The `GetSideChainIdAndHeight()` function accesses `sideChainInfo.SideChainStatus` without first checking if `sideChainInfo` is null, which can cause a NullReferenceException. This occurs during a reentrancy window in `CreateSideChain()` where the serial number is incremented before the side chain info is stored, while external contract calls are made.

### Finding Description

The vulnerability exists in the `GetSideChainIdAndHeight()` function where it retrieves side chain information and immediately accesses its status property without null validation: [1](#0-0) 

The function iterates through all serial numbers and retrieves the chainId via `GetChainId()`, then accesses `State.SideChainInfo[chainId]` and directly checks `sideChainInfo.SideChainStatus` without verifying if `sideChainInfo` is null.

This contrasts with all other view functions in the same file that properly validate null before accessing properties: [2](#0-1) [3](#0-2) [4](#0-3) 

The root cause is a reentrancy window in `CreateSideChain()` where the serial number is incremented early in the function: [5](#0-4) 

But the side chain info is only stored much later: [6](#0-5) 

Between these two operations, external contract calls are made: [7](#0-6) [8](#0-7) 

The `ChargeSideChainIndexingFee()` function makes an external call to the Token contract: [9](#0-8) 

And `CreateDefaultOrganizationForIndexingFeePriceManagement()` calls the Association contract: [10](#0-9) 

During these external calls, if a reentrancy occurs where `GetSideChainIdAndHeight()` is invoked, it will iterate up to the newly incremented serial number but find null for the new chainId's info, causing a NullReferenceException when accessing `.SideChainStatus`.

Even internal validation functions follow the proper null-checking pattern: [11](#0-10) 

### Impact Explanation

**Operational Impact**: The missing null check causes a NullReferenceException that crashes any transaction calling `GetSideChainIdAndHeight()` during the reentrancy window. This affects:

1. Direct calls to `GetSideChainIdAndHeight()`
2. `GetAllChainsIdAndHeight()` which depends on it: [12](#0-11) 

3. `GetSideChainIndexingInformationList()` which also depends on it: [13](#0-12) 

Any contract or external system querying side chain information during side chain creation will experience transaction failures, causing temporary DoS of cross-chain query functionality.

The severity is Medium because:
- No direct fund loss occurs
- Impact is limited to the reentrancy window during side chain creation
- It violates defensive programming principles consistently applied elsewhere in the codebase
- It can disrupt cross-chain monitoring and indexing systems

### Likelihood Explanation

**Feasibility**: The vulnerability requires specific timing but is practically exploitable:

1. **Reachable Entry Point**: `GetSideChainIdAndHeight()` is a public view function with no access control, callable by anyone including during reentrancy.

2. **Reentrancy Window**: The window exists during every `CreateSideChain()` execution between the serial number increment and info storage, spanning two external contract calls (Token and Association contracts).

3. **Attack Complexity**: 
   - Medium complexity: requires either a malicious Token/Association contract or a contract that these call to perform reentrancy
   - Or legitimate contracts querying cross-chain info during the creation window
   - Does not require privileged access

4. **Probability**: While the window is narrow (duration of two external calls), side chain creation is a non-trivial operation that happens periodically, and monitoring systems may regularly poll `GetSideChainIdAndHeight()`, increasing collision probability.

The likelihood is **Medium** because while it requires specific timing during side chain creation, the reentrancy surface is real and the function has no access control.

### Recommendation

**Immediate Fix**: Add null check before accessing `sideChainInfo.SideChainStatus` to match the pattern used consistently throughout the codebase:

```csharp
public override ChainIdAndHeightDict GetSideChainIdAndHeight(Empty input)
{
    var dict = new ChainIdAndHeightDict();
    var serialNumber = State.SideChainSerialNumber.Value;
    for (long i = 1; i <= serialNumber; i++)
    {
        var chainId = GetChainId(i);
        var sideChainInfo = State.SideChainInfo[chainId];
        // Add null check here
        if (sideChainInfo == null || sideChainInfo.SideChainStatus == SideChainStatus.Terminated)
            continue;
        var height = State.CurrentSideChainHeight[chainId];
        dict.IdHeightDict.Add(chainId, height);
    }
    return dict;
}
```

**Additional Hardening**: Consider using reentrancy guard pattern in `CreateSideChain()` or reordering operations to set `State.SideChainInfo[chainId]` immediately after incrementing the serial number, before any external calls.

**Test Cases**:
1. Unit test calling `GetSideChainIdAndHeight()` when `State.SideChainInfo[chainId]` is null for a valid serial number
2. Integration test simulating reentrancy during `CreateSideChain()` that calls `GetSideChainIdAndHeight()`
3. Verify all view functions handle null gracefully and consistently

### Proof of Concept

**Required Initial State**:
- CrossChainContract initialized with serial number = 0
- Valid side chain creation proposal approved and ready for release

**Exploitation Steps**:

1. Attacker deploys a malicious Token or Association contract (or compromises the callback path)
2. Side chain creator calls `ReleaseSideChainCreation()` which triggers `CreateSideChain()`
3. In `CreateSideChain()`:
   - Serial number incremented to 1 (line 135)
   - `ChargeSideChainIndexingFee()` called, making external call to Token contract (line 141)
4. During the Token contract's `TransferFrom` callback, attacker calls `GetSideChainIdAndHeight()`
5. Function loops from i=1 to serialNumber=1, retrieves chainId for i=1
6. `State.SideChainInfo[chainId]` returns null (not yet set)
7. Code attempts to access `sideChainInfo.SideChainStatus` (line 109)

**Expected Result**: Function should skip null entries and return successfully

**Actual Result**: NullReferenceException thrown, transaction reverts with error

**Success Condition**: Transaction calling `GetSideChainIdAndHeight()` during the reentrancy window fails with NullReferenceException, demonstrating the missing null check vulnerability.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L50-52)
```csharp
        var info = State.SideChainInfo[input.Value];
        Assert(info != null, "Side chain not found.");
        return new GetChainStatusOutput { Status = info.SideChainStatus };
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L57-58)
```csharp
        var info = State.SideChainInfo[input.Value];
        Assert(info != null, "Side chain not found.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L84-85)
```csharp
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L107-110)
```csharp
            var chainId = GetChainId(i);
            var sideChainInfo = State.SideChainInfo[chainId];
            if (sideChainInfo.SideChainStatus == SideChainStatus.Terminated)
                continue;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L120-120)
```csharp
        var dict = GetSideChainIdAndHeight(new Empty());
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L133-133)
```csharp
        var sideChainIdAndHeightDict = GetSideChainIdAndHeight(new Empty());
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L135-137)
```csharp
        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
        var chainId = GetChainId(serialNumber);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L141-141)
```csharp
        ChargeSideChainIndexingFee(input.Proposer, sideChainCreationRequest.LockedTokenAmount, chainId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L152-152)
```csharp
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L154-154)
```csharp
        State.SideChainInfo[chainId] = sideChainInfo;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L170-174)
```csharp
    private void TransferFrom(TransferFromInput input)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        State.TokenContract.TransferFrom.Send(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L665-666)
```csharp
        SetContractStateRequired(State.AssociationContract, SmartContractConstants.AssociationContractSystemName);
        State.AssociationContract.CreateOrganization.Send(createOrganizationInput);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L700-702)
```csharp
            var info = State.SideChainInfo[chainId];
            if (info == null || info.SideChainStatus == SideChainStatus.Terminated)
                return false;
```
