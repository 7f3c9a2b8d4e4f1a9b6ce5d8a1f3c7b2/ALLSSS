### Title
Unbounded EncryptedPieces and DecryptedPieces Dictionaries Allow Resource Exhaustion in Consensus Updates

### Summary
The `ExtractInformationToUpdateConsensus` function and subsequent `PerformSecretSharing` processing lack application-level bounds validation on the size and content of `EncryptedPieces` and `DecryptedPieces` dictionaries. While infrastructure-level protections (5MB transaction limit, 128KB state size limit) provide partial mitigation, a malicious elected miner can submit excessively large encrypted data that wastes block space and could cause the Round object to approach state size limits, potentially causing legitimate consensus transactions to fail and disrupting block production.

### Finding Description

The vulnerability exists across multiple locations in the consensus processing flow: [1](#0-0) [2](#0-1) 

The root cause is the absence of validation before adding user-provided encrypted/decrypted pieces to the Round state object. Specifically:

1. In `PerformSecretSharing`, the code directly adds all entries from `input.EncryptedPieces` without validating dictionary size, key validity (whether keys are actual miner public keys), or byte array sizes.

2. No check exists to ensure the number of encrypted pieces corresponds to the actual number of miners in the round (should be at most N-1 where N is the miner count).

3. No validation ensures byte arrays contain reasonably-sized encrypted data (legitimate encrypted hash values should be 100-300 bytes).

The execution path is:
1. Elected miner calls `UpdateValue` with malicious `UpdateValueInput`
2. `ProcessConsensusInformation` is invoked
3. `PerformSecretSharing` adds unvalidated data to `minerInRound.EncryptedPieces`
4. `TryToUpdateRoundInformation` attempts to write the Round object to state [3](#0-2) 

While the state size limit (128KB) prevents persistence of excessively large Round objects by throwing `StateOverSizeException`, this protection occurs too late—after block space has been consumed and processing resources wasted. [4](#0-3) 

### Impact Explanation

The concrete impacts are:

**Resource Waste**: A malicious miner can submit UpdateValue transactions with EncryptedPieces approaching the 5MB transaction limit. Even though the state write will fail if the Round object exceeds 128KB, the transaction still consumes block space and processing resources. [5](#0-4) 

**Consensus DoS**: With typical miner counts (17-100), normal operation might use 50-80KB for the Round object. If multiple miners submit large EncryptedPieces (even if individually they cause state write failures), the accumulated legitimate data from other miners could push the Round object close to the 128KB limit. At this threshold, any subsequent UpdateValue transaction from an honest miner could fail due to state size overflow, disrupting consensus block production.

**Severity Justification**: Medium severity because while the attack requires being an elected miner (high cost/stake requirement), it can disrupt the critical consensus mechanism affecting the entire network. The infrastructure limits prevent unlimited memory exhaustion but don't prevent the DoS scenario.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be an elected miner, which requires:
- Significant token stake
- Winning votes in the election process
- Passing initial validation checks [6](#0-5) 

**Attack Complexity**: Once elected, executing the attack is straightforward—simply craft an UpdateValueInput with excessively large EncryptedPieces (many entries or large byte arrays up to transaction limits).

**Feasibility Conditions**: The attack is practically executable within AElf's execution model. The transaction will pass signature verification and size checks at the pool level, and only fail at state write if limits are exceeded. [7](#0-6) 

**Detection/Operational Constraints**: The attack is detectable through monitoring of abnormally large consensus transactions and state write failures, but detection doesn't prevent the block space waste or potential DoS.

**Probability**: Moderate—requires becoming an elected miner (barrier to entry), but once achieved, easy to execute repeatedly. Could also occur accidentally from buggy miner client implementations.

### Recommendation

Implement application-level bounds validation in `PerformSecretSharing`:

1. **Validate EncryptedPieces key count**: Ensure the number of entries does not exceed the current miner count minus one.

2. **Validate keys are legitimate miners**: Check that all keys in EncryptedPieces correspond to actual miner public keys in `round.RealTimeMinersInformation`.

3. **Validate byte array sizes**: Impose maximum size limits for individual encrypted pieces (e.g., 1KB per piece, sufficient for encrypted 32-byte hashes with encryption overhead).

4. **Add similar validation for DecryptedPieces**: Before accessing `round.RealTimeMinersInformation[decryptedPreviousInValue.Key]`, verify the key exists to prevent exceptions.

Example validation to add in `PerformSecretSharing`:

```csharp
// Validate encrypted pieces count and keys
Assert(input.EncryptedPieces.Count <= round.RealTimeMinersInformation.Count - 1, 
    "Too many encrypted pieces.");
foreach (var piece in input.EncryptedPieces)
{
    Assert(round.RealTimeMinersInformation.ContainsKey(piece.Key), 
        "Invalid miner public key in encrypted pieces.");
    Assert(piece.Value.Length <= 1024, 
        "Encrypted piece size exceeds maximum.");
}
```

Add regression test cases covering:
- UpdateValue with EncryptedPieces count exceeding miner count
- UpdateValue with invalid public keys in EncryptedPieces
- UpdateValue with excessively large byte arrays in EncryptedPieces

### Proof of Concept

**Initial State**:
- Network has 17 elected miners
- Current round is in normal operation
- Attacker is one of the elected miners

**Attack Steps**:

1. **Attacker crafts malicious UpdateValueInput**:
   - Create EncryptedPieces dictionary with 100 entries (far exceeding 16 legitimate other miners)
   - Each entry has 50KB byte array (total 5MB approaching transaction limit)
   - Keys are arbitrary strings, not necessarily valid miner public keys

2. **Attacker submits UpdateValue transaction**:
   - Transaction passes pool validation (under 5MB limit)
   - PreCheck passes (attacker is elected miner)
   - PerformSecretSharing adds all 5MB to minerInRound.EncryptedPieces without validation

3. **Expected Result**: Transaction should be rejected with validation error

4. **Actual Result**: 
   - No validation occurs
   - Data is added to Round object
   - State write fails with StateOverSizeException (Round object exceeds 128KB)
   - Transaction fails but has wasted block space and processing time

5. **DoS Scenario** (multiple rounds):
   - Multiple miners submit large but not-too-large EncryptedPieces
   - Round object size accumulates to ~120KB
   - Next honest miner's UpdateValue fails due to state overflow
   - Consensus block production is disrupted

**Success Condition**: The attack succeeds if the malicious transaction is processed (consuming resources) despite containing invalid oversized EncryptedPieces, or if legitimate transactions begin failing due to accumulated Round object size approaching state limits.

### Notes

The protobuf definition allows `map<string, bytes>` with no inherent size constraints: [8](#0-7) [9](#0-8) 

While the legitimate SecretSharingService generates appropriately-sized encrypted pieces, the contract accepts whatever data is provided in the transaction without validation. The infrastructure protections (transaction and state size limits) prevent worst-case unbounded growth but are insufficient for proper application-level security.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L45-45)
```csharp
            EncryptedPieces = { minerInRound.EncryptedPieces },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/BasicTransactionValidationProvider.cs (L32-41)
```csharp
        if (transaction.CalculateSize() > TransactionPoolConsts.TransactionSizeLimit)
        {
            await LocalEventBus.PublishAsync(new TransactionValidationStatusChangedEvent
            {
                TransactionId = transactionId,
                TransactionResultStatus = TransactionResultStatus.NodeValidationFailed,
                Error = "Transaction size exceeded."
            });
            return false;
        }
```

**File:** protobuf/aedpos_contract.proto (L210-212)
```text
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
```

**File:** protobuf/aedpos_contract.proto (L294-296)
```text
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```
