### Title
Deterministic Random Hash Generation Causes DoS in NFT Protocol Creation for Multiple Transactions per Block

### Summary
The `GenerateSymbolNumber()` function in the NFT contract generates symbol numbers using a hash computed from only `Context.Sender` and random bytes retrieved for the previous block height. When the same sender submits multiple NFT protocol creation transactions within the same block, all transactions compute identical `randomHash` values, causing the second and subsequent transactions to enter an infinite loop in the collision-avoidance mechanism and ultimately fail after exceeding the execution branch threshold.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function where the random hash is computed as: [1](#0-0) 

The `randomBytes` value is obtained from the consensus contract using `Context.CurrentHeight.Sub(1)` as the height parameter: [2](#0-1) 

The consensus contract's `GetRandomBytes` implementation returns the same random hash for all calls with the same block height: [3](#0-2) 

When multiple transactions from the same sender are included in the same block:
1. All transactions have identical `Context.Sender` values
2. All transactions have identical `Context.CurrentHeight` values
3. All transactions call `GetRandomBytes` with the same height parameter (`CurrentHeight - 1`)
4. All transactions receive identical `randomBytes` from the consensus contract's state storage
5. All transactions compute identical `randomHash` values

The collision detection mechanism attempts to find an unused number but fails: [4](#0-3) 

Since `Context.ConvertHashToInt64` is a deterministic function, the same `randomHash` always produces the same `randomNumber`. After the first transaction marks the number as used, subsequent transactions with the same hash enter an infinite loop:
- They compute the same `randomNumber` from the same `randomHash`
- They find `State.IsCreatedMap[randomNumber]` is `true`
- They loop back and recompute the same `randomNumber`
- This continues until the execution branch threshold is exceeded

The function is invoked through the public `Create` method: [5](#0-4) 

### Impact Explanation

**Operational Impact - DoS of NFT Protocol Creation**

When a user (intentionally or accidentally) submits multiple NFT protocol creation transactions in the same block:
- The first transaction succeeds and creates an NFT protocol
- All subsequent transactions fail after consuming maximum execution resources
- Failed transactions still charge transaction fees to users
- Execution resources are wasted until the branch threshold is hit (15,000 branches) [6](#0-5) 

**Who is Affected:**
- Users attempting to create multiple NFT protocols in rapid succession
- Users who submit transactions that get batched into the same block
- The network's execution resources are depleted unnecessarily

**Severity: HIGH** because:
- Core NFT functionality is impaired
- Users lose transaction fees for failed transactions
- Easy to trigger without malicious intent
- No workaround available except waiting for next block
- Violates the Token Supply & Fees invariant requiring NFT uniqueness checks to function correctly

### Likelihood Explanation

**Attack Complexity: LOW**
- No special privileges required - any user can call the `Create` method
- No complex preconditions needed
- Exploit is deterministic and repeatable

**Attacker Capabilities:**
- Standard transaction submission capability
- Ability to submit multiple transactions (either intentionally or through automated systems)

**Feasibility Conditions:**
- Transactions must be from the same sender
- Transactions must be included in the same block
- This commonly occurs when users submit transactions in rapid succession or when transaction batching occurs

**Economic Rationality:**
- Users inadvertently trigger this when legitimately trying to create multiple NFT protocols
- Attacker could intentionally cause DoS by submitting multiple creation transactions
- Transaction fees are lost for failed transactions, but this affects the attacker too

**Detection/Operational Constraints:**
- The issue is not easily detectable before transaction execution
- No runtime protection exists beyond execution limits
- Failed transactions appear as normal execution failures

**Probability: HIGH** - This will occur whenever users naturally attempt to create multiple NFT protocols in quick succession, making it a practical operational issue rather than just a theoretical vulnerability.

### Recommendation

**Immediate Fix:**
Include transaction-specific entropy in the random hash computation by incorporating `Context.TransactionId`: [7](#0-6) 

Modify the hash computation to:
```csharp
var randomHash = HashHelper.ConcatAndCompute(
    HashHelper.ComputeFrom(Context.Sender),
    HashHelper.ComputeFrom(randomBytes),
    HashHelper.ComputeFrom(Context.TransactionId));
```

This ensures each transaction computes a unique hash even when from the same sender in the same block.

**Additional Safeguards:**
1. Add a maximum iteration limit to the `do-while` loop to fail gracefully if collision resolution takes too long
2. Consider using a more robust random number generation approach that inherently includes transaction-level uniqueness
3. Add explicit validation to detect and reject multiple NFT creation transactions from the same sender in the same block at the entry point

**Test Cases:**
1. Test multiple `Create` calls from the same sender in the same block
2. Verify each transaction generates a unique symbol
3. Verify no transactions fail due to collision loop
4. Test edge case of maximum concurrent creations per sender per block

### Proof of Concept

**Initial State:**
- NFT contract deployed and initialized
- User account with sufficient balance for multiple transaction fees
- No existing NFT protocols created

**Exploitation Steps:**

1. **User submits first Create transaction:**
   - Calls `Create(CreateInput)` with NFT type "Art"
   - Transaction is included in block N
   - `GenerateSymbolNumber()` generates hash from:
     - `Context.Sender` = User Address
     - `randomBytes` = Consensus random hash for block N-1
   - Computes `randomNumber` = e.g., 123456789
   - Sets `State.IsCreatedMap[123456789] = true`
   - Successfully creates NFT protocol "AR123456789"

2. **User submits second Create transaction:**
   - Calls `Create(CreateInput)` with NFT type "Music"  
   - Transaction is included in same block N
   - `GenerateSymbolNumber()` generates hash from:
     - `Context.Sender` = Same User Address
     - `randomBytes` = Same consensus random hash for block N-1
   - Computes identical `randomHash` as first transaction
   - Computes `randomNumber` = 123456789 (same as first)
   - Checks `State.IsCreatedMap[123456789]` = `true`
   - Loops: recomputes same `randomNumber` = 123456789
   - Continues looping, incrementing branch counter
   - After 15,000 iterations, exceeds `ExecutionBranchThreshold`
   - Transaction fails with `RuntimeBranchThresholdExceededException`

**Expected vs Actual Result:**
- **Expected:** Both transactions succeed, creating "AR123456789" and "MU234567890" (or similar unique symbols)
- **Actual:** First transaction succeeds, second transaction enters infinite loop and fails after exceeding execution limits

**Success Condition for Exploit:**
The vulnerability is confirmed when the second transaction fails due to branch threshold exceeded, which can be verified by checking transaction execution results and observing that no second NFT protocol was created.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-74)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-129)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }

    public override BytesValue GetRandomBytes(BytesValue input)
    {
        var height = new Int64Value();
        height.MergeFrom(input.Value);
        return GetRandomHash(height).ToBytesValue();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/CSharpSmartContractContext.cs (L54-57)
```csharp
    /// <summary>
    ///     The ID of the transaction that's currently executing.
    /// </summary>
    public Hash TransactionId => SmartContractBridgeContextImplementation.TransactionId;
```
