# Audit Report

## Title
Insufficient Behavior Validation Allows Premature Round/Term Transition in AEDPoS Consensus

## Summary
The AEDPoS consensus contract's `GetConsensusBlockExtraData()` method accepts consensus behavior from trigger information without validating whether that behavior is appropriate for the current consensus state and time. This allows any active miner to force premature `NextRound` or `NextTerm` transitions during their regular time slot, bypassing the intended extra block time slot validation mechanism and disrupting consensus round progression.

## Finding Description

The vulnerability exists in the behavior dispatch and validation pipeline:

**Root Cause - Unchecked Behavior Dispatch:**
The `GetConsensusBlockExtraData()` function performs a simple switch statement on the `triggerInformation.Behaviour` field without validating whether the requested behavior is valid for the current consensus state or timing. [1](#0-0) 

**Missing Timing/Authority Validation:**
When `NextRound` behavior is dispatched, `GetConsensusExtraDataForNextRound()` generates the next round information without any checks for: (1) whether the current time is in the extra block time slot, (2) whether the sender is the designated extra block producer, or (3) whether it's appropriate to terminate the current round. [2](#0-1) 

Similarly, `GetConsensusExtraDataForNextTerm()` has no time-based or state-based validation. [3](#0-2) 

**Validation Pipeline Gap:**
The validation pipeline in `ValidateBeforeExecution()` adds behavior-specific validators for `NextRound`, but none verify that the behavior itself is appropriate for the current time and round state. [4](#0-3) 

**TimeSlotValidationProvider Limitation:**
For `NextRound` behavior with a new `RoundId`, `TimeSlotValidationProvider` only validates the internal structure of the new round via `CheckRoundTimeSlots()`, which verifies equal time slot intervals but NOT whether it's the appropriate time to terminate the current round or whether the sender has authority. [5](#0-4) 

The `CheckRoundTimeSlots()` method only validates structural properties (equal intervals, non-zero mining time) but not timing appropriateness or authority. [6](#0-5) 

**RoundTerminateValidationProvider Limitation:**
This validator only checks that round numbers increment correctly and `InValues` are null, but does not validate timing or authority for round termination. [7](#0-6) 

**Weak Permission Check:**
The `PreCheck()` in `ProcessConsensusInformation()` only verifies the sender is in the current or previous miner list, but doesn't validate behavior appropriateness. [8](#0-7) 

The trigger information containing the behavior field is generated client-side and accepted without verification that it matches what the contract's `GetConsensusCommand()` would legitimately return for the current consensus state.

## Impact Explanation

**Consensus Integrity Violation:**
A malicious miner can force premature round transitions, causing other miners who haven't yet had their time slots to miss their turn. This directly violates the critical consensus invariant of correct round transitions and time-slot validation.

**Mining Reward Manipulation:**
When `ProcessNextRound()` executes, it calls `TryToDetectEvilMiners()` to identify miners who missed their designated time slots. Miners who haven't had their turn due to premature round termination will be incorrectly marked as evil and penalized. [9](#0-8) 

The evil miner detection is based on `MissedTimeSlots` count, which will be incorrectly incremented for innocent miners. [10](#0-9) 

**LIB Calculation Disruption:**
The Last Irreversible Block (LIB) height calculation depends on miners producing blocks in their designated time slots according to the round schedule. Premature round transitions disrupt this calculation, potentially affecting finality guarantees.

**Term Transition Manipulation:**
For main chains, attackers can force premature `NextTerm` behavior, triggering early term changes, election snapshots, and treasury releases at incorrect times. [11](#0-10) 

## Likelihood Explanation

**High Likelihood - Attacker Capabilities:**
Any miner in the active miner list can execute this attack by modifying their local node software to:
1. Override the consensus command generation to return `NextRound` or `NextTerm` behavior
2. Generate trigger information with the malicious behavior
3. Produce a block during their regular time slot with the invalid behavior
4. Broadcast the block to the network

**Low Complexity:**
The trigger information behavior field is populated client-side. The contract's `GetConsensusCommand()` method determines proper behavior based on round state and timing, but this determination happens on-chain and is advisory - the contract accepts trigger information with arbitrary behavior without cross-validation. [12](#0-11) 

**No Special Privileges Required:**
The attacker only needs to be an active miner in the miner list, which is a normal operational role. No additional privileged access or role compromise is required beyond being a legitimate consensus participant.

**Practical Execution:**
1. Attacker miner waits for their regular time slot
2. Instead of producing proper `UpdateValue` or `TinyBlock` behavior, they craft `NextRound` trigger information
3. Block passes all validations because no validator checks behavior timing/authority appropriateness
4. Round prematurely transitions via `ProcessNextRound()`, disrupting other miners

**Detection Difficulty:**
The attack appears as a valid consensus transaction that passes all validation checks. It's difficult to distinguish from legitimate extra block producer behavior without detailed timing analysis.

## Recommendation

Add explicit validation in `ValidateBeforeExecution()` or create a dedicated validator that checks for `NextRound` and `NextTerm` behaviors:

1. **Verify Extra Block Producer Authority:** Check that the sender is the designated extra block producer for round termination behaviors.
2. **Verify Timing:** Check that the current time is within the extra block time slot when `NextRound` or `NextTerm` is requested.
3. **Cross-validate Behavior:** Compare the provided behavior against what `GetConsensusCommand()` would return for the current consensus state, or embed this check directly in the validation pipeline.

The validation should occur in `TimeSlotValidationProvider` for `NextRound` behaviors with new `RoundId`, checking:
- `Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime()`
- `sender == supposedExtraBlockProducer` (identified via `IsExtraBlockProducer` flag)

Similar logic exists in `IsCurrentMiner()` view method and should be enforced during validation. [13](#0-12) 

## Proof of Concept

A test can be constructed as follows:

1. Initialize a consensus round with multiple miners
2. During a regular miner's time slot (not the extra block producer, not during extra block time slot)
3. Craft trigger information with `NextRound` behavior instead of `UpdateValue`
4. Call `GetConsensusExtraData()` to generate the block extra data
5. Call `ValidateConsensusBeforeExecution()` - it will return Success=true
6. Execute the consensus transaction via `NextRound()`
7. Observe that:
   - The round transitions prematurely
   - Miners who haven't had their turn miss their time slots
   - `ProcessNextRound()` may mark them as evil miners
   - The attack succeeds despite being outside the proper extra block time slot

The vulnerability is confirmed by the absence of timing/authority checks in the validation pipeline for round termination behaviors.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```
