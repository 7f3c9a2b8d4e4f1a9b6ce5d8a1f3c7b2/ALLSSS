### Title
First-Time Miners Can Claim Welcome Rewards Through Pubkey Replacement

### Summary
When a first-time miner replaces their public key during their first term of mining, the replacement pubkey incorrectly inherits `LatestMinedTerm = 0`, causing it to qualify for welcome rewards at term end. This allows miners to receive welcome rewards for a replacement pubkey that is not genuinely a new miner, resulting in unfair reward distribution.

### Finding Description

The vulnerability exists in the `RecordMinerReplacement` function where it blindly transfers the `LatestMinedTerm` value from the old pubkey to the new pubkey without validating whether the old pubkey has completed at least one mining term. [1](#0-0) 

When `IsOldPubkeyEvil` is false (which is the default value used by the consensus contract), the code transfers `LatestMinedTerm` from old to new pubkey. The consensus contract never sets this field to true: [2](#0-1) 

The exploitation path works as follows:

1. A miner is elected for the first time in Term N. During this term, their `LatestMinedTerm` remains 0 because `UpdateStateAfterDistribution` only updates this value at term end: [3](#0-2) 

2. During Term N, the miner calls `ReplaceCandidatePubkey` to replace their pubkey. The consensus contract updates the current round information to replace the old pubkey with the new one: [4](#0-3) 

3. The Treasury contract's `RecordMinerReplacement` transfers `LatestMinedTerm = 0` to the new pubkey.

4. At the end of Term N, the `Release` function identifies "new" miners by checking if `LatestMinedTerm[p] == 0`: [5](#0-4) 

5. The replacement pubkey passes this check (LatestMinedTerm = 0) and is incorrectly added to `newElectedMiners`. The `previousTermInformation` contains the replacement pubkey (not the original) because the round was updated during the replacement.

6. `UpdateWelcomeRewardWeights` then adds the replacement pubkey as a beneficiary for welcome rewards: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: The replacement pubkey receives welcome rewards that should only be distributed to genuinely new miners. Welcome rewards are specifically designed to incentivize new miners joining the network, as indicated by the Treasury contract's design where these are one of the three sub-schemes under "Mining Reward": [7](#0-6) 

**Affected Parties**: 
- Legitimate new miners receive diluted welcome rewards as the pool is shared with illegitimate recipients
- The protocol's economic model is violated as welcome rewards are meant to be a one-time incentive for new participation, not a bonus for pubkey changes

**Severity Justification**: This is a HIGH severity issue because:
1. It directly misallocates treasury funds designated for welcome rewards
2. It can be systematically exploited by any first-time miner
3. It undermines the intended economic incentive structure of the protocol

### Likelihood Explanation

**Attacker Capabilities**: Any first-time elected miner can exploit this. The only requirement is being elected as a miner for the first time and having the authority to call `ReplaceCandidatePubkey`: [8](#0-7) 

**Attack Complexity**: Low. The attack requires:
1. Being elected as a miner (legitimate participation)
2. Calling `ReplaceCandidatePubkey` during the first term
3. Waiting for term end when `Release` is called

**Feasibility Conditions**: The attack is always feasible for first-time miners. There are no additional preconditions or race conditions to satisfy.

**Detection**: The exploitation is difficult to distinguish from legitimate pubkey replacements, as the protocol allows miners to replace their pubkeys for valid operational reasons (e.g., key rotation).

**Probability**: HIGH. First-time miners are a regular occurrence in the network, and they can exploit this either intentionally for extra rewards or accidentally if they need to replace their pubkey for legitimate reasons during their first term.

### Recommendation

Modify the `RecordMinerReplacement` function to preserve the replacement status when `LatestMinedTerm = 0`:

**Code-level Mitigation**:
1. When transferring `LatestMinedTerm` from old to new pubkey, do not transfer a zero value. Instead, set the new pubkey's `LatestMinedTerm` to the `CurrentTermNumber` to indicate they are already participating in this term.

2. Alternatively, introduce a separate state mapping to track pubkey replacements and exclude them from welcome reward eligibility:
   - Add `State.ReplacementPubkeys[newPubkey] = currentTermNumber` in `RecordMinerReplacement`
   - Modify the filter in `Release` to also check `!State.ReplacementPubkeys.Contains(p)`

**Invariant Checks**:
- Ensure that welcome rewards are only distributed to pubkeys that have never participated in mining before
- Ensure replacement pubkeys maintain continuity with their predecessor's mining history

**Test Cases**:
1. Test that a first-time miner who replaces their pubkey during Term N does NOT receive welcome rewards
2. Test that a genuinely new miner in Term N+1 still receives welcome rewards correctly
3. Test that replacement during subsequent terms (when LatestMinedTerm > 0) works correctly

### Proof of Concept

**Initial State**:
- Term N begins, Alice is elected as a miner for the first time
- `State.LatestMinedTerm[Alice] = 0` (Alice has not completed a term)
- Alice is mining blocks in Term N

**Attack Steps**:
1. During Term N, Alice (or the candidate admin) calls `Election.ReplaceCandidatePubkey(Alice, Bob)`
2. `Election.PerformReplacement` is executed
3. `AEDPoS.RecordCandidateReplacement` updates the current round to replace Alice with Bob in `RealTimeMinersInformation`
4. `Treasury.RecordMinerReplacement` is called with `IsOldPubkeyEvil = false` (default)
5. `State.LatestMinedTerm[Bob] = 0` (inherited from Alice)
6. `State.LatestMinedTerm.Remove(Alice)`

**At Term N End**:
1. `Release(PeriodNumber = N)` is called
2. `previousTermInformation` contains Bob (not Alice) due to the round update
3. `maybeNewElectedMiners` includes Bob from `previousTermInformation.RealTimeMinersInformation.Keys`
4. Filter check: `State.LatestMinedTerm[Bob] == 0` ✓ (Bob has LatestMinedTerm = 0)
5. Filter check: `!GetInitialMinerList().Contains(Bob)` ✓ (Bob is not an initial miner)
6. Bob is added to `newElectedMiners`
7. `UpdateWelcomeRewardWeights` adds Bob as a beneficiary for welcome rewards
8. Bob receives welcome rewards in the distribution

**Expected Result**: Bob should NOT receive welcome rewards because Bob is a replacement for Alice, who was already mining.

**Actual Result**: Bob DOES receive welcome rewards due to inheriting `LatestMinedTerm = 0`.

**Success Condition**: After term end, Bob's profit scheme entry shows shares allocated in the `VotesWeightRewardHash` (Welcome Reward) scheme for Term N+1, indicating Bob will receive welcome rewards.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L28-34)
```csharp
///     (Mining Reward for Miners) - 3
///     (Subsidy for Candidates / Backups) - 1
///     (Welfare for Electors / Voters / Citizens) - 1
///     3 sub profit schemes for Mining Rewards:
///     (Basic Rewards) - 4
///     (Welcome Rewards) - 1
///     (Flexible Rewards) - 1
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L155-156)
```csharp
        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L583-588)
```csharp
        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L766-769)
```csharp
    private void UpdateStateAfterDistribution(Round previousTermInformation, List<string> currentMinerList)
    {
        foreach (var miner in currentMinerList) State.LatestMinedTerm[miner] = previousTermInformation.TermNumber;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L864-879)
```csharp
        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-146)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L149-154)
```csharp
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```
