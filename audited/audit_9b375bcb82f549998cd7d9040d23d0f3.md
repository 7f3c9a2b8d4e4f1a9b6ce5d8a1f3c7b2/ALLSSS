# Audit Report

## Title
Insufficient Validation Allows Duplicate Mining Orders in Consensus Round Transitions

## Summary
The `NextRoundMiningOrderValidationProvider` uses `Distinct()` on `MinerInRound` objects to validate uniqueness, but protobuf-generated classes compare all fields (17 total), not just `FinalOrderOfNextRound`. This allows malicious miners to propose consensus rounds with duplicate mining orders, violating the fundamental AEDPoS invariant that each miner has a unique, deterministic time slot.

## Finding Description

The vulnerability exists in the validation logic that checks for duplicate `FinalOrderOfNextRound` values during NextRound transitions. [1](#0-0) 

The validator calls `Distinct()` on `MinerInRound` objects, where `MinerInRound` is a protobuf-generated message type with 17 fields [2](#0-1) , including `pubkey` (field 9) and `final_order_of_next_round` (field 12).

Since protobuf equality compares ALL fields, two miners with duplicate `FinalOrderOfNextRound` values but different `pubkey` values will be considered distinct objects. The validation will pass even though there are duplicate mining orders.

**How the Attack Works:**

1. A malicious miner crafts a `NextRoundInput` where multiple miners have the same `FinalOrderOfNextRound` value (e.g., MinerA and MinerB both have order 1)

2. The `ProvidedRound` comes from miner-submitted consensus header data [3](#0-2) , not from validated chain state

3. When validation runs [4](#0-3) , `Distinct()` checks if entire `MinerInRound` objects are equal

4. Since each miner has a unique `pubkey`, they are considered distinct even with duplicate orders

5. The validation passes: distinctCount equals the count of miners with `OutValue`

6. The malicious round is stored to state [5](#0-4) 

7. When generating the next round [6](#0-5) , the system orders miners by `FinalOrderOfNextRound`, but with duplicates this creates scheduling conflicts

The system expects unique `FinalOrderOfNextRound` values, treating them as "occupied orders" [7](#0-6)  when assigning miners who didn't mine to remaining slots.

## Impact Explanation

This vulnerability directly undermines consensus schedule integrity, a core invariant of the AEDPoS mechanism:

- **Consensus Ambiguity**: Multiple miners assigned the same mining order creates ambiguity about who should mine in each time slot
- **Block Production Conflicts**: Miners with duplicate orders may attempt to produce blocks simultaneously, causing forks or conflicts  
- **Network Instability**: The deterministic mining schedule that ensures orderly block production is compromised
- **Finality Risks**: Consensus conflicts affect the network's ability to reach agreement on the canonical chain

The impact is **Critical** because it breaks a fundamental protocol invariant that the entire consensus mechanism relies upon. Unlike issues affecting individual miners, this creates network-wide consensus instability affecting all participants.

## Likelihood Explanation

The likelihood is **Medium-High**:

**Attacker Requirements:**
- Must be a miner in the current round (realistic - multiple miners participate)
- Must be selected to propose NextRound (typically the extra block producer)
- This opportunity occurs regularly at every round transition

**Attack Complexity:**
- **Low** - Simply requires constructing a `NextRoundInput` with duplicate `FinalOrderOfNextRound` values
- No complex cryptographic operations needed
- No precise timing requirements
- The flawed validation accepts the malicious input

**Detection:**
- The validator specifically checks for this condition but fails due to incorrect equality semantics
- No subsequent validation catches duplicate orders
- The malicious round is accepted into chain state

The combination of regular opportunity (every round transition) and low attack complexity makes this readily exploitable once a miner is in position to propose NextRound.

## Recommendation

Fix the validation to check for duplicate `FinalOrderOfNextRound` values specifically:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    
    // Get miners with set orders
    var minersWithOrders = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .ToList();
    
    // Check for duplicate FinalOrderOfNextRound values
    var distinctOrdersCount = minersWithOrders
        .Select(m => m.FinalOrderOfNextRound)
        .Distinct()
        .Count();
    
    if (minersWithOrders.Count != distinctOrdersCount)
    {
        validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
        return validationResult;
    }
    
    // Check count matches miners who participated
    if (minersWithOrders.Count != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

This ensures:
1. The count of miners with orders equals the count of distinct order values (no duplicates)
2. The count of miners with orders equals the count who participated (completeness)

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_DuplicateMiningOrders_ShouldFail()
{
    // Arrange: Create a malicious NextRoundInput with duplicate FinalOrderOfNextRound
    var maliciousInput = new NextRoundInput
    {
        RoundNumber = 2,
        RealTimeMinersInformation = 
        {
            {
                "MinerA",
                new MinerInRound
                {
                    Pubkey = "MinerA",
                    FinalOrderOfNextRound = 1,  // Duplicate!
                    OutValue = HashHelper.ComputeFrom("A")
                }
            },
            {
                "MinerB", 
                new MinerInRound
                {
                    Pubkey = "MinerB",
                    FinalOrderOfNextRound = 1,  // Duplicate!
                    OutValue = HashHelper.ComputeFrom("B")
                }
            },
            {
                "MinerC",
                new MinerInRound
                {
                    Pubkey = "MinerC",
                    FinalOrderOfNextRound = 2,
                    OutValue = HashHelper.ComputeFrom("C")
                }
            }
        }
    };
    
    // Act: Attempt to submit NextRound with duplicate orders
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // Assert: Should fail but currently passes due to bug
    // After fix, this should fail with "Duplicate FinalOrderOfNextRound values detected."
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Duplicate FinalOrderOfNextRound");
}
```

This test demonstrates that the current validation accepts duplicate mining orders, allowing consensus schedule corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
