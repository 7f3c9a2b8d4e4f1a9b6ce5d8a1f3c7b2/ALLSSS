### Title
Incorrect Proposer Assignment in CreateProposalBySystemContract Breaks Governance Authorization Model

### Summary
The `CreateProposalBySystemContract` function validates `OriginProposer` authorization but stores `Context.Sender` (the system contract address) as the proposal's proposer instead. This breaks the governance authorization model by preventing the actual originating proposer from releasing their approved proposals, forcing mandatory dependency on system contract wrapper functions and creating potential for stuck proposals.

### Finding Description

The vulnerability exists in the Association contract (and identically in Parliament and Referendum contracts). When `CreateProposalBySystemContract` is called: [1](#0-0) 

Line 118 correctly validates that `input.OriginProposer` is authorized to propose to the organization. However, line 119 calls `CreateNewProposal(input.ProposalInput)` which internally sets the proposer to `Context.Sender`: [2](#0-1) 

At line 157, the proposer is set to `Context.Sender`, which is the system contract address (verified at line 116 of Association.cs), NOT the `input.OriginProposer` who was authorized.

This causes the Release function to fail for the actual originating proposer: [3](#0-2) 

Line 186 checks `Context.Sender == proposalInfo.Proposer`. Since `proposalInfo.Proposer` is the system contract address (not the OriginProposer), only the system contract can release the proposal, not the original user who created it.

The ACS3 standard clearly documents that `origin_proposer` represents "The actor that trigger the call": [4](#0-3) 

### Impact Explanation

**Governance Authorization Breach**: The core governance invariant is violated - authorized proposers cannot manage their own proposals. Users who are validated as authorized proposers (line 118) are incorrectly locked out from releasing their proposals.

**State Inconsistency**: The `GetProposal` view function returns incorrect proposer information (system contract address instead of the actual user), breaking transparency and auditability of governance actions: [5](#0-4) 

**Operational Impact**: This affects critical system operations including:
- Contract deployment proposals via Genesis contract (used in all contract upgrades)
- Cross-chain indexing proposals (critical for cross-chain operations)
- Any future system contracts using this pattern

**Forced Dependency**: Users must rely on system contract wrapper functions (like `ReleaseApprovedContract` in Genesis or `ReleaseCrossChainIndexingProposal` in CrossChain) that perform their own authorization checks. If these wrappers have bugs, rate limits, or are missing for some use cases, proposals become permanently stuck.

### Likelihood Explanation

**Reachability**: HIGH - This is a public method used in production workflows:
- Genesis contract uses it for all contract deployment proposals
- CrossChain contract uses it for all cross-chain indexing proposals [6](#0-5) [7](#0-6) 

**Occurrence**: GUARANTEED - Every proposal created via `CreateProposalBySystemContract` exhibits this issue. The test suite confirms the method is functional but lacks tests verifying the correct proposer is stored: [8](#0-7) 

**Exploitation**: No attacker action needed - this is a design flaw affecting normal operations. The incorrect proposer assignment happens automatically for all system-contract-initiated proposals.

### Recommendation

**Code-Level Fix**: Modify `CreateNewProposal` to accept an optional proposer parameter, and have `CreateProposalBySystemContract` pass `input.OriginProposer`:

1. Update `CreateNewProposal` signature to accept `Address proposer = null`
2. Use `proposer ?? Context.Sender` when setting the Proposer field
3. Update `CreateProposalBySystemContract` to call `CreateNewProposal(input.ProposalInput, input.OriginProposer)`

**Invariant Check**: Add assertion that for proposals created via `CreateProposalBySystemContract`, the stored proposer must equal the `OriginProposer` parameter, not the system contract address.

**Regression Test**: Add test case verifying:
1. Create proposal via `CreateProposalBySystemContract` with specific `OriginProposer`
2. Query proposal via `GetProposal` 
3. Assert `proposal.Proposer == OriginProposer`
4. Approve proposal by organization members
5. Call `Release` as `OriginProposer` (not as system contract)
6. Assert release succeeds

### Proof of Concept

**Initial State**: 
- Association organization exists with user Alice in proposer whitelist
- System contract (Genesis) is registered as system contract

**Transaction Sequence**:

1. Alice calls `ProposeNewContract` on Genesis contract
2. Genesis internally calls `AssociationContract.CreateProposalBySystemContract`:
   - `OriginProposer = Alice's address`
   - Line 118 validates Alice is in proposer whitelist ✓
   - Line 119 calls `CreateNewProposal`
   - Line 157 sets `Proposer = Context.Sender` (Genesis contract address)
   
3. Query proposal via `GetProposal`:
   - **Expected**: `proposal.Proposer == Alice's address`
   - **Actual**: `proposal.Proposer == Genesis contract address` ❌

4. Organization members approve proposal (reaches release threshold)

5. Alice attempts to call `Release` directly on Association contract:
   - Line 186 checks `Context.Sender == proposalInfo.Proposer`
   - `Context.Sender = Alice`, `proposalInfo.Proposer = Genesis contract`
   - **Expected**: Release succeeds (Alice is the actual proposer)
   - **Actual**: Transaction fails with "No permission." ❌

This demonstrates the authorization model is broken - the validated proposer cannot release their own approved proposal.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L114-121)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** protobuf/acs3.proto (L151-156)
```text
message CreateProposalBySystemContractInput {
    // The parameters of creating proposal.
    acs3.CreateProposalInput proposal_input =1;
    // The actor that trigger the call.
    aelf.Address origin_proposer = 2;
}
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L142-165)
```csharp
        // Create proposal for deployment
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L363-380)
```csharp
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput =
                new CreateProposalInput
                {
                    ContractMethodName = nameof(CreateSideChain),
                    ToAddress = Context.Self,
                    ExpiredTime =
                        Context.CurrentBlockTime.AddSeconds(SideChainCreationProposalExpirationTimePeriod),
                    Params = new CreateSideChainInput { SideChainCreationRequest = request, Proposer = proposer }
                        .ToByteString(),
                    OrganizationAddress = sideChainLifeTimeController.OwnerAddress
                },
            OriginProposer = Context.Sender
        };
        Context.SendInline(sideChainLifeTimeController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L1198-1218)
```csharp
        var input = new CreateProposalBySystemContractInput
        {
            ProposalInput = createProposalInput, OriginProposer = DefaultSender
        };
        var chain = _blockchainService.GetChainAsync();
        var blockIndex = new BlockIndex
        {
            BlockHash = chain.Result.BestChainHash,
            BlockHeight = chain.Result.BestChainHeight
        };
        //Unauthorized to propose
        var transactionResult =
            await AssociationContractStub.CreateProposalBySystemContract.SendWithExceptionAsync(input);
        transactionResult.TransactionResult.Error.ShouldContain("Not authorized to propose");
        //success
        await _smartContractAddressService.SetSmartContractAddressAsync(blockIndex,
            _smartContractAddressNameProvider.ContractStringName, DefaultSender);
        var transactionResult2 =
            await AssociationContractStub.CreateProposalBySystemContract.SendAsync(input);
        transactionResult2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```
