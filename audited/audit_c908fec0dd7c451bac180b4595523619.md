# Audit Report

## Title
Unvalidated ActualMiningTimes in RecoverFromTinyBlock Enables Term Change Manipulation and Consensus Corruption

## Summary
The AEDPoS consensus contract fails to validate that miner-provided `ActualMiningTime` timestamps in `TinyBlockInput` transactions match the actual block production time (`Context.CurrentBlockTime`). Since `ActualMiningTimes` is excluded from round hash verification and directly affects critical consensus decisions like term changes, malicious miners can provide arbitrary timestamps within their time slots to manipulate consensus behavior and corrupt the blockchain's temporal integrity.

## Finding Description

**Root Cause**: The vulnerability exists at multiple validation layers that fail to verify timestamp authenticity:

1. **No Validation in ProcessTinyBlock**: [1](#0-0) 
   The method directly adds the provided `ActualMiningTime` to blockchain state without comparing it against `Context.CurrentBlockTime`.

2. **RecoverFromTinyBlock Blindly Merges Data**: [2](#0-1) 
   This recovery function adds provided timestamps without any validation against actual block time.

3. **Hash Verification Excludes ActualMiningTimes**: [3](#0-2) 
   The `GetCheckableRound` method explicitly clears `ActualMiningTimes` before computing hashes, meaning manipulated timestamps bypass integrity verification.

4. **Validation Uses Corrupted Data**: [4](#0-3) 
   The `RecoverFromTinyBlock` is called BEFORE validation providers run, so validators check against already-corrupted data.

5. **TimeSlotValidationProvider Checks Manipulated Timestamps**: [5](#0-4) 
   The validator checks if the miner respects their time slot, but uses the already-recovered (potentially fake) timestamps from `baseRound`.

**Attack Flow**:
1. Authorized miner constructs a `TinyBlockInput` with `ActualMiningTime` set to a fake timestamp (e.g., start of their time slot instead of actual block time)
2. Miner includes transaction in their block with header timestamp set to actual time
3. During validation, `RecoverFromTinyBlock` merges the fake timestamp into `baseRound`
4. `TimeSlotValidationProvider` validates using the fake timestamp (passes if within time slot)
5. Hash verification doesn't catch it (ActualMiningTimes excluded from hash)
6. `ProcessTinyBlock` persists fake timestamp to permanent state
7. Future consensus decisions use corrupted timestamp data

## Impact Explanation

**Critical Consensus Corruption:**

1. **Term Change Manipulation**: [6](#0-5) 
   The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` to determine when to trigger term changes. Miners can:
   - **Delay term changes** by providing timestamps earlier in their slot, keeping themselves in power longer and postponing election updates and treasury releases
   - **Advance term changes** by providing timestamps later in their slot, triggering premature elections

2. **Time Slot Validation Bypass**: Miners can extend their effective mining windows by providing timestamps within their allocated slot even when the actual block time exceeds it, gaining unfair mining advantages.

3. **Consensus Command Generation Corruption**: [7](#0-6) 
   Future consensus behavior depends on `ActualMiningTimes` count and values. Manipulated timestamps corrupt tiny block limit calculations and time slot determinations.

4. **Governance Disruption**: [8](#0-7) 
   Term changes trigger election snapshots and treasury releases. Manipulated timing affects governance voting periods and financial distributions.

**Affected Parties**: All blockchain participants suffer from consensus instability, miners gain unfair advantages, governance processes are disrupted, and treasury releases are mistimed.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be an active miner in the current miner list (verified by PreCheck)
- Must have normal block production capabilities
- Can construct arbitrary transaction parameters (standard capability)

**Attack Complexity: LOW**
1. Miner is already authorized to call `UpdateTinyBlockInformation`: [9](#0-8) 
2. Miner manually constructs `TinyBlockInput` with fake `ActualMiningTime` (within their time slot to pass validation)
3. Transaction executes successfully, persisting fake timestamp
4. No cryptographic signature on timestamps themselves
5. No comparison with `Context.CurrentBlockTime` anywhere in the validation or execution path

**Feasibility: HIGH**
- No cryptographic barriers
- No timestamp verification logic exists
- Manipulation limited only by time slot duration (4-8 seconds), sufficient for meaningful impact
- Single miner can corrupt their own timestamps; coordinated miners can amplify effects

**Detection: DIFFICULT**
- Observers only see final persisted timestamps
- Cannot distinguish legitimate delays from malicious manipulation without off-chain block time comparison
- No events or logs expose the discrepancy

## Recommendation

Add explicit validation in `ProcessTinyBlock` to verify the provided timestamp matches actual block time:

```csharp
private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
{
    TryToGetCurrentRoundInformation(out var currentRound);
    
    var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
    
    // ADDED: Validate ActualMiningTime matches actual block time
    Assert(tinyBlockInput.ActualMiningTime == Context.CurrentBlockTime,
        $"Provided ActualMiningTime ({tinyBlockInput.ActualMiningTime}) must match actual block time ({Context.CurrentBlockTime}).");
    
    minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
    minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
    minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

    Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
}
```

Additionally, consider adding similar validation in `ProcessUpdateValue` for consistency: [10](#0-9) 

## Proof of Concept

```csharp
[Fact]
public async Task TinyBlock_FakeTimestamp_ShouldBeRejectedButIsnt()
{
    // Setup: Initialize consensus with first round
    await InitializeCandidates(1);
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var miner = firstRound.RealTimeMinersInformation.Values.First();
    
    // Set actual block time to end of miner's time slot
    var actualBlockTime = miner.ExpectedMiningTime.AddMilliseconds(GetMiningInterval(firstRound));
    BlockTimeProvider.SetBlockTime(actualBlockTime);
    
    // Attack: Provide fake timestamp at START of time slot (not matching actual block time)
    var fakeTimestamp = miner.ExpectedMiningTime; // Much earlier than actualBlockTime
    var maliciousInput = new TinyBlockInput
    {
        RoundId = firstRound.RoundId,
        ProducedBlocks = 1,
        ActualMiningTime = fakeTimestamp, // FAKE: Earlier than Context.CurrentBlockTime
        RandomNumber = ByteString.CopyFrom(await GenerateRandomProofAsync(BootMinerKeyPair))
    };
    
    // Expected: Should reject due to timestamp mismatch
    // Actual: Accepts and persists fake timestamp
    var result = await AEDPoSContractStub.UpdateTinyBlockInformation.SendAsync(maliciousInput);
    
    // Vulnerability: Transaction succeeds when it should fail
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify fake timestamp was persisted to state
    var updatedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var updatedMiner = updatedRound.RealTimeMinersInformation[miner.Pubkey];
    
    // Fake timestamp is now in blockchain state
    updatedMiner.ActualMiningTimes.Last().ShouldBe(fakeTimestamp);
    // But actual block time was much later
    actualBlockTime.ShouldNotBe(fakeTimestamp);
    
    // This corrupted timestamp will now affect term change calculations
    // demonstrating the consensus manipulation risk
}
```

**Notes**: 
- The vulnerability affects ALL TinyBlock transactions as there is no validation comparing provided timestamps with actual block times
- While constrained by time slot boundaries, the manipulation window of 4-8 seconds is sufficient to meaningfully delay or advance term changes when multiple miners coordinate
- The issue also affects `UpdateValue` transactions similarly at line 243: [11](#0-10)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L49-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L54-63)
```csharp
        private bool IsLastTinyBlockOfCurrentSlot()
        {
            var producedBlocksOfCurrentRound = MinerInRound.ProducedTinyBlocks;
            var roundStartTime = CurrentRound.GetRoundStartTime();

            if (CurrentBlockTime < roundStartTime) return producedBlocksOfCurrentRound == _maximumBlocksCount;

            var blocksBeforeCurrentRound = MinerInRound.ActualMiningTimes.Count(t => t < roundStartTime);
            return producedBlocksOfCurrentRound == blocksBeforeCurrentRound.Add(_maximumBlocksCount);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
