### Title
Side Chain Consensus Halt Due to Lack of TokenContract Method Signature Backward Compatibility Validation

### Summary
The AEDPoS consensus contract on side chains directly calls TokenContract methods (`Transfer`, `GetBalance`, `TransferFrom`, `Approve`, `IsTokenAvailableForMethodFee`) for resource token distribution and dividend pool operations without any error handling or compatibility validation. If a TokenContract upgrade removes or changes these method signatures, the consensus contract's `UpdateInformationFromCrossChain` and dividend pool operations will fail with method-not-found errors, causing complete side chain consensus halt. The contract upgrade process only validates version number increments but performs no automated backward compatibility checks on method signatures.

### Finding Description

**Exact Code Locations:**

The consensus contract references TokenContract without version pinning: [1](#0-0) 

Critical TokenContract method calls in resource token distribution (ACS11 implementation): [2](#0-1) [3](#0-2) 

Critical TokenContract method calls in side chain dividend pool (ACS10 implementation): [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

**Root Cause:**

When a method handler is not found during contract execution, the runtime throws an exception: [8](#0-7) 

This exception causes the transaction to fail and state changes are rolled back: [9](#0-8) 

**Why Protections Fail:**

The contract update validation only checks that the version number is subsequent/higher, not that method signatures remain compatible: [10](#0-9) 

The actual update process increments version but performs no interface compatibility validation: [11](#0-10) 

**Execution Path:**

On side chains, when cross-chain information is updated, resource token distribution must succeed before miner list updates: [12](#0-11) 

### Impact Explanation

**What Harm Occurs:**

If TokenContract is upgraded with breaking changes (method renamed, removed, or signature changed), the following critical operations fail:

1. **Resource Token Distribution Failure**: The `DistributeResourceTokensToPreviousMiners` method calls `Transfer` and `GetBalance` on TokenContract. If these methods don't exist, the method-not-found exception causes transaction failure.

2. **Cross-Chain Indexing Halt**: Since `DistributeResourceTokensToPreviousMiners` is called within `UpdateInformationFromCrossChain`, the entire cross-chain information update transaction fails, preventing miner list updates from the main chain.

3. **Consensus Halt**: Without updated miner lists, the side chain cannot continue consensus operations, effectively halting all block production.

4. **Dividend Pool Disruption**: The `Donate` method in the side chain dividend pool uses `TransferFrom` and `Approve`. If these fail, the dividend mechanism breaks.

**Quantified Impact:**

- **Side Chain Halt**: Complete cessation of block production on affected side chain
- **Economic Loss**: All transactions on the side chain fail until emergency governance intervention
- **Cross-Chain Freeze**: Cross-chain transfers to/from the affected side chain become impossible
- **Recovery Cost**: Emergency governance process to roll back TokenContract or update consensus contract

**Who Is Affected:**

- All side chain users and dApps
- Cross-chain transfer participants
- Side chain miners (no block rewards)
- Protocols relying on that side chain's operation

**Severity Justification:**

HIGH severity because:
- Impact is CRITICAL (total side chain halt)
- Likelihood is MODERATE (requires governance approval but no technical safeguards exist)
- The vulnerability is in system-critical contracts
- Recovery requires emergency governance intervention

### Likelihood Explanation

**Attacker Capabilities:**

The "attacker" could be:
1. A malicious governance participant who intentionally proposes breaking changes
2. More likely: A well-intentioned developer who refactors TokenContract without understanding downstream dependencies

**Attack Complexity:**

1. Create governance proposal via `ProposeUpdateContract` to update TokenContract
2. Proposal must pass both deployment controller approval and code check controller approval (typically requiring BP votes)
3. After approval, `ReleaseCodeCheckedContract` and `UpdateSmartContract` are executed

The governance process is defined here: [13](#0-12) [14](#0-13) 

**Feasibility Conditions:**

- Requires majority BP approval through governance
- No automated checks prevent breaking changes
- Human code review is the only defense, which is fallible
- Protobuf refactoring for "improvements" could accidentally break compatibility

**Detection/Operational Constraints:**

- Breaking changes would likely be noticed during code review by BPs
- However, no automated CI/CD checks enforce interface stability
- Integration tests don't specifically validate cross-contract method compatibility across upgrades
- The dependency is implicit, not documented in contract specifications

**Probability Reasoning:**

- **LOW** probability of intentional malicious attack (requires BP collusion)
- **MODERATE** probability of accidental breaking change (human error in refactoring)
- **HIGH** impact makes even low-probability events unacceptable
- Overall: MODERATE likelihood when considering both malicious and accidental scenarios

### Recommendation

**Exact Code-Level Mitigation:**

1. **Add Interface Compatibility Validation to Contract Upgrade Process:**

In `BasicContractZero_Helper.cs`, enhance `AssertContractVersion` or add a new validation method to check that critical system contract interfaces remain backward compatible. This should validate that all methods used by dependent contracts still exist with compatible signatures.

Location to modify: [10](#0-9) 

2. **Add Error Handling in Critical Consensus Operations:**

Wrap TokenContract calls in try-catch blocks in `DistributeResourceTokensToPreviousMiners` and `Donate` methods with graceful degradation:
- Log errors instead of failing entire transaction
- Continue consensus operations even if token distribution fails
- Accumulate failed distributions for retry

Locations to modify: [15](#0-14) [16](#0-15) 

3. **Document Cross-Contract Dependencies:**

Create explicit documentation or metadata specifying which methods in TokenContract are required by which system contracts, preventing accidental removal.

**Invariant Checks to Add:**

- Pre-upgrade validation: System contracts must maintain interface compatibility with existing dependent contracts
- Runtime check: Verify TokenContract method availability before critical consensus operations
- Post-upgrade smoke tests: Automated verification that consensus operations succeed after TokenContract upgrades

**Test Cases to Prevent Regression:**

1. **Test_TokenContract_Upgrade_Maintains_Required_Methods**: Validate that Transfer, GetBalance, TransferFrom, Approve, and IsTokenAvailableForMethodFee methods remain available after upgrades

2. **Test_UpdateInformationFromCrossChain_Survives_TokenContract_Failure**: Test that consensus operations can continue even if token distribution fails

3. **Test_Contract_Upgrade_Cross_Contract_Compatibility**: Integration test that validates all system contract interactions after any contract upgrade

Test location reference for similar integration tests: [17](#0-16) 

### Proof of Concept

**Required Initial State:**

1. Functioning side chain with AEDPoS consensus
2. Active cross-chain indexing with main chain
3. TokenContract deployed with standard methods (Transfer, GetBalance, etc.)
4. Resource tokens (READ, WRITE, STORAGE, TRAFFIC) accumulated in consensus contract balance

**Transaction Steps:**

1. **Preparation Phase:**
   - Create governance proposal to update TokenContract
   - Modify TokenContract code to rename `Transfer` method to `TransferV2` (simulating refactoring)
   - Ensure version number is incremented (passes version check)

2. **Governance Execution:**
   - Submit proposal via `ProposeUpdateContract` with the modified TokenContract code
   - Obtain deployment controller approval (BP votes)
   - Obtain code check controller approval (BP votes)
   - Execute `ReleaseCodeCheckedContract` and `UpdateSmartContract`
   - TokenContract is now updated with `TransferV2` instead of `Transfer`

3. **Trigger Failure:**
   - Cross-chain contract calls `UpdateInformationFromCrossChain` with new main chain consensus information
   - `DistributeResourceTokensToPreviousMiners` is invoked (line 53 of ACS11 implementation)
   - Attempts to call `State.TokenContract.Transfer.Send()` (line 88)
   - Runtime cannot find handler for method "Transfer" (only "TransferV2" exists)
   - Throws RuntimeException: "Failed to find handler for Transfer"

**Expected vs Actual Result:**

- **Expected**: Cross-chain information updates successfully, miner list updated, consensus continues
- **Actual**: Transaction fails with "Failed to find handler for Transfer", state rolled back, miner list not updated, subsequent cross-chain updates fail, side chain consensus halts

**Clear Success Condition:**

The vulnerability is confirmed when:
1. TokenContract upgrade with breaking changes succeeds (passes governance but no compatibility check)
2. `UpdateInformationFromCrossChain` transaction fails with method-not-found error
3. Side chain can no longer process new blocks due to inability to update miner information
4. Manual intervention (contract rollback or emergency upgrade) is required to restore operation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ContractsReferences.cs (L16-16)
```csharp
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-94)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });

        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;

        Context.LogDebug(() => $"Contributed {input.Amount} {input.Symbol}s to side chain dividends pool.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L154-158)
```csharp
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L133-137)
```csharp
            if (!_callHandlers.TryGetValue(methodName, out var handler))
                throw new RuntimeException(
                    $"Failed to find handler for {methodName}. We have {_callHandlers.Count} handlers: " +
                    string.Join(", ", _callHandlers.Keys.OrderBy(k => k))
                );
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L199-221)
```csharp
    public T Call<T>(Address fromAddress, Address toAddress, string methodName, ByteString args)
        where T : IMessage<T>, new()
    {
        var trace = AsyncHelper.RunSync(async () =>
        {
            var chainContext = new ChainContext
            {
                BlockHash = TransactionContext.PreviousBlockHash,
                BlockHeight = TransactionContext.BlockHeight - 1,
                StateCache = CachedStateProvider.Cache
            };

            var tx = new Transaction
            {
                From = fromAddress,
                To = toAddress,
                MethodName = methodName,
                Params = args
            };
            return await _transactionReadOnlyExecutionService.ExecuteAsync(chainContext, tx, CurrentBlockTime);
        });

        if (!trace.IsSuccessful()) throw new ContractCallException(trace.Error);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-144)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

        var oldCodeHash = info.CodeHash;
        var newCodeHash = HashHelper.ComputeFrom(code);
        Assert(oldCodeHash != newCodeHash, "Code is not changed.");
        AssertContractNotExists(newCodeHash);

        info.CodeHash = newCodeHash;
        info.IsUserContract = isUserContract;
        info.Version++;

        var reg = new SmartContractRegistration
        {
            Category = info.Category,
            Code = ByteString.CopyFrom(code),
            CodeHash = newCodeHash,
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.UpdateSmartContract(contractAddress, reg, null, info.ContractVersion);
        Assert(contractInfo.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({info.ContractVersion}), please correct the version number.");

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;

        Context.Fire(new CodeUpdated
        {
            Address = contractAddress,
            OldCodeHash = oldCodeHash,
            NewCodeHash = newCodeHash,
            Version = info.Version,
            ContractVersion = info.ContractVersion
        });

        Context.LogDebug(() => "BasicContractZero - update success: " + contractAddress.ToBase58());
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L366-377)
```csharp
    private void AssertContractVersion(string currentVersion, ByteString code, int category)
    {
        var contractVersionCheckResult =
            Context.CheckContractVersion(currentVersion, new SmartContractRegistration
            {
                Code = code,
                Category = category,
                CodeHash = HashHelper.ComputeFrom(code.ToByteArray())
            });
        Assert(contractVersionCheckResult.IsSubsequentVersion,
            $"The version to be deployed is lower than the effective version({currentVersion}), please correct the version number.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-232)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);

        Assert((input.Address == Context.Self || info.SerialNumber > 0) && input.ContractOperation == null ||
               info.SerialNumber == 0 && input.ContractOperation != null, "Not compatible.");

        if (input.ContractOperation != null)
        {
            ValidateContractOperation(input.ContractOperation, info.Version, codeHash);
            RemoveOneTimeSigner(input.ContractOperation.Deployer);
            AssertSameDeployer(input.Address, input.ContractOperation.Deployer);
        }

        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();

        // Create proposal for contract update
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L35-88)
```csharp
    public async Task UpdateInformationFromCrossChainTest()
    {
        SetToSideChain();
        InitialContracts();
        InitialAcs3Stubs();
        var mockedCrossChain = SampleAccount.Accounts.Last();
        var mockedCrossChainStub =
            GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
                ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
                mockedCrossChain.KeyPair);

        var headerInformation = new AElfConsensusHeaderInformation
        {
            Round = new Round
            {
                RoundNumber = 2,
                RealTimeMinersInformation =
                {
                    { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
                }
            }
        };

        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.First().PublicKey)
        });
        await CreateAndIssueToken("ELF");
        await CreateAndIssueToken("READ");
        await TokenStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "READ",
            Amount = 10_00000000,
            To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
        });

        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = headerInformation.ToByteString()
        });

        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex()).ShouldBe(headerInformation.Round.RealTimeMinersInformation.Keys);

        var balance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.Skip(1).First().PublicKey),
            Symbol = "READ"
        });
        balance.Balance.ShouldBe(2_00000000);
    }
```
