### Title
Consensus Threshold Bypass Allows Indefinite Network Degradation Through Strategic Time Slot Missing

### Summary
The `TryToDetectEvilMiners()` function uses a per-term threshold check that resets at term boundaries, allowing miners to strategically miss up to 4,319 time slots per term (just below the 4,320 threshold) indefinitely without being marked as evil nodes. This enables sustained network performance degradation of approximately 48% while avoiding automated punishment mechanisms.

### Finding Description

The evil miner detection mechanism in the AEDPoS consensus contract has a critical design flaw in how it tracks and penalizes poor miner performance.

**Root Cause:**

The detection logic checks if a miner's `MissedTimeSlots >= TolerableMissedTimeSlotsCount` (4,320 slots) at each round transition: [1](#0-0) 

The threshold constant is defined as: [2](#0-1) 

However, `MissedTimeSlots` accumulates within a term but **resets to zero at every term change**: [3](#0-2) 

**Why Protections Fail:**

1. **Accumulation Logic**: `MissedTimeSlots` increments when a miner fails to produce blocks during their assigned slot: [4](#0-3) 

2. **Detection Timing**: Evil detection only occurs during `ProcessNextRound`, not at term boundaries: [5](#0-4) 

3. **Election Independence**: When miners are marked as evil, they are banned from the election contract: [6](#0-5) 

However, miners who stay below the threshold are never marked as evil. Election victory is determined solely by vote count, not performance metrics: [7](#0-6) 

**Exploitation Path:**

With default parameters (7-day term, ~4s mining interval, 17 miners):
- Rounds per term: ~8,894 rounds
- Slots per miner per term: ~8,894 slots
- Threshold: 4,320 missed slots
- A miner can miss 4,319 slots (48.6% of their slots) per term
- At term change, counter resets to zero
- Pattern repeats indefinitely across terms

### Impact Explanation

**Network Throughput Degradation:**
A single miner staying at 4,319 missed slots represents ~48% reduced contribution from that miner. If multiple miners adopt this strategy, network block production capacity degrades proportionally, leading to:
- Slower transaction confirmation times
- Reduced network throughput and capacity
- Degraded user experience
- Potential congestion during high-demand periods

**Severity Justification (Medium):**
While this doesn't result in direct fund theft or consensus failure, it allows sustained operational degradation that undermines network reliability. The impact is medium rather than high because:
- It requires deliberate miner action
- Economic disincentives exist (lost block rewards)
- Each individual miner can only degrade their own contribution, not the entire network
- The network remains functional, just degraded

**Affected Parties:**
- Network users experiencing slower transaction processing
- Honest miners bearing increased load
- dApp developers relying on consistent performance
- Network reputation and reliability

### Likelihood Explanation

**Attacker Capabilities:**
The "attacker" is an existing authorized miner with valid credentials. No special permissions or exploits are needed—they simply choose not to produce blocks strategically.

**Attack Complexity:**
Low complexity. A miner needs to:
1. Track their accumulated `MissedTimeSlots` count
2. Produce blocks normally until approaching 4,319 missed slots
3. Resume normal operation at term change when counter resets

**Feasibility Conditions:**
- Miner must be elected and have valid mining credentials
- Miner must be willing to forgo ~48% of block rewards
- However, if alternative revenue exists (MEV opportunities, transaction fees, or simply maintaining miner status with minimal effort), this becomes economically viable

**Detection Constraints:**
The `missed_time_slots` metric is tracked and publicly visible in candidate information: [8](#0-7) 

However, no automated enforcement prevents re-election. Detection relies on off-chain monitoring and voter awareness, which may be insufficient.

**Probability:**
Medium likelihood. While economically suboptimal in pure block reward terms, miners might exploit this if:
- They value maintaining miner status over maximizing short-term rewards
- Alternative income sources offset lost block rewards
- Coordinated malicious activity seeks to degrade network performance
- Miners face operational issues but want to avoid evil node designation

### Recommendation

**Immediate Mitigations:**

1. **Implement Cumulative Tracking Across Terms:**
```
// In ProcessNextTerm, do NOT reset MissedTimeSlots to zero
// Instead, track cumulative missed slots across multiple terms
// Only reset upon explicit governance action or successful improvement
```

2. **Add Performance-Based Re-election Criteria:**
Modify the election contract to factor performance metrics into candidacy eligibility:
```
// Add minimum performance threshold for election participation
// Example: Candidates with >30% miss rate in previous term are ineligible
// Require governance approval for re-eligibility after poor performance
```

3. **Implement Progressive Penalties:**
```
// Instead of binary evil/not-evil detection:
// - Warning at 2,000 missed slots
// - Reduced rewards at 3,000 missed slots  
// - Temporary suspension at 4,000 missed slots
// - Permanent ban at 5,000 missed slots
```

**Code-Level Changes:**

In `ProcessNextTerm`:
```csharp
// Before resetting, check for consistently poor performance
foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
{
    // Track historical performance instead of resetting
    var historicalMissRate = CalculateHistoricalMissRate(minerInRound.Pubkey);
    if (historicalMissRate > ACCEPTABLE_THRESHOLD)
    {
        // Mark as underperforming, reduce eligibility
    }
    
    // Only reset if performance is acceptable
    if (minerInRound.MissedTimeSlots < ACCEPTABLE_THRESHOLD)
    {
        minerInRound.MissedTimeSlots = 0;
    }
}
```

**Invariant Checks:**
- Miners with >40% cumulative miss rate across N terms must be flagged
- Election contract must validate performance history before allowing candidacy
- Governance must review and approve re-election of previously flagged miners

**Test Cases:**
- Test miner staying at 4,319 missed slots across multiple terms
- Verify detection triggers before threshold bypass is possible
- Test performance metric influence on re-election eligibility
- Validate progressive penalty application at various miss rate levels

### Proof of Concept

**Initial State:**
- Network running with default parameters (7-day terms, 17 miners)
- Malicious miner M is an elected miner in good standing
- Current term is T, round is R

**Attack Steps:**

1. **Term T, Rounds 1-4,575:** Miner M produces blocks normally
   - `MissedTimeSlots[M] = 0`

2. **Term T, Rounds 4,576-8,894:** Miner M deliberately skips all assigned slots
   - Each missed slot increments `MissedTimeSlots[M]` by 1
   - After 4,319 missed slots: `MissedTimeSlots[M] = 4,319`
   - Check: `4,319 < 4,320` → NOT marked as evil

3. **Term T ends, Term T+1 begins:** `ProcessNextTerm()` executes
   - Line 168: `CountMissedTimeSlots()` counts final round
   - Line 201: Performance reported to Election contract
   - Line 181: `MissedTimeSlots[M] = 0` (RESET)
   
4. **Term T+1:** Miner M repeats steps 1-2
   - Continues to be re-elected based on vote count alone
   - Performance metric visible but not enforced

**Expected vs Actual Result:**

*Expected:* Miner with ~48% miss rate should be penalized or prevented from re-election

*Actual:* Miner continues indefinitely with no automated penalty, only losing block rewards for missed slots

**Success Condition:**
Miner M operates for 5+ consecutive terms maintaining 4,319 missed slots per term without being marked as evil or losing mining eligibility, demonstrating the threshold bypass vulnerability.

### Notes

The vulnerability fundamentally stems from the **per-term reset mechanism** combined with **threshold-based binary detection** and **vote-only election criteria**. While economic incentives (lost rewards) provide some deterrent, they are insufficient protection against:

1. Miners with alternative revenue sources
2. Coordinated attacks to degrade network performance
3. Operational incompetence masked as strategic behavior
4. Miners prioritizing status over short-term rewards

The current performance tracking in `CandidateInformation` is informational only and not enforced by the protocol, making it a monitoring tool rather than a security control.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L52-55)
```csharp
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-81)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
```

**File:** protobuf/election_contract.proto (L365-380)
```text
message CandidateInformation {
    // Candidate’s public key.
    string pubkey = 1;
    // The number of terms that the candidate is elected.
    repeated int64 terms = 2;
    // The number of blocks the candidate has produced.
    int64 produced_blocks = 3;
    // The time slot for which the candidate failed to produce blocks.
    int64 missed_time_slots = 4;
    // The count of continual appointment.
    int64 continual_appointment_count = 5;
    // The transaction id when the candidate announced.
    aelf.Hash announcement_transaction_id = 6;
    // Indicate whether the candidate can be elected in the current term.
    bool is_current_candidate = 7;
}
```
