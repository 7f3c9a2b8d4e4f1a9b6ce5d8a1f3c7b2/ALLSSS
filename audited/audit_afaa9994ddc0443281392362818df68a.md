### Title
Lack of Emergency Recovery Mechanism for Compromised Method Fee Controller

### Summary
The `ChangeMethodFeeController` function in TokenHolder contract (and all other ACS1-implementing contracts) has no emergency override mechanism to revert malicious controller changes. If the controller organization is compromised, an attacker can permanently transfer control to their own organization with no recovery path, as only the current controller can change the controller.

### Finding Description

The `ChangeMethodFeeController` function implements strict authorization that only allows the current controller's owner address to change the controller: [1](#0-0) 

The authorization check requires the sender to be the current controller's OwnerAddress: [2](#0-1) 

While an Emergency Response Organization exists in the Parliament contract with high approval thresholds (90%): [3](#0-2) 

And is used for emergency operations in other contracts like Election: [4](#0-3) [5](#0-4) 

**However**, `ChangeMethodFeeController` has NO such emergency override check. This pattern is consistent across all 15 contracts implementing ACS1, creating a systemic governance vulnerability.

The default controller is Parliament's default organization requiring 66.67% miner approval: [6](#0-5) 

If this organization is compromised through social engineering, key theft, or coordinated malicious miners, an attacker can execute `ChangeMethodFeeController` to transfer control to their own organization. Once changed, ONLY the new malicious controller can change it back, creating an irrecoverable governance takeover.

### Impact Explanation

**Governance Impact**: Permanent loss of method fee control for critical system contracts (TokenHolder, MultiToken, Parliament, Consensus, Election, Treasury, etc.). The attacker gains exclusive authority to:
- Set arbitrary transaction fees, making contract functions economically unusable
- Extract value by forcing users to pay excessive fees
- Disable critical contract functionality through prohibitive fee structures

**Affected Parties**: 
- All users of the compromised contract (forced to pay attacker-controlled fees)
- Protocol governance (permanently locked out of fee management)
- System integrity (critical infrastructure functions may become unusable)

**Severity Justification**: Medium severity due to:
- HIGH impact (permanent governance takeover affecting all users)
- MEDIUM/LOW likelihood (requires compromising 67% of miners, but no recovery if it happens)
- Systemic issue affecting 15 system contracts

### Likelihood Explanation

**Attacker Capabilities Required**:
- Compromise Parliament's default organization by gaining control of 67% of block producer keys through social engineering, key theft, or insider attacks
- OR exploit undiscovered bugs in proposal validation/execution

**Attack Complexity**: 
- Initial compromise is DIFFICULT (requires compromising majority of miners)
- Post-compromise exploitation is TRIVIAL (single function call)
- Detection: Proposal would be visible on-chain, but may execute before community response

**Feasibility Conditions**:
- Active blockchain with distributed miners (makes coordination attacks harder)
- BUT: No recovery mechanism means even a one-time successful compromise is permanent

**Probability**: LOW for initial compromise, but CRITICAL gap is lack of recovery mechanism. Best practice for high-value governance systems is defense-in-depth with emergency overrides.

### Recommendation

Add Emergency Response Organization override to `ChangeMethodFeeController`:

**Code-level Mitigation**:
```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    
    // Allow either current controller OR emergency response organization
    var isCurrentController = Context.Sender == State.MethodFeeController.Value.OwnerAddress;
    var isEmergencyOrg = Context.Sender == GetEmergencyResponseOrganizationAddress();
    
    Assert(isCurrentController || isEmergencyOrg, "Unauthorized behavior.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");

    State.MethodFeeController.Value = input;
    return new Empty();
}

private Address GetEmergencyResponseOrganizationAddress()
{
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value = Context.GetContractAddressByName(
            SmartContractConstants.ParliamentContractSystemName);
    return State.ParliamentContract.GetEmergencyResponseOrganizationAddress.Call(new Empty());
}
```

**Invariant Checks**:
- Emergency Response Organization must exist before production deployment
- Test that Emergency Response Organization can override compromised controller
- Ensure 90% approval threshold remains enforced for emergency actions

**Test Cases**:
1. Create malicious organization, use it to take over controller
2. Verify Emergency Response Organization can revert the takeover
3. Verify normal controller changes still work
4. Verify unauthorized addresses still fail authorization

Apply this fix to ALL 15 contracts implementing ChangeMethodFeeController.

### Proof of Concept

**Initial State**:
- TokenHolder contract deployed with Parliament default organization as controller
- Emergency Response Organization created
- Attacker controls malicious organization at address `AttackerOrg`

**Attack Sequence**:

1. **Attacker compromises Parliament default organization** (through social engineering/key theft)
2. **Attacker creates malicious proposal**:
   ```
   CreateProposal(
     OrganizationAddress: ParliamentDefaultOrg,
     ToAddress: TokenHolderContract,
     ContractMethodName: "ChangeMethodFeeController",
     Params: AuthorityInfo{OwnerAddress: AttackerOrg, ContractAddress: AttackerContract}
   )
   ```

3. **Attacker gets compromised miners to approve** (67% vote yes)
4. **Proposal executes**: Controller changed to AttackerOrg
5. **Result**: `State.MethodFeeController.Value.OwnerAddress == AttackerOrg`

**Expected vs Actual**:
- **Expected**: Emergency Response Organization can create proposal to revert controller back to legitimate organization
- **Actual**: Emergency Response Organization CANNOT revert because `AssertSenderAddressWith` requires sender to be AttackerOrg (the current compromised controller)

**Success Condition**: 
Legitimate governance is permanently locked out. Only AttackerOrg can now change the controller, and they have no incentive to relinquish control.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L66-68)
```csharp
    private void AssertSenderAddressWith(Address address)
    {
        Assert(Context.Sender == address, "Unauthorized behavior.");
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L314-330)
```csharp
    private void CreateEmergencyResponseOrganization()
    {
        var createOrganizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = 9000,
                MinimalVoteThreshold = 9000,
                MaximalAbstentionThreshold = 1000,
                MaximalRejectionThreshold = 1000
            },
            ProposerAuthorityRequired = false,
            ParliamentMemberProposingAllowed = true
        };

        State.EmergencyResponseOrganizationAddress.Value = CreateOrganization(createOrganizationInput);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L83-88)
```csharp
    public override Empty UpdateCandidateInformation(UpdateCandidateInformationInput input)
    {
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) ==
            Context.Sender || Context.Sender == GetEmergencyResponseOrganizationAddress(),
            "Only consensus contract can update candidate information.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-339)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-8)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
```
