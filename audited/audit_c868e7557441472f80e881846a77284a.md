### Title
Incomplete Token Distribution Due to Outdated SymbolList in TakeSnapshot Causing Permanent Reward Loss

### Summary
The `TakeSnapshot()` function in the Election contract retrieves a symbol list from the Treasury's `GetSymbolList()` and uses it to distribute profits for `SubsidyHash` and `WelfareHash` schemes. If this list is incomplete or outdated (missing newly added tokens), only tokens in the list are distributed while others remain locked. Critically, the distribution period is incremented regardless, permanently preventing redistribution of the missed tokens for that period.

### Finding Description

The vulnerability exists in the interaction between three components:

**Entry Point:** [1](#0-0) 

Here, `GetSymbolList()` is called to retrieve supported token symbols, and an `amountsMap` is constructed with all values set to 0. This map is then passed to `DistributeProfits()` for both `SubsidyHash` and `WelfareHash` schemes.

**Root Cause:** [2](#0-1) 

The `DistributeProfits()` method has conditional logic: if `AmountsMap` contains ANY entries (even if incomplete), it ONLY processes those specific symbols. The fallback to `ReceivedTokenSymbols` (which contains all tokens ever contributed to the scheme) only triggers when `AmountsMap` is completely empty. This means if the symbol list is missing some tokens, those tokens are silently skipped.

**Irreversible Period Increment:** [3](#0-2) 

After distribution (regardless of completeness), the `CurrentPeriod` is incremented.

**Period Validation Prevents Retry:** [4](#0-3) 

Any subsequent `DistributeProfits()` call must use the current period number. Once a period is processed, it cannot be retried, making the missed token distributions permanent.

**Why Protections Fail:**
- Treasury's `SymbolList` is manually configured via governance [5](#0-4) 
- There is no validation that `SymbolList` includes all tokens actually present in the profit schemes
- The contract design assumes `SymbolList` is always up-to-date, but provides no enforcement mechanism

### Impact Explanation

**Direct Harm:**
When the Treasury supports multiple tokens (e.g., ELF, USDT) that flow through to SubsidyHash and WelfareHash schemes, but `SymbolList` only contains ["ELF"], the following occurs:
1. Only ELF rewards are distributed to backup candidates and voters
2. USDT (and any other missing tokens) remain in the scheme's virtual address
3. These tokens cannot be distributed for that specific period due to period validation
4. Beneficiaries permanently lose those rewards for that term

**Affected Parties:**
- Backup node operators expecting subsidy rewards
- Token holders/voters expecting welfare dividends
- Any beneficiaries of these profit schemes

**Severity Justification:**
- **High Impact**: Permanent loss of rewards; funds become effectively locked in the contract
- **No Recovery Mechanism**: Period-based distribution model prevents retroactive fixes
- **Cumulative Effect**: Each term with incomplete symbol list causes additional loss
- **Trust Damage**: Users lose confidence in reward distribution system

### Likelihood Explanation

**Realistic Scenario:**
1. Treasury is initialized with `SymbolList` containing only native token (ELF) [6](#0-5) 
2. Governance later adds new tokens to the ecosystem (e.g., USDT for method fees)
3. These tokens start flowing through Treasury donations to SubsidyHash/WelfareHash schemes [7](#0-6) 
4. Governance fails to update `SymbolList` to include the new token (operational oversight)
5. Next `TakeSnapshot()` is automatically called by consensus contract [8](#0-7) 
6. Incomplete distribution occurs

**Feasibility:**
- **No Attacker Required**: This is an operational failure triggered by normal system operations
- **Automatic Trigger**: `TakeSnapshot()` is called automatically every term (approximately weekly)
- **No Safeguards**: Contract lacks validation to detect symbol list incompleteness
- **Governance Dependency**: Relies on perfect governance coordination between token additions and SymbolList updates

**Probability:**
Medium to High - As the ecosystem grows and new tokens are added, the coordination overhead increases. A single oversight causes immediate loss.

### Recommendation

**Immediate Fix:**
Modify `TakeSnapshot()` to pass an empty `AmountsMap` instead of constructing one from `GetSymbolList()`:

```csharp
// Remove lines 440-441, and modify the DistributeProfits calls:
State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
{
    SchemeId = State.SubsidyHash.Value,
    Period = input.TermNumber,
    AmountsMap = { } // Empty map triggers ReceivedTokenSymbols fallback
});
```

This ensures all tokens in `ReceivedTokenSymbols` are distributed automatically.

**Alternative Fix:**
In `DistributeProfits()`, add validation to ensure `AmountsMap` includes all symbols from `ReceivedTokenSymbols`, or always merge both lists:

```csharp
// After line 432, add:
if (input.AmountsMap.Any() && scheme.ReceivedTokenSymbols.Any())
{
    foreach (var symbol in scheme.ReceivedTokenSymbols)
    {
        if (!input.AmountsMap.ContainsKey(symbol))
        {
            var balance = State.TokenContract.GetBalance.Call(...).Balance;
            profitsMap.Add(symbol, balance);
        }
    }
}
```

**Invariant Check:**
Add assertion in `DistributeProfits()` to verify all tokens with non-zero balances in the scheme's virtual address are included in the distribution.

**Test Cases:**
1. Test distribution with incomplete symbol list
2. Test distribution with empty symbol list (should use ReceivedTokenSymbols)
3. Test that all tokens in scheme's virtual address are distributed
4. Test multi-token scenario with symbol list updates

### Proof of Concept

**Initial State:**
1. Treasury is initialized with SymbolList = ["ELF"]
2. SubsidyHash scheme exists with `IsReleaseAllBalanceEveryTimeByDefault = true`
3. SubsidyHash has `ReceivedTokenSymbols = ["ELF", "USDT"]` (from previous distributions)
4. SubsidyHash virtual address holds: 1000 ELF, 500 USDT
5. Current period = 10

**Transaction Sequence:**
1. Consensus contract calls `TakeSnapshot()` with `TermNumber = 10`
2. Line 440: `GetSymbolList()` returns `["ELF"]`
3. Line 441: `amountsMap` = `{"ELF": 0}`
4. Line 442-447: `DistributeProfits()` called with `AmountsMap = {"ELF": 0}`
5. In `DistributeProfits()`:
   - Line 433: `input.AmountsMap.Any()` is true
   - Lines 435-445: Only processes "ELF", queries balance (1000), adds to profitsMap
   - Lines 447-460: ReceivedTokenSymbols fallback NOT triggered
   - Line 494: CurrentPeriod incremented to 11
   - Distribution completes with profitsMap = {"ELF": 1000}

**Actual Result:**
- 1000 ELF distributed to beneficiaries ✓
- 500 USDT remains in SubsidyHash virtual address ✗
- CurrentPeriod = 11
- Future `DistributeProfits(Period=10)` calls will fail with "Invalid period"

**Expected Result:**
- Both 1000 ELF and 500 USDT should be distributed
- All beneficiaries receive their full rewards for period 10

**Success Condition:**
The 500 USDT for period 10 is permanently lost to beneficiaries, confirming the vulnerability.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L408-408)
```csharp
        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L440-447)
```csharp
        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-460)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-644)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L72-75)
```csharp
        State.SymbolList.Value = new SymbolList
        {
            Value = { Context.Variables.NativeSymbol }
        };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-309)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
```
