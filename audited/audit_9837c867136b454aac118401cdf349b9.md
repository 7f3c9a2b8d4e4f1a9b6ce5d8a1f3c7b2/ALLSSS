### Title
Off-By-One Error in MinersCountOfConsent Enables Term Change Denial-of-Service When Miner Count is Divisible by Three

### Summary
The `MinersCountOfConsent` formula uses `(Count * 2) / 3 + 1` which requires one additional vote beyond the standard 2/3 majority when the total miner count is divisible by 3. This allows an attacker controlling exactly 1/3 of miners to block term changes by refusing to produce blocks, preventing new elected miners from joining and delaying treasury reward distributions.

### Finding Description

The vulnerability exists in the calculation of the consensus threshold for term changes. [1](#0-0) 

The formula `RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1)` computes as `(Count * 2) / 3 + 1` using integer division. [2](#0-1) 

When `Count` is divisible by 3 (e.g., 3, 6, 9 miners), the formula produces:
- Count=3: requires 3 votes (100%) instead of standard 2/3 = 2 votes (66.7%)
- Count=6: requires 5 votes (83.3%) instead of standard 2/3 = 4 votes (66.7%)
- Count=9: requires 7 votes (77.8%) instead of standard 2/3 = 6 votes (66.7%)

The `NeedToChangeTerm` function filters only miners who have produced blocks and compares against this inflated threshold: [3](#0-2) 

The comment explicitly states "two thirds of miners" should meet the threshold, indicating the intended behavior is a standard 2/3 majority (≥66.7%), not the higher threshold implemented. [4](#0-3) 

**Exploitation Path:**
1. Network operates with 6 miners (or any multiple of 3)
2. Attacker controls 2 miners (exactly 1/3)
3. When term period expires, honest miners' blocks signal term change via `IsTimeToChangeTerm` [5](#0-4) 
4. Attacker's 2 miners cease block production entirely
5. Only 4 honest miners have `ActualMiningTimes.Any()` evaluating to true
6. Count of 4 < `MinersCountOfConsent` of 5, so term change is blocked
7. The consensus behavior provider continues returning `NextRound` instead of `NextTerm` [6](#0-5) 

### Impact Explanation

**Governance Disruption:**
- New miners elected through the election contract cannot join the active miner set because term transitions are blocked [7](#0-6) 
- The old miner set (including attackers) remains in power indefinitely
- Election snapshots are not taken, breaking the election cycle [8](#0-7) 

**Economic Impact:**
- Treasury profit releases for the completed term are delayed [9](#0-8) 
- Current miners continue earning block rewards that should go to newly elected miners
- Attackers who lost the election extend their tenure and reward earnings

**Severity Justification:**
Medium severity - while this does not enable direct fund theft, it constitutes a denial-of-service attack on the governance layer, disrupts democratic miner rotation, and delays economic distributions. Block production continues normally, preventing complete chain halt.

### Likelihood Explanation

**Attacker Capabilities:**
- Must control exactly `Count/3` miners when `Count` is divisible by 3
- Attack execution is trivial: simply stop mining blocks

**Feasibility Conditions:**
- Network must have 3, 6, 9, 12, 15, 18, or 21 miners (multiples of 3)
- While default constants show 17 miners, the system is configurable [10](#0-9) 
- Test configurations use 5 miners, but production networks may choose values like 6, 9, or 12 for operational reasons

**Economic Rationality:**
- Attackers who are current miners and lost the recent election can delay replacement for days
- They continue earning block rewards (12,500,000 tokens per block initially) [11](#0-10) 
- Evil miner detection only triggers after 4,320 missed time slots (~3 days) [12](#0-11) 
- This provides several days of illicit rewards before penalties apply

**Detection:**
- Attack is observable through missed block production
- Eventually detected as evil miners, but after significant delay [13](#0-12) 

### Recommendation

**Code-Level Fix:**
Replace the threshold formula in `Round_ImpliedIrreversibleBlockHeight.cs` to use proper ceiling division for 2/3 majority:

```csharp
// Change from:
public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);

// To:
public int MinersCountOfConsent => (RealTimeMinersInformation.Count.Mul(2).Add(2)).Div(3);
// This implements ceil(Count * 2 / 3) = (Count * 2 + 2) / 3
```

**Verification:**
- Count=3: (6+2)/3 = 2 (66.7% - correct)
- Count=4: (8+2)/3 = 3 (75% - correct)  
- Count=6: (12+2)/3 = 4 (66.7% - correct)
- Count=9: (18+2)/3 = 6 (66.7% - correct)

**Test Cases:**
Add regression tests verifying term changes succeed with exactly 2/3 support when miner counts are 3, 6, 9, and other multiples of 3.

### Proof of Concept

**Initial State:**
- Network configured with 6 miners (M1, M2, M3, M4, M5, M6)
- Attacker controls M5 and M6
- Term period = 7 days
- Current term = 1, blockchain age exceeds term period

**Attack Sequence:**
1. Honest miners M1-M4 produce blocks at timestamps beyond the term period
2. Each block has `(blockTimestamp - blockchainStart) / periodSeconds != 0`, signaling term change needed
3. M5 and M6 (attacker controlled) stop producing blocks entirely
4. `NeedToChangeTerm()` evaluates:
   - Filters to miners with `ActualMiningTimes.Any()` → only M1-M4 (count = 4)
   - All 4 have timestamps meeting `IsTimeToChangeTerm` criteria
   - Compares: 4 >= `MinersCountOfConsent` (which equals 5)
   - Returns `false` (4 < 5)
5. `MainChainConsensusBehaviourProvider` returns `NextRound` instead of `NextTerm`
6. Term number remains 1, new elected miners cannot join
7. M5 and M6 accumulate missed slots but remain in miner set
8. Attack continues for days until 4,320 missed slots trigger evil miner detection

**Expected Result:** Term should change when 4 out of 6 miners (66.7%) signal readiness

**Actual Result:** Term change blocked because threshold incorrectly requires 5 out of 6 miners (83.3%)

**Success Condition:** New term not initiated despite majority consensus, allowing attackers to extend their tenure and block governance transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L21-24)
```csharp
    public static int Div(this int a, int b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L209-211)
```csharp
    /// <summary>
    ///     Change term if two thirds of miners latest ActualMiningTime meets threshold of changing term.
    /// </summary>
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L239-243)
```csharp
    private static bool IsTimeToChangeTerm(Timestamp blockchainStartTimestamp, Timestamp blockProducedTimestamp,
        long termNumber, long periodSeconds)
    {
        return (blockProducedTimestamp - blockchainStartTimestamp).Seconds.Div(periodSeconds) != termNumber - 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L7-7)
```csharp
    public const long InitialMiningRewardPerBlock = 12500000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```
