### Title
Round 1 Special Handling Causes Incorrect Penalty for All Miners When First Miner Misses Time Slot

### Summary
When Round 1's first miner misses their time slot, the protocol's special handling instructs other miners to produce `NextRound` blocks instead of `UpdateValue` blocks. However, `NextRound` blocks do not set `SupposedOrderOfNextRound`, causing `GenerateNextRoundInformation` to treat all miners (including actively mining ones) as non-mining, incorrectly incrementing their `MissedTimeSlots` counter.

### Finding Description

The vulnerability exists in the interaction between consensus behavior determination and round generation logic: [1](#0-0) 

In Round 1, when the first miner (Order 1) has not yet produced a block (`FirstMiner().OutValue == null`), all other miners are instructed to produce `NextRound` behavior instead of `UpdateValue` to prevent fork blocks due to incorrect expected mining times.

However, `SupposedOrderOfNextRound` is only set during `UpdateValue` block production: [2](#0-1) 

`NextRound` blocks skip `ApplyNormalConsensusData` entirely: [3](#0-2) 

When `GenerateNextRoundInformation` is called, it uses `SupposedOrderOfNextRound` to distinguish miners who mined from those who didn't: [4](#0-3) 

Since Round 1 is initialized with all miners having `SupposedOrderOfNextRound = 0` (default value): [5](#0-4) 

The result is that `GetMinedMiners()` returns an empty list, and all miners are treated as non-mining: [6](#0-5) 

### Impact Explanation

**Concrete Harm:**
- All miners in the network receive an incorrect `MissedTimeSlots` increment of 1, including the miner actively producing the `NextRound` block
- This corrupts the miner statistics used for consensus monitoring and reputation
- While the immediate penalty (1 missed slot) is small compared to the evil miner threshold of 4320, it represents incorrect data in the consensus state
- The `MissedTimeSlots` counter persists across rounds and could accumulate if similar scenarios occur in future term starts

**Who is Affected:**
- All miners in the network during the Round 1 to Round 2 transition when the first miner misses their slot
- Particularly unfair to the miner who is following protocol instructions to produce the `NextRound` block

**Severity Justification (Medium):**
- Does not cause immediate fund loss or system halt
- Creates incorrect consensus state and miner penalties
- Affects consensus integrity and fairness
- Limited to specific scenario but guaranteed to occur when first miner is delayed in Round 1

### Likelihood Explanation

**Attack Complexity:** None required - this is a protocol design flaw, not an exploitable attack

**Feasibility Conditions:**
- Occurs naturally in Round 1 when the first miner (Order 1) misses their time slot due to:
  - Network delays
  - Node temporarily offline
  - Slow block propagation
  - Any other reason for delayed mining

**Probability:**
- High probability of occurrence during blockchain initialization or new term starts
- Round 1 timing is noted in code comments as unreliable, making first miner delays realistic
- No attacker capabilities needed - this happens through normal protocol operation

**Detection:**
- The issue is deterministic and will happen every time the preconditions are met
- Can be verified by examining Round 2 miner statistics after a Round 1 where first miner was delayed

### Recommendation

**Fix 1: Track NextRound Producer Activity**
Modify `GenerateNextRoundInformation` to account for the miner producing the `NextRound` transition block:

```csharp
public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, 
    Timestamp blockchainStartTimestamp, out Round nextRound, 
    bool isMinerListChanged = false, string nextRoundProducerPubkey = null)
{
    var minersMinedCurrentRound = GetMinedMiners();
    var minersNotMinedCurrentRound = GetNotMinedMiners();
    
    // If we have a NextRound producer, treat them as having mined
    if (!string.IsNullOrEmpty(nextRoundProducerPubkey) && 
        RealTimeMinersInformation.ContainsKey(nextRoundProducerPubkey) &&
        !minersMinedCurrentRound.Any(m => m.Pubkey == nextRoundProducerPubkey))
    {
        // Treat NextRound producer as a miner who mined
        minersMinedCurrentRound.Add(RealTimeMinersInformation[nextRoundProducerPubkey]);
        minersNotMinedCurrentRound.RemoveAll(m => m.Pubkey == nextRoundProducerPubkey);
    }
    // ... rest of the method
}
```

**Fix 2: Set SupposedOrderOfNextRound for NextRound Blocks**
Alternatively, ensure `NextRound` blocks also call `ApplyNormalConsensusData` or set `SupposedOrderOfNextRound` through a different mechanism.

**Test Cases:**
1. Test Round 1 transition when first miner misses time slot and second miner produces `NextRound`
2. Verify the `NextRound` producer does not get incorrectly penalized
3. Verify other miners who genuinely missed also get correctly penalized
4. Test that this does not affect normal Round 1 transitions where first miner produces successfully

### Proof of Concept

**Initial State:**
- Blockchain just initialized with Round 1
- 5 miners with Orders 1-5
- All miners have `SupposedOrderOfNextRound = 0` (default from `GenerateFirstRoundOfNewTerm`)

**Step 1:** First miner (Order 1) misses time slot
- Miner 1 is offline or delayed
- `RealTimeMinersInformation[miner1].OutValue == null` remains true

**Step 2:** Second miner (Order 2) queries consensus behavior
- Calls `GetConsensusBehaviour()`
- Enters `HandleMinerInNewRound()` because `OutValue == null`
- Conditions match: `RoundNumber == 1 && Order != 1 && FirstMiner().OutValue == null`
- Returns `AElfConsensusBehaviour.NextRound` (not `UpdateValue`)

**Step 3:** Miner 2 produces NextRound block
- Calls `GetConsensusExtraDataForNextRound`
- Invokes `GenerateNextRoundInformation(currentRound, ...)` where currentRound is Round 1
- `GetMinedMiners()` checks `SupposedOrderOfNextRound != 0` for all miners
- All miners have `SupposedOrderOfNextRound == 0`, returns empty list
- `GetNotMinedMiners()` returns all 5 miners
- All 5 miners processed in lines 42-56 with `MissedTimeSlots.Add(1)`

**Expected Result:** Miner 2 should NOT be penalized as they are actively mining
**Actual Result:** All miners including Miner 2 have `MissedTimeSlots` incorrectly incremented to 1

**Success Condition:** Check Round 2 miner data - all miners show `MissedTimeSlots = 1` even though Miner 2 produced a block

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L92-102)
```csharp
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L42-56)
```csharp
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```
