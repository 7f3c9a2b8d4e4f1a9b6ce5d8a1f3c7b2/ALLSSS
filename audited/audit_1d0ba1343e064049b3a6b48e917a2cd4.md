# Audit Report

## Title
Non-Retroactive Vote Weight Updates Allow Early Voters to Maintain Permanently Inflated Profit Shares After Interest Rate Decreases

## Summary
The `SetVoteWeightInterest()` function in the Election contract updates global interest rate parameters but does not retroactively recalculate existing vote weights. When governance decreases interest rates, voters who locked tokens under higher rates permanently maintain inflated profit shares compared to new voters with identical stakes and lock periods, creating systemic unfairness in welfare profit distribution.

## Finding Description

The vulnerability exists at the intersection of three contract mechanisms:

**1. Non-Retroactive Interest Rate Updates**

The `SetVoteWeightInterest()` function updates the global interest configuration but contains no logic to recalculate existing vote weights. [1](#0-0) 

**2. One-Time Weight Calculation**

When users call `Vote()`, the weight is calculated once using current interest rates via `GetVotesWeight()` and stored as immutable "shares" in the profit scheme. [2](#0-1) 

The `GetVotesWeight()` function applies a compound interest formula that exponentially increases weight based on lock duration. [3](#0-2) 

These calculated weights become profit shares via `AddBeneficiaryToVoter()`. [4](#0-3) 

**3. Shares Preservation in Profit Details**

Vote weights stored as profit shares persist unchanged throughout the vote's lifetime. Even when `ExtendVoterWelfareProfits()` is called during vote target changes, the underlying shares are preserved. [5](#0-4) 

The `FixProfitDetail()` method in the Profit contract clones existing details and only updates period boundaries - it explicitly preserves the original shares value. [6](#0-5) 

**Evidence of Abandoned Implementation**

A `FixTotalWeightsInput` message is defined in the protocol but has no corresponding implementation. [7](#0-6) 

The `WeightsAlreadyFixedMap` state variable exists but is never set to `true` anywhere in the codebase - it's only checked and removed in withdrawal logic. [8](#0-7) 

## Impact Explanation

**Severity: High**

This creates measurable unfair profit distribution:

**Concrete Example:**
- Governance decreases 365-day interest from `Interest=1, Capital=1000` to `Interest=1, Capital=10000`
- Early voter: Locked 1M tokens for 365 days under old rates → Weight ≈ 1,440,000 shares
- New voter: Locks identical 1M tokens for 365 days under new rates → Weight ≈ 1,037,000 shares
- **Result**: Early voter receives ~39% more welfare profits for identical economic commitment

**Protocol Impact:**
- Violates economic fairness invariant: identical stakes should receive identical rewards
- Creates permanent two-tier voter system until old votes naturally expire
- Undermines governance authority - interest rate policy changes fail to apply uniformly
- Enables rational actors to front-run governance proposals for permanent advantage

**Who Is Affected:**
- All new voters receive proportionally less profit than legacy voters
- Welfare profit scheme becomes systematically inequitable
- Multiple voters across any rate change are naturally affected

## Likelihood Explanation

**Likelihood: High**

**Preconditions:**
- Governance decides to decrease interest rates (realistic economic policy adjustment)
- Voters have active votes under old rates

**Attack Complexity: Low**
1. Monitor public governance proposals for interest rate decreases
2. Call `Vote()` with maximum amount and longest lock before execution
3. Maintain inflated weight throughout lock period with no further action

**Economic Rationality: High**
- Clear financial incentive with quantifiable advantage
- No risk beyond opportunity cost of locked capital (returned after lock period)
- Rational economic actors will maximize returns under available rules

**Feasibility:**
- Public `Vote()` function is unrestricted [9](#0-8) 
- Front-running governance execution is trivial on public blockchain
- Single transaction execution
- Issue persists across all future rate decreases until fixed

## Recommendation

Implement retroactive weight recalculation when interest rates change:

1. **Complete the abandoned `FixTotalWeights()` implementation** to iterate through active votes and recalculate weights based on new interest rates

2. **Add recalculation logic to `SetVoteWeightInterest()`**:
   - Enumerate all active votes via `ElectorVotes` state
   - For each active vote, recalculate weight using new rates
   - Call `FixProfitDetail()` with updated shares to reflect new weights
   - Set `WeightsAlreadyFixedMap[voteId] = true` to track updated votes

3. **Alternative: Implement gradual transition mechanism** where new rates apply only to new votes while old votes maintain original rates until expiry (document as intended behavior)

## Proof of Concept

```csharp
// Test demonstrating the vulnerability
[Fact]
public async Task Test_NonRetroactiveVoteWeights()
{
    // Setup: Initial vote under high interest rates
    var voter1Amount = 1_000_000_00000000;
    var lockDays = 365;
    
    // Vote 1 under default rates (Interest=1, Capital=1000)
    var vote1Id = await VoteForCandidate(voter1Amount, lockDays);
    var vote1Weight = await GetVoteWeight(vote1Id); // ≈ 1,440,000 shares
    
    // Governance decreases interest rates
    await SetVoteWeightInterest(new VoteWeightInterestList {
        VoteWeightInterestInfos = {
            new VoteWeightInterest { Day = 365, Interest = 1, Capital = 10000 }
        }
    });
    
    // Vote 2 under new rates with identical parameters
    var vote2Id = await VoteForCandidate(voter1Amount, lockDays);
    var vote2Weight = await GetVoteWeight(vote2Id); // ≈ 1,037,000 shares
    
    // Assert: Vote1 maintains higher weight despite rate change
    Assert.True(vote1Weight > vote2Weight * 1.3); // ~39% advantage
    
    // Distribute profits and verify unfair distribution
    await DistributeWelfareProfits(1_000_000_00000000);
    var profit1 = await GetVoterProfit(vote1Id);
    var profit2 = await GetVoterProfit(vote2Id);
    
    // Vote1 receives disproportionately more profit for same commitment
    Assert.True(profit1 > profit2 * 1.3);
}
```

## Notes

This vulnerability represents a design flaw where governance parameter changes don't apply retroactively to existing commitments. The abandoned `FixTotalWeightsInput` and unused `WeightsAlreadyFixedMap` suggest this issue was recognized but never fully addressed. The impact is particularly severe because it creates permanent economic unfairness that undermines the integrity of the welfare profit distribution system and governance authority over economic parameters.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L126-160)
```csharp
    private void ExtendVoterWelfareProfits(Hash voteId)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);

        // Extend endPeriod from now no, so the lockTime will *NOT* be changed.
        var lockTime = State.LockTimeMap[voteId];
        var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
        if (lockPeriod == 0)
        {
            return;
        }

        var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L665-669)
```csharp
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** protobuf/election_contract.proto (L530-533)
```text
message FixTotalWeightsInput {
    repeated aelf.Hash vote_ids = 1;
    
}
```
