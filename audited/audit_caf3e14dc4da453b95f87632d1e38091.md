### Title
Voluntary Key Rotation Bypasses Performance Penalties in Miner Reward Distribution

### Summary
The `UpdateBasicMinerRewardWeights` function gives miners with the `IsReplacedEvilMiner` flag their `ProducedBlocks` count directly as shares, bypassing the penalty calculation in `CalculateShares`. This flag is set for voluntary key rotations (not evil miner replacements), allowing underperforming miners to avoid quadratic performance penalties by rotating their key before term end, potentially doubling their undeserved rewards.

### Finding Description

The audit question incorrectly assumes the code at lines 802-808 affects evil miner replacements, but investigation reveals it only affects **voluntary** key rotations: [1](#0-0) 

The `IsReplacedEvilMiner` flag is only set when `RecordMinerReplacement` is called: [2](#0-1) 

However, `RecordMinerReplacement` is **only** called during voluntary key rotations via the AEDPoS contract's `RecordCandidateReplacement`: [3](#0-2) 

For voluntary replacements, the entire `MinerInRound` information (including `ProducedBlocks`) is transferred to the new pubkey: [4](#0-3) 

In contrast, automatic evil miner replacements (detected via `TryToDetectEvilMiners`) create a fresh `MinerInRound` with default values and **never call** `RecordMinerReplacement`: [5](#0-4) 

The vulnerability arises because the normal reward calculation penalizes poor performance through `CalculateShares`: [6](#0-5) 

Miners producing between 50%-80% of average blocks receive quadratic penalties (blocks² / average). By rotating their key, they bypass this penalty entirely.

### Impact Explanation

**Direct Fund Impact - Reward Misallocation:**

A miner producing 200 blocks when the average is 400 blocks should receive:
- Normal: `CalculateShares(200, 400) = 200 * 200 / 400 = 100` shares
- After key rotation: `200` shares directly
- **Excess reward: 100% (doubling their undeserved compensation)**

For miners at the threshold (producing exactly 160 blocks with average 400):
- Normal: `160 * 160 / 400 = 64` shares  
- After rotation: `160` shares
- **Excess reward: 150%**

This undermines the core economic invariant that miners must maintain reliable block production to receive proportional rewards. Over multiple terms with strategic rotations, consistently underperforming miners can maintain reward levels intended only for reliable miners, diluting rewards for honest participants and weakening consensus incentives.

### Likelihood Explanation

**Attacker Capabilities:** Any miner/candidate with admin access to their candidate account can call `ReplaceCandidatePubkey` with no restrictions: [7](#0-6) 

**Attack Complexity:** Low - single transaction during any point in the term. No timing restrictions exist; the replacement can occur at any moment before term end.

**Feasibility Conditions:**
- Miner anticipates poor performance (e.g., connectivity issues, hardware problems)
- Executes key rotation before term ends
- At term end, `Release` is called, triggering reward distribution
- The new pubkey still has `IsReplacedEvilMiner` flag set, bypassing penalties
- Flag is cleared after one use, ready for next exploitation

**Detection Constraints:** The key rotation appears legitimate (intended for security/key management), making malicious intent difficult to distinguish from genuine operational needs.

**Economic Rationality:** Zero cost (just gas fees) with immediate benefit in current term's reward distribution. Risk-free exploitation with guaranteed profit for underperforming miners.

### Recommendation

**Code-Level Mitigation:**

Modify `UpdateBasicMinerRewardWeights` to remove the special handling for replaced miners, ensuring all miners undergo the same performance-based calculation:

```csharp
// Remove lines 802-808, replace with:
shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
```

If preserving continuity for legitimate key rotations is desired, apply the penalty reduction proportionally based on when the rotation occurred:

```csharp
if (State.IsReplacedEvilMiner[i.Pubkey])
{
    // Still apply penalty calculation, no special treatment
    shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
    State.IsReplacedEvilMiner.Remove(i.Pubkey);
}
```

**Invariant Check:** Ensure that performance penalties apply uniformly regardless of key rotation status.

**Test Cases:**
1. Miner with poor performance (< 80% average) rotates key → verify penalty still applies
2. Miner with good performance (≥ 80% average) rotates key → verify no change in reward
3. Multiple key rotations within single term → verify penalties compound appropriately

### Proof of Concept

**Initial State:**
- Term N in progress, 17 miners active
- Target average: 400 blocks per miner
- Attacker miner uses pubkey A, has produced 200 blocks mid-term (poor performance)

**Exploit Steps:**

1. **Before term end**, attacker calls `ReplaceCandidatePubkey`:
   ```
   Input: { OldPubkey: A, NewPubkey: B }
   ```

2. AEDPoS `RecordCandidateReplacement` executes, transferring `ProducedBlocks=200` to pubkey B

3. Treasury `RecordMinerReplacement` executes, setting `IsReplacedEvilMiner[B] = true`

4. Term N continues, pubkey B may produce additional blocks (doesn't affect exploit)

5. **Term N ends**, AEDPoS calls Treasury `Release`

6. `UpdateBasicMinerRewardWeights` processes rewards:
   - Average calculated: 400 blocks
   - Pubkey B has `IsReplacedEvilMiner[B] = true`
   - **Lines 802-808 execute**: `shares = 200` (direct assignment)
   - Flag cleared: `IsReplacedEvilMiner.Remove(B)`

**Expected Result:** Pubkey B should receive `100` shares (with penalty: `200*200/400`)

**Actual Result:** Pubkey B receives `200` shares (bypassing penalty)

**Success Condition:** Attacker receives double the rewards they deserve, verified by comparing actual profit distribution to expected penalized distribution for the same block production.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L596-596)
```csharp
        State.IsReplacedEvilMiner[input.NewPubkey] = true;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L802-808)
```csharp
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L149-154)
```csharp
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L328-338)
```csharp
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```
