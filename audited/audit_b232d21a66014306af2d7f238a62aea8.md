### Title
LockTimeMap Entries Not Removed on Vote Withdrawal Leading to Storage Bloat and Vote ID Reuse Prevention

### Summary
The Election contract's `LockTimeMap` state stores vote ID to lock time mappings but never removes entries when votes are withdrawn. This causes unbounded storage growth as stale entries accumulate, and prevents users from reusing vote IDs (especially custom tokens), creating operational limitations and potential DoS conditions over time.

### Finding Description

The vulnerability exists in the vote withdrawal flow where `LockTimeMap` entries persist indefinitely after use.

**Vote Creation:** When a user votes, the contract generates a vote ID and stores the lock time in `LockTimeMap`: [1](#0-0) 

The assertion at line 433 prevents vote ID reuse by checking if `LockTimeMap[voteId] == 0`, treating any non-zero value as an existing vote.

**Vote Withdrawal:** When votes are withdrawn, the contract validates the lock time has expired and updates vote records: [2](#0-1) 

However, the `LockTimeMap` entry is **never removed**. The method reads from it (line 634) for validation but contains no cleanup logic such as `State.LockTimeMap.Remove(input)` or setting the value to 0.

**Vote ID Generation:** Vote IDs can be created using custom tokens provided by users or auto-generated: [3](#0-2) 

When users provide custom tokens (line 404-405), the same token will always generate the same vote ID. Since `LockTimeMap` entries are never cleaned up, once a custom token is used and withdrawn, it can never be used again—the assertion at line 433 will fail with "Vote already exists."

**Root Cause:** The contract lacks cleanup logic in the withdrawal path. The `LockTimeMap` was designed as a check mechanism for vote existence and lock time validation, but failed to account for entry removal after votes are withdrawn and no longer active.

### Impact Explanation

**1. Unbounded Storage Bloat:**
Every vote creates a permanent `LockTimeMap` entry consuming contract storage. With thousands of votes over the contract's lifetime, this leads to significant storage growth. In AElf's state model, larger state sizes increase query costs and contract execution overhead.

**2. Vote ID Reuse Prevention:**
Users who provide custom tokens (as demonstrated in test code at line 2048) cannot reuse those tokens after withdrawal. This is a functional limitation that may affect:
- Users who want consistent vote IDs across multiple voting periods
- Applications that rely on deterministic vote ID generation
- Integration patterns that use specific token values

**3. Display Inconsistency:**
The `TransferVotingRecordToElectionVotingRecord` view method continues reading from `LockTimeMap` for withdrawn votes: [4](#0-3) 

This displays stale lock time data for withdrawn votes, potentially confusing users or applications querying historical voting records.

**Affected Parties:** All election participants who vote and later withdraw, with cumulative impact on the entire Election contract's state storage.

### Likelihood Explanation

**Likelihood: High**

This issue occurs through normal contract usage without requiring any special attack:

**Attack Complexity:** None - this is a design flaw triggered by legitimate operations:
1. User calls public `Vote` method with custom token or standard parameters
2. User later calls public `Withdraw` method after lock period
3. `LockTimeMap` entry remains permanently

**Attacker Capabilities:** Any user can trigger this—it requires no special permissions, only:
- Sufficient tokens to vote (varying amounts)
- Patience to wait for the lock period
- Standard transaction fees

**Economic Rationality:** While an attacker could intentionally create many votes with different tokens to amplify storage bloat, the issue occurs naturally through normal usage. Each user withdrawal contributes to the accumulation.

**Probability:** 100% occurrence rate on every withdrawal. The codebase search confirms no removal logic exists:
- No `LockTimeMap.Remove()` calls found in the codebase
- No pattern of setting entries to 0
- Withdrawal tests demonstrate the behavior but don't verify cleanup

**Detection Constraints:** This is not easily detectable without monitoring contract state growth over time, making it a persistent operational issue.

### Recommendation

**1. Add LockTimeMap Cleanup in Withdraw Method:**

Add entry removal after validating the lock time in the `Withdraw` method at line 636:

```csharp
Assert(actualLockedTime >= claimedLockDays,
    $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

// Clean up LockTimeMap entry after successful validation
State.LockTimeMap.Remove(input);
```

**2. Add Cleanup in ChangeVotingOption Method:**

When votes are changed without resetting time (non-reuse of vote ID), the old lock time entry should be removed if the vote target changes: [5](#0-4) 

However, since `ChangeVotingOption` reuses the same vote ID, the entry should be updated (as it currently is at line 42) rather than removed. This is correct behavior.

**3. Invariant to Add:**

Add a post-condition check in tests: after withdrawal, verify `State.LockTimeMap[voteId] == 0` or the entry doesn't exist.

**4. Migration Consideration:**

For existing deployed contracts, consider adding a cleanup method (governance-controlled) to batch-remove stale entries for withdrawn votes, querying withdrawn vote IDs and clearing their `LockTimeMap` entries.

### Proof of Concept

**Initial State:**
- User has sufficient ELF tokens to vote (e.g., 1000 ELF)
- A valid candidate exists
- Current block time is T

**Exploit Steps:**

1. **First Vote with Custom Token:**
```csharp
var token = HashHelper.ComputeFrom("my_custom_token");
var voteId = await ElectionContract.Vote(new VoteMinerInput {
    CandidatePubkey = candidatePubkey,
    Amount = 1000,
    EndTimestamp = CurrentTime.AddDays(100),
    Token = token
});
// State.LockTimeMap[voteId] = 8640000 (100 days in seconds)
```

2. **Wait for Lock Period and Withdraw:**
```csharp
BlockTimeProvider.SetBlockTime(CurrentTime.AddDays(101));
await ElectionContract.Withdraw(voteId);
// Vote records updated, tokens unlocked
// BUT: State.LockTimeMap[voteId] STILL = 8640000 (NOT REMOVED)
```

3. **Attempt to Vote Again with Same Token:**
```csharp
var voteId2 = await ElectionContract.Vote(new VoteMinerInput {
    CandidatePubkey = candidatePubkey,
    Amount = 1000,
    EndTimestamp = CurrentTime.AddDays(200),
    Token = token  // Same token as before
});
// FAILS with: "Vote already exists."
// Because State.LockTimeMap[voteId] != 0
```

**Expected Result:** Second vote should succeed since the first vote was fully withdrawn.

**Actual Result:** Second vote fails because `LockTimeMap` entry was never cleaned up, permanently blocking reuse of the custom token.

**Success Condition:** The assertion `Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.")` fails on the second vote attempt, proving the stale entry blocks legitimate reuse.

**Storage Bloat Verification:** Query contract state size before and after multiple vote/withdraw cycles - `LockTimeMap` size grows by one entry per vote and never decreases.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L23-50)
```csharp
    public override Empty ChangeVotingOption(ChangeVotingOptionInput input)
    {
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input.VoteId);
        Assert(Context.Sender == votingRecord.Voter, "No permission to change current vote's option.");
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");

        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }

        // Withdraw old votes
        State.VoteContract.Withdraw.Send(new WithdrawInput
        {
            VoteId = input.VoteId
        });

```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L402-412)
```csharp
    private Hash GenerateVoteId(VoteMinerInput voteMinerInput)
    {
        if (voteMinerInput.Token != null)
            return Context.GenerateId(Context.Self, voteMinerInput.Token);

        var candidateVotesCount =
            State.CandidateVotes[voteMinerInput.CandidatePubkey]?.ObtainedActiveVotedVotesAmount ?? 0;
        return Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(voteMinerInput.CandidatePubkey.GetBytes(),
                candidateVotesCount.ToBytes(false)));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-434)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L629-679)
```csharp
    public override Empty Withdraw(Hash input)
    {
        var votingRecord = State.VoteContract.GetVotingRecord.Call(input);

        var actualLockedTime = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockDays = State.LockTimeMap[input];
        Assert(actualLockedTime >= claimedLockDays,
            $"Still need {claimedLockDays.Sub(actualLockedTime).Div(86400)} days to unlock your token.");

        var voterPublicKey = Context.RecoverPublicKey();

        var voterVotes = GetElectorVote(voterPublicKey);

        Assert(voterVotes != null, $"Voter {Context.Sender.ToBase58()} never votes before");

        voterVotes.ActiveVotingRecordIds.Remove(input);
        voterVotes.WithdrawnVotingRecordIds.Add(input);
        voterVotes.ActiveVotedVotesAmount = voterVotes.ActiveVotedVotesAmount.Sub(votingRecord.Amount);

        State.ElectorVotes[Context.Sender.ToBase58()] = voterVotes;

        // Update Candidate's Votes information.
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;

        UnlockTokensOfVoter(input, votingRecord.Amount);
        RetrieveTokensFromVoter(votingRecord.Amount);
        WithdrawTokensOfVoter(input);
        if (!State.WeightsAlreadyFixedMap[input])
        {
            RemoveBeneficiaryOfVoter();
            State.WeightsAlreadyFixedMap.Remove(input);
        }

        var rankingList = State.DataCentersRankingList.Value;
        if (!rankingList.DataCenters.ContainsKey(newestPubkey)) return new Empty();
        rankingList.DataCenters[newestPubkey] =
            rankingList.DataCenters[newestPubkey].Sub(votingRecord.Amount);
        UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, newestPubkey);
        State.DataCentersRankingList.Value = rankingList;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L337-355)
```csharp
    private ElectionVotingRecord TransferVotingRecordToElectionVotingRecord(VotingRecord votingRecord, Hash voteId)
    {
        var lockSeconds = State.LockTimeMap[voteId];
        return new ElectionVotingRecord
        {
            Voter = votingRecord.Voter,
            Candidate = GetNewestPubkey(votingRecord.Option),
            Amount = votingRecord.Amount,
            TermNumber = votingRecord.SnapshotNumber,
            VoteId = voteId,
            LockTime = lockSeconds,
            VoteTimestamp = votingRecord.VoteTimestamp,
            WithdrawTimestamp = votingRecord.WithdrawTimestamp,
            UnlockTimestamp = votingRecord.VoteTimestamp.AddSeconds(lockSeconds),
            IsWithdrawn = votingRecord.IsWithdrawn,
            Weight = GetVotesWeight(votingRecord.Amount, lockSeconds),
            IsChangeTarget = votingRecord.IsChangeTarget
        };
    }
```
