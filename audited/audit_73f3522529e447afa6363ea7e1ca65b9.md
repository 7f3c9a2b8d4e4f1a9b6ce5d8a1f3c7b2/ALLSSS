### Title
Association Contract Vote Threshold Counts Non-Member Votes Leading to Governance Bypass

### Summary
The `CheckEnoughVoteAndApprovals()` function in the Association contract counts all votes toward `MinimalVoteThreshold` without filtering by current organization membership, unlike the approval/rejection/abstention counts which are correctly filtered. This allows proposals to pass with votes from removed members, bypassing the intended participation requirements and creating an inconsistency with the Parliament contract's correct implementation.

### Finding Description

The vulnerability exists in the `CheckEnoughVoteAndApprovals()` function where vote threshold validation is inconsistent with other threshold checks. [1](#0-0) 

This code counts ALL votes (approvals, rejections, abstentions) without filtering by `organization.OrganizationMemberList.Contains`, unlike the approval count on the same function: [2](#0-1) 

This inconsistency is also present in the rejection and abstention counting functions: [3](#0-2) [4](#0-3) 

The root cause is that while only current members can vote (verified by authorization checks in Approve/Reject/Abstain methods): [5](#0-4) 

Members can be removed after voting through the `RemoveMember` function: [6](#0-5) 

When members are removed, their addresses remain in the proposal's vote lists, but they are no longer in `OrganizationMemberList`. The unfiltered total vote count continues to include these removed members, while the filtered approval/rejection/abstention counts correctly exclude them.

This creates a critical inconsistency with the Parliament contract, which correctly filters ALL vote counts by current membership: [7](#0-6) 

### Impact Explanation

This vulnerability allows governance bypass through the following mechanism:

1. **Participation Requirement Bypass**: The `MinimalVoteThreshold` is designed to ensure minimum participation relative to current organization size. The validation enforces this relationship: [8](#0-7) 

However, by counting removed members' votes, the actual current member participation can be significantly lower than intended.

2. **Concrete Attack Scenario**:
   - Organization with 10 members, `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=5`, `MaximalRejectionThreshold=2`
   - Proposal created, 7 members vote: 5 approve, 2 reject
   - Organization passes another proposal to remove the 2 members who rejected
   - Now organization has 8 members remaining
   - Original proposal vote counts:
     - `approvedMemberCount = 5` (filtered by current members, still valid)
     - `rejectionMemberCount = 0` (filtered, the 2 rejecters removed)
     - `totalVotes = 7` (NOT filtered, includes removed members)
   - Proposal passes with only 5/8 (62.5%) current member participation instead of requiring 7/8 (87.5%)

3. **Governance Manipulation**: Organizations can strategically remove dissenting members after they vote, neutralizing their rejections/abstentions while still benefiting from their vote count toward the participation threshold. This breaks the democratic safeguards that thresholds provide.

4. **Affected Parties**: All Association-based governance systems, including multi-signature wallets and DAOs using Association contracts for decision-making.

### Likelihood Explanation

The vulnerability is highly exploitable under realistic conditions:

1. **Reachable Entry Points**: All functions are part of the public ACS3 interface:
   - `Approve`, `Reject`, `Abstain` for voting
   - `RemoveMember` for member removal
   - `Release` for proposal execution [9](#0-8) 

2. **Feasible Preconditions**: 
   - Only requires normal organization operations (voting and member management)
   - Member removal requires the organization itself to call it (via virtual address), which is standard for organization management
   - No special permissions beyond normal organization governance needed

3. **Execution Practicality**: The attack sequence is straightforward:
   - Create proposal, gather votes
   - Create and pass a second proposal to remove members
   - Release the original proposal with manipulated vote counts
   - All steps use standard contract methods with no unusual parameters

4. **Economic Rationality**: The cost is minimal - only transaction fees for normal proposal operations. The benefit is bypassing intended governance safeguards, which could be valuable for contentious proposals.

5. **Detection Difficulty**: The manipulation is subtle and would appear as legitimate organization management. There's no on-chain signal distinguishing malicious member removal from legitimate restructuring.

### Recommendation

**Code-Level Mitigation**: Modify the `CheckEnoughVoteAndApprovals()` function to filter total votes by current membership, consistent with Parliament's implementation:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
        .Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This change makes the Association contract consistent with:
1. Parliament contract's correct filtering pattern
2. Its own filtering logic for approval/rejection/abstention counts
3. The intended invariant that thresholds reflect current membership participation

**Additional Safeguards**:
1. Add test cases verifying vote counts after member removal
2. Consider whether removed members' votes should be automatically removed from pending proposals
3. Document the behavior when members are added/removed during active proposal voting periods

**Test Cases to Prevent Regression**:
1. Test that `MinimalVoteThreshold` only counts current member votes
2. Test proposal status after member removal (should fail if below threshold)
3. Test consistency between Association and Parliament threshold logic
4. Test edge case where all voters are removed from organization

### Proof of Concept

**Initial State**:
- Organization created with 10 members (Member1-10)
- Thresholds: `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=5`, `MaximalRejectionThreshold=2`

**Attack Sequence**:

1. **Create Proposal A**: "Execute critical action"
   - Proposer: Member1
   - Result: ProposalA created

2. **Vote on Proposal A**:
   - Member1-5: Approve (5 approvals)
   - Member6-7: Reject (2 rejections)
   - Current state: approvedMemberCount=5, rejectionMemberCount=2, totalVotes=7
   - Proposal A should be releasable (5≥5 approvals, 2≤2 rejections, 7≥7 total votes)

3. **Create Proposal B**: "Remove Member6 and Member7"
   - Get 6 approvals from Member1-5 plus one other
   - Release Proposal B
   - Organization now has 8 members

4. **Check Proposal A Status** (Expected vs Actual):
   - **Expected Behavior** (with fix): 
     - totalVotes = 5 (only current member votes)
     - 5 < 7 (MinimalVoteThreshold)
     - Proposal A should NOT be releasable
   
   - **Actual Behavior** (current bug):
     - approvedMemberCount = 5 (filtered correctly)
     - rejectionMemberCount = 0 (removed members excluded)
     - totalVotes = 7 (BUG: includes removed members)
     - 7 ≥ 7 (MinimalVoteThreshold met incorrectly)
     - Proposal A IS releasable despite only 5/8 current members participating

5. **Release Proposal A**: 
   - Member1 calls Release(ProposalA)
   - **Success Condition**: Proposal executes despite insufficient current member participation

**Verification**: The proposal passes with 62.5% current member participation (5/8) when the threshold requires 87.5% (7/8), demonstrating the governance bypass.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L55-57)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-73)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
```

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-188)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L97-100)
```csharp
        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
                .Count(parliamentMembers.Contains) * AbstractVoteTotal >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold * parliamentMembers.Count;
```
