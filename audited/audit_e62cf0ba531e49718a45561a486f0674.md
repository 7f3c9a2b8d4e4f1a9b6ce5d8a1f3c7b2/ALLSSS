# Audit Report

## Title
Race Condition in Mining Order Assignment Allows Duplicate FinalOrderOfNextRound Values

## Summary
The AEDPoS consensus contract fails to validate uniqueness of `FinalOrderOfNextRound` values during `UpdateValue` operations. When multiple miners independently calculate identical mining orders, both values are committed to state without conflict detection, breaking the critical consensus invariant that each miner must have a unique order in the next round.

## Finding Description

The vulnerability exists across two execution phases:

**Phase 1 - Block Generation (Off-chain):**

When a miner generates a block, `GetConsensusExtraDataToPublishOutValue()` calls `ApplyNormalConsensusData()` on a local copy of the current round state. [1](#0-0) 

The conflict detection logic checks for existing miners with the same `FinalOrderOfNextRound` and reassigns them to available slots. [2](#0-1) 

However, this check operates on the miner's local copy of state. In a distributed system, if two miners generate blocks before either's transaction is executed and state is propagated, both will read the same initial state where no conflicts exist yet.

The `TuneOrderInformation` dictionary is populated only with conflicts detected in the local copy. [3](#0-2) 

**Phase 2 - Transaction Execution (On-chain):**

When `ProcessUpdateValue()` executes, it directly assigns the `FinalOrderOfNextRound` from the input without re-validating uniqueness. [4](#0-3) 

It then applies any tuning information, but if both miners detected no conflicts locally, both have empty tuning maps and no adjustments occur. [5](#0-4) 

**Why Existing Protections Fail:**

1. The `UpdateValueValidationProvider` only validates OutValue/Signature correctness and PreviousInValue, with no order uniqueness checks. [6](#0-5) 

2. The `NextRoundMiningOrderValidationProvider` contains a bug - it calls `.Distinct()` on entire `MinerInRound` objects rather than on the `FinalOrderOfNextRound` integer values, making it ineffective at detecting duplicate orders. [7](#0-6) 

3. This validator is only registered for `NextRound` behavior, not for `UpdateValue` behavior. [8](#0-7) 

4. `EnsureTransactionOnlyExecutedOnceInOneBlock()` only prevents the same transaction from executing twice, not different miners' transactions. [9](#0-8) 

## Impact Explanation

When two miners have identical `FinalOrderOfNextRound` values, the next round generation logic breaks critically:

The `GenerateNextRoundInformation()` method orders miners by `FinalOrderOfNextRound` and directly assigns these as the `Order` field in the next round. [10](#0-9) 

With duplicate orders:
- Two miners get assigned to the same mining slot
- The `occupiedOrders` collection used to assign remaining slots becomes incorrect
- Round scheduling becomes undefined
- Block production conflicts occur
- Consensus round transitions fail

This violates the fundamental AEDPoS invariant that each miner must have a unique mining order. The order calculation uses `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, which has a collision probability of approximately 1/N per miner pair. [11](#0-10) 

## Likelihood Explanation

This vulnerability can occur naturally during normal consensus operation:

**Distributed System Race Window:**
- Block generation happens off-chain based on each node's current state view
- State propagation has inherent network latency
- A miner can generate their block header before seeing another miner's committed state update
- This timing window exists in any distributed blockchain system

**Collision Probability:**
With N miners (e.g., 17 in typical AEDPoS), the probability of two miners calculating the same order is approximately 1/N â‰ˆ 6% per miner pair. Over multiple rounds and multiple miners, collisions become increasingly probable.

**No Validation:**
The complete absence of order uniqueness validation for `UpdateValue` operations means that even rare collisions will not be caught and will corrupt state.

**Realistic Conditions:**
- High network latency between geographically distributed nodes
- Fast block production rate
- Network congestion during peak usage
- Normal operation of multi-miner consensus

No attacker is required - this occurs as a natural consequence of distributed system timing and probabilistic order calculation.

## Recommendation

Implement proper uniqueness validation for `FinalOrderOfNextRound` during `UpdateValue` operations:

1. **Fix NextRoundMiningOrderValidationProvider:**
   - Change `.Distinct()` to operate on order values, not entire objects
   - Apply validator to `UpdateValue` behavior, not just `NextRound`

2. **Add State-Level Validation in ProcessUpdateValue:**
   - Before committing `FinalOrderOfNextRound`, check all existing miners in current round for duplicates
   - If duplicate detected, reject the transaction or reassign the conflicting miner

3. **Add Explicit Uniqueness Constraint:**
   - After processing all tuning information, validate that all non-zero `FinalOrderOfNextRound` values are unique
   - Assert failure if duplicates found

Example fix for the validator:
```csharp
var orderValues = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
if (orderValues.Distinct().Count() != orderValues.Count)
{
    validationResult.Message = "Duplicate FinalOrderOfNextRound detected.";
    return validationResult;
}
```

## Proof of Concept

A test demonstrating this vulnerability would:
1. Set up a round with multiple miners
2. Simulate two miners generating blocks with identical signature hash values (leading to same modulo result)
3. Have both miners call `ProcessUpdateValue` with their respective inputs
4. Verify that both miners end up with the same `FinalOrderOfNextRound` value in state
5. Attempt to generate the next round and observe the failure/undefined behavior

The vulnerability is confirmed by the code structure showing no validation preventing this scenario, combined with the proven collision probability in the order calculation algorithm.

## Notes

This vulnerability represents a critical failure in consensus invariant enforcement. While the exact frequency of occurrence depends on network conditions and miner count, the combination of:
- Probabilistic collision in order calculation
- Race condition window in distributed systems  
- Complete absence of validation

Makes this a genuine threat to consensus integrity that should be addressed immediately.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-40)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-247)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-49)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }

    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
