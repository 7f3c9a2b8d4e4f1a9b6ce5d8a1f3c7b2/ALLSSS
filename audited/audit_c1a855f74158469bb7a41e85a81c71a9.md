# Audit Report

## Title
Missing Symbol Validation in Side Chain Token Creation Allows DoS of Governance Process

## Summary
The `AssertValidSideChainTokenInfo()` function in the CrossChain contract performs insufficient validation on side chain token parameters before proposals are created. This allows proposals with invalid token symbols (exceeding 10 characters or containing special characters) to pass initial validation and be approved by governance, but fail during execution when the MultiToken contract enforces proper validation. This results in wasted governance effort, consumed gas, and locked proposer tokens.

## Finding Description

The vulnerability stems from a validation gap between two contract components that validate token creation parameters at different stages of the side chain creation process.

**Initial Validation (Insufficient):**
When a side chain creation request is submitted via `RequestSideChainCreation`, the `AssertValidSideChainTokenInfo()` method only validates that the symbol and name are not null/empty and that the total supply is positive: [1](#0-0) 

This validation is called during the proposal creation phase: [2](#0-1) 

**Stricter Validation (At Execution):**
However, when the proposal is released via `ReleaseSideChainCreation`, it calls `CreateSideChainToken`, which invokes the MultiToken contract's `Create` method: [3](#0-2) [4](#0-3) 

The MultiToken contract enforces much stricter validation through multiple layers:

1. **Symbol format validation** - The `GetSymbolType` method validates that symbols match the pattern `^[a-zA-Z0-9]+$`: [5](#0-4) 

2. **Symbol length validation** - The `CheckSymbolLength` method enforces a maximum of 10 characters for regular tokens: [6](#0-5) [7](#0-6) 

3. **Token name length validation** - The `AssertValidCreateInput` method enforces a maximum of 80 characters for token names: [8](#0-7) 

**The Vulnerability:**
Since `CreateSideChainToken` is called in `ReleaseSideChainCreation` BEFORE the proposal is actually released (via the `Context.SendInline` call on line 108-110), any validation failure in the MultiToken contract will cause the entire transaction to revert. This leaves the proposal in an unreleased state, with the proposer's tokens remaining locked until the proposal expires.

An attacker can exploit this by submitting proposals with:
- Symbols exceeding 10 characters (e.g., "VERYLONGSYMBOL")
- Symbols containing special characters (e.g., "MY-TOKEN!" or "TOKEN@123")
- Token names exceeding 80 characters

These proposals will pass initial validation, consume governance time for review and approval, but will always fail when anyone attempts to release them.

## Impact Explanation

This vulnerability enables a denial-of-service attack on the governance process with the following impacts:

1. **Governance Resource Waste**: Governance members spend time and effort reviewing and approving proposals that are destined to fail during execution. This wastes the collective decision-making capacity of the governance body.

2. **Gas Cost Waste**: Each attempted release consumes transaction gas fees, but the transaction reverts without completing the side chain creation. These costs are borne by whoever attempts to release the proposal.

3. **Capital Inefficiency**: The proposer's tokens (specified in `LockedTokenAmount`) remain locked in the contract from proposal submission until expiration. This reduces capital efficiency and ties up funds unnecessarily.

4. **Operational Disruption**: Multiple invalid proposals can clog the governance queue, creating confusion about which proposals are legitimate and delaying the processing of valid side chain creation requests.

The impact is categorized as operational disruption rather than fund loss, since tokens are eventually unlocked upon proposal expiration. However, it represents a clear degradation of governance effectiveness and wastes both time and gas resources.

## Likelihood Explanation

The attack has moderate-to-low likelihood due to several mitigating factors:

**Factors Increasing Likelihood:**
- **Low Technical Barrier**: The attack requires minimal sophistication - simply submitting a proposal with an invalid symbol
- **Low Economic Cost**: Only requires the standard proposal submission allowance
- **Repeatable**: Can be executed multiple times with different proposals

**Factors Decreasing Likelihood:**
- **Governance Review**: Proposals must be approved by governance, which includes a public review process where observant members could detect invalid symbols
- **Off-Chain Detection**: Invalid symbols can be detected through automated off-chain validation before governance approval
- **Visibility**: Proposal parameters are publicly visible, allowing community monitoring to identify and flag suspicious proposals
- **Immediate Failure**: Failed release attempts are immediately visible, making it difficult to repeatedly exploit unnoticed

The likelihood is assessed as moderate-to-low because while the attack is technically easy to execute, the governance review process provides significant opportunity for detection and rejection before approval.

## Recommendation

Add comprehensive validation to `AssertValidSideChainTokenInfo()` to match the MultiToken contract's requirements:

```csharp
private void AssertValidSideChainTokenInfo(SideChainTokenCreationRequest sideChainTokenCreationRequest)
{
    // Existing checks
    Assert(
        !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenSymbol) &&
        !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenName),
        "Invalid side chain token name.");
    Assert(sideChainTokenCreationRequest.SideChainTokenTotalSupply > 0, "Invalid side chain token supply.");
    
    // Add symbol length validation
    Assert(
        sideChainTokenCreationRequest.SideChainTokenSymbol.Length <= TokenContractConstants.SymbolMaxLength,
        "Token symbol exceeds maximum length of 10 characters.");
    
    // Add token name length validation
    Assert(
        sideChainTokenCreationRequest.SideChainTokenName.Length <= TokenContractConstants.TokenNameLength,
        "Token name exceeds maximum length of 80 characters.");
    
    // Add symbol character validation (alphanumeric only)
    Assert(
        Regex.IsMatch(sideChainTokenCreationRequest.SideChainTokenSymbol, "^[a-zA-Z0-9]+$"),
        "Token symbol must contain only alphanumeric characters.");
}
```

This ensures that validation failures occur during the initial proposal submission phase rather than during governance-approved proposal release, preventing the waste of governance resources and avoiding locked tokens in unreleased proposals.

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:
1. Submits a side chain creation proposal with an invalid symbol (>10 characters)
2. Approves the proposal through governance
3. Attempts to release the proposal
4. Observes that the release transaction fails due to MultiToken validation

The key evidence is that `AssertValidSideChainTokenInfo` accepts symbols that `MultiToken.Create` will reject, creating the validation gap that enables this governance DoS attack.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L100-137)
```csharp
    private void AssertValidSideChainCreationRequest(SideChainCreationRequest sideChainCreationRequest,
        Address proposer)
    {
        var proposedRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(proposedRequest == null || Context.CurrentBlockTime >= proposedRequest.ExpiredTime,
            "Request side chain creation failed.");

        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var allowance = State.TokenContract.GetAllowance.Call(new GetAllowanceInput
        {
            Owner = proposer,
            Spender = Context.Self,
            Symbol = Context.Variables.NativeSymbol
        }).Allowance;

        Assert(
            allowance >= sideChainCreationRequest.LockedTokenAmount,
            "Allowance not enough.");

        Assert(
            sideChainCreationRequest.IndexingPrice >= 0 &&
            sideChainCreationRequest.LockedTokenAmount >= sideChainCreationRequest.IndexingPrice,
            "Invalid chain creation request.");

        if (!sideChainCreationRequest.IsPrivilegePreserved)
            return; // there is no restriction for non-exclusive side chain creation

        AssertValidResourceTokenAmount(sideChainCreationRequest);

        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // assert primary token to create
        AssertValidSideChainTokenInfo(sideChainCreationRequest.SideChainTokenCreationRequest);
        Assert(sideChainCreationRequest.SideChainTokenInitialIssueList.Count > 0 &&
               sideChainCreationRequest.SideChainTokenInitialIssueList.All(issue => issue.Amount > 0),
            "Invalid side chain token initial issue list.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L147-154)
```csharp
    private void AssertValidSideChainTokenInfo(SideChainTokenCreationRequest sideChainTokenCreationRequest)
    {
        Assert(
            !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenSymbol) &&
            !string.IsNullOrEmpty(sideChainTokenCreationRequest.SideChainTokenName),
            "Invalid side chain token name.");
        Assert(sideChainTokenCreationRequest.SideChainTokenTotalSupply > 0, "Invalid side chain token supply.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L176-195)
```csharp
    private void CreateSideChainToken(SideChainCreationRequest sideChainCreationRequest, int chainId,
        Address creator)
    {
        if (!IsPrimaryTokenNeeded(sideChainCreationRequest))
            return;

        // new token needed only for exclusive side chain
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        State.TokenContract.Create.Send(new CreateInput
        {
            TokenName = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenName,
            Decimals = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenDecimals,
            IsBurnable = true,
            Issuer = creator,
            IssueChainId = chainId,
            Symbol = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenSymbol,
            TotalSupply = sideChainCreationRequest.SideChainTokenCreationRequest.SideChainTokenTotalSupply,
            Owner = creator
        });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L98-114)
```csharp
    public override Empty ReleaseSideChainCreation(ReleaseSideChainCreationInput input)
    {
        var sideChainCreationRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(sideChainCreationRequest != null, "Release side chain creation failed.");
        if (!TryClearExpiredSideChainCreationRequestProposal(input.ProposalId, Context.Sender))
        {
            var serialNumber = State.SideChainSerialNumber.Value.Add(1);
            var chainId = GetChainId(serialNumber);
            CreateSideChainToken(sideChainCreationRequest.SideChainCreationRequest, chainId,
                sideChainCreationRequest.Proposer);
            Context.SendInline(State.SideChainLifetimeController.Value.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
                input.ProposalId);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L305-311)
```csharp
    private void CheckSymbolLength(string symbol, SymbolType symbolType)
    {
        if (symbolType == SymbolType.Token)
            Assert(symbol.Length <= TokenContractConstants.SymbolMaxLength, "Invalid token symbol length");
        if (symbolType == SymbolType.Nft || symbolType == SymbolType.NftCollection)
            Assert(symbol.Length <= TokenContractConstants.NFTSymbolMaxLength, "Invalid NFT symbol length");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L5-8)
```csharp
    public const int TokenNameLength = 80;
    public const int MaxDecimals = 18;
    public const int SymbolMaxLength = 10;
    public const int MemoMaxLength = 64;
```
