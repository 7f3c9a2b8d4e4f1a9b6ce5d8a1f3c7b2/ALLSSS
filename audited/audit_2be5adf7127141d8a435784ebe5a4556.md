### Title
Predictable Signature Generation via Null InValue Bypass Allows Mining Order Manipulation

### Summary
A miner can manipulate their mining order in the next round by intentionally omitting their `PreviousInValue`, forcing the system to use a predictable `fakePreviousInValue` based on block height for signature calculation. The vulnerability exists because `InValue` is never populated for miners who produce blocks normally, causing the null check at line 100 to fail and allowing signature manipulation that passes validation.

### Finding Description

The vulnerability occurs in the `GetConsensusExtraDataToPublishOutValue` function when a miner does not provide their `PreviousInValue` in the trigger information. The code path is as follows: [1](#0-0) 

When a miner omits `triggerInformation.PreviousInValue`, the code computes a `fakePreviousInValue` from the concatenation of pubkey and current block height. The code then attempts to retrieve the miner's stored `InValue` from the previous round to override this fake value. However, this stored `InValue` is never populated for miners who produce blocks normally.

The root cause is that `InValue` is only set by `SupplyCurrentRoundInformation` for miners who **missed** their blocks, never for miners who produced blocks successfully: [2](#0-1) 

During normal block production via `ProcessUpdateValue`, the miner's `InValue` field is never assigned: [3](#0-2) 

This creates a logic gap where the null check `if (appointedPreviousInValue != null)` at line 100 always fails for miners who produced blocks normally, allowing them to use the predictable `fakePreviousInValue` for signature calculation.

The signature determines the miner's order in the next round through this mechanism: [4](#0-3) 

The validation system does not prevent this attack because it explicitly allows `Hash.Empty` as a valid `PreviousInValue`: [5](#0-4) 

This is by design, as indicated in the comment: [6](#0-5) 

However, while the `PreviousInValue` stored in the round is `Hash.Empty`, the **signature** is calculated using the predictable `fakePreviousInValue`, creating a mismatch that enables manipulation.

### Impact Explanation

**Consensus Integrity Violation**: An attacker can manipulate their position in the mining order for the next round, undermining the fairness and randomness that the AEDPoS consensus mechanism is designed to provide. 

**Specific Harms**:
1. **Unfair Mining Advantages**: Earlier positions in the mining order allow miners to be first to process transactions, potentially extracting MEV (Miner Extractable Value)
2. **Reward Manipulation**: Mining order can affect reward distribution in certain scenarios
3. **Consensus Fairness Breakdown**: Honest miners who properly reveal their `PreviousInValue` are disadvantaged against attackers who manipulate their order
4. **Protocol Trust Degradation**: The deterministic order generation based on signatures loses its unpredictability property

**Affected Parties**: All honest miners and the network's consensus integrity. The attack can be repeated every round by any malicious miner.

**Severity Justification**: HIGH - This directly compromises the core consensus mechanism's fairness and enables systematic gaming of the mining order by any miner, violating the critical invariant of "miner schedule integrity."

### Likelihood Explanation

**Attacker Capabilities**: Any active miner can execute this attack. The attacker only needs to:
1. Be a valid miner in the current round
2. Control the timing of their block submission
3. Omit `PreviousInValue` from their trigger information

**Attack Complexity**: LOW. The attacker can:
- Compute signatures offline for multiple block heights: `Hash(pubkey + height_1)`, `Hash(pubkey + height_2)`, etc.
- Calculate the resulting `SupposedOrderOfNextRound` for each height
- Choose to mine at the block height that gives them the most favorable next-round position
- Submit their block with `PreviousInValue` omitted (null or `Hash.Empty`)

**Feasibility Conditions**: 
- No special permissions required beyond being a miner
- No additional computational or economic cost
- Attack can be executed every round
- No detection mechanism exists since omitting `PreviousInValue` is explicitly permitted by validation

**Detection Constraints**: The attack is undetectable because:
1. Validation explicitly allows `PreviousInValue = Hash.Empty`
2. No signature source validation exists
3. The system is designed to permit miners not publishing in values

**Probability**: HIGH - The attack is practical, repeatable, and offers direct benefit with no downside risk to the attacker.

### Recommendation

**Immediate Fix**: Enforce that miners who produced blocks in the previous round MUST reveal their `PreviousInValue`. Modify the validation logic to reject `Hash.Empty` or `null` `PreviousInValue` for miners who were present and produced blocks in the previous round:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
    
    // NEW CHECK: If miner produced blocks in previous round, they MUST reveal PreviousInValue
    var minerInPreviousRound = validationContext.PreviousRound.RealTimeMinersInformation[publicKey];
    if (minerInPreviousRound.OutValue != null && minerInPreviousRound.OutValue != Hash.Empty)
    {
        // Miner produced a block in previous round, must reveal InValue
        if (previousInValue == null || previousInValue == Hash.Empty)
            return false; // Reject empty PreviousInValue for miners who mined previously
    }

    if (previousInValue == null || previousInValue == Hash.Empty) 
        return true;

    var previousOutValue = minerInPreviousRound.OutValue;
    return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
}
```

**Additional Safeguards**:
1. Store the actual `InValue` when processing `UpdateValue` to enable recovery mechanisms
2. Add signature validation to ensure it was derived from the correct previous in value
3. Implement slashing for miners who fail to reveal their `PreviousInValue` after producing blocks

**Test Cases**:
1. Test that miners who produced blocks in round N cannot omit `PreviousInValue` in round N+1
2. Test that miners who missed blocks in round N can still mine in round N+1 with `Hash.Empty`
3. Test that signature validation rejects signatures not derived from revealed `PreviousInValue`

### Proof of Concept

**Required Initial State**:
- Attacker is a valid miner in rounds N and N+1
- Attacker successfully mines a block in round N with `OutValue_N = Hash(InValue_N)`

**Attack Sequence**:

**Round N (Setup)**:
1. Attacker mines normally, generates secret `InValue_N`
2. Publishes `OutValue_N = Hash(InValue_N)` 
3. Stores `InValue_N` locally (keeps secret)

**Round N+1 (Exploitation)**:
1. Attacker prepares to mine their block at height H
2. Computes offline: for heights H, H+1, H+2... calculate `fakePreviousInValue = Hash(pubkey + height.ToString())`
3. For each height, calculates resulting signature: `sig = CalculateSignature(fakePreviousInValue)` using previous round's miner signatures
4. For each signature, calculates next round order: `order = (sig.ToInt64() % minersCount) + 1`
5. Selects the height H* that gives the most favorable order (e.g., order = 1 for first position)
6. Waits until blockchain reaches height H*
7. Submits block with:
   - `triggerInformation.InValue = InValue_{N+1}` (new random value)
   - `triggerInformation.PreviousInValue = null` (OMITTED - this is the attack)
8. Code path executes the vulnerable branch:
   - `appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue` â†’ **null** (never set)
   - Null check fails, keeps `fakePreviousInValue = Hash(pubkey + H*)`
   - Signature calculated using predictable value
9. Validation passes because `PreviousInValue` stored as `Hash.Empty` is explicitly allowed
10. Attacker's `SupposedOrderOfNextRound` is set to their chosen favorable position

**Expected vs Actual Result**:
- **Expected**: Signature should be unpredictable, derived from secret previous InValue
- **Actual**: Signature is predictable, derived from controllable block height, allowing order manipulation

**Success Condition**: Attacker consistently achieves favorable mining positions (e.g., first 3 positions) more frequently than statistical probability would allow, indicating successful order manipulation.

### Notes

This vulnerability exploits a fundamental assumption in the code: that miners who don't provide `PreviousInValue` will have their `InValue` stored from the previous round via `SupplyCurrentRoundInformation`. However, this only occurs for miners who **missed** their blocks. Miners who produced blocks successfully never have `InValue` populated, creating an exploitable logic gap.

The design decision to allow miners not to publish their in values (as indicated by the comment "It is permissible for miners not publish their in values") appears intended for edge cases like newly joined miners or recovery scenarios, but it inadvertently enables this manipulation vector for normal miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L94-102)
```csharp
            else
            {
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L213-214)
```csharp
            miner.InValue = previousInValue;
            miner.Signature = signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-265)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L42-46)
```csharp
        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;
```
