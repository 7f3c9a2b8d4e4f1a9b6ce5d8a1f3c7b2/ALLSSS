### Title
Integer Overflow in Bancor Price Calculation Causes Denial of Service for Large Token Purchases

### Summary
The `GetAmountToPayFromReturn()` function in BancorHelper validates that inputs are positive but fails to check for upper bounds. When users attempt to buy large amounts of tokens, the Bancor formula calculations produce decimal values exceeding `Long.MaxValue`. Since overflow checking is enabled in the project configuration, casting these values to `long` throws an `OverflowException`, causing transaction reversion and preventing legitimate large token purchases.

### Finding Description

The vulnerability exists in the `GetAmountToPayFromReturn()` method which calculates the cost to purchase a specified amount of tokens using the Bancor formula. [1](#0-0) 

The validation only checks that connector balances and amounts are positive, with no upper bound validation. The function then performs Bancor calculations and casts the result to `long`:

**Equal weights path:** [2](#0-1) 

**Different weights path:** [3](#0-2) 

The project has overflow checking explicitly enabled: [4](#0-3) 

This function is called from the public `Buy()` method: [5](#0-4) 

The `BuyInput` message only defines amount as `int64` with no additional constraints: [6](#0-5) 

**Root Cause:** The Bancor pricing model is designed so that purchasing a large percentage of available supply results in exponentially increasing prices. For example, with equal weights and the simplified formula `(bf / (bt - a)) * a`, if a user attempts to buy 99% of the supply:
- Result = `(fromBalance / (toBalance - 0.99*toBalance)) * 0.99*toBalance`
- Result = `(fromBalance / 0.01*toBalance) * 0.99*toBalance`
- Result = `100 * fromBalance * 0.99` ≈ `99 * fromBalance`

With realistic token supplies (e.g., 10^18 for 18-decimal tokens), this easily exceeds `Long.MaxValue` (9.22 × 10^18).

### Impact Explanation

**Concrete Harm:**
- Users cannot purchase large amounts of tokens even if they have sufficient funds and the purchase is economically valid
- The connector becomes unusable for any transaction that would trigger the overflow
- Protocol functionality is blocked for legitimate high-value trades

**Affected Parties:**
- Any user attempting to buy a significant percentage of available token supply
- Particularly affects connectors with large token balances (common in production blockchains with 18-decimal tokens)

**Severity Justification:**
This is a **High severity** Denial of Service vulnerability because:
1. It affects core protocol functionality (token purchasing)
2. It can be triggered by any user without special privileges
3. It blocks economically valid transactions
4. The Bancor formula naturally produces large values for reasonable purchase sizes, making this easily triggerable in production environments

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call the public `Buy()` method
- No special permissions or privileges required
- Only needs to specify a large amount in the transaction input

**Attack Complexity:**
- Trivial - single transaction with large `amount` parameter
- No complex setup or state manipulation required

**Feasibility Conditions:**
- Connector has sufficient token balance
- User attempts to buy a large percentage (>50-90%) of available supply
- With 18-decimal tokens at 10^18+ supply, even buying 10% could trigger overflow depending on weights

**Probability:**
High likelihood in production because:
1. Blockchain tokens commonly use 10^18+ total supplies
2. Legitimate users may attempt large purchases for liquidity provision or strategic positions
3. The Bancor formula's exponential nature makes overflow likely for purchases exceeding 50% of available supply

### Recommendation

**Code-Level Mitigation:**

1. Add upper bound validation before calculations:

```csharp
// In GetAmountToPayFromReturn(), after line 73:
Assert(amountToReceive < toConnectorBalance, 
    "Amount to receive cannot exceed available balance");

// Add safety check for percentage:
var purchasePercentage = (decimal)amountToReceive / toConnectorBalance;
Assert(purchasePercentage < 0.95m, 
    "Cannot purchase more than 95% of available supply in single transaction");
```

2. Add try-catch with meaningful error for overflow:

```csharp
try {
    return (long)(bf / (bt - a) * a);
} catch (OverflowException) {
    throw new AssertionException("Purchase amount too large - would exceed maximum calculable value");
}
```

3. Consider using SafeMath operations with explicit bounds checking: [7](#0-6) 

**Invariant Checks:**
- `amountToReceive < toConnectorBalance * 0.95` (prevent >95% purchases)
- Result of Bancor calculation must be < `Long.MaxValue` before casting
- Result must be positive and reasonable (not orders of magnitude larger than input balances)

**Test Cases:**
1. Test buying 50%, 75%, 90%, 95%, 99% of available supply
2. Test with connector balances at 10^18 (realistic token supply)
3. Test with different weight combinations (0.1-0.9 range)
4. Verify appropriate error messages for overflow scenarios

### Proof of Concept

**Required Initial State:**
- TokenConverter contract initialized
- Connector pair established with:
  - `fromConnectorBalance` = 1,000,000,000,000,000,000 (10^18)
  - `toConnectorBalance` = 1,000,000,000,000,000,000 (10^18)
  - `fromConnectorWeight` = 0.5
  - `toConnectorWeight` = 0.5
  - Connector enabled for purchase

**Transaction Steps:**

1. User calls `Buy()` with:
   ```
   symbol: [target token symbol]
   amount: 990,000,000,000,000,000 (99% of supply)
   payLimit: 0 (no limit)
   ```

2. `GetAmountToPayFromReturn()` executes:
   - Passes validation (amount > 0)
   - Equal weights path: calculates `(10^18 / (10^18 - 0.99*10^18)) * 0.99*10^18`
   - Result: `(10^18 / 0.01*10^18) * 0.99*10^18 = 100 * 0.99*10^18 = 99*10^18`
   - Attempts cast: `(long)(99*10^18)`
   - 99*10^18 > Long.MaxValue (9.22*10^18)

**Expected vs Actual Result:**
- **Expected:** Transaction processes or returns meaningful error about purchase size
- **Actual:** `OverflowException` thrown, transaction reverts with cryptic error

**Success Condition:**
Transaction fails with OverflowException instead of processing the purchase or returning a user-friendly error message.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-73)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L80-84)
```csharp
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** protobuf/token_converter_contract.proto (L125-133)
```text
message BuyInput {
    // The token symbol you want to buy.
    string symbol = 1;
    // The amount you want to buy.
    int64 amount = 2;
    // Limit of cost. If the token required for buy exceeds this value, the buy will be abandoned.
    // And 0 is no limit.
    int64 pay_limit = 3; 
}
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L1-10)
```csharp
﻿using System.Numerics;
using AElf.Types;

namespace AElf.CSharp.Core;

/// <summary>
///     Helper methods for safe math operations that explicitly check for overflow.
/// </summary>
public static class SafeMath
{
```
