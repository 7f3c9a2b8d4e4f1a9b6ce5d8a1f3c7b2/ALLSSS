### Title
Time-of-Check-Time-of-Use (TOCTOU) Race Condition in Contract Address Reservation Allows Conflicting Proposals

### Summary
The `ProposeNewContract` function checks contract address availability at proposal creation time but does not reserve the address until actual deployment occurs after governance approval. This creates a TOCTOU vulnerability where multiple proposals with the same deployer/salt combination can all pass validation, but only the first deployed contract will succeed, causing subsequent approved proposals to fail and waste governance resources.

### Finding Description

The vulnerability exists in the contract deployment proposal flow with the following execution path:

**Check Phase (Proposal Creation):** [1](#0-0) 

At line 139, `AssertContractAddressAvailable` is called, which computes the deterministic contract address from the deployer and salt, then checks if it's available: [2](#0-1) 

However, this check does NOT reserve the address. The proposal is registered by input hash only: [3](#0-2) 

The `RegisterContractProposingData` method only prevents duplicate proposals with identical input (same code, deployer, salt). Different contracts with the same deployer/salt have different input hashes and are allowed.

**Use Phase (Actual Deployment):** [4](#0-3) 

The address is only reserved when `State.ContractInfos[contractAddress]` is set during actual deployment at line 70: [5](#0-4) 

**Root Cause:**
The time gap between the check (proposal creation) and reservation (deployment after governance approval) can be hours or days. During this period, multiple valid proposals with the same deployer/salt but different code can be created, all passing the availability check.

**Attack Constraint:**
The attacker must have valid signing authority for the target deployer address, verified here: [6](#0-5) 

The signature must recover to either the deployer itself or an address registered in `State.SignerMap[deployer]`.

### Impact Explanation

**Governance Resource Waste:**
When multiple proposals with conflicting deployer/salt combinations proceed through the multi-stage approval process (ContractDeploymentController approval → code check proposal → CodeCheckController approval), all but one will fail at deployment. This wastes:
- Validator voting time and gas for approving proposals that will ultimately fail
- Block producer resources for code checking doomed proposals
- User gas fees for release transactions

**Deployment Failures:**
Users who successfully navigate the entire governance approval process will experience unexpected deployment failures with "Contract address exists" error, despite their proposal passing all checks and approvals. This creates poor user experience and unpredictable outcomes.

**Griefing Vector:**
An attacker with signing rights for a deployer address can intentionally submit conflicting proposals to block legitimate deployments or force races between proposals. In scenarios with shared multisig deployers or delegated signers, malicious parties can exploit this.

**Severity Justification:**
Medium severity due to operational disruption of governance flows and potential for griefing, though mitigated by the requirement for signing authority.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Access to a deployer address's private key OR registration as an authorized signer via `SetSigner`
- Ability to craft valid `ContractOperation` with proper signature
- Knowledge of pending proposals (observable on-chain or in transaction pool)

**Attack Scenarios:**
1. **Malicious Signer:** A party granted signer rights via `SetSigner` submits conflicting proposals to grief the deployer
2. **Shared Multisig:** Multiple teams using the same multisig deployer accidentally or intentionally create conflicting proposals
3. **Accidental Collision:** Same user accidentally submits the same deployer/salt with different code (e.g., during testing)
4. **Front-running:** Attacker monitors pending proposals and submits higher-priority transaction with same deployer/salt

**Feasibility Conditions:**
- Entry point is publicly accessible via `ProposeNewContract`
- No commented-out authorization check at line 124 provides additional protection
- The signature validation is the only barrier, which is realistic in delegated deployment scenarios

**Probability Assessment:**
Low-to-Medium likelihood. While the signing requirement limits casual attacks, legitimate scenarios exist where multiple parties have signing authority (multisig wallets, delegated deployment rights, contract factories). The long time window (days/weeks) between proposal and deployment increases collision probability.

### Recommendation

**Immediate Mitigation:**
Reserve the contract address at proposal creation time by maintaining a separate mapping of reserved addresses:

```csharp
// In BasicContractZeroState.cs
public MappedState<Address, Hash> ReservedContractAddresses { get; set; }

// In ProposeNewContract, after line 139:
if (input.ContractOperation != null)
{
    ValidateContractOperation(input.ContractOperation, 0, codeHash);
    RemoveOneTimeSigner(input.ContractOperation.Deployer);
    
    var contractAddress = AddressHelper.ComputeContractAddress(
        input.ContractOperation.Deployer, input.ContractOperation.Salt);
    
    AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
    
    // NEW: Reserve the address immediately
    Assert(State.ReservedContractAddresses[contractAddress] == null || 
           Context.CurrentBlockTime >= State.ContractProposingInputMap[State.ReservedContractAddresses[contractAddress]].ExpiredTime,
           "Contract address already reserved by another proposal.");
    State.ReservedContractAddresses[contractAddress] = proposedContractInputHash;
}

// In TryClearContractProposingData, when clearing proposal:
// Remove the reservation when proposal is deployed or expired
if (contractProposingInput.ContractAddress != null)
{
    State.ReservedContractAddresses.Remove(contractProposingInput.ContractAddress);
}
```

**Invariant to Enforce:**
For any contract address computed from (deployer, salt), at most one active proposal can reserve it at any time until deployment or expiration.

**Test Cases:**
1. Test that two proposals with same deployer/salt but different code cannot both be created
2. Test that reservation is cleared upon deployment
3. Test that expired proposals release their address reservations
4. Test that the same deployer/salt can be reused after proposal expiration

### Proof of Concept

**Initial State:**
- Deployer address D with private key K
- Two users A and B both have signing authority for D (B is registered via SetSigner)
- Salt S = Hash("mysalt")

**Attack Sequence:**

1. **T=0:** User A calls `ProposeNewContract` with:
   - ContractOperation.Deployer = D
   - ContractOperation.Salt = S  
   - ContractOperation.CodeHash = Hash(CodeA)
   - Valid signature from A using K
   - Result: Check passes, ProposalA created with proposalHashA

2. **T=100:** User B calls `ProposeNewContract` with:
   - ContractOperation.Deployer = D
   - ContractOperation.Salt = S
   - ContractOperation.CodeHash = Hash(CodeB) ← Different code
   - Valid signature from B (authorized signer)
   - Result: Check passes, ProposalB created with proposalHashB
   - Note: Different input hash (different code) so RegisterContractProposingData allows it

3. **T=1000:** ProposalA completes governance approval and deploys
   - Address = ComputeContractAddress(D, S)
   - State.ContractInfos[Address] = ContractA
   - Deployment succeeds

4. **T=2000:** ProposalB completes governance approval and attempts deployment
   - Address = ComputeContractAddress(D, S) ← Same address
   - Assert at line 40 fails: "Contract address exists"
   - Deployment fails despite full governance approval

**Expected Result:** Both proposals should not be allowed to proceed simultaneously

**Actual Result:** Both proposals pass validation and proceed through governance, but second deployment fails

**Success Condition:** Second proposal creation should fail at line 139 with address reservation conflict

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L139-139)
```csharp
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L34-41)
```csharp
        else
        {
            serialNumber = 0;
            contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        }

        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L70-70)
```csharp
        State.ContractInfos[contractAddress] = info;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L395-413)
```csharp
    private void ValidateContractOperation(ContractOperation contractOperation, int currentVersion, Hash codeHash)
    {
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
        Assert(contractOperation.CodeHash != null && !contractOperation.CodeHash.Value.IsNullOrEmpty(),
            "Invalid input code hash.");
        Assert(!contractOperation.Signature.IsNullOrEmpty(), "Invalid input signature.");

        Assert(contractOperation.Version == currentVersion + 1, "Invalid input version.");
        Assert(contractOperation.ChainId == Context.ChainId, "Invalid input chain id.");
        Assert(contractOperation.CodeHash == codeHash, "Invalid input code hash.");

        var recoveredAddress = RecoverAddressFromSignature(contractOperation);

        Assert(
            recoveredAddress == contractOperation.Deployer ||
            State.SignerMap[contractOperation.Deployer] == recoveredAddress, "Invalid signature.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L440-444)
```csharp
    private void AssertContractAddressAvailable(Address deployer, Hash salt)
    {
        var contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
    }
```
