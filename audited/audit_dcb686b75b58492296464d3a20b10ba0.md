# Audit Report

## Title
Miners Lose Term Credit When Replacing Pubkey Before Term End Due to Stale Round Data

## Summary
When a miner replaces their public key via `ReplaceCandidatePubkey`, the Election contract transfers the candidateInformation to the new pubkey and removes it from the old pubkey. However, the consensus contract's stored round data for previous rounds remains unchanged with the old pubkey. When `TakeSnapshot` is called at term end, it retrieves miners from this stale round data, but the early return in `UpdateCandidateInformation` prevents updating the Terms list because the old pubkey's candidateInformation is now null. This causes miners to lose credit for terms where they successfully produced blocks.

## Finding Description

The vulnerability stems from incomplete synchronization between pubkey replacement and historical round data during term snapshots.

**Root Cause:**

When `ReplaceCandidatePubkey` is called, the Election contract removes the old pubkey's candidateInformation and creates it under the new pubkey: [1](#0-0) 

The consensus contract is notified and updates the **current** round's `RealTimeMinersInformation` to use the new pubkey: [2](#0-1) 

However, previous rounds already stored in state remain unchanged and still contain the old pubkey.

**Failure Point:**

When a term ends, `TakeSnapshot` is called by the consensus contract: [3](#0-2) 

It calls `GetPreviousTermMinerPubkeyList`, which returns pubkeys directly from the stored round data without applying any pubkey replacement mapping: [4](#0-3) 

For each pubkey in this list, `UpdateCandidateInformation` is called. This private method has an early return when candidateInformation is null: [5](#0-4) 

Since the old pubkey's candidateInformation was removed during replacement, the method returns early at line 485, preventing the Terms list update.

**Why Existing Protections Fail:**

The codebase has a `GetNewestPubkey` function that correctly maps old pubkeys to their newest replacements: [6](#0-5) 

This function is correctly used in other parts of the codebase, such as when withdrawing votes: [7](#0-6) 

However, it is **not used** in the `TakeSnapshot` flow before calling `UpdateCandidateInformation`, causing the old (now null) pubkey to be used instead of the correctly resolved new one.

## Impact Explanation

This vulnerability breaks critical invariants in the Election contract's miner participation tracking system:

**Direct Impacts:**
1. **Loss of Participation Records**: Miners who replace their pubkeys lose credit for any terms where they successfully produced blocks if the replacement occurs before term end and `TakeSnapshot` is called.

2. **Incomplete Terms List**: The `Terms` list in candidateInformation becomes incomplete, missing terms where the miner actually participated. This violates the documented purpose of the Terms field.

3. **Broken Continuity Tracking**: The `ContinualAppointmentCount` is not updated correctly, breaking the continuity tracking mechanism used to measure consistent miner performance.

**Affected Parties:**
- Any miner who uses the legitimate pubkey replacement feature for key rotation
- Voters who rely on accurate candidate history to make informed voting decisions  
- Off-chain systems and UIs that display miner participation history for transparency

**Severity Justification:**
This is a **High** severity issue because it directly compromises the integrity of the election system's transparency and accountability mechanisms. The Terms list serves as the historical record of miner participation, and its corruption undermines trust in the system. While it doesn't directly affect funds, it impacts governance transparency and could affect future eligibility determinations if the Terms list is used for such purposes.

## Likelihood Explanation

**Trigger Conditions:**
- Any miner with a valid candidateInformation entry can trigger this vulnerability by calling `ReplaceCandidatePubkey`
- No special privileges required beyond being a registered candidate
- The vulnerability activates automatically when the term ends and `TakeSnapshot` is executed

**Attack Complexity:**
- **Very Simple**: The miner simply calls `ReplaceCandidatePubkey` at any time before or during a term
- The term credit loss happens passively when the consensus contract calls `TakeSnapshot` at term end
- No special timing requirements or race conditions needed

**Feasibility:**
- Pubkey replacement is a legitimate, documented feature designed for key rotation scenarios
- Using this feature is not suspicious and is expected in production
- Works for any miner in any term with no additional preconditions

**Probability:**
This is **High** likelihood because:
- The vulnerability triggers automatically for every miner who replaces their pubkey before term end
- Key rotation is a security best practice, so usage is expected
- No detection mechanism exists to warn users of the impending credit loss
- The issue is deterministic and reproducible

## Recommendation

Apply the `GetNewestPubkey` resolution before calling `UpdateCandidateInformation` in the `TakeSnapshot` flow. Modify the code as follows:

In `ElectionContract_Maintainence.cs`, update the `TakeSnapshot` method to resolve pubkeys before updating candidate information:

```csharp
foreach (var pubkey in previousTermMinerList)
{
    var newestPubkey = GetNewestPubkey(pubkey);
    UpdateCandidateInformation(newestPubkey, input.TermNumber, previousTermMinerList);
}
```

This ensures that even if the consensus round data contains old pubkeys, the Election contract will correctly update the candidateInformation associated with the current (newest) pubkey, maintaining the integrity of the Terms list and ContinualAppointmentCount.

## Proof of Concept

**Scenario:**
1. Miner becomes an active block producer in term N
2. During term N, miner calls `ReplaceCandidatePubkey` to rotate keys (oldPubkey â†’ newPubkey)
3. Election contract moves candidateInformation from oldPubkey to newPubkey
4. Consensus contract updates current round but previous rounds retain oldPubkey
5. Term N ends and consensus contract calls `TakeSnapshot`
6. `GetPreviousTermMinerPubkeyList` returns oldPubkey from stored round data
7. `UpdateCandidateInformation(oldPubkey, ...)` is called
8. candidateInformation lookup for oldPubkey returns null
9. Early return at line 485 prevents Terms list update
10. Miner's participation in term N is lost from their candidateInformation

**Expected Result:** Miner's Terms list should include term N since they produced blocks during that term.

**Actual Result:** Miner's Terms list does not include term N, violating the participation record invariant.

**Test Validation:** This can be verified by:
1. Querying candidateInformation for the new pubkey after term end
2. Checking that the Terms list does not contain the term where the replacement occurred
3. Verifying the ContinualAppointmentCount was not incremented despite continuous participation

---

## Notes

This vulnerability represents a subtle but significant flaw in the cross-contract state synchronization between the Election and Consensus contracts. The fix is straightforward and follows the existing pattern already used correctly in other methods like `Withdraw` and `ChangeVotingOption`. The root issue is that historical consensus round data is immutable once written, so any reference to it must account for potential pubkey replacements through the `GetNewestPubkey` mapping.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L237-242)
```csharp
        var candidateInformation = State.CandidateInformationMap[input.OldPubkey];
        if (candidateInformation != null)
        {
            candidateInformation.Pubkey = input.NewPubkey;
            State.CandidateInformationMap[input.NewPubkey] = candidateInformation;
            State.CandidateInformationMap.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L430-434)
```csharp
        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L481-492)
```csharp
    private void UpdateCandidateInformation(string pubkey, long lastTermNumber,
        List<string> previousMiners)
    {
        var candidateInformation = State.CandidateInformationMap[pubkey];
        if (candidateInformation == null) return;
        candidateInformation.Terms.Add(lastTermNumber);
        var victories = GetVictories(previousMiners);
        candidateInformation.ContinualAppointmentCount = victories.Contains(ByteStringHelper.FromHexString(pubkey))
            ? candidateInformation.ContinualAppointmentCount.Add(1)
            : 0;
        State.CandidateInformationMap[pubkey] = candidateInformation;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L136-146)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L464-472)
```csharp
    public override PubkeyList GetPreviousTermMinerPubkeyList(Empty input)
    {
        var lastRoundNumber = State.FirstRoundNumberOfEachTerm[State.CurrentTermNumber.Value].Sub(1);
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
        return new PubkeyList
        {
            Pubkeys = { lastRound.RealTimeMinersInformation.Keys }
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L651-660)
```csharp
        var newestPubkey = GetNewestPubkey(votingRecord.Option);
        var candidateVotes = State.CandidateVotes[newestPubkey];

        Assert(candidateVotes != null, $"Newest pubkey {newestPubkey} is invalid. Old pubkey is {votingRecord.Option}");

        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
        candidateVotes.ObtainedActiveVotedVotesAmount =
            candidateVotes.ObtainedActiveVotedVotesAmount.Sub(votingRecord.Amount);
        State.CandidateVotes[newestPubkey] = candidateVotes;
```
