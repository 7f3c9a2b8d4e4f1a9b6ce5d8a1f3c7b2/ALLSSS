### Title
PreviousInValue Validation Bypass Allows Miners to Hide Malicious Random Number Generation

### Summary
The `RecoverFromUpdateValue()` function copies `PreviousInValue` for all miners without proper validation. While `UpdateValueValidationProvider` attempts to validate the sender's `PreviousInValue`, it allows `Hash.Empty` to pass validation even when the miner has a committed `OutValue` in the previous round. This breaks the InValue/OutValue commitment scheme, enabling miners to avoid accountability for random number generation and manipulate consensus randomness.

### Finding Description

**Root Cause:**

In `RecoverFromUpdateValue()`, line 18 copies the sender's `PreviousInValue` and lines 28-29 copy `PreviousInValue` for all miners from the provided round into the current state: [1](#0-0) [2](#0-1) 

The validation occurs in `ValidateBeforeExecution()` where `RecoverFromUpdateValue()` is called first, then `UpdateValueValidationProvider` is added to perform validation: [3](#0-2) [4](#0-3) 

**Critical Flaw:**

The `ValidatePreviousInValue()` method has an early return that allows `Hash.Empty` to pass validation without checking the hash relationship: [5](#0-4) 

At line 46, if `previousInValue == Hash.Empty`, validation returns `true` immediately, skipping the critical check at line 48 that verifies `Hash(previousInValue) == previousOutValue`. This occurs even when the miner has a non-null `OutValue` in the previous round (line 44 successfully retrieves `previousOutValue`).

**Additional Issue:**

Lines 28-29 in `RecoverFromUpdateValue()` copy `PreviousInValue` for ALL miners, but validation only checks the sender's value (line 38). Other miners' `PreviousInValue` values can be set through `RevealedInValues` in the trigger information without any validation: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Consensus Integrity Breach:**

The AEDPoS consensus relies on a cryptographic commitment scheme where miners:
1. Commit to `OutValue = Hash(InValue)` in round N
2. Reveal `InValue` as `PreviousInValue` in round N+1
3. Verification ensures `Hash(PreviousInValue) == OutValue` from previous round

This validation bypass breaks the commitment scheme entirely. A malicious miner can:

1. **Hide Malicious Random Number Generation:** Generate `OutValue` through manipulation (e.g., grinding for favorable values) in round N, then provide `Hash.Empty` as `PreviousInValue` in round N+1 to avoid revealing how the value was generated.

2. **Manipulate Mining Order:** Since `PreviousInValue` is used in `CalculateSignature()` which determines `SupposedOrderOfNextRound`, miners can influence mining order by selectively revealing or hiding their values: [8](#0-7) 

3. **Set False Values for Other Miners:** Through `RevealedInValues`, a malicious miner can set incorrect `PreviousInValue` for other miners, affecting round hash calculations and consensus validation: [9](#0-8) 

**Affected Parties:**
- All network participants relying on fair consensus randomness
- Miners expecting fair time-slot allocation and mining order
- DApps and protocols depending on unpredictable random numbers

**Severity Justification:**
HIGH severity due to fundamental consensus integrity violation enabling manipulation of core protocol randomness and miner scheduling.

### Likelihood Explanation

**Attacker Capabilities:**
Any miner can exploit this vulnerability with no special privileges beyond standard mining rights.

**Attack Complexity:**
LOW - Exploitation requires only:
1. Producing a block with `UpdateValue` behavior
2. Providing `Hash.Empty` as `PreviousInValue` in the consensus extra data
3. Optionally providing false `RevealedInValues` for other miners

**Feasibility Conditions:**
- Attacker must be a registered miner (realistic prerequisite)
- No additional preconditions or state requirements
- Works in any round after the first round of a term

**Detection Constraints:**
The validation explicitly allows `Hash.Empty` values, making exploitation indistinguishable from legitimate behavior in edge cases (first round of term, new miners). Honest nodes cannot detect when a miner should have revealed their `InValue` but chose `Hash.Empty` instead.

**Execution Path:**
1. Miner produces block in round N with maliciously chosen `InValue`
2. In round N+1, miner produces block with `PreviousInValue = Hash.Empty`
3. Validation at line 46 returns `true` without hash verification
4. Block is accepted and state is updated with empty `PreviousInValue`
5. Miner successfully hides their random number generation method [10](#0-9) [11](#0-10) 

**Probability Assessment:**
HIGH likelihood - trivially exploitable by any miner with immediate effect on consensus randomness.

### Recommendation

**Primary Fix - Remove Hash.Empty Bypass:**

Modify `UpdateValueValidationProvider.ValidatePreviousInValue()` to require proper validation when a miner exists in the previous round with a non-null `OutValue`:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;

    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) 
        return true;

    var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
    
    // If miner produced a block in previous round, PreviousInValue must be provided and valid
    if (previousOutValue != null && previousOutValue != Hash.Empty)
    {
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        
        if (previousInValue == null || previousInValue == Hash.Empty)
            return false; // Reject empty values when miner has committed OutValue
            
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
    
    return true; // Allow empty for miners who didn't produce blocks
}
```

**Secondary Fix - Validate Other Miners' PreviousInValue:**

Add validation for `RevealedInValues` before accepting them:

```csharp
// In UpdateLatestSecretPieces or create new validation provider
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
    {
        var targetMiner = revealedInValue.Key;
        if (previousRound.RealTimeMinersInformation.ContainsKey(targetMiner))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[targetMiner].OutValue;
            if (expectedOutValue != null && expectedOutValue != Hash.Empty)
            {
                // Validate revealed value matches committed OutValue
                if (HashHelper.ComputeFrom(revealedInValue.Value) != expectedOutValue)
                    continue; // Skip invalid revealed values
            }
        }
        
        if (updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue == Hash.Empty ||
            updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue == null)
            updatedRound.RealTimeMinersInformation[targetMiner].PreviousInValue = revealedInValue.Value;
    }
}
```

**Invariant Checks:**
- For all miners with non-null `OutValue` in round N, `PreviousInValue` in round N+1 must satisfy `Hash(PreviousInValue) == OutValue`
- `PreviousInValue` can only be `Hash.Empty` or `null` for miners who didn't produce blocks or are in first round of term

**Test Cases:**
1. Test that miner with `OutValue` in previous round cannot provide `Hash.Empty` as `PreviousInValue`
2. Test that incorrect `PreviousInValue` is rejected when hash doesn't match `OutValue`
3. Test that `RevealedInValues` with incorrect hashes are rejected
4. Test that legitimate cases (first round, new miners) still work correctly

### Proof of Concept

**Initial State:**
- Round N: Miner A produces block with `OutValue = Hash(secretInValue)` where `secretInValue` was maliciously chosen
- `OutValue` is stored in state for Miner A in round N

**Attack Sequence:**

**Step 1:** In round N+1, Miner A generates consensus trigger information with `PreviousInValue = Hash.Empty` or provides incorrect value that fails self-check: [12](#0-11) 

**Step 2:** When self-check fails or no `PreviousInValue` provided, `previousInValue` is set to `Hash.Empty`: [13](#0-12) 

**Step 3:** Block is broadcast with `PreviousInValue = Hash.Empty` in consensus extra data

**Step 4:** Validation runs - `RecoverFromUpdateValue()` copies the empty value, then `UpdateValueValidationProvider` validates: [14](#0-13) 

**Step 5:** Validation returns `true` at line 46, skipping hash verification at line 48

**Expected Result:** Block should be rejected because Miner A must reveal their `InValue` from round N

**Actual Result:** Block is accepted, Miner A successfully hides how they generated their malicious `OutValue` in round N

**Success Condition:** Miner A avoids accountability for their random number generation, maintaining the ability to manipulate future consensus randomness without detection.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L18-18)
```csharp
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L28-29)
```csharp
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-80)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L38-38)
```csharp
        var publicKey = validationContext.SenderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L44-48)
```csharp
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L70-70)
```csharp
        var previousInValue = Hash.Empty; // Just initial previous in value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L74-90)
```csharp
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-194)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;
```
