# Audit Report

## Title
Evil Miners Can Produce Blocks During Transition Round Due to Missing Banned Status Validation

## Summary
The `MiningPermissionValidationProvider` performs insufficient validation by only checking if a miner's public key exists in `RealTimeMinersInformation.Keys`, without verifying whether the miner has been marked as evil in the Election Contract's `BannedPubkeyMap`. This creates a one-round timing gap where miners detected as evil can continue producing blocks and earning rewards throughout the next round before being replaced.

## Finding Description

The vulnerability stems from incomplete validation logic in the consensus block validation flow. When a block is validated before execution, the `MiningPermissionValidationProvider` only verifies membership in the current round's miner list: [1](#0-0) 

The critical timing gap occurs in the round transition sequence:

**Step 1 - Round Generation:** When transitioning from Round N to Round N+1, the next round is generated by calling `GenerateNextRoundInformation`, which queries the Election Contract for miners to replace: [2](#0-1) 

**Step 2 - Replacement Check:** The `GetMinerReplacementInformation` method identifies evil miners by checking which miners are already present in `BannedPubkeyMap`: [3](#0-2) 

**Step 3 - Detection (Too Late):** However, evil miner detection happens AFTER the new round is generated, during `ProcessNextRound` execution: [4](#0-3) 

The detection logic checks for excessive missed time slots: [5](#0-4) 

**Step 4 - Banning (Too Late for Current Round):** When evil miners are detected, they are marked in `BannedPubkeyMap` in the Election Contract: [6](#0-5) 

**The Timing Gap:** Because evil miner detection occurs AFTER Round N+1 is already generated with the evil miner included, and the validation provider only checks `RealTimeMinersInformation.Keys` without consulting `BannedPubkeyMap`, the evil miner can produce blocks throughout the entire Round N+1 despite being detected and banned.

## Impact Explanation

**Consensus Integrity Compromise:**
- Evil miners who have been detected for malicious behavior (excessive missed time slots) continue participating in consensus for an additional full round
- They continue receiving block production rewards and transaction fees during this extended period
- This undermines the intended punishment mechanism designed to immediately penalize and remove bad actors

**Economic Impact:**
- Evil miners receive a full round's worth of mining rewards despite being flagged for removal
- Legitimate replacement candidates lose one round of mining opportunities and associated rewards
- The delayed replacement extends the window during which consensus operates with known malicious participants

**Network Reliability:**
- Users and token holders experience degraded network reliability as evil miners continue producing blocks
- The consensus system's credibility is damaged when punishment mechanisms don't execute immediately upon detection

While the impact is temporary (limited to one round), a round can consist of hundreds of blocks on the main chain, representing significant reward misallocation and extended exposure to malicious behavior.

## Likelihood Explanation

**Automatic Triggering:** This vulnerability activates automatically whenever the consensus system's evil miner detection mechanism triggers. No attacker action is required - it's a design flaw in the validation sequence.

**Frequent Occurrence:** Evil miner detection is a core punishment mechanism of AEDPoS consensus. Any miner exceeding `TolerableMissedTimeSlotsCount` (typically due to network issues, hardware failures, or intentional disruption) will trigger this scenario.

**No Preconditions Required:**
- No special permissions needed
- No complex race conditions to exploit
- No state manipulation required
- Happens during normal consensus operations on the main chain

**Execution Path:** The vulnerability executes through the standard block validation flow (`ValidateConsensusBeforeExecution`), which is called before every block execution.

The likelihood is **HIGH** - this occurs in every instance where a miner is detected as evil, which is a regularly exercised code path in the consensus system.

## Recommendation

Modify the `MiningPermissionValidationProvider` to check the Election Contract's `BannedPubkeyMap` before allowing block production. The validation should reject blocks from miners who are banned, even if they appear in `RealTimeMinersInformation`.

**Option 1 - Enhance MiningPermissionValidationProvider:**
Pass the Election Contract reference through `ConsensusValidationContext` and add a banned status check:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
        return validationResult;
    }
    
    // NEW: Check if miner is banned
    if (validationContext.IsMinerBanned(validationContext.SenderPubkey))
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is banned.";
        return validationResult;
    }

    validationResult.Success = true;
    return validationResult;
}
```

**Option 2 - Add Pre-Validation Check:**
Add an explicit check in `ValidateBeforeExecution` that queries the Election Contract:

```csharp
// Before validation providers run
if (State.IsMainChain.Value && State.ElectionContract.Value != null)
{
    var isBanned = State.ElectionContract.GetBannedStatus.Call(new StringValue 
    { 
        Value = extraData.SenderPubkey.ToHex() 
    }).Value;
    
    if (isBanned)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "Miner is banned and cannot produce blocks." 
        };
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated through the following test sequence:

1. **Setup:** Create a test environment with multiple miners in Round N
2. **Trigger:** Have one miner miss time slots exceeding `TolerableMissedTimeSlotsCount`
3. **Round Transition:** Transition to Round N+1 (evil miner detection occurs but miner remains in Round N+1)
4. **Verify:** The evil miner can still produce blocks in Round N+1 (validation passes)
5. **Confirm:** Check that `BannedPubkeyMap[evilMiner] == true` but miner is in `RealTimeMinersInformation` for Round N+1
6. **Final Check:** Transition to Round N+2 to verify the evil miner is finally replaced

The test would validate that:
- `MiningPermissionValidationProvider.ValidateHeaderInformation` returns success for a banned miner if they're in `RealTimeMinersInformation`
- The evil miner can produce valid blocks during Round N+1 despite being in `BannedPubkeyMap`
- The evil miner receives rewards for Round N+1 blocks
- The evil miner is only removed in Round N+2

This demonstrates the one-round delay between detection and enforcement of the ban.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
