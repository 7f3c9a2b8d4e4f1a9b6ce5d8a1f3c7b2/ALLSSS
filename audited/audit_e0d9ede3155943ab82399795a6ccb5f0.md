# Audit Report

## Title
Secret Sharing Order Mismatch Vulnerability Allows Manipulation of Revealed In-Values

## Summary
The AEDPoS consensus secret sharing mechanism has a critical flaw where Shamir's Secret Sharing shares are encoded using Round N-1 Order values but decoded using Round N Order values. Since miners can manipulate their Order in Round N by selecting specific `previousInValue` inputs, this creates a mismatch in Lagrange interpolation x-coordinates, causing incorrect secret reconstruction and breaking consensus randomness guarantees.

## Finding Description

The vulnerability exists in the coordination between share creation and share reconstruction in the secret sharing protocol.

**Encoding Phase (Share Creation):**

When Round N is created, the `SecretSharingInformation` event fires with `PreviousRound` containing Round N-1 data. [1](#0-0) 

The off-chain `SecretSharingService` then creates Shamir secret shares using the Order values from Round N-1. [2](#0-1) 

The `EncodeSecret` function creates shares for x-coordinates 1 through totalParts, where share at index `(order-1)` corresponds to x-coordinate `order`. [3](#0-2) 

**Decoding Phase (Secret Reconstruction):**

When revealing secrets in Round N+1, the `RevealSharedInValues` function extracts Order values from `previousRound`, which references Round N (not Round N-1). [4](#0-3) 

These Round N Order values are then used as x-coordinates in Lagrange interpolation. [5](#0-4) 

**The Critical Mismatch:**

Order values in Round N are determined by `FinalOrderOfNextRound` from Round N-1. [6](#0-5) 

Miners control their `FinalOrderOfNextRound` by manipulating their signature value. The signature is calculated as `XOR(previousInValue, aggregate_of_signatures)`. [7](#0-6) 

The signature determines `SupposedOrderOfNextRound = (signature.ToInt64() % minersCount) + 1`, which becomes `FinalOrderOfNextRound`. [8](#0-7) 

By trying different `previousInValue` candidates before producing their block, a miner can find one that yields a desired signature and thus a desired Order for the next round.

**Missing Validation:**

The existing validation only checks that miners who produced blocks have `FinalOrderOfNextRound` set, not that these values are consistent with the secret sharing scheme. [9](#0-8) 

The Lagrange interpolation algorithm blindly uses whatever Order values are provided without verifying they match the encoding phase. [10](#0-9) 

## Impact Explanation

**Consensus Randomness Corruption:**
The revealed `InValue` is stored as `PreviousInValue` for miners and feeds into the consensus randomness generation. When the x-coordinates used in Lagrange interpolation don't match those used during share creation, the reconstructed polynomial (and thus the revealed InValue) will be mathematically incorrect.

**Attack Scenario:**
Consider 3 miners with Round N-1: Alice (Order=1), Bob (Order=2), Charlie (Order=3).
- Alice creates shares: s₁ for x=1 → Alice, s₂ for x=2 → Bob, s₃ for x=3 → Charlie
- Bob manipulates his signature to achieve Order=3 in Round N
- Charlie gets reassigned to Order=2 due to conflict resolution
- During reconstruction: Alice's share used at x=1 ✓, Bob's share at x=3 ✗ (should be x=2), Charlie's share at x=2 ✗ (should be x=3)
- Result: Wrong secret reconstructed

**Cascading Effects:**
- Corrupted randomness affects extra block producer selection
- Block production scheduling becomes predictable
- Coordinated miners can exploit this for economic advantage
- Breaks the fundamental security assumption of unpredictable consensus randomness

This is HIGH severity because it compromises a core security property of the consensus layer that all blockchain security depends upon.

## Likelihood Explanation

**Attack Feasibility:**
Any active miner can execute this attack with modest computational resources:

1. **Low Computational Cost:** The attacker only needs to hash different `previousInValue` candidates until finding one that produces the desired order. With only `minersCount` possible order values (typically 17-21 miners), this requires testing on average `minersCount/2` candidates.

2. **No Special Privileges:** The attack uses normal `UpdateValue` transactions. [11](#0-10) 

3. **Undetectable:** The chosen `previousInValue` appears valid since its hash matches the committed `OutValue` from the previous round. [12](#0-11) 

4. **Economic Incentive:** Manipulating consensus randomness can provide advantages in block scheduling and rewards, making rational miners likely to exploit this.

The likelihood is HIGH because the attack is technically simple, economically incentivized, and cannot be prevented by current validation mechanisms.

## Recommendation

**Fix:** Ensure Order values remain consistent between encoding and decoding by using a canonical round reference for both phases.

**Option 1 - Use Encoding Round for Decoding:**
Modify `RevealSharedInValues` to extract orders from the same round that was used for encoding (two rounds back instead of one).

**Option 2 - Encode Using Next Round Orders:**
Store `FinalOrderOfNextRound` values at the time of encoding and use those same values during decoding, rather than looking up current Order values.

**Option 3 - Validate Order Consistency:**
Add validation that checks if any miner's Order changed between the encoding and decoding rounds, and reject secret reconstruction if Order values are inconsistent.

**Recommended Implementation (Option 1):**
In `RevealSharedInValues`, change the order extraction logic to look up miners' Orders from two rounds back (the round that was used for encoding), not from the previous round.

## Proof of Concept

A proof of concept would require:

1. **Setup:** Deploy test consensus contract with 3 miners in Round N-1 with Orders: Alice=1, Bob=2, Charlie=3
2. **Manipulation:** Have Bob produce a block in Round N-1, trying different `previousInValue` values until finding one where `signature = XOR(previousInValue, aggregate)` produces `(signature % 3) + 1 = 3`
3. **Round Transition:** Transition to Round N where Bob's Order becomes 3, Charlie's becomes 2
4. **Verification:** In Round N+1, call `RevealSharedInValues` and observe that the reconstructed InValue for Alice differs from the actual InValue she used, proving the interpolation used wrong x-coordinates

The test would demonstrate that Lagrange interpolation with points (1,s₁), (3,s₂), (2,s₃) produces a different result than the original secret used to create shares at (1,s₁), (2,s₂), (3,s₃).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L110-115)
```csharp
            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L106-115)
```csharp
        foreach (var pair in secretSharingInformation.PreviousRound.RealTimeMinersInformation
                     .OrderBy(m => m.Value.Order).ToDictionary(m => m.Key, m => m.Value.Order))
        {
            var pubkey = pair.Key;
            var order = pair.Value;

            var plainMessage = secretShares[order - 1];
            var receiverPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);
            var encryptedPiece = await _accountService.EncryptMessageAsync(receiverPublicKey, plainMessage);
            encryptedPieces[pubkey] = encryptedPiece;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L28-38)
```csharp
            for (var i = 1; i < totalParts + 1; i++)
            {
                var secretBigInteger = coefficients[0];
                for (var j = 1; j < threshold; j++)
                {
                    secretBigInteger += coefficients[j] * BigInteger.Pow(new BigInteger(i), j);
                    secretBigInteger %= SecretSharingConsts.FieldPrime;
                }

                result.Add(secretBigInteger.ToByteArray());
            }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L52-58)
```csharp
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-44)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-44)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-48)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```
