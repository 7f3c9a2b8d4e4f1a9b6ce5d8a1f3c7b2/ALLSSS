### Title
Secret Sharing Order Mismatch Vulnerability Allows Manipulation of Revealed In-Values

### Summary
The secret sharing mechanism uses inconsistent Order values for encoding versus decoding shares, creating a critical vulnerability in the consensus randomness generation. Shares are created using Round N-1 Order values but decoded using Round N Order values, which can differ because miners can manipulate their FinalOrderOfNextRound during Round N-1. This mismatch in Lagrange interpolation coordinates causes incorrect secret reconstruction, breaking the consensus protocol's randomness guarantees.

### Finding Description

**Root Cause:**

The vulnerability stems from a fundamental mismatch in the x-coordinates used for Shamir's Secret Sharing between encoding and decoding phases:

**Encoding Phase (Round N creation):**
When Round N is created, the `SecretSharingInformation` event is fired with `PreviousRound` containing Round N-1 data. [1](#0-0) 

The off-chain `SecretSharingService` creates shares using Order values from Round N-1: [2](#0-1) 

Each share at position `order-1` is assigned to the miner whose Order in Round N-1 equals `order`. The shares are created for x-coordinates corresponding to Round N-1 Order values.

**Decoding Phase (Round N+1):**
When revealing secrets in Round N+1, the `RevealSharedInValues` function extracts Order values from `previousRound` (which is Round N): [3](#0-2) 

These Order values from Round N are used as x-coordinates in the Lagrange interpolation: [4](#0-3) 

**The Mismatch:**
Order values in Round N are determined by `FinalOrderOfNextRound` from Round N-1, NOT by Round N-1's Order values: [5](#0-4) 

Miners can manipulate their `FinalOrderOfNextRound` by controlling their signature value, which is derived from their chosen `previousInValue`. The signature determines `SupposedOrderOfNextRound`, which initializes `FinalOrderOfNextRound`: [6](#0-5) 

**Why Existing Protections Fail:**
There is no validation that Order values remain consistent between encoding and decoding. The Lagrange interpolation algorithm blindly uses whatever Order values are provided: [7](#0-6) 

The algorithm performs modular arithmetic with the provided orders as x-coordinates (line 57), with no awareness that these coordinates may be incorrect for the given shares.

### Impact Explanation

**Consensus Integrity Breakdown:**
The revealed InValue is used for random number generation in the AEDPoS consensus protocol. An incorrect revealed InValue means:
1. The consensus randomness is corrupted
2. Future block producer selection may be manipulated
3. Extra block producer assignment becomes predictable
4. The cryptographic guarantees of the consensus protocol are violated

**Concrete Attack Scenario:**
Consider 3 miners with Round N-1 orders: Alice=1, Bob=2, Charlie=3.
- Shares are created: s₁→Alice (x=1), s₂→Bob (x=2), s₃→Charlie (x=3)
- Bob manipulates his signature to swap orders in Round N: Alice=1, Bob=3, Charlie=2
- Decoding uses: Alice's share at x=1 (correct), Bob's share at x=3 (WRONG, should be x=2), Charlie's share at x=2 (WRONG, should be x=3)
- Lagrange interpolation with points (1,s₁), (3,s₂), (2,s₃) produces an incorrect secret

**Quantified Impact:**
- All revealed InValues during the attack period will be incorrect
- Affects every round where a miner successfully manipulates their Order
- Breaks the unpredictability guarantee essential for consensus security
- Could allow coordinated miners to gain unfair advantages in block production scheduling

**Severity Justification:**
This is HIGH severity because it directly compromises the consensus layer's cryptographic randomness, which is fundamental to the security of the entire blockchain. The manipulated randomness can cascade into economic advantages through controlled block production.

### Likelihood Explanation

**Attacker Capabilities Required:**
A single malicious miner can execute this attack by:
1. Computing different `previousInValue` candidates
2. Calculating the resulting signature for each: signature = XOR(previousInValue, aggregate of previous round signatures) [8](#0-7) 
3. Selecting a `previousInValue` that produces a desired `SupposedOrderOfNextRound`
4. Submitting this in their UpdateValue transaction

**Attack Complexity:**
- Low: Requires only brute-forcing hash values, which is computationally feasible
- The search space is limited to `minersCount` possible order values
- Modern hardware can test millions of candidates per second
- No special privileges required beyond being a miner

**Feasibility Conditions:**
- Attacker must be a current miner (publicly reachable)
- Normal UpdateValue transaction flow is used [9](#0-8) 
- The signature and order updates are processed through standard consensus paths
- No special timing or coordination required for a single attacker

**Detection Constraints:**
- The attack appears as normal consensus operation
- Order adjustments are a legitimate feature for conflict resolution
- No on-chain validation can detect that the InValue was chosen to manipulate Order
- The incorrect revealed secret cannot be distinguished from a correct one without external verification

**Probability Assessment:**
HIGH - Any rational miner can execute this attack with minimal effort and cost. The benefits (predictable randomness, advantageous block scheduling) outweigh the computational cost of finding a suitable previousInValue.

### Recommendation

**Immediate Fix:**
Use consistent Order values for both encoding and decoding. Specifically, modify the secret sharing to use `FinalOrderOfNextRound` from the current round (which will become Order in the next round) instead of current round Order values:

In `SecretSharingService.CollectPiecesWithSecretSharingAsync`, change the share distribution to use:
```
secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound
```
instead of:
```
secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].Order
```

This ensures shares are created using the same x-coordinates that will be used for decoding.

**Invariant Check to Add:**
Before performing Lagrange interpolation in `RevealSharedInValues`, validate that the Order values being used match the Order values that were used during share creation. This could be achieved by:
1. Storing a hash of the Order mapping when shares are created
2. Verifying this hash before decoding
3. Rejecting revelation if the Order mapping has changed

**Alternative Mitigation:**
Store the original Order values (from the encoding round) alongside the encrypted shares, and use those stored values for decoding instead of looking up current Order values.

**Test Cases to Add:**
1. Test that reveals correct InValue when all miners maintain their Order
2. Test that reveals correct InValue even when miners change Order between rounds
3. Test that detection mechanism catches Order manipulation attempts
4. Integration test simulating a malicious miner manipulating their signature to change Order

### Proof of Concept

**Required Initial State:**
- 3 active miners: Alice, Bob, Charlie
- Round N-1 with Order assignments: Alice=1, Bob=2, Charlie=3
- Secret sharing enabled in configuration

**Attack Sequence:**

**Step 1 - Round N-1:** 
Alice creates InValue and shares are distributed:
- EncodeSecret creates shares: [s₁, s₂, s₃] for x-coordinates [1, 2, 3]
- Share s₁ encrypted for Alice (Order=1)
- Share s₂ encrypted for Bob (Order=2)  
- Share s₃ encrypted for Charlie (Order=3)

**Step 2 - Round N-1 (Bob's manipulation):**
Bob computes multiple previousInValue candidates until finding one where:
- signature = XOR(previousInValue, aggregate_signatures)
- signature mod 3 + 1 = 3 (to get Order=3 in next round)

Bob submits UpdateValue with this crafted previousInValue, setting his FinalOrderOfNextRound=3.

**Step 3 - Round N generation:**
GenerateNextRoundInformation assigns:
- Alice: Order=1 (from her FinalOrderOfNextRound=1)
- Bob: Order=3 (from his manipulated FinalOrderOfNextRound=3)
- Charlie: Order=2 (reassigned to available slot)

**Step 4 - Round N+1 (Revelation):**
RevealSharedInValues attempts to decode Alice's InValue:
- Extracts orders from Round N: Alice→1, Bob→3, Charlie→2
- Decodes using DecodeSecret with orders=[1, 3, 2] and shares=[s₁, s₂, s₃]
- Lagrange interpolation computes: L(0) with points (1,s₁), (3,s₂), (2,s₃)

**Expected vs Actual Result:**
- **Expected:** InValue revealed correctly using correct x-coordinates [1, 2, 3]
- **Actual:** Incorrect InValue computed due to wrong x-coordinates [1, 3, 2]
- **Verification:** Hash of decoded secret ≠ original InValue hash

**Success Condition:**
The revealed InValue (line 49-50) differs from the actual InValue that Alice used, demonstrating that Order manipulation corrupted the Lagrange interpolation and broke the secret sharing scheme.

### Notes

This vulnerability is particularly insidious because:
1. Order changes appear legitimate due to the conflict resolution mechanism
2. The attack requires no collusion - a single miner can manipulate their own Order
3. The impact compounds over time as incorrect randomness affects future rounds
4. Detection is extremely difficult without external verification of the correct InValues

The root cause is the temporal separation between share creation (using Round N-1 Orders) and share decoding (using Round N Orders), combined with the ability of miners to influence their Order transition through signature manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L110-115)
```csharp
            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L106-112)
```csharp
        foreach (var pair in secretSharingInformation.PreviousRound.RealTimeMinersInformation
                     .OrderBy(m => m.Value.Order).ToDictionary(m => m.Key, m => m.Value.Order))
        {
            var pubkey = pair.Key;
            var order = pair.Value;

            var plainMessage = secretShares[order - 1];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-44)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-44)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```
