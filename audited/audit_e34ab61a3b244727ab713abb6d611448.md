### Title
Integer Truncation in Bancor Pricing Allows Free Token Acquisition

### Summary
The `GetAmountToPayFromReturn` function in BancorHelper.cs truncates decimal calculation results to `long`, causing amounts less than 1 to become 0. The `Buy` function does not validate that `amountToPay > 0` before executing transfers, allowing attackers to acquire resource tokens for free by requesting small amounts that result in zero cost after truncation.

### Finding Description

The root cause is in [1](#0-0) 

The function calculates the cost to acquire a specified amount of tokens using Bancor formulas, but casts the decimal result directly to `long` without rounding or minimum value checks.

**For equal weights case:** [2](#0-1) 

The formula `(bf / (bt - a)) * a` produces values less than 1 when:
- `a < bt / (bf + 1)`

**For different weights case:** [3](#0-2) 

The formula `bf * (Exp(y * Ln(x)) - 1)` similarly produces values less than 1 for small amounts relative to balances.

When the decimal result is between 0 and 1 (exclusive), the `(long)` cast truncates it to 0.

The `Buy` function fails to protect against this: [4](#0-3) 

There is no check that `amountToPay > 0`. The only validation is the PayLimit check, which passes when `amountToPay = 0`.

The exploit executes as follows: [5](#0-4) 

When `amountToPay = 0`, the user transfers 0 base tokens but receives the full requested `input.Amount` of resource tokens.

### Impact Explanation

**Direct Fund Impact - Critical:**
- Attackers can drain all resource tokens from TokenConverter reserves by repeatedly calling Buy with small amounts
- Each call acquires tokens worth market value for zero cost
- No fee is charged since fee = `amountToPay * feeRate = 0`
- Total loss equals entire reserve balance of affected token pairs

**Concrete Example:**
- Connector pair: 10,000 ELF deposit ↔ 1,000,000 RESOURCE tokens (equal weights 0.5)
- Attack: Buy 50 RESOURCE tokens
- Calculation: `(10000 / 999950) * 50 = 0.50...` → truncates to 0
- Result: Acquire 50 RESOURCE for 0 ELF
- Repeat 20,000 times to drain entire 1,000,000 reserve

**Affected parties:**
- All users who deposited base tokens as connector reserves
- Protocol treasury (loses fee revenue)
- Token economics integrity (resource tokens distributed without corresponding base token backing)

### Likelihood Explanation

**Reachable Entry Point:** [6](#0-5) 
The `Buy` function is publicly accessible and requires only that the connector is purchase-enabled.

**Feasible Preconditions:**
1. Connector must be enabled (normal operational state)
2. Attacker needs approval to transfer 0 tokens (automatically satisfied)
3. No special permissions required

**Execution Practicality:**
- Single transaction per exploit iteration
- Gas cost minimal (only state reads and 0-value transfers)
- Deterministic: mathematical conditions are trivially calculable off-chain
- Scalable: can drain reserves through batch transactions

**Attack Complexity: Low**
- Calculate threshold: `a < toConnectorBalance / (fromConnectorBalance + 1)`
- Submit Buy transactions below threshold
- Automated exploitation straightforward

**Detection Constraints:**
- 0-value transfers may appear suspicious but are not explicitly blocked
- Event emission shows `base_amount = 0` but `bought_amount > 0`
- Could be detected by monitoring but damage occurs before intervention

**Economic Rationality:**
- Zero cost attack (only gas fees)
- Profit = market value of acquired tokens
- Risk = none (transaction reverts or succeeds, no loss scenario)

### Recommendation

**Immediate Fix:**
Add minimum payment validation in BancorHelper.cs after line 93 and line 84:

```csharp
// After line 84 (equal weights case)
var result = (long)(bf / (bt - a) * a);
if (result <= 0)
    throw new InvalidValueException("Amount too small, cost rounds to zero.");
return result;

// After line 93 (different weights case)  
var result = (long)(bf * (Exp(y * Ln(x)) - decimal.One));
if (result <= 0)
    throw new InvalidValueException("Amount too small, cost rounds to zero.");
return result;
```

**Alternative Fix:**
Implement proper rounding in the Buy function at line 127:

```csharp
var amountToPay = BancorHelper.GetAmountToPayFromReturn(...);
Assert(amountToPay > 0, "Purchase amount too small, resulting cost is zero.");
```

**Invariant to Enforce:**
For all Buy operations: `amountToPay > 0 AND amountToPay >= minimumCost` where minimumCost prevents economically irrational micro-purchases.

**Test Cases:**
1. Attempt to buy 1 token when `fromBalance = 1000, toBalance = 1000000`
2. Attempt to buy amount where formula result is 0.1, 0.5, 0.9
3. Verify all attempts revert with appropriate error
4. Boundary test: buy exactly at threshold where cost = 1

### Proof of Concept

**Initial State:**
- Connector pair established and enabled
- fromConnector (base token deposit): balance = 10,000 ELF, weight = 0.5
- toConnector (resource token): balance = 1,000,000 RESOURCE, weight = 0.5
- Attacker has 0 ELF balance (only needs gas)

**Exploitation Steps:**

1. **Calculate exploit threshold:**
   - Threshold = `toBalance / (fromBalance + 1) = 1,000,000 / 10,001 ≈ 99.99`
   - Choose amount: 50 RESOURCE tokens (well below threshold)

2. **Call Buy function:**
   ```
   Buy({
     symbol: "RESOURCE",
     amount: 50,
     pay_limit: 0  // No limit
   })
   ```

3. **Internal execution:**
   - `GetAmountToPayFromReturn(10000, 0.5, 1000000, 0.5, 50)` called
   - Formula: `(10000 / (1000000 - 50)) * 50 = (10000 / 999950) * 50`
   - Result: `500000 / 999950 = 0.500025...`
   - Cast: `(long)(0.500025) = 0`
   - `amountToPay = 0`

4. **Token transfers:**
   - Transfer 0 ELF from attacker to contract ✓
   - Transfer 50 RESOURCE from contract to attacker ✓

**Expected vs Actual:**
- **Expected:** Buy reverts or requires payment ≥ 1 ELF
- **Actual:** Buy succeeds with 0 ELF payment, attacker receives 50 RESOURCE

**Success Condition:**
- Attacker RESOURCE balance increases by 50
- Attacker ELF balance unchanged (minus gas)
- Contract RESOURCE reserve decreases by 50
- No corresponding increase in base token reserves

**Repeatable:** Execute 20,000 times to drain entire 1,000,000 RESOURCE reserve for zero cost.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```
