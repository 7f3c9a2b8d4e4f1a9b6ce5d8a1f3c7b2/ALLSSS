### Title
Unvalidated Extra Block Producer Invariant Enables Consensus DoS via Single() Exception

### Summary
The `IsCurrentMiner` function uses `.Single()` to retrieve the extra block producer from the current round, which throws an `InvalidOperationException` if zero or multiple miners have `IsExtraBlockProducer=true`. Byzantine miners can submit `NextRoundInput` or `NextTermInput` with corrupted round data violating this invariant, as no validation enforces exactly one extra block producer exists. This causes denial of service in consensus operations and cross-chain indexing.

### Finding Description

The vulnerability exists at the intersection of round data submission and mining permission validation:

**Root Cause Location:** [1](#0-0) 

The `IsCurrentMiner` function uses `.Single()` which enforces exactly one match. This will throw if the predicate matches zero or multiple elements.

**Attack Vector - Unvalidated Round Submission:**

Miners submit consensus updates via `NextRound` and `NextTerm` methods: [2](#0-1) [3](#0-2) 

The input is converted via `ToRound()` without validation: [4](#0-3) 

**Missing Validation:**

The validation providers check round number, term number, mining order, and time slots, but NOT the extra block producer invariant: [5](#0-4) 

None of the validation providers enforce exactly one extra block producer: [6](#0-5) [7](#0-6) 

**Normal Round Generation (for comparison):**

During legitimate round generation, exactly one miner is always assigned as extra block producer: [8](#0-7) 

However, this logic is bypassed when miners provide their own round data through the attack vector.

### Impact Explanation

**Operational DoS - Consensus and Cross-Chain:**

1. **Cross-Chain Indexing Blocked**: The `IsCurrentMiner` check gates critical cross-chain operations: [9](#0-8) [10](#0-9) [11](#0-10) 

When `IsCurrentMiner` throws, miners cannot propose or release cross-chain indexing data, halting parent-child chain communication.

2. **Mining Permission Validation Fails**: The function is used to validate mining time slots, particularly for extra block production. If it throws during extra block time slot validation, the entire mining permission check fails.

3. **Related Operations Blocked**: The `GetExtraBlockProducerInformation` helper also uses `.First()` which throws on empty sequences: [12](#0-11) 

**Severity Justification**: HIGH - Complete disruption of consensus operations and cross-chain functionality until malicious round data ages out or governance intervention occurs.

### Likelihood Explanation

**Attacker Capabilities:**
Only current miners can call `NextRound` or `NextTerm` due to the permission check: [13](#0-12) 

This requires a byzantine miner, but such miners exist in realistic threat models for consensus systems.

**Attack Complexity:** TRIVIAL
1. Construct `NextRoundInput` with `RealTimeMinersInformation` where zero or multiple miners have `IsExtraBlockProducer = true`
2. Submit via `NextRound` transaction when it's the attacker's mining turn
3. The corrupted round passes all validation and gets stored
4. Subsequent `IsCurrentMiner` calls throw exceptions

**Feasibility Conditions:**
- Attacker must be an active miner (controlled precondition)
- Must wait for their scheduled mining turn (timing constraint)
- The attack is immediately visible and traceable to the malicious miner

**Detection/Operational Constraints:**
The attack would be immediately detected as it breaks consensus operations. The malicious miner could be identified from block data and potentially slashed. However, the damage (DoS) occurs before remediation is possible.

**Probability Assessment:** MEDIUM - While requiring a byzantine miner (reducing likelihood), the technical execution is trivial and the validation gap is definitive. The attack is economically irrational for long-term miners but feasible for compromised nodes or attackers willing to sacrifice miner stake for temporary disruption.

### Recommendation

**1. Add Extra Block Producer Validation:**

Add a new validation provider that enforces exactly one extra block producer:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedRound = validationContext.ExtraData.Round;
        var extraBlockProducerCount = providedRound.RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
        
        if (extraBlockProducerCount != 1)
            return new ValidationResult 
            { 
                Message = $"Invalid extra block producer count: {extraBlockProducerCount}. Expected exactly 1." 
            };
        
        return new ValidationResult { Success = true };
    }
}
```

Register this provider in the validation pipeline: [14](#0-13) 

**2. Defensive Coding in IsCurrentMiner:**

Replace `.Single()` with safe retrieval and explicit validation:

```csharp
// Line 169-170
var extraBlockProducers = currentRound.RealTimeMinersInformation
    .Where(m => m.Value.IsExtraBlockProducer).ToList();
Assert(extraBlockProducers.Count == 1, 
    "State corruption: Invalid extra block producer count");
var supposedExtraBlockProducer = extraBlockProducers[0].Key;
```

**3. Add FirstRound Input Validation:**

Even though `FirstRound` is called during genesis, validate the input: [15](#0-14) 

Add validation after line 77 to ensure exactly one extra block producer exists in the genesis round.

**4. Test Cases:**

Add regression tests that attempt to submit rounds with:
- Zero extra block producers
- Multiple extra block producers
- Verify validation rejects these and prevents state corruption

### Proof of Concept

**Initial State:**
- Byzantine miner is in the active miner list for the current term
- Current round number is N

**Attack Sequence:**

**Step 1**: Byzantine miner waits for their scheduled mining turn

**Step 2**: Byzantine miner constructs malicious `NextRoundInput`:
```
NextRoundInput {
  RoundNumber: N+1,
  RealTimeMinersInformation: {
    "miner1": { IsExtraBlockProducer: true, ... },
    "miner2": { IsExtraBlockProducer: true, ... },  // INVALID: Multiple
    "miner3": { IsExtraBlockProducer: false, ... }
  },
  // ... other valid fields
}
```

**Step 3**: Byzantine miner submits `NextRound(maliciousInput)` transaction

**Expected Result**: Transaction should be rejected due to invalid extra block producer count

**Actual Result**: Transaction succeeds because no validation checks the extra block producer invariant. The corrupted round is stored in `State.Rounds[N+1]`.

**Step 4**: Any miner or cross-chain operation calls `IsCurrentMiner()` during round N+1

**Expected Result**: Function returns true/false based on mining permission

**Actual Result**: Function throws `InvalidOperationException` at `.Single()` call because two miners have `IsExtraBlockProducer=true`, causing transaction failure and operational DoS.

**Success Condition**: Round N+1 is stored with multiple miners having `IsExtraBlockProducer=true`, and subsequent `IsCurrentMiner()` calls fail with exceptions, blocking consensus and cross-chain operations.

### Notes

This vulnerability demonstrates a gap between the system's invariant assumptions (exactly one extra block producer per round) and the actual validation enforcement. While the legitimate round generation code maintains this invariant correctly, the lack of validation on externally-provided round data from miners creates an attack surface.

The `.Single()` LINQ method is appropriate when the invariant is guaranteed, but becomes a liability when state can be corrupted through unvalidated input paths. The fix requires both preventing the corruption (validation) and handling potential corruption defensively (explicit assertions).

The attack requires a byzantine miner but is otherwise trivial to execute, making the likelihood assessment MEDIUM rather than LOW. The HIGH impact (complete DoS of consensus and cross-chain operations) combined with MEDIUM likelihood results in a HIGH severity finding.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L62-92)
```csharp
        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-290)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-301)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```
