# Audit Report

## Title
NFT Protocol Creation Accepts Empty Address Values Leading to Permanent Protocol Bricking

## Summary
The NFT contract's `Create` method fails to validate that `input.Creator` has a non-empty `Address.Value` field before using it as the token issuer. Combined with insufficient validation in the MultiToken contract's `RegisterTokenInfo` method, this allows creation of NFT protocols with invalid issuer addresses (empty byte values), permanently bricking the protocol as no one can mint NFTs or manage the minter list.

## Finding Description

The vulnerability exists in the NFT creation flow across two contracts:

**NFT Contract - Insufficient Creator Validation:**

The `Create` method uses a null-coalescing operator to set the creator without validating the `Address.Value` field. [1](#0-0)  This only checks if `input.Creator` is null, but does not validate whether the Address object has an empty `Value` field (ByteString). If a caller passes `new Address()` or `new Address { Value = ByteString.Empty }`, this is a non-null Address object that bypasses the null check, resulting in `creator` being set to an invalid empty-value address.

This invalid creator is then passed to the MultiToken contract as the `Issuer`. [2](#0-1) 

**MultiToken Contract - Incomplete RegisterTokenInfo Validation:**

The `RegisterTokenInfo` method only validates that the issuer is not null, [3](#0-2)  but does not check if the `Address.Value` field is empty. This is inconsistent with the proper validation pattern used elsewhere in the same contract, such as in `ModifyTokenIssuerAndOwner` which correctly validates both conditions. [4](#0-3) 

**Protocol Becomes Permanently Unusable:**

Once created with an empty-value issuer, the protocol cannot be used:

1. **Minting Fails**: The `GetMinterList` helper adds the empty-value issuer to the minter list, [5](#0-4)  but the minting permission check fails because `Context.Sender` (a valid address) will never equal the empty-value address. [6](#0-5) 

2. **Minter Management Fails**: The `AddMinters` and `RemoveMinters` methods require the caller to equal the protocol creator, [7](#0-6)  which will always fail for any real sender when the creator has an empty value.

## Impact Explanation

**Severity: High/Critical**

This vulnerability enables permanent denial-of-service attacks against NFT protocol functionality:

1. **Complete Protocol Bricking**: Any NFT protocol created with an empty-value creator becomes permanently unusable - no NFTs can ever be minted, and the minter list cannot be modified.

2. **Economic Damage**: 
   - Attackers can intentionally brick protocols, wasting the creation fees/costs paid by legitimate users
   - If the attacker front-runs a legitimate NFT protocol creation, the intended creator loses their fees and must create under a different symbol

3. **Griefing Attack Vector**: Malicious actors can systematically brick popular NFT symbol names or types, causing operational disruption and user frustration.

4. **No Recovery Mechanism**: Unlike some protocol configuration issues that can be fixed through governance, there is no mechanism to recover from this state. The protocol creator address is immutably stored and cannot be changed through any existing method.

## Likelihood Explanation

**Probability: High**

This vulnerability is highly exploitable:

1. **Reachable Entry Point**: The `Create` method is a public function callable by any user who can pay the creation fee or hold a seed NFT.

2. **Low Attack Complexity**: Exploitation requires only sending a `CreateInput` message with `Creator = new Address { Value = ByteString.Empty }` (an Address object with empty Value). This is trivial to construct in any AElf transaction.

3. **No Special Permissions Required**: Any user can call the Create method - the only barrier is passing the seed NFT check or being in the create whitelist, which is necessary for any protocol creation anyway.

4. **Low Attack Cost**: The cost is merely the NFT creation fee/seed NFT, making griefing attacks economically viable.

5. **Undetectable Until Too Late**: The protocol appears to be created successfully - the vulnerability only manifests when users attempt to mint or manage minters, at which point the damage is already done.

## Recommendation

Add proper validation for the `Address.Value` field in both the NFT contract and MultiToken contract:

**In NFTContract_Create.cs:**
```csharp
var creator = input.Creator ?? Context.Sender;
Assert(creator != null && !creator.Value.IsNullOrEmpty(), "Invalid creator address.");
```

**In TokenContract_Helper.cs RegisterTokenInfo method:**
```csharp
Assert(tokenInfo.Issuer != null && !tokenInfo.Issuer.Value.IsNullOrEmpty(), "Invalid issuer address.");
Assert(tokenInfo.Owner != null && !tokenInfo.Owner.Value.IsNullOrEmpty(), "Invalid owner address.");
```

This follows the existing validation pattern already used in `ModifyTokenIssuerAndOwner`. [4](#0-3) 

## Proof of Concept

```csharp
[Fact]
public async Task CreateNFTWithEmptyCreator_ShouldBrickProtocol()
{
    // Arrange: Prepare create input with empty-value creator address
    var emptyCreatorAddress = new Address { Value = ByteString.Empty };
    var createInput = new CreateInput
    {
        NftType = "Art",
        ProtocolName = "BrickedNFT",
        TotalSupply = 1000,
        Creator = emptyCreatorAddress,  // Empty value address
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF"),
        BaseUri = "https://example.com/",
        IsTokenIdReuse = false
    };
    
    // Act: Create protocol - this should succeed despite invalid creator
    var result = await NFTContractStub.Create.SendAsync(createInput);
    var symbol = result.Output.Value;
    
    // Verify protocol was created
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    Assert.NotNull(protocolInfo);
    Assert.True(protocolInfo.Creator.Value.IsNullOrEmpty()); // Creator has empty value
    
    // Assert: Minting fails - Context.Sender can never equal empty-value address
    var mintInput = new MintInput
    {
        Symbol = symbol,
        Alias = "NFT1",
        TokenId = 1,
        Uri = "https://example.com/1"
    };
    
    var exception = await Assert.ThrowsAsync<AssertionException>(
        async () => await NFTContractStub.Mint.SendAsync(mintInput)
    );
    Assert.Contains("No permission to mint", exception.Message);
    
    // Assert: AddMinters also fails - Context.Sender can never equal empty-value creator
    var addMintersInput = new AddMintersInput
    {
        Symbol = symbol,
        MinterList = new MinterList { Value = { DefaultSender } }
    };
    
    var addException = await Assert.ThrowsAsync<AssertionException>(
        async () => await NFTContractStub.AddMinters.SendAsync(addMintersInput)
    );
    Assert.Contains("No permission", addException.Message);
    
    // Protocol is permanently bricked - no way to mint or manage minters
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L27-27)
```csharp
            Issuer = creator,
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L230-230)
```csharp
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L646-647)
```csharp
        Assert(input.Issuer != null && !input.Issuer.Value.IsNullOrEmpty(), "Invalid input issuer.");
        Assert(input.Owner != null && !input.Owner.Value.IsNullOrEmpty(), "Invalid input owner.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L338-338)
```csharp
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
