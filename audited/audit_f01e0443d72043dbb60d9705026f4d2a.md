### Title
Miner List Change Flag Manipulation Bypasses Consensus Validation

### Summary
The `ValidateConsensusAfterExecution` method uses the `IsMinerListJustChanged` flag to determine hash comparison parameters, but for NextRound/NextTerm behaviors, it compares the stored round against itself, creating a tautological validation. An attacker can set `IsMinerListJustChanged = true` when no miner list change occurred, bypassing secret sharing mechanisms and PreviousInValue validation, potentially compromising consensus randomness and fairness.

### Finding Description

The vulnerability exists in the consensus validation logic where the `IsMinerListJustChanged` flag controls whether `PreviousInValue` is included in hash comparisons. [1](#0-0) 

For NextRound and NextTerm behaviors, unlike UpdateValue and TinyBlock, there is no recovery step that reconstructs the round from the base state: [2](#0-1) 

During `ProcessNextRound`, the input round is converted and stored directly without modification: [3](#0-2) [4](#0-3) 

The `AddRoundInformation` method stores the round as-is: [5](#0-4) 

When `ValidateConsensusAfterExecution` runs, it retrieves this same round from state and compares it against the header round (which is identical). Since both have the same `IsMinerListJustChanged` value, the validation passes regardless of whether the flag is correct.

The miner replacement validation at lines 103-123 only executes when hashes don't match, which won't occur if the attacker sets both rounds identically: [6](#0-5) 

**Root Cause:** There is no validation that verifies whether the miner list actually changed when `IsMinerListJustChanged = true`, or remained the same when it's `false`. The validation compares the round against itself rather than checking against the previous round's miner list.

### Impact Explanation

**Secret Sharing Bypass:**
When `IsMinerListJustChanged = true` is set falsely, the `SecretSharingInformation` event is not fired: [7](#0-6) 

This bypasses the secret sharing mechanism critical for distributed random number generation in the consensus protocol, weakening the cryptographic randomness guarantees.

**PreviousInValue Manipulation:**
The attacker can set `PreviousInValue = Hash.Empty` for all miners without validation. The `GetHash` method excludes `PreviousInValue` when `IsMinerListJustChanged = true`: [8](#0-7) 

`PreviousInValue` is used in signature calculations that determine the extra block producer: [9](#0-8) [10](#0-9) 

**Affected Parties:**
- All network participants: Compromised consensus randomness affects extra block producer selection fairness
- Future rounds: Corrupted round state propagates to subsequent rounds
- Validators: Cannot detect or reject invalid `IsMinerListJustChanged` claims

**Severity:** High - compromises consensus integrity through manipulation of cryptographic randomness and secret sharing mechanisms.

### Likelihood Explanation

**Attacker Capabilities:**
An attacker must be a valid miner in the current round with an assigned time slot for producing blocks. This is a reasonable precondition on any active blockchain network.

**Attack Complexity:**
The attack is straightforward:
1. When it's the attacker's turn to produce a NextRound block, instead of calling the contract's `GetConsensusExtraData`, they craft the consensus extra data locally
2. They compute the correct next round using `GenerateNextRoundInformation` 
3. They manually set `IsMinerListJustChanged = true` (when it should be false)
4. They set `PreviousInValue = Hash.Empty` for all miners
5. The crafted round passes all validation checks

**Feasibility:**
The honest path shows miners generate consensus extra data via: [11](#0-10) [12](#0-11) [13](#0-12) 

However, nothing prevents a miner from crafting this data off-chain and setting the flag incorrectly.

**Detection Constraints:**
The attack is difficult to detect because:
- The validation logic compares identical rounds, always passing
- No logs or events indicate incorrect `IsMinerListJustChanged` values
- The impact manifests subtly in randomness quality rather than obvious failures

**Probability:** High - any miner producing NextRound blocks can execute this attack with minimal effort and no additional resources.

### Recommendation

**Add Miner List Change Validation:**
In `ValidateConsensusAfterExecution`, add validation before the hash comparison to verify the `IsMinerListJustChanged` flag accurately reflects whether the miner list changed:

```
// After line 98, before the hash comparison
if (headerInformation.Behaviour == AElfConsensusBehaviour.NextRound || 
    headerInformation.Behaviour == AElfConsensusBehaviour.NextTerm)
{
    if (TryToGetPreviousRoundInformation(out var previousRound))
    {
        var previousMiners = previousRound.RealTimeMinersInformation.Keys.ToHashSet();
        var currentMiners = currentRound.RealTimeMinersInformation.Keys.ToHashSet();
        var minerListActuallyChanged = !previousMiners.SetEquals(currentMiners);
        
        if (currentRound.IsMinerListJustChanged != minerListActuallyChanged)
        {
            return new ValidationResult 
            { 
                Success = false, 
                Message = $"IsMinerListJustChanged flag ({currentRound.IsMinerListJustChanged}) does not match actual miner list change status ({minerListActuallyChanged})"
            };
        }
    }
}
```

**Add Invariant Check:**
For NextTerm behavior, always verify the flag is true:
```
if (headerInformation.Behaviour == AElfConsensusBehaviour.NextTerm && 
    !currentRound.IsMinerListJustChanged)
{
    return new ValidationResult { Success = false, Message = "NextTerm must have IsMinerListJustChanged = true" };
}
```

**Test Cases:**
1. Test NextRound with `IsMinerListJustChanged = true` when miner list unchanged - should fail validation
2. Test NextRound with `IsMinerListJustChanged = false` when miner list changed - should fail validation
3. Test NextTerm with `IsMinerListJustChanged = false` - should fail validation
4. Test legitimate miner replacements with correct flag - should pass validation

### Proof of Concept

**Initial State:**
- Round N with miners [A, B, C]
- All miners have valid `PreviousInValue` from previous rounds
- No evil miners detected, no miner replacement should occur
- Miner A is scheduled to produce the NextRound block

**Attack Steps:**
1. Miner A's time slot arrives for producing the NextRound block
2. Instead of calling the contract's `GetConsensusExtraData`, Miner A crafts consensus extra data locally:
   - Computes next round (N+1) with same miners [A, B, C]
   - **Sets `IsMinerListJustChanged = true`** (incorrect - miner list didn't change)
   - **Sets `PreviousInValue = Hash.Empty`** for all miners
   - Computes all other fields (time slots, orders, etc.) correctly
3. Miner A produces block with this crafted consensus extra data
4. `ValidateConsensusBeforeExecution` runs:
   - Checks mining permission, time slot, continuous blocks - all pass
   - No validation of `IsMinerListJustChanged` - passes
5. Block executes, `ProcessNextRound` called:
   - Converts input to Round via `input.ToRound()`
   - Stores round N+1 with incorrect flag via `AddRoundInformation`
   - Secret sharing event NOT fired due to `IsMinerListJustChanged = true`
6. `ValidateConsensusAfterExecution` runs:
   - Gets `currentRound` = round N+1 with `IsMinerListJustChanged = true`
   - Computes `isContainPreviousInValue = false`
   - Compares `headerInformation.Round.GetHash(false)` with `currentRound.GetHash(false)`
   - Both exclude `PreviousInValue`, both are identical - **validation passes**
7. Round N+1 is now stored with corrupted state

**Expected vs Actual:**
- **Expected:** Validation should reject the block because `IsMinerListJustChanged = true` is incorrect (miner list [A,B,C] â†’ [A,B,C] didn't change)
- **Actual:** Validation passes, round N+1 is stored with incorrect flag and missing secret sharing

**Success Condition:**
Block is accepted and round N+1 in state has `IsMinerListJustChanged = true` when it should be false, and no `SecretSharingInformation` event was fired.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-97)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L99-101)
```csharp
            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L103-123)
```csharp
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-115)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-194)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-14)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-122)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L285-298)
```csharp
    private void GenerateNextRoundInformation(Round currentRound, Timestamp currentBlockTime, out Round nextRound)
    {
        TryToGetPreviousRoundInformation(out var previousRound);
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();
        var isMinerListChanged = false;
```
