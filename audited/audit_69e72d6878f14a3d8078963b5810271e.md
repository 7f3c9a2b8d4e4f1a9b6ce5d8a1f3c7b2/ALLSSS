### Title
Null Reference Exception in GetElectionResult View Method Due to Unchecked Cross-Contract Call

### Summary
The `GetElectionResult` view method in the Election contract makes a cross-contract call to the Vote contract's `GetVotingResult` without validating the returned result. When queried with an invalid or non-existent term number, the Vote contract returns `null`, causing a `NullReferenceException` when the Election contract attempts to access the `Results` property, resulting in a denial-of-service on this read operation.

### Finding Description

The vulnerability exists in the `GetElectionResult` method which is marked as a view method: [1](#0-0) 

The implementation calls the Vote contract without null validation: [2](#0-1) 

The Vote contract's `GetVotingResult` method returns `null` when no voting result exists for the given voting item ID and snapshot number combination: [3](#0-2) 

**Root Cause:** The Vote contract performs a state lookup that returns `null` for non-existent keys. The Election contract assumes the cross-contract call always returns a valid `VotingResult` object and directly accesses `votingResult.Results` at line 114 without null checking.

**Why Protections Fail:** There are no validation checks on the `input.TermNumber` parameter, and no null check on the `votingResult` before accessing its properties. VotingResults are only created when:
1. A voting item is registered (creates snapshot 1)
2. TakeSnapshot is called (creates subsequent snapshots) [4](#0-3) [5](#0-4) 

### Impact Explanation

**Operational Impact - Denial of Service on Read Operations:**
- Any call to `GetElectionResult` with an invalid term number (future terms, past terms before voting item creation, or non-existent terms) will throw a `NullReferenceException`
- This breaks all read operations attempting to query election results, affecting dApps, frontends, block explorers, and monitoring systems
- The method is a public view function with no authorization requirements, accessible to any user or system
- While this doesn't result in fund theft or state corruption, it creates a reliability issue that impacts user experience and system observability

**Who is Affected:**
- End users querying historical or future election data
- dApps and frontends displaying election information
- Block explorers and analytics platforms
- Monitoring and auditing systems

**Severity Justification (Medium):**
- This is a DoS on read operations, not state-modifying transactions
- Does not directly impact funds, consensus, or governance execution
- However, it's easily exploitable with zero cost and can be triggered repeatedly
- Breaks an essential view function for election transparency and observability

### Likelihood Explanation

**High Likelihood:**

**Reachable Entry Point:** `GetElectionResult` is a public view method with no access controls.

**Attacker Capabilities Required:** None - any user can call this view method.

**Attack Complexity:** Trivial - simply call `GetElectionResult` with any term number that doesn't have a corresponding voting snapshot:
- Term numbers greater than the current term (future queries)
- Term number 0 or negative numbers
- Any term before the miner election voting item was registered

**Feasibility Conditions:**
- No preconditions required
- No transaction cost (view method)
- Can be triggered accidentally by legitimate queries (e.g., a frontend displaying a date picker allowing users to select future dates)

**Detection/Operational Constraints:** None - the call is indistinguishable from legitimate queries until it throws an exception.

**Probability:** Very high - this can occur during normal operations when users query historical data or when frontends implement prediction/forecast features.

### Recommendation

**Code-Level Mitigation:**

Add null validation after the cross-contract call in `GetElectionResult`:

```csharp
public override ElectionResult GetElectionResult(GetElectionResultInput input)
{
    var votingResult = State.VoteContract.GetVotingResult.Call(new GetVotingResultInput
    {
        VotingItemId = State.MinerElectionVotingItemId.Value,
        SnapshotNumber = input.TermNumber
    });

    // Add null check
    if (votingResult == null)
    {
        return new ElectionResult
        {
            TermNumber = input.TermNumber,
            IsActive = false,
            Results = { }
        };
    }

    var result = new ElectionResult
    {
        TermNumber = input.TermNumber,
        IsActive = input.TermNumber == State.CurrentTermNumber.Value,
        Results = { votingResult.Results }
    };

    return result;
}
```

**Invariant Checks:**
- All view methods performing cross-contract calls must validate the returned result before dereferencing properties
- View methods should never throw exceptions on invalid inputs - they should return empty or default results

**Test Cases to Add:**
1. Test `GetElectionResult` with a term number greater than `CurrentTermNumber`
2. Test `GetElectionResult` with term number 0
3. Test `GetElectionResult` with a term number from before the voting item was registered
4. Verify the method returns a valid (possibly empty) `ElectionResult` object instead of throwing

### Proof of Concept

**Required Initial State:**
- Election contract deployed and initialized
- Miner election voting item registered with `CurrentTermNumber = N`

**Exploitation Steps:**

1. Query the current term number to get N
2. Call `GetElectionResult` with term number N+1 (future term):
   ```
   GetElectionResult({ TermNumber: N+1 })
   ```

**Expected vs Actual Result:**
- **Expected:** Return an empty or default `ElectionResult` with `IsActive = false` and empty `Results`
- **Actual:** Throws `NullReferenceException` at line 114 when accessing `votingResult.Results`

**Success Condition:**
The view call throws an exception instead of gracefully returning an empty result, causing the read operation to fail and breaking any system relying on this view method for election data queries.

### Citations

**File:** protobuf/election_contract.proto (L138-140)
```text
    rpc GetElectionResult (GetElectionResultInput) returns (ElectionResult) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L102-118)
```csharp
    public override ElectionResult GetElectionResult(GetElectionResultInput input)
    {
        var votingResult = State.VoteContract.GetVotingResult.Call(new GetVotingResultInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            SnapshotNumber = input.TermNumber
        });

        var result = new ElectionResult
        {
            TermNumber = input.TermNumber,
            IsActive = input.TermNumber == State.CurrentTermNumber.Value,
            Results = { votingResult.Results }
        };

        return result;
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L34-42)
```csharp
    public override VotingResult GetVotingResult(GetVotingResultInput input)
    {
        var votingResultHash = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = input.SnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```
