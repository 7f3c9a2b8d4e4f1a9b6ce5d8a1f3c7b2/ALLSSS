### Title
Conflict Resolution Failure Due to TOCTOU Race and Insufficient Validation Enabling Duplicate Mining Order Assignments

### Summary
The `ApplyNormalConsensusData` function calculates conflict resolution for `FinalOrderOfNextRound` based on stale state during view calls, while the actual state update occurs later in `ProcessUpdateValue`. When multiple miners' signatures result in the same mining order, a TOCTOU race between the consensus extra data calculation and transaction execution can cause duplicate `FinalOrderOfNextRound` assignments. This is exacerbated by buggy validation logic that fails to detect duplicate order values, potentially disrupting consensus by assigning multiple miners to the same time slot in the next round.

### Finding Description

The vulnerability stems from a multi-stage failure in the mining order conflict resolution mechanism: [1](#0-0) 

**Stage 1: Stale Conflict Detection**
During block production, `GetConsensusExtraData` calls `ApplyNormalConsensusData` on an in-memory Round copy to calculate `FinalOrderOfNextRound` values and detect conflicts. The conflicts list is created from the current state snapshot, but this state can become stale before the actual state update occurs. [2](#0-1) 

**Stage 2: State Update with Pre-calculated Values**
The calculated conflict resolution is encoded in `TuneOrderInformation` and later applied during `ProcessUpdateValue`: [3](#0-2) [4](#0-3) 

Between the view call and transaction execution, other miners can update state, invalidating the calculated conflict resolution.

**Stage 3: Flawed Validation**
The validation fails to detect duplicate orders: [5](#0-4) 

The `.Distinct()` call operates on `MinerInRound` object references (reference equality), not on `FinalOrderOfNextRound` values, so it cannot detect when multiple miners have the same order number.

**Additional Bug in Conflict Resolution Logic:** [6](#0-5) 

When all mining slots are occupied, the availability check includes the conflicted miner itself, preventing it from being reassigned. If no available slot is found, the conflicted miner keeps their order: [7](#0-6) 

Then the current miner is also assigned to the same order: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:**
Duplicate `FinalOrderOfNextRound` assignments cause multiple miners to be assigned the same position in the next round's mining schedule. When the next round is generated, these miners would have identical expected mining times: [9](#0-8) 

This creates ambiguity in time slot assignments, potentially causing:
- Block production conflicts where multiple miners attempt to produce blocks at the same time
- Consensus stalling if miners wait for each other
- Invalid round transitions that fail time slot validation
- Potential for chain forks if different nodes accept different blocks from conflicting miners

**Affected Parties:**
- All network participants experience consensus disruption
- Miners assigned duplicate orders may lose block rewards
- Transaction finality is delayed during consensus irregularities

**Severity Justification:**
This directly violates the critical invariant of "miner schedule integrity" by allowing the core mining order assignment mechanism to produce invalid schedules.

### Likelihood Explanation

**Attack Complexity:** Medium
The vulnerability can manifest through natural hash collisions without malicious intent:
1. Two miners' signatures modulo miner count produce the same value (`GetAbsModulus(sigNum, minersCount) + 1`)
2. Both miners call `GetConsensusExtraData` within a short time window
3. Both see no conflict in the current state
4. Both produce blocks setting `FinalOrderOfNextRound` to the same value
5. The buggy validation accepts both blocks [10](#0-9) 

**Feasibility Conditions:**
- Natural hash collisions: With N miners, probability of collision â‰ˆ 1/N per pair of miners
- TOCTOU window: Blocks produced within the round transition period
- Later in rounds: More likely when many miners have already set their orders

**Detection/Operational Constraints:**
The validation is designed to catch this but is buggy, making exploitation undetected until round transition when scheduling conflicts emerge.

**Probability:** 
In a network with frequent block production and multiple miners, hash collisions causing order conflicts will occur regularly. The TOCTOU race window makes duplicate assignments probable during high-throughput periods.

### Recommendation

**1. Fix Validation to Detect Duplicate Orders:**
```csharp
// In NextRoundMiningOrderValidationProvider.cs
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**2. Fix Conflict Resolution Availability Check:**
Exclude the miner being reassigned from the availability check:
```csharp
// In Round_ApplyNormalConsensusData.cs, line 34
if (RealTimeMinersInformation.Values
    .Where(m => m.Pubkey != orderConflictedMiner.Pubkey)
    .All(m => m.FinalOrderOfNextRound != maybeNewOrder))
```

**3. Add State Hash Validation:**
Include a proper comparison of Round state before recovery to detect stale conflict resolutions:
```csharp
// Store original state hash before RecoverFromUpdateValue
var originalStateHash = currentRound.GetHash(isContainPreviousInValue);
// After recovery, compare with header
if (headerInformation.Round.GetHash(isContainPreviousInValue) != originalStateHash)
    return new ValidationResult { Success = false, Message = "Stale round state" };
```

**4. Add Invariant Check:**
After `ProcessUpdateValue`, verify no duplicate `FinalOrderOfNextRound` values exist in the round.

### Proof of Concept

**Initial State:**
- Round with 4 miners: A, B, C, D
- Current round number: 10
- All miners have `FinalOrderOfNextRound = 0` (not yet set)

**Attack Sequence:**

1. Miner A produces block:
   - A's signature: Hash value that results in `supposedOrderOfNextRound = 2`
   - `GetConsensusExtraData` sees no conflicts (all orders are 0)
   - Block H includes: `UpdateValue` with A.FinalOrderOfNextRound = 2
   - State after execution: A=2, B=0, C=0, D=0

2. Miner B produces block at nearly the same time:
   - B's signature: Different hash but results in `supposedOrderOfNextRound = 2` (collision)
   - `GetConsensusExtraData` called before seeing A's block
   - Sees no conflicts (based on stale state where A=0)
   - Block H+1 includes: `UpdateValue` with B.FinalOrderOfNextRound = 2
   - Validation in `NextRoundMiningOrderValidationProvider` uses `.Distinct()` on objects, not values
   - Validation passes incorrectly
   - State after execution: A=2, B=2, C=0, D=0

**Expected Result:** Validation should reject B's block due to duplicate order assignment.

**Actual Result:** Both miners assigned `FinalOrderOfNextRound = 2`. When next round is generated, both A and B get order=2 and identical expected mining times, creating a scheduling conflict.

**Success Condition:** Query round state and observe `A.FinalOrderOfNextRound == B.FinalOrderOfNextRound == 2`, violating the uniqueness invariant of mining order assignments.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L44-44)
```csharp
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```
