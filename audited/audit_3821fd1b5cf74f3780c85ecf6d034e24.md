# Audit Report

## Title
Null Reference Exception in Disassemble() Bricks Legitimate Disassembly Operations

## Summary
The `Disassemble()` function contains a critical null reference vulnerability where calling `Clone()` on potentially null state map entries causes transaction failures. NFTs assembled with only fungible tokens (FTs) or only non-fungible tokens (NFTs) cannot be disassembled, permanently bricking the disassembly process for these legitimate assets.

## Finding Description

The root cause lies in the unsafe invocation of `Clone()` on state map values without null-checking. [1](#0-0) 

The same vulnerability exists for the FT component map. [2](#0-1) 

The null checks occur too late—after the `Clone()` call has already been executed. [3](#0-2) [4](#0-3) 

The vulnerability manifests because `Assemble()` conditionally populates state maps only when components exist. [5](#0-4) [6](#0-5) 

When accessing a non-existent key in AElf's `MappedState`, the underlying serialization helper returns `default(T)` for the type. [7](#0-6)  For protobuf message reference types like `AssembledNfts` and `AssembledFts`, this evaluates to `null`.

The execution flow through `MappedState` confirms this behavior. [8](#0-7)  When a key is not found, it loads null bytes and deserializes them to null.

This contrasts with defensive patterns used elsewhere in the codebase, such as the null-conditional operator. [9](#0-8) 

## Impact Explanation

The vulnerability causes complete denial-of-service for the disassembly functionality affecting NFTs assembled with only one component type. Users who create composite NFTs using exclusively fungible tokens or exclusively other NFTs will find their assets permanently locked in the contract, as any disassembly attempt will revert with a `NullReferenceException`.

While the NFT itself is not permanently lost (the transaction revert prevents state corruption), the disassembly operation becomes permanently unavailable. The locked component tokens (FTs or NFTs) remain trapped in the contract indefinitely, with no recovery mechanism available to the legitimate owner.

This breaks the fundamental protocol guarantee that assembled NFTs can be disassembled to retrieve their components. The severity is medium because it requires minter privileges and doesn't result in total fund loss, but it does cause indefinite fund lock and operational DoS for legitimate use cases.

## Likelihood Explanation

The likelihood is **high** because this represents a natural protocol usage pattern rather than an adversarial edge case. The `Assemble()` function explicitly supports creating composite NFTs with either FTs alone, NFTs alone, or both. [10](#0-9) [11](#0-10) 

Attack complexity is extremely low—a minter simply needs to call `Assemble()` with only one component type populated, then attempt `Disassemble()`. The minter privilege requirement is standard for burnable NFT protocols. [12](#0-11) 

Users may legitimately want to create NFTs backed by fungible token reserves alone, or create collections composed purely of other NFTs. This will occur naturally during normal protocol operations, affecting any user following documented assembly patterns with single-component types.

## Recommendation

Use the null-conditional operator to safely handle potentially null state map values:

```csharp
var assembledNfts = State.AssembledNftsMap[tokenHash]?.Clone();
if (assembledNfts != null)
{
    // ... existing logic
}

var assembledFts = State.AssembledFtsMap[tokenHash]?.Clone();
if (assembledFts != null)
{
    // ... existing logic
}
```

This follows the defensive pattern already used in other system contracts and ensures that null values are handled gracefully without throwing exceptions.

## Proof of Concept

```csharp
[Fact]
public async Task DisassembleWithOnlyFTs_ShouldFail()
{
    // Setup: Create NFT protocol
    var symbol = await CreateTest();
    await AddMinterAsync(symbol);
    
    // Approve NFT contract to spend ELF tokens
    await TokenContractStub.Approve.SendAsync(new MultiToken.ApproveInput
    {
        Spender = NFTContractAddress,
        Symbol = "ELF",
        Amount = 1000
    });
    
    // Assemble NFT with ONLY FTs (no NFTs)
    var tokenHash = await NFTContractStub.Assemble.SendAsync(new AssembleInput
    {
        Symbol = symbol,
        AssembledNfts = new AssembledNfts(), // Empty - no NFTs
        AssembledFts = new AssembledFts
        {
            Value = { ["ELF"] = 100 }
        }
    });
    
    // Attempt to disassemble - this will throw NullReferenceException
    var disassembleResult = await NFTContractStub.Disassemble.SendAsync(new DisassembleInput
    {
        Symbol = symbol,
        TokenId = 1
    });
    
    // Transaction should fail with null reference exception
    disassembleResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

## Notes

The vulnerability is confirmed through multiple lines of evidence: the conditional state map population in `Assemble()`, the unsafe `Clone()` invocation in `Disassemble()`, and the AElf runtime behavior where `MappedState` returns `null` for non-existent keys via the serialization helper's `default(T)` return value for reference types. The issue affects the NFT Contract system which is in production scope and represents a genuine operational risk for legitimate protocol users.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L87-93)
```csharp
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L120-132)
```csharp
        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L134-163)
```csharp
        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-176)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L178-178)
```csharp
        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-203)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L204-204)
```csharp
        if (assembledNfts != null)
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-212)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L213-213)
```csharp
        if (assembledFts != null)
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L531-531)
```csharp
        voterVotes = State.ElectorVotes[publicKey]?.Clone();
```
