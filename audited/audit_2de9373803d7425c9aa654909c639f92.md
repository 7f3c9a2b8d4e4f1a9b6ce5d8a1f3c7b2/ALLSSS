### Title
Insufficient Validation of Critical Round Fields in NextRound Consensus Behavior Enables State Corruption

### Summary
The `NextRoundInput.Create` method performs no validation on the `Round` object fields before storing them to state. Critical consensus fields including `ConfirmedIrreversibleBlockHeight`, `ConfirmedIrreversibleBlockRoundNumber`, and `IsMinerListJustChanged` are not included in the hash-based validation performed after execution, allowing a malicious block producer to manipulate these values and corrupt consensus state, potentially causing DoS or improper LIB tracking.

### Finding Description

The vulnerability exists in the NextRound consensus transaction flow:

**1. No Input Validation in NextRoundInput.Create:**
The `NextRoundInput.Create` method simply copies all fields from the provided Round object without any validation: [1](#0-0) 

**2. Transaction Generation Without Field Validation:**
When `NextRound` behavior is triggered, `GenerateTransactionListByExtraData` calls `NextRoundInput.Create(round, randomNumber)` directly without validating the round's critical fields: [2](#0-1) 

**3. Incomplete Hash-Based Validation:**
The after-execution validation compares round hashes, but the `GetCheckableRound` method only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge` in the hash calculation—excluding critical fields: [3](#0-2) 

**4. Before-Execution Validation Gaps:**
The `RoundTerminateValidationProvider` for NextRound only validates round number increment and that InValues are null, not checking LIB fields or other critical state: [4](#0-3) 

**5. LibInformationValidationProvider Not Applied to NextRound:**
The `LibInformationValidationProvider` that validates LIB heights is only applied for `UpdateValue` behavior, not for `NextRound`: [5](#0-4) 

**6. Direct State Storage Without Full Validation:**
The unvalidated round is stored directly to state in `ProcessNextRound`: [6](#0-5) 

### Impact Explanation

**Consensus/Cross-Chain Integrity Violation:**

1. **DoS via LIB Round Manipulation:** A malicious miner can inflate `ConfirmedIrreversibleBlockRoundNumber` in the NextRound input. The corrupted value is used in `GetMaximumBlocksCount` to calculate blockchain mining status: [7](#0-6) 

If `currentRoundNumber >= libRoundNumber + SevereStatusRoundsThreshold` (where SevereStatusRoundsThreshold = max(8, maximumBlocksCount)), the blockchain enters "Severe" status, reducing maximum blocks count to 1 and firing `IrreversibleBlockHeightUnacceptable` events. This severely degrades network performance.

2. **LIB Finality Corruption:** Manipulating `ConfirmedIrreversibleBlockHeight` can cause incorrect block finalization tracking, as this value is directly stored and used throughout the consensus protocol without verification against actual blockchain state.

3. **Secret Sharing Bypass:** The `IsMinerListJustChanged` flag controls whether secret sharing information is fired in `AddRoundInformation`: [8](#0-7) 

A malicious miner can flip this flag to bypass secret sharing when the miner list hasn't changed, or force unnecessary secret sharing events.

**Affected Parties:** All network participants, as consensus state corruption affects the entire blockchain's operation and security.

**Severity Justification:** High - This enables operational DoS of the consensus mechanism and corruption of critical finality tracking without requiring majority miner collusion.

### Likelihood Explanation

**Reachable Entry Point:** Any authorized block producer can trigger this vulnerability through the standard consensus flow when producing blocks with `NextRound` behavior.

**Attacker Capabilities:** 
- Must be an authorized miner (part of the consensus set)
- Can modify block header consensus extra data after calling `GenerateConsensusTransactions` but before broadcasting
- No additional privileges required beyond normal block production rights

**Attack Complexity:** Low to Medium
1. Call `GetConsensusCommand` to determine behavior should be `NextRound`
2. Call `GenerateConsensusTransactions` to get valid transaction structure
3. Modify the `AElfConsensusHeaderInformation.Round` in the block header before broadcasting, specifically manipulating unvalidated fields
4. The block passes validation and corrupts state

**Feasibility Conditions:**
- Attacker must be in the current miner list (realistic for any miner)
- No special blockchain state required
- Can be executed during any normal round transition
- The hash comparison in after-execution validation won't detect the manipulation since excluded fields can be arbitrarily modified

**Detection Constraints:** The manipulation is difficult to detect because:
- Before-execution validation only checks basic round number and InValue constraints
- After-execution hash validation excludes the manipulated fields
- No cross-validation against actual blockchain LIB state occurs

**Probability:** High - Any malicious or compromised miner can execute this attack during their normal block production turn.

### Recommendation

**1. Include All Critical Fields in Hash Validation:**
Modify `GetCheckableRound` to include all consensus-critical fields in the hash calculation: [3](#0-2) 

Add to the checkable round:
- `ConfirmedIrreversibleBlockHeight`
- `ConfirmedIrreversibleBlockRoundNumber`
- `IsMinerListJustChanged`
- `RoundIdForValidation`
- `MainChainMinersRoundNumber`
- `ExtraBlockProducerOfPreviousRound`

**2. Apply LibInformationValidationProvider to NextRound:**
Extend validation in `ValidateBeforeExecution` to include `LibInformationValidationProvider` for `NextRound` behavior: [9](#0-8) 

**3. Add Explicit Field Validation in NextRoundInput.Create:**
Before creating the input, validate:
- `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` match or properly increment from current round
- `TermNumber` equals current term (for NextRound, not NextTerm)
- `IsMinerListJustChanged` matches actual miner list change detection

**4. Cross-Validate LIB Against Actual State:**
In `ProcessNextRound`, assert that provided LIB values are consistent with actual blockchain state before storing.

**Test Cases:**
- Verify NextRound with inflated `ConfirmedIrreversibleBlockRoundNumber` is rejected
- Verify NextRound with manipulated `IsMinerListJustChanged` is rejected
- Verify hash comparison catches all field modifications
- Verify legitimate NextRound with proper LIB values succeeds

### Proof of Concept

**Initial State:**
- Blockchain at round N with actual LIB at height H, round R
- Attacker is authorized miner in current round
- Current round stored in state with legitimate LIB values

**Attack Sequence:**

**Step 1:** Attacker as authorized miner calls `GetConsensusCommand` when it's their turn for extra block, receives `NextRound` behavior.

**Step 2:** Attacker calls `GenerateConsensusTransactions` which internally:
- Calls `GetConsensusBlockExtraData` generating legitimate next round with correct LIB values
- Returns transaction with `NextRoundInput.Create(round, randomNumber)`

**Step 3:** Before broadcasting block, attacker modifies the `AElfConsensusHeaderInformation` in block header:
```
headerInformation.Round.ConfirmedIrreversibleBlockRoundNumber = currentRoundNumber + 100
// This value is far ahead, forcing "Severe" status
```

**Step 4:** Block is broadcast and validated:
- `ValidateConsensusBeforeExecution` passes (only checks round number increment and InValues)
- Transaction executes via `NextRound` → `ProcessConsensusInformation` → `ProcessNextRound`
- `AddRoundInformation` stores corrupted round to state with inflated LIB round number
- `ValidateConsensusAfterExecution` passes (hash doesn't include LIB fields)

**Expected Result:** Block should be rejected due to invalid LIB values.

**Actual Result:** Block accepted, state corrupted with inflated `ConfirmedIrreversibleBlockRoundNumber`.

**Success Condition:** Next call to `GetMaximumBlocksCount` returns 1 (Severe status) instead of normal value (8), and `IrreversibleBlockHeightUnacceptable` event is fired, causing operational DoS.

### Notes

This vulnerability is particularly severe for side chains as indicated by the initial function reference: [10](#0-9) 

Side chains always return `NextRound` for round termination, making this attack vector consistently available. The randomNumber validation via VRF occurs correctly, but the Round field validation is insufficient. The core issue is the architectural decision to perform hash-based validation on only a subset of Round fields, leaving critical consensus state unprotected.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-115)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L16-23)
```csharp
        /// <summary>
        ///     Simply return NEXT_ROUND for side chain.
        /// </summary>
        /// <returns></returns>
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```
