# Audit Report

## Title
Referendum Organizations Can Become Permanently Locked Through Invalid Configuration Changes

## Summary
The Referendum contract allows organizations to modify their governance configuration through self-executed proposals, but insufficient validation permits setting configurations that make future proposals impossible to create or pass. This results in permanent governance lock with no recovery mechanism, affecting both malicious attacks and accidental configuration errors.

## Finding Description

The Referendum contract provides two methods for organizations to modify their configuration: `ChangeOrganizationThreshold` and `ChangeOrganizationProposerWhiteList`. Both methods can only be called by the organization itself through the proposal mechanism. [1](#0-0) [2](#0-1) 

When a proposal is released, it executes via virtual inline call, making the organization address the sender. [3](#0-2) 

The core vulnerability lies in the `Validate(Organization)` method which performs insufficient validation. [4](#0-3) 

**Three Critical Validation Gaps:**

**1. Unreachable Whitelist Lock:**
The validation only checks if the whitelist is non-empty via `Empty()` function. [5](#0-4) 

It does NOT verify that addresses are controlled by anyone, are burn addresses, or are capable of creating proposals. An organization can set its whitelist to addresses with lost private keys or deliberately unreachable addresses.

**2. Impossible Threshold Lock:**
The validation enforces `MinimalApprovalThreshold > 0` and `MinimalApprovalThreshold <= MinimalVoteThreshold`, but imposes NO upper bounds on threshold values. Thresholds are `int64` types. [6](#0-5) 

An organization can set `MinimalVoteThreshold` to values like `long.MaxValue` (9,223,372,036,854,775,807), exceeding any realistic token supply or voting capacity.

**3. Zero-Tolerance Lock:**
The validation only checks `MaximalAbstentionThreshold >= 0` and `MaximalRejectionThreshold >= 0`, allowing zero values. When checking if a proposal can be released, the logic rejects proposals where rejection or abstention counts exceed these thresholds. [7](#0-6) 

If either threshold is zero, even a single rejection or abstention vote blocks the proposal, requiring perfect unanimous approval with 100% participation.

**Comparison with Other Governance Contracts:**
The Association contract has proper validation that bounds thresholds to the organization member count, preventing impossible configurations. [8](#0-7) 

The Parliament contract similarly bounds thresholds to the abstract vote total. [9](#0-8) 

However, the Referendum contract has no such upper bound validation because it uses a token-based voting model rather than a fixed member list.

## Impact Explanation

Once an organization is locked through any of these three vectors, the impact is catastrophic and permanent:

**Complete Governance DoS:**
- No new proposals can be created if the whitelist contains only unreachable addresses
- No proposals can pass if thresholds are set to impossible values
- No proposals can be released if zero-tolerance thresholds are violated by any single voter

**Permanent Fund Lock:**
Any funds held in the organization's virtual address become permanently unrecoverable since configuration changes require passing proposals, which becomes impossible.

**No Recovery Mechanism:**
There is no admin override, no emergency procedure, and no time-based unlock. The ONLY way to modify organization configuration is through the very proposal mechanism that has been locked. [10](#0-9) 

**Severity Justification: HIGH**
- Complete and irreversible loss of governance functionality
- Permanent loss of access to organization-controlled funds and permissions
- No recovery path exists in the contract design
- Affects protocol-level governance capabilities

## Likelihood Explanation

**Attack Prerequisites:**
- Attacker must be in the proposer whitelist (standard governance participation)
- Attacker must coordinate sufficient votes to pass ONE malicious proposal under current thresholds

**Attack Complexity: LOW**
The attack follows the standard proposal workflow using public methods: `CreateProposal`, `Approve`, and `Release`. No special exploits or unusual transaction patterns are required. [11](#0-10) 

**Two Attack Vectors:**

1. **Malicious Attack:**
   - Insider threat: Whitelisted proposer deliberately submits locking configuration
   - Cost: Standard proposal and voting transaction fees
   - Motivation: Griefing, competitive advantage, or ransom scenarios

2. **Accidental Lock:**
   - Configuration errors are highly probable given the lack of validation
   - Examples: Typo in threshold values (adding extra zeros), copying wrong addresses to whitelist, misunderstanding threshold semantics
   - The contract provides NO warnings about potentially dangerous configurations

**Feasibility: HIGH**
Test evidence shows that threshold changes to arbitrarily high values are accepted without validation. [12](#0-11) 

The test successfully changes thresholds to 20,000 without upper bound checks, confirming the vulnerability.

## Recommendation

Implement comprehensive validation in the `Validate(Organization)` method:

**1. Add Upper Bound Checks:**
```csharp
// Get token total supply for the governance token
var tokenInfo = GetTokenInfo(organization.TokenSymbol);
var maxReasonableThreshold = tokenInfo.Supply; // or a fraction thereof

Assert(proposalReleaseThreshold.MinimalVoteThreshold <= maxReasonableThreshold,
    "MinimalVoteThreshold exceeds token supply");
Assert(proposalReleaseThreshold.MinimalApprovalThreshold <= maxReasonableThreshold,
    "MinimalApprovalThreshold exceeds token supply");
```

**2. Add Minimum Threshold Checks for Rejection/Abstention:**
```csharp
Assert(proposalReleaseThreshold.MaximalRejectionThreshold > 0,
    "MaximalRejectionThreshold must be greater than zero");
Assert(proposalReleaseThreshold.MaximalAbstentionThreshold > 0,
    "MaximalAbstentionThreshold must be greater than zero");
```

**3. Add Whitelist Address Validation:**
```csharp
// Prevent known burn addresses
foreach (var proposer in organization.ProposerWhiteList.Proposers)
{
    Assert(!IsBurnAddress(proposer), "Whitelist contains burn address");
}
```

**4. Add Sanity Checks:**
Ensure that the configuration is logically achievable:
```csharp
// Ensure it's possible to pass proposals
var minVotesNeeded = proposalReleaseThreshold.MinimalVoteThreshold;
var maxRejectionAllowed = proposalReleaseThreshold.MaximalRejectionThreshold;
var maxAbstentionAllowed = proposalReleaseThreshold.MaximalAbstentionThreshold;

Assert(minVotesNeeded <= maxRejectionAllowed + maxAbstentionAllowed + minVotesNeeded,
    "Configuration makes proposals mathematically impossible");
```

## Proof of Concept

```csharp
[Fact]
public async Task Organization_Lock_Via_Impossible_Threshold()
{
    // Create organization with valid initial thresholds
    var organizationAddress = await CreateOrganizationAsync(
        minimalApprovalThreshold: 5000,
        minimalVoteThreshold: 5000,
        maximalAbstentionThreshold: 10000,
        maximalRejectionThreshold: 10000,
        new[] { DefaultSender }
    );

    // Create malicious proposal to change threshold to impossible value
    var impossibleThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = long.MaxValue, // Impossible to reach
        MinimalApprovalThreshold = 5000,
        MaximalRejectionThreshold = 10000,
        MaximalAbstentionThreshold = 10000
    };

    var maliciousProposalId = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair,
        impossibleThreshold,
        nameof(ReferendumContractStub.ChangeOrganizationThreshold),
        organizationAddress,
        ReferendumContractAddress
    );

    // Approve and release under CURRENT valid thresholds
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, maliciousProposalId);
    await ApproveAsync(Accounts[3].KeyPair, maliciousProposalId);
    
    var releaseResult = await ReferendumContractStub.Release.SendAsync(maliciousProposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

    // Verify organization is now locked - no future proposal can pass
    var newProposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Even with maximum possible votes, proposal cannot reach MinimalVoteThreshold
    await ApproveAllowanceAsync(Accounts[3].KeyPair, long.MaxValue / 2, newProposalId);
    await ApproveAsync(Accounts[3].KeyPair, newProposalId);
    
    var lockedProposal = await ReferendumContractStub.GetProposal.CallAsync(newProposalId);
    
    // Proposal can never be released - organization is permanently locked
    lockedProposal.ToBeReleased.ShouldBeFalse();
    
    // Attempting to release will fail
    var failedRelease = await ReferendumContractStub.Release.SendWithExceptionAsync(newProposalId);
    failedRelease.TransactionResult.Error.ShouldContain("Not approved");
}
```

## Notes

This vulnerability represents a fundamental design flaw in the Referendum contract's validation logic. Unlike Association and Parliament contracts which bound thresholds to member counts or abstract vote totals, the Referendum contract lacks equivalent safeguards for its token-based voting model.

The vulnerability is particularly dangerous because:
1. It can be triggered through normal governance operations
2. The impact is permanent with no recovery mechanism
3. It can occur accidentally through honest configuration errors
4. The contract provides no warnings about dangerous configurations

Organizations using Referendum contracts should be extremely careful when voting on configuration change proposals and should implement off-chain validation before approving such changes.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-177)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }

    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }

    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.RejectionCount = proposal.RejectionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Reject);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty Abstain(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.AbstentionCount = proposal.AbstentionCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Abstain);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }

    public override Empty ReclaimVoteToken(Hash input)
    {
        var proposal = State.Proposals[input];
        Assert(proposal == null ||
               Context.CurrentBlockTime >= proposal.ExpiredTime, "Unable to reclaim at this time.");
        UnlockToken(input, Context.Sender);
        return new Empty();
    }

    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }

    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }

    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }

    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L13-16)
```csharp
    public static bool Empty(this ProposerWhiteList proposerWhiteList)
    {
        return proposerWhiteList.Count() == 0;
    }
```

**File:** protobuf/acs3.proto (L128-137)
```text
message ProposalReleaseThreshold {
    // The value for the minimum approval threshold.
    int64 minimal_approval_threshold = 1;
    // The value for the maximal rejection threshold.
    int64 maximal_rejection_threshold = 2;
    // The value for the maximal abstention threshold.
    int64 maximal_abstention_threshold = 3;
    // The value for the minimal vote threshold.
    int64 minimal_vote_threshold = 4;
}
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** test/AElf.Contracts.Referendum.Tests/ReferendumContractTest.cs (L741-760)
```csharp
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 20000,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            ReferendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var changeProposalId = await CreateReferendumProposalAsync(DefaultSenderKeyPair,
                proposalReleaseThresholdInput,
                nameof(ReferendumContractStub.ChangeOrganizationThreshold), organizationAddress,
                ReferendumContractAddress);
            await ApproveAllowanceAsync(keyPair, minimalApproveThreshold, changeProposalId);
            await ApproveAsync(Accounts[3].KeyPair, changeProposalId);
            var referendumContractStub = GetReferendumContractTester(DefaultSenderKeyPair);
            var result = await referendumContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await referendumContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
```
