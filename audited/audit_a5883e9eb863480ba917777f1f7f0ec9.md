### Title
Method Fee Controller Governance Bypass via Unvalidated Cross-Contract Call

### Summary
The `ChangeMethodFeeController` function accepts arbitrary contract addresses without validation, allowing a malicious contract to bypass organization existence checks by always returning true. If governance approves such a change, an attacker gains unilateral control over method fees, bypassing ongoing governance requirements.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` method which blindly trusts any contract address provided in the `AuthorityInfo` parameter. [1](#0-0) 

The `ChangeMethodFeeController` function calls this validation at line 26 without any verification that `input.ContractAddress` is one of the legitimate governance contracts (Parliament, Association, or Referendum). [2](#0-1) 

The root cause is that the code makes a cross-contract call to `input.ContractAddress` expecting it to implement the ACS3 `ValidateOrganizationExist` method, but never validates that this address is a trusted system contract. [3](#0-2) 

A malicious contract can implement this interface to always return `BoolValue{Value=true}`, bypassing the intended validation that checks if the organization actually exists in a legitimate governance contract. [4](#0-3) 

The AElf system provides known constants for legitimate governance contracts, but these are not validated in the authority change flow. [5](#0-4) 

Additionally, the Genesis contract provides a `ValidateSystemContractAddress` method that could be used to verify contract addresses, but it is not utilized in this validation path. [6](#0-5) 

### Impact Explanation

**Governance Bypass:** Once the method fee controller is changed to point to a malicious contract, the `SetMethodFee` function will check sender authorization against the attacker-controlled address. [7](#0-6) 

This allows the attacker to:
1. **Set arbitrary method fees** without requiring ongoing Parliament approval
2. **Execute DoS attacks** by setting fees to prohibitively high values, making contract methods unusable
3. **Cause revenue loss** by setting fees to zero
4. **Manipulate fee economics** to benefit specific operations or actors

The severity is CRITICAL because it completely bypasses the governance control over a critical system parameter. This pattern exists across all system contracts implementing ACS1. [8](#0-7) 

### Likelihood Explanation

**Attack Requirements:**
1. Deploy a malicious contract implementing `ValidateOrganizationExist` returning true (requires standard contract deployment)
2. Create a Parliament proposal to call `ChangeMethodFeeController` with the malicious contract address
3. Obtain Parliament approval for the proposal

**Feasibility Factors:**
- The current controller check at line 25 requires sender to be the existing controller's owner (typically Parliament organization)
- Parliament approval is required, which is controlled by miners (trusted set)
- However, the proposal parameters may not be carefully inspected, especially if disguised or bundled with legitimate changes
- No automated validation exists to flag non-standard contract addresses
- The lack of explicit validation creates a security gap that relies solely on manual governance review

**Attack Complexity:** Medium - requires governance interaction but exploits a clear validation gap in the code.

**Detection:** Difficult - the malicious contract address would be visible in the proposal parameters, but without automated checks, it relies on manual review.

### Recommendation

**Primary Fix:** Add contract address whitelist validation before calling `ValidateOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate that ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address."
    );
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply this fix to all contracts** with the same pattern identified in the codebase.

**Test Cases:**
1. Verify `ChangeMethodFeeController` fails when providing non-whitelisted contract addresses
2. Verify it succeeds only with Parliament, Association, or Referendum contract addresses
3. Test that a malicious contract cannot bypass the check even if it implements the interface

### Proof of Concept

**Step 1:** Deploy malicious contract:
```csharp
public class MaliciousAuthContract {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

**Step 2:** Create Parliament proposal with parameters:
- Target: TokenConverter.ChangeMethodFeeController
- Input: AuthorityInfo { ContractAddress = [MaliciousAuthContract], OwnerAddress = [AttackerAddress] }

**Step 3:** If proposal is approved and released:
- CheckOrganizationExist calls MaliciousAuthContract.ValidateOrganizationExist
- Returns true regardless of whether organization exists
- Controller is set to attacker's address

**Step 4:** Attacker directly calls SetMethodFee:
- Sender check passes (attacker owns the controller)
- Can set arbitrary fees without further governance approval

**Expected Result:** Call should fail with "Invalid governance contract address"

**Actual Result:** Call succeeds, bypassing organization validation

### Notes

This vulnerability pattern exists across all ACS1-implementing contracts in the codebase, affecting method fee governance system-wide. The fix should be implemented consistently across Parliament, Association, Referendum, Genesis, MultiToken, TokenConverter, Consensus, CrossChain, Economic, Election, Configuration, Profit, Treasury, TokenHolder, and Vote contracts.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/acs3.proto (L67-70)
```text
    // Check the existence of an organization.
    rpc ValidateOrganizationExist(aelf.Address) returns (google.protobuf.BoolValue){
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L48-58)
```csharp
    public static readonly string ParliamentContractSystemName = GetStringName(ParliamentContractSystemHashName);
    public static readonly string VoteContractSystemName = GetStringName(VoteContractSystemHashName);
    public static readonly string ProfitContractSystemName = GetStringName(ProfitContractSystemHashName);
    public static readonly string CrossChainContractSystemName = GetStringName(CrossChainContractSystemHashName);

    public static readonly string TokenConverterContractSystemName =
        GetStringName(TokenConverterContractSystemHashName);

    public static readonly string EconomicContractSystemName = GetStringName(EconomicContractSystemHashName);
    public static readonly string ReferendumContractSystemName = GetStringName(ReferendumContractSystemHashName);
    public static readonly string AssociationContractSystemName = GetStringName(AssociationContractSystemHashName);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
