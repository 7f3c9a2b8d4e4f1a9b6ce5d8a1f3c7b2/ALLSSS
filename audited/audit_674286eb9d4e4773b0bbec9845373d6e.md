### Title
Non-Deterministic Extra Block Producer Selection Enables Consensus Fork via Dictionary Enumeration Order

### Summary
The `GetExtraBlockProducerInformation()` method uses `.First()` on a protobuf map (Dictionary) without validating that exactly one miner has `IsExtraBlockProducer=true`. A malicious or buggy extra block producer can submit a `NextRound` transaction with multiple miners marked as extra block producers. Since Dictionary enumeration order is non-deterministic across nodes, different nodes will select different extra block producers via `.First()`, causing divergent time slot arrangements and consensus fork.

### Finding Description

The vulnerability exists in the interaction between round generation, validation, and mining time arrangement:

**Root Cause 1: Non-Deterministic Selection** [1](#0-0) 

The `GetExtraBlockProducerInformation()` method uses `.First()` on `RealTimeMinersInformation` which is a protobuf map. This map is defined as: [2](#0-1) 

Protobuf maps become `Dictionary<string, MinerInRound>` in C#, and Dictionary enumeration order is non-deterministic and can vary across different processes/nodes.

**Root Cause 2: Missing Validation**
The NextRound validation does not check that exactly one miner has `IsExtraBlockProducer=true`: [3](#0-2) [4](#0-3) 

Neither validation provider checks the extra block producer count invariant.

**Root Cause 3: Vulnerable Usage Sites**
The non-deterministic selection is used in critical consensus paths:

1. In `ArrangeAbnormalMiningTime` for scheduling extra block mining: [5](#0-4) 

2. In `BreakContinuousMining` when generating next round: [6](#0-5) [7](#0-6) 

**Attack Vector**
A malicious extra block producer can craft a `NextRoundInput` with multiple `IsExtraBlockProducer=true`: [8](#0-7) 

The `ToRound()` method preserves the malicious map data, and `ProcessNextRound` accepts it without validation: [9](#0-8) 

### Impact Explanation

**Consensus Fork (Critical)**
- Different nodes select different extra block producers via non-deterministic `.First()`
- Nodes arrange different mining times via `ArrangeExtraBlockMiningTime`
- Nodes expect different miners to produce round termination blocks
- When generating the next round, `BreakContinuousMining` swaps orders differently on each node
- Network splits into multiple forks following different consensus views

**Chain Split Duration**
- Fork persists until manual intervention or chain reorganization
- All blocks after the malicious round are affected
- Transaction finality is compromised across the network

**Affected Parties**
- All network participants experience consensus divergence
- Miners cannot agree on valid blocks
- Users see inconsistent chain state
- dApps and services built on the chain become unreliable

### Likelihood Explanation

**Attacker Capabilities**
- Requires being selected as extra block producer (periodic role rotation)
- Must be able to construct malformed `NextRoundInput` (standard transaction capability)
- No special privileges beyond normal miner status needed

**Attack Complexity**
- Low: Simply set multiple `IsExtraBlockProducer=true` in transaction data
- No cryptographic bypass or complex exploit chain required
- Single malicious transaction triggers network-wide fork

**Feasibility Conditions**
- Attacker waits until their turn as extra block producer
- Submits crafted `NextRound` transaction
- Existing validation accepts the malicious data: [10](#0-9) 

**Detection Difficulty**
- Fork manifests gradually as nodes diverge on mining schedules
- No immediate transaction failure or error
- Difficult to trace back to root cause without deep protocol analysis

**Probability Assessment: High**
- No technical barriers prevent exploitation
- Dictionary non-determinism is well-documented C# behavior
- Missing validation is a clear weakness in current implementation

### Recommendation

**1. Add Validation for Exactly One Extra Block Producer**
In `RoundTerminateValidationProvider.ValidationForNextRound`, add:
```csharp
var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values
    .Count(m => m.IsExtraBlockProducer);
if (extraBlockProducerCount != 1)
    return new ValidationResult { 
        Message = $"Invalid extra block producer count: {extraBlockProducerCount}. Expected exactly 1." 
    };
```

**2. Replace Non-Deterministic .First() with Deterministic Selection**
In `GetExtraBlockProducerInformation`, replace:
```csharp
return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
```
With deterministic selection (e.g., by pubkey alphabetical order):
```csharp
return RealTimeMinersInformation
    .Where(bp => bp.Value.IsExtraBlockProducer)
    .OrderBy(bp => bp.Key)
    .First()
    .Value;
```

**3. Add Invariant Check in AddRoundInformation**
Before storing round data: [11](#0-10) 

Add assertion:
```csharp
Assert(round.RealTimeMinersInformation.Values.Count(m => m.IsExtraBlockProducer) == 1,
    "Round must have exactly one extra block producer");
```

**4. Add Regression Test**
Create test case verifying rejection of `NextRoundInput` with multiple extra block producers.

### Proof of Concept

**Initial State:**
- Network running with N miners in current round
- Attacker is selected as extra block producer for current round

**Attack Sequence:**

**Step 1:** Attacker's node generates next round normally: [12](#0-11) 

**Step 2:** Attacker modifies the generated round before submitting:
```
nextRound.RealTimeMinersInformation["MinerA"].IsExtraBlockProducer = true;
nextRound.RealTimeMinersInformation["MinerB"].IsExtraBlockProducer = true;
nextRound.RealTimeMinersInformation["MinerC"].IsExtraBlockProducer = true;
```

**Step 3:** Attacker submits malicious `NextRound` transaction: [13](#0-12) 

**Step 4:** Transaction passes validation (no check for extra block producer count) and is accepted by all nodes.

**Step 5:** Nodes store the corrupted round data: [14](#0-13) 

**Step 6:** Different nodes call `GetExtraBlockProducerInformation()` and get different results:
- Node1's Dictionary.First() returns MinerA
- Node2's Dictionary.First() returns MinerB  
- Node3's Dictionary.First() returns MinerC

**Expected Result:** Single consistent extra block producer across all nodes

**Actual Result:** Non-deterministic selection causing:
- Different time slot arrangements per node
- Different expectations for next round termination
- Consensus fork when nodes reject blocks from "wrong" extra block producer

**Success Condition:** Network splits into multiple forks, each following different extra block producer. Blocks from one fork are rejected by nodes on other forks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L39-42)
```csharp
    private MinerInRound GetExtraBlockProducerInformation()
    {
        return RealTimeMinersInformation.First(bp => bp.Value.IsExtraBlockProducer).Value;
    }
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L78-90)
```csharp
        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L92-107)
```csharp
        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L1-50)
```csharp
using AElf.CSharp.Core;
using AElf.Sdk.CSharp;
using AElf.Types;
using Google.Protobuf;
using Google.Protobuf.WellKnownTypes;

namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public partial class AEDPoSContract
{
    private bool IsMainChain
    {
        get
        {
            if (_isMainChain != null) return (bool)_isMainChain;
            _isMainChain = State.IsMainChain.Value;
            return (bool)_isMainChain;
        }
    }

    private Timestamp GetBlockchainStartTimestamp()
    {
        return State.BlockchainStartTimestamp.Value ?? new Timestamp();
    }

    private bool IsFirstRoundOfCurrentTerm(out long termNumber)
    {
        termNumber = 1;
        return (TryToGetTermNumber(out termNumber) &&
                TryToGetPreviousRoundInformation(out var previousRound) &&
                previousRound.TermNumber != termNumber) ||
               (TryToGetRoundNumber(out var roundNumber) && roundNumber == 1);
    }

    private bool TryToGetTermNumber(out long termNumber)
    {
        termNumber = State.CurrentTermNumber.Value;
        return termNumber != 0;
    }

    private bool TryToGetRoundNumber(out long roundNumber)
    {
        roundNumber = State.CurrentRoundNumber.Value;
        return roundNumber != 0;
    }

    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
