### Title
Miners Can Manipulate Next Round Mining Order Through Invalid PreviousInValue

### Summary
Miners can manipulate their mining order in the next consensus round by providing arbitrary `previousInValue` that fails validation. While the invalid value is rejected, the signature calculation still uses it, allowing miners to brute-force favorable mining positions. This violates the critical invariant of miner schedule integrity.

### Finding Description

The vulnerability exists in the consensus extra data generation flow where signature calculation uses miner-provided `previousInValue` even when validation fails. [1](#0-0) 

The `_previousRoundId` is populated from blockchain state: [2](#0-1) [3](#0-2) 

However, in `GetConsensusExtraDataToPublishOutValue`, when a miner provides an invalid `previousInValue`: [4](#0-3) 

The validation at lines 80-86 correctly rejects invalid `previousInValue` by setting it to `Hash.Empty`. However, line 92 still calculates the signature using the invalid `triggerInformation.PreviousInValue`. This signature directly determines the miner's order in the next round: [5](#0-4) 

The signature is stored (line 13) and used to calculate `supposedOrderOfNextRound` (lines 19-21). The `PreviousRoundId` hint is never validated against blockchain stateâ€”it's only used client-side for cache lookup, but miners can bypass this entirely by providing arbitrary values to `GetConsensusExtraData`.

### Impact Explanation

**Consensus Integrity Compromise**: Miners can manipulate their position in the next round's mining schedule, violating the core consensus invariant that "miner schedule integrity" must be maintained. This allows:

1. **Front-running advantages**: A miner can position themselves first to collect maximum transaction fees
2. **Strategic timing**: Miners can choose specific time slots for block production
3. **Unfair resource allocation**: Mining order affects reward distribution and network influence

The impact is protocol-wide as it affects all consensus participants. While individual manipulation is bounded by the modulus operation (can only choose from available positions), coordinated manipulation by multiple miners could significantly distort the intended randomness of mining order.

### Likelihood Explanation

**High Likelihood - Easily Exploitable**:

- **Reachable Entry Point**: Public method `GetConsensusExtraData` accessible to all miners
- **No Special Privileges Required**: Any active miner can perform this attack
- **Trivial Computation**: Attacker can compute offline:
  1. Retrieve `aggregateSignatures` from previous round (public blockchain state)
  2. Calculate `targetSignature` for desired order: `targetSig` where `(targetSig % minersCount) + 1 == desiredOrder`
  3. Compute `requiredPreviousInValue = XOR(targetSignature, aggregateSignatures)`
  4. Submit with this crafted value
- **Undetectable**: Invalid `previousInValue` appears as legitimate validation failure (miner "forgot" their previous value)
- **Economic Incentive**: Miners benefit from better positions through increased fees and strategic advantages

### Recommendation

**Immediate Fix**: Validate that signature calculation uses only validated `previousInValue`:

In `GetConsensusExtraDataToPublishOutValue`, modify lines 79-93 to ensure signature calculation happens after validation:

```csharp
if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
    previousRound.RealTimeMinersInformation[pubkey].OutValue)
{
    Context.LogDebug(() => "Failed to produce block at previous round?");
    previousInValue = Hash.Empty;
    // Use deterministic fallback for signature, not user-provided value
    var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
    signature = previousRound.CalculateSignature(fakePreviousInValue);
}
else
{
    previousInValue = triggerInformation.PreviousInValue;
    signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
}
```

**Additional Validation**: Add explicit check that `hint.PreviousRoundId` matches `State.Rounds[CurrentRoundNumber - 1].RoundId` in the contract validation phase.

**Test Cases**: Add regression tests verifying that manipulated `previousInValue` values do not affect mining order calculation.

### Proof of Concept

**Initial State**:
- Current round: N (with 5 miners)
- Previous round: N-1 (with all miner signatures committed)
- Attacker is miner with pubkey "MinerA"
- Attacker's current order would naturally be position 3

**Attack Sequence**:

1. **Attacker retrieves blockchain state**:
   - Fetch `previousRound = State.Rounds[N-1]`
   - Calculate `aggregateSignatures = XOR of all previousRound.RealTimeMinersInformation[*].Signature`

2. **Attacker computes target**:
   - Desired order: 1 (first miner)
   - Calculate target signature: `targetSig` where `(targetSig % 5) + 1 == 1`
   - Compute `maliciousPreviousInValue = XOR(targetSig, aggregateSignatures)`

3. **Attacker submits block**:
   - Call `GetConsensusExtraData` with `triggerInformation.PreviousInValue = maliciousPreviousInValue`
   - Validation fails (line 80-82) since `Hash(maliciousPreviousInValue) != previousRound.OutValue`
   - But signature calculated as: `signature = previousRound.CalculateSignature(maliciousPreviousInValue)` (line 92)

4. **Result**:
   - Attacker's `supposedOrderOfNextRound` becomes 1 instead of natural position 3
   - In round N+1, attacker mines first, gaining fee advantages

**Expected vs Actual**:
- **Expected**: Mining order determined by cryptographically secure randomness from valid previous round participation
- **Actual**: Attacker can choose their mining order by providing crafted invalid values that still influence signature calculation

**Success Condition**: Attacker's `FinalOrderOfNextRound` in the updated round matches their desired position (verifiable by checking `State.Rounds[N].RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound`).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L23-41)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeNormalBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);

            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L34-37)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                TryToGetPreviousRoundInformation(out var previousRound);
                return new ConsensusCommandProvider(new NormalBlockCommandStrategy(currentRound, pubkey,
                    currentBlockTime, previousRound.RoundId)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L56-64)
```csharp
    private bool TryToGetPreviousRoundInformation(out Round previousRound)
    {
        previousRound = new Round();
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        if (roundNumber < 2) return false;
        var targetRoundNumber = roundNumber.Sub(1);
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L72-93)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound) && !IsFirstRoundOfCurrentTerm(out _))
        {
            if (triggerInformation.PreviousInValue != null &&
                triggerInformation.PreviousInValue != Hash.Empty)
            {
                Context.LogDebug(
                    () => $"Previous in value in trigger information: {triggerInformation.PreviousInValue}");
                // Self check.
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
                else
                {
                    previousInValue = triggerInformation.PreviousInValue;
                }

                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```
