### Title
NFT Contract SetMethodFee() Silently Fails While Creating False Perception of Successful Fee Updates

### Summary
The NFT contract's ACS1 implementation accepts `SetMethodFee()` calls and returns success (Empty) without error, but performs no state updates. [1](#0-0)  Meanwhile, `GetMethodFee()` continues returning hardcoded values (100 ELF for Create method), [2](#0-1)  creating a false perception that fee configuration works when it does not. This violates ACS1 standard expectations and permanently locks governance out of controlling NFT creation fees.

### Finding Description

The NFT contract implements a broken ACS1 (Transaction Fee Standard) pattern:

**Broken Implementation:**
- `SetMethodFee()` returns Empty without storing any data or performing validation [1](#0-0) 
- `ChangeMethodFeeController()` returns Empty without updating controller [3](#0-2) 
- `GetMethodFee()` returns hardcoded 100 ELF for "Create" method, ignoring any previous SetMethodFee calls [2](#0-1) 
- `GetMethodFeeController()` returns empty AuthorityInfo [4](#0-3) 

**Missing State Storage:**
The NFTContractState has no `TransactionFees` or `MethodFeeController` state variables to persist fee configurations. [5](#0-4) 

**Contrast with Proper Implementation:**
Other system contracts properly implement ACS1 by storing fees in `State.TransactionFees[input.MethodName]` with authorization checks, [6](#0-5)  and defining the required state variables. [7](#0-6) 

**Fee Enforcement Path:**
The token contract's `ChargeTransactionFees` calls `GetMethodFee` to retrieve fees [8](#0-7)  - since NFT's `GetMethodFee` returns hardcoded values, any `SetMethodFee` updates are completely ignored during fee charging.

**ACS1 Standard Violation:**
The ACS1 documentation describes two valid approaches: (1) hardcoded fees WITHOUT implementing the setter methods, or (2) configurable fees WITH proper state storage. [9](#0-8)  The NFT contract incorrectly mixes both approaches - it implements the setter methods but with no-op behavior, creating misleading interface semantics.

### Impact Explanation

**Governance Control Loss:**
Governance administrators (Parliament default organization or designated controller) completely lose the ability to adjust NFT creation fees through standard ACS1 mechanisms. The fee is permanently hardcoded at 100 ELF regardless of market conditions, token price fluctuations, or economic policy changes.

**Silent Failure & False Perception:**
When authorized parties call `SetMethodFee()`, the transaction succeeds and returns Empty, creating the false impression that fees were updated. Administrators may believe they've successfully adjusted fees and wait for effects that never materialize. This silent failure is more dangerous than explicit reversion.

**Economic Inflexibility:**
- If ELF price increases significantly, 100 ELF becomes prohibitively expensive for NFT creation
- If ELF price decreases, 100 ELF may be insufficient to prevent spam/abuse
- No governance mechanism exists to adapt to changing economic conditions

**Operational & Trust Impact:**
- Administrators waste time investigating why fee changes don't take effect
- Creates confusion about which contracts properly implement ACS1
- Undermines trust in the governance system's fee management capabilities

**Severity Justification:**
HIGH severity due to complete governance control loss over an important economic parameter, combined with the deceptive silent-failure behavior that misleads administrators.

### Likelihood Explanation

**Certainty of Occurrence:**
This issue WILL occur with 100% probability whenever any authorized party attempts to use the standard ACS1 interface to configure NFT method fees. No special preconditions or attack sophistication required.

**Realistic Scenario:**
1. Parliament proposes and approves changing NFT creation fee from 100 ELF to 50 ELF due to ELF price increase
2. Parliament calls `SetMethodFee` with the new configuration
3. Transaction succeeds, returns Empty, no error thrown
4. Administrators believe fee update succeeded
5. Users continue being charged 100 ELF because `GetMethodFee` still returns hardcoded value
6. Confusion ensues, administrators investigate, discover the silent failure

**Affected Parties:**
- Governance administrators attempting legitimate fee configuration
- NFT creators expecting adjusted fees after governance proposals pass
- End users confused by discrepancy between announced and actual fees

**Detection Complexity:**
Moderate - requires administrators to notice that actual charged fees don't match expected configured fees, which may take time to discover depending on monitoring practices.

**Probability Assessment:**
HIGH probability - any governance attempt to adjust NFT fees encounters this issue immediately. The only way to avoid it is to never attempt fee configuration, which is an unreasonable operational constraint.

### Recommendation

**1. Add Required State Variables:**
Define in `NFTContractState.cs`:
```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**2. Implement Proper SetMethodFee:**
Following the standard pattern from other system contracts:
- Add authorization check using `RequiredMethodFeeControllerSet()` helper
- Validate token symbols and amounts using `AssertValidToken`
- Store fees in state: `State.TransactionFees[input.MethodName] = input`
- Assert sender matches controller: `Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.")`

**3. Implement GetMethodFee to Read State:**
Change implementation to: `return State.TransactionFees[input.Value] ?? [default hardcoded value for backward compatibility]`

**4. Implement ChangeMethodFeeController & GetMethodFeeController:**
Follow standard patterns from Association/Parliament contracts with proper authorization checks and state persistence. [10](#0-9) 

**5. Alternative - Explicit No-Op Pattern:**
If hardcoded fees are intentional, make the no-op behavior explicit by asserting/reverting in SetMethodFee instead of silently returning Empty, matching the ACS1 documentation recommendation. [11](#0-10) 

**6. Add Test Coverage:**
Create tests validating:
- SetMethodFee stores and GetMethodFee retrieves configured values
- Unauthorized SetMethodFee calls are rejected
- Fee charging uses configured values, not hardcoded ones

### Proof of Concept

**Initial State:**
- NFT contract deployed with current ACS1 implementation
- Create method fee hardcoded at 100 ELF

**Transaction Sequence:**

1. **Query Initial Fee:**
   - Call `GetMethodFee("Create")`
   - Returns: `MethodFees { MethodName = "Create", Fees = [{ Symbol = "ELF", BasicFee = 100_00000000 }] }`

2. **Attempt Fee Configuration:**
   - Governance calls `SetMethodFee(MethodFees { MethodName = "Create", Fees = [{ Symbol = "ELF", BasicFee = 50_00000000 }] })`
   - Returns: `Empty` (success)
   - Expected: Fee updated to 50 ELF
   - Actual: No state change occurred

3. **Verify Fee Update:**
   - Call `GetMethodFee("Create")`
   - Expected: Returns 50 ELF fee
   - **Actual: Still returns 100 ELF fee** (hardcoded value unchanged)

4. **Verify Actual Charging:**
   - User calls NFT `Create` method
   - Token contract's `ChargeTransactionFees` queries `GetMethodFee("Create")`
   - User is charged 100 ELF, not the "configured" 50 ELF

**Success Condition:**
The vulnerability is confirmed when Step 3 returns the original hardcoded value despite Step 2's successful return, proving the state inconsistency and false perception of successful fee updates.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
ï»¿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L21-43)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }

    #region Views

    public override MethodFees GetMethodFee(StringValue input)
    {
        return State.TransactionFees[input.Value];
    }

    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationState.cs (L11-12)
```csharp
    public MappedState<string, MethodFees> TransactionFees { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```

**File:** docs-sphinx/reference/acs/acs1.rst (L231-277)
```text
The easiest way to do this is to just implement the method
``GetMethodFee``.

If there are Foo1, Foo2, Bar1 and Bar2 methods related to business logic
in a contract, they are priced as 1, 1, 2, 2 ELF respectively, and the
transaction fees of these four methods will not be easily modified
later, they can be implemented as follows:

.. code:: c#

   public override MethodFees GetMethodFee(StringValue input)
   {
       if (input.Value == nameof(Foo1) || input.Value == nameof(Foo2))
       {
           return new MethodFees
           {
               MethodName = input.Value,
               Fees =
               {
                   new MethodFee
                   {
                       BasicFee = 1_00000000,
                       Symbol = Context.Variables.NativeSymbol
                   }
               }
           };
       }
       if (input.Value == nameof(Bar1) || input.Value == nameof(Bar2))
       {
           return new MethodFees
           {
               MethodName = input.Value,
               Fees =
               {
                   new MethodFee
                   {
                       BasicFee = 2_00000000,
                       Symbol = Context.Variables.NativeSymbol
                   }
               }
           };
       }
       return new MethodFees();
   }

This implementation can modify the transaction fee only by upgrading the
contract, without implementing the other three interfaces.
```
