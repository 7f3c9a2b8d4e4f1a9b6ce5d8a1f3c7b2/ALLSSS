### Title
Governance Bypass via Malicious AuthorityInfo in Connector Controller Change

### Summary
The `ChangeConnectorController` function validates the new controller's organization existence by calling an arbitrary contract address specified in the input `AuthorityInfo`, without verifying that this contract is a legitimate governance contract (Parliament, Association, or Referendum). An attacker who obtains temporary governance control can set a malicious `AuthorityInfo` pointing to a fake governance contract, permanently bypassing all future governance requirements for connector management operations.

### Finding Description

**Root Cause:**

The `CheckOrganizationExist` function in `TokenConverterContract_ACS1_TransactionFeeProvider.cs` makes an unchecked cross-contract call to whatever address is provided in `authorityInfo.ContractAddress`: [1](#0-0) 

This function blindly trusts the provided `ContractAddress` without validating it's one of the legitimate system governance contracts. An attacker can deploy a malicious contract that implements `ValidateOrganizationExist` and always returns `true`.

**Vulnerable Flow:**

In `ChangeConnectorController`, the validation only checks if an organization exists in the provided contract: [2](#0-1) 

After the malicious `AuthorityInfo` is set, all subsequent authorization checks in `AssertPerformedByConnectorController` only validate `OwnerAddress`, completely ignoring `ContractAddress`: [3](#0-2) 

**Why Protections Fail:**

The default controller correctly points to the Parliament contract: [4](#0-3) 

However, there is no whitelist or validation ensuring that `ContractAddress` in a new `AuthorityInfo` must be one of the three legitimate governance contracts (Parliament, Association, or Referendum). The system assumes any contract implementing `ValidateOrganizationExist` is a valid governance contract.

### Impact Explanation

**Governance Bypass:**
Once a malicious `AuthorityInfo` is set, the attacker gains permanent unauthorized control over critical connector management functions:
- `UpdateConnector` - modify connector weights and virtual balances, manipulating Bancor pricing
- `AddPairConnector` - add unauthorized trading pairs
- `SetFeeRate` - change fee rates to 0 or extreme values
- `ChangeConnectorController` - prevent governance from regaining control

**Economic Damage:**
The attacker can manipulate connector parameters to:
- Drain reserves by setting unfavorable weights
- Manipulate token prices through virtual balance changes
- Eliminate or maximize fees to disrupt the conversion mechanism
- Add malicious token pairs that could be exploited

**Permanence:**
The vulnerability creates irreversible governance loss. Since `AssertPerformedByConnectorController` only checks if `Context.Sender == OwnerAddress` (the attacker's address), legitimate governance cannot reclaim control even through Parliament proposals. The attacker can continuously reset the controller to their address.

**Severity Justification:**
HIGH - This violates the critical governance invariant that "organization thresholds and method-fee provider authority" must be maintained. It allows permanent bypass of all connector governance controls after a single malicious proposal.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Deploy a malicious contract (allowed through standard user contract deployment)
2. Get one Parliament proposal approved (requires majority miner support or key compromise)

**Attack Complexity:**
MEDIUM - The attack requires:
- Creating a simple contract with `ValidateOrganizationExist() returns true`
- Crafting a Parliament proposal with the malicious `AuthorityInfo`
- Waiting for proposal approval and execution

**Feasibility Conditions:**
- Parliament proposal approval is the main barrier
- Once approved, execution is straightforward and deterministic
- No technical obstacles prevent the attack

**Detection Constraints:**
The malicious `AuthorityInfo` would be visible in the proposal parameters, but validators might not recognize the security implication of a non-standard governance contract address. The attack appears as a "legitimate" controller change.

**Economic Rationality:**
The cost is the effort to get one proposal approved. The benefit is permanent control over a critical DeFi component (token converter) that manages significant value in reserves. This is highly profitable for an attacker.

**Probability Assessment:**
While requiring governance compromise, this represents a critical escalation vulnerability. A single malicious proposal (which could result from social engineering, miner key compromise, or emergency situations) leads to permanent, irrecoverable governance loss rather than a limited one-time action.

### Recommendation

**Immediate Mitigation:**

Add validation in `ChangeConnectorController` to whitelist legitimate governance contracts:

```csharp
public override Empty ChangeConnectorController(AuthorityInfo input)
{
    AssertPerformedByConnectorController();
    
    // Whitelist legitimate governance contracts
    var validGovernanceContracts = new[]
    {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validGovernanceContracts.Contains(input.ContractAddress),
        "Controller contract must be a valid governance contract (Parliament, Association, or Referendum)");
    
    Assert(CheckOrganizationExist(input), "new controller does not exist");
    State.ConnectorController.Value = input;
    return new Empty();
}
```

**Comprehensive Fix:**

This vulnerability pattern exists across ALL AElf system contracts using the same `CheckOrganizationExist` pattern. Apply the same fix to:
- `TokenContract.ChangeMethodFeeController`
- `BasicContractZero.ChangeContractDeploymentController`
- `BasicContractZero.ChangeCodeCheckController`
- All other contracts with similar controller change methods

**Test Cases:**

Add regression tests:
1. Test that `ChangeConnectorController` rejects non-governance contract addresses
2. Test that only Parliament, Association, and Referendum contracts are accepted
3. Test that attacker cannot use a custom contract implementing `ValidateOrganizationExist`

### Proof of Concept

**Initial State:**
- ConnectorController points to Parliament default organization
- Attacker has deployed MaliciousGovernance contract with:
  ```csharp
  public BoolValue ValidateOrganizationExist(Address input) 
  { 
      return new BoolValue { Value = true }; 
  }
  ```

**Attack Steps:**

1. **Attacker creates Parliament proposal** with parameters:
   - Target: TokenConverterContract
   - Method: `ChangeConnectorController`
   - Parameters: 
     ```
     AuthorityInfo {
         ContractAddress = MaliciousGovernance,
         OwnerAddress = AttackerAddress
     }
     ```

2. **Proposal gets approved** (via compromised miner or social engineering)

3. **Proposal is executed:**
   - `AssertPerformedByConnectorController()` passes (Context.Sender = Parliament organization)
   - `CheckOrganizationExist()` calls `MaliciousGovernance.ValidateOrganizationExist(AttackerAddress)`
   - Returns `true` (always)
   - `State.ConnectorController.Value` set to malicious AuthorityInfo

4. **Post-Attack State:**
   - Attacker directly calls `UpdateConnector`, `SetFeeRate`, etc.
   - `AssertPerformedByConnectorController()` checks only `Context.Sender == AttackerAddress` âœ“
   - No governance required
   - Legitimate governance cannot reclaim control

**Expected vs Actual:**
- **Expected:** Only legitimate governance organizations can control connector parameters
- **Actual:** Attacker has permanent direct control, governance permanently bypassed

**Success Condition:**
Attacker can successfully call `UpdateConnector(maliciousParams)` without any governance proposal, while legitimate Parliament cannot call `ChangeConnectorController` to fix the issue.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L405-416)
```csharp
    private AuthorityInfo GetDefaultConnectorController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```
