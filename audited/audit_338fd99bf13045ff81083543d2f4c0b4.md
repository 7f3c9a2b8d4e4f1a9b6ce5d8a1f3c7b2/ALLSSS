### Title
Chain ID Collision Enables Side Chain State Overwrite and Token Theft

### Summary
The `CreateSideChain` function derives chain IDs using a hash function with modulo operation that can produce collisions for different serial numbers, and lacks validation to prevent creating a side chain with an existing chain ID. An attacker can pre-compute colliding serial numbers offline, wait for the collision point, and create a malicious side chain that overwrites the state of an existing legitimate side chain, stealing its locked tokens and breaking cross-chain indexing.

### Finding Description

The vulnerability exists in the chain ID generation mechanism used during side chain creation.

**Chain ID Derivation:**
The chain ID is computed from the serial number using a hash-based function that is susceptible to collisions: [1](#0-0) [2](#0-1) 

The `GetHashCode()` method maps long values (2^64) to int values (2^32), then applies modulo 11316496, creating a space with only ~11 million possible chain IDs. This compression guarantees hash collisions exist.

**Collision Proven:**
Test cases explicitly demonstrate that different serial numbers produce identical chain IDs: [3](#0-2) 

**Missing Validation:**
When creating a side chain, the contract increments the serial number, derives the chain ID, and directly overwrites state mappings without checking if the chain ID already exists: [4](#0-3) 

No assertion validates that `State.SideChainInfo[chainId]` is null before assignment at line 154, allowing state overwrite.

**Attack Execution Path:**
1. Attacker computes `GetChainId(M + Context.ChainId)` for all M in range to find collision with existing chain at serial N (where M > N)
2. Attacker submits `RequestSideChainCreation` with malicious parameters
3. Proposal goes through governance approval process
4. When serial number reaches M, attacker calls `ReleaseSideChainCreation`
5. Governance executes `CreateSideChain`, which overwrites state at the colliding chain ID
6. Original chain N's data (`SideChainInfo`, `AcceptedSideChainCreationRequest`, `SideChainInitializationData`, `CurrentSideChainHeight`) is destroyed
7. Locked tokens are reassigned to attacker's proposer address

### Impact Explanation

**Direct Fund Impact:**
- Original chain's locked tokens (stored at virtual address derived from chain ID) become controlled by attacker's proposer address through the overwritten `SideChainInfo.Proposer` field
- When the attacker's malicious chain is later disposed or tokens unlocked, funds go to attacker instead of legitimate owner
- Amount at risk: full `LockedTokenAmount` specified in original chain's creation request

**Cross-Chain Integrity Impact:**
- Cross-chain indexing for the original chain becomes permanently corrupted as `State.SideChainInfo[chainId]` now points to attacker's chain
- Merkle proof verification breaks for original chain's transactions
- `GetMerkleTreeRoot` function returns wrong merkle roots for the overwritten chain ID [5](#0-4) 

**Operational Impact:**
- Original side chain becomes completely inaccessible through parent chain contract
- All view functions return attacker's chain data for the colliding chain ID
- Cross-chain messages between original chain and parent chain fail validation
- Recharge, indexing, and disposal operations target wrong chain

**Severity Justification:**
HIGH severity due to:
- Direct theft of locked tokens (financial loss)
- Complete destruction of side chain functionality (operational failure)
- Permanent cross-chain communication breakdown (integrity violation)
- Multiple critical state mappings simultaneously compromised

### Likelihood Explanation

**Attacker Capabilities:**
- Can compute `ChainHelper.GetChainId` for any serial number offline (deterministic function)
- Can observe current `SideChainSerialNumber` from blockchain state
- Can predict exact chain ID for any future serial number
- Requires standard governance approval but no privileged access

**Attack Complexity:**
- Finding collision: FEASIBLE - Birthday paradox suggests 50% collision probability after ~3,365 side chains (sqrt(11,316,496))
- Offline computation: TRIVIAL - Can pre-compute chain IDs for millions of serial numbers in minutes
- Timing attack: MODERATE - Must submit proposal to execute at exact colliding serial number, requiring coordination with governance approval timing
- No cryptographic hardness prevents collision discovery

**Feasibility Conditions:**
- System must have created at least one side chain (to have a collision target)
- Attacker's malicious proposal must receive governance approval (standard process, no special requirements beyond creating valid-looking proposal)
- Sufficient side chains must be created to reach collision point (or attacker must wait)
- In mature system with many side chains, unintentional collisions become increasingly likely without attacker action

**Detection/Operational Constraints:**
- Collision not detectable until too late (state already overwritten)
- Governance approvers cannot see resulting chain ID in proposal parameters, only see creation request
- No monitoring alerts for chain ID reuse
- Irreversible once executed (state permanently overwritten)

**Probability Reasoning:**
MEDIUM-HIGH likelihood because:
- Collision computation is deterministic and trivial
- No cryptographic barrier prevents finding collisions
- Attack becomes MORE likely as ecosystem grows (more side chains = higher collision probability)
- Only barrier is timing the governance approval, not preventing the collision itself

### Recommendation

**Immediate Mitigation:**
Add explicit uniqueness validation in `CreateSideChain` before any state assignment:

```csharp
// In CreateSideChain function, after line 137
var chainId = GetChainId(serialNumber);
Assert(State.SideChainInfo[chainId] == null, 
    "Chain ID collision detected. Side chain with this ID already exists.");
```

**Long-term Solution:**
Replace the collision-prone hash-based chain ID generation with a guaranteed-unique scheme:

1. Use serial number directly as chain ID (with appropriate encoding)
2. Or use cryptographic hash of `(Context.ChainId, serialNumber, Context.CurrentBlockTime)` with sufficient output bits
3. Or maintain explicit registry of used chain IDs and reject collisions

**Invariant to Enforce:**
- Each chain ID must be unique across all created side chains
- `State.SideChainInfo[chainId]` must be null before creation
- Serial numbers must map bijectively to chain IDs (no collisions)

**Test Cases:**
1. Attempt to create side chain with pre-existing chain ID (should revert)
2. Verify GetChainId produces unique outputs for sequential serial numbers up to reasonable limit (e.g., 100,000)
3. Test collision scenario: if collision found, verify proper rejection
4. Integration test: create multiple side chains and verify no chain ID reuse

### Proof of Concept

**Initial State:**
- Parent chain operational with CrossChain contract deployed
- `State.SideChainSerialNumber.Value = 0`
- `Context.ChainId = PARENT_CHAIN_ID` (known constant, e.g., 9992731)

**Attack Steps:**

**Step 1: Compute Collision Offline**
```
For M = 1 to 1,000,000:
    chainId_M = ChainHelper.GetChainId(M + PARENT_CHAIN_ID)
    Store mapping[chainId_M] = M
    If mapping[chainId_M] already exists with value N (where N < M):
        Found collision: serial N and serial M produce same chainId
        Break
```

**Step 2: Legitimate Chain Created**
- User A calls `RequestSideChainCreation` with 10,000 ELF locked
- Proposal approved, serial number advances to N=1
- Chain ID for serial 1: `chainId_1 = GetChainId(1 + PARENT_CHAIN_ID)`
- `State.SideChainInfo[chainId_1].Proposer = UserA`
- `State.SideChainInfo[chainId_1].LockedTokenAmount = 10000 ELF`

**Step 3: Wait for Collision Point**
- System creates (M-1) more legitimate side chains
- `State.SideChainSerialNumber.Value = M-1`

**Step 4: Attacker Executes**
- Attacker calls `RequestSideChainCreation` with malicious parameters
- Governance approves (proposal looks legitimate)
- Attacker calls `ReleaseSideChainCreation`
- `CreateSideChain` executes with serial M
- Computes: `chainId_M = GetChainId(M + PARENT_CHAIN_ID) = chainId_1` (COLLISION!)

**Step 5: State Overwrite Occurs**
Line 154 executes: `State.SideChainInfo[chainId_1] = maliciousChainInfo`
- Original: `SideChainInfo.Proposer = UserA` 
- Overwritten: `SideChainInfo.Proposer = Attacker`
- UserA's 10,000 ELF locked tokens now associated with Attacker's chain

**Expected Result:**
CreateSideChain should revert with "Chain ID already exists" error

**Actual Result:**
CreateSideChain succeeds and overwrites all state for the colliding chain ID, destroying original chain data and reassigning locked tokens to attacker

**Success Condition:**
After Step 5, calling `GetSideChainCreator(chainId_1)` returns Attacker address instead of UserA address, and UserA's original chain is completely inaccessible.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L355-358)
```csharp
    private int GetChainId(long serialNumber)
    {
        return ChainHelper.GetChainId(serialNumber + Context.ChainId);
    }
```

**File:** src/AElf.Types/Helper/ChainHelper.cs (L9-24)
```csharp
        public static int GetChainId(long serialNumber)
        {
            // For 4 base58 chars use following range (2111 ~ zzzz):
            // Max: 57*58*58*58+57*58*58+57*58+57 = 11316496 (zzzz)
            // Min: 1*58*58*58+0*58*58+0*58+0 = 195112 (2111)
            var validNUmber = (uint)serialNumber.GetHashCode() % 11316496;
            if (validNUmber < 195112)
                validNUmber += 195112;

            var validNUmberBytes = validNUmber.ToBytes().Skip(1).ToArray();

            // Use BigInteger(BigEndian) format (bytes size = 3)
            Array.Resize(ref validNUmberBytes, 4);

            return validNUmberBytes.ToInt32(false);
        }
```

**File:** test/AElf.Types.Tests/Helper/ChainHelperTests.cs (L37-38)
```csharp
            var chainIdMinValue = ChainHelper.GetChainId(long.MinValue);
            chainIdMinValue.ShouldBe(chainIdMaxValue);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L135-159)
```csharp
        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
        var chainId = GetChainId(serialNumber);
        State.AcceptedSideChainCreationRequest[chainId] = sideChainCreationRequest;

        // lock token
        ChargeSideChainIndexingFee(input.Proposer, sideChainCreationRequest.LockedTokenAmount, chainId);

        var sideChainInfo = new SideChainInfo
        {
            Proposer = input.Proposer,
            SideChainId = chainId,
            SideChainStatus = SideChainStatus.Active,
            IndexingPrice = sideChainCreationRequest.IndexingPrice,
            IsPrivilegePreserved = sideChainCreationRequest.IsPrivilegePreserved,
            CreationTimestamp = Context.CurrentBlockTime,
            CreationHeightOnParentChain = Context.CurrentHeight,
            IndexingFeeController = CreateDefaultOrganizationForIndexingFeePriceManagement(input.Proposer)
        };
        State.SideChainInfo[chainId] = sideChainInfo;
        State.CurrentSideChainHeight[chainId] = 0;

        var chainInitializationData =
            GetChainInitializationData(sideChainInfo, sideChainCreationRequest);
        State.SideChainInitializationData[sideChainInfo.SideChainId] = chainInitializationData;
```
