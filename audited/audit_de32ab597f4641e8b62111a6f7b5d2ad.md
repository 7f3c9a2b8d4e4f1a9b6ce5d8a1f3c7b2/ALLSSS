### Title
Accounting Error in Recharge Function Allows Insufficient Balance to Mark Side Chain as Active

### Summary
The `Recharge()` function contains an accounting error in its balance validation check that double-counts the recharged amount. This allows a side chain with indexing fee debt to be marked as Active with insufficient balance, violating the critical invariant that an Active side chain must have at least `IndexingPrice` in its deposit to pay for indexing operations.

### Finding Description

The vulnerability exists in the `Recharge()` function where the balance validation check incorrectly calculates the required recharge amount. [1](#0-0) 

**Root Cause:**

The function follows this execution flow:
1. User transfers `input.Amount` tokens to the side chain's virtual address
2. If the side chain has `IndexingFeeDebt` status, arrears are paid to proposers from the virtual address
3. The balance check at line 207 reads: `input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice`

The critical error is that `originBalance` is obtained AFTER the arrears transfers have already been deducted from the virtual address balance. Therefore:
- `originBalance = GetSideChainIndexingFeeDeposit(chainId)` returns the current balance = `initial_balance + input.Amount - arrearsAmount`
- The assertion becomes: `input.Amount + (initial_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice`
- Simplifying: `2 * input.Amount + initial_balance >= 2 * arrearsAmount + IndexingPrice`

This double-counts `input.Amount`, making the check more lenient than intended. The correct check should be:
- `initial_balance + input.Amount >= arrearsAmount + IndexingPrice`
- Or equivalently: `originBalance >= IndexingPrice` (since originBalance already reflects the recharged and spent amounts) [2](#0-1) 

**Why Existing Protection Fails:**

The `GetSideChainIndexingFeeDeposit()` function correctly retrieves the current balance, but the assertion logic incorrectly adds `input.Amount` again instead of just checking if the remaining balance is sufficient.

### Impact Explanation

**Direct Impact:**
- Side chains can be marked as Active with insufficient funds (balance < IndexingPrice)
- Breaks the critical accounting invariant that Active side chains must be able to pay for at least one indexing operation
- Indexers who propose blocks for such under-funded side chains will not receive payment and will accumulate new arrears

**Quantified Damage:**
Using a concrete example:
- If `arrearsAmount = 100` and `IndexingPrice = 10`
- Correct requirement: recharge with 110 tokens (100 for arrears + 10 for minimum balance)
- With bug: only need to recharge with 105 tokens
- Result: side chain marked Active with balance of 5, unable to pay the required 10 per indexing operation
- Underfunding gap: ~4.5% to 25% depending on the ratio of arrears to indexing price

**Affected Parties:**
- Side chain operators who believe their chain is properly funded
- Block proposers/indexers who won't receive indexing fees for Active chains
- Protocol integrity as the Active status becomes unreliable [3](#0-2) 

When indexing is attempted on an under-funded Active side chain, it immediately reverts to `IndexingFeeDebt` status, accumulating more arrears instead of paying the proposer.

### Likelihood Explanation

**Reachable Entry Point:**
The `Recharge()` function is a public method callable by any user holding the side chain's token allowance. No special privileges required.

**Feasible Preconditions:**
1. A side chain must be in `IndexingFeeDebt` status (occurs naturally when balance depletes during indexing)
2. User must have tokens and set allowance for the CrossChain contract
3. Both conditions are common and expected in normal operations

**Execution Practicality:**
The exploit requires only a single transaction calling `Recharge()` with a calculated amount that satisfies the buggy check but leaves insufficient balance. No complex multi-transaction sequences or race conditions involved.

**Economic Rationality:**
An attacker (or simply a careless user) can save 5-25% of the required recharge amount by exploiting this bug. For large arrears or high indexing prices, this represents significant value. The exploit cost is minimal (just transaction fees).

**Detection:**
The bug is not easily detectable as:
- The transaction succeeds without reverting
- The side chain status changes to Active as "expected"
- The accounting error only manifests on the next indexing attempt

### Recommendation

**Code-Level Mitigation:**

Replace the assertion at line 207 with one of the following correct checks:

Option 1 (Check remaining balance directly):
```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

Option 2 (Check total before transfers):
```csharp
var initialBalance = GetSideChainIndexingFeeDeposit(chainId);
// Perform transfers in loop...
Assert(input.Amount + initialBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

**Invariant Checks to Add:**
1. Add assertion after setting status to Active: `Assert(GetSideChainIndexingFeeDeposit(chainId) >= sideChainInfo.IndexingPrice, "Insufficient balance for Active status")`
2. Add pre-condition check in `IndexSideChainBlockData()` to verify Active chains have sufficient balance before indexing

**Test Cases:**
1. Test recharge with exact minimum amount (arrears + IndexingPrice)
2. Test recharge with amount just below minimum (should fail)
3. Test that Active status guarantees at least one indexing operation can be paid
4. Test the edge case where arrearsAmount is large relative to IndexingPrice

### Proof of Concept

**Initial State:**
- Side chain created with `lockedToken = 100`, `IndexingPrice = 10`
- 10 blocks indexed, consuming all 100 tokens (10 × 10 = 100)
- 1 additional block indexed with insufficient balance
- Status: `IndexingFeeDebt`
- `ArrearsInfo[proposer] = 10` (one block's worth unpaid)
- Virtual address balance: 0

**Exploitation Steps:**

1. User calls `Recharge()` with `input.Amount = 15` tokens
   - Correct requirement: 10 (arrears) + 10 (minimum balance) = 20 tokens
   - Buggy check allows: 15 tokens

2. Execution flow:
   - Transfer 15 tokens to virtual address → balance = 15
   - Pay arrears: transfer 10 to proposer → balance = 5
   - `originBalance = GetSideChainIndexingFeeDeposit() = 5`
   - Check: `15 + 5 >= 10 + 10` → `20 >= 20` ✓ **PASSES** (incorrectly)
   - Status set to `Active`
   - `ArrearsInfo` cleared

**Expected Result:**
Transaction should revert with "Indexing fee recharging not enough" because final balance (5) < IndexingPrice (10)

**Actual Result:**
Transaction succeeds, side chain marked as Active with balance of 5 tokens

**Success Condition (Demonstrating Bug):**
1. Query side chain status → Returns `Active`
2. Query balance → Returns 5
3. Attempt to index one block (requires 10 tokens)
4. Side chain immediately reverts to `IndexingFeeDebt` status
5. New arrears accumulate for the proposer

This proves the accounting invariant is violated: an Active side chain exists with insufficient funds to pay for even a single indexing operation.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-893)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            long arrearsAmount = 0;
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }

            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
            
            Context.Fire(new SideChainIndexed
            {
                ChainId = chainId,
                IndexedHeight = currentSideChainHeight
            });
        }

        if (indexedSideChainBlockData.Count > 0)
            Context.LogDebug(() =>
                $"Last indexed height {indexedSideChainBlockData.Last().Height} for side chain {chainId}");

        return indexedSideChainBlockData;
    }
```
