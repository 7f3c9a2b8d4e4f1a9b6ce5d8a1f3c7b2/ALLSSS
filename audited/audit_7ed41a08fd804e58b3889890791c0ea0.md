### Title
Weak Referendum Thresholds Enable Parliament to Bypass Community Consensus for User Fee Changes

### Summary
The referendum organization controlling user fee changes is initialized with minimal thresholds requiring only 1 token for approval and 0 maximum for rejection/abstention. While any token holder can theoretically block proposals, parliament controls proposal creation and timing, enabling user fee changes to pass with minimal community participation rather than the intended "broader community consensus."

### Finding Description

The `GetReferendumControllerCreateInputForUserFee()` function creates a referendum organization with critically weak thresholds: [1](#0-0) 

The proposal release threshold logic validates these values are sufficient to pass proposals: [2](#0-1) 

With `MinimalApprovalThreshold = 1` and `MinimalVoteThreshold = 1`, a proposal passes if at least 1 token is locked for approval. With `MaximalRejectionThreshold = 0` and `MaximalAbstentionThreshold = 0`, any rejection or abstention vote blocks the proposal.

However, parliament exclusively controls proposal creation through the whitelist: [3](#0-2) [4](#0-3) 

Anyone can vote by locking tokens, but there is no minimum expiration time requirement: [5](#0-4) 

The validation only requires thresholds greater than 0, allowing the value of 1: [6](#0-5) 

The UserFeeController requires both parliament AND referendum approval through an Association: [7](#0-6) 

### Impact Explanation

**Governance Bypass:** Parliament can approve user fee changes affecting all network transactions with only 1 token of approval, fundamentally undermining the referendum layer's purpose of ensuring community consensus.

**Economic Impact:** User fee coefficients control transaction costs across the entire blockchain. Malicious manipulation could:
- Extract value by raising fees excessively
- DoS the network with prohibitive transaction costs
- Favor certain transaction types over others unfairly

**Affected Parties:** All users and applications on the AElf blockchain depend on fair, community-approved fee structures.

**Severity Justification:** HIGH - This is a critical governance design flaw enabling centralization of power over a protocol-wide economic parameter that should require broad stakeholder consensus.

### Likelihood Explanation

**Attacker Capabilities:** Parliament (default organization) controls proposal creation and only needs access to 1 token for approval voting.

**Attack Complexity:** LOW
1. Parliament creates Association proposal for malicious user fee change
2. Parliament approves via its own governance process
3. Parliament creates Referendum proposal with short expiration time
4. Parliament or ally locks 1 token and approves Referendum proposal  
5. If no token holder detects and blocks before expiration, all proposals can be released
6. Malicious fee change takes effect

**Feasibility Conditions:**
- Parliament controls timing and visibility of proposals
- No notification mechanism alerts token holders to new proposals
- No minimum expiration time requirement allows rapid execution
- Community must actively monitor blockchain to detect and block proposals

**Detection Constraints:** Requires continuous on-chain monitoring by token holders. Short expiration windows (e.g., seconds) make detection and response difficult.

**Probability:** MEDIUM-HIGH - While token holders have veto power theoretically, the asymmetric information and timing control gives parliament practical ability to pass changes with minimal oversight if community monitoring lapses.

### Recommendation

**Immediate Fix:** Update `GetReferendumControllerCreateInputForUserFee()` to set meaningful thresholds:

```csharp
ProposalReleaseThreshold = new ProposalReleaseThreshold
{
    MinimalApprovalThreshold = 10000000, // e.g., 10M tokens minimum
    MinimalVoteThreshold = 15000000,     // e.g., 15M tokens minimum quorum  
    MaximalRejectionThreshold = 5000000,  // e.g., 5M tokens can block
    MaximalAbstentionThreshold = 5000000  // e.g., 5M tokens can block
}
```

**Invariant Checks:**
- Enforce minimum approval threshold as percentage of total token supply (e.g., 5%)
- Enforce minimum vote threshold as quorum requirement (e.g., 10% of supply)
- Add minimum expiration time for referendum proposals (e.g., 7 days)

**Test Cases:**
- Verify proposal with only 1 token approval cannot pass with new thresholds
- Verify proposals require genuine community participation to pass
- Test that short expiration times are rejected
- Add monitoring tests for proposal creation events

### Proof of Concept

**Initial State:**
- Parliament controls default organization
- UserFeeController initialized with weak referendum thresholds
- Token holders not actively monitoring proposals

**Attack Steps:**

1. Parliament creates proposal in Association (RootController) to change `UpdateCoefficientsForSender` to malicious values

2. Parliament creates proposal in Parliament organization to approve the Association proposal

3. Parliament approves and releases the Parliament proposal

4. Parliament creates proposal in Referendum organization to approve the Association proposal (only parliament can propose due to whitelist) [8](#0-7) 

5. Parliament or ally approves 1 token to proposal's virtual address and votes approve: [9](#0-8) 

6. Set short expiration (e.g., 60 seconds) so proposal expires before community can react

7. Parliament releases referendum proposal after 1 token approval: [10](#0-9) 

8. Association proposal now has both parliament and referendum approval

9. Parliament releases Association proposal, executing the malicious user fee change

**Expected Result:** Community should require meaningful participation (thousands/millions of tokens) before user fee changes take effect

**Actual Result:** Proposal passes with only 1 token approval if no token holder notices and votes reject/abstain before the short expiration window

**Success Condition:** Malicious user fee coefficients are applied to the contract, affecting all subsequent transactions

### Notes

The test suite demonstrates this minimal approval flow working as designed: [11](#0-10) 

While the design provides token holders with theoretical veto power, the practical implementation favors parliament control over community consensus due to asymmetric information, timing control, and lack of participation requirements.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L136-136)
```csharp
        var whiteList = new List<Address> { parliamentAddress };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L143-149)
```csharp
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L158-184)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetAssociationControllerCreateInputForUserFee(
        Address parliamentAddress, Address referendumAddress)
    {
        var proposers = new List<Address>
            { referendumAddress, parliamentAddress };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-59)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L70-83)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        var organization = State.Organizations[proposal.OrganizationAddress];
        var allowance = GetAllowance(Context.Sender, organization.TokenSymbol, input);

        proposal.ApprovalCount = proposal.ApprovalCount.Add(allowance);
        State.Proposals[input] = proposal;
        var referendumReceiptCreated = LockToken(organization.TokenSymbol, allowance, input, Context.Sender,
            proposal.OrganizationAddress);
        referendumReceiptCreated.ReceiptType = nameof(Approve);
        Context.Fire(referendumReceiptCreated);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractReferenceFeeTest.cs (L918-962)
```csharp
    private async Task VoteToReferendumAsync(Hash input, string primaryTokenSymbol)
    {
        var organizations = await GetControllerForUserFeeAsync();

        var referendumProposal = new CreateProposalInput
        {
            ToAddress = AssociationContractAddress,
            Params = input.ToByteString(),
            OrganizationAddress = organizations.ReferendumController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Approve),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };

        var parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposal.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.CreateProposal),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        var ret = await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
        var referendumProposalId = ProposalCreated.Parser
            .ParseFrom(ret.Logs.First(l => l.Name.Contains(nameof(ProposalCreated)))
                .NonIndexed).ProposalId;
        var proposalVirtualAddress =
            await ReferendumContractStub.GetProposalVirtualAddress.CallAsync(referendumProposalId);
        var approveResult = await TokenContractStub.Approve.SendAsync(new ApproveInput
        {
            Spender = proposalVirtualAddress,
            Symbol = primaryTokenSymbol,
            Amount = 100000
        });
        await ReferendumContractStub.Approve.SendAsync(referendumProposalId);

        parliamentProposal = new CreateProposalInput
        {
            ToAddress = ReferendumContractAddress,
            Params = referendumProposalId.ToByteString(),
            OrganizationAddress = organizations.ParliamentController.OwnerAddress,
            ContractMethodName = nameof(AuthorizationContractContainer.AuthorizationContractStub.Release),
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1)
        };
        await MainChainTesterCreatApproveAndReleaseProposalForParliamentAsync(parliamentProposal);
    }
```
