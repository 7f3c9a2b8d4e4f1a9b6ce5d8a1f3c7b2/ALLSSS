# Audit Report

## Title
Missing Token Name Length Validation in Cross-Chain Token Creation Allows Storage DoS

## Summary
The `CrossChainCreateToken` function bypasses the 80-character TokenName length validation enforced in the normal `Create` flow, allowing tokens with extremely long names (up to ~100KB within the 128KB state size limit) to be registered from whitelisted cross-chains, causing storage bloat and potential DoS.

## Finding Description
The vulnerability exists due to inconsistent validation across two token registration paths:

**Normal Create Path (Protected):**
The `CreateToken` method calls `AssertValidCreateInput` which enforces the TokenName length constraint. [1](#0-0) 

The constant `TokenNameLength` is defined as 80 characters. [2](#0-1) 

**Cross-Chain Create Path (Vulnerable):**
The `CrossChainCreateToken` method creates a `TokenInfo` object directly from cross-chain data and passes it to `RegisterTokenInfo` without any length validation. [3](#0-2) 

**Root Cause:**
The `RegisterTokenInfo` function only validates that TokenName is not null or empty but never checks its length, relying entirely on upstream callers to perform this validation. [4](#0-3) 

**Why State Size Limit Is Insufficient:**
While AElf enforces a 128KB state size limit [5](#0-4) , this only provides an upper bound. It still allows TokenName values approximately 1,250x larger than the intended 80 bytes (~100KB vs 80 bytes), violating defense-in-depth principles. The state size validation occurs at the VM level but does not enforce contract-specific business logic constraints.

## Impact Explanation
**Storage Bloat:** Each malicious token can consume ~100KB for TokenName instead of the intended 80 bytes, a ~1,250x increase per token.

**Cumulative DoS:** An attacker controlling a compromised whitelisted source chain can register multiple such tokens, causing cumulative storage consumption that stresses node storage infrastructure.

**Expensive Operations:** Reading/writing `TokenInfo` objects with extremely large TokenName fields increases gas costs proportionally, degrading contract performance and user experience.

**State Database Stress:** Large state entries burden the underlying storage layer (Redis/SSDB), affecting overall blockchain performance.

**Quantified Impact:** A single token with 100KB TokenName consumes ~131,000 excess bytes. Ten such tokens = ~1.3MB excess storage, with proportionally higher gas costs for all token operations involving these TokenInfo objects.

**Affected Parties:** Node operators (storage costs), contract users (higher gas fees), protocol (state bloat).

## Likelihood Explanation
**Prerequisites:**
1. Source chain must be whitelisted via Parliament governance [6](#0-5) 
2. Source chain must be compromised, have a validation bug, or run a different contract version allowing oversized TokenName
3. Attacker must execute cross-chain token creation with valid merkle proof verification [7](#0-6) 

**Likelihood Assessment:** Medium-Low. Requires compromising or exploiting a trusted whitelisted source chain, which has governance controls. However, defense-in-depth principles suggest the receiving chain should independently validate all inputs regardless of source trust, making this a valid security concern.

**Feasibility:** Executable if preconditions are met. While whitelisted chains are presumed trustworthy, cross-chain integrations inherently involve external trust boundaries where validation should occur.

## Recommendation
Add TokenName length validation in `RegisterTokenInfo` or create a dedicated validation method called by both `CreateToken` and `CrossChainCreateToken`:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
    Assert(tokenInfo.TokenName.Length <= TokenContractConstants.TokenNameLength, 
        "Token name exceeds maximum length.");
    Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
    Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
    Assert(tokenInfo.Owner != null, "Invalid owner address.");
    State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
    State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
}
```

This ensures consistent validation across all token creation paths, preventing storage bloat from any source including cross-chain operations.

## Proof of Concept
A full end-to-end PoC requires a multi-chain test environment with:
1. A source chain with modified token contract allowing >80 character TokenName
2. Whitelisting the source chain's token contract address
3. Creating an oversized-name token on the source chain
4. Generating and submitting a valid `ValidateTokenInfoExists` transaction with merkle proof
5. Calling `CrossChainCreateToken` on destination chain

The vulnerability is evident from code inspection: `CrossChainCreateToken` (lines 478-534) constructs a `TokenInfo` with unvalidated `TokenName` from cross-chain input (line 495) and calls `RegisterTokenInfo` (line 508), which lacks length validation (line 228 only checks not empty). This contrasts with the normal `CreateToken` path which enforces the 80-character limit (line 274) before calling `RegisterTokenInfo`.

**Notes**
This is a defense-in-depth violation at a trust boundary. While the state size limit (128KB) provides an absolute upper bound, it does not enforce the intended business logic constraint of 80 characters. Cross-chain validation should mirror local validation to prevent external dependencies from violating protocol invariants. The likelihood is correctly assessed as Medium-Low due to requiring source chain compromise, but the impact is real and measurable.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L228-228)
```csharp
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L274-274)
```csharp
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L5-5)
```csharp
    public const int TokenNameLength = 80;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-482)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L488-488)
```csharp
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-508)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
