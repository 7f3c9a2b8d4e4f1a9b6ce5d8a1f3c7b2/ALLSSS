### Title
Inconsistent Profit Detail Matching Logic Causes Welfare Misattribution in Multi-Vote Scenarios

### Summary
The `GetProfitDetailByElectionVotingRecord()` function uses `LastOrDefault` for old-style profit detail matching, while `FixProfitDetail` uses `FirstOrDefault(OrderBy StartPeriod)`. When a voter has multiple old-style votes with identical shares (weight), calling `ChangeVotingOption` with `IsResetVotingTime=true` will validate against one profit detail but extend a different one, causing misattribution of welfare profit entitlement and financial loss to the voter.

### Finding Description

**Root Cause:**
The Election contract contains backwards compatibility code for "old world" profit details where the `Id` field is null. [1](#0-0) 

Two different matching strategies are used:

1. **GetProfitDetailByElectionVotingRecord** - Returns the LAST profit detail matching shares: [2](#0-1) 

2. **FixProfitDetail** (Profit contract) - Returns the FIRST profit detail (ordered by StartPeriod) matching shares: [3](#0-2) 

**Execution Path:**
When `ChangeVotingOption` is called with `IsResetVotingTime=true`: [4](#0-3) 

It calls `ExtendVoterWelfareProfits`, which:
1. Calls `GetProfitDetailByElectionVotingRecord` to validate a matching detail exists (returns last)
2. Calls `FixProfitDetail` to extend the detail (extends first by StartPeriod) [5](#0-4) 

**Why Protections Fail:**
The null check at line 141 only validates that SOME profit detail with matching shares exists, but doesn't ensure the SAME detail will be extended by `FixProfitDetail`. The `ProfitDetailId` parameter passed to `FixProfitDetail` fails to match (old details have null Id), causing fallback to shares-based matching which uses different logic.

### Impact Explanation

**Concrete Financial Harm:**
- Voter loses welfare profit entitlement on Vote B (intended vote) for multiple periods
- Voter gains unintended welfare profit entitlement on Vote A (wrong vote) for multiple periods  
- Net impact depends on the relative EndPeriods and timing, but represents misallocation of Treasury welfare funds

**Affected Parties:**
- Any voter with multiple old-style votes having identical weight (same token amount and lock duration)
- The welfare profit scheme experiences incorrect share distribution

**Quantified Impact:**
If Vote B should extend from period 24→32 (8 periods) but Vote A extends from period 22→32 (10 periods) instead:
- Vote B loses 8 periods of welfare profit claiming rights
- Vote A gains 10 periods it shouldn't have
- The misattribution affects the voter's entitled welfare token distribution per period

**Severity Justification:**
Medium severity - Direct financial impact on welfare distribution with concrete misallocation, but limited to voters' own profit details (not theft from others) and requires specific preconditions.

### Likelihood Explanation

**Attacker Capabilities:**
Any voter can trigger this by calling the public `ChangeVotingOption` method. No special privileges required.

**Preconditions:**
1. Old-style profit details must exist (from pre-upgrade system where ProfitDetailId was not set)
2. Voter must have multiple active votes with identical weight (Shares)
3. Voter calls `ChangeVotingOption` with `IsResetVotingTime=true`

**Feasibility:**
The code explicitly includes backwards compatibility for "the old world" [6](#0-5) , indicating old-style profit details were expected to exist in production. Multiple votes with same weight are realistic (voter stakes same amount for same duration multiple times).

**Detection:**
Test coverage doesn't validate the old-style multi-vote scenario. The existing test creates 3 votes with identical parameters but uses new-style profit details (with Id set). [7](#0-6) 

**Probability:**
Medium - If the system was upgraded and had existing votes, old-style details would exist. The bug is deterministic once conditions are met.

### Recommendation

**Code-Level Mitigation:**
Unify the matching logic between `GetProfitDetailByElectionVotingRecord` and the Profit contract's fallback mechanism. Change line 181 to use consistent ordering:

```csharp
// Change from:
profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);

// To (matching FixProfitDetail's strategy):
profitDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
    .FirstOrDefault(d => d.Shares == electionVotingRecord.Weight);
```

**Invariant Checks:**
1. Assert the returned profit detail from `GetProfitDetailByElectionVotingRecord` has properties matching the target vote
2. Add validation in `FixProfitDetail` to verify StartPeriod consistency when matching by Shares

**Migration Strategy:**
For existing old-style profit details, run a one-time migration to populate the `Id` field with the associated `voteId`, eliminating reliance on shares-based matching.

**Test Cases:**
Add test coverage for:
1. Multiple old-style votes (Id=null) with identical Shares values
2. ChangeVotingOption on different votes in sequence
3. Verify correct profit detail gets extended (match by StartPeriod or creation order)

### Proof of Concept

**Initial State:**
1. System contains old-style profit details from pre-upgrade period
2. Voter creates Vote A: 100 tokens, 365 days lock → Weight=1000, ProfitDetail_A (Id=null, StartPeriod=10, EndPeriod=22)
3. Voter creates Vote B: 100 tokens, 365 days lock → Weight=1000, ProfitDetail_B (Id=null, StartPeriod=15, EndPeriod=27)
4. Treasury CurrentPeriod = 20

**Transaction Steps:**
1. Voter calls `ChangeVotingOption(voteId=B, candidatePubkey=X, isResetVotingTime=true)`
2. `ExtendVoterWelfareProfits(voteId=B)` is invoked
3. `GetProfitDetailByElectionVotingRecord` returns ProfitDetail_B (LastOrDefault)
4. Null check passes
5. `FixProfitDetail(voteId=B, Shares=1000, EndPeriod=32)` is called
6. `FixProfitDetail` matches by Shares, OrderBy StartPeriod → returns ProfitDetail_A (StartPeriod=10 < 15)
7. ProfitDetail_A.EndPeriod extended from 22 → 32
8. ProfitDetail_B.EndPeriod remains 27 (NOT extended)

**Expected vs Actual:**
- **Expected:** Vote B's profit detail extended to period 32, allowing welfare profit claims until period 32
- **Actual:** Vote A's profit detail extended to period 32, while Vote B's remains at period 27

**Success Condition:**
Query `GetProfitDetails` for the voter and observe ProfitDetail_A has EndPeriod=32 while ProfitDetail_B has EndPeriod=27, despite Vote B being the target of the extension operation.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-43)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
        else
        {
            // false, no change for EndPeroid
            State.LockTimeMap[input.VoteId] = State.LockTimeMap[input.VoteId].Sub(actualLockedSeconds);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L140-154)
```csharp
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L176-182)
```csharp
        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L284-289)
```csharp
        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }
```

**File:** test/AElf.Contracts.Election.Tests/Full/ChangeVotingOptionTests.cs (L22-26)
```csharp
        for (var i = 0; i < 3; i++)
        {
            await VoteToCandidateAsync(VoterKeyPairs[0], CoreDataCenterKeyPairs[0].PublicKey.ToHex(), 20 * 86400,
                10);
        }
```
