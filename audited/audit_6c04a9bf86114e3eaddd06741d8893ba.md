### Title
Missing Validation of ExtraBlockProducerOfPreviousRound Allows Manipulation of Block Producer Privileges

### Summary
The `ValidationForNextRound()` function fails to validate that the `ExtraBlockProducerOfPreviousRound` field matches the actual block producer, allowing any miner to arbitrarily set this value when creating a NextRound block. This manipulated field is then used to grant unauthorized mining privileges before the round start time and additional tiny block production quota, directly affecting block producer selection and consensus fairness.

### Finding Description

The vulnerability exists in the round transition validation logic. When a miner produces a block to transition to the next round, the `ExtraBlockProducerOfPreviousRound` field is included in the `NextRoundInput` structure: [1](#0-0) 

The validation performed by `ValidationForNextRound()` only checks round number increment and that InValues are null, but **does not validate** that `ExtraBlockProducerOfPreviousRound` matches the actual sender: [2](#0-1) 

The validation service applies validators based on consensus behavior, including `RoundTerminateValidationProvider` for NextRound transitions: [3](#0-2) 

When processing the NextRound input, the system simply converts it to a Round object via `ToRound()`, which **directly copies** the unvalidated field: [4](#0-3) [5](#0-4) 

The manipulated field is then used in two critical consensus functions to grant special privileges:

1. **Mining permission before round start**: The `IsCurrentMiner()` function allows the `ExtraBlockProducerOfPreviousRound` to mine before the round officially begins: [6](#0-5) 

2. **Additional tiny block quota**: The consensus behavior provider grants extra tiny blocks beyond normal limits to the `ExtraBlockProducerOfPreviousRound`: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation**: An attacker can manipulate which miner receives privileged block production rights, breaking the fundamental fairness of the AEDPoS consensus mechanism. This affects:

1. **Unauthorized Mining Windows**: Setting the field to their own pubkey (when they shouldn't be the extra block producer) grants them permission to mine during the pre-round period, a time slot they should not have access to.

2. **Additional Block Production Quota**: The attacker or their chosen pubkey receives `_maximumBlocksCount + blocksBeforeCurrentRound` tiny blocks instead of the normal `_maximumBlocksCount` limit, allowing significantly more block production.

3. **Reward Misallocation**: More blocks produced means more mining rewards, directly impacting the economics and fairness of reward distribution among miners.

4. **Block Producer Selection Manipulation**: By granting unauthorized miners extra time slots and quotas, the attacker can influence which miners produce blocks and when, undermining the consensus schedule integrity.

5. **Chain-wide Impact**: This affects all participants in the network as it compromises the deterministic and fair nature of block production scheduling.

### Likelihood Explanation

**HIGH Likelihood**:

- **Reachable Entry Point**: Any miner can execute the `NextRound` public RPC method when producing the extra block that terminates a round.

- **Minimal Attacker Capabilities**: The attacker only needs to be a valid miner in the current round to execute this exploit - no special permissions or compromised keys required.

- **Trivial Execution**: The attack is as simple as setting the `ExtraBlockProducerOfPreviousRound` field to any desired pubkey (including their own or another miner's) when constructing the `NextRoundInput` in their consensus client.

- **No Additional Barriers**: The validation logic has a clear gap - no validator checks this field against the actual sender or previous round state.

- **Immediate Benefit**: The attacker gains extra mining privileges in the very next round, providing immediate economic incentive.

- **Low Detection Risk**: Since the field is accepted without validation, the manipulation appears as valid consensus data in the blockchain state.

### Recommendation

Add validation in `ValidationForNextRound()` to verify that `ExtraBlockProducerOfPreviousRound` matches the actual sender:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };
    
    // Validate InValues are null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate ExtraBlockProducerOfPreviousRound matches sender
    var senderPubkey = extraData.SenderPubkey.ToHex();
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != senderPubkey)
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match the block producer." };
    
    return new ValidationResult { Success = true };
}
```

Additionally, add similar validation in `ValidationForNextTerm()` since term transitions also set this field: [9](#0-8) 

**Test cases to add**:
1. Verify NextRound transaction fails if ExtraBlockProducerOfPreviousRound doesn't match sender
2. Verify NextTerm transaction fails if ExtraBlockProducerOfPreviousRound doesn't match sender  
3. Verify miners cannot gain unauthorized pre-round mining privileges
4. Verify tiny block quota calculations respect proper extra block producer

### Proof of Concept

**Initial State**:
- Current round has miners [A, B, C, D, E] with miner C as the designated extra block producer
- Round is about to terminate

**Attack Sequence**:

1. **Attacker (Miner B) produces NextRound block**:
   - Miner B produces the extra block to terminate the round (legitimate action)
   - When constructing the `NextRoundInput`, Miner B sets:
     - `ExtraBlockProducerOfPreviousRound = "B"` (their own pubkey)
   - Or alternatively sets it to a colluding miner's pubkey

2. **Validation passes** (current code):
   - `MiningPermissionValidationProvider` checks B is in miner list ✓
   - `TimeSlotValidationProvider` checks time slot is valid ✓
   - `NextRoundMiningOrderValidationProvider` checks mining orders ✓
   - `RoundTerminateValidationProvider.ValidationForNextRound()` checks:
     - Round number incremented ✓
     - InValues are null ✓
     - **MISSING**: No check on ExtraBlockProducerOfPreviousRound

3. **Block is accepted and state updated**:
   - `ProcessNextRound()` accepts the manipulated input
   - New round is stored with `ExtraBlockProducerOfPreviousRound = "B"`

4. **Exploitation of privileges**:
   - In the new round, before round start time, `IsCurrentMiner()` returns true for Miner B
   - Miner B can produce blocks in the pre-round period (unauthorized)
   - Miner B receives additional tiny block quota: `_maximumBlocksCount + blocksBeforeCurrentRound` instead of normal `_maximumBlocksCount`
   - Miner B produces more blocks and earns more rewards

**Expected Result**: Transaction should be rejected with validation error: "ExtraBlockProducerOfPreviousRound must match the block producer."

**Actual Result**: Transaction succeeds, granting Miner B unauthorized mining privileges and breaking consensus fairness.

### Citations

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L149-155)
```csharp
        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```
