### Title
Stale Beneficiaries Due to Custom Profits Receiver Address Changes in Treasury Reward Distribution

### Summary
The Treasury contract's reward weight update functions (`UpdateBasicMinerRewardWeights`, `UpdateWelcomeRewardWeights`, and `UpdateFlexibleRewardWeights`) use the current profits receiver mapping to remove beneficiaries that were added with historical receiver addresses. When a miner changes their custom profits receiver between reward distributions, the removal targets the new receiver address instead of the old one, leaving the old receiver as a permanent stale beneficiary that continues to drain rewards indefinitely.

### Finding Description

The vulnerability exists in three reward update functions that follow the same flawed pattern. In `UpdateBasicMinerRewardWeights`, beneficiaries are removed using `GetAddressesFromCandidatePubkeys` [1](#0-0) 

The `GetAddressesFromCandidatePubkeys` function returns both the pubkey-derived address and the result of `GetProfitsReceiver` [2](#0-1) 

The `GetProfitsReceiver` function returns the CURRENT value from `State.ProfitsReceiverMap[pubkey]` [3](#0-2) 

When beneficiaries are added, they use `GetProfitsReceiver(i.Pubkey)` which captures the receiver address at that point in time [4](#0-3) 

The root cause is that when a miner changes their custom receiver via `SetProfitsReceiver`, it updates `State.ProfitsReceiverMap[input.Pubkey]` [5](#0-4)  but does NOT update the Treasury's reward schemes (BasicReward, VotesWeightReward, ReElectionReward). It only notifies the Election contract for the Subsidy scheme [6](#0-5) 

The Profit contract's `RemoveBeneficiary` function silently fails if the beneficiary address doesn't exist in the profit details map [7](#0-6) 

The same vulnerability pattern exists in `UpdateWelcomeRewardWeights` [8](#0-7)  and `UpdateFlexibleRewardWeights` [9](#0-8) 

### Impact Explanation

**Direct Fund Impact:**
- Stale beneficiary addresses continue receiving shares of BasicReward, WelcomeReward, and FlexibleReward schemes indefinitely
- Each stale beneficiary dilutes rewards for legitimate current miners
- With average block production, a miner with 1 share receives approximately `(produced_blocks / total_shares) * period_rewards` [10](#0-9) 
- Multiple receiver changes compound the issue, creating multiple stale beneficiaries per miner
- Affects all three major Treasury reward distribution channels

**Who is Affected:**
- Active miners receive reduced rewards due to inflated total shares
- The Treasury's reward pool is systematically drained
- Legitimate candidates who don't exploit this lose competitive advantage

**Severity Justification:**
This is a HIGH severity vulnerability because it enables permanent theft of mining rewards through a simple, repeatable action with no cost to the attacker. The funds cannot be recovered once distributed to stale beneficiaries.

### Likelihood Explanation

**Attacker Capabilities:**
- Any candidate can call `SetProfitsReceiver` through their admin account [11](#0-10) 
- No special privileges required beyond being a registered candidate
- Multiple changes can be made to accumulate stale beneficiaries

**Attack Complexity:**
- Extremely low complexity: requires only calling `SetProfitsReceiver` to change receiver address
- No timing constraints or race conditions
- Works reliably due to deterministic state management

**Feasibility Conditions:**
- Attacker must be a current candidate (realistic for adversarial miners)
- Two-term delay between add/remove operations provides ample opportunity window
- No monitoring exists to detect stale beneficiaries

**Detection/Operational Constraints:**
- Stale beneficiaries are indistinguishable from legitimate beneficiaries in profit schemes
- No events or logs indicate failed removal attempts
- Silent failure in `RemoveBeneficiary` prevents detection

**Probability:**
HIGH - The attack is trivial to execute, costs nothing, and is difficult to detect. Any rational adversarial candidate would exploit this.

### Recommendation

**Code-Level Mitigation:**

1. Store historical receiver mappings keyed by `(pubkey, termNumber)` to track which address was the beneficiary for each term:
```
State.HistoricalProfitsReceiverMap[pubkey][termNumber] = receiverAddress
```

2. Modify removal logic to use historical mappings:
```csharp
private List<Address> GetHistoricalAddressesFromCandidatePubkeys(
    ICollection<string> pubkeys, 
    long termNumber)
{
    var addresses = pubkeys.Select(k => 
        State.HistoricalProfitsReceiverMap[k][termNumber] ?? 
        Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k))
    ).ToList();
    return addresses;
}
```

3. Update `SetProfitsReceiver` to proactively update all Treasury schemes (BasicReward, VotesWeightReward, ReElectionReward), not just notify Election contract

4. Add cleanup mechanism to remove stale beneficiaries from profit schemes when receiver changes

**Invariant Checks:**
- Assert that removal operations successfully reduce total shares
- Verify beneficiary count matches expected miner count after updates
- Add events for beneficiary removal failures

**Test Cases:**
- Scenario: Candidate with custom receiver R1 → changes to R2 → verify R1 is removed and R2 is added
- Scenario: Candidate changes receiver multiple times → verify no stale beneficiaries remain
- Scenario: Candidate with no custom receiver → sets receiver → removes receiver → verify correct cleanup

### Proof of Concept

**Initial State:**
- Miner M (pubkey "PUBKEY_M") is elected at Term 100
- Miner M has custom profits receiver R1 (address "0xR1...")
- `State.ProfitsReceiverMap["PUBKEY_M"] = 0xR1...`

**Step 1 (Term 100):**
- `UpdateBasicMinerRewardWeights` executes during term transition
- Adds beneficiary R1 to BasicRewardHash with shares calculated from block production
- R1 is now registered as beneficiary for Term 100

**Step 2 (Between Term 100-102):**
- Miner M's admin calls `SetProfitsReceiver(PUBKEY_M, 0xR2...)`
- `State.ProfitsReceiverMap["PUBKEY_M"]` updates to `0xR2...`
- Election contract updates Subsidy scheme (removes R1, adds R2)
- BasicRewardHash still has R1 as beneficiary (unchanged)

**Step 3 (Term 102):**
- `UpdateBasicMinerRewardWeights` executes
- Calls `GetAddressesFromCandidatePubkeys` to remove Term 100 beneficiaries
- `GetProfitsReceiver("PUBKEY_M")` returns `0xR2...` (current value)
- `RemoveBeneficiaries` called with `[Address.FromPublicKey("PUBKEY_M"), 0xR2...]`
- Profit contract tries to remove these addresses from BasicRewardHash
- `State.ProfitDetailsMap[BasicRewardHash][0xR2...]` is null (never added)
- `State.ProfitDetailsMap[BasicRewardHash][Address.FromPublicKey("PUBKEY_M")]` is null (never added)
- Both removals fail silently

**Expected Result:**
R1 should be removed from BasicRewardHash

**Actual Result:**
- R1 remains in BasicRewardHash as stale beneficiary
- R1 continues receiving rewards in perpetuity
- Each distribution period, R1 receives `(shares_R1 / total_shares) * period_rewards`
- Attack can be repeated with R2→R3, R3→R4, etc. to accumulate multiple stale beneficiaries

**Success Condition:**
Query `State.ProfitDetailsMap[BasicRewardHash][0xR1...]` after Term 102 - it still contains non-zero shares, confirming stale beneficiary persists.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L620-620)
```csharp
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L621-626)
```csharp
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L657-663)
```csharp
    private List<Address> GetAddressesFromCandidatePubkeys(ICollection<string> pubkeys)
    {
        var addresses = pubkeys.Select(k => Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)))
            .ToList();
        addresses.AddRange(pubkeys.Select(GetProfitsReceiver));
        return addresses;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L814-818)
```csharp
                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L850-857)
```csharp
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L907-913)
```csharp
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```
