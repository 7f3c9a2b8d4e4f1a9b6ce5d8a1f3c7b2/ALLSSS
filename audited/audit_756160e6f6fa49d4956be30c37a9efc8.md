### Title
Parliament Proposal State Inconsistency Due to Dynamic Member List Evaluation

### Summary
The `IsProposalStillPending()` function calculates proposal states (pending/rejected/abstained) dynamically against the current parliament member list, which changes between consensus terms. This causes proposals to transition between "finalized" and "pending" states without any new votes, allowing rejected proposals to become releasable after parliament expansion, or approved proposals to become non-releasable after parliament changes.

### Finding Description

The vulnerability exists in the state calculation logic for parliament proposals. [1](#0-0) 

The `IsProposalStillPending()` function returns false (not pending) when `IsProposalRejected()` or `IsProposalAbstained()` return true. [2](#0-1) 

The root cause is that threshold checks use the CURRENT parliament member list obtained dynamically from the consensus contract. [3](#0-2) 

The parliament member list changes between consensus terms. [4](#0-3) 

**Execution Path:**
1. A proposal is created and receives votes (e.g., 3 rejections out of 10 members = 30%)
2. With rejection threshold at 20%, the proposal is marked as "rejected": `3 * 10000 > 2000 * 10` → true
3. `IsProposalStillPending()` returns false (not pending)
4. Parliament expands to 20 members after term change
5. Same 3 rejections now equal 15%: `3 * 10000 > 2000 * 20` → false
6. Proposal is no longer "rejected" and could become releasable with sufficient approvals

The proposal structure does not store the parliament membership at creation time - only individual votes are stored. This means all state calculations use the current member count, not a snapshot.

**Why Existing Protections Fail:**
- No snapshot of parliament membership is stored with proposals
- Expiration times mitigate but don't prevent state transitions during proposal lifetime
- No mechanism prevents voting or releasing proposals after state transitions
- The validation logic only ensures threshold relationships, not state stability: [5](#0-4) 

### Impact Explanation

**Governance Impact:**
1. **Governance Bypass:** A proposal rejected by a smaller parliament (e.g., 3 rejections out of 10 = rejected) can become releasable when parliament expands (e.g., 3 rejections out of 20 = not rejected), allowing execution of proposals the original parliament explicitly rejected.

2. **Denial of Service:** A proposal approved by a smaller parliament can become non-releasable when parliament expands, preventing execution of legitimately approved proposals. [6](#0-5) 

3. **State Inconsistency:** Query functions return different results at different times without state changes. [7](#0-6) 

**Who is Affected:**
- Parliament members making governance decisions based on unstable proposal states
- Proposers whose proposals can flip from approved to rejected
- Users relying on governance query functions for decision-making

**Severity Justification:**
Medium severity - violates critical governance invariants (stable proposal states), enables governance bypass, but requires specific timing around parliament membership changes and doesn't directly steal funds.

### Likelihood Explanation

**Attacker Capabilities:**
- Any proposer can create proposals
- Timing exploitation requires coordination with consensus term changes
- No special privileges needed beyond normal proposal creation rights

**Attack Complexity:**
- Low complexity - attacker creates proposal, waits for rejection, then waits for parliament expansion
- Natural parliament size fluctuations due to miner elections make exploitation feasible
- No need to compromise trusted roles

**Feasibility Conditions:**
- Parliament membership must change between proposal creation and release
- Proposal expiration time must span multiple consensus terms
- Parliament size fluctuations must be significant enough to cross thresholds

**Probability Reasoning:**
- Parliament membership changes occur regularly with term transitions (hours to days)
- Proposals with longer expiration times are more vulnerable
- Natural miner election dynamics create size fluctuations
- High probability for long-lived proposals spanning multiple terms

### Recommendation

**Code-Level Mitigation:**

1. **Snapshot Parliament Membership:** Store the parliament member list hash and size at proposal creation time in ProposalInfo:
```
message ProposalInfo {
    ...
    int32 parliament_size_at_creation = [next_field_number];
    aelf.Hash parliament_composition_hash = [next_field_number+1];
}
```

2. **Use Snapshot for Calculations:** Modify threshold check functions to use the snapshotted parliament size instead of current size:
```csharp
private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
{
    var rejectionMemberCount = proposal.Rejections.Count;
    var parliamentSizeAtCreation = proposal.ParliamentSizeAtCreation;
    return rejectionMemberCount * AbstractVoteTotal > 
           organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentSizeAtCreation;
}
```

3. **Add State Finalization:** Once a proposal reaches rejected/abstained/approved state, mark it as finalized and prevent further state transitions.

**Invariant Checks:**
- Assert that proposal state transitions are monotonic (once finalized, stays finalized)
- Validate that release checks use the same member count as pending checks
- Ensure parliament size snapshot matches actual member list at creation

**Test Cases:**
1. Test proposal rejection with small parliament, then verify it remains rejected after parliament expansion
2. Test proposal approval with large parliament, then verify it remains approved after parliament shrinks
3. Test GetNotVotedPendingProposals returns consistent results across term changes
4. Test Release function rejects proposals that were approved but became non-approved due to parliament changes

### Proof of Concept

**Initial State:**
- Parliament has 10 members: [Member1...Member10]
- Organization thresholds: MinimalApprovalThreshold=6667 (66.67%), MaximalRejectionThreshold=2000 (20%)
- Current term: Term_N

**Transaction Sequence:**

1. **T1: Create Proposal**
   - Proposer creates proposal with 30-day expiration
   - Initial state: 0 approvals, 0 rejections, 0 abstentions

2. **T2-T4: Collect Rejections**
   - Member1 calls Reject(proposalId)
   - Member2 calls Reject(proposalId)
   - Member3 calls Reject(proposalId)
   - State: 0 approvals, 3 rejections (30% > 20% threshold)
   - IsProposalRejected() = true (3 * 10000 > 2000 * 10)
   - IsProposalStillPending() = false
   - IsReleaseThresholdReached() = false

3. **T5: Query Pending Proposals**
   - Call GetNotVotedPendingProposals([proposalId])
   - Returns: empty list (proposal not pending)
   - Expected: Proposal is "finalized" as rejected

4. **T6: Consensus Term Change**
   - Parliament expands to 20 members due to miner elections
   - New parliament: [Member1...Member20]

5. **T7: Collect Approvals from New Members**
   - Member11 through Member24 (14 members) call Approve(proposalId)
   - State: 14 approvals, 3 rejections
   - IsProposalRejected() = false (3 * 10000 = 30000 NOT > 2000 * 20 = 40000)
   - CheckEnoughVoteAndApprovals() = true (14 * 10000 = 140000 >= 6667 * 20 = 133340)
   - IsReleaseThresholdReached() = true

6. **T8: Release Previously Rejected Proposal**
   - Proposer calls Release(proposalId)
   - Expected result: Should fail (proposal was rejected by original parliament)
   - **Actual result: Succeeds** - proposal executes despite being rejected by 30% of original parliament

**Success Condition:**
The exploit succeeds if a proposal that was "rejected" (IsProposalRejected=true, IsProposalStillPending=false) at one point can later be released (IsReleaseThresholdReached=true) due to parliament membership changes, without any change in the actual rejection votes.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L13-20)
```csharp
    private List<Address> GetCurrentMinerList()
    {
        RequireConsensusContractStateSet();
        var miner = State.ConsensusContract.GetCurrentMinerList.Call(new Empty());
        var members = miner.Pubkeys.Select(publicKey =>
            Address.FromPublicKey(publicKey.ToByteArray())).ToList();
        return members;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L50-62)
```csharp
    private bool IsProposalStillPending(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var isRejected = IsProposalRejected(proposal, organization, parliamentMembers);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization, parliamentMembers);
        if (isAbstained)
            return false;

        return !CheckEnoughVoteAndApprovals(proposal, organization, parliamentMembers);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-78)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(parliamentMembers.Contains);
        return abstentionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalAbstentionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L31-42)
```csharp
    public override MinerList GetCurrentMinerList(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var round)
            ? new MinerList
            {
                Pubkeys =
                {
                    round.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k))
                }
            }
            : new MinerList();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L300-316)
```csharp
    public override ProposalIdList GetNotVotedPendingProposals(ProposalIdList input)
    {
        var result = new ProposalIdList();
        var currentParliament = GetCurrentMinerList();
        foreach (var proposalId in input.ProposalIds)
        {
            var proposal = State.Proposals[proposalId];
            if (proposal == null || !Validate(proposal) || CheckProposalAlreadyVotedBy(proposal, Context.Sender))
                continue;
            var organization = State.Organizations[proposal.OrganizationAddress];
            if (organization == null || !IsProposalStillPending(proposal, organization, currentParliament))
                continue;
            result.ProposalIds.Add(proposalId);
        }

        return result;
    }
```
