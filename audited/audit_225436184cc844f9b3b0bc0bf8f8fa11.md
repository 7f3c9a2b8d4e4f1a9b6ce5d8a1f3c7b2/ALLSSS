### Title
Decimal Overflow in Bancor Formula Calculation Causing DoS on Token Swaps

### Summary
The `GetReturnFromPaid()` function in BancorHelper can throw an `OverflowException` when computing `Exp(y * Ln(x))` with extreme but valid connector weight ratios and large transaction sizes. The overflow occurs in the `Pow()` function's power series calculation, not from the final multiplication with `toConnectorBalance`, causing transaction reversion and denial of service on token swaps.

### Finding Description

The vulnerability exists in the Bancor formula calculation at line 53 of BancorHelper.cs: [1](#0-0) 

The calculation computes `bt * (decimal.One - Exp(y * Ln(x)))` where:
- `y = wf / wt` (ratio of fromConnectorWeight to toConnectorWeight)
- `x = bf / (bf + a)` (ratio determining price impact)

**Root Cause:**

Connector weights are validated to be strictly between 0 and 1 individually: [2](#0-1) [3](#0-2) 

However, their **ratio** `y = wf/wt` is unbounded. When `wt` is very small (e.g., 0.001) and `wf` is larger (e.g., 0.5), `y` can be 500 or more.

For large transaction sizes where `a` (paidAmount) is significant relative to `bf` (fromConnectorBalance), `x` becomes small, making `Ln(x)` very negative. This causes `y * Ln(x)` to become a large negative number (e.g., -230).

The `Exp()` function computes a power series with terms including `Pow(y, k)` for k up to 20: [4](#0-3) 

The `Pow()` function uses binary exponentiation with repeated squaring: [5](#0-4) 

When computing `(-230)^20`, even powers produce positive results: `2300^20 ≈ 2.7 × 10^67`, which massively exceeds `Decimal.MaxValue ≈ 7.9 × 10^28`. The multiplication at line 115 (`A *= A`) throws an `OverflowException` in C#, reverting the transaction.

**Why Existing Protections Fail:**

The connector weight validation only checks individual bounds, not their ratio: [6](#0-5) 

Neither `GetReturnFromPaid()` nor the `Exp()`/`Ln()` functions validate that the input to `Exp()` is within safe computational bounds. [7](#0-6) 

### Impact Explanation

**Harm:** Complete denial of service on token swaps for affected connector pairs. Users cannot buy or sell tokens through the affected TokenConverter connectors, effectively locking liquidity.

**Affected Parties:**
- Users attempting to swap tokens through connectors with extreme weight ratios
- Liquidity providers whose funds become temporarily inaccessible
- The protocol's token conversion functionality

**Severity Justification:** HIGH
- Critical functionality (token swaps) is completely disabled
- No fund loss, but liquidity is effectively locked
- Affects core protocol economic functionality
- Transaction reverts before any state changes, preventing partial execution risks

The vulnerability is triggered through the public `Sell()` function: [8](#0-7) 

### Likelihood Explanation

**Attacker Capabilities Required:**
- No direct attacker control needed - the issue arises from legitimate operations
- Requires governance/controller to set extreme (but valid) weight ratios
- Users perform normal large swap transactions

**Attack Complexity:** LOW
- Automatically triggered when mathematical conditions are met
- No sophisticated exploitation required
- Can occur during normal market operations

**Feasibility Conditions:**
1. Connector weight ratio ≥ 50:1 (e.g., `wt = 0.01`, `wf = 0.5` - both valid values)
2. Transaction size where `paidAmount / fromConnectorBalance ≥ 1.5` (selling ~1.5x pool size)
3. Or more extreme: `wt = 0.001` (0.1% reserve), transaction size ≥ 25% of pool

**Probability:** MEDIUM-HIGH
- While extreme weight ratios are unusual, they are not invalid
- Low liquidity pools or poorly initialized connectors increase risk
- Market volatility can lead to large transaction attempts
- No active monitoring prevents reaching overflow conditions

### Recommendation

**1. Add Input Validation:**
Add bounds checking in `GetReturnFromPaid()` and `GetAmountToPayFromReturn()` before calling `Exp()`:

```csharp
// After line 52 in GetReturnFromPaid
var exponentInput = y * Ln(x);
if (Math.Abs(exponentInput) > 50m) // Conservative safe threshold
    throw new InvalidValueException("Connector weight ratio or transaction size too extreme");
```

**2. Validate Connector Weight Ratio:**
Add ratio validation in `AssertValidConnectorWeight()` or when setting connector pairs:

```csharp
// In AddPairConnector or UpdateConnector
var weightRatio = Math.Max(resourceWeight / nativeWeight, nativeWeight / resourceWeight);
Assert(weightRatio <= 100m, "Connector weight ratio must not exceed 100:1");
```

**3. Add Safe Math Wrapper:**
Wrap the `Exp()` function to catch overflow and return appropriate error:

```csharp
private static decimal SafeExp(decimal y)
{
    try {
        return Exp(y);
    } catch (OverflowException) {
        throw new InvalidValueException("Exponential calculation overflow - transaction too large");
    }
}
```

**4. Test Cases:**
Add regression tests covering:
- Extreme weight ratios (0.001, 0.999)
- Large transaction sizes (up to 10x pool balance)
- Boundary conditions for `y * Ln(x)` approaching ±50

### Proof of Concept

**Initial State:**
1. Initialize TokenConverter with connectors:
   - Resource connector (e.g., "WRITE"): weight = "0.5", balance = 1,000,000 tokens
   - Native connector (e.g., "ELF"): weight = "0.001", balance = 10,000,000 tokens (with virtual balance)

**Exploitation Steps:**
1. User attempts to sell 300,000 WRITE tokens (30% of pool)
2. System calculates:
   - `x = 1,000,000 / (1,000,000 + 300,000) = 0.769`
   - `y = 0.5 / 0.001 = 500`
   - `Ln(0.769) ≈ -0.262`
   - `y * Ln(x) = 500 × (-0.262) = -131`
3. `Exp(-131)` attempts to compute `(-131)^20` in power series
4. `131^20 ≈ 1.8 × 10^42` exceeds Decimal.MaxValue
5. Line 115 in `Pow()` throws `OverflowException`

**Expected Result:** Transaction completes, tokens are swapped

**Actual Result:** Transaction reverts with `OverflowException`, DoS on swap functionality

**Success Condition:** Any transaction meeting the mathematical conditions (`|y * Ln(x)| > ~53`) will trigger the overflow and revert, demonstrating the vulnerability.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-41)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L53-53)
```csharp
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L44-50)
```csharp
                AssertValidConnectorWeight(connector);
            }
            else
            {
                Assert(IsValidSymbol(connector.Symbol), "Invalid symbol.");
                AssertValidConnectorWeight(connector);
            }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```
