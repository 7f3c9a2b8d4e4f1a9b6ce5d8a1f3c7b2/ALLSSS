# Audit Report

## Title
Predictable NFT Symbol Generation Enables Selective Participation Attack

## Summary
The NFT contract's `GenerateSymbolNumber()` function uses the previous block's random hash as its randomness source, which is publicly readable before transactions execute. This allows attackers to predict their assigned symbol number in advance and selectively submit NFT creation transactions only when they would receive desirable vanity symbols, enabling systematic monopolization of premium symbol numbers.

## Finding Description

The NFT contract generates protocol symbols by combining a type prefix (e.g., "AR" for Art) with a random number. The `GenerateSymbolNumber()` function obtains this random number by querying the consensus contract for the random hash of the **previous block** [1](#0-0) .

When a transaction executes in block H, it requests randomness from block H-1. The consensus contract stores random hashes during block production [2](#0-1) . Once block H-1 is finalized, its random hash becomes publicly accessible through the `GetRandomHash` view method [3](#0-2) , which is explicitly marked as a view method in the protocol definition [4](#0-3) .

**Attack Execution Flow:**

1. After block N is finalized, attacker queries `GetRandomHash(N)` to retrieve the stored random hash
2. Attacker computes predicted symbol for their address:
   - Combines `Hash(AttackerAddress)` with the retrieved random hash [5](#0-4) 
   - Converts to symbol number using `ConvertHashToInt64` [6](#0-5) 
3. If the predicted symbol is desirable (e.g., contains repeating digits like 111111 or 888888), attacker submits `Create` transaction in block N+1
4. If not desirable, attacker waits for next block and repeats

**Why Existing Protections Fail:**

The inclusion of `Context.Sender` in the hash computation does not prevent prediction because the attacker is computing the outcome for their own address - they know all inputs to the calculation. The do-while collision check only prevents duplicate symbols, not predictability [7](#0-6) .

## Impact Explanation

**High Severity** - This vulnerability breaks the fundamental fairness guarantee of the NFT protocol symbol allocation mechanism.

**Concrete Harms:**
- **Value Extraction**: Premium NFT symbols (patterns like AR111111, AR888888, AR123456) have intrinsic market value similar to vanity addresses or premium domain names. Attackers can systematically monopolize these valuable symbols.
- **Market Manipulation**: Attackers can accumulate portfolios of premium symbols and either withhold them or sell at inflated prices, extracting value from the ecosystem.
- **Fairness Violation**: Legitimate NFT creators cannot compete on equal terms for desirable symbols, undermining trust in the protocol.
- **Systemic Impact**: The attack can be executed repeatedly over time, allowing sustained value extraction with minimal cost (only transaction fees for desirable symbols).

## Likelihood Explanation

**High Likelihood** - The attack is practical, profitable, and requires only standard blockchain capabilities.

**Attacker Requirements:**
- Read blockchain state through standard node queries (no special access)
- Compute hash functions (standard cryptographic operations)
- Submit transactions (basic blockchain participation)

**Feasibility:**
- No special privileges required
- Works for any NFT type
- Easily automated with monitoring scripts
- Undetectable - transactions appear legitimate
- Economic cost is minimal - attacker only pays fees when obtaining desirable symbols

The attack can be executed by any rational actor monitoring the blockchain, making exploitation highly probable.

## Recommendation

**Solution 1: Use Current Block Randomness (Preferred)**
Modify `GenerateSymbolNumber()` to use `Context.CurrentHeight` instead of `Context.CurrentHeight.Sub(1)` when requesting random bytes. This ensures the randomness is not known until after the transaction is included in the block.

**Solution 2: Add Transaction-Specific Entropy**
Include additional unpredictable data in the hash computation, such as:
- Transaction hash (`Context.TransactionId`)
- Block time (`Context.CurrentBlockTime`)
- A user-provided nonce that gets hashed

**Solution 3: Commit-Reveal Scheme**
Implement a two-phase protocol:
1. User commits to creating an NFT protocol (hash of parameters + secret)
2. After commitment is included in a block, user reveals parameters and secret
3. Symbol is generated using the reveal block's randomness combined with the secret

## Proof of Concept

```csharp
[Fact]
public async Task PredictableSymbolGenerationTest()
{
    // Setup: Issue ELF tokens and get consensus contract stub
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ELF",
        Amount = 1_00000000_00000000,
        To = DefaultAddress
    });
    
    var consensusStub = GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
        ConsensusContractAddress, DefaultKeyPair);
    
    // Step 1: Get current block height
    var currentHeight = (await consensusStub.GetCurrentRoundInformation.CallAsync(new Empty()))
        .RealTimeMinersInformation.Values.First().ExpectedMiningTime.Seconds;
    
    // Step 2: Read the random hash from previous block (publicly accessible)
    var previousRandomHash = await consensusStub.GetRandomHash.CallAsync(
        new Int64Value { Value = currentHeight - 1 });
    
    // Step 3: Predict the symbol number using same logic as contract
    var senderHash = HashHelper.ComputeFrom(DefaultAddress);
    var randomBytes = previousRandomHash.Value.ToByteArray();
    var predictedRandomHash = HashHelper.ConcatAndCompute(
        senderHash, HashHelper.ComputeFrom(randomBytes));
    
    // Convert to symbol number (assuming 7-digit length)
    var from = 1000000L;
    var to = 10000000L;
    var predictedNumber = Math.Abs((long)(new BigInteger(predictedRandomHash.Value.ToByteArray()) 
        % (to - from))) + from;
    
    // Step 4: Create NFT protocol
    var result = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        Creator = DefaultAddress,
        IsBurnable = true,
        NftType = NFTType.Art.ToString(),
        ProtocolName = "TEST_NFT",
        TotalSupply = 1000000
    });
    
    // Step 5: Extract actual symbol number and verify it matches prediction
    var actualSymbol = result.Output.Value; // e.g., "AR1234567"
    var actualNumber = long.Parse(actualSymbol.Substring(2)); // Remove "AR" prefix
    
    // VULNERABILITY: Actual number matches our prediction
    actualNumber.ShouldBe(predictedNumber);
}
```

**Notes:**

This vulnerability is confirmed through direct code analysis. The randomness source (previous block's random hash) is publicly readable before transactions execute, making symbol numbers predictable. While the NFT symbol generation was likely designed to be "random enough" for uniqueness, it fails to provide the fairness guarantee expected in a public protocol where symbol aesthetics have market value.

The severity is justified by the systematic nature of the exploit - attackers can continuously monitor and selectively participate, accumulating premium symbols over time with minimal cost. This undermines the core fairness principle of the NFT protocol and enables long-term value extraction from the ecosystem.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-74)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** protobuf/aedpos_contract.proto (L143-145)
```text
    rpc GetRandomHash (google.protobuf.Int64Value) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
```
