### Title
Non-Deterministic Miner Ordering in Term Transitions Due to Dictionary Enumeration

### Summary
The `GenerateFirstRoundOfNewTerm()` function uses a Dictionary intermediate step when sorting miners by their public key's first byte, causing non-deterministic ordering when multiple miners share the same first byte value. This results in different nodes producing different consensus rounds during term transitions, leading to consensus failures and potential chain halts.

### Finding Description
The vulnerability exists in the miner ordering logic used during consensus term transitions: [1](#0-0) 

The code converts `Pubkeys` to a `Dictionary<string, int>` where the key is the hex representation and the value is the first byte (`miner[0]`), then orders by that first byte descending. When multiple pubkeys have identical first byte values, their relative order depends on the Dictionary's enumeration order.

**Root Cause:** C# Dictionary enumeration order is implementation-dependent and not guaranteed to be deterministic across different nodes, runtime versions, or executions. While LINQ's `OrderBy` is a stable sort (preserves relative order of equal elements), it can only preserve the order from its source collection. Since the source is a Dictionary with non-deterministic enumeration, the final ordering is non-deterministic.

This function is invoked during every term transition via the consensus command generation path: [2](#0-1) [3](#0-2) 

The same vulnerability exists in multiple implementations across the codebase: [4](#0-3) [5](#0-4) 

### Impact Explanation
**Consensus Integrity Violation:** Different nodes will generate different Round objects with different miner orderings when pubkeys collide on the first byte. This causes:

1. **Different Extra Block Producers:** The first miner in the sorted list becomes the extra block producer. Non-deterministic ordering means different nodes disagree on who should produce the extra block. [6](#0-5) 

2. **Different Time Slot Assignments:** Each miner's order determines their expected mining time slot. Non-deterministic ordering causes nodes to expect different miners at different times. [7](#0-6) 

3. **Consensus Failure:** When nodes disagree on the round structure, they cannot reach consensus on blocks, causing chain halts or forks.

**Collision Probability:** With mainnet configuration of 17 miners and 256 possible first byte values, the birthday paradox gives approximately 43% probability that at least two miners share the same first byte. This is unacceptably high for consensus-critical code. [8](#0-7) 

### Likelihood Explanation
**Extremely High Likelihood:**

- **Reachable Entry Point:** Automatically invoked during every term transition (default: every 7 days) via the NextTerm consensus behavior [9](#0-8) 

- **No Attacker Required:** This is deterministic consensus logic that must execute identically on all nodes. The non-determinism occurs naturally without any malicious action.

- **High Collision Probability:** With 17 miners, ~43% chance of first byte collision per term. Over a year (52 terms), the probability approaches certainty.

- **No Prevention Mechanism:** There are no safeguards, validation, or secondary tie-breaking mechanisms to ensure deterministic ordering.

- **Affects All Chains:** The vulnerability exists in mainnet production code, sidechain code, and kernel extensions, affecting all AElf chains.

### Recommendation
**Primary Fix:** Add a secondary sort key to ensure deterministic ordering when first bytes are equal:

```csharp
var sortedMiners =
    (from obj in Pubkeys
            .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
        orderby obj.Value descending, obj.Key ascending
        select obj.Key).ToList();
```

Or eliminate the Dictionary entirely and sort by full pubkey directly:

```csharp
var sortedMiners = Pubkeys
    .Select(pk => pk.ToHex())
    .OrderByDescending(hex => hex[0])
    .ThenBy(hex => hex)
    .ToList();
```

**Apply to All Implementations:** Update the same logic in:
- `contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs`
- `src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs`
- `src/AElf.Blockchains.SideChain/Protobuf/MinerListExtension.cs`
- All test implementations

**Add Regression Tests:** Create unit tests that verify deterministic ordering with miners having identical first bytes, executed multiple times to catch non-determinism.

**Consider Design Review:** The existing code for miner hash calculation uses proper lexicographic ordering, showing the team understands determinism requirements in some contexts: [10](#0-9) 

Apply similar full-key ordering to `GenerateFirstRoundOfNewTerm`.

### Proof of Concept
**Initial State:**
- 17 active miners (mainnet configuration)
- At least 2 miners have pubkeys starting with the same byte (e.g., both start with `0x04`)
- Current term period has expired, triggering NextTerm behavior

**Execution Steps:**
1. Extra block producer generates NextTerm consensus command
2. `GetConsensusExtraDataForNextTerm` is called
3. `GenerateFirstRoundOfNextTerm` is invoked on multiple nodes simultaneously
4. Each node converts pubkeys to Dictionary and orders by first byte
5. For pubkeys with matching first byte, Dictionary enumeration order differs between nodes
6. Nodes produce different `Round` objects with different miner orderings

**Expected Result (Correct Behavior):**
All nodes produce identical Round objects with deterministic miner ordering

**Actual Result (Vulnerability):**
- Node A produces Round with miner order: [M1, M2, M3, ...] where M1 is extra block producer
- Node B produces Round with miner order: [M2, M1, M3, ...] where M2 is extra block producer
- Nodes disagree on consensus round structure
- Consensus validation fails, chain cannot progress

**Success Condition:**
Different nodes generate different NextTerm consensus data for the same term transition, detectable through Round hash comparison or by observing consensus failures during term transitions with first-byte collisions among miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L26-28)
```csharp

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L30-33)
```csharp
            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L356-360)
```csharp
    private static Hash GetMinerListHash(IEnumerable<string> minerList)
    {
        return HashHelper.ComputeFrom(
            minerList.OrderBy(p => p).Aggregate("", (current, publicKey) => current + publicKey));
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** src/AElf.Blockchains.SideChain/Protobuf/MinerListExtension.cs (L14-18)
```csharp
        var sortedMiners =
            (from obj in miners.Pubkeys.Distinct()
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L41-44)
```csharp
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
```
