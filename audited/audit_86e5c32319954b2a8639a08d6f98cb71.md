### Title
Consensus Randomness Corruption via Colluded InValue Submission in First Round of New Term

### Summary
In the first round of a new term, all miners have `PreviousInValue` set to `Hash.Empty`, and the validation logic accepts any `InValue` without checking for uniqueness across miners. Colluding miners can exploit this by submitting identical `InValue` data, causing all miners to generate identical signatures and predictable mining orders for subsequent rounds, fundamentally compromising the randomness guarantees of the AEDPoS consensus mechanism.

### Finding Description

**Root Cause:**

When a new term begins, the `GenerateFirstRoundOfNewTerm` function initializes all miners with `PreviousInValue = Hash.Empty`: [1](#0-0) 

The validation logic in `UpdateValueValidationProvider` explicitly allows any value when `PreviousInValue` is `Hash.Empty`: [2](#0-1) 

There is no validation mechanism that checks whether multiple miners are submitting the same `InValue` within a round.

**Exploitation Path:**

1. When miners produce blocks in the first round of a new term with identical `InValue`, the signature calculation becomes deterministic: [3](#0-2) 

Since `IsFirstRoundOfCurrentTerm()` returns true, the condition on line 72 fails, and the signature remains as the initial calculation: `Hash(OutValue || InValue)`. With identical `InValue` across all miners, all signatures become identical.

2. The identical signatures cause all miners to calculate the same `SupposedOrderOfNextRound`: [4](#0-3) 

3. The conflict resolution mechanism assigns orders based on block production sequence, making the next round's order predictable since the first round's order is predetermined by pubkey sorting.

4. **Critical: Secret sharing is explicitly disabled when miner list changes**, removing the primary mitigation: [5](#0-4) 

5. The predictability cascades beyond the first round. In round 2, signatures are calculated using `CalculateSignature` which XORs the `PreviousInValue` with the aggregate of all round 1 signatures: [6](#0-5) 

Since all round 1 signatures were identical, and all miners have the same `PreviousInValue` from round 1, the round 2 signatures also become identical, perpetuating the predictability.

6. The extra block producer selection is also compromised: [7](#0-6) 

With predictable signatures from the first miner, colluding miners can predetermine who becomes the extra block producer.

### Impact Explanation

**Consensus Integrity Violation:**
The AEDPoS consensus mechanism relies on unpredictable signatures derived from secret `InValue` data to ensure randomness in mining order. This vulnerability allows colluding miners to eliminate this randomness for multiple rounds following a term change.

**Specific Harms:**
1. **Loss of Mining Order Randomness**: The mining order for round 2 and subsequent rounds becomes deterministic and predictable to colluding miners
2. **Predictable Extra Block Producer**: Miners can predetermine which miner will produce the extra block in subsequent rounds
3. **Coordination Attacks**: Predictable ordering enables coordinated denial-of-service against specific miners (ensuring they miss time slots), transaction ordering manipulation, and potential MEV-type attacks
4. **Weakened Consensus Security**: The fundamental security property that mining order should be unpredictable is violated

**Who is Affected:**
All network participants are affected as the consensus randomness property is compromised. Honest miners face unfair disadvantages if colluding miners manipulate ordering to their benefit.

**Severity Justification:**
While the direct economic impact may be limited (rewards are primarily based on blocks produced rather than order), this constitutes a fundamental violation of consensus security properties. The ability to predict and manipulate mining order undermines the fairness and security assumptions of the AEDPoS mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Collusion among all or a majority of miners
- Coordination to agree on a common `InValue` at the start of each new term
- No special privileges beyond being elected miners

**Attack Complexity:**
The attack is technically straightforward once miners coordinate:
1. Miners agree on a specific `InValue` (e.g., `Hash("collusion")`)
2. Each miner submits this identical value in the first round
3. The predictability automatically follows from the deterministic signature calculations

**Feasibility Conditions:**
- Occurs at term boundaries when `IsMinerListJustChanged` is true
- No external validation or monitoring specifically detects identical `InValue` submissions
- Secret sharing (the primary mitigation) is explicitly disabled for first rounds after miner list changes

**Detection Constraints:**
The attack would be visible on-chain (all miners having identical `OutValue` and `Signature` values), but may not trigger immediate alerts. The evil miner detection system only monitors missed time slots, not consensus data manipulation: [6](#0-5) 

**Economic Rationality:**
While direct profit is unclear, potential indirect benefits include transaction ordering advantages, coordinated attacks on competitors, and positioning for future governance proposals.

### Recommendation

**1. Add InValue Uniqueness Validation:**

Modify `UpdateValueValidationProvider` to check that within a single round, no two miners submit the same `OutValue` (which would indicate identical `InValue`):

```csharp
private bool ValidateInValueUniqueness(ConsensusValidationContext validationContext)
{
    var currentOutValue = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey].OutValue;
    
    var duplicateCount = validationContext.ProvidedRound.RealTimeMinersInformation.Values
        .Count(m => m.OutValue != null && m.OutValue == currentOutValue);
    
    return duplicateCount <= 1; // Only the current miner should have this OutValue
}
```

Add this check to the validation chain in `UpdateValueValidationProvider.ValidateHeaderInformation()`.

**2. Enforce Minimum Entropy for First Round InValues:**

In `GetConsensusExtraDataToPublishOutValue`, when `IsFirstRoundOfCurrentTerm()` is true, require miners to incorporate their public key or other unique identifier into the `InValue` generation:

```csharp
if (IsFirstRoundOfCurrentTerm(out _))
{
    Assert(
        triggerInformation.InValue != Hash.Empty && 
        triggerInformation.InValue.ToByteArray().Take(8).SequenceEqual(
            publicKeyBytes.Take(8)
        ),
        "InValue must incorporate miner's unique data in first round of term"
    );
}
```

**3. Add Event Logging:**

Emit an event when identical signatures are detected across multiple miners to enable monitoring:

```csharp
Context.Fire(new SignatureCollisionDetected
{
    RoundNumber = currentRound.RoundNumber,
    TermNumber = currentRound.TermNumber,
    SignatureValue = signature
});
```

**4. Test Cases:**

Add regression tests that:
- Verify rejection when miners submit identical `InValue` in first round of new term
- Confirm that mining order remains unpredictable across term boundaries
- Validate that signature collisions trigger appropriate alerts

### Proof of Concept

**Initial State:**
- New term is about to begin (term N transitioning to term N+1)
- Miners have coordinated to use `InValue = Hash("attack")`

**Exploitation Steps:**

1. **Term Transition:** `ProcessNextTerm` is called, creating first round of new term with all `PreviousInValue = Hash.Empty` [1](#0-0) 

2. **Miner 1 produces block:** Submits `InValue = Hash("attack")`
   - `OutValue = Hash(Hash("attack"))`
   - `Signature = Hash(OutValue || Hash("attack"))`
   - `SupposedOrderOfNextRound = Signature.ToInt64() % N + 1 = X`

3. **Miner 2 produces block:** Submits same `InValue = Hash("attack")`
   - Same `OutValue`, same `Signature`
   - Same `SupposedOrderOfNextRound = X`
   - Conflict resolution bumps Miner 1 to next available slot

4. **All miners produce blocks:** All with `InValue = Hash("attack")`
   - All have identical signatures
   - Final order determined by block production sequence (predetermined by pubkey sorting)

5. **Round 2 begins:** Miners calculate signatures using: [6](#0-5) 

With all round 1 signatures identical and all `PreviousInValue` values identical, round 2 signatures are also identical.

**Expected vs Actual Result:**
- **Expected:** Each miner has unique, unpredictable signature; mining order for subsequent rounds is randomized
- **Actual:** All miners have identical signatures; mining order for rounds 2+ is predictable and deterministic based on round 1 block production order

**Success Condition:**
Colluding miners successfully predict the mining order for rounds 2, 3, and beyond, enabling coordinated attacks or unfair advantages.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L35-35)
```csharp
            minerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L67-69)
```csharp
        var outValue = HashHelper.ComputeFrom(triggerInformation.InValue);
        var signature =
            HashHelper.ConcatAndCompute(outValue, triggerInformation.InValue); // Just initial signature value.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-108)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L118-121)
```csharp
        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
```
