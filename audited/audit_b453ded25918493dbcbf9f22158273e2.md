### Title
Unbounded ReceivedTokenSymbols Growth Enables DoS of Side Chain Dividend Distribution

### Summary
An attacker can donate dust amounts across thousands of different burnable token symbols to inflate the `ReceivedTokenSymbols` list without limit. When `Release()` is automatically called during consensus operations, it must iterate over all symbols and perform cross-contract balance queries for each, causing execution to exceed AElf's 15,000 method call limit and permanently disabling dividend distribution on side chains.

### Finding Description

The vulnerability exists in the interaction between the donation mechanism and automatic release logic for side chain dividend pools.

**Entry Point - Unrestricted Symbol Addition:**
The `Donate()` function only validates that a token is burnable but places no limit on the number of unique symbols that can be donated. [1](#0-0) 

Each donation flows to `TokenHolderContract.ContributeProfits` which calls `ProfitContract.ContributeProfits`, where new symbols are unconditionally added to `ReceivedTokenSymbols`: [2](#0-1) 

**Automatic Release Trigger:**
On side chains, `Release()` is called automatically after every consensus update (UpdateValue, NextRound, NextTerm, TinyBlock) when round number exceeds 1: [3](#0-2) 

**Gas Exhaustion Path:**
The `Release()` method triggers `TokenHolderContract.DistributeProfits`, which creates profit schemes with `IsReleaseAllBalanceEveryTimeByDefault=true`: [4](#0-3) 

When `ProfitContract.DistributeProfits` executes with this flag, it iterates over ALL `ReceivedTokenSymbols` and performs a cross-contract `GetBalance` call for each symbol: [5](#0-4) 

Similarly, `GetUndistributedDividends()` suffers the same issue by iterating over all symbols: [6](#0-5) 

**No Protection Mechanisms:**
The side chain dividend pool explicitly disables manual symbol list management: [7](#0-6) 

AElf enforces a 15,000 method call limit per transaction to prevent infinite loops: [8](#0-7) 

### Impact Explanation

**Severity: High - Permanent DoS of Side Chain Consensus and Economic System**

**Direct Operational Impact:**
- Side chain dividend distribution becomes permanently disabled once symbol count exceeds ~7,500 (considering each GetBalance as 2 method calls - the call itself and internal operations)
- Since `Release()` is called automatically after every consensus update, consensus operations will fail or consume excessive resources
- All side chain participants lose access to staking dividends indefinitely

**Economic Damage:**
- Accumulated dividends from transaction fees and mining rewards become permanently locked
- Token holders cannot claim their rightful profit distributions
- Side chain economic incentive model breaks down entirely

**Systemic Risk:**
- Affects the entire side chain, not individual users
- No recovery mechanism exists - `SetSymbolList()` is disabled and symbols cannot be removed from `ReceivedTokenSymbols`
- Attack cannot be reversed without contract upgrade

**Affected Parties:**
- All side chain token holders expecting dividends
- Side chain miners relying on dividend pool rewards
- Side chain validators unable to process consensus updates efficiently

### Likelihood Explanation

**Likelihood: High - Attack is Practical and Economically Rational**

**Attacker Capabilities:**
- Any user can call the public `Donate()` method
- Attacker can create their own burnable tokens with zero cost (mint any amount to themselves)
- Alternatively, attacker can use existing burnable tokens in the ecosystem

**Attack Complexity:**
- Low complexity: Simple repeated donations of 1 wei across different token symbols
- No special permissions or governance control required
- No timing constraints or race conditions involved

**Economic Feasibility:**
- Cost to create N burnable tokens: N × transaction_fee (minimal)
- Cost to donate: N × (transaction_fee + 1 wei per token)
- For 10,000 symbols, total cost is roughly 10,000-20,000 transaction fees
- Return: Permanent disruption of entire side chain dividend system (asymmetric impact)

**Detection Constraints:**
- Attack can be executed gradually over time to avoid detection
- Each individual donation appears legitimate
- No immediate visible impact until Release() is called with large symbol count

**Execution Practicality:**
- Attack can be scripted and automated
- No coordination with other parties needed
- Works under normal AElf contract execution model
- Does not rely on any edge cases or race conditions

### Recommendation

**Immediate Mitigation:**
Implement a maximum limit on `ReceivedTokenSymbols` size in the `ProfitContract.ContributeProfits` method:

```csharp
public override Empty ContributeProfits(ContributeProfitsInput input)
{
    // ... existing validation ...
    
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    
    // Add symbol limit check
    if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol))
    {
        Assert(scheme.ReceivedTokenSymbols.Count < MAX_RECEIVED_TOKEN_SYMBOLS,
            "Maximum token symbol limit reached.");
        scheme.ReceivedTokenSymbols.Add(input.Symbol);
    }
    
    // ... rest of implementation ...
}
```

Where `MAX_RECEIVED_TOKEN_SYMBOLS` should be set to a reasonable value (e.g., 100) that balances functionality with gas safety.

**Additional Safeguards:**
1. Implement pagination in `DistributeProfits` to process symbols in batches across multiple transactions
2. Add a governance-controlled whitelist of acceptable token symbols for donations
3. Implement a minimum donation threshold per symbol to discourage dust attacks
4. Add monitoring/alerting when symbol count approaches dangerous levels
5. Enable `SetSymbolList()` for privileged addresses to allow emergency symbol pruning

**Test Cases to Add:**
1. Test that donations fail when symbol limit is reached
2. Test that Release() succeeds with maximum allowed symbols
3. Test that GetUndistributedDividends() completes within gas limits for maximum symbols
4. Test governance mechanism for updating symbol whitelist
5. Fuzz testing with various symbol counts to identify exact gas consumption thresholds

### Proof of Concept

**Initial State:**
- Side chain is operational with dividend pool initialized
- Token holder scheme created with `IsReleaseAllBalanceEveryTimeByDefault=true`

**Attack Sequence:**

1. **Attacker creates 10,000 burnable tokens:**
   - For i=1 to 10,000: Create token "DUST_i" with IsBurnable=true
   - Mint 10,000 wei of each token to attacker address

2. **Attacker donates dust amounts:**
   - For each token DUST_i:
     - Call `Donate(symbol="DUST_i", amount=1)`
     - Each call adds DUST_i to `ReceivedTokenSymbols`
   - After 10,000 donations: `ReceivedTokenSymbols.Count == 10,000`

3. **Consensus triggers automatic Release():**
   - Miner produces next block
   - `ProcessConsensusInformation` executes
   - Calls `Release()` at line 83
   - `Release()` calls `TokenHolderContract.DistributeProfits`
   - `ProfitContract.DistributeProfits` iterates over 10,000 symbols
   - Each iteration performs `State.TokenContract.GetBalance` (cross-contract call)
   - Total method calls: 10,000+ balance queries + distribution logic
   - Exceeds 15,000 method call limit

**Expected Result:**
- Normal dividend distribution completes successfully
- Consensus operations process without issues

**Actual Result:**
- Transaction fails with method call count exceeded error
- Side chain consensus cannot complete consensus updates
- Dividend distribution permanently disabled
- All accumulated dividends locked in contract

**Success Condition:**
- AttackerSymbol count > 7,500 causes Release() to consistently fail
- GetUndistributedDividends() also fails with same error
- No recovery possible without contract upgrade

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-94)
```csharp
    public override Empty Donate(DonateInput input)
    {
        EnsureTokenContractAddressSet();

        if (!State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = input.Symbol }).Value)
            return new Empty();

        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });

        Context.Fire(new DonationReceived
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            PoolContract = Context.Self
        });

        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;

        Context.LogDebug(() => $"Contributed {input.Amount} {input.Symbol}s to side chain dividends pool.");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L124-128)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        Assert(false, "Side chain dividend pool not support setting symbol list.");
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L147-161)
```csharp
    public override Dividends GetUndistributedDividends(Empty input)
    {
        var scheme = GetSideChainDividendPoolScheme();
        return new Dividends
        {
            Value =
            {
                scheme.ReceivedTokenSymbols.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L447-460)
```csharp
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L83-83)
```csharp
        if (!State.IsMainChain.Value && currentRound.RoundNumber > 1) Release();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L13-13)
```text
- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```
