### Title
Time-Of-Check-Time-Of-Use Vulnerability in EnableConnector Due to External Callback Reentrancy

### Summary
The `EnableConnector` function calculates the required deposit amount via `GetNeededDeposit()`, then executes external `TransferFrom` calls that can trigger token callbacks, and finally uses the potentially stale deposit calculation to set `State.DepositBalance`. This TOCTOU vulnerability violates the Checks-Effects-Interactions pattern and can result in incorrect reserve tracking if token supply/balances change during callbacks, leading to mispricing in subsequent Buy/Sell operations.

### Finding Description

The vulnerability exists in the `EnableConnector` function's execution sequence: [1](#0-0) 

The function first calls `GetNeededDeposit()` which reads current token state: [2](#0-1) 

The calculation reads `tokenInfo.TotalSupply` and contract balance at lines 62-72, computes `amountOutOfTokenConvert` at line 73, and calculates the required deposit using the Bancor formula at lines 81-83.

After this calculation, `EnableConnector` executes two `TransferFrom` operations (lines 278-285 for base token, 288-295 for resource token). These calls invoke the MultiToken contract's `DoTransferFrom`: [3](#0-2) 

Critically, `DoTransferFrom` calls `DealWithExternalInfoDuringTransfer` at line 92-93 AFTER modifying balances (line 91) but BEFORE updating allowances (line 94): [4](#0-3) 

This callback mechanism (using `Context.SendInline` at line 346) is triggered if the token has `TransferCallbackExternalInfoKey` in its ExternalInfo, which is a legitimate documented feature: [5](#0-4) 

**Root Cause:** State is read (GetNeededDeposit), external calls are made (TransferFrom with potential callbacks), then the stale value is used (State.DepositBalance assignment). During the callback, token supply can be modified via mint/burn, tokens can be transferred, or `EnableConnector` can be called recursively (no reentrancy guard exists).

**Why Protections Fail:**
1. No check for `IsPurchaseEnabled` before allowing EnableConnector execution (unlike UpdateConnector at line 64)
2. No reentrancy guard on EnableConnector
3. State writes (line 297) occur AFTER external calls (lines 278-295) [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:** `State.DepositBalance` is used by `GetSelfBalance` for all Buy/Sell Bancor calculations: [7](#0-6) 

If set incorrectly due to stale calculations, the Bancor formula in Buy (lines 120-123) and Sell (lines 168-172) operations will compute wrong prices: [8](#0-7) 

**Scenarios:**
- If tokens are minted during callback: `needDeposit` calculated for fewer tokens, `DepositBalance` too low → users pay less base token during Buy, receive more during Sell → reserve drainage
- If tokens are burned during callback: `needDeposit` calculated for more tokens, `DepositBalance` too high → users pay more during Buy, receive less during Sell → unfair pricing
- If recursive EnableConnector: inner call sets correct `DepositBalance`, outer call overwrites with stale value → incorrect reserves

**Who is Affected:** All users trading through the affected connector pair, potentially the entire protocol's reserve backing.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Token with `ExternalInfo` containing `aelf_transfer_callback` (legitimate feature, set during token creation)
2. Callback code that either:
   - Mints/burns tokens (requires issuer authority)
   - Calls EnableConnector recursively
   - Transfers tokens affecting balances
3. Governance approval to add token as connector (via AddPairConnector with controller authority)

**Attack Complexity:** Low once preconditions met - simply call EnableConnector with appropriate parameters.

**Feasibility Constraints:** 
- Transfer callbacks are a documented legitimate feature but uncommon in practice
- Governance must approve the connector (requires AssertPerformedByConnectorController)
- However, callbacks don't need to be overtly malicious - legitimate tokens with unusual tokenomics (e.g., rebase tokens, tokens with transfer fees/hooks) could inadvertently trigger this

**Detection:** Difficult to detect in advance unless governance thoroughly audits callback behavior of all tokens before approval.

**Probability:** MEDIUM - While requiring governance approval reduces likelihood, the vulnerability stems from a general architectural flaw (CEI pattern violation) that could be triggered by any token with transfer side effects, not just malicious ones.

### Recommendation

**Immediate Fix:**
1. Add reentrancy guard checking `IsPurchaseEnabled` at start of EnableConnector:
```
Assert(!fromConnector.IsPurchaseEnabled, "Connector already enabled");
Assert(!toConnector.IsPurchaseEnabled, "Connector already enabled");
```

2. Follow Checks-Effects-Interactions pattern - set state BEFORE external calls:
```
// Set state first
State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
toConnector.IsPurchaseEnabled = true;
fromConnector.IsPurchaseEnabled = true;

// Then make external calls
if (needDeposit.NeedAmount > 0) { ... TransferFrom base token ... }
if (input.AmountToTokenConvert > 0) { ... TransferFrom resource token ... }
```

3. Re-validate state after external calls:
```
// After transfers, verify token state hasn't changed unexpectedly
var currentTokenInfo = State.TokenContract.GetTokenInfo.Call(...);
Assert(currentTokenInfo.TotalSupply == expectedSupply, "Token supply changed during execution");
```

**Invariant Checks:**
- `IsPurchaseEnabled` must be false when EnableConnector starts
- Token supply must not change between GetNeededDeposit and state updates
- DepositBalance must match calculated needDeposit

**Test Cases:**
- Test EnableConnector with token containing transfer callback that attempts reentrancy
- Test EnableConnector with token that mints during transfer callback
- Verify proper rejection of duplicate EnableConnector calls

### Proof of Concept

**Initial State:**
- Malicious token deployed with ExternalInfo containing callback to contract that calls EnableConnector recursively
- Governance adds token as connector via AddPairConnector
- User approves sufficient allowance for both base token and resource token

**Exploitation Steps:**
1. Attacker calls `EnableConnector(tokenSymbol: "MALICIOUS", amountToTokenConvert: 100)`
2. `GetNeededDeposit` calculates `needDeposit1 = X` based on current state
3. `TransferFrom` base token executes successfully
4. `TransferFrom` resource token executes:
   - `DoTransferFrom` modifies balances
   - `DealWithExternalInfoDuringTransfer` invokes callback
   - Callback calls `EnableConnector(tokenSymbol: "MALICIOUS", amountToTokenConvert: 50)`
   - Inner call calculates `needDeposit2 = Y` (different from X due to balance changes)
   - Inner call sets `State.DepositBalance = Y` and enables connectors
   - Callback returns
5. Outer call continues, sets `State.DepositBalance = X` (overwrites Y with stale value)

**Expected vs Actual:**
- Expected: `State.DepositBalance` should reflect actual deposit needed for final token state
- Actual: `State.DepositBalance` contains stale calculation from step 2, before balance changes in step 4

**Success Condition:** After execution, verify `State.DepositBalance` does not match the deposit amount that would be calculated by `GetNeededDeposit` using the final token supply/balance state.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```
