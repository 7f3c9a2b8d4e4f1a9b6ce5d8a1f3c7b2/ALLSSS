### Title
BFT Safety Violation in Last Irreversible Block Calculation Due to Insufficient Consensus Threshold

### Summary
The LIB calculation in `LastIrreversibleBlockHeightCalculator` uses a `<` comparison that allows exactly `MinersCountOfConsent` miners to proceed with LIB calculation. However, the subsequent index formula `(Count-1)/3` selects a height confirmed by only `MinersCountOfConsent-1` miners, violating the 2/3+1 BFT safety requirement and potentially allowing Byzantine nodes to influence chain finality with insufficient consensus.

### Finding Description
The vulnerability exists in the LIB calculation logic where two components interact incorrectly: [1](#0-0) [2](#0-1) [3](#0-2) 

The root cause is that when `Count == MinersCountOfConsent` exactly, the index calculation produces a position where only `Count - ((Count-1)/3)` miners confirm the selected height. For example, with 7 total miners (MinersCountOfConsent = 5):
- When exactly 5 miners provide heights [h0, h1, h2, h3, h4]
- The comparison `5 < 5` is false, so execution proceeds
- Index = (5-1)/3 = 1
- Selected height is h1 (second element)
- Only miners at indices 1,2,3,4 (4 miners) have confirmed h1 or higher
- This is one fewer than the required 5 miners for BFT safety

The comparison operator `<` gates this unsafe scenario. Using `<=` would require `Count > MinersCountOfConsent`, preventing the edge case where exactly the minimum threshold participates. [4](#0-3) [5](#0-4) 

### Impact Explanation
This vulnerability breaks the fundamental BFT safety guarantee of AEDPoS consensus:

**Consensus Integrity Impact**: When exactly MinersCountOfConsent miners participate in a round, the LIB is determined by only MinersCountOfConsent-1 confirmations. With N=7 miners tolerating up to 2 Byzantine nodes, this reduces the actual confirmation threshold from 5 to 4, allowing 3 Byzantine nodes (43% of participants) to potentially manipulate the LIB selection.

**Chain Finality Risk**: An incorrect LIB affects all dependent subsystems including cross-chain verification, block pruning, and state finality assumptions. If Byzantine miners can influence LIB with insufficient consensus, they could:
- Cause honest nodes to finalize different blocks
- Create fork conditions in cross-chain communications
- Manipulate the irreversible block height used for indexing

**Severity**: Critical - violates the core 2/3+1 Byzantine fault tolerance invariant that the entire consensus mechanism depends on for safety.

### Likelihood Explanation
**Attacker Capabilities**: No special attack needed - this is a logic error that triggers during normal operation when exactly the minimum threshold of miners participate.

**Attack Complexity**: Trivial - occurs naturally when exactly MinersCountOfConsent miners mine in a round, which is a common scenario especially during:
- Network partitions or connectivity issues
- Rounds where some miners miss their time slots
- Intentional Byzantine behavior coordinating to be exactly at threshold

**Feasibility Conditions**: 
- Requires exactly MinersCountOfConsent miners to successfully mine in current round
- These miners must have provided ImpliedIrreversibleBlockHeight in previous round
- No additional permissions or access required [6](#0-5) 

**Probability**: HIGH - the exact threshold participation scenario occurs regularly in production, making this not a theoretical edge case but a practical safety violation that undermines consensus guarantees.

### Recommendation
**Immediate Fix**: Change the comparison operator from `<` to `<=` at line 26:

```diff
- if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
+ if (impliedIrreversibleHeights.Count <= _currentRound.MinersCountOfConsent)
```

This prevents LIB calculation when exactly MinersCountOfConsent miners participate, requiring strictly more participants to ensure the index formula produces safe results.

**Proper Fix**: Additionally correct the index formula to `Count - MinersCountOfConsent` to properly select the height confirmed by at least MinersCountOfConsent miners:

```diff
- libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
+ libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(_currentRound.MinersCountOfConsent)];
```

With both fixes, restore the comparison to `<` to allow exactly MinersCountOfConsent when the index formula is correct.

**Invariant Checks**:
- Add assertion: `(Count - selectedIndex) >= MinersCountOfConsent` before setting LIB
- Add test cases covering exact threshold scenarios (Count = MinersCountOfConsent, MinersCountOfConsent+1, etc.)
- Monitor for rounds where LIB calculation returns 0 due to insufficient participation

### Proof of Concept
**Initial State**:
- Network has 7 miners total
- MinersCountOfConsent = (7*2)/3 + 1 = 5
- Previous round completed with all miners providing implied heights
- Current round: exactly 5 miners successfully mined blocks

**Execution Steps**:
1. Five miners (M1, M2, M3, M4, M5) mine blocks in current round
2. Their implied heights from previous round: [100, 105, 110, 115, 120] (sorted)
3. `GetMinedMiners()` returns these 5 miners
4. `GetSortedImpliedIrreversibleBlockHeights()` returns [100, 105, 110, 115, 120]
5. Check: `5 < 5` â†’ false, proceed
6. Calculate index: `(5-1)/3 = 1`
7. Select LIB: `impliedIrreversibleHeights[1] = 105`

**Expected Result**: LIB should be 100 (confirmed by all 5 miners)

**Actual Result**: LIB is 105 (confirmed by only 4 miners: M2, M3, M4, M5)

**Success Condition**: Miner M1's confirmation of height 100 is ignored, allowing consensus with only 4 out of 5 required confirmations, violating BFT safety with exactly (MinersCountOfConsent - 1) consensus instead of MinersCountOfConsent.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L26-30)
```csharp
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L32-32)
```csharp
            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L268-279)
```csharp
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
