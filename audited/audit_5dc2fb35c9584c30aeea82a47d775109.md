### Title
Missing Null Validation in RequireParliamentContractAddressSet Causes Null Reference Exception in Method Fee Controller Initialization

### Summary
The `RequiredMethodFeeControllerSet()` function contains a logic error where it calls `RequireParliamentContractAddressSet()` but does not validate that the Parliament contract address was successfully retrieved. If `Context.GetContractAddressByName()` returns null (because the Parliament contract is not deployed or registered), the function continues execution and attempts to call methods on a null contract reference, resulting in a runtime exception.

### Finding Description
The vulnerability exists in the `RequiredMethodFeeControllerSet()` private method: [1](#0-0) 

At line 62, the function calls `RequireParliamentContractAddressSet()`, which is implemented as: [2](#0-1) 

The `RequireParliamentContractAddressSet()` method attempts to set `State.ParliamentContract.Value` using `Context.GetContractAddressByName()`, but critically **does not validate** that the returned address is non-null. When the Parliament contract is not deployed or registered, `GetContractAddressByName()` returns null, as confirmed by: [3](#0-2) 

After `RequireParliamentContractAddressSet()` returns (with `State.ParliamentContract.Value` still null), execution continues to line 66 where the code attempts to call `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())`. This invokes the `MethodReference.Call()` method: [4](#0-3) 

The `Call()` method accesses `_parent.Value` (line 25), which is null, passing a null address to `Context.Call()`. This causes a null reference or invalid address exception at runtime.

The method is misnamed - "Require" suggests it validates and enforces a precondition, but it merely attempts to set the value without validation, violating the fail-fast principle.

### Impact Explanation
**Operational Impact - DoS of Critical Governance Functions:**

This vulnerability affects three public methods that call `RequiredMethodFeeControllerSet()`:

1. `SetMethodFee()` - Used to configure transaction fees for contract methods [5](#0-4) 

2. `ChangeMethodFeeController()` - Used to update the governance authority for method fees [6](#0-5) 

3. `GetMethodFeeController()` - A public view method to query the fee controller [7](#0-6) 

When these methods are invoked before the Parliament contract is deployed/registered, all transactions fail with runtime exceptions, creating a denial-of-service condition for critical method fee management functionality. This prevents:
- Initial configuration of transaction fees for system contracts
- Governance operations related to fee management
- Query operations for fee controller information

The severity is Medium because while it doesn't allow fund theft or permanent damage, it **blocks critical initialization and governance operations** until the Parliament contract is properly deployed.

### Likelihood Explanation
**Likelihood: Medium**

**Reachable Entry Points:**
All three affected methods (`SetMethodFee`, `ChangeMethodFeeController`, `GetMethodFeeController`) are public and can be invoked by external callers. Notably, `GetMethodFeeController()` is a view method with no access controls, making it callable by anyone at any time.

**Feasible Preconditions:**
The vulnerability triggers when:
1. The Genesis contract is deployed and initialized
2. A caller invokes one of the affected methods BEFORE the Parliament contract is deployed/registered
3. `Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName)` returns null

**Execution Practicality:**
While system contracts are typically deployed in a specific order during chain initialization, there is a time window where:
- Genesis contract exists and is callable
- Parliament contract has not yet been deployed/registered in the `NameAddressMapping`
- External actors can call public methods like `GetMethodFeeController()`

The vulnerability is particularly relevant because:
- No access control prevents early calls to `GetMethodFeeController()`
- The method's "view" nature might lead developers to assume it's safe to call anytime
- Initialization race conditions or deployment sequence errors could trigger this issue

**Economic Rationality:**
No financial cost or gain is involved - this is an initialization/deployment issue that causes operational disruption rather than economic exploitation.

### Recommendation
**Add explicit null validation after attempting to retrieve the Parliament contract address:**

Modify `RequireParliamentContractAddressSet()` to enforce the precondition its name suggests:

```csharp
private void RequireParliamentContractAddressSet()
{
    if (State.ParliamentContract.Value == null)
    {
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        Assert(State.ParliamentContract.Value != null, 
            "Parliament contract not deployed. Unable to initialize method fee controller.");
    }
}
```

**Alternative approach - Add defensive check in RequiredMethodFeeControllerSet:**

```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    RequireParliamentContractAddressSet();
    
    Assert(State.ParliamentContract.Value != null, 
        "Parliament contract address not set.");

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
        ContractAddress = State.ParliamentContract.Value
    };

    State.MethodFeeController.Value = defaultAuthority;
}
```

**Test cases to add:**
1. Test calling `GetMethodFeeController()` before Parliament contract deployment - should fail gracefully with clear error message
2. Test calling `SetMethodFee()` before Parliament deployment - should fail with appropriate error
3. Test the initialization sequence ensuring Parliament is deployed before Genesis methods requiring it are callable

### Proof of Concept

**Initial State:**
1. Genesis contract (BasicContractZero) is deployed and initialized
2. Parliament contract has NOT been deployed yet
3. `State.MethodFeeController.Value` is null
4. `State.ParliamentContract.Value` is null

**Exploit Steps:**

Step 1: External caller invokes the public view method:
```
GenesisContractStub.GetMethodFeeController.Call(new Empty())
```

Step 2: Execution flow:
- Enters `GetMethodFeeController()` at line 49
- Calls `RequiredMethodFeeControllerSet()` at line 51
- Line 61: `State.MethodFeeController.Value` is null, continues
- Line 62: Calls `RequireParliamentContractAddressSet()`
- Inside helper method: `State.ParliamentContract.Value` is null
- Calls `Context.GetContractAddressByName()` - returns null (Parliament not deployed)
- Sets `State.ParliamentContract.Value = null`
- Returns to `RequiredMethodFeeControllerSet()`
- Line 66: Attempts `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())`
- Calls `MethodReference.Call()` with `_parent.Value = null`
- Passes null address to `Context.Call()`

**Expected Result:** 
Method should either succeed by returning a valid controller or fail gracefully with a clear error message about Parliament contract not being available.

**Actual Result:**
Runtime exception occurs (null reference or invalid address exception) when attempting to call a method on a contract reference with null address, causing transaction failure and DoS of the method.

**Success Condition:**
The transaction fails with an unhandled exception rather than a controlled assertion failure with a clear error message, confirming the lack of proper null validation.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L49-53)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L59-71)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        RequireParliamentContractAddressSet();

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L163-168)
```csharp
    private void RequireParliamentContractAddressSet()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L40-44)
```csharp
    public override Address GetContractAddressByName(Hash input)
    {
        var address = State.NameAddressMapping[input];
        return address;
    }
```

**File:** src/AElf.Sdk.CSharp/State/MethodReference.cs (L23-26)
```csharp
    public TOutput Call(TInput input)
    {
        return _parent.Context.Call<TOutput>(_parent.Value, _name, input);
    }
```
