# Audit Report

## Title
Systematic Token Loss Due to Truncation in Profit Distribution to Period Virtual Addresses

## Summary
The `SafeCalculateProfits()` function performs decimal-to-long casting that truncates fractional token amounts during profit distribution. When beneficiaries claim their shares, each claim loses the fractional part, causing the sum of all claims to be less than the total distributed amount. These leftover tokens accumulate in period-specific virtual addresses with no recovery mechanism, resulting in permanent token loss.

## Finding Description

**Root Cause - Truncation in SafeCalculateProfits:**

The `SafeCalculateProfits()` method converts long values to decimals, performs the calculation, then casts back to long, which truncates any fractional result. [1](#0-0) 

**Complete Execution Flow:**

1. When a scheme manager calls `DistributeProfits()`, the contract records the total amount in `distributedProfitsInformation.AmountsMap[symbol]` and updates the distributed profits state. [2](#0-1) 

2. The contract then transfers tokens to a period-specific virtual address generated deterministically via `GetDistributedPeriodProfitsVirtualAddress()`. [3](#0-2) [4](#0-3) 

3. The period virtual address is computed by XOR-hashing the scheme ID with the period number. [5](#0-4) 

4. When beneficiaries call `ClaimProfits()`, the contract invokes `ProfitAllPeriods()` which calculates each beneficiary's share using the truncating `SafeCalculateProfits()` function. [6](#0-5) 

5. The calculated (truncated) amount is then transferred from the period virtual address to the beneficiary using `Context.SendVirtualInline()`. [7](#0-6) 

**Why Protections Fail:**

The Profit contract provides no mechanism to recover leftover tokens from period virtual addresses. Examining the complete contract interface shows that only `ClaimProfits` can withdraw from period addresses, and this method uses the truncating calculation. [8](#0-7) 

The scheme manager's permissions are limited to distribution and beneficiary management, with no direct access to period virtual addresses. [9](#0-8) 

**Test Evidence of Known Issue:**

Test files show developers accommodate this issue using tolerance ranges rather than fixing it. Test assertions allow for losses of up to 2 tokens per individual claim and 6 tokens total across all claims, confirming awareness of systematic rounding losses. [10](#0-9) [11](#0-10) 

## Impact Explanation

**Quantified Loss:**
For each beneficiary claiming with shares S out of total shares T from distributed amount A:
- Theoretical share: A × S / T
- Actual received: floor(A × S / T)
- Loss per beneficiary: up to 1 token (the truncated fractional part)

With N beneficiaries, total loss per distribution period can reach N tokens. This accumulates across:
- Multiple distribution periods per scheme
- Multiple profit schemes
- Multiple token symbols

**Concrete Example:**
Distributing 100 tokens among 30 beneficiaries (1 share each, 30 total shares):
- Each should receive: 100/30 = 3.333... tokens
- Each actually receives: floor(3.333...) = 3 tokens
- Total claimed: 30 × 3 = 90 tokens
- **Permanently locked: 10 tokens in period virtual address**

**Affected Parties:**
All profit schemes and their beneficiaries experience proportional value loss. The locked tokens remain in virtual addresses that are deterministically generated but inaccessible, effectively removing them from circulation permanently.

## Likelihood Explanation

**Certainty:** This occurs deterministically in every profit distribution where the distributed amount is not perfectly divisible by the share ratios. Given typical token amounts and beneficiary counts, this affects the vast majority of distributions.

**No Attacker Required:** This is a design flaw inherent in normal contract operation. Any honest scheme manager distributing profits and honest beneficiaries claiming their shares will trigger the token loss.

**Preconditions:** The vulnerability requires only:
1. A profit scheme with multiple beneficiaries
2. Token amounts that don't divide evenly by share ratios (extremely common)
3. Normal profit distribution and claiming workflow

**Frequency:** This happens continuously in production as the Profit contract is used throughout the AElf ecosystem for reward distributions, election rewards, citizen welfare, and other profit-sharing mechanisms.

## Recommendation

Implement one of the following solutions:

**Solution 1: Dust Collection to First/Last Claimer**
Modify the claiming logic to award any remaining dust amount to the first or last beneficiary to claim in each period. This ensures all tokens are distributed without requiring additional recovery mechanisms.

**Solution 2: Manager Recovery Function**
Add a scheme manager function to withdraw unclaimed tokens from period virtual addresses after all beneficiaries have claimed or after a sufficient timeout period. This requires tracking claim status per period.

**Solution 3: Proportional Rounding with Remainder Distribution**
Use a more sophisticated rounding approach that tracks remainder amounts and distributes them proportionally or to the beneficiaries with the largest fractional parts (largest remainder method).

**Recommended Implementation (Solution 1 - Simplest):**
Track whether all beneficiaries have claimed for a period. When the last beneficiary claims, add any remaining balance from the period virtual address to their claim amount. This ensures complete distribution without leaving locked tokens.

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```
1. Create a profit scheme with 30 beneficiaries, each with 1 share (30 total shares)
2. Manager distributes 100 tokens for period 1
3. Each of the 30 beneficiaries calls ClaimProfits
4. Verify each receives exactly 3 tokens (floor(100/30))
5. Check the period virtual address balance - it will contain 10 locked tokens
6. Verify no function exists to recover these 10 tokens
7. These tokens remain permanently inaccessible
```

The test would verify:
- Sum of claimed amounts (90) < distributed amount (100)
- Period virtual address balance equals the difference (10)
- No recovery mechanism exists in the contract interface
- Tokens are permanently locked as the period advances and new distributions occur

This can be validated by inspecting the `GetBalance` of the period virtual address after all beneficiaries have claimed, which will show the non-zero leftover balance that cannot be recovered.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L482-483)
```csharp
        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L595-603)
```csharp
            if (remainAmount != 0)
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = profitsReceivingVirtualAddress,
                        Amount = remainAmount,
                        Symbol = symbol
                    }.ToByteString());
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L887-895)
```csharp
                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L51-60)
```csharp
    private Address GetDistributedPeriodProfitsVirtualAddress(Hash schemeId, long period)
    {
        return Context.ConvertVirtualAddressToContractAddress(
            GeneratePeriodVirtualAddressFromHash(schemeId, period));
    }

    private Hash GeneratePeriodVirtualAddressFromHash(Hash schemeId, long period)
    {
        return HashHelper.XorAndCompute(schemeId, HashHelper.ComputeFrom(period));
    }
```

**File:** protobuf/profit_contract.proto (L45-47)
```text
    // The beneficiary draws tokens from the scheme.
    rpc ClaimProfits (ClaimProfitsInput) returns (google.protobuf.Empty) {
    }
```

**File:** test/AElf.Contracts.Election.Tests/Full/CitizenWelfareTests.cs (L716-716)
```csharp
            actualClaimed.ShouldBeInRange(shouldClaimed - 2, shouldClaimed);
```

**File:** test/AElf.Contracts.Election.Tests/Full/CitizenWelfareTests.cs (L724-724)
```csharp
        profitsList.Sum().ShouldBeInRange(totalAmount - 6, totalAmount);
```
