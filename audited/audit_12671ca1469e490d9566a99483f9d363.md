### Title
Dictionary Access Vulnerability in Consensus Block Production Causes Chain Halt via Miner Pubkey Replacement Race Condition

### Summary
The AEDPoS consensus contract contains unprotected dictionary accesses to `RealTimeMinersInformation` during block production that can cause `KeyNotFoundException` crashes when a miner's pubkey is replaced mid-block-production. While the question identifies `GetUpdateValueRound()` line 13, the vulnerability manifests earlier in the call chain at `GetConsensusExtraDataToPublishOutValue()` lines 58-63, causing immediate block production failure and potential consensus halt.

### Finding Description

The vulnerability exists in the consensus block production flow where dictionary accesses lack key existence validation:

**Primary crash location**: [1](#0-0) 

These lines directly access `currentRound.RealTimeMinersInformation[pubkey]` without checking if the key exists. The only validation is an empty pubkey check: [2](#0-1) 

**Attack mechanism via pubkey replacement**: The Election Contract allows candidate admins to replace miner pubkeys at any time via: [3](#0-2) 

This triggers `RecordCandidateReplacement` which removes the old pubkey from the current round: [4](#0-3) 

**Race condition window**: Block production flow has a time gap:
1. `GetConsensusCommand` validates miner is in list: [5](#0-4) 
2. Later, `GetConsensusExtraData` is called for actual block production: [6](#0-5) 

Between these calls, if `RecordCandidateReplacement` executes and removes the pubkey, the subsequent dictionary access crashes.

**Additional vulnerable locations**: The same pattern exists in:
- `GetConsensusExtraDataForTinyBlock`: [7](#0-6) 
- `GetUpdateValueRound` (as identified in the question): [8](#0-7) 
- `GetTinyBlockRound`: [9](#0-8) 

Note that `NextRound` and `NextTerm` behaviors have proper existence checks: [10](#0-9)  and [11](#0-10) 

### Impact Explanation

**Consensus disruption**: When a miner's block production crashes with `KeyNotFoundException`, that time slot is lost. If this affects multiple miners through coordinated replacements, block production stalls.

**Chain halt risk**: In scenarios with few active miners or during critical consensus transitions, preventing even one miner from producing blocks could halt the chain until manual intervention.

**Affected parties**: 
- All blockchain users experience transaction delays
- Miners lose block rewards
- DApps depending on timely block production fail

**Severity justification**: This violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity" and enables operational DoS of consensus, qualifying as Critical severity.

### Likelihood Explanation

**Attacker capabilities**: The attacker must be a candidate admin (controlled via: [12](#0-11) ). While this is a semi-privileged role, candidate admins are not expected to be trusted for consensus integrity.

**Attack complexity**: 
1. Monitor when target miner receives mining command
2. Call `ReplaceCandidatePubkey` with timing to hit the window between command and block production
3. The race window exists because `TriggerConsensusAsync` and `GetConsensusExtraDataAsync` are separate calls at different times

**Feasibility conditions**:
- No rate limiting on `ReplaceCandidatePubkey` calls
- Candidate admin has transaction priority to ensure execution before block production
- Multiple candidate admins could coordinate to affect multiple miners simultaneously

**Detection constraints**: The attack leaves evidence in Election Contract logs, but by then damage is done. Automated monitoring could detect replacement patterns but cannot prevent the crash.

**Probability**: MEDIUM-HIGH. Candidate admins have legitimate access and the timing window is predictable from public consensus commands. A determined attacker with admin access can reliably trigger this.

### Recommendation

**Code-level mitigation**: Add `ContainsKey` checks before all dictionary accesses:

```csharp
// In GetConsensusExtraDataToPublishOutValue (line 58)
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    Context.LogWarning($"Miner {pubkey} not found in current round during UpdateValue");
    return new AElfConsensusHeaderInformation 
    { 
        SenderPubkey = ByteStringHelper.FromHexString(pubkey),
        Round = currentRound,
        Behaviour = triggerInformation.Behaviour 
    };
}
```

Apply similar checks in:
- `GetConsensusExtraDataForTinyBlock` before line 158
- `GetUpdateValueRound` before line 13  
- `GetTinyBlockRound` before line 60

**Invariant enforcement**: Add validation in `GetConsensusBlockExtraData` immediately after retrieving round information: [13](#0-12) 

Add after line 23:
```csharp
Assert(currentRound.RealTimeMinersInformation.ContainsKey(pubkey), 
    $"Miner {pubkey} is not in the current round's miner list.");
```

**Additional protection**: Consider adding a lock period after pubkey replacement during which the old pubkey remains valid for in-flight block production, or reject replacements when the miner has active consensus commands.

**Test cases**:
1. Test `ReplaceCandidatePubkey` called immediately before block production
2. Test concurrent replacement and block production from same miner
3. Test all four consensus behaviors (UpdateValue, TinyBlock, NextRound, NextTerm) with missing pubkey
4. Verify graceful handling returns invalid consensus command rather than crashing

### Proof of Concept

**Initial state**:
- Blockchain running with miner list including pubkey A
- Miner A's node is active and scheduled to produce blocks
- Attacker controls the admin address for candidate A

**Attack sequence**:

1. **Setup**: Miner A calls `GetConsensusCommand` which validates A is in the current round and schedules block production

2. **Attack**: Before miner A produces the block:
   - Attacker (as admin) calls Election Contract's `ReplaceCandidatePubkey(oldPubkey: A, newPubkey: B)`
   - This calls: [14](#0-13) 
   - Which executes: [15](#0-14) 
   - Pubkey A is removed from `currentRound.RealTimeMinersInformation`

3. **Trigger**: Miner A's node attempts block production:
   - Calls `GetConsensusExtraData` with pubkey A (from local account service: [16](#0-15) )
   - Enters `GetConsensusExtraDataToPublishOutValue`
   - Executes line 58: `currentRound.RealTimeMinersInformation[pubkey]`
   - **Crash**: `KeyNotFoundException` thrown

4. **Result**: 
   - Expected: Miner A produces block with UpdateValue consensus data
   - Actual: Block production fails with unhandled exception, time slot wasted, consensus disrupted

**Success condition**: Transaction logs show `KeyNotFoundException` with message referencing the removed pubkey, and no block is produced in miner A's time slot despite the miner being online and active.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L18-18)
```csharp
        Assert(triggerInformation.Pubkey.Any(), "Invalid pubkey.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L20-23)
```csharp
        TryToGetCurrentRoundInformation(out var currentRound);

        var publicKeyBytes = triggerInformation.Pubkey;
        var pubkey = publicKeyBytes.ToHex();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L58-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L158-163)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L180-187)
```csharp
        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L211-212)
```csharp
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L26-27)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-58)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L13-13)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L60-60)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L32-32)
```csharp
    private ByteString Pubkey => ByteString.CopyFrom(AsyncHelper.RunSync(_accountService.GetPublicKeyAsync));
```
