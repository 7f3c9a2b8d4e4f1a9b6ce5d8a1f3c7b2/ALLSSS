### Title
Quadratic Complexity DoS in Association Proposal Threshold Validation

### Summary
The `IsProposalRejected`, `IsProposalAbstained`, and `CheckEnoughVoteAndApprovals` methods use nested iteration (`Count(Contains)`) to validate voter membership against organization member lists, resulting in O(n*m) computational complexity. An attacker can create an organization with thousands of members, have them all vote, and cause transaction timeout when proposals are released or queried, effectively DoSing governance functionality for that organization.

### Finding Description

The vulnerability exists in the threshold validation logic used by the Association contract: [1](#0-0) 

The `IsProposalRejected` method uses `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` where:
- `proposal.Rejections` is a list of addresses who rejected (defined as `repeated aelf.Address` in protobuf)
- `organization.OrganizationMemberList` is also a list of addresses (defined as `repeated aelf.Address`)
- The `Contains` method performs linear search O(m) for each rejection O(n) [2](#0-1) [3](#0-2) 

The same O(n*m) pattern appears in: [4](#0-3) [5](#0-4) 

All three methods are invoked during threshold checking: [6](#0-5) 

This is called from critical execution paths: [7](#0-6) [8](#0-7) 

**Why protections fail**: The contract validation logic checks organization structure but imposes no explicit limit on organization size: [9](#0-8) 

With AElf's 5MB transaction size limit, an attacker can create an organization with 10,000-50,000 members: [10](#0-9) 

### Impact Explanation

**Concrete Harm**:
- An organization with 10,000 members and 10,000 rejections requires ~100 million `Contains` operations (10,000 × 10,000)
- Three such operations (rejection + abstention + approval checks) result in ~300 million operations total
- This exceeds AElf's block execution time limit (typically 400ms), causing transaction reversion
- The `Release()` method becomes permanently unusable for proposals from affected organizations
- The `GetProposal()` view method also times out, preventing status queries

**Who is affected**:
- Any organization with legitimately large membership (e.g., community DAOs, token holder groups)
- Attackers can intentionally create bloated organizations to grief governance
- Once an organization reaches problematic size, ALL its proposals become unreleasable

**Severity justification**: Medium
- **Impact**: High - complete DoS of governance release mechanism for affected organizations
- **Likelihood**: Medium - requires creating large organization (one-time setup cost) but attack is repeatable
- **Scope**: Limited to specific organizations but governance is a critical system function

### Likelihood Explanation

**Attacker capabilities**:
- Anyone can create an Association organization (permissionless)
- Attacker controls all member addresses during organization creation
- Each member can vote once on any proposal

**Attack complexity**:
1. Create organization with 10,000+ member addresses in single transaction (within 5MB limit)
2. Create proposal through that organization
3. Have members reject/abstain to maximize computation
4. Anyone attempting to call `Release()` or `GetProposal()` hits timeout

**Feasibility conditions**:
- Transaction size limit (5MB) allows ~130,000 addresses theoretically, but 10,000-50,000 is practical
- No contract-level enforcement of member count limits
- Block execution time limit (400ms) is exceeded with sufficient member count
- Attack setup is one-time cost; DoS is repeatable for all proposals

**Economic rationality**:
- Creating large organization has transaction fee cost but is one-time
- Each vote by member also has minimal cost
- Benefit: permanent governance disruption for that organization outweighs setup cost

**Detection constraints**:
- Large organizations are visible on-chain but may appear legitimate
- No runtime protection to abort excessive computation early
- View method (`GetProposal`) DoS is particularly problematic as it cannot be fee-limited

### Recommendation

**Immediate mitigation**:

1. **Convert member list to HashSet during threshold validation**:
```csharp
private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
{
    var memberSet = new HashSet<Address>(organization.OrganizationMemberList.OrganizationMembers);
    var rejectionMemberCount = proposal.Rejections.Count(memberSet.Contains);
    return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
}
```
This reduces complexity from O(n*m) to O(n+m).

2. **Add explicit organization size limit**:
```csharp
private bool Validate(Organization organization)
{
    const int MaxOrganizationMembers = 1000; // Reasonable limit
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    Assert(organizationMemberCount <= MaxOrganizationMembers, 
           "Organization member count exceeds maximum allowed.");
    
    // ... rest of validation
}
```

3. **Cache member set in Organization state** for repeated lookups during proposal lifecycle.

**Invariant checks to add**:
- Maximum organization member count enforcement at creation and modification
- Maximum vote list sizes relative to organization size
- Execution time monitoring during threshold validation

**Test cases**:
- Create organization with 1000+ members, verify threshold checks complete within acceptable time
- Attempt to create organization exceeding member limit, verify rejection
- Proposal with maximum valid votes should complete Release() successfully
- Benchmark threshold validation with various organization/vote sizes

### Proof of Concept

**Required initial state**:
- Attacker has sufficient transaction fees
- Association contract deployed and functional

**Transaction sequence**:

1. **Setup - Create large organization**:
   ```
   CreateOrganization({
     organization_member_list: [address1, address2, ..., address10000], // 10,000 members
     proposal_release_threshold: {
       minimal_approval_threshold: 5000,
       minimal_vote_threshold: 5000,
       maximal_rejection_threshold: 4999,
       maximal_abstention_threshold: 0
     },
     proposer_white_list: [attacker_address]
   })
   ```

2. **Create proposal**:
   ```
   CreateProposal({
     organization_address: org_address,
     contract_method_name: "SomeMethod",
     to_address: target_contract,
     params: encoded_params,
     expired_time: future_timestamp
   })
   → Returns proposal_id
   ```

3. **Vote with all members** (in batches):
   ```
   For each of 10,000 member addresses:
     Reject(proposal_id) // As that member
   ```

4. **Attempt to release proposal**:
   ```
   Release(proposal_id)
   ```

**Expected vs actual result**:
- **Expected**: Proposal is checked against threshold and either released or rejected based on vote counts
- **Actual**: Transaction times out during `IsReleaseThresholdReached` → `IsProposalRejected` computation (10,000 × 10,000 = 100M operations), transaction reverts, proposal cannot be released

**Success condition**: 
- `Release()` transaction consistently fails with timeout/gas exceeded
- `GetProposal()` view call also times out or takes >1 second
- Governance for this organization is effectively blocked
- Reducing organization size to <1000 members allows successful Release()

### Notes

The Parliament contract has identical O(n*m) complexity patterns but is less exploitable because parliament members are derived from the current miner list (typically 21-100 members), which is controlled by consensus rather than arbitrary user input: [11](#0-10) 

The Association contract is uniquely vulnerable due to permissionless organization creation with unbounded member lists.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```

**File:** protobuf/association_contract.proto (L105-108)
```text
message OrganizationMemberList {
    // The address of organization members.
    repeated aelf.Address organization_members = 1;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L18-42)
```csharp
    public override ProposalOutput GetProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        if (proposal == null) return new ProposalOutput();

        var organization = State.Organizations[proposal.OrganizationAddress];
        var readyToRelease = IsReleaseThresholdReached(proposal, organization);

        return new ProposalOutput
        {
            ProposalId = proposalId,
            ContractMethodName = proposal.ContractMethodName,
            ExpiredTime = proposal.ExpiredTime,
            OrganizationAddress = proposal.OrganizationAddress,
            Params = proposal.Params,
            Proposer = proposal.Proposer,
            ToAddress = proposal.ToAddress,
            ToBeReleased = readyToRelease,
            ApprovalCount = proposal.Approvals.Count,
            RejectionCount = proposal.Rejections.Count,
            AbstentionCount = proposal.Abstentions.Count,
            Title = proposal.Title,
            Description = proposal.Description
        };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L1-6)
```csharp
namespace AElf.Kernel.TransactionPool;

public class TransactionPoolConsts
{
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```
