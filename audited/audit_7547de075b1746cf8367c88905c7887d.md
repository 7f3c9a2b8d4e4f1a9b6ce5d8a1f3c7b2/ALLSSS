### Title
Continuous Blocks Limit Bypass via Fake Round Number in Block Headers for UpdateValue/TinyBlock Behaviors

### Summary
The `ContinuousBlocksValidationProvider` uses `ProvidedRound.RoundNumber` from block headers to determine whether to enforce continuous blocks limits. For UpdateValue and TinyBlock behaviors, there is no validation ensuring `ProvidedRound.RoundNumber` matches the actual state round number. An attacker can set a fake round number (≤ 2) in block headers to bypass continuous blocks validation, enabling unlimited consecutive block production and DoS on other miners.

### Finding Description

The vulnerability exists in the consensus validation flow where round number consistency is not enforced for certain behaviors.

**Root Cause Location:**

The `RoundTerminateValidationProvider` only validates round number consistency for NextRound and NextTerm behaviors, not for UpdateValue or TinyBlock: [1](#0-0) 

The validation context exposes `ProvidedRound` directly from block header extra data without verifying it matches state: [2](#0-1) 

**Exploitation Mechanism:**

The `ContinuousBlocksValidationProvider` checks if `ProvidedRound.RoundNumber > 2` before enforcing continuous blocks limits: [3](#0-2) 

When behavior is UpdateValue or TinyBlock, the validation flow does NOT add `RoundTerminateValidationProvider`: [4](#0-3) 

The recovery operations do NOT validate or copy the round number field: [5](#0-4) [6](#0-5) 

**Why Protections Fail:**

After recovery, `ValidateConsensusAfterExecution` compares hashes but both sides reference the same object (state round), providing no validation of the original header round number: [7](#0-6) 

### Impact Explanation

**Concrete Harm:**

1. **Consensus DoS**: A malicious miner can bypass the continuous blocks limit (normally 8 blocks, defined as `MaximumTinyBlocksCount`) and produce unlimited consecutive blocks, preventing other miners from producing their allocated blocks. [8](#0-7) 

2. **Centralization**: The continuous blocks limit exists specifically to prevent single-miner dominance and ensure fair block production across all miners. Bypassing this breaks a fundamental consensus invariant.

3. **Chain Stability**: The mechanism dynamically reduces limits during abnormal mining conditions to prevent forks. Bypassing this can lead to chain instability. [9](#0-8) 

4. **Reward Manipulation**: The attacker gains unfair block production rewards while other miners are starved.

**Affected Parties:**
- All non-malicious miners lose block production opportunities
- Network stability and decentralization are compromised
- Token economics are distorted through reward manipulation

### Likelihood Explanation

**Attack Feasibility: HIGH**

**Attacker Capabilities:**
- Must be a valid miner in the current round's miner list
- Must have normal block production capabilities
- No special privileges or contract permissions required

**Attack Complexity: LOW**
1. Attacker monitors their `LatestPubkeyToTinyBlocksCount` state
2. When exhausted (BlocksCount < 0), construct a block with UpdateValue or TinyBlock behavior
3. Set `ProvidedRound.RoundNumber = 1` (or 2) in the block header consensus extra data
4. Submit the block - validation passes, continuous blocks check is skipped
5. Repeat indefinitely

**Execution Practicality:**
The attack requires only standard block production with modified header data. The validation path is deterministic and reliably bypasses the check: [10](#0-9) 

**Detection/Operational Constraints:**
- Attack is difficult to detect automatically since blocks appear valid
- No transaction-level errors occur
- Only detectable through manual audit of block header round numbers vs state

**Probability: HIGH** - The attack is straightforward, repeatable, and has no significant barriers once a miner decides to exploit it.

### Recommendation

**Primary Fix:**

Add round number validation for UpdateValue and TinyBlock behaviors. In `RoundTerminateValidationProvider`, enforce that the provided round matches the current state round:

Modify the validation logic to check round number consistency for ALL behaviors, not just NextRound/NextTerm: [1](#0-0) 

**Specific Code Changes:**

1. In `RoundTerminateValidationProvider.ValidateHeaderInformation`, add validation before the behavior switch:
   ```csharp
   // Validate round number matches for UpdateValue and TinyBlock
   if ((extraData.Behaviour == AElfConsensusBehaviour.UpdateValue || 
        extraData.Behaviour == AElfConsensusBehaviour.TinyBlock) &&
       validationContext.BaseRound.RoundNumber != extraData.Round.RoundNumber)
       return new ValidationResult { Message = "Round number mismatch in block header." };
   ```

2. Alternatively, modify `ContinuousBlocksValidationProvider` to use `BaseRound.RoundNumber` (from state) instead of `ProvidedRound.RoundNumber`: [11](#0-10) 

**Invariant Check to Add:**

For UpdateValue and TinyBlock behaviors:
- `Assert(ProvidedRound.RoundNumber == BaseRound.RoundNumber, "Round number must match current state")`

**Test Cases:**

1. Test UpdateValue with fake round number ≤ 2 when actual round > 2 - should FAIL
2. Test TinyBlock with fake round number ≤ 2 when actual round > 2 - should FAIL
3. Test that legitimate blocks with correct round numbers pass validation
4. Test continuous blocks limit enforcement with various round numbers

### Proof of Concept

**Initial State:**
- Blockchain at round 100
- Attacker miner M is in the miner list
- M has produced 8 consecutive blocks (exhausted quota)
- `State.LatestPubkeyToTinyBlocksCount[M].BlocksCount = -1`

**Attack Steps:**

1. **Construct Malicious Block:**
   - Create TinyBlockInput with normal fields
   - In block header's AElfConsensusHeaderInformation, set:
     - `Behaviour = AElfConsensusBehaviour.TinyBlock`
     - `Round.RoundNumber = 1` (fake value)
     - All other Round fields match current state

2. **Submit Block:**
   - Block enters `ValidateBeforeExecution` [12](#0-11) 

3. **Validation Bypass:**
   - `RoundTerminateValidationProvider` NOT added (line 77-92)
   - `ContinuousBlocksValidationProvider` executes check at line 13:
     - `ProvidedRound.RoundNumber (1) > 2` evaluates to FALSE
     - Continuous blocks validation SKIPPED
   - Validation passes

4. **State Update:**
   - `ProcessTinyBlock` updates state normally [13](#0-12) 
   - State round number remains 100
   - M's block counter increments

5. **Repeat:**
   - M can produce unlimited blocks using same technique

**Expected Result:**
- Block validation should FAIL with "Round number mismatch" or "Sender produced too many continuous blocks"

**Actual Result:**
- Block validation PASSES
- M produces 9th, 10th, 11th... consecutive blocks
- Other miners cannot produce their blocks
- Consensus centralization and DoS achieved

### Notes

This vulnerability specifically affects the continuous blocks limit enforcement, which is a critical anti-centralization mechanism in the AEDPoS consensus. The fix must ensure that block header round numbers cannot be arbitrarily set to bypass validation checks, while maintaining backward compatibility for legitimate block production flows.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-28)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-60)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L1-20)
```csharp
namespace AElf.Contracts.Consensus.AEDPoS;

// ReSharper disable once InconsistentNaming
public static class AEDPoSContractConstants
{
    public const int MaximumTinyBlocksCount = 8;
    public const long InitialMiningRewardPerBlock = 12500000;
    public const long TimeToReduceMiningRewardByHalf = 126144000; // 60 * 60 * 24 * 365 * 4
    public const int SupposedMinersCount = 17;
    public const int KeepRounds = 40960;
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
    public const string SideChainShareProfitsTokenSymbol = "SHARE";
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
    public const string SecretSharingEnabledConfigurationKey = "SecretSharingEnabled";
}

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-67)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-53)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```
