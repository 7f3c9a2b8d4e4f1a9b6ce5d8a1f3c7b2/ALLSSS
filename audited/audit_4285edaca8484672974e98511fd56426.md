### Title
Unauthorized Admin Takeover via AnnounceElectionFor Enables Reward Redirection

### Summary
The `AnnounceElectionFor` method lacks permission validation to verify that the caller owns the private key for the pubkey being announced as a candidate. This allows any attacker to front-run legitimate candidate announcements, become the admin of the target pubkey, and subsequently redirect all mining/candidate rewards to attacker-controlled addresses through `SetProfitsReceiver`. The legitimate owner has no mechanism to recover control once the attack succeeds.

### Finding Description

**Root Cause:**

The `AnnounceElectionFor` method accepts any pubkey and admin address without verifying ownership of the pubkey's private key. [1](#0-0) 

The method sets the caller (or specified address) as admin without any authorization check:
- Line 127: `var admin = input.Admin ?? Context.Sender;`  
- Line 128: `State.CandidateAdmins[pubkey] = admin;`

This contrasts with `AnnounceElection` which requires transaction signature verification via `Context.RecoverPublicKey()` to ensure the caller owns the pubkey. [2](#0-1) 

The underlying `AnnounceElection(byte[])` private method only validates that the pubkey is not an initial miner, not already a candidate, and not banned—but never checks caller authorization. [3](#0-2) 

**Attack Path:**

1. Attacker identifies a target pubkey (e.g., known validator pubkey, initial miner not yet announced)
2. Before legitimate owner announces, attacker calls `AnnounceElectionFor` with:
   - `Pubkey`: victim's pubkey  
   - `Admin`: attacker's address
3. Attacker becomes admin and is recorded in `State.CandidateAdmins[pubkey]` [4](#0-3) 
4. Attacker calls `TreasuryContract.SetProfitsReceiver` specifying their own address as profits receiver
5. `SetProfitsReceiver` validates admin permission via `GetCandidateAdmin` and succeeds since attacker is the admin [5](#0-4) 
6. `State.ProfitsReceiverMap[input.Pubkey]` is set to attacker's address [6](#0-5) 

**Why Existing Protections Fail:**

The `SetCandidateAdmin` method that could theoretically allow recovery requires the caller to be either Parliament or the current admin. [7](#0-6) 

Since the attacker is already the admin (set via `AnnounceElectionFor`), the legitimate pubkey owner cannot change the admin unless they control Parliament, which they do not. The victim is permanently locked out.

### Impact Explanation

**Direct Financial Theft:**
All mining rewards and candidate subsidies for the hijacked pubkey flow to the attacker's address instead of the legitimate owner. Mining rewards include:
- Basic miner rewards distributed per term [8](#0-7) 
- Welcome rewards for newly elected miners [9](#0-8) 
- Flexible rewards [10](#0-9) 
- Backup subsidy for candidates in data center ranking [11](#0-10) 

The profits receiver determines the beneficiary address used in all profit distribution calculations. [12](#0-11) 

**Systemic Impact:**
- **Consensus Integrity**: Legitimate validators lose economic incentive if rewards are stolen, potentially undermining network security
- **Denial of Service**: Victim must generate and use entirely new keypairs, losing any reputation or history associated with the original pubkey
- **Trust Breakdown**: The fundamental assumption that miners control their own reward destinations is violated

**Affected Parties:**
- Initial miners who haven't set admins (admins are not initialized in `InitialElectionContract`) [13](#0-12) 
- Any new validators preparing to announce candidacy
- The broader ecosystem's trust in reward distribution fairness

### Likelihood Explanation

**Attacker Capabilities Required:**
- Capital: 100,000 ELF (100_000_00000000 units) to pay `LockTokenForElection` [14](#0-13) 
- This capital is fully recoverable by calling `QuitElection` as admin [15](#0-14) 
- Ability to monitor mempool or identify target pubkeys before they announce

**Attack Complexity:**
- **Very Low**: Single transaction call to `AnnounceElectionFor`
- No special privileges required beyond having sufficient ELF balance
- No race conditions or timing dependencies beyond front-running the legitimate announcement

**Economic Rationality:**
- Mining rewards per term significantly exceed 100,000 ELF deposit
- Attacker gets deposit back if victim never becomes miner
- High ROI if victim pubkey gets elected
- Can target multiple pubkeys to increase success probability

**Detection Constraints:**
- Attack is indistinguishable from legitimate sponsored announcements (intended use case shown in tests) [16](#0-15) 
- No on-chain signal that the admin is not the legitimate owner
- Victim only discovers after attempting to announce or claim rewards

**Probability Assessment:**
HIGH - The attack is deterministic, economically profitable, technically trivial, and has no preventive controls. Initial miners and known validator pubkeys are public information, making target selection straightforward.

### Recommendation

**Immediate Fix:**

Add authorization check to `AnnounceElectionFor` method:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    
    // NEW: Verify the admin owns the pubkey or is explicitly authorized
    if (input.Admin != Address.FromPublicKey(pubkeyBytes))
    {
        // Require signature from the pubkey owner to authorize a different admin
        var authorization = input.Authorization; // New field in AnnounceElectionForInput
        Assert(authorization != null, "Authorization signature required when admin differs from pubkey owner");
        
        // Verify signature: Hash(admin_address, pubkey) signed by pubkey's private key
        var message = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(input.Admin), 
            HashHelper.ComputeFrom(pubkey)
        );
        var recoveredPubkey = Context.RecoverPublicKey(authorization.ToByteArray(), message.ToByteArray());
        Assert(recoveredPubkey.ToHex() == pubkey, "Invalid authorization signature");
    }
    
    // Continue with existing logic...
}
```

**Alternative Simpler Fix:**

Remove `AnnounceElectionFor` entirely and require all candidates to use `AnnounceElection` (which has proper signature verification), or restrict `AnnounceElectionFor` to only allow `Admin == Address.FromPublicKey(pubkeyBytes)`.

**Additional Safeguards:**

1. Add a "challenge period" after admin changes where the pubkey owner can override via signature
2. Emit events when admin is set to enable off-chain monitoring
3. Add recovery mechanism for initial miners through Parliament governance

**Test Cases Required:**

1. Test that `AnnounceElectionFor` rejects unauthorized admin assignments
2. Test that signature verification works correctly for authorized delegations
3. Test that legitimate sponsored announcements still work with authorization
4. Regression test ensuring SetProfitsReceiver fails for unauthorized callers

### Proof of Concept

**Initial State:**
- Attacker has balance ≥ 100,000 ELF
- Target pubkey (VictimPubkey) has not yet announced election
- VictimPubkey is a known validator or initial miner public key

**Attack Sequence:**

**Step 1:** Attacker announces election for victim  
```
Transaction: ElectionContract.AnnounceElectionFor
Input: {
    Pubkey: "VictimPubkey_Hex_String",
    Admin: AttackerAddress
}
Sender: AttackerAddress
```
**Result:** `State.CandidateAdmins["VictimPubkey"] = AttackerAddress`

**Step 2:** Attacker redirects rewards  
```
Transaction: TreasuryContract.SetProfitsReceiver
Input: {
    Pubkey: "VictimPubkey_Hex_String", 
    ProfitsReceiverAddress: AttackerAddress
}
Sender: AttackerAddress
```
**Result:** `State.ProfitsReceiverMap["VictimPubkey"] = AttackerAddress`

**Step 3:** Verify control  
```
Query: TreasuryContract.GetProfitsReceiver("VictimPubkey")
Returns: AttackerAddress ✓ (attack successful)

Query: ElectionContract.GetCandidateAdmin("VictimPubkey")  
Returns: AttackerAddress ✓ (attacker is admin)
```

**Expected vs Actual:**
- **Expected:** Only VictimPubkey owner can set admin and profits receiver
- **Actual:** Attacker gains full control, VictimPubkey owner permanently locked out

**Success Condition:**
When VictimPubkey is elected as miner, all rewards flow to AttackerAddress instead of the legitimate owner, verified by querying profit distribution records in the Profit contract after term settlement.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-57)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            oldAdminManagedPubkeys.Value.Remove(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[Context.Sender] = oldAdminManagedPubkeys;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-280)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContractState.cs (L68-68)
```csharp
    public MappedState<string, Address> CandidateAdmins { get; set; }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L601-629)
```csharp
    public override Empty SetProfitsReceiver(SetProfitsReceiverInput input)
    {
        if (State.ElectionContract.Value == null)
            State.ElectionContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        var pubkey = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.Pubkey));
        
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
        
        var candidateList = State.ElectionContract.GetCandidates.Call(new Empty());
        Assert(candidateList.Value.Contains(pubkey),"Pubkey is not a candidate.");

        var previousProfitsReceiver = State.ProfitsReceiverMap[input.Pubkey];
        //Set same profits receiver address.
        if (input.ProfitsReceiverAddress == previousProfitsReceiver)
        {
            return new Empty();
        }
        State.ProfitsReceiverMap[input.Pubkey] = input.ProfitsReceiverAddress;
        State.ElectionContract.SetProfitsReceiver.Send(new AElf.Contracts.Election.SetProfitsReceiverInput
        {
            CandidatePubkey = input.Pubkey,
            ReceiverAddress = input.ProfitsReceiverAddress,
            PreviousReceiverAddress = previousProfitsReceiver ?? new Address()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L651-655)
```csharp
    private Address GetProfitsReceiver(string pubkey)
    {
        return State.ProfitsReceiverMap[pubkey] ??
               Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L848-891)
```csharp
    private void UpdateWelcomeRewardWeights(Round previousTermInformation, List<string> newElectedMiners)
    {
        var previousMinerAddresses =
            GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
        var possibleWelcomeBeneficiaries = new RemoveBeneficiariesInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            Beneficiaries = { previousMinerAddresses }
        };
        State.ProfitContract.RemoveBeneficiaries.Send(possibleWelcomeBeneficiaries);
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });

        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
        }
        else
        {
            Context.LogDebug(() => "Welcome reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L893-936)
```csharp
    private void UpdateFlexibleRewardWeights(Round previousTermInformation)
    {
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value
        });
        State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
        {
            SchemeId = State.ReElectionRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value
        });
        if (State.ProfitContract.GetScheme.Call(State.ReElectionRewardHash.Value).TotalShares > 0)
        {
            var previousMinerAddresses =
                GetAddressesFromCandidatePubkeys(previousTermInformation.RealTimeMinersInformation.Keys);
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                Beneficiaries = { previousMinerAddresses }
            });
        }

        if (State.HasNewMiner[previousTermInformation.TermNumber])
        {
            Context.LogDebug(() => "Flexible reward will go to Welfare Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.WelfareHash.Value,
                SubSchemeShares = 1
            });
        }
        else
        {
            Context.LogDebug(() => "Flexible reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContractState.cs (L58-58)
```csharp
    public MappedState<string, Address> ProfitsReceiverMap { get; set; }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L201-218)
```csharp
        if (rankingList.DataCenters.ContainsKey(input.OldPubkey))
        {
            rankingList.DataCenters.Add(input.NewPubkey, rankingList.DataCenters[input.OldPubkey]);
            rankingList.DataCenters.Remove(input.OldPubkey);
            State.DataCentersRankingList.Value = rankingList;

            // Notify Profit Contract to update backup subsidy profiting item.
            if (State.ProfitContract.Value == null)
                State.ProfitContract.Value =
                    Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            
            var oldProfitReceiver = GetProfitsReceiverOrDefault(input.OldPubkey);
            var profitReceiver = oldProfitReceiver.Value.Any()
                ? oldProfitReceiver
                : null;
            RemoveBeneficiary(input.OldPubkey);
            AddBeneficiary(input.NewPubkey, profitReceiver);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** test/AElf.Contracts.Election.Tests/BVT/SponsorTests.cs (L15-49)
```csharp
    [Fact]
    public async Task ElectionContract_AnnounceElectionFor_State_Test()
    {
        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();
        var sponsorKeyPair = ValidationDataCenterKeyPairs.Last();
        var balanceBeforeAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);

        // Execute AnnounceElectionFor.
        var electionStub = GetElectionContractTester(sponsorKeyPair);
        var candidateAdmin = Address.FromPublicKey(candidatesKeyPair.PublicKey);
        await electionStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
        {
            Admin = candidateAdmin,
            Pubkey = candidatesKeyPair.PublicKey.ToHex()
        });

        var balanceAfterAnnouncing = await GetNativeTokenBalance(sponsorKeyPair.PublicKey);
        balanceAfterAnnouncing.ShouldBe(balanceBeforeAnnouncing - ElectionContractConstants.LockTokenForElection);

        var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput
        {
            VotingItemId = MinerElectionVotingItemId
        });
        votingItem.Options.Count.ShouldBe(1);
        votingItem.Options.ShouldContain(candidatesKeyPair.PublicKey.ToHex());
        var dataCenterList = await ElectionContractStub.GetDataCenterRankingList.CallAsync(new Empty());
        dataCenterList.DataCenters.ContainsKey(candidatesKeyPair.PublicKey.ToHex()).ShouldBeTrue();
        var subsidy = ProfitItemsIds[ProfitType.BackupSubsidy];
        var profitDetail = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            SchemeId = subsidy,
            Beneficiary = Address.FromPublicKey(candidatesKeyPair.PublicKey)
        });
        profitDetail.Details.Count.ShouldBe(1);
    }
```
