### Title
Unvalidated Boolean Parsing in CrossChainCreate Enables NFT Protocol Creation DoS

### Summary
An attacker can create a token on the mainchain with a malicious `NftTokenIdReuseMetadataKey` value (e.g., "1", "yes", "TRUE") in its ExternalInfo by directly calling the MultiToken contract's Create method. When this token is cross-chained to a sidechain and `CrossChainCreate()` is invoked, the unprotected `bool.Parse()` call throws a `FormatException`, permanently preventing NFT protocol creation for that symbol on the sidechain.

### Finding Description

The vulnerability exists in the `CrossChainCreate()` method which retrieves token information from the MultiToken contract and parses the `NftTokenIdReuseMetadataKey` value without validation or error handling: [1](#0-0) 

The `bool.Parse()` method only accepts "True"/"true" or "False"/"false" (case-insensitive). Any other value throws a `FormatException`.

The root cause is that the MultiToken contract's `Create()` method accepts arbitrary ExternalInfo values without validating their format: [2](#0-1) 

While the NFT contract's `Create()` method properly sets this value using `bool.ToString()` and protects the key as reserved: [3](#0-2) [4](#0-3) 

An attacker can bypass the NFT contract entirely and create a token directly through the MultiToken contract with malicious ExternalInfo values. The only requirement is possessing a seed NFT or being on the whitelist: [5](#0-4) 

Once the malicious token is created on mainchain, it can be legitimately cross-chained to sidechains via `CrossChainCreateToken`, which validates the token's existence but not the ExternalInfo value formats: [6](#0-5) 

### Impact Explanation

**Operational Impact - DoS of NFT Protocol Creation:**
- When `CrossChainCreate()` is called on a sidechain for a poisoned token symbol, the transaction fails with an unhandled `FormatException`
- The NFT protocol for that symbol becomes permanently uncreatable on the sidechain since the check at line 79 prevents duplicate protocols: [7](#0-6) 

- This blocks legitimate NFT functionality for that symbol namespace on all sidechains where the malicious token is cross-chained
- Multiple symbols can be poisoned if the attacker obtains multiple seed NFTs
- No fund loss occurs, but NFT protocol deployment becomes impossible for affected symbols

**Severity Justification:** Medium - Operational DoS with no direct fund impact, but permanently damages protocol functionality on sidechains for affected symbols.

### Likelihood Explanation

**Attacker Capabilities:**
- Must obtain a seed NFT for the target symbol (e.g., "XX123456" with valid NFT type prefix)
- Seed NFTs can be purchased or obtained through normal protocol mechanisms
- No special privileges or compromised roles required

**Attack Complexity:**
- Low - straightforward 5-step process:
  1. Obtain seed NFT for symbol
  2. Call `TokenContract.Create()` with malicious ExternalInfo
  3. Call `ValidateTokenInfoExists` on mainchain
  4. Call `CrossChainCreateToken` on sidechain with merkle proof
  5. Victim/attacker calls `CrossChainCreate()` â†’ transaction fails

**Economic Rationality:**
- Cost: Seed NFT price + transaction fees
- Detection: Malicious token visible on-chain but may not be detected before cross-chaining
- The attack is economically feasible for targeted DoS attacks

**Probability:** High - All preconditions are realistic and execution is straightforward under normal AElf contract semantics.

### Recommendation

**Immediate Fix:**
Replace the unsafe `bool.Parse()` with `bool.TryParse()` and handle invalid values gracefully:

```csharp
// At line 88 in NFTContract_Create.cs
if (!bool.TryParse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey], out var isTokenIdReuse))
{
    // Default to false or throw descriptive error
    throw new AssertionException($"Invalid {NftTokenIdReuseMetadataKey} value in token ExternalInfo.");
}
```

**Additional Hardening:**
1. Add ExternalInfo format validation in `TokenContract.Create()` for known metadata keys
2. Validate critical ExternalInfo keys in `CrossChainCreateToken` before registering tokens
3. Add integration tests covering malformed ExternalInfo values in cross-chain scenarios

**Test Cases:**
- Test `CrossChainCreate()` with various invalid boolean strings ("1", "yes", "TRUE", empty string)
- Test token creation with malformed ExternalInfo through MultiToken contract
- Test cross-chain token transfer with invalid metadata values

### Proof of Concept

**Initial State:**
- Mainchain: AELF chain initialized
- Sidechain: Side chain initialized with cross-chain transfers enabled
- Attacker: Possesses seed NFT for symbol "XX123456"

**Attack Steps:**

1. **Create Malicious Token on Mainchain:**
   - Attacker calls `TokenContract.Create()` with:
     - Symbol: "XX123456"
     - ExternalInfo: `{"aelf_nft_token_id_reuse": "1", "aelf_nft_base_uri": "https://example.com", "aelf_nft_type": "Art"}`
   - Transaction succeeds, token created with malicious metadata

2. **Cross-Chain Token to Sidechain:**
   - Call `ValidateTokenInfoExists` on mainchain with the token details
   - Call `CrossChainCreateToken` on sidechain with transaction bytes and merkle proof
   - Token successfully created on sidechain with same malicious ExternalInfo

3. **Trigger DoS:**
   - Anyone calls `NFTContract.CrossChainCreate({symbol: "XX123456"})` on sidechain
   - Code reaches line 88: `bool.Parse("1")`
   - **Expected:** NFT protocol created successfully
   - **Actual:** Transaction fails with `FormatException: String '1' was not recognized as a valid Boolean.`

4. **Verify Permanent DoS:**
   - Any subsequent attempt to create NFT protocol for "XX123456" on sidechain fails the same way
   - Symbol namespace permanently blocked on sidechain

**Success Condition:** Transaction failure with `FormatException` at line 88, preventing NFT protocol creation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L79-79)
```csharp
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L88-88)
```csharp
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L199-199)
```csharp
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-77)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L489-501)
```csharp
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L97-107)
```csharp
    private List<string> GetNftMetadataReservedKeys()
    {
        return new List<string>
        {
            NftTypeMetadataKey,
            NftBaseUriMetadataKey,
            AssembledNftsKey,
            AssembledFtsKey,
            NftTokenIdReuseMetadataKey
        };
    }
```
