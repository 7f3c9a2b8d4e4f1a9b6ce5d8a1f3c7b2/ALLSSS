### Title
Symbol Removal from Treasury SymbolList Can Hide and Prevent Distribution of Undistributed Balances

### Summary
The `GetUndistributedDividends()` function only returns balances for symbols currently in `State.SymbolList`, which can be modified via `SetSymbolList()`. When the Treasury controller removes a symbol from this list, any undistributed balance of that symbol in the Treasury virtual address becomes invisible to users and excluded from future distributions, effectively locking those funds until the symbol is re-added.

### Finding Description
The Treasury contract maintains a configurable symbol list in `State.SymbolList.Value` [1](#0-0)  that controls which token symbols are tracked for distribution purposes.

The `GetUndistributedDividends()` function iterates only through symbols in `State.SymbolList.Value` to query balances [2](#0-1) , meaning removed symbols are excluded from the returned result.

Similarly, the `Release()` function uses `State.SymbolList.Value` to create the distribution amounts map [3](#0-2) , and `ReleaseTreasurySubProfitItems()` also uses this list for creating the amounts map for sub-scheme distributions [4](#0-3) .

The `SetSymbolList()` function allows the Treasury controller (Parliament by default) to update this list [5](#0-4) . However, it performs NO validation to ensure that symbols being removed have zero balance in the Treasury virtual address. The function only validates that new symbols being added are profitable or whitelisted [6](#0-5) , but provides no protection against removing symbols with existing balances.

### Impact Explanation
When a symbol with non-zero balance is removed from `State.SymbolList`:

1. **Visibility Loss**: Users calling `GetUndistributedDividends()` will not see the balance of removed symbols, preventing proper accounting and transparency
2. **Distribution Halt**: Future `Release()` calls will not distribute removed symbols to beneficiaries, causing those funds to accumulate indefinitely in the Treasury virtual address
3. **Fund Lockup**: While not permanent theft, the funds remain locked until governance re-adds the symbol to the list

The Treasury virtual address is computed deterministically [7](#0-6)  and controlled through the Profit contract scheme, meaning there's no direct transfer mechanism outside of the distribution flow.

This affects all Treasury beneficiaries (miners, voters, backup nodes) who would have received a share of the removed symbol's distributions. The severity is Low because the impact is operational rather than causing permanent fund loss, and the issue is fully recoverable through governance action to re-add the symbol.

### Likelihood Explanation
The vulnerability requires the Treasury controller (Parliament) to call `SetSymbolList()` and remove a symbol that has non-zero balance. [8](#0-7) 

This could occur through:
- **Accidental misconfiguration**: Parliament votes to optimize the symbol list without checking Treasury balances
- **Incomplete migration**: Governance removes a symbol assuming all balances have been distributed
- **Misunderstanding**: Belief that removing a symbol only affects future donations, not existing balances

The likelihood is reduced because it requires a governance proposal and vote, making it unlikely to happen frequently. However, the complete lack of defensive checks means there's nothing preventing this mistake if governance decides to modify the symbol list.

### Recommendation
Add balance validation to `SetSymbolList()` to prevent removing symbols with non-zero balances:

```csharp
public override Empty SetSymbolList(SymbolList input)
{
    AssertPerformedByTreasuryController();
    Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
    
    if (State.TokenContract.Value == null)
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    // NEW: Check that removed symbols have zero balance
    var currentSymbols = State.SymbolList.Value?.Value ?? new List<string>();
    var removedSymbols = currentSymbols.Except(input.Value).ToList();
    foreach (var symbol in removedSymbols)
    {
        var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = State.TreasuryVirtualAddress.Value,
            Symbol = symbol
        }).Balance;
        Assert(balance == 0, 
            $"Cannot remove symbol {symbol} with non-zero balance {balance}. Distribute all funds first.");
    }

    // ... rest of existing validation ...
}
```

Additionally, consider:
1. Emitting an event when symbols are removed to alert users
2. Adding a view function to check balances of all symbols that have ever been received, not just current list
3. Implementing a grace period before symbol removal takes effect in distribution logic

### Proof of Concept
**Initial State:**
- Treasury has received donations in multiple symbols: ELF (1000), TOKEN_A (500), TOKEN_B (300)
- `State.SymbolList.Value` contains ["ELF", "TOKEN_A", "TOKEN_B"]

**Attack Steps:**
1. Parliament proposes and approves `SetSymbolList(["ELF", "TOKEN_B"])` to remove TOKEN_A (assuming it's no longer needed)
2. User calls `GetUndistributedDividends()` - returns only ELF: 1000, TOKEN_B: 300 (TOKEN_A balance hidden)
3. Consensus calls `Release(periodNumber)` - only distributes ELF and TOKEN_B
4. TOKEN_A balance (500) remains in Treasury virtual address, undistributed

**Expected Result:** Either SetSymbolList should fail due to non-zero balance, or all symbols should remain visible/distributable

**Actual Result:** TOKEN_A balance is hidden from view and excluded from distribution, effectively locked until symbol is re-added

**Success Condition:** Governance can successfully remove a symbol with non-zero balance without any error or warning, causing operational disruption to dividend distribution system

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContractState.cs (L36-36)
```csharp
    public SingletonState<SymbolList> SymbolList { get; set; }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L116-118)
```csharp
        var treasuryVirtualAddress = Address.FromPublicKey(State.ProfitContract.Value.Value.Concat(
            managingSchemeIds[0].Value.ToByteArray().ComputeHash()).ToArray());
        State.TreasuryVirtualAddress.Value = treasuryVirtualAddress;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L133-133)
```csharp
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L282-310)
```csharp
    public override Empty SetSymbolList(SymbolList input)
    {
        AssertPerformedByTreasuryController();
        Assert(input.Value.Contains(Context.Variables.NativeSymbol), "Need to contain native symbol.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        if (State.TokenConverterContract.Value == null)
            State.TokenConverterContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenConverterContractSystemName);

        foreach (var symbol in input.Value.Where(s => s != Context.Variables.NativeSymbol))
        {
            var isTreasuryInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
            {
                Symbol = symbol,
                Address = Context.Self
            }).Value;
            Assert(
                State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value ||
                isTreasuryInWhiteList, "Symbol need to be profitable.");
            Assert(!State.TokenConverterContract.IsSymbolAbleToSell.Call(new StringValue { Value = symbol }).Value,
                $"Token {symbol} doesn't need to set to symbol list because it would become native token after donation.");
        }

        State.SymbolList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L367-380)
```csharp
    public override Dividends GetUndistributedDividends(Empty input)
    {
        return new Dividends
        {
            Value =
            {
                State.SymbolList.Value.Value.Select(s => State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = State.TreasuryVirtualAddress.Value,
                    Symbol = s
                })).ToDictionary(b => b.Symbol, b => b.Balance)
            }
        };
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L707-707)
```csharp
        var amountsMap = State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L);
```
