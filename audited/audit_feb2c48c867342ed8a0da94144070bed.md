### Title
Consensus Signature Bypass Allows Mining Order Manipulation

### Summary
The `UpdateValueValidationProvider.NewConsensusInformationFilled()` function only checks if a signature exists (non-null and non-empty) but does not verify its correctness. A malicious miner can submit arbitrary signature values that pass the `.Any()` check, allowing them to manipulate their mining order in subsequent rounds and potentially influence random number generation, breaking consensus integrity.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The validation only checks that the signature field is non-null and contains at least one byte, but never verifies the signature value is correctly calculated.

**Expected Signature Calculation:** [2](#0-1) [3](#0-2) 

The signature should be calculated as `previousRound.CalculateSignature(previousInValue)`, which XORs the InValue with all previous round signatures.

**Signature Usage Without Verification:** [4](#0-3) [5](#0-4) 

The provided signature is stored directly and converted to Int64 to determine the miner's order in the next round, without any validation of its correctness.

**Protocol Definition:** [6](#0-5) 

The protocol documentation states the signature should be "Calculated from current in value and signatures of previous round," but this calculation is never validated.

### Impact Explanation

**Consensus Integrity Compromise:**
1. **Mining Order Manipulation**: An attacker can choose any signature value to optimize their mining position. Since mining order is calculated as `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, the attacker can select a signature that places them at the most profitable time slot.

2. **Random Number Generation Compromise**: Signatures are used in random hash generation through `GetLatestSignature()`. [7](#0-6) 

Invalid signatures break the randomness chain, potentially allowing predictable random values.

3. **Cascade Effect**: The forged signature becomes part of the signature chain for subsequent rounds, affecting all future miners' order calculations and breaking the integrity of the entire consensus mechanism.

**Severity Justification**: CRITICAL - This breaks fundamental consensus assumptions, allowing any authorized miner to manipulate the consensus ordering and randomness, which are core security properties of the DPoS system.

### Likelihood Explanation

**Attack Feasibility:**
- **Entry Point**: Public `UpdateValue` method accessible to all authorized miners [8](#0-7) 

- **Preconditions**: Attacker must be an authorized miner (verified in PreCheck) [9](#0-8) 

- **Execution Complexity**: LOW - Attacker simply provides a crafted signature value in the `UpdateValueInput` message
- **Detection**: DIFFICULT - The forged signature appears valid to all existence checks and propagates through the system
- **Cost**: MINIMAL - No additional transaction costs beyond normal block production

**Probability**: HIGH - Any malicious miner in the set can exploit this in every block they produce.

### Recommendation

**Add Signature Correctness Validation:**

Modify `UpdateValueValidationProvider.NewConsensusInformationFilled()` to verify the signature matches the expected calculation:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    
    // Existing checks
    if (minerInRound.OutValue == null || minerInRound.Signature == null ||
        !minerInRound.OutValue.Value.Any() || !minerInRound.Signature.Value.Any())
        return false;
    
    // NEW: Verify signature correctness
    if (validationContext.PreviousRound != null && 
        validationContext.PreviousRound.RealTimeMinersInformation.Any())
    {
        var previousInValue = minerInRound.PreviousInValue;
        if (previousInValue != null && previousInValue != Hash.Empty)
        {
            var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
            if (minerInRound.Signature != expectedSignature)
                return false;
        }
    }
    
    return true;
}
```

**Invariant to Enforce:**
- For UpdateValue transactions, the provided signature MUST equal `previousRound.CalculateSignature(previousInValue)` when previousInValue is available and valid.

**Test Cases:**
1. Test that UpdateValue with forged signature is rejected
2. Test that UpdateValue with correct signature is accepted
3. Test edge case when previousInValue is empty or unavailable
4. Test signature validation across round transitions

### Proof of Concept

**Initial State:**
- Blockchain running with multiple authorized miners
- Current round N with previous round N-1 containing miner signatures

**Attack Steps:**

1. **Attacker produces block during their time slot**
   - Entry point: `UpdateValue` method
   - Attacker is authorized miner (passes `PreCheck()`)

2. **Craft malicious UpdateValueInput:**
   ```
   UpdateValueInput {
     out_value: <valid hash of InValue>
     signature: <FORGED_VALUE chosen to optimize mining order>
     previous_in_value: <valid previous InValue>
     // ... other valid fields
   }
   ```

3. **Submit transaction:**
   - Validation passes: `NewConsensusInformationFilled()` only checks `.Any()` (non-empty)
   - Signature stored without verification
   - Mining order calculated: `order = GetAbsModulus(FORGED_VALUE.ToInt64(), minersCount) + 1`

4. **Expected vs Actual Result:**
   - **Expected**: Transaction rejected due to invalid signature
   - **Actual**: Transaction accepted, attacker gains preferred mining order in next round

**Success Condition:**
Attacker successfully produces blocks with arbitrary signatures that pass validation, demonstrating the ability to manipulate mining order at will without detection.

**Notes**

The signature field in AEDPoS consensus is not a cryptographic ECDSA signature over transaction data, but rather a consensus-specific hash value used for mining order determination and random number generation. However, this does not diminish the severity - the lack of correctness validation still allows manipulation of critical consensus properties. The validation must ensure the signature is computed correctly according to the protocol specification, even if it's not a traditional cryptographic signature.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L95-106)
```csharp
    private Hash GetLatestSignature(Round currentRound)
    {
        var latestSignature = currentRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .LastOrDefault(m => m.Signature != null)?.Signature;
        if (latestSignature != null) return latestSignature;
        if (TryToGetPreviousRoundInformation(out var previousRound))
            latestSignature = previousRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order)
                .LastOrDefault(m => m.Signature != null)
                ?.Signature;

        return latestSignature;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-244)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-21)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** protobuf/aedpos_contract.proto (L194-198)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
