### Title
Secret Sharing Integrity Violation: Unvalidated Encrypted Pieces Allow Miners to Bypass InValue Recovery

### Summary
The `ExtractInformationToUpdateConsensus` function copies encrypted pieces from miners without any cryptographic validation that these pieces actually encode the miner's InValue. A malicious miner can provide fake encrypted pieces while still passing all validation checks by self-reporting the correct PreviousInValue, completely breaking the secret sharing protocol's core security guarantee that InValues can be recovered even when miners don't voluntarily reveal them.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
The encrypted pieces extracted at line 45 are stored directly into the contract state without any validation: [2](#0-1) 

The only validation performed is checking that the self-reported PreviousInValue hashes to the previous OutValue: [3](#0-2) 

However, there is **no validation** that the encrypted pieces actually encode this same InValue. When other miners attempt to reconstruct the InValue using secret sharing: [4](#0-3) 

The reconstructed value is never compared against the self-reported PreviousInValue. A miner's self-reported value is simply accepted: [5](#0-4) 

**Why Protections Fail:**
The secret sharing protocol assumes encrypted pieces are honest encodings of InValues. The validation only checks cryptographic consistency between self-reported InValue and OutValue, but doesn't verify that encrypted pieces would reconstruct to the same InValue.

### Impact Explanation

**Consensus Integrity Compromise:**
- The secret sharing mechanism is designed to ensure InValues can be recovered even if miners refuse to reveal them, providing accountability for randomness generation
- With fake encrypted pieces, InValue recovery becomes impossible, allowing miners to permanently hide their InValues
- This breaks the verifiable random function (VRF) security guarantees that underpin consensus fairness

**Randomness Manipulation:**
- Miners can strategically withhold InValues that would produce unfavorable random outcomes
- The random hash generation depends on all miners' InValues being recoverable: [6](#0-5) 
- Corrupted secret sharing allows selective InValue disclosure, biasing randomness

**No Detection or Punishment:**
- The evil miner detection only checks for missed time slots: [7](#0-6) 
- Miners providing fake encrypted pieces while producing blocks normally are never detected or punished

**Severity: HIGH** - Breaks fundamental consensus security mechanism, enables randomness manipulation, affects all network participants.

### Likelihood Explanation

**Reachable Entry Point:**
The attack vector is through the public `UpdateValue` RPC method: [8](#0-7) 

**Attacker Capabilities:**
- Any active miner can execute this attack
- Requires no special privileges beyond being in the current miner set
- No additional economic cost (continues earning block rewards)

**Execution Practicality:**
1. Miner generates legitimate InValue_N and OutValue_N = Hash(InValue_N)
2. Instead of properly encrypting shares of InValue_N, generates random/fake encrypted pieces
3. Provides fake pieces in UpdateValueInput at transaction generation: [9](#0-8) 
4. Self-reports correct PreviousInValue in next round
5. Validation passes, fake pieces stored

**Detection Constraints:**
- No cryptographic proof verification of encrypted pieces
- Other miners cannot distinguish fake pieces from valid ones until decryption
- By the time decryption reveals garbage, the miner has already passed validation

**Probability: HIGH** - Trivial to execute, no detection mechanism, no punishment.

### Recommendation

**Code-Level Mitigation:**

1. **Add zero-knowledge proof or commitment validation** in `PerformSecretSharing`:
   - Require miners to provide a commitment that encrypted pieces encode the same InValue as PreviousInValue
   - Validate commitment before storing encrypted pieces

2. **Cross-verify reconstructed InValue** in `ProcessUpdateValue`:
   - After calling `RevealSharedInValues`, compare reconstructed InValue with self-reported PreviousInValue
   - Reject updates where Hash(reconstructed_InValue) != Hash(self_reported_PreviousInValue)
   - Add assertion at line 264 vicinity: [5](#0-4) 

3. **Implement punishment for invalid encrypted pieces**:
   - Mark miners as evil if their encrypted pieces cannot be properly decrypted or reconstructed
   - Trigger the evil miner detection flow: [10](#0-9) 

**Invariant to Add:**
`∀ miner: SecretSharingHelper.DecodeSecret(DecryptedPieces[miner]) == self_reported_PreviousInValue[miner]`

**Test Cases:**
- Test that UpdateValue fails when encrypted pieces don't decode to PreviousInValue
- Test that miners providing fake pieces are marked as evil
- Test that secret sharing reconstruction matches self-reported values for honest miners

### Proof of Concept

**Initial State:**
- Network has 5 active miners
- Secret sharing enabled (2/3 threshold = 4 pieces needed)
- Miner A is current block producer

**Attack Sequence:**

1. **Round N - Miner A produces block:**
   - Generate legitimate InValue_N = Hash("legitimate_random_seed")
   - Compute OutValue_N = Hash(InValue_N)
   - **ATTACK**: Generate fake encrypted pieces (random bytes) instead of properly encrypting shares of InValue_N
   - Include fake pieces in UpdateValueInput
   - Transaction executed via UpdateValue method

2. **Round N+1 - Other miners decrypt:**
   - Miners B, C, D, E decrypt Miner A's fake pieces
   - Receive garbage data, not valid secret shares
   - Store garbage in DecryptedPieces for Miner A

3. **Round N+1 - Secret sharing reconstruction:**
   - `RevealSharedInValues` attempts to reconstruct Miner A's InValue
   - `SecretSharingHelper.DecodeSecret` processes garbage data
   - Produces invalid_InValue ≠ InValue_N (or fails entirely)

4. **Round N+1 - Miner A's next update:**
   - Miner A provides correct PreviousInValue = InValue_N
   - Validation checks: Hash(InValue_N) == OutValue_N ✓ PASSES
   - No check that reconstructed invalid_InValue matches InValue_N
   - Transaction succeeds

**Expected Result:**
Validation should fail at step 4 when reconstructed InValue doesn't match self-reported value.

**Actual Result:**
Validation passes. Miner A successfully hides InValue_N while appearing compliant. Secret sharing protocol security guarantee violated.

**Success Condition:**
Miner A continues producing blocks and earning rewards while providing fake encrypted pieces that make InValue recovery impossible, demonstrating complete bypass of the secret sharing accountability mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L45-45)
```csharp
            EncryptedPieces = { minerInRound.EncryptedPieces },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-80)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L140-140)
```csharp
            currentRound.TryToDetectEvilMiners(out var evilMiners))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L263-264)
```csharp
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L290-290)
```csharp
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```
