### Title
Missing Miner List Validation in NextTerm Allows Consensus Takeover via Malicious NextTermInput Injection

### Summary
The `NextTerm` method accepts arbitrary miner lists in `NextTermInput` without validating them against the Election contract's `GetVictories` results. Any current or previous miner can inject a malicious `NextTermInput` with an arbitrary miner list to hijack consensus, bypassing the democratic election process entirely.

### Finding Description

**Root Cause:**
The `NextTerm` method processes `NextTermInput` and directly uses its miner list without verifying it matches the legitimate winners from the Election contract. [1](#0-0) 

**Entry Point:**
`NextTerm` is a public RPC method that accepts `NextTermInput` from any caller: [2](#0-1) 

**Authorization Check (Insufficient):**
The only authorization is `PreCheck()` which allows ANY current or previous round miner to call consensus methods: [3](#0-2) [4](#0-3) 

**Missing Validation:**
The validation for `NextTerm` only checks that term/round numbers increment by 1 and InValues are null, but does NOT validate the miner list: [5](#0-4) [6](#0-5) 

**Vulnerable Execution Path:**
`ProcessNextTerm` directly extracts the miner list from `NextTermInput` and calls `SetMinerList` without validation: [7](#0-6) 

The miner list is taken from `nextRound.RealTimeMinersInformation.Keys` (which comes from `NextTermInput`) without comparing it to the Election contract's `GetVictories` results: [8](#0-7) 

**What Should Happen:**
Legitimate term generation calls `GenerateFirstRoundOfNextTerm` which retrieves winners from the Election contract: [9](#0-8) [10](#0-9) 

**Why Protections Fail:**
The comment references a non-existent `ConstrainedAEDPoSTransactionValidationProvider` that should prevent malicious consensus transactions: [11](#0-10) 

This provider does not exist in the codebase, leaving no transaction-pool-level protection against malicious consensus method calls.

### Impact Explanation

**Complete Consensus Takeover:**
- Attacker gains full control over block production by injecting arbitrary miners
- Can exclude all legitimate validators, creating a single-miner or colluding-miner dictatorship
- Bypasses the entire Election contract voting mechanism
- All subsequent blocks and consensus decisions controlled by attacker

**Financial Impact:**
- Control over mining reward distribution (processable via `DonateMiningReward`)
- Authority over treasury releases tied to term transitions
- Ability to manipulate irreversible block heights
- Complete control over which transactions get included in blocks

**Governance Impact:**
- Undermines democratic validator election process
- Attackers can maintain indefinite control by repeatedly calling `NextTerm` with their own miner list
- Legitimate validators permanently excluded from consensus

**Protocol Integrity:**
- Violates the core invariant: "miner schedule integrity"
- Election contract voting results become meaningless
- Cross-chain security compromised if sidechains rely on mainchain miner set

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current or previous round miner (achievable through legitimate election or by compromising one miner)
- Must have ability to submit transactions or produce blocks

**Attack Complexity:**
- LOW: Simply craft `NextTermInput` with:
  - `TermNumber = currentTerm + 1`
  - `RoundNumber = currentRound + 1`
  - `RealTimeMinersInformation` containing only attacker-controlled miners
  - All `InValue` fields set to null
- Submit transaction calling `NextTerm(maliciousInput)` or include it when producing a block

**Feasibility:**
- HIGH: No cryptographic challenges, race conditions, or complex state manipulation
- Attack succeeds if attacker produces the block containing the term transition OR submits transaction that gets included first
- `EnsureTransactionOnlyExecutedOnceInOneBlock` only prevents duplicate executions in same block, not malicious input [12](#0-11) 

**Detection:**
- Difficult to detect immediately as the malicious miner list will appear valid to contract state
- Election contract's `TakeSnapshot` is called but doesn't validate the miner list matches its winners
- Requires off-chain monitoring comparing actual miner lists to expected `GetVictories` results

**Probability:**
- HIGH if any miner becomes malicious or is compromised
- Permanent damage once exploited (requires manual intervention/fork to recover)

### Recommendation

**1. Add Miner List Validation in ProcessNextTerm:**
```solidity
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADD THIS: Validate miner list against Election contract
    if (State.IsMainChain.Value)
    {
        var expectedMinerList = State.ElectionContract.GetVictories.Call(new Empty());
        var actualMiners = new MinerList
        {
            Pubkeys = { nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
        
        Assert(
            expectedMinerList.Pubkeys.Count == actualMiners.Pubkeys.Count &&
            expectedMinerList.Pubkeys.All(pk => actualMiners.Pubkeys.Contains(pk)),
            "Miner list does not match Election contract results"
        );
    }
    
    // ... rest of existing logic
}
```

**2. Add Validation Provider:**
Create a `NextTermMinerListValidationProvider` that validates the miner list during `ValidateBeforeExecution`: [5](#0-4) 

**3. Implement Transaction Pool Validation:**
Implement the referenced `ConstrainedAEDPoSTransactionValidationProvider` to restrict consensus method calls at the transaction pool level.

**4. Add Test Cases:**
- Test that `NextTerm` with non-matching miner list fails
- Test that only GetVictories-validated miner lists are accepted
- Test that previous miners cannot inject arbitrary miner lists

### Proof of Concept

**Initial State:**
- Current term: 100, round: 1000
- Current miners: [MinerA, MinerB, MinerC]
- Election contract GetVictories would return: [MinerX, MinerY, MinerZ] for next term
- Attacker controls MinerB

**Attack Steps:**

1. MinerB crafts malicious `NextTermInput`:
```protobuf
NextTermInput {
  term_number: 101,
  round_number: 1001,
  real_time_miners_information: {
    "MinerB_pubkey": { order: 1, in_value: null, ... },
    "MinerB_accomplice": { order: 2, in_value: null, ... }
  },
  // ... other fields matching normal increments
}
```

2. MinerB submits transaction:
```
To: AEDPoS Contract
Method: NextTerm
Params: maliciousNextTermInput
```

3. Transaction executes:
    - `PreCheck()` passes (MinerB is in current miner list)
    - `EnsureTransactionOnlyExecutedOnceInOneBlock()` passes (first consensus tx in block)
    - Validation only checks term/round numbers (both correct) âœ“
    - `ProcessNextTerm` calls `SetMinerList` with [MinerB, MinerB_accomplice]

**Expected Result:**
Transaction should FAIL with "Miner list does not match Election contract results"

**Actual Result:**
Transaction SUCCEEDS. Term 101 now has only [MinerB, MinerB_accomplice] as miners, completely bypassing the election of [MinerX, MinerY, MinerZ]. MinerB maintains control indefinitely by repeating the attack for subsequent terms.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** protobuf/aedpos_contract.proto (L37-39)
```text
    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-28)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-92)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L134-138)
```csharp
    private void EnsureTransactionOnlyExecutedOnceInOneBlock()
    {
        Assert(State.LatestExecutedHeight.Value != Context.CurrentHeight, "Cannot execute this tx.");
        State.LatestExecutedHeight.Value = Context.CurrentHeight;
    }
```
