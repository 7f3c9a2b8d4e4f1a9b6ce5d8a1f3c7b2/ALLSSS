### Title
Method Fee Controller Validation Bypass via Malicious Contract

### Summary
The `ChangeMethodFeeController()` function's `CheckOrganizationExist()` validation can be bypassed by deploying a malicious contract that implements `ValidateOrganizationExist` and always returns `true`. This allows setting an arbitrary contract as the method fee controller, bypassing the intended governance model where only Parliament, Association, or Referendum contracts should control method fees.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist()` function implementation: [1](#0-0) 

This function performs a cross-contract call to `authorityInfo.ContractAddress` without validating that the address points to a legitimate governance contract (Parliament, Association, or Referendum). It simply calls `ValidateOrganizationExist` on whatever contract address is provided and trusts the response. [2](#0-1) 

The legitimate governance contracts implement `ValidateOrganizationExist` by checking if the organization exists in their state: [3](#0-2) [4](#0-3) 

However, an attacker can deploy a malicious contract that implements the same interface but always returns `true`, bypassing the organization existence check entirely.

**Root Cause**: The validation logic assumes that only legitimate governance contracts will be passed as `ContractAddress`, but there is no enforcement of this assumption. The code lacks a whitelist check to verify that `authorityInfo.ContractAddress` is one of the three system governance contracts.

**Why Protection Fails**: While `Context.Call` will throw an exception for non-existent contracts or missing methods (protecting against scenario 1), it cannot detect a malicious contract that deliberately implements the expected interface with malicious behavior (scenario 2). [5](#0-4) 

This same vulnerable pattern is replicated across all ACS1-implementing contracts in the system: [6](#0-5) 

### Impact Explanation

**Authorization & Governance Bypass**: An attacker who successfully changes the MethodFeeController to a malicious contract gains unauthorized control over method fee settings for the Genesis contract (and by the same pattern, all other system contracts implementing ACS1).

**Affected System Scope**: The vulnerability pattern exists in 15+ system contracts including Genesis, MultiToken, Parliament, Association, Referendum, Consensus, CrossChain, Economic, Treasury, Profit, TokenConverter, TokenHolder, Election, Vote, and Configuration contracts.

**Concrete Harm**:
1. Attacker can call `SetMethodFee()` directly without governance approval after the malicious controller is set
2. Method fees can be set to extreme values (0 or very high), disrupting contract economics
3. The governance invariant "method fee changes require proper organization approval" is violated
4. Trust in the governance model is undermined as method fee control bypasses intended multi-signature or Parliament approval mechanisms [7](#0-6) 

**Severity Justification**: While no direct fund theft occurs, the ability to bypass governance for critical configuration changes (method fees) represents a fundamental breach of the authorization model that underpins the entire system's security.

### Likelihood Explanation

**Precondition Requirements**: The attack requires the attacker to first become the current MethodFeeController.OwnerAddress, which by default is the Parliament default organization requiring 2/3 block producer approval. [8](#0-7) 

**Attack Complexity**: 
1. Deploy malicious contract with `ValidateOrganizationExist` method that always returns `true`
2. Submit governance proposal to change MethodFeeController to malicious contract + attacker address
3. Obtain governance approval (2/3 BPs)
4. Execute proposal via `Parliament.Release()`
5. After controller change, directly call `SetMethodFee()` without further governance approval

**Feasibility Constraint**: The critical constraint is **step 2-4 requires governance approval**, which is a trusted role compromise. The vulnerability exists because the validation logic fails to protect against malicious controller changes even when governance might approve them unknowingly.

**Economic Rationality**: While contract deployment costs are reasonable, the fundamental dependency on governance compromise significantly reduces exploitability.

**Detection**: A malicious controller change would be visible on-chain in the proposal text and could be detected before execution if governance participants inspect the `ContractAddress` parameter carefully.

### Recommendation

**Code-Level Mitigation**: Add explicit validation that `authorityInfo.ContractAddress` is one of the three legitimate governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address."
    );
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant Check**: Add assertion: "MethodFeeController.ContractAddress must be Parliament, Association, or Referendum system contract"

**Apply Fix Across System**: This same fix must be applied to all 15+ contracts using the vulnerable `CheckOrganizationExist` pattern.

**Test Cases**:
1. Attempt to set MethodFeeController with non-governance contract address → should fail
2. Attempt to set MethodFeeController with user-deployed contract → should fail  
3. Verify legitimate controller changes with Parliament/Association/Referendum still work
4. Verify malicious contract with `ValidateOrganizationExist` is rejected

### Proof of Concept

**Initial State**: Genesis contract deployed with default Parliament controller

**Attack Sequence**:

1. **Deploy malicious contract** (MaliciousGovernance.sol):
```csharp
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

2. **Create Parliament proposal**:
   - Method: `ChangeMethodFeeController`
   - Parameter: `AuthorityInfo { ContractAddress = <malicious_contract>, OwnerAddress = <attacker_address> }`

3. **Obtain 2/3 BP approval and execute proposal**

4. **Expected Result**: Proposal should fail with "Invalid governance contract address"

5. **Actual Result** (vulnerable version): 
   - CheckOrganizationExist calls malicious contract
   - Malicious contract returns `true`
   - MethodFeeController set to malicious controller
   - Attacker can now directly call `SetMethodFee()` without governance

6. **Success Condition**: Attacker can execute `SetMethodFee()` directly with `Context.Sender == <attacker_address>` matching the OwnerAddress, bypassing all governance requirements.

### Notes

This vulnerability demonstrates insufficient validation of external contract addresses in authorization flows. While exploitation requires initial governance approval (reducing practical likelihood), the validation failure means the safety check provides no actual protection against malicious controllers. The fix is straightforward but must be applied consistently across all ACS1-implementing contracts to fully address the systemic issue.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L59-71)
```csharp
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.DeploySmartContract(contractAddress, reg, name);

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-18)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-29)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L199-226)
```csharp
    public T Call<T>(Address fromAddress, Address toAddress, string methodName, ByteString args)
        where T : IMessage<T>, new()
    {
        var trace = AsyncHelper.RunSync(async () =>
        {
            var chainContext = new ChainContext
            {
                BlockHash = TransactionContext.PreviousBlockHash,
                BlockHeight = TransactionContext.BlockHeight - 1,
                StateCache = CachedStateProvider.Cache
            };

            var tx = new Transaction
            {
                From = fromAddress,
                To = toAddress,
                MethodName = methodName,
                Params = args
            };
            return await _transactionReadOnlyExecutionService.ExecuteAsync(chainContext, tx, CurrentBlockTime);
        });

        if (!trace.IsSuccessful()) throw new ContractCallException(trace.Error);

        var obj = new T();
        obj.MergeFrom(trace.ReturnValue);
        return obj;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
