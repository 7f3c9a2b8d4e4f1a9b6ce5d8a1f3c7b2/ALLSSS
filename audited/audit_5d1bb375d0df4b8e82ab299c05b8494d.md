### Title
Initial Miner Exclusion Bypass via Round 1 Data Corruption Leading to Welcome Reward Misallocation

### Summary
The `Release()` function filters initial miners from welcome rewards using `GetInitialMinerList()`, which queries round 1 data from the AEDPoS contract. If round 1 data is corrupted or missing, this function returns an empty list, causing the exclusion filter to fail and allowing initial miners with `LatestMinedTerm == 0` to fraudulently qualify for welcome rewards intended only for newly elected miners.

### Finding Description

The vulnerability exists in the `Release()` function's initial miner filtering mechanism: [1](#0-0) 

The filter relies on `GetInitialMinerList()` to identify and exclude initial miners: [2](#0-1) 

This function calls `GetRoundInformation` on the AEDPoS contract for round 1. The AEDPoS implementation returns an empty `Round` object when round data doesn't exist: [3](#0-2) 

The underlying check uses `TryToGetRoundInformation`, which validates round existence: [4](#0-3) 

A `Round` is considered empty when `RoundId == 0`: [5](#0-4) 

When round 1 data is corrupted or missing, `GetInitialMinerList()` returns an empty list. The filter condition `!GetInitialMinerList().Contains(p)` then evaluates to `true` for all miners, including initial miners. Initial miners who have `State.LatestMinedTerm[p] == 0` (never mined or previously replaced) will pass both filter conditions and be added to welcome rewards: [6](#0-5) 

**Why Protections Fail:**
- Round 1 is designed to be preserved from deletion, but no validation exists for data corruption scenarios
- No defensive check verifies that `GetInitialMinerList()` returns a non-empty result
- No fallback mechanism exists when round 1 data is unavailable

**Conditions for Exploitation:**
1. Round 1 data must be corrupted/missing (State.Rounds[1] is null or isEmpty)
2. Initial miner must have `State.LatestMinedTerm[pubkey] == 0` - occurs when:
   - Miner was in initial setup but never entered any `currentMinerList`, OR
   - Miner was replaced (non-evil) and their state removed: [7](#0-6) 

3. Initial miner must re-enter the mining pool (in current/previous term or as replacement candidate)

### Impact Explanation

**Direct Harm:**
- Initial miners receive welcome rewards they should be excluded from, causing misallocation of treasury funds
- Welcome rewards are distributed with 1 share per qualified miner from the `VotesWeightRewardHash` scheme
- Legitimate new miners receive diluted rewards as the pool is split with ineligible initial miners

**Affected Parties:**
- Truly new miners: reduced welcome incentives due to pool dilution
- Treasury: incorrect fund distribution violating reward policy
- Protocol: compromised integrity of miner onboarding incentive mechanism

**Severity Justification:** MEDIUM
- Direct financial impact through reward misallocation
- Violates critical invariant: "Profit/Treasury/TokenHolder share calculations, donation/release logic, dividend distribution and settlement accuracy"
- Does not result in total fund theft, but systematic misallocation over time
- Limited to welcome reward pool (default weight of 1 out of 4 for miner rewards)

### Likelihood Explanation

**Preconditions:**
1. **Round 1 Data Corruption:** LOW probability
   - Round 1 is explicitly protected from deletion in normal cleanup operations: [8](#0-7) 
   
   - Could occur through state migration errors, database corruption, or initialization bugs
   - Not exploitable by external attacker without system-level access

2. **Initial Miner with LatestMinedTerm == 0:** MEDIUM probability
   - Possible if initial miner never participated actively
   - Guaranteed if replaced miner re-enters (state explicitly removed at line 587)

3. **Initial Miner Re-entry:** MEDIUM probability
   - Miners can be re-elected in subsequent terms through normal election process

**Attack Complexity:** 
- Not directly exploitable by attackers (requires system-level data corruption)
- However, represents a critical resilience failure when corruption occurs
- No attacker capabilities required beyond triggering the existing Release() flow

**Detection:** 
- Difficult to detect without monitoring round 1 data integrity
- Misallocations appear as legitimate welcome reward distributions

**Overall Likelihood:** LOW-MEDIUM
- Primary barrier is the low-probability corruption precondition
- Once corruption occurs, exploitation is automatic through normal operations

### Recommendation

1. **Add Defensive Validation:**
```csharp
private List<string> GetInitialMinerList()
{
    var round = State.AEDPoSContract.GetRoundInformation.Call(new Int64Value { Value = 1 });
    Assert(round != null && round.RealTimeMinersInformation.Count > 0, 
           "Critical error: Round 1 data is missing or corrupted.");
    return round.RealTimeMinersInformation.Keys.ToList();
}
```

2. **Cache Initial Miner List:**
Store initial miners in contract state during initialization to eliminate dependency on round 1 data:
```csharp
// In InitialMiningRewardProfitItem or similar initialization
State.InitialMinerList.Value = new StringList 
{ 
    Value = { State.AEDPoSContract.GetRoundInformation.Call(new Int64Value { Value = 1 })
                    .RealTimeMinersInformation.Keys } 
};

// Use cached value in GetInitialMinerList
private List<string> GetInitialMinerList()
{
    return State.InitialMinerList.Value?.Value.ToList() ?? new List<string>();
}
```

3. **Add Invariant Test:**
Implement regression test verifying initial miners never qualify for welcome rewards regardless of round data state.

### Proof of Concept

**Initial State:**
- System initialized with initial miners [M1, M2, M3] in round 1
- M1 participates in early terms, then is replaced (non-evil)
- M1's `LatestMinedTerm` entry is removed per line 587
- Round 1 data subsequently corrupted (e.g., state migration error)

**Exploitation Sequence:**

1. **Term N:** M1 re-elected through normal election process
   - M1 enters `currentMinerList` for term N+1
   
2. **AEDPoS calls Release(N):**
   - Line 141-145: M1 added to `maybeNewElectedMiners` (in currentMinerList)
   - Line 156: Filter evaluation:
     - `State.LatestMinedTerm[M1]` returns 0 (entry was removed) ✓
     - `GetInitialMinerList()` returns empty list (round 1 corrupted)
     - `!GetInitialMinerList().Contains(M1)` evaluates to `true` ✓
   - M1 passes filter and included in `newElectedMiners`
   
3. **Line 762:** `UpdateWelcomeRewardWeights` called with M1 in `newElectedMiners`

4. **Lines 867-879:** M1 added to welcome reward beneficiaries with 1 share

**Expected Result:** M1 should be excluded (is initial miner)

**Actual Result:** M1 receives welcome rewards, diluting pool for legitimate new miners

**Success Condition:** M1's address appears in welcome reward scheme beneficiaries for term N+1, which can be verified through profit contract queries.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L155-156)
```csharp
        maybeNewElectedMiners = maybeNewElectedMiners
            .Where(p => State.LatestMinedTerm[p] == 0 && !GetInitialMinerList().Contains(p)).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L168-172)
```csharp
    private List<string> GetInitialMinerList()
    {
        return State.AEDPoSContract.GetRoundInformation.Call(new Int64Value { Value = 1 }).RealTimeMinersInformation
            .Keys.ToList();
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L583-587)
```csharp
        if (!input.IsOldPubkeyEvil)
        {
            var latestMinedTerm = State.LatestMinedTerm[input.OldPubkey];
            State.LatestMinedTerm[input.NewPubkey] = latestMinedTerm;
            State.LatestMinedTerm.Remove(input.OldPubkey);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L864-879)
```csharp
        if (newElectedMiners.Any())
        {
            Context.LogDebug(() => "Welcome reward will go to new miners.");
            var newBeneficiaries = new AddBeneficiariesInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                EndPeriod = previousTermInformation.TermNumber.Add(1)
            };
            foreach (var minerAddress in newElectedMiners.Select(GetProfitsReceiver))
                newBeneficiaries.BeneficiaryShares.Add(new BeneficiaryShare
                {
                    Beneficiary = minerAddress,
                    Shares = 1
                });

            if (newBeneficiaries.BeneficiaryShares.Any()) State.ProfitContract.AddBeneficiaries.Send(newBeneficiaries);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L26-29)
```csharp
    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L118-123)
```csharp
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L26-26)
```csharp
    public bool IsEmpty => RoundId == 0;
```
