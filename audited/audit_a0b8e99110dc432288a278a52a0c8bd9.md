### Title
Inconsistent Resource Declaration for Zero-Fee Symbols Breaks ACS2 Parallel Execution

### Summary
The compound condition at line 71 excludes symbols with `BasicFee = 0` from the resource path declaration in `GetTransactionFeeSymbols`, but these symbols are still processed during fee charging, causing undeclared state path accesses. This violates ACS2 invariants and triggers parallel execution failure detection, resulting in systematic performance degradation or transaction DoS for methods configured with zero-fee symbols.

### Finding Description

**Root Cause**: 
The filtering logic in `GetTransactionFeeSymbols` excludes symbols when `BasicFee = 0`: [1](#0-0) 

However, `GetBaseFeeDictionary` includes ALL symbols regardless of BasicFee value (including zero): [2](#0-1) 

**Execution Path**:
1. During ACS2 resource declaration, `GetResourceInfo` calls `AddPathForTransactionFee`, which uses `GetTransactionFeeSymbols` to determine which balance paths to declare: [3](#0-2) 

2. Symbols with `BasicFee = 0` are excluded from the declared paths, so their balance state paths are NOT added to `ResourceInfo.WritePaths`.

3. Later during transaction execution, `ChargeTransactionFees` processes the fee dictionary that includes zero-fee symbols and calls `TryToChargeUserBaseFee`: [4](#0-3) 

4. `TryToChargeUserBaseFee` iterates through ALL symbols (including those with amount = 0) and calls `GetBalance`: [5](#0-4) 

5. `GetBalance` reads the undeclared state path: [6](#0-5) 

6. The parallel execution validation service detects this mismatch between declared and actual state accesses: [7](#0-6) 

**Why Protections Fail**: 
The code assumes that filtering symbols by `BasicFee > 0` is sufficient because zero-fee symbols won't result in balance modifications. However, the fee charging logic still READS balances for all symbols to determine which token to charge, creating undeclared state accesses that violate ACS2.

### Impact Explanation

**Operational Impact (Medium)**:
- All transactions calling methods with `BasicFee = 0` symbols will be marked as having "wrong resources" by the parallel execution system
- These transactions cannot be properly grouped for parallel execution, causing systematic performance degradation
- Affected transactions are logged as conflicting and may face execution failures depending on node configuration
- This violates the ACS2 critical invariant that declared resource paths must match actual accesses

**Scope**: 
Any method configured with MethodFees containing symbols where `BasicFee = 0` is affected. This could include:
- Methods intentionally configured as "free" (only size fees apply)
- Temporary fee configurations during transitions
- Mixed fee structures where some tokens have zero base fees

**Severity Justification**: 
While this doesn't directly cause fund loss, it creates systematic operational disruption of the parallel execution system, a core performance feature of AElf. The impact scales with usage of affected methods.

### Likelihood Explanation

**Preconditions**:
- Requires `MethodFeeController` (typically governance via Parliament) to set `BasicFee = 0` for one or more symbols in a method's fee configuration: [8](#0-7) 

**Feasibility**:
- **Medium Likelihood**: While governance-controlled, setting `BasicFee = 0` is a legitimate configuration choice (e.g., making certain methods free or configuring size-fee-only methods)
- Could occur accidentally during fee updates or intentionally for specific use cases
- Once configured, the issue affects ALL subsequent transactions using that method
- No malicious intent required; normal governance operations can trigger this

**Attack Complexity**: 
Low - Once the precondition is met through governance action, the issue manifests automatically without further intervention.

### Recommendation

**Fix Option 1 (Recommended)**: Include zero-fee symbols in resource declaration
Modify line 71 to remove the `BasicFee > 0` check, since the balance is read regardless:
```csharp
if (!symbols.Contains(methodFee.Symbol))
    symbols.Add(methodFee.Symbol);
```

**Fix Option 2**: Skip balance reads for zero-amount fees
Modify `TryToChargeUserBaseFee` to skip iteration entries where `value == 0`:
```csharp
foreach (var (symbol, value) in symbolToAmountMap)
{
    if (value <= 0) continue;  // Skip zero-fee symbols
    // ... existing logic
}
```

**Fix Option 3**: Filter zero-amount entries from GetBaseFeeDictionary
```csharp
return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
    .GroupBy(f => f.Symbol, f => f.BasicFee)
    .ToDictionary(g => g.Key, g => g.Sum())
    .Where(kvp => kvp.Value > 0)  // Filter out zero sums
    .ToDictionary(kvp => kvp.Key, kvp => kvp.Value);
```

**Test Cases**:
1. Set MethodFees with `BasicFee = 0` for a symbol
2. Execute method and verify ResourceInfo includes that symbol's balance path
3. Verify ConflictingTransactionIdentificationService doesn't flag the transaction
4. Confirm parallel execution works correctly

### Proof of Concept

**Initial State**:
- MethodFeeController is configured (Parliament address)
- Method "SomeMethod" exists on a contract

**Attack Sequence**:
1. Governance calls `SetMethodFee` with:
   ```
   method_name: "SomeMethod"
   fees: [
     {symbol: "ELF", basic_fee: 100},
     {symbol: "USDT", basic_fee: 0}
   ]
   ```

2. User calls "SomeMethod" transaction

3. `GetResourceInfo` executes:
   - `GetTransactionFeeSymbols` returns ["ELF"] (excludes "USDT")
   - Only ELF balance path added to ResourceInfo

4. Transaction executes, `ChargeTransactionFees` called:
   - `GetBaseFeeDictionary` returns {ELF: 100, USDT: 0}
   - `TryToChargeUserBaseFee` calls `GetBalance(user, "USDT")`
   - Reads `State.Balances[user]["USDT"]` - UNDECLARED PATH

5. `ConflictingTransactionIdentificationService` validation:
   - Compares declared paths vs actual StateAccesses
   - Detects USDT balance key in actual but not in declared
   - Marks transaction as having wrong resources

**Expected Result**: Transaction executes normally with proper parallel grouping

**Actual Result**: Transaction flagged as conflicting, cannot be properly parallelized, logged as having wrong resource declaration

**Success Condition**: System logs show the transaction in `wrongTxnWithResources` list with USDT balance key in the conflict set

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L71-72)
```csharp
                if (!symbols.Contains(methodFee.Symbol) && methodFee.BasicFee > 0)
                    symbols.Add(methodFee.Symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L278-283)
```csharp
        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L762-767)
```csharp
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L84-96)
```csharp
    private void AddPathForTransactionFee(ResourceInfo resourceInfo, string from, string methodName)
    {
        var symbols = GetTransactionFeeSymbols(methodName);
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        if (_primaryTokenSymbol != string.Empty && !symbols.Contains(primaryTokenSymbol))
            symbols.Add(primaryTokenSymbol);
        var paths = symbols.Select(symbol => GetPath(nameof(TokenContractState.Balances), from, symbol));
        foreach (var path in paths)
        {
            if (resourceInfo.WritePaths.Contains(path)) continue;
            resourceInfo.WritePaths.Add(path);
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ConflictingTransactionIdentificationService.cs (L46-74)
```csharp
    private async Task<List<TransactionWithResourceInfo>> FindContractOfWrongResourcesAsync(IChainContext chainContext,
        List<ExecutionReturnSet> returnSets)
    {
        var transactionIds = returnSets.Select(rs => rs.TransactionId);
        var transactions = await _blockchainService.GetTransactionsAsync(transactionIds);

        var txnWithResources =
            await _resourceExtractionService.GetResourcesAsync(chainContext, transactions, CancellationToken.None);
        txnWithResources =
            txnWithResources.Where(t => t.TransactionResourceInfo.ParallelType == ParallelType.Parallelizable);

        var txnWithResourceList = txnWithResources.ToList();
        var readOnlyKeys = txnWithResourceList.GetReadOnlyPaths().Select(p => p.ToStateKey()).ToList();
        var returnSetLookup = returnSets.ToDictionary(rs => rs.TransactionId, rs => rs);
        var wrongTxnWithResources = new List<TransactionWithResourceInfo>();
        foreach (var txnWithResource in txnWithResourceList)
        {
            var extracted = new HashSet<string>(txnWithResource.TransactionResourceInfo.WritePaths
                .Concat(txnWithResource.TransactionResourceInfo.ReadPaths).Select(p => p.ToStateKey()));
            extracted.ExceptWith(readOnlyKeys);
            var actual = GetKeys(returnSetLookup[txnWithResource.Transaction.GetHash()]);
            actual.ExceptWith(extracted);
            if (actual.Count == 0) continue;
            Logger.LogDebug($"Conflict keys:{string.Join(";", actual)}");
            wrongTxnWithResources.Add(txnWithResource);
        }

        return wrongTxnWithResources;
    }
```
