### Title
Proposals Created via CreateProposalBySystemContract Are Permanently Unreleasable Due to Incorrect Proposer Assignment

### Summary
All three governance contracts (Referendum, Parliament, Association) incorrectly set the `Proposer` field to the system contract address instead of the `OriginProposer` when creating proposals through `CreateProposalBySystemContract`. This causes the `Release()` function's authorization check to fail for the actual user, making approved proposals permanently unreleasable and blocking critical workflows like contract deployment and updates.

### Finding Description

**Root Cause:**

In `CreateNewProposal()`, the `Proposer` field is always set to `Context.Sender`: [1](#0-0) [2](#0-1) [3](#0-2) 

When `CreateProposalBySystemContract()` is invoked by a system contract (e.g., BasicContractZero), `Context.Sender` is the system contract address, not the actual user: [4](#0-3) [5](#0-4) [6](#0-5) 

While the method correctly validates authorization for `input.OriginProposer` (the actual user), it does not use this value when setting the proposal's `Proposer` field.

**Why Protections Fail:**

The `Release()` function enforces that only the proposer can release an approved proposal: [7](#0-6) [8](#0-7) [9](#0-8) 

Since `proposal.Proposer` is set to the system contract address, only that system contract can call `Release()`. However:
- System contracts are automated protocol contracts without private keys
- There is no mechanism for system contracts to monitor proposal approval status and call `Release()`
- The `OriginProposer` (actual user) will always fail the authorization check

**Execution Path:**

The vulnerability manifests in the contract deployment/update flow: [10](#0-9) [11](#0-10) 

1. User calls `ProposeNewContract()` or `ProposeUpdateContract()` on BasicContractZero
2. BasicContractZero (system contract) calls `CreateProposalBySystemContract()` with `OriginProposer = Context.Sender` (the user)
3. Proposal is created with `Proposer = BasicContractZero` address
4. Proposal undergoes voting and gets approved
5. User attempts to call `Release()` → fails with "No permission"
6. Proposal remains in approved state but cannot be executed

### Impact Explanation

**Operational Impact: Critical DoS of Governance Flows**

- **Contract Deployment Blocked**: All new contract deployments via `ProposeNewContract()` cannot be released after approval, preventing any new contracts from being deployed to the chain
- **Contract Updates Blocked**: All contract upgrades via `ProposeUpdateContract()` cannot be released, freezing the protocol at its current version and preventing critical bug fixes or improvements
- **Governance Deadlock**: Any system contract creating proposals on behalf of users (a core governance pattern) results in permanently stuck proposals

**Who Is Affected:**
- Contract developers attempting to deploy new contracts
- System administrators attempting to upgrade existing contracts
- Any user or system requiring the governance flow through `CreateProposalBySystemContract`

**Severity Justification:**
HIGH severity because:
- Completely breaks critical protocol functionality (contract deployment/update)
- Affects all three governance contracts (Referendum, Parliament, Association)
- No workaround exists within the current contract design
- Requires protocol-level fix to restore functionality

### Likelihood Explanation

**Attacker Capabilities:**
No attacker action required - this is a design flaw that occurs during normal protocol operation.

**Attack Complexity:**
None - the vulnerability is triggered by legitimate users performing standard operations.

**Feasibility Conditions:**
- User calls `ProposeNewContract()` or `ProposeUpdateContract()` on BasicContractZero (normal operation)
- Proposal gets approved through voting (intended flow)
- User attempts to release the approved proposal (expected behavior)
- Release fails due to authorization check (bug manifestation)

**Probability:**
CERTAIN - This occurs 100% of the time when using the `CreateProposalBySystemContract` flow, which is the standard mechanism for contract deployment/update governance.

### Recommendation

**Code-Level Mitigation:**

Modify all three governance contracts to accept and use the `OriginProposer` parameter when creating proposals via system contracts:

1. **Update CreateProposalBySystemContract signature** to pass `OriginProposer` to `CreateNewProposal()`
2. **Modify CreateNewProposal** to accept an optional proposer parameter
3. **Set Proposer field** to the provided parameter (for system contract flow) or Context.Sender (for direct flow)

Example fix for Referendum_Helper.cs:
```csharp
private Hash CreateNewProposal(CreateProposalInput input, Address proposer = null)
{
    CheckCreateProposalInput(input);
    var proposalId = GenerateProposalId(input);
    Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
    var proposal = new ProposalInfo
    {
        ContractMethodName = input.ContractMethodName,
        ToAddress = input.ToAddress,
        ExpiredTime = input.ExpiredTime,
        Params = input.Params,
        OrganizationAddress = input.OrganizationAddress,
        Proposer = proposer ?? Context.Sender,  // Use provided proposer or default to Context.Sender
        ProposalDescriptionUrl = input.ProposalDescriptionUrl,
        Title = input.Title,
        Description = input.Description
    };
    // ... rest of function
}
```

And update the call in Referendum.cs:
```csharp
public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
{
    Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
        "Not authorized to propose.");
    AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
    var proposalId = CreateNewProposal(input.ProposalInput, input.OriginProposer);  // Pass OriginProposer
    return proposalId;
}
```

Apply the same fix to Parliament_Helper.cs and Association_Helper.cs.

**Test Cases to Add:**
1. Create proposal via `CreateProposalBySystemContract` with `OriginProposer = UserA`
2. Approve the proposal through voting
3. Call `Release()` as UserA (OriginProposer)
4. Verify Release succeeds and proposal executes
5. Verify GetProposal shows correct Proposer = UserA

### Proof of Concept

**Initial State:**
- BasicContractZero deployed as system contract
- Parliament/Association/Referendum governance contracts deployed
- User A wants to deploy a new contract

**Transaction Sequence:**

1. **User A calls ProposeNewContract():**
   - Context.Sender = UserA
   - BasicContractZero creates CreateProposalBySystemContractInput with OriginProposer = UserA

2. **BasicContractZero calls CreateProposalBySystemContract() on Parliament:**
   - Context.Sender = BasicContractZero (system contract)
   - OriginProposer = UserA (passed in input)
   - AssertIsAuthorizedProposer(organizationAddress, UserA) ✓ passes
   - CreateNewProposal() sets Proposer = Context.Sender = BasicContractZero

3. **Proposal gets approved by parliament members:**
   - Sufficient approvals collected
   - IsReleaseThresholdReached() returns true

4. **User A calls Release(proposalId):**
   - Context.Sender = UserA
   - proposal.Proposer = BasicContractZero
   - Assert(Context.Sender.Equals(proposal.Proposer)) evaluates to Assert(UserA == BasicContractZero)
   - ✗ FAILS with "No permission."

**Expected vs Actual Result:**
- **Expected:** User A (OriginProposer) can release the approved proposal
- **Actual:** Only BasicContractZero can release it, but as a system contract it has no mechanism to do so

**Success Condition for Exploit:**
The vulnerability is confirmed by the Release() call failing with "No permission" when invoked by the OriginProposer, despite the proposal being fully approved and the OriginProposer being the legitimate initiator of the proposal.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L61-68)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L68-76)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);

        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L65-73)
```csharp
    #endregion view

    #region Actions

    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L143-173)
```csharp
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(DeploySmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = input.Category,
                    IsSystemContract = false
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
        Context.SendInline(State.ContractDeploymentController.Value.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput.ToByteString());

        Context.Fire(new ContractProposed
        {
            ProposedContractInputHash = proposedContractInputHash
        });

        return proposedContractInputHash;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L202-221)
```csharp
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName =
                    nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.ProposeContractCodeCheck),
                Params = new ContractCodeCheckInput
                {
                    ContractInput = input.ToByteString(),
                    CodeCheckReleaseMethod = nameof(UpdateSmartContract),
                    ProposedContractInputHash = proposedContractInputHash,
                    Category = info.Category,
                    IsSystemContract = info.IsSystemContract
                }.ToByteString(),
                OrganizationAddress = State.ContractDeploymentController.Value.OwnerAddress,
                ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
            },
            OriginProposer = Context.Sender
        };
```
