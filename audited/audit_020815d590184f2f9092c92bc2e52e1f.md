### Title
Negative MissedTimeSlots Bypass Evil Miner Detection via Unchecked Round Input

### Summary
Miners can inject negative `MissedTimeSlots` values through crafted `NextRoundInput` transactions, bypassing the evil miner detection mechanism. Since no validator checks for non-negative values and the detection logic uses `>=` comparison against a positive threshold, negative counters will never trigger punishment, allowing malicious miners to miss unlimited time slots without being banned.

### Finding Description

**Root Cause:**

The `NextRound` method accepts user-provided `NextRoundInput` containing `MinerInRound` structures with `MissedTimeSlots` values (int64/signed type). No validation ensures these values are non-negative. [1](#0-0) 

The input is directly converted to a Round object and stored without checking MissedTimeSlots bounds: [2](#0-1) 

**Why Protections Fail:**

All validators for NextRound behavior check structural properties but ignore MissedTimeSlots values: [3](#0-2) [4](#0-3) 

The PreCheck only verifies miner membership, not input data integrity: [5](#0-4) 

**Execution Path:**

When `GenerateNextRoundInformation` processes rounds with negative MissedTimeSlots (line 54), the SafeMath.Add simply performs arithmetic addition without bounds checking: [6](#0-5) [7](#0-6) 

If MissedTimeSlots = -1000, then -1000 + 1 = -999 (remains negative). Evil miner detection compares against positive threshold and fails: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Compromise:**

Malicious miners can completely bypass the punishment mechanism designed to maintain consensus quality. The evil miner detection is a critical invariant that ensures miners who consistently fail to produce blocks are removed from the validator set.

**Concrete Harm:**
- Miners can miss unlimited time slots without being marked as evil nodes
- The `-999 >= TolerableMissedTimeSlotsCount` comparison always returns false for negative values
- Undermines the economic security model that penalizes unreliable validators
- Other honest miners lose block rewards when malicious miners hold time slots but don't produce
- Network liveness degrades as slots are wasted by non-performing miners

**Affected Parties:**
- Honest miners suffer reduced rewards
- Token holders experience degraded consensus performance
- Users experience slower block times and reduced throughput

**Severity Justification:**

Medium severity because while it doesn't directly steal funds, it compromises a critical consensus invariant (miner schedule integrity), enabling operational DoS where malicious validators indefinitely occupy slots meant for reliable block production.

### Likelihood Explanation

**Attacker Capabilities:**

The attacker must be a current miner in the validator set. This is a realistic scenario as:
1. Miners are elected through governance voting
2. A compromised or malicious node could be elected
3. The attack requires no special privileges beyond normal miner duties

**Attack Complexity:**

Low complexity. The attacker:
1. Monitors when they are scheduled to produce a NextRound block
2. Crafts a `NextRoundInput` with their own (or any miner's) `MissedTimeSlots` set to a large negative value (e.g., -10000)
3. Submits the transaction calling `NextRound` with this crafted input
4. The malicious round is stored in state at line 156 of ProcessNextRound [9](#0-8) 

**Feasibility Conditions:**

All preconditions are easily met:
- Being a miner (normal consensus participant role)
- Ability to submit transactions (standard blockchain operation)
- No economic barriers (normal transaction fees apply)

**Detection Constraints:**

The attack is difficult to detect because:
- The malicious transaction appears valid to all validators
- Negative MissedTimeSlots may not be visible in typical monitoring
- The effect manifests gradually as the miner continues missing slots without punishment

**Probability:**

High probability if a malicious actor becomes a miner, as the attack is straightforward with no technical barriers.

### Recommendation

**Code-Level Mitigation:**

Add validation in `NextRound` processing to ensure all `MissedTimeSlots` values are non-negative:

```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    
    // Add validation
    foreach (var miner in nextRound.RealTimeMinersInformation.Values)
    {
        Assert(miner.MissedTimeSlots >= 0, 
            $"Invalid MissedTimeSlots value: {miner.MissedTimeSlots}");
        Assert(miner.ProducedBlocks >= 0, 
            $"Invalid ProducedBlocks value: {miner.ProducedBlocks}");
    }
    
    // Continue with existing logic...
}
```

**Invariant Checks:**

Add a new validation provider `MinerStatisticsValidationProvider` that validates:
- `MissedTimeSlots >= 0` for all miners
- `ProducedBlocks >= 0` for all miners
- Reasonable bounds on these values based on round/term duration

**Test Cases:**

1. Test NextRound rejection with negative MissedTimeSlots
2. Test NextRound rejection with negative ProducedBlocks
3. Test evil miner detection with edge cases (0, TolerableMissedTimeSlotsCount-1, TolerableMissedTimeSlotsCount)
4. Integration test simulating the full attack scenario

### Proof of Concept

**Required Initial State:**
- Blockchain initialized with AEDPoS consensus
- Attacker is elected as a miner in the current validator set
- Current round number N with attacker having MissedTimeSlots = 3

**Attack Steps:**

1. **Attacker monitors consensus and waits to be the extra block producer** (entitled to call NextRound)

2. **Attacker crafts malicious NextRoundInput:**
   ```
   NextRoundInput {
     RoundNumber: N + 1,
     RealTimeMinersInformation: {
       "attacker_pubkey": MinerInRound {
         Pubkey: "attacker_pubkey",
         Order: 1,
         MissedTimeSlots: -10000,  // Malicious negative value
         ProducedBlocks: 0,
         ...
       },
       // Other miners with legitimate values
     },
     ...
   }
   ```

3. **Attacker submits transaction:**
   `AEDPoSContract.NextRound(malicious_input)`

4. **Transaction executes successfully:**
   - PreCheck passes (attacker is in miner list)
   - Validators check round number (+1), InValues (null), mining orders (correct)
   - NO validator checks MissedTimeSlots sign
   - Malicious round stored at Round N+1

5. **In subsequent rounds (N+2, N+3, ...):**
   - When attacker misses slots, GenerateNextRoundInformation increments: -10000 → -9999 → -9998...
   - Evil miner detection checks: `-9998 >= TolerableMissedTimeSlotsCount` = FALSE
   - Attacker never gets banned despite missing thousands of time slots

**Expected vs Actual Result:**

Expected: Attacker detected as evil node after missing TolerableMissedTimeSlotsCount slots

Actual: Attacker escapes detection indefinitely with negative counter

**Success Condition:**

Query `GetRoundInformation(N+1)` shows attacker's `MissedTimeSlots = -10000`, and subsequent calls to `NextRound` continue accepting blocks from attacker despite them missing their time slots repeatedly.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L52-55)
```csharp
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```
