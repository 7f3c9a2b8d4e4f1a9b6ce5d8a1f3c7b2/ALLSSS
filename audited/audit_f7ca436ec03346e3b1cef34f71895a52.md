### Title
Miner Can Manipulate Next Round Order by Setting Invalid SupposedOrderOfNextRound Without Validation

### Summary
The `ProcessUpdateValue` method directly trusts the miner-provided `SupposedOrderOfNextRound` value without validating it against the deterministic calculation from the miner's signature. Combined with a broken validation in `NextRoundMiningOrderValidationProvider` that checks the wrong round data, a malicious miner can produce blocks (set `OutValue != null`) while setting `SupposedOrderOfNextRound = 0`, causing them to be treated as "not mined" and assigned an arbitrary order in the next round instead of their deterministic `FinalOrderOfNextRound`.

### Finding Description

**Root Cause 1: Missing Validation in ProcessUpdateValue** [1](#0-0) 

The `ProcessUpdateValue` method directly sets `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` from the miner-provided `UpdateValueInput` without validating that `SupposedOrderOfNextRound` matches the deterministic calculation: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [2](#0-1) 

While `ApplyNormalConsensusData` correctly calculates `SupposedOrderOfNextRound` from the signature during block production setup, this calculation is not re-validated when processing the submitted `UpdateValueInput`.

**Root Cause 2: Broken NextRoundMiningOrderValidationProvider** [3](#0-2) 

The validator checks `providedRound` (the proposed NEXT round), but the next round generated by `GenerateNextRoundInformation` creates fresh `MinerInRound` objects without `OutValue` or `FinalOrderOfNextRound` fields populated: [4](#0-3) 

This causes both counts to be 0, making the validation always pass regardless of actual miner behavior in the current round.

**Exploitation Path** [5](#0-4) 

When generating the next round, `GetMinedMiners()` filters by `SupposedOrderOfNextRound != 0` to determine which miners produced blocks. A miner who sets `SupposedOrderOfNextRound = 0` despite having `OutValue != null` will be incorrectly classified as "not mined" and assigned to an available order slot rather than their deterministic position. [6](#0-5) 

The validation only runs `NextRoundMiningOrderValidationProvider` for `NextRound` behavior, but the broken validator passes unconditionally.

### Impact Explanation

**Consensus Integrity Compromise:**
- Miners can manipulate their position in the next round's mining order, breaking the deterministic ordering based on cryptographic signatures
- An attacker can avoid their calculated `FinalOrderOfNextRound` and instead be assigned to any available slot (lines 42-56 in Round_Generation.cs)
- This allows miners to choose favorable time slots for block production or coordinate with other malicious miners to cluster their blocks
- The `MissedTimeSlots` counter is incorrectly incremented for miners who actually produced blocks, affecting reward calculations and evil miner detection

**Protocol-Wide Effects:**
- Breaks the randomness guarantee of mining order determined by unpredictable signatures
- Enables miners to manipulate LIB (Last Irreversible Block) calculation by controlling block production timing
- Compromises consensus fairness as miners can select advantageous positions

**Affected Parties:**
- All honest miners who follow the deterministic order
- Cross-chain verification relying on predictable consensus behavior
- Reward distribution mechanisms dependent on accurate `MissedTimeSlots` tracking

### Likelihood Explanation

**Reachable Entry Point:**
The attack is trivially reachable through the standard `UpdateValue` public method that all miners call during normal block production.

**Attacker Capabilities:**
Any miner in the active miner set can execute this attack by:
1. Modifying their consensus client to set `SupposedOrderOfNextRound = 0` in their `UpdateValueInput`
2. Keeping all other fields valid (correct `OutValue`, `Signature`, `PreviousInValue`)

**Execution Complexity:**
Very low - the attack requires only a single-field modification in the UpdateValueInput structure. No complex timing, no need for collusion, no economic cost beyond standard block production.

**Detection:**
The attack is difficult to detect because:
- The `UpdateValue` transaction still passes all validations
- The miner's block is accepted and added to the chain
- Only the next round generation logic treats them differently
- No events or errors are emitted

**Probability:**
High - the vulnerability is deterministic, requires minimal sophistication, and provides clear benefit (order manipulation) with no downside risk to the attacker.

### Recommendation

**Fix 1: Validate SupposedOrderOfNextRound in ProcessUpdateValue**

In `AEDPoSContract_ProcessConsensusInformation.cs`, add validation after line 247:

```csharp
minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;

// ADD VALIDATION:
var expectedOrder = Round.GetAbsModulus(
    updateValueInput.Signature.ToInt64(), 
    currentRound.RealTimeMinersInformation.Count
) + 1;
Assert(
    updateValueInput.SupposedOrderOfNextRound == expectedOrder,
    $"Invalid SupposedOrderOfNextRound. Expected {expectedOrder}, got {updateValueInput.SupposedOrderOfNextRound}"
);
```

**Fix 2: Correct NextRoundMiningOrderValidationProvider**

The validator should check `baseRound` (current round) instead of `providedRound` (next round):

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var currentRound = validationContext.BaseRound; // CHANGED from ProvidedRound
    var distinctCount = currentRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).Distinct().Count();
    if (distinctCount != currentRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }
    validationResult.Success = true;
    return validationResult;
}
```

**Fix 3: Add Integration Test**

Add test case verifying that miners cannot manipulate `SupposedOrderOfNextRound`:
- Miner produces valid block with correct `OutValue` and `Signature`
- Miner attempts to set `SupposedOrderOfNextRound = 0` (or any incorrect value)
- Assert that `UpdateValue` transaction fails with "Invalid SupposedOrderOfNextRound" error

### Proof of Concept

**Initial State:**
- Current round N with 7 active miners
- Attacker is Miner A with Order 3 in current round
- Attacker's signature would deterministically calculate to `SupposedOrderOfNextRound = 5`

**Attack Sequence:**

**Step 1:** Attacker produces block at their time slot
- Calculates correct `OutValue = Hash(InValue)`
- Calculates correct `Signature` from previous round signatures
- Gets consensus command via `GetConsensusExtraData` which sets `SupposedOrderOfNextRound = 5`

**Step 2:** Attacker modifies `UpdateValueInput` before submission
- Keeps `OutValue` and `Signature` unchanged (valid)
- Manually sets `SupposedOrderOfNextRound = 0` in the UpdateValueInput
- Submits `UpdateValue` transaction

**Step 3:** UpdateValue processes without validation
- `ProcessUpdateValue` sets `minerInRound.SupposedOrderOfNextRound = 0` (line 246)
- `minerInRound.FinalOrderOfNextRound = 0` (line 247)
- Transaction succeeds, no validation error

**Step 4:** Next round generation treats attacker as "not mined"
- `GetMinedMiners()` filters `SupposedOrderOfNextRound != 0`, excludes Attacker
- `GetNotMinedMiners()` includes Attacker despite `OutValue != null`
- Attacker is assigned to an available order slot (e.g., Order 2) instead of deterministic Order 5
- Attacker's `MissedTimeSlots` is incremented incorrectly

**Expected Result:** UpdateValue should fail with "Invalid SupposedOrderOfNextRound" error

**Actual Result:** UpdateValue succeeds, attacker manipulates next round position

**Success Condition:** Attacker successfully produces a block in round N but gets assigned Order 2 instead of deterministic Order 5 in round N+1, breaking consensus ordering integrity.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-135)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }

    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
