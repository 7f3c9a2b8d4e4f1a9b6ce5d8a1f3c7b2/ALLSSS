### Title
Missing Cryptographic Verification of DecryptedPieces in Secret Sharing Mechanism

### Summary
The `RevealSharedInValues` function reconstructs miners' InValues from DecryptedPieces without verifying that these pieces were correctly decrypted from the original EncryptedPieces. Malicious miners can submit arbitrary bytes as DecryptedPieces, causing Shamir's Secret Sharing reconstruction to produce corrupted InValues that are permanently stored on-chain and used in consensus signature calculations, compromising consensus integrity.

### Finding Description

**Root Cause:**

The AEDPoS consensus contract accepts DecryptedPieces from miners without any cryptographic proof of correct decryption. The vulnerability spans two critical functions:

1. **PerformSecretSharing** accepts unverified DecryptedPieces: [1](#0-0) 

When miners submit `UpdateValueInput`, their `DecryptedPieces` are directly added to other miners' `DecryptedPieces` collections without any verification that they are the correct decryption of the corresponding `EncryptedPieces`.

2. **RevealSharedInValues** uses unverified pieces to reconstruct InValues: [2](#0-1) 

The function reads all DecryptedPieces and passes them to `SecretSharingHelper.DecodeSecret()` for Shamir's Secret Sharing reconstruction. The reconstructed InValue is stored as `PreviousInValue` without any validation.

**Why Protections Fail:**

The contract has validation for self-reported PreviousInValue: [3](#0-2) 

However, this validation only applies when miners self-report their InValue. For InValues revealed through secret sharing, there is **no validation** that `Hash(revealedInValue) == previousOutValue`.

**Execution Path:**

1. Round N: Honest Miner A produces block with secret `InValue_A`, publishes `OutValue_A = Hash(InValue_A)` and `EncryptedPieces[B, C, D...]` [4](#0-3) 

2. Round N+1: Malicious Miner B submits `UpdateValueInput` with `DecryptedPieces[A] = arbitrary_garbage`

3. `PerformSecretSharing` stores the corrupt data without verification

4. Round N+1→N+2 transition: `RevealSharedInValues` is called during NextRound: [5](#0-4) 

5. Shamir's Secret Sharing reconstruction produces `CorruptedInValue_A` from the garbage bytes (Shamir's algorithm has no internal validation and will compute a result even from invalid inputs)

6. The corrupted value is stored as Miner A's `PreviousInValue` and subsequently used in consensus operations

### Impact Explanation

**Consensus State Corruption:**
The corrupted InValues become permanent on-chain state. When miners who didn't produce blocks need their InValue filled, the system uses the revealed (corrupted) PreviousInValue: [6](#0-5) 

**Signature Chain Corruption:**
Consensus signatures are calculated using InValues via XOR operations: [7](#0-6) 

Corrupted InValues lead to incorrect signatures, breaking the cryptographic chain that ensures consensus integrity.

**Byzantine Fault Tolerance Breach:**
The secret sharing mechanism is designed to provide 2/3 Byzantine fault tolerance. However, this vulnerability allows a **single malicious miner** to corrupt InValue revelation, completely breaking the security model. The requirement for all miners to submit DecryptedPieces makes the attack even more impactful: [8](#0-7) 

**Affected Parties:**
- All network participants relying on consensus integrity
- Miners whose InValues are corrupted
- Applications depending on consensus randomness quality

### Likelihood Explanation

**Attacker Capabilities:**
Any miner in the consensus pool can execute this attack. The attacker simply needs to:
- Be part of the active miner set (which is the intended use case)
- Submit an UpdateValue transaction with corrupt DecryptedPieces

**Attack Complexity: LOW**
The attack requires no sophisticated techniques:
1. Miner submits `UpdateValueInput` with `DecryptedPieces[VictimPubkey] = randomBytes`
2. No additional transactions or setup needed
3. No timing constraints or race conditions

**Feasibility: HIGH**
- Entry point is the public `UpdateValue` method accessible to all miners: [9](#0-8) 
- No special permissions required beyond being a miner
- Attack succeeds deterministically (Shamir's reconstruction always produces output)

**Detection: IMPOSSIBLE**
The contract has no validation to detect corrupt DecryptedPieces. All nodes will accept the corrupted data identically, making the attack undetectable at the protocol level.

**Economic Rationality:**
- Attack cost: negligible (normal transaction fee)
- Impact: high (consensus integrity compromise)
- Risk of detection: zero (no validation exists)

### Recommendation

**Immediate Fix:**
Add cryptographic verification of DecryptedPieces. Since on-chain verification of ECIES decryption is not feasible without access to private keys, implement one of these solutions:

**Solution 1 - Zero-Knowledge Proof:**
Require miners to submit a zero-knowledge proof that their DecryptedPiece is the correct decryption of the corresponding EncryptedPiece.

**Solution 2 - Post-Validation with OutValue:**
After reconstructing InValues via secret sharing, validate that `Hash(reconstructedInValue) == previousOutValue`. Reject and don't store InValues that fail this check:

```csharp
var revealedInValue = HashHelper.ComputeFrom(
    SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL: Validate revealed value against published OutValue
if (HashHelper.ComputeFrom(revealedInValue) != 
    previousRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].OutValue)
{
    Context.LogDebug(() => $"Revealed in value validation failed for {publicKeyOfAnotherMiner}");
    continue; // Skip this corrupted revelation
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Solution 3 - Commit-Reveal with Verification:**
Modify the protocol to have miners commit to their DecryptedPieces hash before revealing, then verify the commitment matches.

**Invariant to Enforce:**
For all revealed InValues: `Hash(PreviousInValue) == PreviousRound[miner].OutValue`

**Test Cases:**
1. Test that corrupt DecryptedPieces cause validation failure
2. Test that honest DecryptedPieces pass validation
3. Test mixed honest/malicious scenarios with various thresholds
4. Test that revelation fails gracefully when validation fails

### Proof of Concept

**Required Initial State:**
- Secret sharing enabled (configuration setting)
- Minimum 3 miners in consensus pool (for 2/3 threshold)
- Honest Miner A has produced a block in Round N

**Attack Sequence:**

1. **Round N - Setup:**
   - Miner A mines block with `InValue_A = 0x1234...`
   - Publishes `OutValue_A = Hash(InValue_A) = 0xabcd...`
   - Stores `EncryptedPieces[MaliciousMiner] = Encrypt(pubkey_malicious, share_A)`

2. **Round N+1 - Attack:**
   - Malicious miner submits `UpdateValue` with:
     ```
     DecryptedPieces["MinerA_Pubkey"] = 0x0000000000000000  // Arbitrary garbage
     ```
   - Contract accepts without verification (line 291-293 of ProcessConsensusInformation.cs)

3. **Round N+1→N+2 - Corruption:**
   - `NextRound` transaction triggers `RevealSharedInValues`
   - Function reconstructs: `revealedInValue = DecodeSecret([0x00000000, honest_piece2, honest_piece3])`
   - Result: `revealedInValue = 0xFFFF...` (incorrect value)
   - Stores: `MinerA.PreviousInValue = 0xFFFF...` (should be `0x1234...`)

4. **Expected vs Actual Result:**
   - **Expected:** `MinerA.PreviousInValue = 0x1234...` and `Hash(0x1234...) == 0xabcd...` ✓
   - **Actual:** `MinerA.PreviousInValue = 0xFFFF...` and `Hash(0xFFFF...) != 0xabcd...` ✗

**Success Condition:**
The attack succeeds if the corrupted InValue is stored on-chain without any validation failure. This can be verified by querying the round information and observing that `Hash(PreviousInValue) != OutValue` from the previous round, yet no error was raised.

**Notes:**
This vulnerability fundamentally breaks the cryptographic security guarantees of the secret sharing mechanism. The lack of verification means the protocol cannot distinguish between honest and malicious DecryptedPieces, allowing single miners to corrupt consensus state at will.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-257)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L35-36)
```csharp
            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** protobuf/aedpos_contract.proto (L294-296)
```text
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L189-199)
```csharp
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
