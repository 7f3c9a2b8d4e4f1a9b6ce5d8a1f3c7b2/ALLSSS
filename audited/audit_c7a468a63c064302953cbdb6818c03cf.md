### Title
Missing Cryptographic Signature Verification in AEDPoS Consensus Allows Mining Order Manipulation

### Summary
The AEDPoS consensus system fails to verify that miner-provided signatures match the expected cryptographic value calculated from PreviousInValue and previous round data. Miners can submit arbitrary signature values during UpdateValue transactions, allowing them to manipulate their mining order in the next round, undermining the fairness of the consensus mechanism.

### Finding Description

The vulnerability exists in the consensus validation flow where signature verification is completely absent.

**Signature Calculation (Expected):**
During block production, signatures are calculated as: [1](#0-0) 

This uses the CalculateSignature method which XORs PreviousInValue with all previous round signatures: [2](#0-1) 

**Signature Usage (Impact):**
The signature directly determines mining order in the next round: [3](#0-2) 

**Missing Verification:**
The UpdateValueValidationProvider only checks that signatures are non-empty, but never verifies correctness: [4](#0-3) 

The validation only verifies that PreviousInValue hashes to PreviousOutValue: [5](#0-4) 

No code exists anywhere that performs: `Assert(providedSignature == previousRound.CalculateSignature(providedPreviousInValue))`

**Regarding GetUpdateValueRound():**
The simplified round does include PreviousInValue: [6](#0-5) 

And for other miners: [7](#0-6) 

So technically all data needed for verification IS present. The issue is not missing data in GetUpdateValueRound(), but missing verification logic in the validation providers.

### Impact Explanation

**Consensus Integrity Compromise:**
- Miners can arbitrarily choose their mining order in the next round by manipulating signature values
- This breaks the verifiable randomness property of AEDPoS consensus
- Attackers can position themselves favorably (e.g., becoming the extra block producer who controls term/round transitions)

**Unfair Advantage:**
- Miners producing extra blocks earn additional rewards and control critical consensus transitions
- Manipulated ordering allows coordinated attacks by multiple colluding miners
- The supposed order (`signature.ToInt64() % minersCount + 1`) becomes attacker-controlled rather than cryptographically random

**Protocol Trust Degradation:**
- The entire InValue/OutValue commit-reveal scheme and signature mechanism becomes meaningless if signatures are not verified
- Other miners cannot trust the fairness of block production scheduling

### Likelihood Explanation

**Highly Practical Attack:**
- Any active miner can exploit this during their designated time slot
- No special privileges required beyond being an authorized miner
- Attack complexity is trivial: simply provide an arbitrary signature value instead of calculating the correct one

**Entry Point:**
The UpdateValue transaction is called by every miner during normal block production: [8](#0-7) 

**No Detection:**
- The system accepts any non-empty signature value
- No monitoring exists to detect manipulated signatures
- The attack is indistinguishable from normal operation since signatures are never validated

**Cost Analysis:**
- Zero additional cost beyond normal mining operations
- No risk of detection or penalty since validation never checks correctness

### Recommendation

**Add Signature Verification:**
In UpdateValueValidationProvider.ValidateHeaderInformation(), add cryptographic signature verification:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var providedSignature = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey].Signature;
    var previousInValue = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // First round or no previous participation
    
    var expectedSignature = validationContext.PreviousRound
        .CalculateSignature(previousInValue);
    
    return providedSignature == expectedSignature;
}
```

Call this in ValidateHeaderInformation() at: [9](#0-8) 

**Add Test Cases:**
- Test that modified signatures are rejected
- Test that correct signatures calculated via CalculateSignature() are accepted
- Test signature verification with various previous round configurations

### Proof of Concept

**Initial State:**
- Miner M is authorized in the current round
- Previous round exists with M having OutValue = Hash(PreviousInValue)
- M wants to become first miner in next round

**Attack Steps:**
1. M calculates PreviousInValue that matches their previous OutValue
2. M calculates current OutValue = Hash(current_secret_InValue)
3. **Instead of** calculating: `signature = previousRound.CalculateSignature(PreviousInValue)`
4. **M provides:** `signature = Hash(desired_order_value)` where `desired_order_value.ToInt64() % minersCount == 0` (to get order 1)
5. M submits UpdateValue transaction with (OutValue, manipulated_signature, PreviousInValue)

**Expected Result:**
Validation should reject the transaction due to signature mismatch

**Actual Result:**
Transaction succeeds because UpdateValueValidationProvider only checks:
- Signature is non-empty ✓
- Hash(PreviousInValue) == PreviousOutValue ✓
- Never checks: provided_signature == expected_signature ✗

**Success Condition:**
M's order in next round is 1 (first position), determined by their manipulated signature rather than the cryptographically correct value, granting unfair mining advantages and potential control over consensus transitions.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L16-19)
```csharp
        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L31-32)
```csharp
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L24-27)
```csharp
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L51-51)
```csharp
                    PreviousInValue = information.Value.PreviousInValue
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-244)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```
