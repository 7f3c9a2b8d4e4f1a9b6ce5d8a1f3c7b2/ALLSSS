# Audit Report

## Title
Secret Sharing Mechanism Completely Broken in NextRound Transitions - Revealed InValues Lost

## Summary
The `RevealSharedInValues()` function computes revealed InValues for miners who missed blocks using secret sharing reconstruction during NextRound transitions. However, these critical values are written to `currentRound` which is immediately discarded, while `nextRound` (which lacks these values) is persisted to state. This completely breaks the secret sharing mechanism's purpose of maintaining consensus integrity when miners fail to produce blocks.

## Finding Description

During NextRound transitions in `GetConsensusExtraDataForNextRound()`, there is a critical data loss bug: [1](#0-0) 

The function generates `nextRound` from `currentRound` at line 176, then calls `RevealSharedInValues(currentRound, pubkey)` at line 189. The problem is that `RevealSharedInValues` modifies `currentRound` by writing revealed InValues: [2](#0-1) 

Line 52 writes the reconstructed InValue to `currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue`. However, the function returns `nextRound`, not `currentRound`, so these modifications are never persisted.

When `ProcessNextRound` is called, only `nextRound` is persisted: [3](#0-2) 

At line 156, `AddRoundInformation(nextRound)` persists only the `nextRound` object to state, discarding all revealed InValues computed by secret sharing.

The root cause is that `GenerateNextRoundInformation` does not copy `PreviousInValue` fields: [4](#0-3) 

Only `Pubkey`, `Order`, `ExpectedMiningTime`, `ProducedBlocks`, and `MissedTimeSlots` are copied from currentRound to nextRound. The `PreviousInValue` field is omitted, causing complete loss of secret sharing reconstruction results.

This breaks the security guarantee documented in the code. When a miner who missed previous blocks tries to produce blocks, the system attempts to retrieve their reconstructed InValue: [5](#0-4) 

Line 191 reads `currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue` - the comment at lines 188-190 explicitly states this field contains "previous in value recovered by other miners". When this value is null due to the NextRound bug, signature calculation fails at line 196-199.

In contrast, the UpdateValue flow works correctly because revealed InValues are passed via trigger information and written to the persisted round: [6](#0-5) 

Lines 148-152 write `triggerInformation.RevealedInValues` to `updatedRound`, which is then persisted. However, NextRound triggers do not include this data: [7](#0-6) 

## Impact Explanation

**Consensus Integrity Breakdown**: The secret sharing mechanism is designed to allow consensus to continue even when miners miss their time slots. By sharing encrypted pieces of their InValues, other miners can reconstruct these values and maintain the consensus chain.

Without properly persisted PreviousInValues:
1. Miners who missed blocks in round N have no reconstructed InValue in round N+1
2. When they attempt to produce blocks, signature calculation fails (see line 196-199 of AEDPoSContract.cs)
3. The consensus randomness chain is broken, undermining unpredictability and fairness
4. The entire secret sharing security mechanism is rendered useless for NextRound transitions

**Affected Parties**: All miners who fail to produce blocks in any round will be unable to properly participate in subsequent consensus operations during NextRound transitions.

**Severity**: HIGH - Complete failure of a critical consensus security mechanism affecting all miners during normal round transitions.

## Likelihood Explanation

**Occurrence**: This bug triggers automatically during every NextRound transition when secret sharing is enabled. It is not an exploit requiring attacker action, but a design flaw in the normal protocol operation.

**Preconditions**:
- Secret sharing enabled (via `IsSecretSharingEnabled()`)
- NextRound transition occurs (happens regularly in normal operation)
- At least one miner failed to produce blocks in the previous round

**Frequency**: CERTAIN - This happens automatically whenever round transitions occur with secret sharing enabled, which is the normal mode of operation for AEDPoS consensus.

The issue is masked in UpdateValue flows (which use a different code path with `triggerInformation.RevealedInValues`), but NextRound transitions have no such mechanism, causing guaranteed data loss.

## Recommendation

Fix the data loss by ensuring revealed InValues are either:

**Option 1**: Copy PreviousInValue in `GenerateNextRoundInformation`:
```csharp
// In Round_Generation.cs, add PreviousInValue to copied fields:
nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
{
    Pubkey = minerInRound.Pubkey,
    Order = order,
    ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
    ProducedBlocks = minerInRound.ProducedBlocks,
    MissedTimeSlots = minerInRound.MissedTimeSlots,
    PreviousInValue = minerInRound.PreviousInValue  // ADD THIS LINE
};
```

**Option 2**: Modify RevealSharedInValues to write to nextRound instead, or call it before generating nextRound and ensure the values are copied.

## Proof of Concept

```csharp
// Test demonstrating the bug:
// 1. Setup: 3 miners with secret sharing enabled, round N completes with miner3 missing blocks
// 2. Action: Miner1 produces NextRound block (calls GetConsensusExtraDataForNextRound)
//    - RevealSharedInValues computes miner3's InValue using secret sharing
//    - Writes to currentRound.RealTimeMinersInformation[miner3].PreviousInValue
//    - Returns nextRound (without this value)
// 3. Result: nextRound is persisted via ProcessNextRound -> AddRoundInformation
// 4. Verify: Query round N+1 state, confirm miner3's PreviousInValue is null/empty
// 5. Impact: When miner3 tries to produce in round N+1, signature calculation fails

[Fact]
public async Task SecretSharing_NextRound_LoseRevealedInValues()
{
    // Setup miners with secret sharing enabled
    var miners = new[] { "miner1", "miner2", "miner3" };
    
    // Round N: miner3 misses block, others share encrypted pieces
    // ... (setup secret sharing data)
    
    // Trigger NextRound as miner1
    var nextRoundResult = await GetConsensusExtraDataForNextRound(miner1Pubkey);
    
    // Process NextRound - this persists nextRound
    await ProcessNextRound(nextRoundResult);
    
    // Verify: miner3's PreviousInValue should be revealed but is actually lost
    var roundAfterTransition = await GetCurrentRoundInformation();
    var miner3Info = roundAfterTransition.RealTimeMinersInformation[miner3Pubkey];
    
    // BUG: This assertion fails - PreviousInValue is null despite secret sharing reconstruction
    Assert.NotNull(miner3Info.PreviousInValue);
    Assert.NotEqual(Hash.Empty, miner3Info.PreviousInValue);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-56)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-200)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L119-125)
```csharp
        return new AElfConsensusTriggerInformation
        {
            Pubkey = Pubkey,
            Behaviour = hint.Behaviour,
            RandomNumber = ByteString.CopyFrom(randomProof)
        }.ToBytesValue();
    }
```
