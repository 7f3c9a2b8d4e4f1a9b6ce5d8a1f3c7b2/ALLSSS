### Title
Consensus DoS via Invalid Miner Order Values in Round Validation

### Summary
A malicious miner can submit a crafted `NextRoundInput` with invalid miner `Order` values that passes validation but causes `GetMiningInterval()` to crash with `IndexOutOfRangeException`. This results in complete blockchain halt as all nodes become unable to generate consensus commands or transition to the next round.

### Finding Description

The vulnerability stems from a critical mismatch between round validation logic and runtime mining interval calculation:

**Validation Logic** in `CheckRoundTimeSlots()`: [1](#0-0) 

The validation orders miners by their `Order` field and validates intervals between consecutive miners in the sorted list. If all miners have `Order = 0`, this validation still passes as long as `ExpectedMiningTime` values have proper intervals. [2](#0-1) 

**Runtime Logic** in `GetMiningInterval()`: [3](#0-2) 

This specifically filters for miners with `Order == 1 || Order == 2` and accesses `firstTwoMiners[1]`. If no miners have these order values, the list is empty and accessing index [1] throws `IndexOutOfRangeException`.

**Attack Execution Path**:

1. Miner calls `NextRound()` with crafted input: [4](#0-3) 

2. Input is converted to Round via `ToRound()` which copies `RealTimeMinersInformation` directly: [5](#0-4) 

3. Validation runs through `ValidateBeforeExecution()`: [6](#0-5) 

4. For NextRound behavior, `TimeSlotValidationProvider` calls `CheckRoundTimeSlots()` on new rounds: [7](#0-6) 

5. Malicious round passes validation and is stored: [8](#0-7) 

6. Later, `GetMiningInterval()` is called from `MiningInterval` property: [9](#0-8) 

7. This property is used to calculate mining limits: [10](#0-9) 

8. The crash occurs during consensus command generation (view call) or next round generation (transaction), causing complete chain halt.

### Impact Explanation

**Operational Impact - Complete Blockchain Halt**:

The malicious round becomes the current consensus state. When any node attempts to:
- Generate consensus commands via `GetConsensusCommand()` (view method marked at ACS4 definition): [11](#0-10) 

The command strategies access `MiningInterval`: [12](#0-11) [13](#0-12) 

- Generate next round via `GenerateNextRoundInformation()`: [14](#0-13) 

Both operations crash with `IndexOutOfRangeException`, preventing:
- All nodes from mining new blocks
- Any round progression
- Chain recovery without hard fork

**Affected Parties**: All network participants - validators cannot mine, users cannot transact, chain is permanently halted.

### Likelihood Explanation

**Reachable Entry Point**: `NextRound()` is a public method callable by any valid miner: [4](#0-3) 

**Attacker Capabilities**: Only requires being a current miner (permission check): [15](#0-14) 

**Attack Complexity**: LOW
- Craft `NextRoundInput` with all miners having `Order = 0`
- Set proper `ExpectedMiningTime` intervals (e.g., T, T+4000ms, T+8000ms)
- Submit via `NextRound()` transaction
- No special timing or complex coordination required

**Detection Difficulty**: The malicious transaction appears valid and is accepted by all nodes simultaneously, making detection before execution impossible.

**Economic Cost**: Minimal - just one transaction fee. Attacker could even be the next scheduled miner earning block rewards before executing the attack.

**Probability**: HIGH - Any miner with grievance or malicious intent can execute this attack at any time.

### Recommendation

**Immediate Fix** - Add explicit Order validation in `CheckRoundTimeSlots()`:

```csharp
public ValidationResult CheckRoundTimeSlots()
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };
    
    // ADD: Validate Order values are sequential starting from 1
    var expectedOrders = Enumerable.Range(1, miners.Count).ToList();
    var actualOrders = miners.Select(m => m.Order).OrderBy(o => o).ToList();
    if (!expectedOrders.SequenceEqual(actualOrders))
        return new ValidationResult { Message = "Invalid Order values - must be sequential from 1 to miner count." };
    
    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
    
    // Rest of validation...
}
```

**Alternative Fix** - Make `GetMiningInterval()` defensive:

```csharp
public int GetMiningInterval()
{
    if (RealTimeMinersInformation.Count == 1)
        return 4000;
    
    var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2).ToList();
    
    // ADD: Defensive check
    if (firstTwoMiners.Count < 2)
        // Fallback: use first two miners after ordering
        firstTwoMiners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).Take(2).ToList();
    
    return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime).Milliseconds());
}
```

**Test Cases**:
1. Test `NextRound()` with all `Order = 0` - should fail validation
2. Test `NextRound()` with missing Order 1 or 2 - should fail validation  
3. Test `NextRound()` with non-sequential Orders - should fail validation
4. Test `GetMiningInterval()` with valid Orders - should succeed
5. Add integration test simulating attack scenario end-to-end

### Proof of Concept

**Initial State**:
- Blockchain running with valid Round N (5 miners with Orders 1-5)
- Attacker is scheduled miner in Round N

**Attack Steps**:

1. Attacker generates malicious `NextRoundInput` for Round N+1:
   ```
   RoundNumber: N+1
   TermNumber: 1
   RealTimeMinersInformation: {
     "miner1": { Order: 0, ExpectedMiningTime: T },
     "miner2": { Order: 0, ExpectedMiningTime: T + 4000ms },
     "miner3": { Order: 0, ExpectedMiningTime: T + 8000ms },
     "miner4": { Order: 0, ExpectedMiningTime: T + 12000ms },
     "miner5": { Order: 0, ExpectedMiningTime: T + 16000ms }
   }
   ```

2. Attacker calls `NextRound(maliciousInput)` as consensus transaction

3. `ValidateBeforeExecution()` runs:
   - `CheckRoundTimeSlots()` orders miners by Order (all 0), gets stable list [miner1...miner5]
   - Calculates interval: T+4000ms - T = 4000ms > 0 ✓
   - All interval checks pass ✓
   - Validation succeeds ✓

4. `ProcessNextRound()` accepts and stores malicious Round N+1

5. **Expected Result**: Round N+1 rejected due to invalid Orders

6. **Actual Result**: Round N+1 accepted, becomes current round

7. Next miner attempts to mine:
   - Calls `GetConsensusCommand()`
   - Strategy accesses `MiningInterval` property
   - `GetMiningInterval()` filters for Order 1 or 2: empty list
   - Accesses `firstTwoMiners[1]`: **IndexOutOfRangeException**
   - All nodes crash on consensus command generation
   - **Blockchain halted permanently**

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L35-35)
```csharp
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L42-60)
```csharp
        private int TinyBlockSlotInterval => MiningInterval.Div(TinyBlocksCount);

        protected int MinersCount => CurrentRound.RealTimeMinersInformation.Count;

        /// <summary>
        ///     Give 3/5 of producing time for mining by default.
        /// </summary>
        protected int DefaultBlockMiningLimit => TinyBlockSlotInterval.Mul(3).Div(5);

        /// <summary>
        ///     If this tiny block is the last one of current time slot, give half of producing time for mining.
        /// </summary>
        protected int LastTinyBlockMiningLimit => TinyBlockSlotInterval.Div(2);

        /// <summary>
        ///     If this block is of consensus behaviour NEXT_TERM, the producing time is MiningInterval,
        ///     so the limitation of mining is 8 times than DefaultBlockMiningLimit.
        /// </summary>
        protected int LastBlockOfCurrentTermMiningLimit => MiningInterval.Mul(3).Div(5);
```

**File:** protobuf/acs4.proto (L20-22)
```text
    rpc GetConsensusCommand (google.protobuf.BytesValue) returns (ConsensusCommand) {
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L38-39)
```csharp
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L34-38)
```csharp
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
                    ? MinerInRound.ActualMiningTimes.First()
                    : MinerInRound.ExpectedMiningTime;
            var currentTimeSlotEndTime = currentTimeSlotStartTime.AddMilliseconds(MiningInterval);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-21)
```csharp
        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
```
