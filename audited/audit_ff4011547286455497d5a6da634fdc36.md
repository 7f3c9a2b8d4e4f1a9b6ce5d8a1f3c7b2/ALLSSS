### Title
Cross-Chain LIB Confusion via Unvalidated ImpliedIrreversibleBlockHeight in Multi-Chain Environment

### Summary
The `LibInformationValidationProvider.ValidateHeaderInformation()` function validates that Last Irreversible Block (LIB) values do not decrease but fails to verify that these values are contextually valid for the current chain. In a multi-chain AElf environment, a malicious miner can provide `ImpliedIrreversibleBlockHeight` values from a different chain, causing consensus state corruption and potentially premature block finalization.

### Finding Description

The validation logic in `LibInformationValidationProvider` only checks that LIB-related values do not decrease compared to the base round state: [1](#0-0) [2](#0-1) 

**Root Cause:** The validation lacks any check to ensure that the provided LIB height values reference blocks from the current chain. In AElf's multi-chain architecture, each chain (mainchain, sidechains) is a separate blockchain with its own chain ID and state storage: [3](#0-2) 

While blocks are validated for correct chain ID at the blockchain layer, the consensus extra data within the block header contains Round information with LIB values that are not cross-validated against the current chain context.

**Execution Path:**

1. During validation, `baseRound` is fetched from the current chain's state: [4](#0-3) 

2. The `providedRound` comes from the block's consensus extra data and is recovered into baseRound: [5](#0-4) 

3. The recovery process copies `ImpliedIrreversibleBlockHeight` from providedRound: [6](#0-5) 

4. This value is then stored in the consensus state: [7](#0-6) 

5. The stored values are used to calculate the chain's LIB: [8](#0-7) 

**Why Protections Fail:**

In honest execution, miners generate consensus data with `ImpliedIrreversibleBlockHeight` set to the current block height: [9](#0-8) 

However, a malicious miner can manually craft consensus extra data with arbitrary `ImpliedIrreversibleBlockHeight` values. The `LibInformationValidationProvider` only checks that these values don't decrease, not that they equal or are bounded by `Context.CurrentHeight`. This allows cross-chain values to pass validation.

The `IrreversibleBlockFoundLogEventProcessor` provides limited protection by checking if a block exists at the calculated LIB height: [10](#0-9) 

However, this only prevents non-existent blocks from being marked irreversible at the chain level—it does not prevent consensus state corruption or premature finalization of existing blocks.

### Impact Explanation

**Consensus State Corruption:** A malicious miner can inject `ImpliedIrreversibleBlockHeight` values from Chain B when mining on Chain A. These cross-chain values are stored in Chain A's consensus state and used in LIB calculations, corrupting Chain A's view of finality.

**Premature Block Finalization:** If the attacker provides inflated values that correspond to existing blocks on the target chain (e.g., Chain A has 1000 blocks, attacker provides height 950 from Chain B where this corresponds to a much older block), the LIB calculation may prematurely finalize blocks on Chain A before sufficient consensus is actually achieved.

**Cross-Chain Indexing Disruption:** The consensus contract's LIB information is used for cross-chain synchronization: [11](#0-10) 

Corrupted LIB values could cause side chains to make incorrect decisions about main chain finality.

**Validation Logic Bypass:** Once the consensus state contains inflated LIB values, legitimate miners may have their blocks rejected because their honest `ImpliedIrreversibleBlockHeight` values appear "too low" compared to the corrupted stored values.

**Quantified Impact:** With 2/3+1 consensus threshold and collusion among miners, or sustained attack over multiple rounds, the attacker can manipulate the LIB calculation. For a 7-miner configuration, controlling 3 miners or attacking over 3+ rounds could shift the LIB by hundreds of blocks incorrectly.

### Likelihood Explanation

**Attacker Capabilities:** Requires the attacker to be an authorized miner on the target chain. In AElf's DPoS system, miners are elected, but this is a realistic precondition for a high-value attack.

**Attack Complexity:** Low—the attacker simply provides inflated `ImpliedIrreversibleBlockHeight` values when producing blocks. The consensus extra data is signed by the miner's key, which they control.

**Feasibility Conditions:** 
- Multi-chain environment (mainchain + sidechains) is standard in AElf
- Attacker observes Chain B has higher block height than Chain A
- Attacker is authorized miner on Chain A
- No additional economic cost beyond mining privileges

**Execution Practicality:** The attack is straightforward:
1. Mine block N on Chain A
2. Craft consensus extra data with `ImpliedIrreversibleBlockHeight = M` where M is from Chain B and M > previous value on Chain A
3. Sign and broadcast the block
4. Validation passes because M >= previous value (no chain context check)

**Detection Constraints:** The attack may initially go undetected as the values pass validation. Detection would require comparing LIB progression rates across chains or monitoring for unusually rapid LIB increases.

**Probability:** HIGH—Given multi-chain deployment is common, miner compromise or collusion is a realistic threat model, and the attack is technically simple with no additional safeguards beyond the insufficient validation.

### Recommendation

**Primary Fix:** Add chain-specific validation in `LibInformationValidationProvider.ValidateHeaderInformation()`:

```csharp
// After line 13, add upper bound validation
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    var providedImpliedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    
    // Validate against current block height
    if (providedImpliedHeight > validationContext.ExtraData.BlockHeight)
    {
        validationResult.Message = "ImpliedIrreversibleBlockHeight exceeds current block height.";
        return validationResult;
    }
    
    // Existing check for non-decreasing
    if (providedImpliedHeight != 0 &&
        baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > providedImpliedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

**Additional Safeguards:**
1. Add similar bounds checking for `ConfirmedIrreversibleBlockHeight` against a reasonable threshold
2. Implement chain ID tracking in the Round structure for cross-chain scenarios
3. Add monitoring for abnormal LIB progression rates

**Test Cases:**
1. Test that blocks with `ImpliedIrreversibleBlockHeight > Context.CurrentHeight` are rejected
2. Test multi-chain scenario where miner attempts to use Chain B heights on Chain A
3. Test that legitimate miners with proper heights continue to be accepted
4. Test LIB calculation with mixed honest/malicious miner inputs

### Proof of Concept

**Initial State:**
- Chain A: blocks 1-1000, current LIB at height 950
- Chain B: blocks 1-5000, current LIB at height 4950
- Attacker is authorized miner on both chains
- Attacker's previous `ImpliedIrreversibleBlockHeight` on Chain A: 950

**Attack Steps:**
1. Attacker mines block 1001 on Chain A
2. Instead of using `GetConsensusBlockExtraData` (which would set `ImpliedIrreversibleBlockHeight = 1001`), attacker manually crafts consensus extra data
3. Sets `ImpliedIrreversibleBlockHeight = 990` (a value from Chain B's context that is higher than 950 but still within Chain A's existing block range)
4. Signs the block with miner's private key
5. Broadcasts block to Chain A network

**Expected vs Actual Result:**
- **Expected (Secure):** Validation should reject the block because 990 is from Chain B's context and doesn't match the expected value of 1001 for Chain A's block 1001
- **Actual (Vulnerable):** `LibInformationValidationProvider` checks only that 990 > 950 (previous value), validation passes, and the cross-chain value is stored in Chain A's consensus state

**Success Condition:** 
- Block 1001 is accepted on Chain A with `ImpliedIrreversibleBlockHeight = 990` instead of 1001
- Over subsequent rounds with multiple colluding miners, the LIB calculation uses these inflated values
- Chain A's `ConfirmedIrreversibleBlockHeight` advances incorrectly, potentially causing premature finalization or state corruption

**Verification:** Check Chain A's consensus state after the attack—the attacker's `ImpliedIrreversibleBlockHeight` will contain a cross-chain value rather than the expected current block height.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L115-119)
```csharp
        if (_blockchainService.GetChainId() != block.Header.ChainId)
        {
            Logger.LogDebug("Block chain id mismatch {ChainId}", block.Header.ChainId);
            return Task.FromResult(false);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L18-20)
```csharp
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/IrreversibleBlockFoundLogEventProcessor.cs (L63-65)
```csharp
            var libBlockHash = await _blockchainService.GetBlockHashByHeightAsync(chain,
                irreversibleBlockFound.IrreversibleBlockHeight, block.GetHash());
            if (libBlockHash == null) return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L13-23)
```csharp
    public override BytesValue GetChainInitializationInformation(BytesValue input)
    {
        return new BytesValue
        {
            Value = new MinerListWithRoundNumber
            {
                MinerList = GetCurrentMinerList(new Empty()),
                RoundNumber = State.CurrentRoundNumber.Value
            }.ToByteString()
        };
    }
```
