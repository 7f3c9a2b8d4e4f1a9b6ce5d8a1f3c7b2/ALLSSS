# Audit Report

## Title
Signature Malleability via InValue Grinding Allows Miners to Manipulate Next Round Order

## Summary
The AEDPoS consensus mechanism allows miners to manipulate their mining order in subsequent rounds by grinding through arbitrary `InValue` candidates. The on-chain validation only verifies that `Hash(previousInValue) == previousOutValue` without cryptographically verifying that the `InValue` was generated through proper signing procedures, enabling miners to select values that produce favorable mining positions.

## Finding Description

The vulnerability exists in the consensus data flow where miners' next-round order is determined by their signature value. The order calculation uses modulo arithmetic on the signature converted to an integer: [1](#0-0) 

The signature is calculated by XORing the `previousInValue` with all signatures from the previous round: [2](#0-1) 

This signature determines the miner's `supposedOrderOfNextRound`, which directly controls their position in the mining schedule. The critical vulnerability is that the only on-chain validation performed on `previousInValue` is a hash check: [3](#0-2) 

While the client-side implementation properly generates `InValue` by signing data with the miner's private key: [4](#0-3) 

There is **no on-chain enforcement** that miners follow this procedure. A malicious miner can exploit this by:

1. In Round N-1, computing all Round N-1 signatures (which are deterministic based on known on-chain data)
2. Trying multiple `InValue` candidates offline
3. For each candidate, computing the resulting signature and next-round order
4. Selecting the `InValue` that produces the most favorable order
5. Publishing `OutValue = Hash(InValue)` in their Round N-1 block
6. Later revealing the selected `InValue`, which passes validation

The secret sharing mechanism does not prevent this attack because miners can grind their `InValue` before splitting it into encrypted pieces. Even with secret sharing enabled: [5](#0-4) 

The miner has already chosen a favorable `InValue` before distributing the pieces, and the reconstructed value will match what they reveal.

## Impact Explanation

This vulnerability violates the core consensus invariant of **miner schedule integrity**. The mining order determines when each miner produces blocks, which affects:

1. **Block Production Timing**: Miners with earlier orders get priority in transaction ordering within their time slots
2. **Mining Rewards Distribution**: While rewards are based on blocks produced, the ability to consistently position oneself favorably could provide strategic advantages over time
3. **Protocol Fairness**: The consensus mechanism is designed to provide random, unpredictable mining orders to ensure fairness. This vulnerability allows deterministic manipulation

The quantified impact: In an N-miner network, honest miners have a 1/N probability of obtaining any specific order position. A malicious miner can achieve near-certainty of their desired position by grinding through approximately N hash attempts (trivially fast on modern hardware).

The mining order assignment affects the `ExpectedMiningTime` calculation: [6](#0-5) 

This represents a **Medium-to-High severity** issue as it fundamentally breaks the fairness guarantees of the consensus mechanism, though it does not directly lead to fund theft or complete consensus failure.

## Likelihood Explanation

**Attack Feasibility**: The attack is computationally trivial and requires no special privileges beyond being an active miner. The execution steps are:

1. When producing a block in Round N-1, the miner can see all necessary on-chain data
2. All Round N-1 signatures are deterministic and computable
3. Modern CPUs can compute millions of hash operations per second
4. Within a typical 4-second mining interval, sufficient grinding is easily achievable
5. The attack is completely undetectable on-chain since the ground `InValue` satisfies all validation checks

**Detection Difficulty**: The revealed `InValue` appears identical to honestly generated values to the validation logic. Statistical analysis would require long-term monitoring and could not definitively prove manipulation due to probabilistic variance.

**Economic Rationality**: The attack cost (computational electricity) is negligible compared to the potential benefit of favorable mining positions over time. All miners could potentially engage in this behavior, creating an arms race that defeats the purpose of randomized ordering.

## Recommendation

Implement cryptographic verification of `InValue` generation on-chain. The fix should enforce that `InValue` is derived from a valid ECDSA signature over deterministic consensus data:

1. Define a standard message format for `InValue` generation (e.g., hash of round information)
2. Require miners to provide the signature data alongside the `InValue`
3. Add validation in `UpdateValueValidationProvider` to verify:
   - The signature is valid for the miner's public key
   - The signed message follows the prescribed format
   - `InValue = Hash(signature)`

Modified validation logic:
```
// In UpdateValueValidationProvider.ValidatePreviousInValue():
// 1. Verify previousInValue == Hash(signature_bytes)
// 2. Recover public key from signature
// 3. Verify recovered key matches the miner's registered public key
// 4. Verify signed message format is Hash(previousRound data)
return HashHelper.ComputeFrom(previousInValue) == previousOutValue 
    && VerifyInValueSignature(previousInValue, publicKey, previousRound);
```

This ensures miners cannot grind arbitrary values while still allowing honest generation through proper signing.

## Proof of Concept

Due to the complexity of the consensus mechanism requiring multiple rounds of block production and state transitions, a complete PoC would require extensive test infrastructure beyond a single function. However, the attack can be demonstrated conceptually:

```csharp
// Conceptual PoC showing the grinding attack
public Hash FindFavorableInValue(Round previousRound, int desiredOrder, int minersCount)
{
    var previousRoundSignatures = previousRound.CalculateAggregateSignatures();
    
    // Grind through candidates
    for (int nonce = 0; nonce < 1000000; nonce++)
    {
        var candidateInValue = HashHelper.ComputeFrom(nonce);
        var signature = HashHelper.XorAndCompute(candidateInValue, previousRoundSignatures);
        var order = (Math.Abs(signature.ToInt64()) % minersCount) + 1;
        
        if (order == desiredOrder)
        {
            // Found a favorable InValue
            var outValue = HashHelper.ComputeFrom(candidateInValue);
            // Publish outValue now, reveal candidateInValue later
            return candidateInValue;
        }
    }
    
    return Hash.Empty;
}
```

The attack succeeds because:
1. All inputs to the signature calculation are deterministic and known
2. Only `Hash(InValue) == OutValue` is validated on-chain
3. No verification that `InValue` was generated by proper signing

## Notes

This vulnerability represents a fundamental design issue where the on-chain validation trusts that off-chain `InValue` generation follows the prescribed procedure. The optional secret sharing mechanism provides consistency guarantees but does not prevent pre-selection grinding. The severity is assessed as Medium-to-High because while it doesn't directly steal funds, it fundamentally breaks the fairness and unpredictability guarantees of the consensus mechanism, which are critical security properties for a blockchain system.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L186-191)
```csharp
    private async Task<Hash> GenerateInValueAsync(IMessage message)
    {
        var data = HashHelper.ComputeFrom(message.ToByteArray());
        var bytes = await _accountService.SignAsync(data.ToByteArray());
        return HashHelper.ComputeFrom(bytes);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L74-89)
```csharp
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
```
