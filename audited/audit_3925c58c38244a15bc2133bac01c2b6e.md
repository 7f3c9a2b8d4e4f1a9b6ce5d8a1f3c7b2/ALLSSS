### Title
State Corruption in UpdateTokenHolderProfitScheme Enables Unauthorized Scheme Manipulation and Fund Theft

### Summary
The `UpdateTokenHolderProfitScheme` function contains a critical bug where it writes updated scheme data to `Context.Sender`'s storage slot instead of the intended `manager`'s slot. This allows any attacker to hijack a victim's scheme ID by calling public functions like `ContributeProfits`, then use TokenHolderContract's privileged relationship with ProfitContract to add malicious beneficiaries and steal accumulated profits.

### Finding Description

**Root Cause:** [1](#0-0) 

The `UpdateTokenHolderProfitScheme` helper function incorrectly uses `Context.Sender` instead of the `manager` parameter when persisting scheme updates to state storage.

**Correct Pattern Used Elsewhere:** [2](#0-1) [3](#0-2) 

Both `DistributeProfits` and `RegisterForProfits` correctly use `input.SchemeManager` (the manager parameter) when persisting scheme updates, demonstrating the intended pattern.

**Vulnerable Execution Path:**

1. When `ContributeProfits` is called with `input.SchemeManager` pointing to a victim's address: [4](#0-3) 

2. `GetValidScheme` retrieves the victim's scheme and calls `UpdateTokenHolderProfitScheme`: [5](#0-4) 

3. The update logic queries ProfitContract for the scheme ID and updates the scheme object: [6](#0-5) 

4. The bug writes the victim's scheme data (including SchemeId) to the attacker's storage slot instead of the victim's slot.

**Why Existing Protections Fail:**

The ProfitContract's authorization check trusts TokenHolderContract as a privileged caller: [7](#0-6) 

Once the attacker has the victim's SchemeId in their storage, calling `AddBeneficiary` reads from the attacker's storage and successfully modifies the victim's scheme through TokenHolderContract's privileged status: [8](#0-7) 

### Impact Explanation

**Direct Fund Theft:**
- Attacker adds themselves as a beneficiary with arbitrarily large shares to any victim's TokenHolder profit scheme
- Attacker claims accumulated profits meant for legitimate stakeholders
- Impact scales with the total profits in victim schemes (could be thousands to millions of tokens)

**Share Dilution:**
- Legitimate beneficiaries receive proportionally reduced profits
- Scheme managers lose control over their beneficiary lists

**State Corruption:**
- Victim's scheme metadata in their storage slot never gets updated (SchemeId remains null)
- Repeated exploitation creates scheme copies in multiple attackers' storage slots
- Operational DoS as scheme state becomes inconsistent

**Affected Parties:**
- DApp operators who create profit schemes for their users
- Token stakers and legitimate beneficiaries expecting profit distributions
- Any scheme with accumulated profits becomes a target

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call public contract functions (standard user capability)
- Knowledge of target scheme manager address (publicly visible from CreateScheme events)
- Minimal token amount for initial ContributeProfits call (can be 1 wei)

**Attack Complexity:**
- Simple 2-transaction attack:
  1. Call `ContributeProfits(schemeManager: VictimAddress, amount: 1, symbol: any)`
  2. Call `AddBeneficiary(beneficiary: AttackerWallet, shares: large_number)`
- No timing constraints or complex state manipulation required
- Deterministic outcome

**Feasibility Conditions:**
- Victim must have created a TokenHolder scheme (common DApp pattern shown in tests) [9](#0-8) 
- Attack works on first use of victim's scheme after creation (when SchemeId is null)
- Also exploitable if attacker calls before victim's scheme is fully initialized

**Economic Rationale:**
- Attack cost: 1 token + gas fees (minimal)
- Attack reward: Proportional share of all accumulated scheme profits (potentially unlimited)
- ROI: Extremely favorable for attacker

**Detection Constraints:**
- No obvious on-chain indicators distinguishing malicious ContributeProfits from legitimate ones
- State corruption is silent until victim attempts scheme operations

### Recommendation

**Immediate Fix:**
Change line 298 in `UpdateTokenHolderProfitScheme` from:
```csharp
State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```
to:
```csharp
State.TokenHolderProfitSchemes[manager] = scheme;
```

**Additional Safeguards:**
1. Add explicit authorization check in `GetValidScheme` when called with `manager != Context.Sender`:
```csharp
if (manager != Context.Sender) {
    // Require explicit authorization for accessing other managers' schemes
    Assert(/* appropriate authorization check */, "Unauthorized scheme access");
}
```

2. Add state consistency validation in tests to detect storage slot mismatches

3. Consider adding events when scheme state is updated to aid monitoring:
```csharp
Context.Fire(new SchemeUpdated {
    Manager = manager,
    SchemeId = scheme.SchemeId,
    Period = scheme.Period
});
```

**Test Cases to Add:**
- Test that ContributeProfits by non-manager doesn't corrupt victim's scheme state
- Test that attacker cannot add beneficiaries to schemes they don't manage
- Verify scheme updates persist to correct storage slot after ContributeProfits
- Test RegisterForProfits and Withdraw don't cause state corruption

### Proof of Concept

**Initial State:**
- Alice creates TokenHolder scheme for "APP" tokens
- Alice's storage: `State.TokenHolderProfitSchemes[Alice] = {Symbol: "APP", SchemeId: null}`
- ProfitContract creates underlying scheme X with manager = Alice
- Alice contributes 10,000 ELF as profits to scheme X

**Attack Sequence:**

**Step 1: Hijack Scheme ID**
```
Transaction 1: Bob calls ContributeProfits
- Input: {schemeManager: Alice, amount: 1, symbol: "ELF"}
- Execution flow:
  - GetValidScheme(Alice) called with Context.Sender = Bob
  - Reads State.TokenHolderProfitSchemes[Alice] (SchemeId = null)
  - UpdateTokenHolderProfitScheme queries ProfitContract, gets SchemeId = X
  - BUG: Writes to State.TokenHolderProfitSchemes[Bob] instead of [Alice]
- Result: Bob's storage = {Symbol: "APP", SchemeId: X}
- Alice's storage still = {Symbol: "APP", SchemeId: null} (CORRUPTED)
```

**Step 2: Add Malicious Beneficiary**
```
Transaction 2: Bob calls AddBeneficiary
- Input: {beneficiary: MaliciousWallet, shares: 1000000000}
- Execution flow:
  - GetValidScheme(Context.Sender) called with Context.Sender = Bob
  - Reads State.TokenHolderProfitSchemes[Bob] = {SchemeId: X}
  - Calls ProfitContract.AddBeneficiary(schemeId: X, beneficiary: MaliciousWallet, shares: 1000000000)
  - ProfitContract authorization check: Context.Sender == TokenHolderContract âœ“ PASSES
  - MaliciousWallet added to scheme X with massive shares
- Result: MaliciousWallet is beneficiary in Alice's scheme
```

**Step 3: Claim Stolen Profits**
```
Transaction 3: Bob calls ClaimProfits
- Input: {schemeManager: Alice (or Bob), beneficiary: MaliciousWallet}
- Result: MaliciousWallet receives large portion of 10,000 ELF
```

**Expected vs Actual Result:**
- **Expected:** Only Alice can add beneficiaries to her scheme. Bob's ContributeProfits should only donate tokens, not gain scheme control.
- **Actual:** Bob successfully adds arbitrary beneficiaries to Alice's scheme and steals accumulated profits.

**Success Condition:** MaliciousWallet balance increases by stolen profits, legitimate beneficiaries receive reduced distributions.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-39)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L100-102)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L145-145)
```csharp
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L205-205)
```csharp
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-283)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-297)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L298-298)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** test/AElf.Contracts.TokenHolder.Tests/DAppTests.cs (L54-58)
```csharp
        await userTokenHolderStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            SchemeManager = DAppContractAddress,
            Amount = 57_00000000
        });
```
