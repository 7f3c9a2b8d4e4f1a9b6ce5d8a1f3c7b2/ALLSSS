### Title
DOS Attack via Empty Period Creation Permanently Blocks Profit Claiming for Early Beneficiaries

### Summary
A malicious TokenHolder scheme manager can repeatedly call `DistributeProfits` with empty `AmountsMap` to create hundreds or thousands of distribution periods with no tokens. Beneficiaries with early `StartPeriod` values become permanently unable to claim profits because the claiming logic cannot advance past empty periods, causing `LastProfitPeriod` to remain stuck at the first empty period indefinitely.

### Finding Description

The vulnerability exists in the interaction between `TokenHolderContract.DistributeProfits` and the underlying `ProfitContract` claiming logic. [1](#0-0) 

In `TokenHolderContract.DistributeProfits`, when `AmountsMap` is null or empty, the function still proceeds to call the Profit contract and unconditionally increments the period counter: [2](#0-1) 

The root cause is that there is no validation preventing distribution with empty amounts. When `AmountsMap` is empty, the Profit contract's `DistributeProfits` checks for `IsReleaseAllBalanceEveryTimeByDefault` but if `ReceivedTokenSymbols` is empty (no contributions yet), `profitsMap` remains empty: [3](#0-2) 

Despite empty `profitsMap`, `UpdateDistributedProfits` still creates a `DistributedProfitsInfo` record with `IsReleased = true`, empty `AmountsMap`, and non-zero `TotalShares`: [4](#0-3) 

The period still increments: [5](#0-4) 

When beneficiaries try to claim via `ProfitAllPeriods`, the logic skips empty periods but never updates `LastProfitPeriod`: [6](#0-5) 

The `continue` statement at line 871 prevents reaching line 908 where `lastProfitPeriod` would be incremented. After processing up to `maxProfitReceivingPeriodCount` empty periods (default 100), the `LastProfitPeriod` remains unchanged: [7](#0-6) 

### Impact Explanation

**Permanent DOS of Profit Claiming:**
- Any beneficiary added with `StartPeriod` before or during the empty period range becomes permanently unable to claim any profits
- Each `ClaimProfits` call processes only up to 100 periods (the default `maxProfitReceivingPeriodCount`) and skips all empty ones without advancing `LastProfitPeriod`
- If 1000 empty periods exist, a beneficiary would need 10+ claim transactions just to skip through them, each costing gas, with `LastProfitPeriod` never advancing
- Even if real distributions occur in future periods (e.g., period 1001+), the beneficiary can never reach them because they're permanently stuck at period 1

**Affected Parties:**
- All early beneficiaries (users who locked tokens) lose access to their entitled profit distributions
- The scheme becomes functionally broken, unable to distribute rewards
- Legitimate stakers cannot recover their earned rewards

**Severity Justification:**
This is a HIGH severity issue because:
1. Results in permanent, irreversible loss of user funds (earned profits)
2. Affects all beneficiaries with early start periods
3. No recovery mechanism exists - beneficiaries are permanently DOS'd
4. Attacker needs only legitimate manager authority, no additional privileges

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be the scheme manager, which is a legitimate role with authorization to call `DistributeProfits`: [8](#0-7) 

**Attack Complexity:**
The attack is trivial to execute:
1. Create a TokenHolder scheme (scheme manager = attacker)
2. Add beneficiaries (to ensure non-zero `TotalShares`)
3. Before any contributions, repeatedly call `DistributeProfits` with empty/null `AmountsMap`
4. Each call costs minimal gas and creates one empty period

**Feasibility Conditions:**
- No validation prevents calling `DistributeProfits` with empty amounts
- No rate limiting on distribution calls
- Attack can be executed before or after legitimate operations
- Even schemes with existing beneficiaries and contributions can be attacked retroactively

**Economic Rationality:**
- Attack cost: negligible (only transaction fees for legitimate manager calls)
- Impact: complete DOS of profit claiming for all early beneficiaries
- Detection: difficult until beneficiaries attempt to claim
- Motivation: griefing, competitive sabotage, or ransom (promise to stop attack in exchange for payment)

**Probability:** HIGH - The attack is practical, cheap, and uses only legitimate authorization. Any malicious or compromised scheme manager can execute it.

### Recommendation

**Primary Fix - Add Empty Distribution Validation:**

In `TokenHolderContract.DistributeProfits`, validate that `AmountsMap` is not empty OR that the scheme has actual token balances to distribute:

```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // ADD VALIDATION HERE
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), 
           "Cannot distribute with empty amounts map.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);
    
    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

**Secondary Fix - Improve Claiming Logic:**

In `ProfitContract.ProfitAllPeriods`, when encountering an empty period, increment `lastProfitPeriod` to skip it:

```csharp
for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
{
    var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
    
    if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
        !distributedProfitsInformation.AmountsMap.Any() ||
        !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
    {
        lastProfitPeriod = period + 1; // INCREMENT TO SKIP EMPTY PERIOD
        continue;
    }
    // ... rest of claiming logic
}
```

**Test Cases:**
1. Test that `DistributeProfits` reverts when called with null `AmountsMap`
2. Test that `DistributeProfits` reverts when called with empty `AmountsMap`
3. Test that beneficiaries can claim after multiple legitimate distributions
4. Test that the claiming logic correctly skips any legacy empty periods

### Proof of Concept

**Initial State:**
1. Create TokenHolder scheme with scheme manager = Attacker
2. Scheme has `CurrentPeriod = 1`, `IsReleaseAllBalanceEveryTimeByDefault = true`
3. Add User A as beneficiary â†’ User A gets `ProfitDetail` with `StartPeriod = 1`, `LastProfitPeriod = 0`

**Attack Execution:**
```
For i = 1 to 1000:
    Attacker calls TokenHolderContract.DistributeProfits({
        SchemeManager: Attacker,
        AmountsMap: null  // or empty {}
    })
```

**Result After Attack:**
- Periods 1-1000 exist with `DistributedProfitsInfo.AmountsMap = {}` (empty)
- Each period has `IsReleased = true`, `TotalShares > 0`
- `CurrentPeriod = 1001`

**Normal Operations:**
- Contributions are made, tokens added to scheme
- Period 1001 distributed with actual tokens

**User A Attempts to Claim:**
```
User A calls ClaimProfits
```

**Expected Result:** User A claims profits from periods 1-1001

**Actual Result:** 
1. Claiming loop processes periods 1-100 (first batch)
2. All 100 periods have empty `AmountsMap`
3. Line 871 `continue` executes for all, skipping profit transfer
4. `LastProfitPeriod` remains stuck at 1 (never updated at line 908)
5. User A receives zero tokens
6. Subsequent claim attempts repeat the same behavior
7. User A is permanently DOS'd, can never claim period 1001+ profits

**Success Condition:** User A's `LastProfitPeriod` never advances beyond the empty periods, proving permanent DOS.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L131-147)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        var scheme = GetValidScheme(input.SchemeManager, true);
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Period = scheme.Period
        };
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L447-460)
```csharp
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-917)
```csharp
                    lastProfitPeriod = period + 1;
                }

                totalAmount = totalAmount.Add(amount);
            }

            profitsMap.Add(symbol, totalAmount);
        }

        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
