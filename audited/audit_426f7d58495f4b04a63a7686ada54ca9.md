### Title
Null Reference Exception in TryToGetCurrentRoundInformation Causes Consensus Command Generation Denial of Service

### Summary
The `TryToGetCurrentRoundInformation` helper method dereferences the `Round` object returned from state without null checking, causing a NullReferenceException when `State.Rounds[roundNumber]` returns null. This crashes the consensus command generation flow, preventing miners from obtaining mining commands and causing a denial of service to the consensus mechanism.

### Finding Description

The vulnerability exists in the `TryToGetCurrentRoundInformation` method where it accesses `round.IsEmpty` without first verifying that `round` is not null: [1](#0-0) 

When `State.Rounds[roundNumber]` returns null (because the round doesn't exist or has been removed), line 53 attempts to access the `IsEmpty` property on a null object, throwing a NullReferenceException.

Evidence that `State.Rounds` can return null is found in other methods that properly check for this condition: [2](#0-1) [3](#0-2) 

The MappedState implementation confirms that accessing non-existent keys returns null through the serialization helper: [4](#0-3) 

The vulnerability is triggered through the public `GetConsensusCommand` entry point: [5](#0-4) 

Regarding the specific question about `TinyBlockCommandStrategy` constructor: while accessing `CurrentRound.GetRoundStartTime()` and `CurrentRound.RoundNumber` would indeed cause null reference exceptions if `currentRound` were null: [6](#0-5) 

The actual crash occurs earlier in `TryToGetCurrentRoundInformation` before `TinyBlockCommandStrategy` is ever instantiated. The same vulnerability pattern exists in related methods: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact: Denial of Service of Consensus Mechanism**

When this exception is thrown, the `GetConsensusCommand` method fails completely, preventing any miner from obtaining consensus commands. This blocks:
- Tiny block production
- Normal block production  
- Round transitions
- Term transitions

The consensus mechanism becomes completely inoperable, halting all block production across the network until the issue is resolved (likely requiring contract upgrade or state repair).

This affects all miners and ultimately all users of the blockchain, as no new transactions can be processed when block production stops.

### Likelihood Explanation

**Low Likelihood - Requires State Corruption or Round Management Bug**

This vulnerability requires `State.CurrentRoundNumber.Value` to point to a round number where `State.Rounds[roundNumber]` returns null. Under normal operation, this should not occur because:

1. Rounds are added to state via `AddRoundInformation` which sets both the round data and updates `CurrentRoundNumber`: [9](#0-8) 

2. Old rounds are only removed from storage after 40,960 rounds have passed: [10](#0-9) [11](#0-10) 

However, this could occur in edge cases:
- State corruption or database inconsistency
- A bug in round management logic causing `CurrentRoundNumber` to be set without corresponding round data
- Race conditions during state updates (though AElf's transaction model should prevent this)
- Contract upgrade scenarios with incomplete state migration

While the likelihood is low, the severity of impact (complete consensus halt) makes this a critical defensive programming issue.

### Recommendation

Add null checks before accessing properties on `Round` objects returned from state:

```csharp
private bool TryToGetCurrentRoundInformation(out Round round)
{
    round = null;
    if (!TryToGetRoundNumber(out var roundNumber)) return false;
    round = State.Rounds[roundNumber];
    return round != null && !round.IsEmpty;
}

private bool TryToGetPreviousRoundInformation(out Round previousRound)
{
    previousRound = new Round();
    if (!TryToGetRoundNumber(out var roundNumber)) return false;
    if (roundNumber < 2) return false;
    var targetRoundNumber = roundNumber.Sub(1);
    previousRound = State.Rounds[targetRoundNumber];
    return previousRound != null && !previousRound.IsEmpty;
}

private bool TryToGetRoundInformation(long roundNumber, out Round round)
{
    round = State.Rounds[roundNumber];
    return round != null && !round.IsEmpty;
}
```

Add test cases to verify graceful handling when rounds don't exist in state, including:
- Calling `GetConsensusCommand` when `CurrentRoundNumber` points to non-existent round
- State consistency validation during round transitions
- Recovery procedures for state corruption scenarios

### Proof of Concept

**Required Initial State:**
- Contract deployed and initialized
- `State.CurrentRoundNumber.Value` = 100 (any valid number)
- `State.Rounds[100]` = null (key doesn't exist in state - simulating corruption or deleted round)

**Execution Steps:**
1. Any miner calls the public `GetConsensusCommand` method with their public key
2. Method reaches line 23: `if (!TryToGetCurrentRoundInformation(out var currentRound))`
3. Inside `TryToGetCurrentRoundInformation`:
   - Line 51: `TryToGetRoundNumber` succeeds, returns roundNumber = 100
   - Line 52: `round = State.Rounds[100]` returns null
   - Line 53: `return !round.IsEmpty` attempts to access `IsEmpty` property on null

**Expected Result:**
Method should return false, indicating current round information is unavailable

**Actual Result:**
NullReferenceException is thrown, causing transaction failure and preventing any consensus commands from being generated

**Success Condition:**
The contract throws an unhandled NullReferenceException, completely blocking the consensus command generation mechanism for all miners.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L62-63)
```csharp
        previousRound = State.Rounds[targetRoundNumber];
        return !previousRound.IsEmpty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L68-69)
```csharp
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L118-123)
```csharp
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L443-444)
```csharp
        var round = State.Rounds[lastRoundNumber];
        if (round == null || round.RoundId == 0) return new Round();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L467-468)
```csharp
        var lastRound = State.Rounds[lastRoundNumber];
        if (lastRound == null || lastRound.RoundId == 0) return new PubkeyList();
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L88-91)
```csharp
        public static T Deserialize<T>(byte[] bytes)
        {
            if (bytes == null)
                return default;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L23-24)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L32-35)
```csharp
            var roundStartTime = CurrentRound.GetRoundStartTime();
            var currentTimeSlotStartTime = CurrentBlockTime < roundStartTime
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L10-10)
```csharp
    public const int KeepRounds = 40960;
```
