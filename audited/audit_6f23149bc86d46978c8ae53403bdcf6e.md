### Title
Arbitrary Contract Address in CheckOrganizationExist Enables Governance Bypass via Fake Authority Structure

### Summary
The `CheckOrganizationExist` method makes a cross-contract call to an arbitrary `ContractAddress` provided in the `AuthorityInfo` input without validating it corresponds to a legitimate governance contract (Parliament, Association, or Referendum). An attacker with temporary governance access can deploy a malicious contract that always returns `true` for `ValidateOrganizationExist`, bypass the organization existence check in `ChangeMethodFeeController`, and establish permanent direct control over method fees without future governance oversight.

### Finding Description

**Vulnerable Code Location:** [1](#0-0) 

The `CheckOrganizationExist` method calls `Context.Call<BoolValue>` on `authorityInfo.ContractAddress` without any validation that this address is one of the three legitimate system governance contracts. The method simply returns the `.Value` property of whatever `BoolValue` the called contract returns.

**Root Cause:**

There is no validation that `authorityInfo.ContractAddress` must be one of:
- Parliament contract address (from `SmartContractConstants.ParliamentContractSystemName`)
- Association contract address (from `SmartContractConstants.AssociationContractSystemName`)  
- Referendum contract address (from `SmartContractConstants.ReferendumContractSystemName`)

Unlike proper validation patterns seen elsewhere in the codebase [2](#0-1) , which validate system contract addresses match expected values, the Election contract accepts any contract address.

**Why Existing Protections Fail:**

The `ChangeMethodFeeController` method has authorization checking: [3](#0-2) 

Line 24 ensures only the current controller's `OwnerAddress` can call the method. However, this only protects against unauthorized callers - it does not validate the **new** `AuthorityInfo` structure being set. The check on lines 25-26 is meant to validate the new controller, but it can be bypassed by providing a malicious `ContractAddress`.

**Execution Path:**

1. Attacker gains temporary governance access (e.g., through a compromised Parliament proposal)
2. Attacker deploys a malicious contract implementing `ValidateOrganizationExist` that always returns `new BoolValue { Value = true }`
3. Parliament proposal executes `ChangeMethodFeeController` with `AuthorityInfo { ContractAddress: MaliciousContract, OwnerAddress: AttackerEOA }`
4. `CheckOrganizationExist` calls the malicious contract, which returns `true`
5. The assertion passes, and the new controller is set with attacker's address as `OwnerAddress`

### Impact Explanation

**Direct Harm:**

After the attack, the `SetMethodFee` method becomes directly callable by the attacker: [4](#0-3) 

Line 16 checks that `Context.Sender == State.MethodFeeController.Value.OwnerAddress`. Since `OwnerAddress` is now the attacker's EOA address (not an organization address), the attacker can directly call `SetMethodFee` without any governance process.

**Protocol Damage:**

The attacker gains complete control over Election contract transaction fees, enabling them to:

1. **Economic DoS**: Set fees to extremely high values, making Election contract methods (voting, candidate registration, etc.) prohibitively expensive
2. **Economic Exploitation**: Set fees to zero, breaking the economic model and allowing spam attacks
3. **Permanent Control**: Continuously call `ChangeMethodFeeController` to maintain control even if governance attempts recovery
4. **Fake Governance**: Create an appearance of legitimate governance while having unilateral control

**Affected Parties:**

- All users of the Election contract (voters, candidates, validators)
- The broader AElf ecosystem's governance integrity
- Economic security of the chain

**Severity Justification:**

This is a **High severity** vulnerability because it:
- Completely bypasses governance controls (Critical Invariant #1 violation)
- Allows permanent capture of method fee authority
- Requires only temporary governance compromise to establish permanent control
- Affects a critical system contract (Election)

### Likelihood Explanation

**Attacker Capabilities:**

The attacker must initially gain control to execute a proposal through the current `MethodFeeController` (typically Parliament). This could occur through:
- A single malicious proposal approved during governance compromise
- Social engineering of miner votes
- Exploiting a separate governance vulnerability

**Attack Complexity:**

The attack is straightforward once initial access is obtained:
1. Deploy a simple malicious contract with 10-20 lines of code
2. Create a single proposal to call `ChangeMethodFeeController`
3. No complex timing, state manipulation, or repeated transactions required

**Feasibility Conditions:**

- Attacker needs temporary governance access (one approved proposal)
- Contract deployment must be permitted
- No special privileges beyond proposal execution required

**Detection Constraints:**

The attack appears as a legitimate governance action:
- Uses official `ChangeMethodFeeController` method
- Passes all authorization checks
- The malicious contract address may not be immediately recognizable as fake
- No failed transactions or obvious attack signatures

**Probability Assessment:**

Given the low technical complexity and high impact, if an attacker achieves temporary governance access (e.g., through miner collusion or a governance vulnerability), exploiting this to establish permanent control is **highly likely**.

### Recommendation

**Code-Level Mitigation:**

Modify `CheckOrganizationExist` to validate the contract address:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant Checks:**

Add assertion that `MethodFeeController.ContractAddress` must always be one of the three system governance contracts. Validate this in:
- Contract initialization
- Any controller update
- Before processing proposals

**Test Cases:**

1. Test `ChangeMethodFeeController` with arbitrary contract address - should fail
2. Test `ChangeMethodFeeController` with non-governance system contract - should fail  
3. Test `ChangeMethodFeeController` with EOA address - should fail
4. Test `ChangeMethodFeeController` with valid Parliament/Association/Referendum addresses - should succeed
5. Verify malicious contract returning `true` is rejected due to address validation

### Proof of Concept

**Initial State:**
- Election contract deployed with default Parliament controller
- Attacker has temporary Parliament governance access (one approved proposal)

**Attack Sequence:**

**Step 1:** Attacker deploys malicious contract:
```csharp
public class MaliciousOrganizationContract : ContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

**Step 2:** Attacker creates Parliament proposal targeting Election contract:
- Method: `ChangeMethodFeeController`
- Parameters: `AuthorityInfo { ContractAddress: MaliciousContractAddress, OwnerAddress: AttackerEOAAddress }`

**Step 3:** Proposal gets approved and released through Parliament

**Step 4:** During proposal execution:
- `Context.Sender` = Parliament organization address (passes line 24 authorization)
- `CheckOrganizationExist` calls `MaliciousContract.ValidateOrganizationExist(AttackerEOAAddress)`
- Malicious contract returns `BoolValue { Value = true }`
- Assertion on line 26 passes
- New controller set: `State.MethodFeeController.Value = AuthorityInfo { ContractAddress: MaliciousContract, OwnerAddress: AttackerEOA }`

**Step 5:** Attacker directly calls `SetMethodFee`:
- `Context.Sender` = AttackerEOA
- Line 16 check passes: `AttackerEOA == State.MethodFeeController.Value.OwnerAddress` (AttackerEOA)
- Attacker sets arbitrary fees without governance

**Expected vs Actual Result:**

**Expected:** Organization validation should fail because AttackerEOA is not a valid Parliament/Association/Referendum organization, preventing the controller change.

**Actual:** Malicious contract returns `true`, validation passes, and attacker gains permanent direct control over method fees, completely bypassing governance requirements.

**Success Condition:** Attacker can call `SetMethodFee` directly from their EOA without creating proposals or requiring governance approval, while all other users must go through the proper governance process.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L11-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_ACS1_TransactionFeeProvider.cs (L67-72)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L59-64)
```csharp
    public override Empty ValidateSystemContractAddress(ValidateSystemContractAddressInput input)
    {
        var actualAddress = GetContractAddressByName(input.SystemContractHashName);
        Assert(actualAddress == input.Address, "Address not expected.");
        return new Empty();
    }
```
