# Audit Report

## Title
Hex Case Mismatch in Pubkey Replacement Causes Active Miner Denial of Service

## Summary
The `RecordCandidateReplacement` method in the AEDPoS consensus contract accepts pubkey strings without normalizing hex case before storing them as dictionary keys in `RealTimeMinersInformation`. When a replaced miner attempts to retrieve consensus commands, the system converts their pubkey bytes to lowercase hex, causing a dictionary key mismatch if the replacement was stored with uppercase or mixed case. This prevents the affected miner from producing blocks.

## Finding Description

The vulnerability exists in the pubkey replacement flow between the Election and Consensus contracts:

**Root Cause:** The `RecordCandidateReplacement` method directly uses the `input.NewPubkey` string as a dictionary key without normalizing its hex case. [1](#0-0) 

The protobuf definition confirms both pubkeys are plain strings without case constraints: [2](#0-1) 

**Entry Point:** Candidate admins call `ReplaceCandidatePubkey`, which sends these user-provided strings to the consensus contract: [3](#0-2) 

**Failure Point:** When miners request consensus commands, the system converts their pubkey bytes to lowercase hex using `ToHex()`, then performs a case-sensitive dictionary lookup via `IsInMinerList()`: [4](#0-3) 

The `IsInMinerList` method performs case-sensitive string comparison: [5](#0-4) 

**Hex Conversion Guarantee:** The `ToHex()` method always produces lowercase hex characters ('a'-'f') for values 10-15: [6](#0-5) 

The formula `b + 0x37 + 0x20` adds an extra 0x20 offset, producing lowercase instead of uppercase letters.

**Established Convention:** All initial miner list creation uses `ToHex()`, establishing lowercase as the expected format: [7](#0-6) 

**Exploit Scenario:**
1. A miner is currently active with lowercase pubkey "04abcd..." in `RealTimeMinersInformation`
2. Admin calls `ReplaceCandidatePubkey` with correctly-cased `OldPubkey` but uppercase `NewPubkey = "04EFGH..."`
3. The consensus contract's `RecordCandidateReplacement` removes the old key and adds the uppercase key
4. The replaced miner attempts to produce blocks by calling `GetConsensusCommand` with their new pubkey bytes
5. The system converts these bytes to lowercase "04efgh..." via `ToHex()`
6. Dictionary lookup fails because the key is stored as "04EFGH..." (uppercase)
7. Miner receives `InvalidConsensusCommand` and cannot produce blocks

## Impact Explanation

**Consensus Disruption:**
- The affected miner cannot retrieve valid consensus commands, completely preventing block production
- Network consensus capacity is reduced by one miner until remediation
- The miner loses all block rewards during the outage period
- If multiple miners are affected through repeated admin errors, network liveness could be severely impacted

**Affected Parties:**
- The miner whose pubkey was replaced with non-lowercase hex loses the ability to mine
- The blockchain network suffers reduced consensus participation and potentially slower block times
- Token holders may experience degraded network performance

**Severity Assessment:**
- **Medium Severity** - No direct fund theft but operational disruption to critical consensus mechanism
- Can be remediated by calling `ReplaceCandidatePubkey` again with correctly-cased hex strings
- Requires admin-level action to trigger, limiting attack surface
- Detection is immediate (miner fails to produce blocks) but may not be obvious to non-technical admins
- Impact scales linearly with number of affected miners

## Likelihood Explanation

**Triggering Conditions:**
- Requires being a candidate admin authorized to call `ReplaceCandidatePubkey`
- Must provide new pubkey in non-lowercase format (uppercase or mixed case)
- No special cryptographic or timing knowledge required

**Attack Complexity:**
- Very low complexity: Single transaction with uppercase hex string
- No race conditions or complex state manipulation
- Deterministic outcome once executed

**Feasibility:**
- All test cases use `.ToHex()` which produces lowercase: [8](#0-7) 

- However, **no contract-level validation enforces lowercase hex**
- The `ByteArrayHelper.HexStringToByteArray` method accepts both uppercase and lowercase: [9](#0-8) 

- Manual API calls, CLI tools, or UI inputs could provide uppercase strings
- More likely to be accidental (admin copy-pasting from external source) than intentional

**Probability:**
- **Moderate likelihood** - Requires deviation from documented patterns but nothing prevents it
- Higher probability in production where admins may obtain hex strings from various sources
- Detection is immediate but root cause may not be obvious

## Recommendation

Add hex case normalization to the `RecordCandidateReplacement` method before using pubkeys as dictionary keys:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    // Normalize hex strings to lowercase
    var normalizedOldPubkey = input.OldPubkey?.ToLowerInvariant();
    var normalizedNewPubkey = input.NewPubkey?.ToLowerInvariant();

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(normalizedOldPubkey)) 
        return new Empty();

    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[normalizedOldPubkey];
    realTimeMinerInformation.Pubkey = normalizedNewPubkey;
    currentRound.RealTimeMinersInformation.Remove(normalizedOldPubkey);
    currentRound.RealTimeMinersInformation.Add(normalizedNewPubkey, realTimeMinerInformation);
    
    if (currentRound.ExtraBlockProducerOfPreviousRound == normalizedOldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = normalizedNewPubkey;
    
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = normalizedOldPubkey,
        NewPubkey = normalizedNewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

Alternatively, add validation in `ReplaceCandidatePubkey` to enforce lowercase input before sending to consensus contract.

## Proof of Concept

```csharp
[Fact]
public async Task ReplaceCandidatePubkey_UppercaseNewPubkey_CausesDoS()
{
    // Setup: Announce a candidate who becomes a miner
    var oldKeyPair = InitialCoreDataCenterKeyPairs[0];
    var newKeyPair = ValidationDataCenterKeyPairs[0];
    var admin = ValidationDataCenterKeyPairs.Last();
    
    // Get initial consensus command (should succeed)
    var consensusCommand = await AEDPoSContractStub.GetConsensusCommand.CallAsync(
        ByteString.CopyFrom(oldKeyPair.PublicKey).ToBytesValue());
    consensusCommand.ShouldNotBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Replace with UPPERCASE new pubkey
    var adminStub = GetElectionContractStub(admin);
    await adminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
    {
        OldPubkey = oldKeyPair.PublicKey.ToHex(),  // lowercase (correct)
        NewPubkey = newKeyPair.PublicKey.ToHex().ToUpperInvariant()  // UPPERCASE (bug trigger)
    });
    
    // Try to get consensus command with new key - should FAIL due to case mismatch
    var newKeyStub = GetAEDPoSContractStub(newKeyPair);
    var failedCommand = await newKeyStub.GetConsensusCommand.CallAsync(
        ByteString.CopyFrom(newKeyPair.PublicKey).ToBytesValue());
    
    // Assert: Miner cannot get valid consensus command (DoS)
    failedCommand.ShouldBe(ConsensusCommandProvider.InvalidConsensusCommand);
    
    // Verify the dictionary has uppercase key but ToHex produces lowercase
    var round = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var uppercaseKey = newKeyPair.PublicKey.ToHex().ToUpperInvariant();
    var lowercaseKey = newKeyPair.PublicKey.ToHex();
    
    round.RealTimeMinersInformation.ContainsKey(uppercaseKey).ShouldBeTrue();  // Stored as uppercase
    round.RealTimeMinersInformation.ContainsKey(lowercaseKey).ShouldBeFalse(); // Lookup uses lowercase
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L140-143)
```csharp
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
```

**File:** protobuf/aedpos_contract.proto (L452-455)
```text
message RecordCandidateReplacementInput {
    string old_pubkey = 1;
    string new_pubkey = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L298-302)
```csharp
        State.AEDPoSContract.RecordCandidateReplacement.Send(new RecordCandidateReplacementInput
        {
            OldPubkey = oldPubkey,
            NewPubkey = newPubkey
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L19-26)
```csharp
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L35-42)
```csharp
            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-37)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ReplaceCandidateTests.cs (L38-42)
```csharp
        await candidateAdminStub.ReplaceCandidatePubkey.SendAsync(new ReplaceCandidatePubkeyInput
        {
            OldPubkey = announceElectionKeyPair.PublicKey.ToHex(),
            NewPubkey = newKeyPair.PublicKey.ToHex()
        });
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-18)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
```
