### Title
ExpectedMiningTime Manipulation in Next Round Allows Network DoS

### Summary
The `ValidationForNextRound()` function and associated validation providers fail to verify that `ExpectedMiningTime` values in the next round are anchored to the current block timestamp. A malicious extra block producer can set arbitrary `ExpectedMiningTime` values (e.g., far in the future or past) while maintaining equal intervals between miners, causing all validation checks to pass. This results in a network DoS as miners cannot produce blocks when the manipulated round becomes active.

### Finding Description

The validation of next round information occurs through multiple providers orchestrated in `ValidateBeforeExecution`. [1](#0-0) 

The `RoundTerminateValidationProvider.ValidationForNextRound()` only validates that the round number increments by 1 and that all miners' `InValue` fields are null. It does not validate `ExpectedMiningTime` values. [2](#0-1) 

The `TimeSlotValidationProvider` delegates time slot validation to `CheckRoundTimeSlots()` when a new round is provided. [3](#0-2) 

The `CheckRoundTimeSlots()` method only validates that: (1) `ExpectedMiningTime` is not null, (2) mining interval > 0, and (3) mining intervals between consecutive miners are roughly equal (with 100% tolerance). It does NOT validate that the absolute `ExpectedMiningTime` values are reasonable relative to the current block time. [4](#0-3) 

The intended generation logic sets `ExpectedMiningTime` based on `currentBlockTimestamp.AddMilliseconds(miningInterval * order)`. [5](#0-4) 

However, validation never compares the provided round's `ExpectedMiningTime` values against this expected calculation. A malicious extra block producer can modify the Round data after calling `GetConsensusExtraData` but before including it in their block. [6](#0-5) 

When the manipulated round becomes active, miners cannot produce blocks because `IsCurrentMiner()` checks fail. The method validates that `Context.CurrentBlockTime` falls within a miner's time slot (`ExpectedMiningTime` to `ExpectedMiningTime + miningInterval`). If `ExpectedMiningTime` is set far in the future, this check fails for all miners. [7](#0-6) 

### Impact Explanation

**Consensus DoS**: When the manipulated next round becomes the current round, all honest miners are unable to produce blocks because their `ExpectedMiningTime` is set far in the future (or past). The `IsCurrentMiner()` validation fails since `Context.CurrentBlockTime` doesn't fall within their assigned time slots.

**Network Halt**: Block production stops completely. No transactions can be processed. The blockchain becomes unusable until manual intervention or a hard fork.

**Affected Parties**: All network participants - users cannot transact, applications cannot function, and the entire chain is frozen.

**Severity Justification**: High severity due to complete network DoS with deterministic exploitation by any miner selected as extra block producer (a regularly rotating role).

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be selected as the extra block producer, which happens through deterministic rotation based on consensus. Any miner in the active set will eventually have this opportunity.

**Attack Complexity**: Low. The attacker modifies the `Round` data structure in their client between generation and serialization into the block header. No special privileges beyond being a miner are required.

**Feasibility Conditions**: 
- Attacker runs a modified client that alters `ExpectedMiningTime` values
- Attacker waits until selected as extra block producer
- No additional preconditions needed

**Detection**: The attack is immediately visible once the manipulated round becomes active (network stops producing blocks), but by then the damage is done.

**Probability**: High. Every miner becomes extra block producer periodically, providing regular attack opportunities. The validation gap makes exploitation trivial.

### Recommendation

Add validation in `ValidationForNextRound()` or `CheckRoundTimeSlots()` to verify that `ExpectedMiningTime` values are correctly derived from the current block timestamp:

1. Calculate the expected first miner's `ExpectedMiningTime` as `Context.CurrentBlockTime + miningInterval`
2. Verify each subsequent miner's `ExpectedMiningTime` equals the first miner's time plus `(order - 1) * miningInterval`
3. Add tolerance of only a few milliseconds (e.g., 100ms) rather than the current 100% tolerance
4. Reject rounds where `ExpectedMiningTime` values deviate from expected calculations

Example validation to add:
```
var expectedFirstMinerTime = Context.CurrentBlockTime.AddMilliseconds(miningInterval);
var actualFirstMinerTime = miners[0].ExpectedMiningTime;
if (Math.Abs((actualFirstMinerTime - expectedFirstMinerTime).Milliseconds()) > 100)
    return new ValidationResult { Message = "First miner's ExpectedMiningTime doesn't match current block time" };
```

Add test cases covering:
- NextRound with ExpectedMiningTime set 1 year in future (should fail)
- NextRound with ExpectedMiningTime set in past (should fail)
- NextRound with correct ExpectedMiningTime based on current time (should pass)

### Proof of Concept

**Initial State**: Network operating normally, attacker is a miner in the active set.

**Attack Steps**:
1. Attacker waits until selected as extra block producer (deterministic rotation)
2. During their extra block time slot, attacker prepares NextRound block
3. Attacker calls `GetConsensusExtraData` with `NextRound` behavior to generate proper round data
4. Attacker's modified client intercepts the generated Round and modifies all `ExpectedMiningTime` values to `Context.CurrentBlockTime + 365 days`
5. Attacker maintains equal intervals between miners (e.g., 4000ms each)
6. Attacker includes manipulated consensus data in block and signs it
7. Block validation occurs via `ValidateBeforeExecution`
8. All validation passes: round number increments, InValues null, intervals equal
9. `ProcessNextRound` stores manipulated round to state
10. Next block attempt: honest miner calls `IsCurrentMiner()` which checks if `Context.CurrentBlockTime` (now) is within their time slot (365 days in future)
11. Check fails: `timeSlotStartTime <= Context.CurrentBlockTime` returns false
12. No miner can produce blocks - network halted

**Expected Result**: Validation should reject the NextRound with manipulated times.

**Actual Result**: Validation passes, manipulated round is stored, and network DoS occurs when that round becomes active.

**Success Condition**: The attack succeeds when the network cannot produce any blocks after the manipulated round becomes the current round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L33-33)
```csharp
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L159-167)
```csharp
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```
