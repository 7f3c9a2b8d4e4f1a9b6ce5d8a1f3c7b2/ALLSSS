### Title
Case-Insensitive Token Duplicate Registration via CrossChainCreateToken Bypass

### Summary
The `CrossChainCreateToken` method bypasses case-insensitive token uniqueness checks by only validating `TokenInfos` existence but not checking `InsensitiveTokenExisting`, allowing creation of duplicate tokens that differ only in case (e.g., "ABC" and "abc"). This violates the protocol's design invariant that tokens must be case-insensitively unique, leading to token confusion and potential fund loss.

### Finding Description

The token creation flow has two entry points with inconsistent validation:

1. **Create method** (via `CreateToken`) properly enforces case-insensitive uniqueness: [1](#0-0) 

The `CheckTokenExists` function validates both state mappings: [2](#0-1) 

2. **CrossChainCreateToken method** only performs partial validation: [3](#0-2) 

This check is case-sensitive and only validates `TokenInfos[symbol]`, completely omitting the `InsensitiveTokenExisting[symbol.ToUpper()]` check.

When `RegisterTokenInfo` executes, it updates both mappings: [4](#0-3) 

**Why this is NOT a race condition:** Both `Create` and `CrossChainCreateToken` are marked as non-parallelizable in the ACS2 implementation, executing sequentially: [5](#0-4) 

Non-parallelizable transactions execute sequentially via `IPlainTransactionExecutingService`: [6](#0-5) 

Therefore, no traditional race condition exists. The vulnerability is a **logic flaw** where CrossChainCreateToken has incomplete validation.

### Impact Explanation

**Direct Token Integrity Impact:**
- Multiple token symbols differing only in case can coexist (e.g., "TOKEN", "token", "Token")
- Each maintains separate `TokenInfo` entries with independent supply, issuer, and ownership
- Token operations (`Transfer`, `GetTokenInfo`, etc.) use case-sensitive lookups, treating them as distinct tokens

**User Impact:**
- Users may transfer funds to wrong symbol variant, causing unintended loss
- Token confusion in cross-chain transfers where case might vary
- Protocol reputation damage from violated uniqueness invariant

**Severity Justification:** High
- Violates critical protocol invariant (case-insensitive token uniqueness)
- Allows permanent state corruption (duplicate symbols persist)
- Affects token integrity across entire chain ecosystem
- No automatic remediation mechanism exists

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Control of a registered cross-chain sender (or compromise of legitimate cross-chain flow)
2. Valid cross-chain proof from parent/side chain
3. Ability to craft token symbol with different casing than existing token

**Attack Complexity:** Medium
- Requires valid cross-chain transaction from registered chain: [7](#0-6) 

- Must pass merkle proof verification
- However, legitimate cross-chain token creation flows could accidentally trigger this if source and destination chains use different symbol casing

**Feasibility Conditions:**
- Cross-chain contract address must be registered in `CrossChainTransferWhiteList`
- Valid merkle path from indexed parent chain block required
- NFT collection must exist if creating NFT (line 491)
- More likely to occur accidentally during legitimate multi-chain token deployments than malicious exploitation

**Probability:** Medium-High
- Not exploitable by arbitrary users without cross-chain access
- But legitimate cross-chain operations are frequent
- No validation prevents this scenario
- Could occur unintentionally in multi-chain environments

### Recommendation

**Immediate Fix:**
Modify `CrossChainCreateToken` to check case-insensitive existence before line 508:

```csharp
if (State.TokenInfos[tokenInfo.Symbol] == null)
{
    // Add case-insensitive check
    Assert(!State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()], 
        "Token already exists.");
    RegisterTokenInfo(tokenInfo);
    // ... rest of token creation
}
```

**Alternative Approach:**
Reuse existing validation by calling `CheckTokenExists` before registration: [2](#0-1) 

**Test Cases Required:**
1. Attempt `CrossChainCreateToken` for symbol differing only in case from existing token
2. Verify transaction fails with "Token already exists" error
3. Test with various case combinations (UPPER, lower, MixedCase)
4. Verify existing same-case cross-chain token creation still works

**Invariant to Enforce:**
For any symbol `S`, at most one entry should exist in `TokenInfos` such that `S.ToUpper()` matches `InsensitiveTokenExisting` keys.

### Proof of Concept

**Initial State:**
- Main chain has token "ABC" created via `Create` method
- Side chain has `CrossChainTransferWhiteList` registered for main chain
- Main chain token contract address validated and indexed

**Attack Steps:**

1. **On Main Chain:** Create token with symbol "ABC"
   - `Create(symbol: "ABC", ...)`
   - Sets `TokenInfos["ABC"]` and `InsensitiveTokenExisting["ABC"] = true`

2. **Prepare Cross-Chain Transaction:** Create validation transaction on main chain
   - `ValidateTokenInfoExists` with symbol "abc" (lowercase)
   - Generate merkle proof and index on side chain

3. **On Side Chain:** Execute `CrossChainCreateToken`
   - Input: `{FromChainId: mainChain, Symbol: "abc", ...}`
   - Line 506 check: `State.TokenInfos["abc"] == null` → TRUE (case-sensitive)
   - Missing check: `State.InsensitiveTokenExisting["ABC"]` → already TRUE (ignored)
   - Executes `RegisterTokenInfo("abc")`
   - Sets `TokenInfos["abc"]` and `InsensitiveTokenExisting["ABC"] = true`

**Expected Result:** Transaction should fail with "Token already exists"

**Actual Result:** Transaction succeeds, creating duplicate case-insensitive token

**Verification:**
- `GetTokenInfo("ABC")` returns first token
- `GetTokenInfo("abc")` returns second token  
- Both exist simultaneously despite case-insensitive collision
- Protocol invariant violated

**Notes**

This is **NOT a race condition** as initially suggested in the security question. The issue stems from incomplete validation logic in `CrossChainCreateToken`, not from concurrent execution or atomic state update problems. AElf's parallel execution framework properly handles non-parallelizable transactions sequentially, preventing race conditions. The vulnerability is purely a missing validation check that allows bypassing the case-insensitive uniqueness constraint through the cross-chain creation path.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L480-488)
```csharp
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L232-233)
```csharp
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L66-68)
```csharp
            default:
                return new ResourceInfo { NonParallelizable = true };
        }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Application/LocalParallelTransactionExecutingService.cs (L102-117)
```csharp
    private async Task<List<ExecutionReturnSet>> ExecuteNonParallelizableTransactionsAsync(
        List<Transaction> transactions,
        BlockHeader blockHeader, BlockStateSet blockStateSet, CancellationToken cancellationToken)
    {
        var nonParallelizableReturnSets = await _planTransactionExecutingService.ExecuteAsync(
            new TransactionExecutingDto
            {
                Transactions = transactions,
                BlockHeader = blockHeader,
                PartialBlockStateSet = blockStateSet
            },
            cancellationToken);

        Logger.LogTrace("Merged results from non-parallelizables.");
        return nonParallelizableReturnSets;
    }
```
