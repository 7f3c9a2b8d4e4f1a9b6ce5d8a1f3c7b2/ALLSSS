### Title
Permanent DoS of NFT Cross-Chain Creation via Malformed Token Metadata

### Summary
The `CrossChainCreate()` function in NFTContract uses `bool.Parse()` on user-controllable metadata without validation, which throws `FormatException` if the `NftTokenIdReuseMetadataKey` value is not exactly "True" or "False". An attacker who obtains a seed NFT can bypass `NFTContract.Create()` and directly call `TokenContract.Create()` with malformed metadata, causing permanent denial-of-service for cross-chain NFT protocol registration on side chains for that symbol.

### Finding Description

**Vulnerable Code Location:** [1](#0-0) 

The `CrossChainCreate()` function retrieves token metadata and directly parses the boolean value without any validation or error handling. The function assumes tokens were created through the proper `NFTContract.Create()` flow which ensures valid metadata formatting.

**Root Cause:**
The vulnerability exists because:

1. **No Metadata Validation**: `CrossChainCreate()` does not validate that required metadata keys exist or contain valid boolean values before parsing. [2](#0-1) 

2. **Bypassable Token Creation**: On the main chain, `TokenContract.Create()` accepts arbitrary `ExternalInfo` without validating metadata values - it only requires a seed NFT or whitelist membership. [3](#0-2) 

3. **Metadata Propagation**: The cross-chain token creation flow (`CrossChainCreateToken`) preserves whatever metadata exists in the validated source token, including malformed values. [4](#0-3) 

4. **Missing Validation in ValidateTokenInfoExists**: This function only checks that the metadata matches between input and actual token - it does not validate metadata format or required keys. [5](#0-4) 

**Why Existing Protections Fail:**

While `NFTContract.Create()` properly formats metadata using `bool.ToString()`: [6](#0-5) 

This protection is insufficient because:
- Users can bypass `NFTContract.Create()` and call `TokenContract.Create()` directly
- On main chain, NFT collection creation only requires a seed NFT (which burns) or whitelist membership [7](#0-6) 

- The `AssertMetadataKeysAreCorrect()` validation only prevents users from overwriting reserved keys, but doesn't validate the VALUES of metadata [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- **Permanent Cross-Chain DoS**: Once a token with malformed metadata is created on the main chain and cross-chain validated to a side chain, `NFTContract.CrossChainCreate()` will permanently fail with `FormatException` for that symbol on the side chain.
- **Protocol-Level Denial**: The NFT protocol for that symbol can never be registered on the side chain, preventing all related NFT operations (mint, transfer, burn) for that collection on the side chain.
- **User Fund Lock**: Users expecting to use that NFT collection cross-chain are permanently blocked - any tokens held on the main chain cannot be properly utilized on side chains.
- **Ecosystem Disruption**: Legitimate NFT projects can be griefed by attackers who front-run their cross-chain deployment with malformed metadata using the same symbol.

**Affected Parties:**
- NFT project owners whose collections are blocked from side chain deployment
- Users holding NFTs from affected collections
- Side chain operators who must handle failed transactions
- DApp developers integrating with affected NFT collections

**Severity Justification:**
HIGH severity because:
- Impact: Permanent DoS of critical cross-chain functionality (operational impact)
- Scope: Affects entire NFT collection on all side chains
- Irreversibility: No recovery mechanism exists once malformed metadata is cross-chain validated
- Exploitability: Requires only a seed NFT (obtainable resource)

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Obtain a seed NFT for the target symbol (costs resources but publicly available through seed generation mechanisms)
2. Knowledge to call `TokenContract.Create()` directly instead of `NFTContract.Create()`
3. Craft malformed `ExternalInfo` with invalid boolean value or missing required key

**Attack Complexity:**
- **Low-to-Medium**: Attack requires understanding contract bypass but no special privileges
- No governance compromise needed
- No timing requirements or race conditions
- Single transaction on main chain enables attack

**Feasibility Conditions:**
- Seed NFTs must be available for the target symbol (generally true for new symbols)
- Attacker must act before legitimate NFT protocol creation
- Main chain must allow token creation (normal operating condition)

**Economic Rationality:**
- **Cost**: Price of seed NFT (varies, but economically rational for griefing competitors or blocking valuable symbols)
- **Gain**: Denial of competitor's cross-chain NFT deployment, potential ransom/extortion scenarios, or simply griefing
- **Detection**: Malformed metadata is visible on-chain but may not be noticed until cross-chain creation is attempted

**Probability Assessment:**
MEDIUM-to-HIGH likelihood because:
- Attack is technically straightforward once understood
- Economic incentive exists for competitive/griefing scenarios
- No monitoring exists to prevent malformed token creation
- Front-running opportunities exist during NFT launches

### Recommendation

**Immediate Fix - Add Defensive Parsing:**

Modify `CrossChainCreate()` to use `bool.TryParse()` with default fallback or explicit validation:

```csharp
// At line 87-88, replace with:
var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
var isTokenIdReuseStr = tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey];
Assert(!string.IsNullOrEmpty(isTokenIdReuseStr), 
    $"Token {input.Symbol} missing required metadata key: {NftTokenIdReuseMetadataKey}");
Assert(bool.TryParse(isTokenIdReuseStr, out var isTokenIdReuse), 
    $"Token {input.Symbol} has invalid boolean value for {NftTokenIdReuseMetadataKey}: {isTokenIdReuseStr}");
```

**Additional Protections:**

1. **Validate Required Metadata Keys**: Add validation in `CrossChainCreate()` to ensure all required NFT metadata keys exist before parsing.

2. **Metadata Format Validation in TokenContract**: Add validation in `TokenContract.Create()` when creating NFT collections to ensure metadata values match expected formats:
```csharp
// In CreateToken, for SymbolType.NftCollection:
if (input.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var reuseValue)) {
    Assert(bool.TryParse(reuseValue, out _), "Invalid boolean format for token ID reuse");
}
```

3. **Metadata Validation Helper**: Create a shared validation method that both `NFTContract.Create()` and `CrossChainCreate()` can use to verify NFT metadata format.

**Test Cases to Add:**
1. Test `CrossChainCreate()` with token missing `NftTokenIdReuseMetadataKey`
2. Test `CrossChainCreate()` with invalid boolean values ("invalid", "1", "yes", etc.)
3. Test token creation via `TokenContract.Create()` bypassing `NFTContract.Create()`
4. Test cross-chain flow with malformed metadata end-to-end
5. Test recovery scenarios after malformed metadata detection

### Proof of Concept

**Initial State:**
- Main chain and side chain are operational and indexed
- Cross-chain token contract addresses are registered
- Attacker has obtained seed NFT for symbol "EVIL"

**Attack Sequence:**

**Step 1 - Create Malformed Token on Main Chain:**
```
Attacker calls: TokenContract.Create({
    Symbol: "EVIL-0",
    TokenName: "Evil NFT Collection",
    TotalSupply: 10000,
    Decimals: 0,
    Issuer: AttackerAddress,
    IsBurnable: true,
    IssueChainId: MainChainId,
    ExternalInfo: {
        "aelf_nft_type": "Art",
        "aelf_nft_base_uri": "https://evil.com/nft/",
        "aelf_nft_token_id_reuse": "invalid"  // MALFORMED VALUE
    }
})
```
Expected: Transaction succeeds, seed NFT is burned, token "EVIL-0" created with malformed metadata

**Step 2 - Validate Token on Main Chain:**
```
Anyone calls: TokenContract.ValidateTokenInfoExists({
    Symbol: "EVIL-0",
    TokenName: "Evil NFT Collection",
    ExternalInfo: { /* includes malformed metadata */ }
})
```
Expected: Transaction succeeds (validation only checks metadata matches token, not format)

**Step 3 - Cross-Chain Token Creation on Side Chain:**
```
Anyone calls: TokenContract.CrossChainCreateToken({
    FromChainId: MainChainId,
    ParentChainHeight: <validation block height>,
    TransactionBytes: <ValidateTokenInfoExists transaction>,
    MerklePath: <proof>
})
```
Expected: Transaction succeeds, token "EVIL-0" created on side chain with malformed metadata

**Step 4 - Attempt NFT Protocol Registration:**
```
Anyone calls: NFTContract.CrossChainCreate({
    Symbol: "EVIL-0"
})
```
**Expected Result**: Transaction FAILS with `FormatException: String was not recognized as a valid Boolean.`

**Actual Result**: Same as expected - permanent DoS

**Success Condition:** 
All subsequent attempts to call `NFTContract.CrossChainCreate("EVIL-0")` on the side chain will permanently fail, preventing NFT protocol registration for that symbol on the side chain indefinitely.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-88)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-77)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }

        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L438-459)
```csharp
    public override Empty ValidateTokenInfoExists(ValidateTokenInfoExistsInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null) throw new AssertionException("Token validation failed.");

        var validationResult = tokenInfo.TokenName == input.TokenName &&
                               tokenInfo.IsBurnable == input.IsBurnable && tokenInfo.Decimals == input.Decimals &&
                               tokenInfo.Issuer == input.Issuer && tokenInfo.TotalSupply == input.TotalSupply &&
                               tokenInfo.IssueChainId == input.IssueChainId && tokenInfo.Owner == input.Owner;

        if (tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.Count > 0 ||
            input.ExternalInfo != null && input.ExternalInfo.Count > 0)
        {
            validationResult = validationResult && tokenInfo.ExternalInfo.Value.Count == input.ExternalInfo.Count;
            if (tokenInfo.ExternalInfo.Value.Any(keyPair =>
                    !input.ExternalInfo.ContainsKey(keyPair.Key) || input.ExternalInfo[keyPair.Key] != keyPair.Value))
                throw new AssertionException("Token validation failed.");
        }

        Assert(validationResult, "Token validation failed.");
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L492-503)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```
