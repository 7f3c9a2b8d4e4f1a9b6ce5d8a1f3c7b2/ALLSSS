# Audit Report

## Title
Retroactive Proposal Invalidation via Member Removal in Association Contract

## Summary
The Association contract contains a time-of-check/time-of-use vulnerability where member approvals validated at vote time are recounted at release time based on current membership. This allows organizations to retroactively invalidate legitimately approved proposals by removing members who voted in favor, undermining the integrity of the governance mechanism.

## Finding Description

The vulnerability exists in the temporal inconsistency between approval validation and approval counting across three critical operations:

**1. Vote-time validation:** When a member approves a proposal, the contract validates that the sender is a current organization member [1](#0-0)  by checking membership [2](#0-1) . The approval is then permanently stored [3](#0-2) .

**2. Release-time revalidation:** When releasing a proposal, the contract recounts approvals by filtering only those from current members [4](#0-3) . The Contains() method checks membership against the current state [5](#0-4) .

**3. Member removal:** The organization can remove members at any time through the RemoveMember function [6](#0-5) . The validation [7](#0-6)  only ensures thresholds remain theoretically achievable with the new member count, but does not check whether existing proposals would lose their valid approvals.

**Root cause:** The contract stores approval addresses permanently in the proposal state but evaluates them dynamically against the current membership list at release time. This creates a temporal inconsistency where a valid approval at time T1 becomes invalid at time T2 due to membership changes, even though the approval was legitimately obtained under the rules at the time of voting.

## Impact Explanation

**Critical Governance Impact:**
- Proposals that legitimately reached the required approval threshold can be prevented from execution
- Organizations can retroactively manipulate the outcome of proposals by strategically removing members who voted in favor
- This violates the fundamental governance invariant that validly approved proposals should be executable

**Affected Parties:**
- Honest organization members whose votes can be nullified after the fact
- Proposers who obtained legitimate approval but cannot execute their proposals  
- The entire governance system's integrity and trustworthiness

**Severity Justification:** This is a **Critical** vulnerability because it allows manipulation of already-approved governance decisions, undermining the entire purpose of the multi-signature governance mechanism. It enables a controlling faction to censor proposals retroactively even after they were legitimately approved according to the rules at the time of voting.

## Likelihood Explanation

**Attacker Capabilities:** The organization itself (through its virtual address, as enforced by Context.Sender check [8](#0-7) ) can call RemoveMember. This means a controlling faction can pass a proposal to remove members.

**Attack Complexity:** Low - the attack requires only:
1. Wait for a proposal to reach approval threshold
2. Create and approve a proposal to remove members who voted for the target proposal
3. Execute the member removal
4. The original proposal can no longer be released

**Feasibility Conditions:**
- Standard organization operations with no special privileges required
- No economic cost beyond normal transaction fees
- Can occur in the normal course of organization management

**Detection Constraints:** Difficult to distinguish from legitimate member management. The attack appears as normal organizational restructuring.

**Probability:** High - this can occur inadvertently during normal member management or deliberately for governance manipulation. The vulnerability is inherent in the design pattern used.

## Recommendation

Implement one of the following solutions:

**Option 1: Snapshot-based voting**
Store a snapshot of the organization membership at proposal creation time and validate approvals against this immutable snapshot instead of the current membership list.

**Option 2: Lock membership during active proposals**
Prevent member removal if it would cause any active (non-expired) proposal to lose its required approval threshold.

**Option 3: Approval threshold finalization**
Once a proposal reaches the approval threshold, mark it as "threshold met" and do not recount approvals at release time. Only verify the marker was set by a legitimate approval process.

The recommended approach is Option 1, as it provides the cleanest separation of concerns and prevents any retroactive manipulation while still allowing normal membership management.

## Proof of Concept

**Scenario:**
1. Organization has 10 members with MinimalApprovalThreshold = 6
2. Proposal A is created
3. Members 1, 2, 3, 4, 5, 6 approve Proposal A (6 approvals - meets threshold)
4. Organization creates and approves Proposal B to remove Members 1, 2, 3
5. Proposal B is released, removing 3 members (7 members remain)
6. Attempt to release Proposal A fails because only 3 current members (4, 5, 6) approved it
7. Proposal A cannot be executed despite legitimately reaching the threshold at approval time

**Code flow:**
- Approve() validates membership at vote time and stores approval
- RemoveMember() removes members without checking impact on pending proposals
- Release() recounts approvals using Count(organization.OrganizationMemberList.Contains), which filters out removed members
- Assertion "Not approved" fails even though proposal was legitimately approved

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L130-130)
```csharp
        proposal.Approvals.Add(Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L49-49)
```csharp
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L17-20)
```csharp
    public bool Contains(Address address)
    {
        return organizationMembers_.Contains(address);
    }
```
