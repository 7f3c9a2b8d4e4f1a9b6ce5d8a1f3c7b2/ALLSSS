# Audit Report

## Title
Missing Timing Validation Allows Any Miner to Trigger Premature Term Changes

## Summary
The AEDPoS consensus contract's `NextTerm()` method updates term and round numbers without enforcing the configured timing period (`periodSeconds`) or the two-thirds miner consensus requirement. While timing validation logic exists in `NeedToChangeTerm()`, it is only used during command generation and not during transaction validation, allowing any miner to prematurely trigger term changes by calling `NextTerm()` with sequentially incremented values. [1](#0-0) 

## Finding Description

The vulnerability exists in the separation between consensus command suggestion and transaction validation enforcement.

**Authorization Check - Insufficient:**
The `PreCheck()` method only verifies that the transaction sender is in the current or previous miner list, without validating timing requirements. [2](#0-1) 

**State Updates - Missing Timing Validation:**
The `ProcessNextTerm()` method directly updates term and round numbers using `TryToUpdateTermNumber()` and `TryToUpdateRoundNumber()`, which only validate sequential increments (current + 1). [3](#0-2) [4](#0-3) 

**Timing Validation Exists But Not Enforced:**
The `NeedToChangeTerm()` method correctly implements timing validation, checking if at least `MinersCountOfConsent` (two-thirds + 1 miners) have ActualMiningTimes meeting the period threshold. [5](#0-4) [6](#0-5) 

However, `NeedToChangeTerm()` is ONLY called during command generation to suggest behavior, not during validation. [7](#0-6) 

**Transaction Validation - Incomplete:**
The `ValidateBeforeExecution()` for NextTerm behavior only adds `RoundTerminateValidationProvider`, which validates sequential increments but NOT timing requirements. [8](#0-7) [9](#0-8) 

**Exploit Flow:**
1. Malicious miner constructs `NextTermInput` with `term_number = current + 1` and `round_number = current + 1`
2. Calls public `NextTerm()` method
3. Passes `PreCheck()` (is in miner list)
4. Passes validation (sequential increments correct)
5. `ProcessNextTerm()` executes, triggering:
   - Term/round number updates
   - New election winners retrieval
   - Miner list update
   - Treasury release
   - Election snapshot [10](#0-9) [11](#0-10) 

## Impact Explanation

**Governance Schedule Disruption (CRITICAL):**
Terms are designed to change at fixed intervals defined by `periodSeconds` (default 7 days = 604800 seconds). Premature term changes break the predictable governance model, undermining voter confidence and campaign planning.

**Economic Manipulation (HIGH):**
- Current miners lose block production rewards before their term naturally expires
- New miners gain rewards early based on current election standings
- A miner can trigger term changes strategically when favorable candidates have recent vote gains
- Reward redistribution occurs outside the intended schedule

**Election Integrity Violation (HIGH):**
Elections require specific timing windows for informed voter decisions and candidate campaigns. Arbitrary timing manipulation allows exploitation of temporary vote fluctuations, undermining democratic legitimacy.

**Consensus Integrity Breach (CRITICAL):**
The `MinersCountOfConsent` (two-thirds requirement) exists to ensure broad miner agreement before major state transitions. Bypassing this requirement allows contentious term changes without consensus, potentially leading to chain instability.

## Likelihood Explanation

**Attacker Capabilities: ANY MINER**
Any active miner in the current or previous round can execute this attack. No special privileges beyond normal block production rights are required.

**Attack Complexity: LOW**
The attacker simply calls `NextTerm()` with properly incremented term/round numbers. No complex contract interactions, timing precision, or special network conditions are needed.

**Feasibility Conditions: ALWAYS MET**
- Attacker must be in current/previous miner list (normal for active miners)
- Can execute during any time slot when miner can produce blocks
- No additional preconditions required

**Detection Difficulty: HIGH**
While the premature term change is visible on-chain, detection occurs after the fact. Once executed, the state transition is irreversible. Other nodes accept the block as valid since all validation checks pass.

**Economic Rationality: STRONG**
Multiple incentive structures favor exploitation:
- Miners can manipulate timing to benefit preferred candidates
- Miners can optimize their reward-earning periods
- Competitive election dynamics create strategic value in timing control

The combination of low technical barriers, high economic incentives, and difficulty in prevention makes exploitation highly probable.

## Recommendation

Add timing validation to the transaction validation phase by implementing a new validation provider or extending `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Existing term number check
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Add timing validation
    var blockchainStartTimestamp = State.BlockchainStartTimestamp.Value;
    var periodSeconds = State.PeriodSeconds.Value;
    if (!validationContext.BaseRound.NeedToChangeTerm(blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, periodSeconds))
    {
        return new ValidationResult { 
            Message = "Term change timing requirements not met. Two-thirds of miners must have mining times meeting the period threshold." 
        };
    }

    return new ValidationResult { Success = true };
}
```

This ensures the timing and consensus requirements are enforced during transaction validation, not just during command suggestion.

## Proof of Concept

```csharp
[Fact]
public async Task PrematureTermChange_ShouldNotBeAllowed_ButCurrentlySucceeds()
{
    // Setup: Initialize chain with term 1, round 1
    await InitializeConsensusContract();
    var currentRound = await GetCurrentRound();
    var currentTerm = await GetCurrentTermNumber();
    
    // Current term just started, periodSeconds (7 days) has not elapsed
    var blockchainAge = await GetBlockchainAge(); // e.g., 1 day = 86400 seconds
    var periodSeconds = await GetPeriodSeconds(); // 604800 seconds (7 days)
    
    Assert.True(blockchainAge < periodSeconds); // Confirm period not elapsed
    
    // Malicious miner constructs NextTermInput with incremented values
    var maliciousMiner = GetFirstMiner();
    var nextTermInput = new NextTermInput
    {
        TermNumber = currentTerm + 1,
        RoundNumber = currentRound.RoundNumber + 1,
        // ... other required fields with sequential increments
    };
    
    // VULNERABILITY: This should fail but currently succeeds
    var result = await maliciousMiner.NextTerm(nextTermInput);
    
    // Verify premature term change occurred
    var newTerm = await GetCurrentTermNumber();
    Assert.Equal(currentTerm + 1, newTerm); // Premature term change succeeded
    
    // Verify new miners were selected and treasury released prematurely
    var newMinerList = await GetCurrentMinerList();
    Assert.NotEqual(currentRound.RealTimeMinersInformation.Keys, newMinerList.Pubkeys);
}
```

## Notes

This vulnerability represents a fundamental mismatch between design intent and implementation. The timing validation logic (`NeedToChangeTerm()`) demonstrates clear design intent for controlled term transitions, but this logic was only integrated into the command suggestion layer rather than the enforcement layer. The separation between "what miners should do" (command generation) and "what miners are allowed to do" (validation) creates an exploitable gap that any miner can leverage for governance manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L98-105)
```csharp
    private bool TryToUpdateTermNumber(long termNumber)
    {
        var oldTermNumber = State.CurrentTermNumber.Value;
        if (termNumber != 1 && oldTermNumber + 1 != termNumber) return false;

        State.CurrentTermNumber.Value = termNumber;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```
