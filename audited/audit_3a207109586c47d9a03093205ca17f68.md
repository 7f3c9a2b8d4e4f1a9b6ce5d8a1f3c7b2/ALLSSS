# Audit Report

## Title
Period Desynchronization Between TokenHolder and Profit Contracts Causes DOS in RegisterForProfits

## Summary
The TokenHolder contract maintains a local `Period` counter that becomes desynchronized from ProfitContract's `CurrentPeriod` when managers call `ProfitContract.DistributeProfits` directly. This causes `RegisterForProfits` with auto-distribute to revert with "Invalid period" errors, creating a DOS condition for new user registrations.

## Finding Description

The vulnerability stems from improper period synchronization between TokenHolder and Profit contracts.

**Root Cause:**

TokenHolder's `RegisterForProfits` method retrieves the scheme without period synchronization: [1](#0-0) 

This calls `GetValidScheme` with the default `updateSchemePeriod = false` parameter: [2](#0-1) 

When `updateSchemePeriod` is false and `SchemeId` is already set, `UpdateTokenHolderProfitScheme` returns early without syncing the period from ProfitContract: [3](#0-2) 

Meanwhile, ProfitContract explicitly allows scheme managers to call `DistributeProfits` directly: [4](#0-3) 

When called directly, ProfitContract increments its `CurrentPeriod`: [5](#0-4) 

**Attack Flow:**

1. Manager creates TokenHolder scheme with auto-distribute threshold
2. Manager calls `ProfitContract.DistributeProfits` directly, advancing ProfitContract's period
3. User calls `TokenHolder.RegisterForProfits` when auto-distribute threshold is met
4. Auto-distribute logic uses the stale period from TokenHolder: [6](#0-5) 
5. ProfitContract validates the period and fails: [7](#0-6) 
6. Transaction reverts with "Invalid period" error

**Additional Bug:**

The synchronization logic also contains a storage bug where it saves to `Context.Sender` instead of the `manager` parameter: [8](#0-7) 

This can save period updates to incorrect addresses, further compounding synchronization issues.

## Impact Explanation

**Severity: HIGH**

This vulnerability causes complete DOS of the `RegisterForProfits` function when auto-distribute thresholds are configured:

- **Core Functionality Broken**: Users cannot stake tokens and register for profit schemes, which is the primary purpose of TokenHolder contract
- **Permanent DOS**: Once desynchronized, every `RegisterForProfits` call with auto-distribute will fail until manually recovered
- **Economic Impact**: New participants cannot join profit schemes, breaking the token holder dividend mechanism
- **User Experience**: Failed transactions with cryptic "Invalid period" errors cause confusion

While the manager can recover by calling `TokenHolder.DistributeProfits` (which uses `updateSchemePeriod = true`), this requires manual intervention and may not be known to managers.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability has high probability of occurrence:

- **Accidental Trigger**: Can happen unintentionally if managers use both TokenHolder and ProfitContract interfaces
- **No Cost**: Only requires normal transaction fees to trigger
- **Public Methods**: Both entry points are publicly accessible with documented APIs
- **Common Configuration**: Auto-distribute thresholds are a standard feature
- **Repeatable**: Manager can continuously trigger desync by calling ProfitContract directly
- **No Detection**: Desynchronization is invisible until users attempt registration

The attack requires no special privileges beyond being a scheme manager (legitimate role), and can occur through normal contract usage patterns.

## Recommendation

**Fix 1: Force Period Synchronization in RegisterForProfits**

Change `GetValidScheme` call to always sync period:
```csharp
var scheme = GetValidScheme(input.SchemeManager, true); // Force sync
```

**Fix 2: Fix Storage Bug**

In `UpdateTokenHolderProfitScheme`, save to correct address:
```csharp
State.TokenHolderProfitSchemes[manager] = scheme; // Use manager parameter, not Context.Sender
```

**Fix 3: Prevent Direct ProfitContract Calls (Optional)**

Consider restricting `ProfitContract.DistributeProfits` to only accept calls from TokenHolderContract for TokenHolder-managed schemes, or add events to track period changes for monitoring.

## Proof of Concept

```csharp
[Fact]
public async Task PeriodDesync_DOS_RegisterForProfits_Test()
{
    // 1. Manager creates TokenHolder scheme with auto-distribute threshold
    var manager = TokenHolderContractStubs[0];
    await manager.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1,
        AutoDistributeThreshold = { { "ELF", 100 } }
    });
    
    var managerAddress = Address.FromPublicKey(SampleAccount.Accounts[0].KeyPair.PublicKey);
    var schemeId = (await ProfitContractStub.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = managerAddress })).SchemeIds.First();
    
    // 2. First operation to initialize SchemeId in TokenHolder (sync period)
    await manager.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = SampleAccount.Accounts[1].Address,
        Shares = 1
    });
    
    // Verify TokenHolder Period = 1 (synced)
    var tokenHolderScheme = await manager.GetScheme.CallAsync(managerAddress);
    tokenHolderScheme.Period.ShouldBe(1);
    
    // 3. Manager calls ProfitContract.DistributeProfits directly, causing desync
    await ProfitContractStub.DistributeProfits.SendAsync(new Profit.DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // ProfitContract Period = 2, but TokenHolder Period = 1 (desynchronized)
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    profitScheme.CurrentPeriod.ShouldBe(2);
    tokenHolderScheme.Period.ShouldBe(1); // Still 1!
    
    // 4. Fund scheme to meet auto-distribute threshold
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = profitScheme.VirtualAddress,
        Symbol = "ELF",
        Amount = 200
    });
    
    // 5. User attempts RegisterForProfits - should fail with "Invalid period"
    var user = TokenHolderContractStubs[2];
    var result = await user.RegisterForProfits.SendWithExceptionAsync(new RegisterForProfitsInput
    {
        SchemeManager = managerAddress,
        Amount = 100
    });
    
    // Verify DOS: Transaction fails due to period mismatch
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Invalid period");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L152-152)
```csharp
        var scheme = GetValidScheme(input.SchemeManager);
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L193-197)
```csharp
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-278)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L289-289)
```csharp
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L298-298)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L478-480)
```csharp
        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```
