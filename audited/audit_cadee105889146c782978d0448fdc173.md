### Title
Missing Input Validation for Shares in TokenHolderContract.AddBeneficiary Allows Zero or Negative Shares Leading to Profit Loss

### Summary
The `AddBeneficiary` function in TokenHolderContract does not validate that `input.Shares` is positive before processing. This allows scheme managers to add beneficiaries with zero shares or use negative shares to zero out existing beneficiary allocations, which can result in profit distribution failures and burned funds when all beneficiaries end up with zero shares.

### Finding Description

The root cause is at line 45 in `TokenHolderContract.AddBeneficiary`, where `input.Shares` is assigned without any validation. [1](#0-0) 

The input type `AddTokenHolderBeneficiaryInput` uses `int64` for shares, allowing negative values: [2](#0-1) 

When an existing beneficiary is updated (lines 46-56), the function removes the old entry and adds back the accumulated shares without validation: [3](#0-2) 

The accumulated shares are then sent to `ProfitContract.AddBeneficiary`, which only validates `Shares >= 0`, explicitly allowing zero: [4](#0-3) 

The zero shares are added to `TotalShares`: [5](#0-4) 

During profit distribution, if `totalShares <= 0`, all profits are burned instead of distributed: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact**: This vulnerability causes permanent loss of funds through two mechanisms:

1. **Profit Burning**: When all beneficiaries have zero shares (totalShares = 0), the `DistributeProfits` function burns all contributed profits instead of distributing them. For example, if 10,000 ELF tokens are contributed but all beneficiaries have been zeroed out, these tokens are permanently burned.

2. **Lost Profit Entitlement**: Beneficiaries who had legitimate share allocations can have their shares reduced to zero, either intentionally or accidentally, causing them to lose their rightful profit distributions.

**Affected Parties**: 
- Beneficiaries who lose profit entitlement when their shares are set to zero
- All profit contributors whose funds get burned when totalShares reaches zero
- The scheme's economic integrity is compromised

**Severity Justification**: Medium severity because while it requires manager action (not arbitrary attacker access), it can cause permanent fund loss through unintentional mistakes and violates the fundamental invariant of accurate profit distribution accounting.

### Likelihood Explanation

**Attacker Capabilities**: The scheme manager (a trusted but not infallible role) can call `AddBeneficiary`. This is not about a compromised manager, but rather inadequate input validation that allows operational mistakes.

**Attack Complexity**: Low - requires a single transaction with zero or negative shares value.

**Feasibility Conditions**: 
- Manager calls `AddBeneficiary(beneficiaryAddress, 0)` directly - adds beneficiary with zero shares
- Manager calls `AddBeneficiary(beneficiaryAddress, -X)` where X equals existing shares - zeros out the beneficiary's allocation
- If the last remaining beneficiary is zeroed out, all future profits get burned

**Probability**: Medium-High for accidental occurrence:
- Off-by-one errors in calculations
- Mistaken negative values during share adjustments
- Integration bugs in frontend/middleware passing incorrect values
- No defense-in-depth to catch these mistakes

### Recommendation

**Code-Level Mitigation**: Add input validation at line 45 in TokenHolderContract.AddBeneficiary:

```csharp
var shares = input.Shares;
Assert(shares > 0, "Shares must be positive.");
```

This should be added immediately after line 45, before any processing occurs.

**Invariant Checks**: 
1. Add validation: `Assert(input.Shares > 0, "Shares must be positive.")` in TokenHolderContract.AddBeneficiary
2. Consider adding similar validation in ProfitContract.AddBeneficiary to change from `>= 0` to `> 0` for defense-in-depth
3. Add validation before DistributeProfits to prevent execution when totalShares = 0

**Test Cases**:
1. Test that AddBeneficiary with shares = 0 is rejected
2. Test that AddBeneficiary with shares = -100 is rejected  
3. Test that adding negative shares to zero out existing shares is prevented
4. Test that the error message clearly indicates positive shares are required

### Proof of Concept

**Initial State**:
- TokenHolder scheme exists with manager = ManagerAddress
- Beneficiary Alice registered with 100 shares from previous `RegisterForProfits` call
- TotalShares = 100
- 10,000 ELF contributed to the scheme

**Attack Steps**:

1. Manager calls `TokenHolderContract.AddBeneficiary`:
   - Input: `{ Beneficiary: Alice, Shares: -100 }`
   
2. Execution flow:
   - Line 45: `shares = -100`
   - Line 46-56: Alice's existing 100 shares are detected and removed (TotalShares = 0)
   - Line 55: `shares.Add(100)` results in 0
   - Line 58-66: ProfitContract.AddBeneficiary called with shares = 0
   - ProfitContract validation passes (0 >= 0)
   - Alice now has 0 shares, TotalShares = 0

3. Manager calls `TokenHolderContract.DistributeProfits`:
   - Line 462 in ProfitContract: totalShares = 0
   - Line 485-486: Condition `totalShares <= 0` is true
   - All 10,000 ELF profits are burned instead of distributed to Alice

**Expected Result**: Transaction should fail with "Shares must be positive" error

**Actual Result**: Transaction succeeds, Alice's 100 shares become 0, and all profits are burned on next distribution

**Success Condition**: 10,000 ELF permanently lost, Alice receives no profits despite being the legitimate beneficiary

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L45-45)
```csharp
        var shares = input.Shares;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L46-56)
```csharp
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }
```

**File:** protobuf/token_holder_contract.proto (L72-77)
```text
message AddTokenHolderBeneficiaryInput {
    // Beneficiary's address.
    aelf.Address beneficiary = 1;
    // The weight of the beneficiary's dividends in the scheme.
    int64 shares = 2;
}
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```
