### Title
Mining Order Collision via Unchecked TuneOrderInformation Allows Time Slot Conflicts and Consensus Disruption

### Summary
Malicious miners can inject colliding `FinalOrderOfNextRound` values through the `TuneOrderInformation` field in `UpdateValueInput`, bypassing collision resolution logic. This causes multiple miners to be assigned identical time slots in subsequent rounds, enabling miners to skip turns or mine out-of-order, potentially stalling consensus.

### Finding Description

The vulnerability exists in the consensus round update flow where order collision validation is missing.

**Root Cause Location:** [1](#0-0) 

The `ProcessUpdateValue` method directly applies `TuneOrderInformation` from attacker-controlled input without validating uniqueness of `FinalOrderOfNextRound` values.

**Missing Validation:** [2](#0-1) 

For `UpdateValue` behavior, only `UpdateValueValidationProvider` and `LibInformationValidationProvider` are applied - neither validates order collision. [3](#0-2) 

The `UpdateValueValidationProvider` only checks that OutValue/Signature are filled and validates PreviousInValue, but performs no order collision checks.

**Why Legitimate Collision Resolution is Bypassed:**

Normal flow uses collision resolution: [4](#0-3) 

However, a malicious miner can bypass this by crafting `TuneOrderInformation` directly with colliding values, which are applied without re-validation.

**Exploitation Path:**

1. Malicious miner crafts consensus extra data containing `UpdateValueInput` with colliding orders in `TuneOrderInformation` (e.g., MinerA→1, MinerB→1)
2. Validation executes but finds no order collision checks for UpdateValue behavior
3. `ProcessUpdateValue` applies the malicious values to stored state
4. When next round is generated, multiple miners receive identical `Order` values: [5](#0-4) 

5. Colliding miners compute identical `ExpectedMiningTime`, causing time slot conflicts

### Impact Explanation

**Consensus Integrity Violation:**
- Multiple miners assigned to mine at the exact same time slot
- Time slot validation becomes ambiguous - both miners believe they have authority
- Creates race conditions where one miner's valid block may be rejected as "out of turn"

**Operational Impact:**
- Consensus rounds can stall when miners with colliding orders both attempt to mine
- Network may fail to progress if critical miners are assigned duplicate slots
- Manipulation of mining order allows attackers to skip their legitimate time slots while claiming others' slots

**Severity Justification:**
This is HIGH severity because:
- Directly compromises the core consensus mechanism invariant (unique time slot assignment)
- Can cause consensus halt affecting entire blockchain operation
- Exploitable by any miner with modified node software
- No on-chain recovery mechanism once colliding orders are stored

### Likelihood Explanation

**Attacker Capabilities:**
- Requires miner status (active block producer)
- Requires modified node software to craft malicious `UpdateValueInput`
- No additional permissions or governance compromise needed

**Attack Complexity:**
- Straightforward: craft `TuneOrderInformation` map with duplicate order values
- No complex cryptographic operations or timing requirements
- Single malicious block can inject colliding orders affecting subsequent rounds

**Feasibility Conditions:**
- Attacker must be in active miner set
- No special network conditions required
- Attack persists until next term transition (could affect multiple rounds)

**Detection Constraints:**
- Malicious input appears structurally valid (passes current validation)
- Collision only manifests when next round is generated
- No automated detection or rejection mechanism exists

**Probability Assessment:**
HIGH likelihood - all preconditions are realistic and attack is technically simple to execute once miner status is achieved.

### Recommendation

**1. Add Order Collision Validation for UpdateValue Behavior:**

In `AEDPoSContract_Validation.cs`, add validation for UpdateValue:
```csharp
case AElfConsensusBehaviour.UpdateValue:
    validationProviders.Add(new UpdateValueValidationProvider());
    validationProviders.Add(new OrderCollisionValidationProvider()); // NEW
    validationProviders.Add(new LibInformationValidationProvider());
    break;
```

**2. Implement OrderCollisionValidationProvider:**

Create new validator that checks:
- All `FinalOrderOfNextRound` values in providedRound are unique
- No value appears more than once across all miners who have mined
- Validate that values are within valid range [1, minerCount]

**3. Add Defensive Check in ProcessUpdateValue:**

Before applying TuneOrderInformation: [1](#0-0) 

Add validation:
```csharp
// Validate no collisions in tune order information
var proposedOrders = new HashSet<int>();
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(proposedOrders.Add(tuneOrder.Value), 
        $"Collision detected: order {tuneOrder.Value} assigned to multiple miners");
}

// Check against orders already assigned in current round
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    var existingMinersWithOrder = currentRound.RealTimeMinersInformation.Values
        .Count(m => m.FinalOrderOfNextRound == tuneOrder.Value && 
                    m.Pubkey != tuneOrder.Key);
    Assert(existingMinersWithOrder == 0, 
        $"Order {tuneOrder.Value} already assigned to another miner");
}
```

**4. Test Cases:**

Add regression tests covering:
- Attempt to submit UpdateValue with duplicate orders in TuneOrderInformation
- Verify validation rejection with clear error message
- Test boundary cases (all miners assigned same order, wrap-around values)
- Ensure legitimate order adjustments still function correctly

### Proof of Concept

**Initial State:**
- 5 active miners in current round (MinerA, MinerB, MinerC, MinerD, MinerE)
- MinerA has mined with legitimately calculated orders for self and others

**Attack Sequence:**

1. **Craft Malicious UpdateValueInput:**
   - MinerB modifies node software to create custom `UpdateValueInput`
   - Sets `tune_order_information = {"MinerC": 1, "MinerD": 1, "MinerE": 1}`
   - All three miners now have colliding `FinalOrderOfNextRound = 1`

2. **Submit Malicious Block:**
   - MinerB produces block with malicious consensus extra data
   - Block passes `ValidateBeforeExecution` (no order collision check exists)
   - Block passes `ValidateAfterExecution` (hash comparison ineffective)

3. **State Corruption via ProcessUpdateValue:** [1](#0-0) 
   - TuneOrderInformation applied: MinerC, MinerD, MinerE all assigned `FinalOrderOfNextRound = 1`
   - Updated round persisted to state via `TryToUpdateRoundInformation`

4. **Consensus Disruption in Next Round:** [5](#0-4) 
   - `GenerateNextRoundInformation` orders miners by `FinalOrderOfNextRound`
   - MinerC, MinerD, MinerE all assigned `Order = 1`
   - All three compute identical `ExpectedMiningTime`
   - Time slot conflict: three miners believe they should mine simultaneously

**Expected Result:**
Transaction should be rejected with "Order collision detected" error.

**Actual Result:**
Transaction succeeds, colliding orders stored, subsequent round has three miners with identical time slots causing consensus ambiguity and potential stall.

**Success Condition:**
Observe in next round that `RealTimeMinersInformation` contains multiple miners with `Order = 1` and identical `ExpectedMiningTime` values, violating the consensus invariant of unique time slot assignment.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-44)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
