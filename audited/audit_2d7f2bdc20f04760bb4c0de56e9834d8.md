### Title
Missing Validation in CreateScheme() Allows Zero or Negative MinimumLockMinutes, Enabling Immediate Token Withdrawals

### Summary
The `CreateScheme()` function in TokenHolderContract accepts `MinimumLockMinutes` without any validation, allowing scheme managers to set it to zero or negative values. This completely bypasses the locking mechanism's time-based withdrawal protection, enabling users to withdraw locked tokens immediately after registration, breaking the core invariant that tokens must be locked for a minimum period.

### Finding Description

**Root Cause:**

The `CreateScheme()` function directly assigns the user-provided `MinimumLockMinutes` value to the scheme state without any bounds checking: [1](#0-0) 

The `MinimumLockMinutes` field is defined as `int64` type in the protobuf schema, which is a signed integer that can accept negative values, zero, or positive values: [2](#0-1) 

**Why Protections Fail:**

The withdrawal check at line 227 uses `MinimumLockMinutes` in a time comparison: [3](#0-2) 

When `MinimumLockMinutes = 0`:
- `LockTimestamp.AddMinutes(0)` returns `LockTimestamp`
- The check becomes: `LockTimestamp < CurrentBlockTime`
- This passes as soon as any time has elapsed (even 1 second)

When `MinimumLockMinutes < 0`:
- `LockTimestamp.AddMinutes(-X)` subtracts X minutes from the lock timestamp
- The check becomes trivial to pass, potentially even in the same block

**Real-World Exploitation Path:**

1. **Protocol Misconfiguration Scenario:** The AEDPoS consensus contract for side chains calculates `MinimumLockMinutes` using integer division: [4](#0-3) 

If `periodSeconds < 60` (e.g., 30 seconds for test/development chains), the division `periodSeconds.Div(60)` results in 0, creating a side chain dividend pool with no lock period.

2. **Default Behavior:** Existing tests demonstrate that schemes can be created with default `MinimumLockMinutes = 0`, and immediate withdrawals work: [5](#0-4) 

The test creates a scheme without specifying `MinimumLockMinutes` (defaulting to 0), registers for profits, and immediately withdraws successfully without any time delay.

### Impact Explanation

**Direct Fund Impact:**
Users can exploit schemes with zero or negative `MinimumLockMinutes` to game profit distribution systems:
- Register for profits just before distribution periods
- Claim accumulated profits
- Immediately withdraw tokens without maintaining any lock commitment
- This dilutes rewards meant for long-term token holders who maintain their locks

**Protocol Integrity Impact:**
- Breaks the fundamental security invariant stated in documentation: "Minimum lock time for holding token"
- System contracts (AEDPoS side chain) are vulnerable to creating schemes with `MinimumLockMinutes = 0` due to integer division when `periodSeconds < 60`
- Defeats the purpose of token locking mechanisms intended to ensure user commitment and alignment

**Affected Parties:**
- Legitimate long-term token holders whose profit shares are diluted
- Protocol-level dividend pools (side chain dividends) with misconfigured lock periods
- Any dApp or governance system relying on TokenHolder locking for commitment mechanisms

**Severity Justification:**
HIGH severity because:
1. Completely bypasses core locking mechanism security
2. Affects protocol-level contracts (AEDPoS)
3. Enables unfair profit extraction from legitimate participants
4. No validation prevents the vulnerability

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call `CreateScheme()` to create their own scheme with `MinimumLockMinutes = 0` or negative
- No special privileges required
- Scheme manager has complete control over this parameter

**Attack Complexity:**
- Trivial: Simply call `CreateScheme()` with `MinimumLockMinutes = 0`
- For existing protocol schemes, exploitation requires only registering for profits and immediate withdrawal

**Feasibility Conditions:**
- Entry point is public and unrestricted
- No preconditions beyond having tokens to lock
- Integer division in AEDPoS creates vulnerable schemes automatically when `periodSeconds < 60`
- Default protobuf behavior sets unspecified int64 fields to 0

**Detection/Operational Constraints:**
- Difficult to detect as it appears as normal scheme creation
- Users can query schemes before registering, but may not understand security implications
- Test environments and development chains likely vulnerable due to short period settings

**Probability:**
HIGH - The vulnerability is:
- Already present in existing tests (default behavior)
- Automatically triggered in AEDPoS for chains with `periodSeconds < 60`
- Trivial to exploit intentionally
- Economically rational (free to exploit, gains unfair profit share)

### Recommendation

**Code-Level Mitigation:**

Add validation in `CreateScheme()` to enforce a minimum positive value for `MinimumLockMinutes`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(input.MinimumLockMinutes > 0, "Minimum lock minutes must be greater than zero.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    // ... rest of function
}
```

**Invariant Checks:**
- Validate `MinimumLockMinutes > 0` at scheme creation
- Consider enforcing a minimum threshold (e.g., `MinimumLockMinutes >= 60` for at least 1 hour)
- Add validation in AEDPoS to ensure `periodSeconds >= 60` before division, or use ceiling division

**Test Cases:**
1. Test that `CreateScheme()` reverts when `MinimumLockMinutes = 0`
2. Test that `CreateScheme()` reverts when `MinimumLockMinutes < 0`
3. Test that withdrawal fails if attempted before minimum lock period expires
4. Test AEDPoS initialization with small `periodSeconds` values to ensure proper handling

### Proof of Concept

**Initial State:**
- User has 1000 ELF tokens
- No existing TokenHolder schemes

**Exploitation Steps:**

1. **Create Vulnerable Scheme:**
   ```
   Call: CreateScheme({
       Symbol: "ELF",
       MinimumLockMinutes: 0,  // or -100
       AutoDistributeThreshold: {}
   })
   ```
   Result: Scheme created with zero lock period

2. **Register for Profits:**
   ```
   Call: RegisterForProfits({
       SchemeManager: <scheme_creator_address>,
       Amount: 1000
   })
   ```
   Result: 1000 ELF tokens locked, user added as beneficiary

3. **Contribute Profits to Scheme:**
   ```
   Call: ContributeProfits({
       SchemeManager: <scheme_creator_address>,
       Symbol: "ELF",
       Amount: 10000
   })
   ```
   Result: 10000 ELF available for distribution

4. **Distribute and Claim Profits:**
   ```
   Call: DistributeProfits({SchemeManager: <address>})
   Call: ClaimProfits({SchemeManager: <address>})
   ```
   Result: User receives proportional share of 10000 ELF

5. **Immediate Withdrawal (Vulnerability):**
   ```
   Call: Withdraw(<scheme_creator_address>)
   ```
   Expected: Should fail due to minimum lock period not elapsed
   **Actual: Succeeds immediately** - user withdraws 1000 ELF with no time delay

**Success Condition:**
User successfully registers, claims profits, and withdraws locked tokens in rapid succession without maintaining any minimum lock commitment, demonstrating complete bypass of the locking mechanism.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** protobuf/token_holder_contract.proto (L66-67)
```text
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L28-32)
```csharp
        State.TokenHolderContract.CreateScheme.Send(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = AEDPoSContractConstants.SideChainShareProfitsTokenSymbol,
            MinimumLockMinutes = periodSeconds.Div(60)
        });
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L434-459)
```csharp
    public async Task Withdraw_Test()
    {
        var amount = 1000L;
        var nativeTokenSymbol = TokenHolderContractTestConstants.NativeTokenSymbol;
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = nativeTokenSymbol
        });
        await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
        {
            Amount = amount,
            SchemeManager = Starter
        });
        var beforeUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        await TokenHolderContractStub.Withdraw.SendAsync(Starter);
        var afterUnLockBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Symbol = nativeTokenSymbol,
            Owner = Starter
        })).Balance;
        afterUnLockBalance.ShouldBe(beforeUnLockBalance.Add(amount));
    }
```
