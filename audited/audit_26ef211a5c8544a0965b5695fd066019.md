### Title
Conflict Resolution Fails When Current Miner's Old Order is Not Considered Available, Causing Duplicate Mining Order Assignments

### Summary
The `ApplyNormalConsensusData` function's conflict resolution logic fails to consider that the current miner is vacating their old order when searching for available reassignment slots. When all N mining orders are occupied and a miner's new order conflicts with an existing miner, the conflict resolution cannot find an available order (because the current miner's old order still appears occupied), resulting in duplicate `FinalOrderOfNextRound` assignments. This leads to two miners assigned the same mining slot in the next round, causing consensus disruption.

### Finding Description

The vulnerability exists in the conflict resolution logic at [1](#0-0) 

**Root Cause:**

When a miner produces a block, their signature determines a `supposedOrderOfNextRound` value [2](#0-1) . If another miner already has this order as their `FinalOrderOfNextRound`, the code identifies them as conflicts and attempts to reassign them [3](#0-2) .

The reassignment logic checks if a candidate order is available using: `RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder)` [4](#0-3) . This check examines the **current state** of all miners' orders before any updates are applied.

The critical flaw: when all N orders (1 to N) are occupied and miner A (currently at order Y) wants to move to order X (where miner B is), the logic tries to find a new order for B. However, order Y still appears occupied by A in the current state, even though A is about to vacate it when assigned to order X at [5](#0-4) . This causes the loop to fail to find any available order for B.

When the loop completes without finding an available order (no `break` executed at line 38), B's `FinalOrderOfNextRound` remains unchanged at X. Then A is also assigned to X, creating a duplicate.

**Why Existing Protections Fail:**

The validation in `UpdateValueValidationProvider` only checks that OutValue and Signature are filled correctly [6](#0-5)  and does not validate for duplicate orders.

The `NextRoundMiningOrderValidationProvider` attempts validation using `.Distinct()` on `MinerInRound` objects [7](#0-6) , but this checks object distinctness (all miners are distinct objects), not whether their `FinalOrderOfNextRound` values are unique.

**Execution Path:**

1. Block generation: `GetConsensusExtraDataToPublishOutValue` calls `ApplyNormalConsensusData` [8](#0-7) 
2. The conflict resolution creates duplicate orders in the returned Round
3. `ExtractInformationToUpdateConsensus` includes the duplicate in `TuneOrderInformation` [9](#0-8) 
4. Block execution: `ProcessUpdateValue` applies the duplicate orders to state [10](#0-9) 
5. State persisted via `TryToUpdateRoundInformation` [11](#0-10) 
6. Next round generation: `GenerateNextRoundInformation` assigns both miners the same Order [12](#0-11) 

### Impact Explanation

**Consensus Integrity Violation:**

When duplicate `FinalOrderOfNextRound` values persist, `GenerateNextRoundInformation` processes miners ordered by this field [13](#0-12) . Both miners with the duplicate order get assigned the same `Order` value in the next round, meaning they have the same `ExpectedMiningTime` (line 33). This creates:

1. **Mining Slot Collision**: Two miners are scheduled to produce blocks at the same time, violating the fundamental AEDPoS invariant that each miner has a unique time slot
2. **Empty Time Slot**: The current miner's old order is left unassigned to any miner
3. **Consensus Disruption**: Multiple miners attempting to produce blocks simultaneously leads to conflicts, potential forks, or chain halts

**Affected Parties:**
- All network participants experience consensus disruption
- Validators face uncertain block production schedules
- Chain may fail to progress if mining conflicts cannot be resolved

**Severity Justification:**
This is HIGH severity because it directly violates consensus protocol integrity, affecting the core mechanism that ensures orderly block production. Unlike issues requiring attacker resources, this can occur naturally during normal operation, making it a systemic weakness in the consensus algorithm.

### Likelihood Explanation

**Realistic Triggering Conditions:**

1. **Normal Operational State**: All N miners have produced blocks in the current round (all orders 1-N are occupied) - this is the expected steady-state
2. **Hash Collision**: A miner's signature hash modulo N produces a value that conflicts with another miner's current order - mathematically inevitable given limited order space
3. **No Attack Required**: This occurs through normal mining operations without any malicious behavior

**Feasibility:**

- **Entry Point**: Reachable through normal block production via `UpdateValue` method [14](#0-13) 
- **Preconditions**: Simply requires active mining by all validators (normal operation)
- **Complexity**: No special setup or malicious actions needed
- **Detection**: Difficult to detect before impact, as validation does not catch the duplicate assignments

**Probability:**

With N miners and signature-based order calculation using `GetAbsModulus(signature.ToInt64(), minersCount) + 1` [15](#0-14) , hash collisions occur regularly. When combined with all orders being occupied (normal state), the bug triggers whenever a miner's new calculated order conflicts with an existing assignment.

**Likelihood: HIGH** - Occurs in normal operation without requiring adversarial behavior.

### Recommendation

**Immediate Fix:**

Modify the conflict resolution logic to exclude the current miner's old order from the "occupied" check:

```csharp
// At line 28-40, before the loop, capture current miner's old order
var currentMinerOldOrder = RealTimeMinersInformation[pubkey].FinalOrderOfNextRound;

foreach (var orderConflictedMiner in conflicts)
    for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
    {
        var maybeNewOrder = i > minersCount ? i % minersCount : i;
        // Modified check: consider an order available if it's either:
        // 1. Not currently assigned to any miner, OR
        // 2. Assigned to the current miner (who is vacating it)
        if (RealTimeMinersInformation.Values.All(m => 
            m.FinalOrderOfNextRound != maybeNewOrder || m.Pubkey == pubkey))
        {
            RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound = maybeNewOrder;
            break;
        }
    }
```

**Additional Validation:**

Add explicit duplicate check in validation provider:

```csharp
// In UpdateValueValidationProvider or new validator
var finalOrders = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
    
if (finalOrders.Count != finalOrders.Distinct().Count())
{
    return new ValidationResult { Message = "Duplicate FinalOrderOfNextRound detected." };
}
```

**Test Cases:**

1. Test with N miners all having orders 1-N, then miner at order 1 produces block with signature resulting in order 2
2. Verify conflicted miner gets reassigned to order 1 (the vacated slot)
3. Verify no duplicate orders in resulting state
4. Test edge cases with different miner counts and conflict patterns

### Proof of Concept

**Initial State:**
- 3 miners: Alice (Order=1), Bob (Order=2), Charlie (Order=3)
- All miners have produced blocks (SupposedOrderOfNextRound != 0)
- All orders 1, 2, 3 are occupied

**Attack Steps:**

1. Alice produces a new block with signature S where `GetAbsModulus(S.ToInt64(), 3) + 1 = 2`
2. `ApplyNormalConsensusData("Alice", ..., S)` is called
3. `supposedOrderOfNextRound = 2` (conflicts with Bob)
4. `conflicts = [Bob]` (Bob has FinalOrderOfNextRound == 2)
5. Conflict resolution loop attempts to reassign Bob:
   - Check order 3: Charlie has it → skip
   - Check order 4 % 3 = 1: Alice still has order 1 → skip (BUG: Alice is moving!)
   - Check order 5 % 3 = 2: Bob has it → skip
   - Loop ends without reassigning Bob
6. Bob remains at FinalOrderOfNextRound = 2
7. Alice assigned to FinalOrderOfNextRound = 2
8. Block is processed, state updated via `TryToUpdateRoundInformation`

**Expected Result:** Alice=2, Bob=1, Charlie=3 (Bob reassigned to Alice's vacated slot)

**Actual Result:** Alice=2, Bob=2, Charlie=3 (DUPLICATE ORDER)

**Impact Verification:**

When `GenerateNextRoundInformation` is called for next round:
- Both Alice and Bob are assigned Order=2 in next round
- Both have identical ExpectedMiningTime
- Order 1 is empty (no miner assigned)
- Consensus disruption: two miners compete for same slot

**Success Condition:** State inspection shows `RealTimeMinersInformation["Alice"].FinalOrderOfNextRound == RealTimeMinersInformation["Bob"].FinalOrderOfNextRound == 2`

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-26)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L44-44)
```csharp
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L45-47)
```csharp
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L247-260)
```csharp
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
