# Audit Report

## Title
Association Proposal Validation Allows Zero Address Leading to Permanent Proposal Failure

## Summary
The Association contract's proposal validation only checks for null addresses but does not validate against zero addresses (32 bytes of 0x00). A proposal with a zero address can pass validation and be approved, but will permanently fail during release because the inline transaction to a non-existent contract address causes the parent transaction to roll back, preventing the proposal removal from persisting in state.

## Finding Description

The validation function in the Association contract performs insufficient address validation. [1](#0-0) 

This validation only checks if `ToAddress` is null, but in AElf's type system, an Address is a protobuf-generated class that wraps a ByteString value. [2](#0-1) 

A zero address created via `Address.FromBytes(new byte[32])` produces a valid non-null Address object that passes the null check but points to no actual contract.

When such a proposal is released, the contract creates an inline transaction to the zero address: [3](#0-2) 

During inline transaction execution, the system attempts to retrieve the contract executive for the target address. When no contract exists at the address, a `SmartContractFindRegistrationException` is caught and the transaction trace is marked with `ExecutionStatus.ContractError`. [4](#0-3) 

In AElf's transaction execution model, a transaction is only considered successful if all its inline transactions succeed. [5](#0-4) 

When a transaction fails due to unsuccessful inline transactions, only pre-transaction and post-transaction plugin state changes are persisted; the main transaction's state changes are rolled back. [6](#0-5) 

This behavior is confirmed by test cases demonstrating that failed inline transactions result in zero state changes. [7](#0-6) 

As a result, the proposal removal statement never persists, leaving the proposal stuck in an approved but unreleasable state until expiration, at which point it can be cleared via the `ClearProposal` function. [8](#0-7) 

## Impact Explanation

**Operational Impact - Medium Severity:**

This vulnerability enables a governance denial-of-service attack with the following consequences:

1. **Stuck Proposals**: Approved proposals with zero addresses cannot be released and occupy state storage until expiration
2. **Gas Wastage**: Each Release attempt by the proposer consumes gas with guaranteed failure
3. **Organization DoS**: Multiple such proposals can clog an organization's proposal queue, especially if multiple proposers are compromised
4. **Resource Lock**: Proposal IDs and state entries remain locked until manual cleanup after expiration

The severity is Medium rather than High because:
- Only whitelisted proposers can create proposals (requires trust or account compromise)
- No direct fund theft or unauthorized state changes occur
- Proposals eventually expire and can be cleared through the public `ClearProposal` function
- The attack is detectable (zero address visible in proposal details)

## Likelihood Explanation

**Likelihood: Medium**

The likelihood is assessed as Medium based on:

**Attacker Requirements:**
- Must have proposer whitelist membership (trusted role or compromised account)
- Can construct proposals with arbitrary addresses

**Attack Complexity: Low**
- Creating a zero address is trivial: `Address.FromBytes(new byte[32])`
- No special knowledge or complex setup required
- Single transaction to create malicious proposal

**Feasibility:**
- Realistic for disgruntled insiders with proposer access
- Viable if proposer accounts are compromised
- Requires social engineering or legitimate-looking proposal content to get approval

**Economic Rationality:**
- Low cost to attacker (only CreateProposal gas)
- High cost to organization (repeated Release attempts, governance disruption)
- Rational for organizational sabotage scenarios

**Detection Constraints:**
- Zero address is visible in proposal details but may not be immediately recognized as invalid
- Could be disguised with legitimate-looking method names and parameters

## Recommendation

Add explicit validation to check if the `ToAddress` is a zero address in the `Validate(ProposalInfo)` function:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;
    
    // Add zero address check
    if (proposal.ToAddress.Value.All(b => b == 0))
        return false;

    return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
}
```

This validation should also be applied to Parliament and Referendum contracts which likely have the same vulnerability pattern.

## Proof of Concept

```csharp
[Fact]
public async Task ZeroAddressProposal_ShouldFailRelease()
{
    // Setup: Create organization with proposer
    var proposer = SampleAccount.Accounts[0].Address;
    var organization = await CreateOrganization(proposer);
    
    // Attack: Create proposal with zero address
    var zeroAddress = Address.FromBytes(new byte[32]);
    var proposalId = await CreateProposal(organization, zeroAddress, "TestMethod");
    
    // Approve the proposal
    await ApproveProposal(proposalId);
    
    // Attempt to release - should fail
    var releaseResult = await ReleaseProposal(proposalId);
    
    // Verify: Transaction failed but proposal still exists
    releaseResult.Status.ShouldBe(TransactionResultStatus.Failed);
    var proposal = await GetProposal(proposalId);
    proposal.ShouldNotBeNull(); // Proposal still in state
    
    // Verify: Release attempts continue to fail
    var secondRelease = await ReleaseProposal(proposalId);
    secondRelease.Status.ShouldBe(TransactionResultStatus.Failed);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** src/AElf.Types/Types/Address.cs (L49-58)
```csharp
        public static Address FromBytes(byte[] bytes)
        {
            if (bytes.Length != AElfConstants.AddressHashLength)
                throw new ArgumentException("Invalid bytes.", nameof(bytes));

            return new Address
            {
                Value = ByteString.CopyFrom(bytes)
            };
        }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L105-126)
```csharp
    private static bool TryUpdateStateCache(TransactionTrace trace, TieredStateCache groupStateCache)
    {
        if (trace == null)
            return false;

        if (!trace.IsSuccessful())
        {
            var transactionExecutingStateSets = new List<TransactionExecutingStateSet>();

            AddToTransactionStateSets(transactionExecutingStateSets, trace.PreTraces);
            AddToTransactionStateSets(transactionExecutingStateSets, trace.PostTraces);

            groupStateCache.Update(transactionExecutingStateSets);
            trace.SurfaceUpError();
        }
        else
        {
            groupStateCache.Update(trace.GetStateSets());
        }

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/PlainTransactionExecutingService.cs (L152-161)
```csharp
            executive = await _smartContractExecutiveService.GetExecutiveAsync(
                internalChainContext,
                singleTxExecutingDto.Transaction.To);
        }
        catch (SmartContractFindRegistrationException)
        {
            txContext.Trace.ExecutionStatus = ExecutionStatus.ContractError;
            txContext.Trace.Error += "Invalid contract address.\n";
            return trace;
        }
```

**File:** src/AElf.Kernel.Core/Extensions/TransactionTraceExtensions.cs (L8-19)
```csharp
    public static bool IsSuccessful(this TransactionTrace txTrace)
    {
        if (txTrace.ExecutionStatus != ExecutionStatus.Executed) return false;

        if (txTrace.PreTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.InlineTraces.Any(trace => !trace.IsSuccessful())) return false;

        if (txTrace.PostTraces.Any(trace => !trace.IsSuccessful())) return false;

        return true;
    }
```

**File:** test/AElf.Parallel.Tests/DeleteDataFromStateDbTest.cs (L2127-2135)
```csharp
        var transactionResult = await GetTransactionResultAsync(transaction.GetHash(), block.Header);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);

        value = await GetValueAsync(accountAddress, key, block.GetHash(), block.Height);
        CheckValueNotExisted(value);

        var blockStateSet = await _blockStateSetManger.GetBlockStateSetAsync(block.GetHash());
        blockStateSet.Changes.Count.ShouldBe(0);
        blockStateSet.Deletes.Count.ShouldBe(0);
```
