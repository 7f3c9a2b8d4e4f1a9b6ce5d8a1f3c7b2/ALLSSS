### Title
Authorization Chain Bypass via Malicious Contract Address in MethodFeeController

### Summary
The `ChangeMethodFeeController` method in Parliament (and all ACS1 implementations) does not validate that the `ContractAddress` field in `AuthorityInfo` points to a legitimate governance contract. An attacker can provide a malicious contract address that implements `ValidateOrganizationExist` to always return true, bypassing governance controls and gaining direct authority to set method fees without future organizational approval.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method which validates the new `AuthorityInfo` by calling `CheckOrganizationExist`: [1](#0-0) 

The `CheckOrganizationExist` method makes a cross-contract call to the provided `ContractAddress` without validating it is a system governance contract: [2](#0-1) 

**Root Cause**: The code blindly trusts any contract address provided in `authorityInfo.ContractAddress` and calls its `ValidateOrganizationExist` method. There is no validation that this address corresponds to Parliament, Association, or Referendum governance contracts.

**Why Existing Protections Fail**: While the system has `GetSystemContractNameToAddressMapping()` available to validate system contracts (as used in other contexts): [3](#0-2) 

This validation is NOT applied to the `ContractAddress` in `ChangeMethodFeeController`. The `ValidateOrganizationExist` interface is defined in ACS3: [4](#0-3) 

But any deployed contract can implement this interface and return arbitrary values.

**Execution Path**:
1. Attacker deploys malicious contract implementing `ValidateOrganizationExist` that returns `BoolValue { Value = true }` for any input
2. Attacker creates Parliament proposal to call `ChangeMethodFeeController` with `AuthorityInfo { ContractAddress = malicious_contract, OwnerAddress = attacker_address }`
3. Proposal gets approved through normal governance
4. Validation passes because malicious contract returns true
5. `State.MethodFeeController.Value` now points to attacker's address
6. Attacker can directly call `SetMethodFee` bypassing all future governance since the check is: [5](#0-4) 

This pattern affects ALL ACS1 implementations identically: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Authorization Chain Violation**: The vulnerability breaks the fundamental invariant that method fee changes must go through governance. Once the malicious controller is set, the attacker gains permanent direct control over method fees.

**Concrete Harms**:
1. **Fee Manipulation**: Attacker can set arbitrary fees for any contract method:
   - Set fees to 0 → Enable transaction spam/DoS
   - Set fees extremely high → Economic griefing of users
   - Discriminatory fee setting to favor/harm specific operations

2. **Governance Bypass**: All future `SetMethodFee` operations bypass organizational approval, breaking the governance model permanently until another governance proposal can reclaim control.

3. **System-Wide Impact**: This affects ALL 15+ system contracts implementing ACS1 (Parliament, Association, Referendum, Token, Consensus, Treasury, Profit, TokenConverter, etc.)

**Affected Parties**: All blockchain users and the protocol's governance integrity. Method fees control transaction costs and network resource usage.

**Severity Justification**: Medium severity because while the impact is high (complete governance bypass for fee control), it requires initial Parliament approval to inject the malicious controller. However, once compromised, the attacker has permanent control without further governance oversight.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Deploy a malicious contract with simple `ValidateOrganizationExist` implementation
2. Create and get approved a Parliament proposal (requires proposer whitelist access or BP status)
3. Standard transaction execution capability

**Attack Complexity**: LOW once proposal is approved. The malicious contract implementation is trivial:
```csharp
public BoolValue ValidateOrganizationExist(Address input) {
    return new BoolValue { Value = true };
}
```

**Feasibility Conditions**: 
- Attacker needs to convince governance to approve the controller change, which is the main barrier
- However, the `AuthorityInfo` structure looks legitimate on the surface (has both ContractAddress and OwnerAddress filled)
- No existing validation would flag this as suspicious during proposal review

**Detection/Operational Constraints**: 
- The malicious controller persists indefinitely
- No automatic detection mechanism exists
- Recovery requires another governance proposal to change controller back

**Probability Reasoning**: MEDIUM likelihood. While getting initial proposal approval is non-trivial, the attack is:
- Technically simple to execute
- Difficult to detect during proposal review
- Provides permanent backdoor value to attacker
- Could be embedded in seemingly legitimate governance restructuring proposals

### Recommendation

**Immediate Fix**: Add validation to `ChangeMethodFeeController` (and all ACS1 implementations) that `input.ContractAddress` must be one of the three legitimate governance contracts:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // ADD THIS VALIDATION:
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    Assert(
        input.ContractAddress == systemContracts[SmartContractConstants.ParliamentContractSystemHashName] ||
        input.ContractAddress == systemContracts[SmartContractConstants.AssociationContractSystemHashName] ||
        input.ContractAddress == systemContracts[SmartContractConstants.ReferendumContractSystemHashName],
        "Contract address must be a valid governance contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Apply To All Contracts**: Update the same validation in ALL ACS1 implementations across the codebase (15+ contracts).

**Test Cases**:
1. Test `ChangeMethodFeeController` with non-governance contract address → should fail
2. Test `ChangeMethodFeeController` with each valid governance contract → should succeed
3. Test that malicious contract implementing `ValidateOrganizationExist` is rejected
4. Verify existing legitimate controller changes still work

### Proof of Concept

**Initial State**:
- Parliament contract initialized with default organization
- MethodFeeController pointing to Parliament's default organization

**Attack Steps**:

1. **Deploy Malicious Contract**:
```csharp
public class MaliciousController : ContractBase {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Parliament Proposal** to call `Parliament.ChangeMethodFeeController` with:
```
AuthorityInfo {
    ContractAddress = <MaliciousController address>,
    OwnerAddress = <Attacker's address>
}
```

3. **Get Proposal Approved** through normal BP voting

4. **Release Proposal** → `ChangeMethodFeeController` executes:
   - `CheckOrganizationExist` calls `MaliciousController.ValidateOrganizationExist(attacker_address)`
   - Returns true (validation passes)
   - `State.MethodFeeController.Value` = malicious AuthorityInfo

5. **Exploit**: Attacker directly calls `Parliament.SetMethodFee` with arbitrary fees:
   - Check passes: `Context.Sender == State.MethodFeeController.Value.OwnerAddress` (attacker's address)
   - No governance approval needed
   - Fees set to attacker's desired values

**Expected vs Actual Result**:
- **Expected**: Controller change should fail because ContractAddress is not a governance contract
- **Actual**: Controller change succeeds, attacker gains permanent control over method fees

**Success Condition**: After step 5, attacker can repeatedly call `SetMethodFee` without any governance approval, permanently bypassing the authorization chain.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L15-15)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L41-42)
```csharp
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** protobuf/acs3.proto (L67-70)
```text
    // Check the existence of an organization.
    rpc ValidateOrganizationExist(aelf.Address) returns (google.protobuf.BoolValue){
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```
