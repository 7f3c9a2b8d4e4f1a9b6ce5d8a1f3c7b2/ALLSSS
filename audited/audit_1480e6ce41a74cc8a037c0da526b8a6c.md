# Audit Report

## Title
Proposer Whitelist Bypass - Removed Proposers Can Execute Approved Proposals

## Summary
The `Release` method in Association, Parliament, and Referendum contracts only validates that the caller is the original proposer without re-checking if the proposer is still in the organization's whitelist. This allows proposers who have been removed from the whitelist to retain execution authority for previously approved proposals, completely bypassing the whitelist authorization mechanism.

## Finding Description

The vulnerability exists in the authorization logic across all three governance contracts. When a proposal is created, the system validates that the proposer is in the whitelist by calling `AssertIsAuthorizedProposer`: [1](#0-0) 

This validation checks if the proposer is in the organization's `ProposerWhiteList`: [2](#0-1) 

However, when releasing an approved proposal, the authorization check is insufficient. The `Release` method only verifies that the caller is the original proposer: [3](#0-2) 

The critical issue is that the `Release` method only checks `Context.Sender == proposalInfo.Proposer` without re-validating whether the proposer is still in the current whitelist. Meanwhile, organizations can update their proposer whitelist at any time through `ChangeOrganizationProposerWhiteList`: [4](#0-3) 

This creates a critical authorization gap: once a proposer creates and gets approval for a proposal, they retain the ability to execute it even after being explicitly removed from the whitelist. The same vulnerability pattern exists in Parliament and Referendum contracts: [5](#0-4) [6](#0-5) 

## Impact Explanation

**Authorization Bypass - HIGH Severity**: Organizations use the proposer whitelist as a critical security control to manage who can interact with their governance. Removing a proposer from the whitelist via `ChangeOrganizationProposerWhiteList` is an explicit revocation of trust and authority. However, this control is completely ineffective for existing proposals - removed proposers retain full execution rights.

**Real-World Harm Scenarios**:

1. **Compromised Account**: When a legitimate proposer's account is compromised, the organization removes them from the whitelist immediately. However, the attacker can still execute any approved proposals using `Context.SendVirtualInlineBySystemContract`, potentially draining funds or changing critical configurations.

2. **Malicious Proposer Discovery**: If a proposer's malicious intent is discovered after their proposal was approved (through social engineering, parameter obfuscation, or deceptive descriptions), removing them from the whitelist does not prevent execution.

3. **Changed Circumstances**: A previously-approved proposal becomes harmful due to changed conditions. The organization removes the proposer to prevent new harm, but cannot stop execution of the old proposal.

**Concrete Damage**: Approved proposals can execute arbitrary contract methods on behalf of the organization, including fund transfers, contract upgrades, permission changes, and other privileged operations. Organizations have no mechanism to revoke release rights for approved but not-yet-expired proposals.

## Likelihood Explanation

**HIGH Likelihood**: The exploit requires no special technical capabilities:

**Attacker Requirements**:
- Must initially be in the proposer whitelist (normal operational state)
- Must create a proposal that gets approved by organization members
- No special exploits or economic resources required

**Attack Complexity - LOW**:
1. Create proposal while whitelisted
2. Wait for member approval (normal operation)
3. After being removed from whitelist, call `Release` method
4. The method executes because it only checks original proposer identity

**Feasibility**: The scenarios triggering this (account compromise, discovered malicious intent, organizational changes) are realistic operational events that organizations must handle. The attack window extends from approval until expiration (typically days), with no race conditions needed. Organizations cannot defend against this - `ClearProposal` only works after expiration. [7](#0-6) 

## Recommendation

Add a whitelist re-validation check in the `Release` method before executing the proposal. The fix should call `AssertIsAuthorizedProposer` to ensure the proposer is still authorized:

```csharp
public override Empty Release(Hash input)
{
    var proposalInfo = GetValidProposal(input);
    Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
    
    // ADD THIS LINE: Re-validate proposer is still in whitelist
    AssertIsAuthorizedProposer(proposalInfo.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposalInfo.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
    Context.SendVirtualInlineBySystemContract(
        CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), 
        proposalInfo.ToAddress,
        proposalInfo.ContractMethodName, 
        proposalInfo.Params);
    // ... rest of method
}
```

Apply this fix to all three contracts: Association, Parliament, and Referendum.

## Proof of Concept

```csharp
[Fact]
public async Task ProposerWhitelistBypass_RemovedProposerCanStillRelease()
{
    // Setup: Create organization with Reviewer1 as proposer
    var organizationAddress = await CreateOrganizationAsync(
        new ProposerWhiteList { Proposers = { Reviewer1 } },
        new OrganizationMemberList { OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3 } }
    );
    
    // Step 1: Reviewer1 creates a proposal (whitelisted at creation time)
    var proposalId = await CreateProposalAsync(Reviewer1Stub, organizationAddress);
    
    // Step 2: Get approval from members
    await ApproveProposalAsync(proposalId, Reviewer1Stub, Reviewer2Stub);
    
    // Step 3: Organization removes Reviewer1 from whitelist (security measure)
    var changeWhitelistProposal = await CreateAndApproveWhitelistChangeProposal(
        organizationAddress, 
        new ProposerWhiteList { Proposers = { Reviewer2 } } // Reviewer1 removed
    );
    await ReleaseWhitelistChangeProposal(changeWhitelistProposal);
    
    // Verify Reviewer1 is no longer in whitelist
    var canPropose = await AssociationContractStub.ValidateProposerInWhiteList.CallAsync(
        new ValidateProposerInWhiteListInput 
        { 
            OrganizationAddress = organizationAddress, 
            Proposer = Reviewer1 
        }
    );
    canPropose.Value.ShouldBeFalse(); // Reviewer1 removed from whitelist
    
    // Step 4: VULNERABILITY - Reviewer1 can still release the approved proposal
    var releaseResult = await Reviewer1Stub.Release.SendAsync(proposalId);
    
    // Expected: Should fail with "Unauthorized to propose" or similar
    // Actual: Transaction succeeds - removed proposer can still execute!
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

This test demonstrates that after being removed from the whitelist, a proposer can still release previously approved proposals, bypassing the whitelist authorization mechanism entirely.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-111)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
