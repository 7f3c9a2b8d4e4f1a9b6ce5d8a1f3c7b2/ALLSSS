### Title
Missing Miner List Validation During Term Transitions Allows Consensus Takeover

### Summary
The `NextTerm` function accepts arbitrary miner lists in the `NextTermInput` without validating them against the Election Contract's official elected miner list. A malicious current miner can produce a block with a `NextTerm` transaction containing any miner list they choose, completely taking over network consensus by excluding legitimate miners and including only themselves and accomplices.

### Finding Description

**Root Cause:**
The validation system for `NextTerm` consensus behavior does not verify that the provided miner list matches the Election Contract's `GetVictories` result.

**Code Locations:**

1. **Entry Point**: `NextTerm` public method calls `ProcessConsensusInformation` [1](#0-0) 

2. **Validation**: Only `RoundTerminateValidationProvider` is added for `NextTerm` behavior [2](#0-1) 

3. **Insufficient Validation**: Checks only term number increment, NOT miner list content [3](#0-2) 

4. **Vulnerable State Modification**: Directly uses input's miner list without verification [4](#0-3) 

5. **No Conversion Validation**: `ToRound()` performs no integrity checks [5](#0-4) 

**Why Protections Fail:**

The legitimate flow generates miner lists via `GenerateFirstRoundOfNextTerm` which calls `TryToGetVictories` to fetch elected miners: [6](#0-5) 

However, validation providers never compare the provided `NextTermInput.RealTimeMinersInformation` against this authoritative source. The blockchain's consensus validation at block level calls `ValidateConsensusBeforeExecution`: [7](#0-6) 

But this validation path never checks miner list integrity for term transitions.

### Impact Explanation

**Consensus Takeover:**
- Attacker gains complete control over block production by setting themselves as the only miner(s)
- Legitimate elected miners are excluded from the network
- Attacker maintains perpetual control by continuing to exclude others in subsequent terms

**Governance Capture:**
- Control over block production means control over all governance actions
- Attacker can pass any proposal, change any parameter, control treasury

**Network Integrity:**
- Breaks fundamental DPoS election mechanism
- Invalidates all election voting and staking
- Undermines trust in the entire blockchain

**Affected Parties:**
- All legitimate miners lose block production rights and rewards
- Token holders' votes become meaningless
- Entire network users affected by governance capture

**Severity Justification:** CRITICAL - Complete network takeover with total control over consensus, governance, and economic policy.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a current miner (to pass `PreCheck` authorization)
- Must control their miner node to produce custom consensus data
- Must wait for a term transition period

**Attack Complexity:** LOW
- Single malicious miner sufficient
- No coordination needed
- No special cryptographic attacks required
- Standard block production mechanism

**Feasibility Conditions:**
- Attack window: Every term transition (periodic, predictable)
- No economic cost beyond normal block production
- Detection: Only after block execution when too late to prevent

**Execution Steps:**
1. Malicious miner M waits for their time slot during term transition
2. M crafts consensus extra data with `AElfConsensusBehaviour.NextTerm` and a `Round` containing only desired miners in `RealTimeMinersInformation`
3. M produces block with this consensus data
4. Network validates via `ValidateConsensusBeforeExecution` - passes (no miner list check)
5. `ProcessNextTerm` executes, extracting miner list and calling `SetMinerList`
6. Malicious miner list becomes official
7. Only attackers can produce subsequent blocks

**Detection Constraints:**
- Pre-execution validation doesn't catch it
- Post-execution validation compares state against itself (already modified)
- Network accepts the block as valid

**Probability:** HIGH for any network with even a single compromised miner during a term transition window.

### Recommendation

**Code-Level Mitigation:**

Add a new validation provider `MinerListValidationProvider` for `NextTerm` behavior:

```csharp
public class MinerListValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        
        // Only validate for NextTerm
        if (extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        // Get official elected miner list from Election Contract
        var officialVictories = State.ElectionContract.GetVictories.Call(new Empty());
        var officialMiners = new HashSet<string>(
            officialVictories.Value.Select(pk => pk.ToHex()));
        
        // Get provided miner list from consensus data
        var providedMiners = new HashSet<string>(
            extraData.Round.RealTimeMinersInformation.Keys);
        
        // Verify exact match (same miners, same count)
        if (!officialMiners.SetEquals(providedMiners))
        {
            validationResult.Message = 
                $"Miner list mismatch. Expected: {string.Join(",", officialMiners)}, " +
                $"Provided: {string.Join(",", providedMiners)}";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Register this provider in `ValidateBeforeExecution`: [2](#0-1) 

Modify to:
```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new MinerListValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

**Invariant Checks:**
- MUST verify `NextTermInput.RealTimeMinersInformation.Keys` exactly matches `ElectionContract.GetVictories()`
- MUST validate before any state modification in `ProcessNextTerm`
- MUST reject blocks with mismatched miner lists in pre-execution validation

**Test Cases:**
1. Test that `NextTerm` with correct election results passes validation
2. Test that `NextTerm` with extra miners fails validation
3. Test that `NextTerm` with missing miners fails validation
4. Test that `NextTerm` with completely different miners fails validation
5. Test term transition with multiple consecutive malicious attempts

### Proof of Concept

**Initial State:**
- Current term has 5 legitimate miners: M1, M2, M3, M4, M5
- Election Contract's `GetVictories()` returns elected miners: E1, E2, E3, E4, E5 for next term
- M1 is malicious and about to produce a block during term transition

**Attack Sequence:**

**Step 1:** M1's turn to produce block at term transition
- M1 crafts consensus header information with `Behaviour = NextTerm`
- M1 creates malicious `Round` with only `RealTimeMinersInformation = {M1, M1-Accomplice1, M1-Accomplice2}`
- M1 produces block with this consensus data

**Step 2:** Network validation (ValidateConsensusBeforeExecution)
- `MiningPermissionValidationProvider`: Checks M1 is in current miner list ✓ (M1 is current miner)
- `RoundTerminateValidationProvider`: Checks round number = current + 1 ✓, term number = current + 1 ✓, InValue null ✓
- **MISSING**: No check that {M1, M1-Accomplice1, M1-Accomplice2} matches {E1, E2, E3, E4, E5}
- Validation passes ✓

**Step 3:** Block execution (ProcessNextTerm)
- Line 163: `nextRound = input.ToRound()` extracts malicious round
- Lines 188-190: Creates `MinerList` from `nextRound.RealTimeMinersInformation.Keys` = {M1, M1-Accomplice1, M1-Accomplice2}
- Calls `SetMinerList(miners, nextRound.TermNumber)` - stores malicious list as official

**Step 4:** Post-execution validation (ValidateConsensusAfterExecution)
- Compares header round hash with state round hash - they match (already stored)
- Validation passes ✓

**Expected Result:**
Network rejects block due to miner list mismatch with Election Contract

**Actual Result:**
Block accepted, `State.MinerListMap[new term]` = {M1, M1-Accomplice1, M1-Accomplice2}, legitimate elected miners E1-E5 excluded

**Success Condition:**
After the attack, query `GetCurrentMinerList()` returns {M1, M1-Accomplice1, M1-Accomplice2} instead of {E1, E2, E3, E4, E5}, and only these three addresses can produce subsequent blocks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-242)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```
