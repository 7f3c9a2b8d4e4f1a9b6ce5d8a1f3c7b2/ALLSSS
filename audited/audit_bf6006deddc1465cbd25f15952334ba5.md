### Title
Approved Proposals Become Unexecutable After Expiration, Causing Governance Failure

### Summary
The Referendum contract's `Release` method validates proposal expiration at execution time rather than at approval time, allowing approved proposals to become permanently unexecutable if they expire before release. This creates a governance deadlock where democratically approved actions cannot be executed, and provides a griefing vector where attackers can delay release transactions to force proposal expiration.

### Finding Description

The vulnerability exists in the proposal lifecycle between approval and execution. The `CreateNewProposal` function validates proposals at creation time, including an expiration check: [1](#0-0) 

The validation logic checks that `Context.CurrentBlockTime < proposal.ExpiredTime`: [2](#0-1) 

However, when `Release` is called to execute an approved proposal, it calls `GetValidProposal` which re-validates the expiration: [3](#0-2) [4](#0-3) 

**Root Cause:** The expiration validation at line 108 of `Validate(ProposalInfo proposal)` is re-executed during `Release`, causing the assertion to fail if time has passed and the proposal expired after approval but before release.

**Why Protections Fail:** While voters can approve/reject/abstain on proposals, and the `IsReleaseThresholdReached` check confirms approval, there is no mechanism to release an expired proposal even if it was legitimately approved while valid. The expiration check blocks execution unconditionally.

**Execution Path:**
1. Proposer creates proposal with ExpiredTime = T (passes validation)
2. Voters approve proposal and it reaches threshold (e.g., via `Approve` at line 70-83)
3. CurrentBlockTime advances past T (proposal expires)
4. Proposer calls `Release` → calls `GetValidProposal` → `Validate` fails → assertion "Invalid proposal"
5. Approved governance action is permanently blocked

### Impact Explanation

**Governance Failure:** Legitimately approved proposals cannot execute their intended governance actions, directly violating the critical invariant that "proposal lifetime/expiration" must be correctly managed. The democratic will of token holders is nullified.

**Economic Waste:** Voters lock tokens during voting (via `LockToken` mechanism at lines 39-72 of Referendum_Helper.cs) for proposals that ultimately cannot execute. While tokens can be reclaimed after expiration, the voting effort is wasted. [5](#0-4) 

**Affected Parties:** 
- All voters who locked tokens for the proposal
- The organization relying on the governance action
- The protocol's governance integrity

**Severity Justification:** HIGH - This breaks the fundamental governance mechanism, allowing approved proposals to become permanently unexecutable. The existing test suite acknowledges this behavior as expected, but does not test the problematic scenario where an approved proposal expires before release: [6](#0-5) 

### Likelihood Explanation

**Reachable Entry Point:** Any user can create proposals (if whitelisted), vote on them, and call `Release`. All are public methods with normal access controls.

**Feasible Preconditions:**
- Proposal must be created with an expiration time
- Proposal must reach approval threshold
- Time must pass such that CurrentBlockTime >= ExpiredTime before Release is called

**Execution Practicality:** 
- **Natural Occurrence:** Proposer may be offline, busy, or unaware proposal is ready for release
- **Attack Scenario:** Attacker can spam network or DoS proposer's transactions to delay Release past expiration
- **Timing Window:** Common proposal lifetimes (days to weeks) provide ample opportunity for natural delays

**Economic Rationality:** Attack requires only network congestion or transaction spam during the final hours before expiration—minimal cost compared to blocking governance actions worth potentially millions in locked value.

**Detection/Constraints:** The system has no warning mechanism when proposals approach expiration, and no grace period for approved proposals.

### Recommendation

**Code-Level Mitigation:**

1. **Option A - Grace Period:** Modify `Validate(ProposalInfo proposal)` to allow a grace period after expiration for approved proposals:

```csharp
private bool Validate(ProposalInfo proposal)
{
    var validDestinationAddress = proposal.ToAddress != null;
    var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
    var hasOrganizationAddress = proposal.OrganizationAddress != null;
    var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    
    // Allow expired proposals if already approved (check in Release only)
    var validExpiredTime = proposal.ExpiredTime != null && 
                          (Context.CurrentBlockTime < proposal.ExpiredTime || 
                           IsApprovedProposal(proposal));
    
    return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
           hasOrganizationAddress && validDescriptionUrl;
}

private bool IsApprovedProposal(ProposalInfo proposal)
{
    var organization = State.Organizations[proposal.OrganizationAddress];
    return organization != null && IsReleaseThresholdReached(proposal, organization);
}
```

2. **Option B - Separate Release Validation:** Create a separate validation method for Release that skips expiration check if proposal is approved:

```csharp
public override Empty Release(Hash input)
{
    var proposal = State.Proposals[input];
    Assert(proposal != null, "Invalid proposal id.");
    Assert(ValidateForRelease(proposal), "Invalid proposal.");
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    // ... rest of release logic
}

private bool ValidateForRelease(ProposalInfo proposal)
{
    // Same validations except expiration if approved
    var basicValidation = proposal.ToAddress != null && 
                         !string.IsNullOrWhiteSpace(proposal.ContractMethodName) &&
                         proposal.OrganizationAddress != null &&
                         ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
    return basicValidation;
}
```

**Invariant Checks to Add:**
- Track approval timestamp when threshold is reached
- Enforce maximum delay between approval and release (e.g., 7 days)
- Emit event when proposal is approved to alert proposer

**Test Cases to Prevent Regression:**
1. Create proposal with 5-day expiration
2. Approve proposal on day 3 (reaches threshold)
3. Advance time to day 7 (expired)
4. Call Release - should succeed (currently fails)
5. Verify proposal execution and token reclaim

### Proof of Concept

**Initial State:**
- Organization created with token symbol "ELF"
- MinimalApprovalThreshold = 5000, MinimalVoteThreshold = 5000
- Proposer is whitelisted
- Multiple voters with sufficient token allowances

**Transaction Steps:**

1. **T=0**: Proposer creates proposal with ExpiredTime = CurrentBlockTime + 7 days
   - Result: Proposal created successfully, validation passes

2. **T=3 days**: Voters approve the proposal
   - Multiple voters call `Approve`, locking 5000+ tokens total
   - Result: `IsReleaseThresholdReached` returns true, proposal is approved

3. **T=8 days**: Block time advances past expiration (CurrentBlockTime >= ExpiredTime)
   - Result: Proposal state unchanged, still approved but now expired

4. **T=8 days**: Proposer calls `Release(proposalId)`
   - `Release` calls `GetValidProposal(input)` (line 165)
   - `GetValidProposal` calls `Validate(proposal)` (line 128)
   - `Validate` checks: `Context.CurrentBlockTime < proposal.ExpiredTime` (line 108)
   - Check fails: CurrentBlockTime (8 days) >= ExpiredTime (7 days)
   - Assert fails: "Invalid proposal"

**Expected vs Actual Result:**
- **Expected:** Approved proposal executes successfully, calling target contract method
- **Actual:** Transaction reverts with "Invalid proposal" error, governance action is blocked

**Success Condition:** The vulnerability is confirmed if Release fails with "Invalid proposal" error for an approved but expired proposal, demonstrating governance deadlock.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L39-72)
```csharp
    private ReferendumReceiptCreated LockToken(string symbol, long amount, Hash proposalId, Address lockedAddress,
        Address organizationAddress)
    {
        Assert(State.LockedTokenAmount[lockedAddress][proposalId] == null, "Already locked.");

        var lockId = Context.GenerateId(Context.Self,
            HashHelper.ConcatAndCompute(proposalId, HashHelper.ComputeFrom(lockedAddress)));
        RequireTokenContractStateSet();
        Context.SendVirtualInline(proposalId, State.TokenContract.Value,
            nameof(TokenContractContainer.TokenContractReferenceState.TransferFrom), new TransferFromInput
            {
                From = Context.Sender,
                To = GetProposalVirtualAddress(proposalId),
                Symbol = symbol,
                Amount = amount,
                Memo = "Referendum."
            });
        State.LockedTokenAmount[Context.Sender][proposalId] = new Receipt
        {
            Amount = amount,
            LockId = lockId,
            TokenSymbol = symbol
        };

        return new ReferendumReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = proposalId,
            Amount = amount,
            Symbol = symbol,
            Time = Context.CurrentBlockTime,
            OrganizationAddress = organizationAddress
        };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L124-130)
```csharp
    private ProposalInfo GetValidProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        Assert(proposal != null, "Invalid proposal id.");
        Assert(Validate(proposal), "Invalid proposal.");
        return proposal;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L159-187)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ToAddress = input.ToAddress,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            OrganizationAddress = input.OrganizationAddress,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });

        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L701-715)
```csharp
    public async Task Release_Expired_Proposal_Test()
    {
        // await InitializeParliamentContracts();
        var minimalApprovalThreshold = 6667;
        var maximalAbstentionThreshold = 2000;
        var maximalRejectionThreshold = 3000;
        var minimalVoteThreshold = 8000;
        var organizationAddress = await CreateOrganizationAsync(minimalApprovalThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, minimalVoteThreshold);
        var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
        ParliamentContractStub = GetParliamentContractTester(DefaultSenderKeyPair);
        BlockTimeProvider.SetBlockTime(BlockTimeProvider.GetBlockTime().AddDays(5));
        var result = await ParliamentContractStub.Release.SendWithExceptionAsync(proposalId);
        result.TransactionResult.Error.ShouldContain("Invalid proposal");
    }
```
