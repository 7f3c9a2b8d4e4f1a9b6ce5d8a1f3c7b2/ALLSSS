# Audit Report

## Title
Unauthorized Admin Takeover via AnnounceElectionFor Allows Arbitrary Public Key Hijacking

## Summary
The `AnnounceElectionFor` function in the Election contract lacks authorization checks, allowing any caller to register arbitrary public keys as candidates and assign themselves (or any address) as the admin. This breaks the fundamental security invariant that only the owner of a public key should be able to register it as a candidate, enabling unauthorized administrative control and permanent denial-of-service attacks against legitimate key owners.

## Finding Description

The vulnerability exists in the `AnnounceElectionFor` function which accepts an arbitrary `pubkey` string and optional `admin` address without verifying that the caller has permission to announce election for that public key. [1](#0-0) 

The function directly assigns the provided admin parameter (defaulting to `Context.Sender`) as the candidate admin without any consent mechanism from the public key owner: [2](#0-1) 

The internal validation only checks pubkey eligibility status (not initial miner, not already announced, not banned) but never validates caller authorization: [3](#0-2) 

**Contrast with Secure Implementation:**

The alternative `AnnounceElection(Address input)` method uses cryptographic signature verification (`Context.RecoverPublicKey()`) to ensure only the private key owner can announce: [4](#0-3) 

This secure pattern is completely missing from `AnnounceElectionFor`, creating the authorization bypass. Any caller can provide any public key hex string and set themselves as admin, with no cryptographic proof of ownership required.

## Impact Explanation

**1. Unauthorized Administrative Control**

An attacker gains full admin privileges over candidates they don't own. Admin control includes:

- **Ability to quit election:** The `QuitElection` method enforces that only the admin can quit: [5](#0-4) 

- **Ability to replace the candidate's public key:** The `ReplaceCandidatePubkey` method requires admin authorization: [6](#0-5) 

- **Ability to set profit receivers:** The Treasury contract's `SetProfitsReceiver` validates that the caller is the candidate admin: [7](#0-6) 

**2. Permanent Registration DoS**

Once a pubkey is announced as a candidate, re-announcement is blocked: [8](#0-7) 

The legitimate owner can never register their public key because the attacker has already registered it. Even after the attacker quits (which sets `IsCurrentCandidate = false`), they can immediately re-announce, creating a persistent griefing attack. [9](#0-8) 

**3. Election and Consensus Manipulation**

- Attacker can strategically quit elections to manipulate the miner selection process during term changes
- Voters may vote for hijacked candidates believing they're legitimate, locking tokens for candidates controlled by attackers
- The data center ranking system can be manipulated by controlling when candidates participate

**4. Reputation and Trust Damage**

Attackers can register well-known public keys (from other blockchains, public figures, or anticipated future validators) as candidates under their control, creating confusion and damaging the election system's integrity.

## Likelihood Explanation

**Attacker Capabilities Required:**
- 100,000 ELF for the candidate lock (defined in constants): [10](#0-9) 

- Ability to call a public contract method
- Knowledge of target public key hex strings

**Attack Complexity: TRIVIAL**
- Single transaction call with two parameters: arbitrary pubkey and attacker's address as admin
- No special timing, race conditions, or complex state setup required

**Economic Cost: MINIMAL**

The attacker locks 100,000 ELF but retrieves it when quitting. The sponsor (attacker) receives the refund: [11](#0-10) 

The sponsor is recorded during announcement: [12](#0-11) 

Net cost is zero plus transaction fees, making this economically viable for persistent attacks.

**Detection Difficulty: HIGH**

The hijacked registration appears legitimate on-chain. Users cannot easily distinguish between legitimate candidate registrations and malicious hijackings without off-chain verification of ownership.

**Probability: HIGH** - The vulnerability is easily discoverable, trivial to exploit, and economically rational for attackers seeking to manipulate elections or grief legitimate candidates.

## Recommendation

Add authorization verification to `AnnounceElectionFor` to ensure only the public key owner can register. The function should either:

1. **Remove the function entirely** if the sponsor feature is not essential, forcing all registrations through the secure `AnnounceElection(Address input)` method that uses signature verification.

2. **Add signature verification** requiring a signature from the public key owner proving consent:
   - Require an additional `signature` parameter
   - Verify the signature against the pubkey using the registration message
   - Only proceed if the signature is valid

3. **Restrict to trusted callers** if this is intended for a specific use case:
   - Add an authorization check requiring the caller to be a whitelisted address or governance-approved sponsor
   - Implement a consent mechanism where the pubkey owner must pre-approve sponsors

The secure pattern already exists in the codebase at line 95 using `Context.RecoverPublicKey()`. Apply similar cryptographic verification to `AnnounceElectionFor`.

## Proof of Concept

```csharp
[Fact]
public async Task AnnounceElectionFor_Vulnerability_UnauthorizedHijack()
{
    // Setup: Get victim's keypair and attacker's keypair
    var victimKeyPair = ValidationDataCenterKeyPairs[0];
    var attackerKeyPair = ValidationDataCenterKeyPairs[1];
    
    // Attacker calls AnnounceElectionFor with victim's public key
    var attackerStub = GetElectionContractTester(attackerKeyPair);
    await attackerStub.AnnounceElectionFor.SendAsync(new AnnounceElectionForInput
    {
        Pubkey = victimKeyPair.PublicKey.ToHex(),
        Admin = Address.FromPublicKey(attackerKeyPair.PublicKey) // Attacker sets themselves as admin
    });
    
    // Verify: Attacker is now the admin for victim's pubkey
    var admin = await ElectionContractStub.GetCandidateAdmin.CallAsync(
        new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    admin.ShouldBe(Address.FromPublicKey(attackerKeyPair.PublicKey));
    
    // Verify: Victim cannot register their own pubkey anymore
    var victimStub = GetElectionContractTester(victimKeyPair);
    var exception = await Assert.ThrowsAsync<Exception>(async () =>
    {
        await victimStub.AnnounceElection.SendAsync(Address.FromPublicKey(victimKeyPair.PublicKey));
    });
    exception.Message.ShouldContain("already announced election");
    
    // Verify: Attacker can quit on behalf of victim
    await attackerStub.QuitElection.SendAsync(new StringValue { Value = victimKeyPair.PublicKey.ToHex() });
    
    // Attacker gets refund and can immediately re-hijack
    var balanceAfterQuit = await GetNativeTokenBalance(attackerKeyPair.PublicKey);
    balanceAfterQuit.ShouldBe(initialBalance); // Full refund received
}
```

This test demonstrates:
1. Attacker registers victim's public key with themselves as admin
2. Victim is permanently blocked from registering their own key
3. Attacker has full admin control (can quit, replace pubkey, set profit receivers)
4. Attack is economically free (full refund on quit)

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-99)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-253)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L181-181)
```csharp
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L608-609)
```csharp
        var admin = State.ElectionContract.GetCandidateAdmin.Call(new StringValue {Value = input.Pubkey});
        Assert(Context.Sender == admin , "No permission.");
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
