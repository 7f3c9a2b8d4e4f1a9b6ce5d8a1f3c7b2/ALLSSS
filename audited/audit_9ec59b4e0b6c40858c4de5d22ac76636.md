# Audit Report

## Title
Missing Mining Interval Validation in Next Round Consensus Transition

## Summary
The AEDPoS consensus contract fails to validate that submitted next round information adheres to the configured mining interval stored in `State.MiningInterval.Value`. A malicious miner can submit a next round with arbitrarily modified expected mining times, causing consensus timing disruption that persists and compounds across subsequent rounds until the next term transition.

## Finding Description

The vulnerability exists in the validation logic for next round transitions. The consensus contract stores a fixed mining interval parameter in state that is set during initialization: [1](#0-0) 

This parameter is set once during the first round: [2](#0-1) 

However, when a miner submits a next round via the `NextRound` method: [3](#0-2) 

The validation performed by `ValidationForNextRound()` only checks round number increment and null InValues, but does NOT validate the mining interval: [4](#0-3) 

The only time-related validation is `CheckRoundTimeSlots()` which is called by `TimeSlotValidationProvider`: [5](#0-4) 

This method only ensures internal consistency (intervals between consecutive miners are approximately equal and greater than 0), but does NOT compare against `State.MiningInterval.Value`: [6](#0-5) 

The root cause is that next round generation uses `GetMiningInterval()` which dynamically calculates from the current round's timing rather than the stored state parameter: [7](#0-6) [8](#0-7) 

**Attack Sequence:**
1. Malicious miner obtains legitimate next round data via consensus command generation
2. Modifies all `ExpectedMiningTime` values in `NextRoundInput` to use a different interval (e.g., 8000ms instead of 4000ms)
3. Ensures modified intervals remain internally consistent (equal spacing between miners)
4. Submits modified `NextRoundInput` to `NextRound` method
5. All validations pass because no check compares against `State.MiningInterval.Value`
6. Modified round is stored and subsequent rounds inherit the corrupted interval

The only usage of `State.MiningInterval.Value` for validation purposes is in `NextTerm` generation (not `NextRound`): [9](#0-8) 

This means the corrupted interval persists across all rounds within a term until the next term transition resets it.

## Impact Explanation

**Consensus Timing Disruption:** A malicious miner can manipulate the mining interval to dramatically alter block production rate. Changing from 4000ms to 8000ms would halve the block production rate, while changing to 2000ms would double it. This breaks the fundamental timing assumptions of the consensus protocol.

**Cumulative Drift:** Since each round's interval calculation depends on the previous round's expected mining times, the manipulated interval propagates indefinitely within a term. Once one malicious round is accepted, all future rounds within that term inherit and perpetuate the corrupted timing.

**Protocol Invariant Violation:** The mining interval is a core consensus parameter that should remain fixed per the initial configuration. The protocol design explicitly stores this as a readonly state parameter, indicating it should be immutable during normal round transitions. Allowing arbitrary modification breaks this critical invariant.

**Network-Wide Impact:** All network participants are affected as the actual block production timing deviates from the expected configured parameters, potentially breaking timing assumptions in dependent systems, affecting synchronization, and disrupting the predictable block production schedule that applications rely on.

## Likelihood Explanation

**Reachable Entry Point:** Any miner in the current rotation can call the `NextRound` method. This is a standard consensus participant role, not a privileged position requiring key compromise.

**Low Attack Complexity:** The attack is straightforward:
- Obtain legitimate next round structure (via standard consensus commands)
- Modify `ExpectedMiningTime` values to use desired interval
- Ensure internal consistency (equal spacing)
- Submit to `NextRound` method

**Feasible Preconditions:** The only requirement is being an active miner in the rotation, which is the normal operational state for consensus participants. No additional privileges or compromised keys are required.

**Difficult Detection:** The attack is subtle because the modified round appears internally valid - all intervals are equal and positive. Without explicit validation against `State.MiningInterval.Value`, the manipulation is indistinguishable from legitimate round data during validation.

**Verification:** The grep search confirms `State.MiningInterval.Value` is ONLY used for initialization and NextTerm generation, never for NextRound validation.

## Recommendation

Add explicit validation in `ValidationForNextRound()` or `CheckRoundTimeSlots()` to compare the calculated mining interval against `State.MiningInterval.Value`:

```csharp
// In RoundTerminateValidationProvider.cs - ValidationForNextRound method
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing validations
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // NEW: Validate mining interval matches stored parameter
    var calculatedInterval = extraData.Round.GetMiningInterval();
    if (calculatedInterval != validationContext.ConfiguredMiningInterval) // Pass from state
        return new ValidationResult { Message = "Mining interval does not match configured value." };

    return new ValidationResult { Success = true };
}
```

The `ConsensusValidationContext` would need to include the configured mining interval from `State.MiningInterval.Value` to enable this validation.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMiner_CanModifyMiningInterval_Test()
{
    // Arrange: Initialize consensus with 4000ms interval
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners, miningInterval: 4000);
    
    // Mine first round normally
    await ProduceNormalBlocks(initialMiners);
    
    // Act: Malicious miner generates next round with doubled interval
    var legitimateNextRound = await GetLegitimateNextRound();
    var maliciousNextRound = ModifyMiningInterval(legitimateNextRound, newInterval: 8000);
    
    // Malicious miner submits modified next round
    var result = await MaliciousMinerStub.NextRound.SendAsync(maliciousNextRound);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // Should succeed
    
    // Assert: Modified interval persists in stored round
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var actualInterval = currentRound.GetMiningInterval();
    actualInterval.ShouldBe(8000); // Attack succeeded - interval was modified
    
    // Assert: Subsequent round inherits corrupted interval
    await ProduceNormalBlocks(initialMiners);
    var nextRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    nextRound.GetMiningInterval().ShouldBe(8000); // Persistence confirmed
}

private NextRoundInput ModifyMiningInterval(Round round, int newInterval)
{
    var modifiedRound = round.Clone();
    var miners = modifiedRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    var baseTime = miners.First().ExpectedMiningTime;
    
    // Modify all expected mining times to use new interval
    for (int i = 0; i < miners.Count; i++)
    {
        miners[i].ExpectedMiningTime = baseTime.AddMilliseconds(newInterval * miners[i].Order);
    }
    
    return NextRoundInput.Create(modifiedRound, GenerateRandomNumber());
}
```

This test demonstrates that a malicious miner can successfully submit a next round with a modified mining interval, the modified round is accepted by all validations, and the corrupted interval persists across subsequent rounds.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L28-28)
```csharp
    public ReadonlyState<int> MiningInterval { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L83-83)
```csharp
        State.MiningInterval.Value = input.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-165)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L20-20)
```csharp
        var miningInterval = GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L209-209)
```csharp
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
```
