### Title
Unbounded Withdrawn Vote Record Collection Causes DoS in GetCandidateVoteWithAllRecords View Method

### Summary
The `GetCandidateVoteWithAllRecords()` function attempts to retrieve all withdrawn voting records for a candidate in a single call, without pagination or size limits. For popular candidates who accumulate thousands of withdrawn votes over time, this can exceed the execution call threshold (15,000 calls), causing the view method to fail with `RuntimeCallThresholdExceededException` and preventing users from querying complete historical voting data.

### Finding Description

The vulnerability exists in the `GetCandidateVoteWithAllRecords()` method which calls `State.VoteContract.GetVotingRecords.Call()` with the complete list of `ObtainedWithdrawnVotingRecordIds`: [1](#0-0) 

The `ObtainedWithdrawnVotingRecordIds` list grows unbounded - each time a voter withdraws their vote from a candidate, the vote ID is added to this list and never removed: [2](#0-1) 

The Vote contract's `GetVotingRecords` implementation iterates through all provided IDs without pagination: [3](#0-2) 

AElf contracts enforce an `ExecutionCallThreshold` of 15,000 calls per transaction: [4](#0-3) 

When this threshold is exceeded, the contract throws `RuntimeCallThresholdExceededException`: [5](#0-4) 

Each iteration in `GetVotingRecords` consumes multiple calls (lambda invocation, state read, collection operations). With approximately 3-5 calls per record, processing 3,000-5,000 withdrawn vote IDs would exceed the 15,000 call threshold.

### Impact Explanation

**Operational Impact - View Method DoS:**
- Users cannot query complete withdrawn voting records for popular candidates
- Historical voting data becomes inaccessible for transparency and auditing purposes
- The method fails entirely rather than returning partial data, providing no information about which candidate has accumulated excessive withdrawn votes
- While the core voting and withdrawal functionality continues to work, the inability to view historical records impacts the transparency and auditability of the election system

**Affected Parties:**
- DApp developers and frontends attempting to display complete voting history
- Auditors and analysts requiring full historical voting data
- Users seeking to verify past voting behavior and withdrawals

The severity is appropriately rated as Medium because while it creates a DoS condition, it only affects a view method for historical data and does not compromise funds, voting integrity, or core election functionality.

### Likelihood Explanation

**High Likelihood for Popular Candidates:**
- The method is publicly accessible as a view function (no authentication required)
- Popular candidates naturally accumulate withdrawn votes over the lifetime of the system
- In a blockchain election with hundreds or thousands of participants, accumulating 3,000-5,000 withdrawn votes over months/years is realistic
- Users withdraw votes when lock periods expire or when changing voting targets
- The issue occurs naturally through normal protocol usage without any attacker action

**Feasibility:**
- No special permissions or setup required
- No economic cost to trigger (view methods are free to call)
- The condition builds up gradually and inevitably for successful candidates
- Once the threshold is reached, the method becomes permanently unusable for that candidate

**Detection:**
- Users will receive `RuntimeCallThresholdExceededException` errors when calling the method
- The threshold is deterministic and easy to reproduce once a candidate has sufficient withdrawn votes

### Recommendation

**Implement Pagination for Withdrawn Records:**

Add pagination parameters to the view method and modify the implementation to support batched retrieval:

1. Add pagination input parameters (start index, page size) to `GetCandidateVoteWithAllRecords`
2. Modify the call to only fetch a subset of withdrawn record IDs per request
3. Return pagination metadata (total count, current page, has more) in the response
4. Implement a maximum page size limit (e.g., 100-500 records per call) to prevent single requests from hitting the execution threshold

**Alternative Solution - Separate Endpoint:**

Create a dedicated paginated method like `GetCandidateWithdrawnRecords(StringValue pubkey, PageInformation pageInfo)` that specifically handles withdrawn records with built-in pagination, similar to the existing `GetPageableCandidateInformation` method: [6](#0-5) 

**Add Documentation:**

Document the execution limits and recommend using the paginated active records method (`GetCandidateVoteWithRecords`) for most use cases, reserving the all-records method for small-scale or recent data only.

### Proof of Concept

**Initial State:**
- Election contract is operational with multiple candidates
- A popular candidate (pubkey = "CANDIDATE_A") has been receiving votes for several months

**Execution Steps:**

1. Over time, 5,000 users vote for CANDIDATE_A and later withdraw their votes after lock periods expire
2. Each withdrawal adds a vote ID to `State.CandidateVotes["CANDIDATE_A"].ObtainedWithdrawnVotingRecordIds`
3. The list now contains 5,000 Hash entries

4. User attempts to call: `GetCandidateVoteWithAllRecords(new StringValue { Value = "CANDIDATE_A" })`

5. The method calls `State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput { Ids = { 5000 vote IDs } })`

6. The Vote contract's `GetVotingRecords` begins iterating: `input.Ids.Select(id => State.VotingRecords[id])`

7. After approximately 3,000-5,000 iterations (depending on exact call count per iteration), the `ExecutionObserver.CallCount()` reaches 15,000

**Expected Result:**
- Method should return all 5,000 withdrawn voting records

**Actual Result:**
- Method throws `RuntimeCallThresholdExceededException` 
- Transaction fails with error: "Contract call threshold 15000 exceeded"
- No withdrawn records are returned
- The view method becomes permanently unusable for this candidate

**Success Condition:**
- The exception is thrown and logged in the transaction result
- Users cannot retrieve any withdrawn voting records for the affected candidate
- The issue persists for all subsequent calls until addressed through pagination

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L240-258)
```csharp
    public override GetPageableCandidateInformationOutput GetPageableCandidateInformation(PageInformation input)
    {
        var output = new GetPageableCandidateInformationOutput();
        var candidates = State.Candidates.Value;

        var count = candidates.Value.Count;
        if (count <= input.Start) return output;

        var length = Math.Min(Math.Min(input.Length, 20), candidates.Value.Count.Sub(input.Start));
        foreach (var candidate in candidates.Value.Skip(input.Start).Take(length))
            output.Value.Add(new CandidateDetail
            {
                CandidateInformation = State.CandidateInformationMap[candidate.ToHex()],
                ObtainedVotesAmount = GetCandidateVote(new StringValue { Value = candidate.ToHex() })
                    .ObtainedActiveVotedVotesAmount
            });

        return output;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L288-305)
```csharp
    public override CandidateVote GetCandidateVoteWithAllRecords(StringValue input)
    {
        var votes = GetCandidateVoteWithRecords(input);

        //get withdrawn records
        var obtainedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedWithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedWithdrawnRecords)
        {
            var voteId = votes.ObtainedWithdrawnVotingRecordIds[index++];
            votes.ObtainedWithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L656-657)
```csharp
        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```
