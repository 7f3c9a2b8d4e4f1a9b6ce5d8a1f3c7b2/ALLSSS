### Title
Privilege Escalation via Replacement Chain Break When Reusing Initial Miner Replacement Pubkeys

### Summary
The `PerformReplacement` function unconditionally overwrites `CandidateReplacementMap[newPubkey]` and `InitialPubkeyMap[newPubkey]` without checking if the newPubkey was previously used as a replacement. When an initial miner is replaced by a pubkey that is then reused in a subsequent candidate replacement, the original replacement history is lost, causing the wrong admin to gain unauthorized control over the pubkey and breaking replacement chain integrity.

### Finding Description

The vulnerability exists in the `PerformReplacement` function where state maps are unconditionally overwritten: [1](#0-0) 

The root cause is that when a pubkey is used as `newPubkey` in a replacement operation, no validation ensures it hasn't been used as a replacement before. This creates an exploitable scenario:

**Initial State Separation**: Initial miners are NOT automatically added to the Candidates list during contract initialization: [2](#0-1) 

**Replacement Logic for Non-Candidates**: When replacing a pubkey, the new pubkey is only added to Candidates if the old pubkey was in Candidates: [3](#0-2) 

**Insufficient Protection**: The only checks preventing pubkey reuse are that newPubkey cannot already be a candidate or banned: [4](#0-3) 

**Why Protections Fail**: After an initial miner A is replaced by B:
- B is added to InitialMiners but NOT to Candidates (because A was not in Candidates)
- B is not banned (only A is banned)
- B can therefore pass all validation checks and be reused as newPubkey in a different replacement

**Admin Resolution Impact**: The admin lookup relies on InitialPubkeyMap to resolve to the original pubkey: [5](#0-4) 

When InitialPubkeyMap[B] is overwritten from A to another value, `GetCandidateAdmin(B)` returns the wrong admin.

### Impact Explanation

**Privilege Escalation**: An attacker who controls candidate X can gain unauthorized admin control over pubkey B that was originally controlled by a different admin. The admin lookup mechanism becomes corrupted: [6](#0-5) 

**Concrete Harm**:
1. **Loss of Control**: The original admin of initial miner A loses control over replacement pubkey B
2. **Unauthorized Admin Access**: The attacker gains ability to:
   - Call `SetCandidateAdmin` to further modify B's admin
   - Call `ReplaceCandidatePubkey` to replace B with another pubkey  
   - Control validator operations requiring admin permission
3. **Replacement History Corruption**: The chain tracking that B replaced A is permanently lost, breaking audit trails
4. **Consensus Integrity**: If B is an active miner, the wrong party controls a consensus participant

**Who is Affected**: Initial miners who replace their pubkeys before regular candidates do, creating a window where their replacement pubkeys can be hijacked.

**Severity Justification**: HIGH - This is an authorization bypass vulnerability enabling privilege escalation without requiring the compromise of any trusted role. It violates the critical invariant that admin control should remain with the rightful owner through replacement chains.

### Likelihood Explanation

**Attacker Capabilities**: 
- Attacker must control a candidate (requires 100,000 ELF stake via AnnounceElection)
- Attacker must identify an initial miner that has been replaced by a pubkey not in Candidates
- No special permissions beyond being a candidate admin required

**Attack Complexity**: LOW
- Replacement events are publicly logged, making it trivial to monitor which initial miners have been replaced
- Candidates list and InitialMiners list are publicly queryable to identify target pubkeys
- The attack is a single transaction calling `ReplaceCandidatePubkey`

**Feasibility Conditions**:
1. An initial miner must have replaced their pubkey (timing: anytime before the attack)
2. The replacement pubkey must not have announced election (remains outside Candidates list) 
3. Attacker must control any candidate willing to sacrifice it for the replacement

**Execution Practicality**: The attack is straightforward: [7](#0-6) 

All validation passes because the target pubkey B is neither in Candidates nor banned.

**Economic Rationality**: The cost is only the 100,000 ELF stake required to be a candidate. The attacker sacrifices their candidate X but gains control over an initial miner's replacement pubkey, which could be valuable if that pubkey is an active validator or holds other privileges.

**Probability**: MEDIUM-HIGH - Initial miners replacing their keys is a legitimate operational need for key rotation. The vulnerability window exists from the moment an initial miner performs a replacement until that replacement pubkey announces election (which initial miners cannot do per the code).

### Recommendation

**Immediate Fix**: Add validation in `ReplaceCandidatePubkey` to prevent reusing any pubkey that has an existing entry in `CandidateReplacementMap`:

```csharp
// After line 191, before calling PerformReplacement:
Assert(State.CandidateReplacementMap[input.NewPubkey] == null, 
    "New pubkey has already been used in a previous replacement.");
```

**Additional Safeguard**: Consider also checking `InitialPubkeyMap` to ensure the newPubkey has never participated in any replacement chain:

```csharp
Assert(State.InitialPubkeyMap[input.NewPubkey] == null,
    "New pubkey already exists in a replacement chain.");
```

**Invariant to Add**: Enforce that once a pubkey participates in the replacement system (as either old or new key), it becomes permanently marked and cannot be reused in future replacements.

**Test Cases**:
1. Test that replacing initial miner A with B, then attempting to replace candidate X with B fails
2. Test that replacing candidate Y with Z, then attempting to replace candidate W with Z fails  
3. Verify GetCandidateAdmin returns correct admin through multi-level replacement chains

### Proof of Concept

**Initial State**:
- Initial Miner A with Admin_A controlling it
- Candidate X (initial pubkey Y) with Admin_Y controlling it
- `CandidateAdmins[A] = Admin_A`
- `CandidateAdmins[Y] = Admin_Y`

**Step 1 - Initial Miner Replacement**:
```
Transaction: Admin_A calls ReplaceCandidatePubkey(oldPubkey=A, newPubkey=B)
Expected: Success
Result After:
- CandidateReplacementMap[B] = A
- InitialPubkeyMap[B] = A  
- InitialToNewestPubkeyMap[A] = B
- B is in InitialMiners, NOT in Candidates
- B is NOT banned
- GetCandidateAdmin(B) returns Admin_A ✓ Correct
```

**Step 2 - Attack (Reuse Replacement Pubkey)**:
```
Transaction: Admin_Y calls ReplaceCandidatePubkey(oldPubkey=X, newPubkey=B)
Expected: Should FAIL but currently SUCCEEDS
Result After:
- CandidateReplacementMap[B] = X (OVERWROTE previous value A)
- InitialPubkeyMap[B] = Y (OVERWROTE previous value A)
- GetCandidateAdmin(B) returns Admin_Y ✗ WRONG! Should return Admin_A
```

**Success Condition (Exploit Confirmed)**:
After Step 2, calling `GetCandidateAdmin(B)` returns `CandidateAdmins[Y]` (Admin_Y) instead of `CandidateAdmins[A]` (Admin_A), proving privilege escalation. Admin_Y can now call `SetCandidateAdmin` or `ReplaceCandidatePubkey` for pubkey B without Admin_A's authorization.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-191)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);

        var oldPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.OldPubkey));
        var newPubkeyBytes = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(input.NewPubkey));

        //     Remove origin pubkey from Candidates, DataCentersRankingList and InitialMiners; then add new pubkey.
        var candidates = State.Candidates.Value;
        Assert(!candidates.Value.Contains(newPubkeyBytes), "New pubkey is already a candidate.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L192-197)
```csharp
        if (candidates.Value.Contains(oldPubkeyBytes))
        {
            candidates.Value.Remove(oldPubkeyBytes);
            candidates.Value.Add(newPubkeyBytes);
            State.Candidates.Value = candidates;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L411-414)
```csharp
    public override Address GetCandidateAdmin(StringValue input)
    {
        return State.CandidateAdmins[State.InitialPubkeyMap[input.Value] ?? input.Value];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-42)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;
```
