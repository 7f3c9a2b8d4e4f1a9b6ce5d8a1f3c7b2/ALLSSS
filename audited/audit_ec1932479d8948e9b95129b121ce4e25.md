### Title
Unbounded Growth of ReceivedTokenSymbols Causing State Bloat and Potential DoS of Profit Distribution

### Summary
The `ReceivedTokenSymbols` list in profit schemes can grow without limit (bounded only by the 128KB state size constraint) as different tokens are contributed or distributed. When schemes have `IsReleaseAllBalanceEveryTimeByDefault` set to true, the `DistributeProfits` function iterates through all symbols with cross-contract calls, creating a denial-of-service vector where the operation becomes prohibitively expensive before reaching the state size limit.

### Finding Description

The vulnerability exists in two locations where token symbols are added to `ReceivedTokenSymbols`: [1](#0-0) [2](#0-1) 

There is no mechanism to remove or clean up token symbols from this list. When `IsReleaseAllBalanceEveryTimeByDefault` is true, `DistributeProfits` iterates through every symbol in the list: [3](#0-2) 

Each iteration makes a cross-contract call to `GetBalance`. The Scheme protobuf definition shows `received_token_symbols` as an unbounded repeated field: [4](#0-3) 

While AElf enforces a 128KB state size limit on all state writes: [5](#0-4) [6](#0-5) 

The DoS condition occurs well before reaching this limit due to the computational cost of iterating hundreds or thousands of symbols with cross-contract calls.

### Impact Explanation

**Primary Impact**: Profit schemes with `IsReleaseAllBalanceEveryTimeByDefault=true` become unusable when `ReceivedTokenSymbols` grows large. The scheme manager cannot distribute profits without incurring excessive transaction costs or potential execution failures.

**Affected Parties**: 
- Scheme managers who cannot perform distributions
- Beneficiaries who cannot receive their profits
- The protocol's profit distribution mechanism integrity

**Quantified Impact**:
- State bloat: Each token symbol consumes ~10-15 bytes; 1000 symbols = ~15KB
- Computational cost: With 1000 symbols, `DistributeProfits` makes 1000 cross-contract `GetBalance` calls
- Practical limit: Schemes become unusable at 100-1000 symbols, far below the 128KB state limit (which would allow ~10,000+ symbols)

**Severity Justification**: LOW - Limited to schemes with specific configuration flag, requires significant attacker investment, bounded by state limit, primarily a griefing attack.

### Likelihood Explanation

**Attacker Capabilities**: Any user can call the public `ContributeProfits` function to add new token symbols: [7](#0-6) 

**Attack Complexity**: MODERATE
1. Create or obtain many different tokens
2. Call `ContributeProfits` for each unique token symbol
3. Each contribution requires actual token transfer (enforced at lines 673-680 or 704-710)
4. Token must exist (validated at line 656)

**Attack Cost**:
- Transaction fees for each `ContributeProfits` call
- Actual token amounts being contributed (can be minimal)
- Token creation fees if creating new tokens
- Estimated: 100-1000 transactions with token transfers

**Economic Rationality**: QUESTIONABLE - This is an expensive griefing attack with no direct financial benefit to the attacker. The attack provides operational disruption but requires substantial upfront investment.

**Detection**: Easy to detect through monitoring `ReceivedTokenSymbols` list growth and `ContributeProfits` transaction patterns.

### Recommendation

**Immediate Mitigation**:
1. Add a maximum limit for `ReceivedTokenSymbols` list size (e.g., 50-100 symbols) in `ContributeProfits` and `DistributeProfitsForSubSchemes`:

```
Assert(scheme.ReceivedTokenSymbols.Count < MAX_TOKEN_SYMBOLS_PER_SCHEME, 
    "Maximum token symbol limit reached.");
```

2. Implement access control on `ContributeProfits` to restrict who can contribute new token types.

**Long-term Solution**:
1. Add a mechanism to remove inactive token symbols (symbols with zero balance for N periods)
2. Consider using a token whitelist approach where only approved tokens can be contributed
3. Add a governance parameter for maximum allowed symbols per scheme

**Invariant Checks**:
- `scheme.ReceivedTokenSymbols.Count <= MAX_TOKEN_SYMBOLS_PER_SCHEME`
- Token symbols should only be added once per unique symbol (current check exists but no count limit)

**Test Cases**:
1. Test contributing 100+ different tokens to a scheme
2. Verify `DistributeProfits` fails or becomes prohibitively expensive with many symbols
3. Test state size validation when approaching 128KB limit
4. Test removal mechanism for inactive symbols

### Proof of Concept

**Initial State**:
- Profit scheme S created with `IsReleaseAllBalanceEveryTimeByDefault = true`
- Attacker has 1000 different token types (T1, T2, ..., T1000)

**Attack Steps**:
1. For each token Ti (i = 1 to 1000):
   - Call `ContributeProfits(schemeId: S, symbol: Ti, amount: 1, period: 0)`
   - Each call adds Ti to `scheme.ReceivedTokenSymbols` if not already present (line 716)

2. After 1000 contributions:
   - `scheme.ReceivedTokenSymbols.Count = 1000`
   - State size still under 128KB limit

3. Scheme manager attempts `DistributeProfits(schemeId: S, period: 1)`:
   - Function iterates all 1000 symbols (lines 451-459)
   - Makes 1000 cross-contract `GetBalance` calls (line 453)
   - Transaction becomes extremely expensive or fails

**Expected Result**: `DistributeProfits` succeeds with normal cost

**Actual Result**: `DistributeProfits` incurs excessive cost or fails, effectively creating a DoS condition for the profit distribution mechanism

**Success Condition**: Scheme manager cannot distribute profits due to prohibitive cost, even though all access controls and state limits are respected.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L449-459)
```csharp
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-644)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L651-721)
```csharp
    public override Empty ContributeProfits(ContributeProfitsInput input)
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        AssertTokenExists(input.Symbol);
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }

        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null)
        {
            throw new AssertionException("Scheme not found.");
        }
        // ReSharper disable once PossibleNullReferenceException
        var virtualAddress = scheme.VirtualAddress;

        if (input.Period == 0)
        {

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = virtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount,
                Memo = $"Add {input.Amount} dividends."
            });
        }
        else
        {
            Assert(input.Period >= scheme.CurrentPeriod, "Invalid contributing period.");
            var distributedPeriodProfitsVirtualAddress =
                GetDistributedPeriodProfitsVirtualAddress(input.SchemeId, input.Period);

            var distributedProfitsInformation = State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
            if (distributedProfitsInformation == null)
            {
                distributedProfitsInformation = new DistributedProfitsInfo
                {
                    AmountsMap = { { input.Symbol, input.Amount } }
                };
            }
            else
            {
                Assert(!distributedProfitsInformation.IsReleased,
                    $"Scheme of period {input.Period} already released.");
                distributedProfitsInformation.AmountsMap[input.Symbol] =
                    distributedProfitsInformation.AmountsMap[input.Symbol].Add(input.Amount);
            }

            State.TokenContract.TransferFrom.Send(new TransferFromInput
            {
                From = Context.Sender,
                To = distributedPeriodProfitsVirtualAddress,
                Symbol = input.Symbol,
                Amount = input.Amount
            });

            State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress] = distributedProfitsInformation;
        }

        // If someone directly use virtual address to do the contribution, won't sense the token symbol he was using.
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);

        State.SchemeInfos[scheme.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** protobuf/profit_contract.proto (L159-159)
```text
    repeated string received_token_symbols = 12;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```
