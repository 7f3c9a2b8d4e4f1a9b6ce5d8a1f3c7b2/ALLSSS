# Audit Report

## Title
Miner List Manipulation in Round Transitions Enables LIB Height Manipulation

## Summary
The AEDPoS consensus contract accepts user-provided `NextRoundInput` and `NextTermInput` with arbitrary `RealTimeMinersInformation` dictionaries without validating that the miner public keys match the expected list. This allows any active miner to manipulate the miner list during round transitions, which directly compromises the Last Irreversible Block (LIB) height calculation and consensus integrity.

## Finding Description

**Root Cause:**

When miners submit round transition transactions via `NextRound()` or `NextTerm()`, the input is converted to a Round object and stored directly without validating that the public keys in `RealTimeMinersInformation` match the expected miners. [1](#0-0) 

The `ProcessNextRound` method extracts the round from user input and stores it: [2](#0-1) 

Similarly, `ProcessNextTerm` creates the miner list directly from input keys and stores it: [3](#0-2) 

**Missing Validations:**

The `PreCheck()` only verifies the transaction sender is in the current or previous miner list, not the content of the provided round: [4](#0-3) 

The validation providers check structural properties but NOT the miner public keys:

1. `MiningPermissionValidationProvider` only checks if sender is in the **base round** (current round stored in state), not the provided round: [5](#0-4) 

2. `NextRoundMiningOrderValidationProvider` only validates internal consistency (FinalOrderOfNextRound vs OutValue count): [6](#0-5) 

3. `RoundTerminateValidationProvider` only checks round number increment and InValue constraints: [7](#0-6) 

**Attack Propagation to LIB Calculation:**

The corrupted miner list directly affects LIB calculation. The `LastIrreversibleBlockHeightCalculator` retrieves miners from the current round and uses them to filter implied irreversible heights: [8](#0-7) 

The filtering happens in `GetSortedImpliedIrreversibleBlockHeights` which only includes heights for miners in the provided public key list: [9](#0-8) 

**Concrete Attack Scenario:**

For `NextRound`: The miner list should remain constant within a term (same miners as current round), but an attacker can submit a `NextRoundInput` with:
- Excluded honest miners (to remove high LIB heights)
- Injected fake/colluding miners (to add low LIB heights)
- No validation compares the provided keys against `currentRound.RealTimeMinersInformation.Keys`

For `NextTerm`: The miner list should match `GetVictories()` from the Election Contract, but an attacker can submit a `NextTermInput` with arbitrary miners without any comparison to the election results.

## Impact Explanation

**Critical Consensus Compromise:**

1. **LIB Manipulation**: By excluding miners with high implied irreversible block heights or including fake miners with low heights, attackers can manipulate the LIB calculation algorithm, which uses the median of the lower 2/3 of heights. This breaks finality guarantees.

2. **Cross-Chain Security Breach**: Cross-chain operations rely on LIB for safety. A manipulated LIB allows acceptance of invalid cross-chain transfers, enabling double-spend attacks across chains.

3. **Mining Rewards Theft**: The miner list determines reward distribution. Injecting fake miners into the list allows stealing rewards intended for legitimate miners.

4. **Chain Reorganization**: Incorrect LIB allows deeper reorganizations than protocol guarantees, enabling sophisticated double-spend attacks.

**Severity: CRITICAL** - This breaks the fundamental consensus invariant that the miner list must match the protocol-defined expected miners (either current miners for NextRound or election winners for NextTerm).

## Likelihood Explanation

**High Likelihood:**

1. **Attacker Requirements**: Any active miner can execute this attack. The only requirement is passing `PreCheck()`, which simply verifies the sender is a current or previous miner.

2. **Attack Complexity**: Low - The attacker constructs a `NextRoundInput` or `NextTermInput` with modified `RealTimeMinersInformation` and submits it via the public methods.

3. **No Detection**: Validation passes successfully because no validator checks the miner public keys against the expected list.

4. **Immediate Exploitability**: Works on both MainChain and SideChains with no special timing requirements.

**Probability: HIGH** - Any compromised or adversarial miner can execute this with minimal effort.

## Recommendation

Add validation to verify miner list integrity:

**For NextRound:**
```csharp
private void ProcessNextRound(NextRoundInput input)
{
    var nextRound = input.ToRound();
    TryToGetCurrentRoundInformation(out var currentRound);
    
    // CRITICAL FIX: Validate miner list matches current round
    var expectedMiners = currentRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var providedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    Assert(expectedMiners.SequenceEqual(providedMiners), 
        "NextRound miner list must match current round miners.");
    
    // Continue with existing logic...
}
```

**For NextTerm:**
```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // CRITICAL FIX: Validate miner list matches election results
    if (State.IsMainChain.Value && TryToGetVictories(out var victories))
    {
        var expectedMiners = victories.Pubkeys.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        var providedMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        Assert(expectedMiners.SequenceEqual(providedMiners),
            "NextTerm miner list must match election victories.");
    }
    
    // Continue with existing logic...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerListManipulation_NextRound_Test()
{
    // Setup: Initialize consensus with legitimate miners
    await InitializeConsensusAsync();
    await NormalBlock(InitialMinersKeyPairs[0]);
    
    // Attack: Malicious miner creates NextRoundInput with fake miner
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousRound = currentRound.Clone();
    maliciousRound.RoundNumber++;
    
    // Inject fake miner into RealTimeMinersInformation
    maliciousRound.RealTimeMinersInformation.Add("FakeMinerPublicKey", new MinerInRound
    {
        Pubkey = "FakeMinerPublicKey",
        Order = 1,
        ImpliedIrreversibleBlockHeight = 1 // Low height to manipulate LIB
    });
    
    // Submit malicious NextRound - should fail but currently succeeds
    var maliciousInput = new NextRoundInput();
    maliciousInput.RoundNumber = maliciousRound.RoundNumber;
    maliciousInput.RealTimeMinersInformation.Add(maliciousRound.RealTimeMinersInformation);
    
    var result = await ConsensusStub.NextRound.SendAsync(maliciousInput);
    
    // Vulnerability: Transaction succeeds and fake miner is stored
    var storedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.True(storedRound.RealTimeMinersInformation.ContainsKey("FakeMinerPublicKey"));
    // This proves the miner list was manipulated without validation
}
```

**Notes:**

The vulnerability exists because the protocol assumes miners will submit correctly formatted round data generated via `GenerateNextRoundInformation`, but nothing prevents a malicious miner from crafting arbitrary input. The validation framework checks structural correctness but not semantic correctness of the miner list against protocol expectations (current miners for NextRound, election winners for NextTerm). This breaks the critical consensus invariant that only authorized miners participate in each round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```
