### Title
Method Fee Controller Validation Bypass via Malicious Authorization Contract

### Summary
The `ChangeMethodFeeController` function fails to validate that the provided `AuthorityInfo.ContractAddress` is a legitimate system governance contract (Parliament, Association, or Referendum). An attacker can supply a malicious contract that falsely validates any organization address, allowing the MethodFeeController to be changed to a controlled or exploitable contract. This enables bypassing governance control over method fees through subsequent exploitation of the compromised controller.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method which accepts an `AuthorityInfo` parameter containing `ContractAddress` and `OwnerAddress` fields. [1](#0-0) 

The validation logic only checks if an organization exists by calling `CheckOrganizationExist`, which makes a cross-contract call to the provided `ContractAddress`: [2](#0-1) 

**Root Cause**: There is no validation ensuring `ContractAddress` is a legitimate system governance contract. Unlike other privileged operations such as `CreateOrganizationBySystemContract`, which properly validates the caller is a system contract: [3](#0-2) 

The `ChangeMethodFeeController` method lacks this critical check.

**Why Protections Fail**: An attacker can deploy a malicious contract implementing `ValidateOrganizationExist` that returns true for any address. When governance is manipulated to approve changing the controller to this malicious configuration, the validation passes. Subsequently, when `SetMethodFee` is called, it only checks: [4](#0-3) 

If `OwnerAddress` is a contract the attacker controls or can exploit, they can make inline calls with `Context.Sender` set to that address: [5](#0-4) 

This allows setting arbitrary method fees without proper governance approval.

### Impact Explanation

**Direct Financial Impact**: 
- Attacker can set method fees to zero, eliminating transaction fee revenue for the protocol
- Attacker can set fees to maximum values (MAX_INT64), effectively denying service to all contract operations

**Governance Bypass**: 
- Complete circumvention of Parliament/Association/Referendum control over method fees
- Undermines the core security model where method fee changes require multi-signature approval from block producers

**Affected Parties**:
- All users paying transaction fees (economic exploitation)
- Protocol treasury (revenue loss)
- Contract operators (DoS if fees set too high)

**Severity Justification**: HIGH - While requiring initial governance manipulation, once compromised, the attacker gains permanent control over method fees without ongoing governance approval, representing a critical failure of the authorization model.

### Likelihood Explanation

**Attack Complexity**: MODERATE
- Phase 1: Requires social engineering or vote manipulation to get governance approval for the malicious controller change
- Phase 2: Requires either controlling a contract or exploiting vulnerabilities in the OwnerAddress contract
- Phase 3: Direct execution via inline calls to SetMethodFee

**Feasibility Conditions**:
1. Attacker deploys malicious validation contract (low cost, ~0.1 ELF deployment)
2. Coordinates with voters or exploits governance process to approve proposal (MODERATE difficulty)
3. Either controls OwnerAddress contract or exploits its vulnerabilities
4. Makes inline calls to SetMethodFee bypassing governance

**Detection Constraints**: 
- Initial controller change appears as legitimate governance action
- Subsequent fee manipulation may be detected but cannot be easily reversed without another governance action
- No automatic monitoring for non-standard controller contract addresses

**Economic Rationality**: High reward-to-risk ratio if governance can be compromised, as permanent control over fees enables ongoing exploitation or ransom scenarios.

### Recommendation

**Code-Level Mitigation**:

Add validation in `ChangeMethodFeeController` to ensure `ContractAddress` is a registered system contract:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // ADD THIS VALIDATION
    var systemContracts = Context.GetSystemContractNameToAddressMapping().Values;
    Assert(systemContracts.Contains(input.ContractAddress), 
        "ContractAddress must be a system governance contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");

    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Invariant Check**: `MethodFeeController.Value.ContractAddress ∈ {Parliament, Association, Referendum} system contract addresses`

**Test Cases**:
1. Test ChangeMethodFeeController with malicious contract address (should fail)
2. Test ChangeMethodFeeController with non-existent address (should fail)  
3. Test ChangeMethodFeeController with only Parliament/Association/Referendum addresses (should succeed)
4. Test SetMethodFee from non-controller contract (should fail)

### Proof of Concept

**Initial State**:
- Parliament contract deployed with default organization
- MethodFeeController set to Parliament's default organization

**Attack Sequence**:

1. **Deploy Malicious Contract**:
```
Contract MaliciousValidator:
  function ValidateOrganizationExist(address org) returns (bool):
    return true  // Always validates any address
```

2. **Create Governance Proposal**:
```
Transaction: CreateProposal
  To: Parliament Contract
  Method: CreateProposal
  Params:
    ToAddress: Parliament Contract
    ContractMethodName: ChangeMethodFeeController
    Params: AuthorityInfo {
      ContractAddress: MaliciousValidator,
      OwnerAddress: AttackerControlledContract
    }
```

3. **Get Proposal Approved** (via social engineering/vote manipulation)

4. **Release Proposal**:
```
Transaction: Release
Result: MethodFeeController now points to AttackerControlledContract via MaliciousValidator
```

5. **Exploit Controller**:
```
Transaction: AttackerControlledContract.MaliciousMethod()
  → Calls Context.SendInline(ParliamentContract, "SetMethodFee", maliciousFees)
  → Context.Sender = AttackerControlledContract
  → Check passes: Context.Sender == OwnerAddress
  → Method fees changed to attacker's values
```

**Expected Result**: SetMethodFee should reject non-governance controller addresses

**Actual Result**: SetMethodFee accepts calls from AttackerControlledContract, allowing arbitrary fee manipulation

**Success Condition**: GetMethodFee returns attacker-controlled values without proper governance approval

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L15-15)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L41-42)
```csharp
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** docs/tutorials/developing-smart-contracts/tx-execution-context.md (L36-36)
```markdown
- **Sender**: the address sending the transaction. If the transaction execution does not produce any inline transactions, this will always be the same. But if one contract calls another with an inline transaction, the sender will be the contract that is calling.
```
