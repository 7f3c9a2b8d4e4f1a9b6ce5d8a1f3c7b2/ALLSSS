# Audit Report

## Title
Missing Validation Allows Future Irreversible Block Height in NextRound Consensus Transitions

## Summary
The AEDPoS consensus contract fails to validate that `ConfirmedIrreversibleBlockHeight` does not exceed the current block height during NextRound transitions. A malicious miner can inject a future LIB value, violating the fundamental consensus invariant that the Last Irreversible Block must never be ahead of the current blockchain tip.

## Finding Description

The vulnerability exists in the NextRound consensus validation flow where `ConfirmedIrreversibleBlockHeight` (LIB) propagates without bounds checking.

**Root Cause:**

`NextRoundInput.Create()` directly copies `ConfirmedIrreversibleBlockHeight` from the provided round parameter without validation: [1](#0-0) 

The `GenerateNextRoundInformation` method copies LIB from the current round without any bounds validation: [2](#0-1) 

**Validation Gap:**

The consensus validation framework applies different validators based on behavior type. For NextRound, only these validators are configured: [3](#0-2) 

`LibInformationValidationProvider` is ONLY applied to UpdateValue behavior, NOT NextRound: [4](#0-3) 

Even if it were applied, `LibInformationValidationProvider` only checks that LIB doesn't decrease, not that it stays within current block height bounds: [5](#0-4) 

`RoundTerminateValidationProvider` validates round number and InValue nullness, but NOT LIB bounds: [6](#0-5) 

**Execution Path:**

1. Malicious miner's turn arrives to produce a NextRound block
2. Miner crafts consensus extra data with future `ConfirmedIrreversibleBlockHeight` (e.g., current height + 10000)
3. ValidateConsensusBeforeExecution parses and validates the extra data: [7](#0-6) 

4. Validation passes because no validator checks LIB bounds for NextRound
5. NextRound public method is invoked with the malicious input: [8](#0-7) 

6. ProcessNextRound stores the malicious round via AddRoundInformation: [9](#0-8) 

7. AddRoundInformation persists the round to state without validation: [10](#0-9) 

## Impact Explanation

**Consensus Invariant Violation:**

The system now violates the fundamental invariant that Last Irreversible Block cannot be ahead of the current blockchain tip. This breaks the core consensus guarantee that "irreversible" blocks have actually been produced and finalized.

**Arithmetic Issues:**

`GetMaximumBlocksCount()` calculates distance to LIB height: [11](#0-10) 

When `libBlockHeight > currentHeight`, the calculation at line 63 produces a negative value, leading to incorrect consensus status reporting and potential disruption of block production limits.

**State Consistency:**

Once injected, the invalid LIB persists in state and propagates to subsequent rounds, as future rounds may copy this value during their generation. This creates a persistent inconsistency in the consensus state.

**Severity:** HIGH - Violates core consensus invariants and can disrupt consensus operation.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active miner in the current miner list (realistic in DPoS)
- Ability to produce blocks during their time slot

**Attack Feasibility:**
- No cryptographic barriers prevent including arbitrary consensus extra data
- The validation gap is absolute - no validator checks LIB <= current height for NextRound
- Detection may be delayed as the system continues operating
- Attack can be executed in a single block during the attacker's mining turn

**Probability:** HIGH - Clear validation gap with realistic attacker capabilities and straightforward execution.

## Recommendation

Add LIB bounds validation for NextRound behavior. Modify the validation configuration to include a bounds check:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    // Add LIB bounds validation
    validationProviders.Add(new LibBoundsValidationProvider()); 
    break;
```

Create a new `LibBoundsValidationProvider` that validates:
```csharp
public class LibBoundsValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var providedRound = validationContext.ProvidedRound;
        
        if (providedRound.ConfirmedIrreversibleBlockHeight > validationContext.CurrentHeight)
        {
            return new ValidationResult 
            { 
                Message = "LIB height cannot exceed current block height." 
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Alternatively, extend `LibInformationValidationProvider` to check both decrease and upper bounds, and apply it to NextRound behavior as well.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanInjectFutureLIB()
{
    // Setup: Get a valid miner and advance to a point where NextRound is expected
    var currentHeight = 2000;
    var maliciousMiner = InitialMiners[0];
    
    // Create malicious NextRound input with future LIB
    var maliciousNextRound = new Round
    {
        RoundNumber = 2,
        ConfirmedIrreversibleBlockHeight = currentHeight + 10000, // Future block!
        // ... other valid fields
    };
    
    var maliciousInput = NextRoundInput.Create(maliciousNextRound, HashHelper.ComputeFrom("random"));
    
    // This should fail but doesn't due to missing validation
    await AEDPoSContractStub.NextRound.SendAsync(maliciousInput);
    
    // Verify the malicious LIB was stored
    var storedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    Assert.True(storedRound.ConfirmedIrreversibleBlockHeight > currentHeight); // Vulnerability confirmed
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-16)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-106)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```
