### Title
RoundId Collision Enables Secret Sharing State Corruption in Consensus Protocol

### Summary
The `RoundId` property is computed as the sum of `ExpectedMiningTime.Seconds` values, while `GetHash()` includes all round fields except `ActualMiningTimes`, `EncryptedPieces`, and `DecryptedPieces`. This allows different rounds to share the same `RoundId`, breaking uniqueness assumptions. The `SecretSharingService` uses `RoundId` as a dictionary key, enabling attackers to corrupt or overwrite secret sharing data by crafting rounds with colliding `RoundId` values, potentially disrupting consensus operations.

### Finding Description

**Root Cause:**

The `RoundId` property is computed solely from the sum of expected mining times: [1](#0-0) 

Meanwhile, `GetHash()` computes a hash from a "checkable round" that excludes only specific fields: [2](#0-1) [3](#0-2) 

This means two rounds with identical `ExpectedMiningTime` sums but different content (miners, signatures, orders, term numbers, etc.) will have:
- **Same RoundId** (identical sum)
- **Different GetHash()** (different content)

**Validation Logic Inconsistency:**

The `TimeSlotValidationProvider` uses `RoundId` to determine whether a provided round is new or an update to the same round: [4](#0-3) 

This validation logic assumes `RoundId` uniquely identifies a round, but this assumption is false.

**Critical Vulnerability - Secret Sharing State Corruption:**

The `SecretSharingService` uses `RoundId` as a dictionary key for storing and retrieving encrypted pieces, decrypted pieces, and revealed in-values: [5](#0-4) [6](#0-5) 

The retrieval methods remove data after access: [7](#0-6) 

**Event Emission Timing:**

The `SecretSharingInformation` event is emitted during round addition, using `RoundId`: [8](#0-7) 

This event is processed by `SecretSharingService` to store secret sharing data. The event is emitted during transaction execution in `ProcessNextRound`: [9](#0-8) 

While `ValidateConsensusAfterExecution` eventually checks hash integrity, this occurs AFTER the event has been emitted and processed: [10](#0-9) 

### Impact Explanation

**Consensus Disruption:**
When two rounds share the same `RoundId`, the `SecretSharingService` dictionaries experience data corruption:
1. First round stores its encrypted/decrypted pieces and revealed in-values with `RoundId` as key
2. Second round with colliding `RoundId` overwrites the first round's data
3. When miners call `GetEncryptedPieces()` or `GetDecryptedPieces()`, data is removed after retrieval
4. Legitimate miners lose access to their secret sharing pieces, breaking the secret sharing protocol

**Security Impact:**
- **Random Number Generation Compromise**: Secret sharing is used to generate secure random numbers for consensus. Corrupted secret sharing data undermines randomness.
- **Consensus Stall**: Miners unable to retrieve correct secret sharing pieces cannot properly participate in consensus rounds.
- **Protocol Integrity Violation**: The AEDPoS consensus protocol's security guarantees depend on correct secret sharing. This vulnerability breaks that assumption.

**Affected Parties:**
All miners participating in consensus are affected. The network's ability to produce blocks reliably is compromised.

### Likelihood Explanation

**Attacker Capabilities:**
An attacker who is a miner (or can influence miner behavior) can craft rounds with colliding `RoundId` values by:
1. Computing target `RoundId` (sum of current round's `ExpectedMiningTime.Seconds`)
2. Selecting different `ExpectedMiningTime` values that sum to the same target
3. Creating a round with different content but identical `RoundId`

**Attack Complexity:**
- **Medium**: Requires solving a subset-sum problem to find `ExpectedMiningTime` values with the desired sum
- **Feasible**: The sum is a long integer; multiple solutions likely exist
- **No special privileges required**: Any miner can propose rounds during their time slot

**Execution Practicality:**
The attack is practical because:
- Miners regularly propose new rounds via `NextRound` transactions
- `ExpectedMiningTime` values are miner-controlled within validation constraints
- The `SecretSharingService` automatically processes emitted events
- Even if `ValidateConsensusAfterExecution` rejects the block, the service state may already be corrupted

**Detection Constraints:**
- Difficult to detect: Hash validation failures appear as normal rejected blocks
- Side effects hidden: `SecretSharingService` state corruption is not visible on-chain
- Persistent impact: Once data is overwritten or removed, legitimate rounds cannot recover it

**Probability:**
High likelihood due to the fundamental design flaw. Even unintentional `RoundId` collisions (through timing or coordination issues) could trigger this vulnerability.

### Recommendation

**Primary Fix - Use Unique Round Identifier:**

1. Replace `RoundId` usage in `SecretSharingService` with a truly unique identifier. Use `(RoundNumber, TermNumber)` tuple or `GetHash()` result as the dictionary key:

```csharp
// In SecretSharingInformation message, add:
bytes round_hash = 4; // Store GetHash() result

// In SecretSharingService, change dictionary keys from long to bytes/string
private readonly Dictionary<string, Dictionary<string, byte[]>> _encryptedPieces = new();
```

2. Update `TimeSlotValidationProvider` to not rely on `RoundId` alone for round identity. Use hash comparison:

```csharp
if (validationContext.ProvidedRound.GetHash() != validationContext.BaseRound.GetHash())
```

**Secondary Fix - Validation Strengthening:**

3. Add explicit uniqueness validation in `AddRoundInformation` to prevent rounds with duplicate `RoundId` from being added within a short window:

```csharp
// Store recent RoundIds with their hashes
// Reject new rounds if RoundId matches but hash differs
```

**Testing Requirements:**

4. Add test cases that:
   - Create two rounds with same `RoundId` but different content
   - Verify secret sharing data is not corrupted
   - Ensure validation properly rejects rounds with colliding identifiers
   - Test `SecretSharingService` behavior under collision scenarios

### Proof of Concept

**Initial State:**
- Blockchain running with AEDPoS consensus
- Current round has miners M1, M2, M3
- Current `RoundId` = R (sum of `ExpectedMiningTime.Seconds`)

**Attack Steps:**

1. **Attacker (Miner M1) observes current round:**
   - Current `RoundId` R = Time1 + Time2 + Time3 (e.g., R = 300)

2. **Attacker crafts malicious round for NextRound:**
   - Set `ExpectedMiningTime` values: Time1' = 100, Time2' = 150, Time3' = 50
   - Sum = 300 = R (same `RoundId`)
   - But use different miner orders, signatures, or other fields
   - Different content means `GetHash()` produces different result

3. **Attacker proposes malicious round:**
   - Call `NextRound` with crafted round
   - `AddRoundInformation` is called, emitting `SecretSharingInformation` event
   - `SecretSharingService.AddSharingInformationAsync()` processes event with `RoundId` = R

4. **State corruption occurs:**
   - `_encryptedPieces[R]` is overwritten with attacker's data
   - Legitimate round's secret sharing data is lost
   - Even though `ValidateConsensusAfterExecution` may reject the block (hash mismatch), `SecretSharingService` state is already corrupted

5. **Impact manifests:**
   - Legitimate miners call `GetEncryptedPieces(R)` and receive wrong/corrupted data
   - Secret sharing protocol fails
   - Consensus cannot proceed properly

**Expected Result:**
Each round should have unique secret sharing data storage.

**Actual Result:**
Rounds with colliding `RoundId` cause data overwrite and loss in `SecretSharingService`, disrupting consensus operations.

**Success Condition:**
Demonstrate that secret sharing data retrieval returns incorrect or missing data after `RoundId` collision.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L60-63)
```csharp
    public Hash GetHash(bool isContainPreviousInValue = true)
    {
        return HashHelper.ComputeFrom(GetCheckableRound(isContainPreviousInValue));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L63-71)
```csharp
    public Dictionary<string, byte[]> GetEncryptedPieces(long roundId)
    {
        _encryptedPieces.TryGetValue(roundId, out var encryptedPieces);
        Logger.LogDebug($"[GetEncryptedPieces]Round id: {roundId}");
        if (encryptedPieces != null) Logger.LogDebug($"Encrypted/Shared {encryptedPieces.Count} pieces.");

        _encryptedPieces.Remove(roundId);
        return encryptedPieces ?? new Dictionary<string, byte[]>();
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L140-141)
```csharp
        _encryptedPieces[secretSharingInformation.CurrentRoundId] = encryptedPieces;
        _decryptedPieces[secretSharingInformation.CurrentRoundId] = decryptedPieces;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L183-183)
```csharp
        _revealedInValues[secretSharingInformation.CurrentRoundId] = revealedInValues;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L110-115)
```csharp
            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-113)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };
```
