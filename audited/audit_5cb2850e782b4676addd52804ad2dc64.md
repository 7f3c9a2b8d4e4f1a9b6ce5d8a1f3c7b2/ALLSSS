### Title
NFT Contract SetMethodFee Implementation is Non-Functional, Causing Governance Resource Waste

### Summary
The NFT contract's `SetMethodFee` method accepts calls without performing any authorization checks or state updates, causing it to silently succeed with no effect. [1](#0-0)  Parliament proposals to update method fees will complete successfully but waste gas and participant resources while leaving fees unchanged.

### Finding Description

The NFT contract implements the ACS1 standard for method fee management, but the implementation is incomplete and non-functional.

**Root Cause**: The `SetMethodFee` method simply returns an empty result without any logic [1](#0-0) , failing to:
1. Validate the caller's authorization
2. Store the fee configuration in contract state
3. Perform any input validation

**Missing State Variables**: The NFTContractState lacks the necessary state variables that other system contracts use to store method fees and controller information. [2](#0-1)  Compare this to proper implementations in Parliament [3](#0-2) , which include `TransactionFees` and `MethodFeeController` state variables.

**Broken View Functions**: The `GetMethodFeeController` returns an empty `AuthorityInfo` object [4](#0-3) , and `GetMethodFee` returns only hardcoded values for the "Create" method [5](#0-4) , ignoring any attempted updates.

**Contrast with Proper Implementations**: Other system contracts implement proper authorization and state storage. For example, the Parliament contract validates the caller, checks token validity, and stores fees in state. [6](#0-5) 

### Impact Explanation

**Governance Resource Waste**: When governance participants create Parliament proposals to update NFT contract method fees:
1. Proposal creation consumes gas and requires proposal deposit
2. Block producers spend time reviewing and approving proposals
3. Proposal release execution consumes gas
4. All these resources are wasted because the fees never actually change

**Erosion of Governance Trust**: Participants who successfully pass proposals through the governance process will discover their changes had no effect, leading to:
- Confusion about whether governance is working correctly
- Loss of confidence in the governance system
- Potential for multiple redundant proposals attempting the same change
- Difficulty distinguishing this issue from other governance problems

**Operational Confusion**: The contract appears to implement ACS1 correctly from the interface perspective, making the issue non-obvious without deep inspection or testing. Standard governance tests like those used for the MultiToken contract [7](#0-6)  would reveal that fee updates don't persist.

**Severity Justification**: This is a Medium severity issue because it wastes resources and damages governance credibility, but does not directly enable fund theft or break critical invariants.

### Likelihood Explanation

**High Likelihood**: This issue will occur through normal governance operations:

1. **Reachable Entry Point**: `SetMethodFee` is a standard ACS1 method that governance participants expect to work, accessible via Parliament proposals
2. **No Special Prerequisites**: Any governance participant can create proposals; block producers routinely approve method fee changes for system contracts
3. **Natural Occurrence**: As the NFT contract is used and fee adjustments become desirable, governance participants will naturally attempt to update fees following the standard pattern demonstrated in tests [8](#0-7) 
4. **Detection Difficulty**: The transaction succeeds without error, requiring participants to query `GetMethodFee` after the proposal to discover the issue

**No Attack Required**: This is not an exploit but a defect that manifests during legitimate governance activities. Participants attempting normal fee governance will encounter this issue.

### Recommendation

**1. Add Required State Variables** to `NFTContractState.cs`:
```csharp
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**2. Implement Proper SetMethodFee Logic** following the pattern from other system contracts:
- Validate input fees (token validity, non-negative amounts)
- Initialize method fee controller if not set (defaulting to Parliament default organization)
- Assert sender authorization: `Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.")`
- Store fees in state: `State.TransactionFees[input.MethodName] = input`

**3. Fix GetMethodFee** to return stored fees from state instead of hardcoded values, maintaining the hardcoded "Create" fee as a default if no custom fee is set

**4. Fix GetMethodFeeController** to properly initialize and return the controller authority info

**5. Add Comprehensive Tests** covering:
- Successful fee updates through Parliament proposals
- Unauthorized direct call rejection
- Invalid input validation (negative amounts, invalid tokens)
- Fee persistence verification after updates

Reference the complete test patterns in [9](#0-8) 

### Proof of Concept

**Initial State**: NFT contract deployed with default ACS1 implementation

**Step 1**: Governance participant creates proposal to update "Create" method fee from 100 ELF to 50 ELF
```
CreateProposal(
  ToAddress: NFTContractAddress,
  ContractMethodName: "SetMethodFee",
  Params: MethodFees { MethodName: "Create", Fees: [{ Symbol: "ELF", BasicFee: 50_00000000 }] }
)
```

**Step 2**: Block producers approve proposal (reaching threshold)

**Step 3**: Proposer releases proposal - **transaction succeeds**

**Step 4**: Query current fee: `GetMethodFee("Create")`

**Expected Result**: Fee should be 50 ELF (5000000000)

**Actual Result**: Fee remains 100 ELF (10000000000) - the hardcoded value [10](#0-9) 

**Verification**: The `SetMethodFee` execution returns success [1](#0-0)  without any state changes, and subsequent queries continue returning the original hardcoded fee value.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
ï»¿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Parliament/ParliamentState.cs (L23-26)
```csharp
    public MappedState<string, MethodFees> TransactionFees { get; set; }

    public SingletonState<ProposerWhiteList> ProposerWhiteList { get; set; }
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L80-96)
```csharp
    private async Task<Hash> CreateProposalAsync(Address contractAddress, Address organizationAddress,
        string methodName, IMessage input)
    {
        var proposal = new CreateProposalInput
        {
            OrganizationAddress = organizationAddress,
            ContractMethodName = methodName,
            ExpiredTime = TimestampHelper.GetUtcNow().AddHours(1),
            Params = input.ToByteString(),
            ToAddress = contractAddress
        };

        var createResult = await ParliamentContractStub.CreateProposal.SendAsync(proposal);
        var proposalId = createResult.Output;

        return proposalId;
    }
```

**File:** test/AElf.Contracts.MultiToken.Tests/BVT/ACS1_ImplementTest.cs (L130-232)
```csharp
    public async Task SetMethodFee_Success_Test()
    {
        var methodName = "Transfer";
        var tokenSymbol = NativeTokenInfo.Symbol;
        var basicFee = 100;
        var methodFeeController = await TokenContractStub.GetMethodFeeController.CallAsync(new Empty());
        var proposalMethodName = nameof(TokenContractStub.SetMethodFee);
        var methodFees = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
            }
        };
        var proposalId = await CreateProposalAsync(TokenContractAddress,
            methodFeeController.OwnerAddress, proposalMethodName, methodFees);
        await ApproveWithMinersAsync(proposalId);
        var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
        releaseResult.TransactionResult.Error.ShouldBeNullOrEmpty();
        releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var afterUpdateMethodFees = await TokenContractStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = methodName
        });
        var tokenFee = afterUpdateMethodFees.Fees.SingleOrDefault(x => x.Symbol == tokenSymbol);
        tokenFee.BasicFee.ShouldBe(basicFee);
    }

    [Fact]
    public async Task SetMethodFee_Fail_Test()
    {
        var tokenSymbol = NativeTokenInfo.Symbol;
        var methodName = "Transfer";
        // unauthorized
        {
            var basicFee = 100;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Unauthorized to set method fee");
        }

        // invalid fee
        {
            var basicFee = 0;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenSymbol, BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Invalid amount");
        }

        //invalid token symbol
        {
            var basicFee = 100;
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = "NOTEXIST", BasicFee = basicFee }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain("Token is not found");
        }

        // token is not profitable
        {
            var tokenNotProfitable = "DLS";
            await CreateMutiTokenAsync(TokenContractStub,new CreateInput
            {
                Symbol = tokenNotProfitable,
                TokenName = "name",
                Issuer = DefaultAddress,
                Owner = DefaultAddress,
                TotalSupply = 1000_000
            });
            var methodFees = new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee { Symbol = tokenNotProfitable, BasicFee = 100 }
                }
            };
            var ret = await TokenContractStub.SetMethodFee.SendWithExceptionAsync(methodFees);
            ret.TransactionResult.Error.ShouldContain($"Token {tokenNotProfitable} cannot set as method fee.");
        }
    }
```
