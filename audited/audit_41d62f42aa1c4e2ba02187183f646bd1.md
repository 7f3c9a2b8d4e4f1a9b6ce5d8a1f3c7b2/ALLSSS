# Audit Report

## Title
NextTerm Round Validation Bypass via RoundIdForValidation Manipulation Leading to Consensus DoS

## Summary
A malicious miner can bypass critical time-slot validation during term transitions by manipulating the `RoundIdForValidation` field in `NextTermInput`. This allows storing a malformed consensus round without `ExpectedMiningTime` values to chain state, causing a permanent denial of service on the entire consensus mechanism.

## Finding Description

The vulnerability exists in the interaction between round creation, the `RoundId` property fallback logic, and validation checks during NextTerm transitions.

**Root Cause:**

The `NextTermInput.Create()` method directly copies the mutable `RoundIdForValidation` field from the source round without validation. [1](#0-0) 

**Exploitable Fallback Logic:**

The `Round.RoundId` property computes the round ID as the sum of all miners' `ExpectedMiningTime.Seconds` when available. If any miner lacks `ExpectedMiningTime`, it falls back to the `RoundIdForValidation` field. [2](#0-1) 

**Validation Bypass:**

The `TimeSlotValidationProvider` only invokes `CheckRoundTimeSlots()` when it detects a NEW round by comparing `ProvidedRound.RoundId != BaseRound.RoundId`. An attacker can make these equal by:
1. Crafting a Round with no `ExpectedMiningTime` set (causing `RoundId` to fall back to `RoundIdForValidation`)
2. Setting `RoundIdForValidation` to match the current round's `RoundId`
3. This makes the validation incorrectly treat it as the same round, skipping `CheckRoundTimeSlots()` [3](#0-2) 

**Missing Structural Validation:**

The `RoundTerminateValidationProvider` for NextTerm only validates round/term number incrementing and `InValue` nullability. It does NOT validate that `ExpectedMiningTime` is properly set for all miners. [4](#0-3) 

**Legitimate Round Structure:**

Legitimate rounds generated via `GenerateFirstRoundOfNewTerm()` always populate `ExpectedMiningTime` for all miners but leave `RoundIdForValidation` at its default value (0), making them distinguishable from current rounds. [5](#0-4) 

**Malformed Round Persistence:**

The malformed round bypasses validation and is stored to state via `ProcessNextTerm()` which calls `AddRoundInformation()`. [6](#0-5) 

## Impact Explanation

**Complete Consensus Halt:**

Once the malformed round is stored, the consensus mechanism becomes permanently broken:

1. **Mining Interval Calculation Fails:** The `GetMiningInterval()` method requires `ExpectedMiningTime` for the first two miners. Without these values, attempting to calculate the interval will cause a null reference exception. [7](#0-6) 

This method is used extensively in consensus command generation strategies. [8](#0-7) 

2. **Time Slot Validation Fails:** Any subsequent attempt to validate rounds via `CheckRoundTimeSlots()` explicitly checks for null `ExpectedMiningTime` and returns a validation failure. [9](#0-8) 

**Severity:** HIGH - The entire blockchain network becomes non-operational. All block production halts, requiring manual chain intervention (hard fork or state recovery) to restore functionality. This affects all nodes, all transactions, and all dependent systems.

## Likelihood Explanation

**Attacker Requirements:**

The attacker must be a current or previous miner, as verified by `PreCheck()`. [10](#0-9) 

This is a realistic threat model - malicious miners are a known concern in consensus systems.

**Attack Complexity:** LOW

The attacker needs to:
1. Query the current round's `RoundId` (public state)
2. Craft a `NextTermInput` protobuf message with:
   - `RoundNumber` = current + 1 (passes validation)
   - `TermNumber` = current + 1 (passes validation)
   - `RealTimeMinersInformation` with miner entries but NO `ExpectedMiningTime` values
   - `RoundIdForValidation` = current round's `RoundId` value
3. Submit via the `NextTerm()` public method during their valid time slot

**No Economic Barriers:** The attack requires only one malicious transaction. There is no staking loss, slashing, or financial cost to the attacker.

**Detection Difficulty:** The malformed round passes all validation checks before execution. The consensus break only becomes apparent when subsequent operations attempt to use the malformed round data.

## Recommendation

**Fix 1: Validate ExpectedMiningTime in NextTerm Validation**

Add explicit validation in `RoundTerminateValidationProvider.ValidationForNextTerm()` to ensure all miners have `ExpectedMiningTime` set:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate ExpectedMiningTime is set for all miners
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = "ExpectedMiningTime must be set for all miners in NextTerm." };
    
    return new ValidationResult { Success = true };
}
```

**Fix 2: Use Computed RoundId in NextTermInput.Create()**

Modify `NextTermInput.Create()` to use the computed `RoundId` property instead of copying `RoundIdForValidation`:

```csharp
public static NextTermInput Create(Round round, ByteString randomNumber)
{
    return new NextTermInput
    {
        RoundNumber = round.RoundNumber,
        RealTimeMinersInformation = { round.RealTimeMinersInformation },
        ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
        BlockchainAge = round.BlockchainAge,
        TermNumber = round.TermNumber,
        ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
        ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
        IsMinerListJustChanged = round.IsMinerListJustChanged,
        RoundIdForValidation = round.RoundId, // Use computed property
        MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
        RandomNumber = randomNumber
    };
}
```

**Fix 3: Mandatory Time Slot Validation for NextTerm**

Add a specific check in `TimeSlotValidationProvider` to always validate time slots for NextTerm behaviour regardless of RoundId comparison:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // For NextTerm, always validate time slots
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextTerm)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    else
    {
        // Existing time slot check logic...
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NextTerm_RoundIdValidationBypass_ConsensusDoS()
{
    // Setup: Initialize consensus with valid round
    var initialMiners = GenerateInitialMiners(3);
    await InitializeConsensus(initialMiners);
    
    // Get current round information
    var currentRound = await GetCurrentRoundInformation();
    var currentRoundId = currentRound.RoundId; // Sum of ExpectedMiningTime.Seconds
    
    // Attacker: Craft malicious NextTermInput
    var maliciousNextTermInput = new NextTermInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber + 1,
        RoundIdForValidation = currentRoundId, // Set to match current round
        // Add miners but WITHOUT ExpectedMiningTime
        RealTimeMinersInformation = 
        {
            { "miner1", new MinerInRound { Pubkey = "miner1", Order = 1 } },
            { "miner2", new MinerInRound { Pubkey = "miner2", Order = 2 } },
            { "miner3", new MinerInRound { Pubkey = "miner3", Order = 3 } }
        },
        RandomNumber = ByteString.CopyFrom(GenerateRandomNumber())
    };
    
    // Execute: Submit malicious NextTerm (should fail but doesn't)
    var result = await ConsensusContract.NextTerm(maliciousNextTermInput);
    result.ShouldNotBeNull(); // Transaction succeeds
    
    // Verify: Malformed round is stored
    var newRound = await GetCurrentRoundInformation();
    newRound.RoundNumber.ShouldBe(currentRound.RoundNumber + 1);
    newRound.TermNumber.ShouldBe(currentRound.TermNumber + 1);
    newRound.RealTimeMinersInformation.Values.All(m => m.ExpectedMiningTime == null).ShouldBeTrue();
    
    // Impact: Consensus operations now fail
    Should.Throw<NullReferenceException>(() => newRound.GetMiningInterval());
    
    var timeSlotValidation = newRound.CheckRoundTimeSlots();
    timeSlotValidation.Success.ShouldBeFalse();
    timeSlotValidation.Message.ShouldContain("Incorrect expected mining time");
    
    // Consensus is now permanently broken - no more blocks can be produced
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L19-19)
```csharp
            RoundIdForValidation = round.RoundIdForValidation,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L40-41)
```csharp
        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-81)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L32-33)
```csharp
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```
