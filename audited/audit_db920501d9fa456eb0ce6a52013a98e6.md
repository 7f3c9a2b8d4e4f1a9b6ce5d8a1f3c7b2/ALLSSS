### Title
Cross-Miner PreviousInValue Injection via Insufficient Validation in UpdateValueValidationProvider

### Summary
The `ValidatePreviousInValue()` function only validates the block producer's own `PreviousInValue`, but does not validate `PreviousInValue` entries for other miners that can be included in the consensus Round data. A malicious miner can inject arbitrary `PreviousInValue` values for other miners, which are then persisted to state without validation, potentially disrupting the secret sharing mechanism, signature calculation, and random number generation in the AEDPoS consensus system.

### Finding Description

The vulnerability exists in the validation flow for UpdateValue consensus behavior:

**Location 1 - Insufficient Validation:** [1](#0-0) 

The `ValidatePreviousInValue()` function only validates the sender's `PreviousInValue` by checking if `hash(previousInValue) == previousOutValue` for the `SenderPubkey`. However, it does not validate `PreviousInValue` entries for OTHER miners that may be present in `extraData.Round.RealTimeMinersInformation`.

**Location 2 - Unvalidated Data Copying:** [2](#0-1) 

During validation, `RecoverFromUpdateValue()` copies `PreviousInValue` for ALL miners from the provided round to the base round, regardless of whether these values have been validated.

**Location 3 - State Persistence:** [3](#0-2) 

During execution, `PerformSecretSharing()` updates the state with `PreviousInValue` entries from `MinersPreviousInValues` for ALL miners in the map, persisting unvalidated data.

**Location 4 - Data Propagation:** [4](#0-3) 

The `ExtractInformationToUpdateConsensus()` method collects ALL miners' `PreviousInValue` entries from the Round and includes them in the `UpdateValueInput`.

**Location 5 - Conditional Overwrite Prevention:** [5](#0-4) 

When generating consensus extra data, miners can only fill in `PreviousInValue` for other miners if the field is Empty or null. Once a malicious miner sets an incorrect value, honest miners cannot overwrite it.

### Impact Explanation

**Consensus Integrity Violation:**
A malicious miner can corrupt the `PreviousInValue` field for other miners in the current round's state. This has several cascading effects:

1. **Secret Sharing Disruption:** The `PreviousInValue` is part of the secret sharing mechanism for random number generation. Corrupting these values prevents the correct reveal process, as shown here: [5](#0-4) 

2. **Signature Calculation Manipulation:** The `PreviousInValue` is used in signature calculation which determines mining order for the next round: [6](#0-5) 

3. **Persistent State Corruption:** The incorrect values are persisted to state and cannot be overwritten by honest miners due to the conditional check.

**Affected Parties:**
- All miners in the consensus round whose `PreviousInValue` is corrupted
- The entire network's consensus integrity and random number generation mechanism

**Severity Justification:**
HIGH - While this doesn't directly steal funds, it compromises the consensus mechanism's integrity, which is a critical invariant. It can lead to manipulation of mining order, disruption of random number generation, and potential denial of service for affected miners.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a valid miner in the current round (able to produce blocks)
- No special permissions beyond normal miner status required

**Attack Complexity:**
- LOW - The attack is straightforward to execute:
  1. When producing a block with UpdateValue behavior, include correct `PreviousInValue` for self
  2. Include arbitrary/incorrect `PreviousInValue` entries for other miners in the `MinersPreviousInValues` map
  3. The validation only checks the attacker's own value, allowing the malicious data through

**Feasibility:**
The attack is highly feasible because:
- Entry point is the standard `UpdateValue` method which any miner can call [7](#0-6) 
- The validation flow is called before execution as shown: [8](#0-7) 
- No additional checks prevent including multiple miners' data

**Detection:**
- Difficult to detect in real-time as the malicious data passes validation
- Would require post-analysis of round state to identify corrupted `PreviousInValue` entries

### Recommendation

**Code-Level Mitigation:**
Modify `ValidatePreviousInValue()` to validate `PreviousInValue` for ALL miners present in `extraData.Round.RealTimeMinersInformation`, not just the sender:

```csharp
private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate PreviousInValue for ALL miners in the provided round
    foreach (var minerInfo in extraData.Round.RealTimeMinersInformation)
    {
        var publicKey = minerInfo.Key;
        var providedMinerInRound = minerInfo.Value;
        
        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
            continue;
            
        if (providedMinerInRound.PreviousInValue == null || 
            providedMinerInRound.PreviousInValue == Hash.Empty)
            continue;
        
        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        
        if (HashHelper.ComputeFrom(providedMinerInRound.PreviousInValue) != previousOutValue)
            return false;
    }
    
    return true;
}
```

**Invariant Check:**
Add assertion: "For every miner in the provided Round with a non-empty PreviousInValue, hash(PreviousInValue) must equal the miner's OutValue from the previous round."

**Test Cases:**
1. Test that validation rejects a block where sender provides correct PreviousInValue but incorrect PreviousInValue for another miner
2. Test that validation accepts a block where all miners' PreviousInValues correctly hash to their previous OutValues
3. Test that validation properly handles miners not present in previous round

### Proof of Concept

**Initial State:**
- Network has miners A, B, C in current round N
- Previous round N-1 exists with all miners having produced blocks
- Miner B has OutValue = hash(B_InValue) in round N-1

**Attack Steps:**
1. Malicious miner A produces a block with UpdateValue behavior
2. In the consensus extra data Round object, miner A includes:
   - Their own correct `PreviousInValue` = A_InValue (hashes to A's OutValue from round N-1)
   - Miner B's INCORRECT `PreviousInValue` = random_hash (does NOT hash to B's OutValue from round N-1)
3. Block validation calls `ValidatePreviousInValue()` which only checks miner A's value - passes âœ“
4. Block is accepted and executed
5. `PerformSecretSharing()` persists the incorrect PreviousInValue for miner B to state
6. In subsequent rounds, honest miners cannot correct this value due to the null/Empty check

**Expected Result:**
Validation should reject the block for containing invalid PreviousInValue for miner B

**Actual Result:**
Block is accepted, and miner B's PreviousInValue is corrupted in state, disrupting secret sharing and potentially affecting mining order calculation

**Success Condition:**
State inspection shows miner B's PreviousInValue in round N does not hash to miner B's OutValue from round N-1, confirming the corruption persisted.

### Notes

The vulnerability stems from a mismatch between the validation scope (single miner) and the data persistence scope (all miners). While the sender's public key is cryptographically verified against the block signer [9](#0-8) , this only ensures the sender's identity, not the validity of data they provide about OTHER miners.

The RecoverFromUpdateValue method is called during BOTH validation and after-execution verification [10](#0-9) , but neither flow validates the cross-miner data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L32-32)
```csharp
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-92)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());
```
