### Title
Zero Transaction Fee Validation Allows Spam and Resource Exhaustion Attacks

### Summary
The Configuration contract (and 13 other system contracts) allows method fees to be set to zero via inadequate validation in `AssertValidToken`. When combined with `IsSizeFeeFree=true`, critical methods can be called unlimited times with zero cost, enabling resource exhaustion and denial-of-service attacks on the blockchain network.

### Finding Description

**Root Cause:**

The `AssertValidToken` method in Configuration contract validates fee amounts with `amount >= 0`, explicitly permitting zero fees: [1](#0-0) 

This contrasts with the TokenContract's stricter validation that requires `amount > 0`: [2](#0-1) 

**Missing Validation:**

The `SetMethodFee` method accepts a `MethodFees` input containing both fee amounts and the `IsSizeFeeFree` boolean flag, but performs no validation preventing the dangerous combination of zero base fees AND size-fee exemption: [3](#0-2) 

The `MethodFees` structure allows this combination: [4](#0-3) 

**Exploitation Path:**

When fees are charged, the system checks if base fees exist and if size fees should be applied: [5](#0-4) 

With zero base fees and `IsSizeFeeFree=true`, both charging steps succeed without deducting any tokens, allowing unlimited free transactions.

**Affected Contracts:**

All system contracts except TokenContract are vulnerable, as confirmed by the consistent use of `amount >= 0` validation: [6](#0-5) [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact:**

Once method fees are set to zero with `IsSizeFeeFree=true`, any user can invoke affected methods unlimited times without cost, causing:

1. **CPU Exhaustion**: Continuous transaction processing overwhelms nodes
2. **Memory Saturation**: Transaction pools fill with zero-cost spam
3. **Storage Bloat**: State writes from repeated method calls (if authorized)
4. **Network Flooding**: Bandwidth consumed by spam transaction propagation
5. **Blockchain DoS**: Legitimate transactions cannot be processed

**Critical Methods at Risk:**

- `SetConfiguration` - could spam configuration changes (if authorized)
- Parliament/Association governance methods - proposal spam
- Consensus methods - potential consensus disruption
- Economic/Treasury methods - reward distribution interference

**Severity Justification:**

HIGH severity due to:
- System-wide scope (14 vulnerable contracts)
- Network-level impact (affects all nodes)
- Zero exploit cost once fees are set
- Breaks fundamental spam protection mechanism

### Likelihood Explanation

**Attack Prerequisites:**

1. Governance (Parliament) must approve a proposal to call `SetMethodFee`
2. Proposal sets `BasicFee=0` for all fee entries AND `IsSizeFeeFree=true`
3. This could occur through:
   - Malicious governance action
   - Accidental misconfiguration
   - Compromised governance participants

**Execution Practicality:**

Once fees are set to zero:
- **Attacker capability**: Any user with network access
- **Technical complexity**: Trivial (send standard transactions)
- **Cost**: Zero tokens required
- **Detection**: Difficult until resource exhaustion occurs
- **Mitigation**: Requires another governance action to restore fees

**Feasibility Conditions:**

The governance barrier is moderate but realistic:
- Parliament default organization requires majority approval
- Historical precedent shows governance does modify fees
- No runtime protection exists once fees are set

**Probability Assessment:**

Medium-to-High likelihood:
- Governance regularly adjusts fees for operational reasons
- Zero fees might be set intentionally for "free" methods
- Without validation, accidental misconfiguration is possible
- Once set, exploitation is inevitable (zero cost, high reward for attackers)

### Recommendation

**Immediate Fix - Add Validation in SetMethodFee:**

Modify all `AssertValidToken` implementations (except TokenContract) to require `amount > 0`:

```diff
- Assert(amount >= 0, "Invalid amount.");
+ Assert(amount > 0, "Invalid amount. Zero fees are not allowed.");
```

Apply this change to all 14 vulnerable contracts.

**Additional Safeguard - Prevent Dangerous Combination:**

Add validation in `SetMethodFee` to prevent zero fees with size-fee exemption:

```csharp
if (input.IsSizeFeeFree)
{
    Assert(input.Fees.Any() && input.Fees.All(f => f.BasicFee > 0), 
        "Methods with IsSizeFeeFree must have non-zero base fees.");
}
```

**Invariant Checks:**

1. All method fees must be > 0 (not >= 0)
2. Methods with `IsSizeFeeFree=true` must have substantial base fees
3. Critical governance/consensus methods must maintain minimum fee thresholds

**Test Cases:**

1. Verify `SetMethodFee` rejects `BasicFee=0`
2. Verify `SetMethodFee` rejects `IsSizeFeeFree=true` with zero fees
3. Test that zero-fee attempts result in "Invalid amount" error
4. Regression test for Configuration, Parliament, and other critical contracts

### Proof of Concept

**Initial State:**
- Parliament governance controls MethodFeeController
- Configuration contract deployed and initialized

**Attack Steps:**

1. **Setup Zero Fees (via Governance):**
   ```
   Parliament.CreateProposal(
     SetMethodFee {
       MethodName = "SetConfiguration",
       Fees = [{ Symbol = "ELF", BasicFee = 0 }],
       IsSizeFeeFree = true
     }
   )
   ```

2. **Approve and Execute Proposal:**
   - Parliament members approve
   - Proposal executes successfully
   - Validation passes: `amount >= 0` check succeeds

3. **Verify Fee Configuration:**
   ```
   GetMethodFee("SetConfiguration")
   Returns: { Fees: [{ Symbol: "ELF", BasicFee: 0 }], IsSizeFeeFree: true }
   ```

4. **Exploit - Spam Transactions:**
   ```
   For i = 1 to 10000:
     Configuration.SetConfiguration(key="spam_key_" + i, value="spam")
   ```

5. **Expected vs Actual Result:**
   - **Expected**: Each transaction costs ELF tokens (base fee + size fee)
   - **Actual**: Zero tokens charged, all transactions succeed for free
   - **Outcome**: Network flooded, nodes overwhelmed, blockchain DoS

**Success Condition:**

Attacker sends unlimited transactions without token deduction, confirmed by checking balance before/after attack remains unchanged while thousands of transactions are processed.

### Notes

The vulnerability exists due to a design inconsistency: **TokenContract correctly uses `amount > 0`**, but all other system contracts use `amount >= 0`. This suggests the stricter validation was intended but not consistently applied across the codebase.

The issue is particularly severe because it affects critical infrastructure contracts (Parliament, Consensus, Economic, Configuration) that control core blockchain functionality. While governance must initially set zero fees, once configured, exploitation requires no special privileges and costs nothing.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L79-81)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** protobuf/acs1.proto (L40-46)
```text
message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L268-299)
```csharp
    private bool ChargeTransactionFeesToBill(ChargeTransactionFeesInput input, Address fromAddress,
        ref TransactionFeeBill bill,
        ref TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee, bool isSizeFeeFree = false,
        TransactionFeeDelegations delegations = null)
    {
        var successToChargeBaseFee = true;

        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L82-82)
```csharp
        Assert(amount >= 0, "Invalid amount.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L92-92)
```csharp
        Assert(amount >= 0, "Invalid amount.");
```

**File:** contract/AElf.Contracts.Economic/EconomicContract_ACS1_TransactionFeeProvider.cs (L80-80)
```csharp
        Assert(amount >= 0, "Invalid amount.");
```
