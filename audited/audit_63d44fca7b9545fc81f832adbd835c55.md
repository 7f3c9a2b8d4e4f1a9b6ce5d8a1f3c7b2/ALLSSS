### Title
Consensus Behavior Validation Bypass Allows Indefinite Term Change Prevention

### Summary
The consensus validation system validates that block data is consistent with the claimed behavior (NextRound vs NextTerm) but never independently verifies that the claimed behavior matches what consensus rules require. A malicious miner can produce NextRound blocks when NextTerm is required, bypassing term transitions and preventing election results from taking effect, miner list updates, and reward distributions.

### Finding Description

The vulnerability exists in the validation flow between behavior determination and validation:

**Behavior Determination Logic:** [1](#0-0) 

This method determines whether to return `NextRound` or `NextTerm` based on `NeedToChangeTerm()`. The method returns `NextTerm` when `NeedToChangeTerm()` returns true (unless it's round 1 or single node). [2](#0-1) 

`NeedToChangeTerm()` checks if 2/3 of miners have mining times that meet the term change threshold based on elapsed time.

**Validation Logic Gap:** [3](#0-2) 

The validation adds different providers based on the CLAIMED behavior from `extraData.Behaviour`, not based on what the behavior SHOULD be according to consensus rules. [4](#0-3) 

`RoundTerminateValidationProvider` validates based on the claimed behavior:
- For `NextRound`: only validates round number increment and InValues are null
- For `NextTerm`: validates round number, InValues, AND term number increment

**Critical Gap:** The validator never calls `NeedToChangeTerm()` to verify the behavior choice was correct. It only validates consistency with the claimed behavior.

**Execution Without Additional Validation:** [5](#0-4) [6](#0-5) 

Neither `ProcessNextRound` nor `ProcessNextTerm` validate that the chosen behavior matches consensus requirements. They execute based on the claimed behavior.

### Impact Explanation

**Consensus Integrity Violation - HIGH Impact:**

When a malicious miner bypasses term changes by claiming NextRound when NextTerm is required:

1. **Election Results Not Applied**: New miners elected through governance cannot join the consensus
2. **Miner List Frozen**: The miner list cannot be updated per election results, allowing current miners to maintain control indefinitely
3. **Reward Distribution Disrupted**: Mining rewards and treasury releases tied to term boundaries are not distributed [7](#0-6) 

4. **Election Snapshots Not Taken**: Historical voting records are not properly captured [8](#0-7) 

5. **Governance System Compromised**: The entire election and governance mechanism becomes ineffective as voted changes never take effect

This affects all network participants and fundamentally breaks the democratic consensus mechanism of AEDPoS.

### Likelihood Explanation

**HIGH Likelihood:**

**Reachable Entry Point:** [9](#0-8) 

Any miner can produce a NextRound block by calling the public `NextRound` method.

**Feasible Preconditions:**
- Blockchain state where `NeedToChangeTerm()` would return true (2/3 miners have reached term change threshold)
- Malicious miner in current miner list

**Execution Practicality:**
- Attacker modifies their node to generate NextRound blocks instead of NextTerm when term change is required
- Block passes validation because validators only check consistency with claimed NextRound behavior
- No cryptographic operations or complex state manipulation required

**Detection Difficulty:**
- Validation at kernel level simply calls the contract's validation method [10](#0-9) 

- No additional checks exist to catch behavior choice mismatches

**Economic Rationality:**
- Incumbent miners benefit from preventing term changes to maintain mining rewards
- Attack cost is negligible (just modify block behavior)
- Benefit is significant (continued mining revenue and governance control)

### Recommendation

**Add Behavior Requirement Validation:**

Modify `RoundTerminateValidationProvider` to independently verify that the claimed behavior matches consensus requirements:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // NEW: Validate behavior choice is correct
    var blockchainStartTimestamp = GetBlockchainStartTimestamp(); // Need to pass this
    var periodSeconds = GetPeriodSeconds(); // Need to pass this
    
    var needsTermChange = validationContext.BaseRound.NeedToChangeTerm(
        blockchainStartTimestamp, 
        validationContext.CurrentTermNumber, 
        periodSeconds);
    
    // Validate behavior matches requirements (skip for round 1 and single node)
    if (validationContext.BaseRound.RoundNumber > 1 && 
        validationContext.BaseRound.RealTimeMinersInformation.Count > 1)
    {
        if (needsTermChange && extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Message = "Term change is required but NextRound behavior claimed." };
        
        if (!needsTermChange && extraData.Behaviour == AElfConsensusBehaviour.NextTerm)
            return new ValidationResult { Message = "Term change is not required but NextTerm behavior claimed." };
    }
    
    // Continue with existing validation
    if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) 
        return ValidationForNextRound(validationContext);
    if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) 
        return ValidationForNextTerm(validationContext);
    
    return new ValidationResult { Success = true };
}
```

**Pass Required Context:**

Extend `ConsensusValidationContext` to include blockchain start timestamp and period seconds: [11](#0-10) 

**Add Test Cases:**
- Test that NextRound blocks are rejected when `NeedToChangeTerm()` returns true
- Test that NextTerm blocks are rejected when `NeedToChangeTerm()` returns false
- Test edge cases around term boundaries with various miner counts

### Proof of Concept

**Initial State:**
1. Blockchain running with current term number = 1
2. Period seconds = 604800 (7 days)
3. Sufficient time has passed that 2/3 of miners' latest ActualMiningTime meets term change threshold
4. `NeedToChangeTerm()` would return true

**Attack Sequence:**
1. Malicious miner's node reaches point where `GetConsensusBehaviour()` should return `NextTerm`
2. Attacker modifies their node code to force `NextRound` behavior instead
3. Attacker produces block with:
   - `extraData.Behaviour = AElfConsensusBehaviour.NextRound`
   - Round number = current + 1
   - Term number = unchanged (still 1)
   - InValues = null
4. Block validation executes:
   - `ValidateBeforeExecution` reads `extraData.Behaviour = NextRound`
   - Adds `RoundTerminateValidationProvider` to validators
   - `RoundTerminateValidationProvider.ValidateHeaderInformation()` sees NextRound behavior
   - Calls `ValidationForNextRound()` which only checks round number and InValues
   - **Never calls `NeedToChangeTerm()` to verify behavior choice**
   - Validation passes âœ“
5. `ProcessNextRound` executes, incrementing round number but NOT term number
6. Term change bypassed - election results not applied, miner list not updated

**Expected vs Actual:**
- **Expected:** Block rejected with "Term change is required" error
- **Actual:** Block accepted, term change bypassed, miner list frozen

**Success Condition:** 
After attack, verify:
- Round number incremented
- Term number unchanged (still 1)
- Miner list not updated with election results
- Treasury release not triggered

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-223)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L10-47)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusValidationProvider.cs (L58-78)
```csharp
    public async Task<bool> ValidateBlockBeforeExecuteAsync(IBlock block)
    {
        if (block.Header.Height == AElfConstants.GenesisBlockHeight)
            return true;

        var consensusExtraData = _consensusExtraDataExtractor.ExtractConsensusExtraData(block.Header);
        if (consensusExtraData == null || consensusExtraData.IsEmpty)
        {
            Logger.LogDebug($"Invalid consensus extra data {block}");
            return false;
        }

        var isValid = await _consensusService.ValidateConsensusBeforeExecutionAsync(new ChainContext
        {
            BlockHash = block.Header.PreviousBlockHash,
            BlockHeight = block.Header.Height - 1
        }, consensusExtraData.ToByteArray());
        if (!isValid) return false;

        return ValidateTransactionCount(block);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L8-41)
```csharp
public class ConsensusValidationContext
{
    public long CurrentTermNumber { get; set; }
    public long CurrentRoundNumber { get; set; }

    /// <summary>
    ///     We can trust this because we already validated the pubkey
    ///     during `AEDPoSExtraDataExtractor.ExtractConsensusExtraData`
    /// </summary>
    public string SenderPubkey => ExtraData.SenderPubkey.ToHex();

    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;

    /// <summary>
    ///     Previous round information fetch from StateDb.
    /// </summary>
    public Round PreviousRound { get; set; }

    /// <summary>
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }

    public AElfConsensusHeaderInformation ExtraData { get; set; }
}
```
