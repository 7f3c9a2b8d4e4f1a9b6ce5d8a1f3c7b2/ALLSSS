# Audit Report

## Title
Consensus Behavior Substitution Allows Miners to Bypass Cryptographic Value Publication

## Summary
A miner producing their first block in a round can incorrectly use `TinyBlock` behavior instead of the required `UpdateValue` behavior, avoiding publication of essential consensus values (OutValue, Signature, PreviousInValue). This breaks the consensus randomness mechanism and creates inconsistent state where miners produce blocks without contributing to the cryptographic chain.

## Finding Description

The AEDPoS consensus system defines two distinct block production behaviors with different cryptographic requirements. The `UpdateValue` behavior is used when a miner produces their first block in a round and requires publishing OutValue, Signature, and PreviousInValue fields. [1](#0-0)  The `TinyBlock` behavior is used for subsequent blocks within the same time slot and excludes these cryptographic fields. [2](#0-1) 

The vulnerability exists because the validation logic does not enforce that miners with `OutValue == null` must use `UpdateValue` behavior. During validation, the system recovers round state based on the **claimed** behavior without verifying the behavior is correct for the miner's state. [3](#0-2) 

When a miner submits TinyBlock behavior, the `UpdateValueValidationProvider` is never added to the validation pipeline, allowing the transaction to bypass OutValue and Signature validation. [4](#0-3) 

The `RecoverFromTinyBlock` function only copies `ActualMiningTimes` and `ImpliedIrreversibleBlockHeight`, completely ignoring OutValue, Signature, and PreviousInValue. [5](#0-4) 

During processing, `ProcessTinyBlock` only updates block production counters without setting any consensus cryptographic values. [6](#0-5)  Since `ApplyNormalConsensusData` is never called, the miner's `SupposedOrderOfNextRound` field remains at its default value of 0. [7](#0-6) 

## Impact Explanation

This vulnerability creates a critical consensus integrity breach with multiple cascading effects:

**State Inconsistency**: Miners can produce blocks (incrementing `ProducedBlocks` counter) while their OutValue, Signature, and PreviousInValue remain null, violating the fundamental invariant that block production requires cryptographic commitment.

**Next Round Misclassification**: During next round generation, the `GetMinedMiners()` function identifies miners by checking `SupposedOrderOfNextRound != 0`. [8](#0-7)  Miners who exploited this vulnerability are instead included in `GetNotMinedMiners()` [9](#0-8)  and incorrectly receive a `MissedTimeSlots` penalty despite having produced blocks.

**Randomness Degradation**: The extra block producer selection mechanism relies on signature availability to calculate randomized mining order. [10](#0-9)  If multiple miners exploit this vulnerability, the system may have no signatures to work with, defaulting to a predictable order 1 assignment, severely compromising consensus randomness.

**Cryptographic Chain Break**: The consensus protocol's commit-reveal scheme for randomness generation depends on the continuous chain of OutValue/Signature pairs. Missing values create gaps in this chain, preventing proper randomness contribution and potentially enabling manipulation of future block producer ordering.

## Likelihood Explanation

**Attacker Prerequisites**: The attacker must be a legitimate consensus miner with active block production rights. This is a reasonable assumption as the vulnerability targets miner behavior, not external attackers.

**Execution Simplicity**: Both `UpdateValue` and `UpdateTinyBlockInformation` are public methods callable by any miner. [11](#0-10)  The attack requires only sending a TinyBlock transaction instead of UpdateValue when OutValue is null - no complex state manipulation or timing attacks needed.

**Detection vs. Prevention**: While the attack is observable on-chain (miners with blocks produced but null consensus values), there is no preventive validation. The attacker does incur a penalty (MissedTimeSlots increment), but this creates a griefing scenario rather than a deterrent, as coordinated attacks by multiple miners could manipulate consensus randomness before penalties accumulate.

**Realistic Threat Scenario**: A malicious or compromised miner could exploit this during their first block in each round. More significantly, a coordinated attack by multiple miners could systematically degrade consensus randomness, making block producer ordering predictable or manipulable.

## Recommendation

Add validation in `ValidateBeforeExecution` to enforce correct behavior type based on miner state:

```csharp
// In ValidateBeforeExecution after line 50
if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
    
    // Enforce that TinyBlock can only be used if OutValue already exists
    var minerInRound = baseRound.RealTimeMinersInformation[extraData.SenderPubkey.ToHex()];
    if (minerInRound.OutValue == null)
    {
        return new ValidationResult 
        { 
            Success = false, 
            Message = "TinyBlock behavior cannot be used for first block in round. UpdateValue required." 
        };
    }
}
```

Alternatively, add a dedicated validation provider that checks behavior appropriateness:

```csharp
public class BehaviorCorrectnessValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        
        if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock && 
            minerInRound.OutValue == null)
        {
            return new ValidationResult 
            { 
                Success = false,
                Message = "Cannot use TinyBlock behavior when OutValue is null. UpdateValue required for first block."
            };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

Add this provider to the basic validation providers list before the behavior-specific switch statement.

## Proof of Concept

This vulnerability can be demonstrated by constructing a test where a miner with `OutValue == null` successfully calls `UpdateTinyBlockInformation` instead of `UpdateValue`, resulting in blocks being produced without consensus values being set and the miner being incorrectly classified in the next round.

The test would:
1. Initialize a round with a miner who has `OutValue == null`
2. Have that miner call `UpdateTinyBlockInformation` instead of `UpdateValue`
3. Verify the transaction succeeds despite being the wrong behavior
4. Verify `OutValue`, `Signature`, and `SupposedOrderOfNextRound` remain null/0
5. Generate the next round and verify the miner is incorrectly placed in `GetNotMinedMiners()` despite `ProducedBlocks > 0`

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L49-114)
```csharp
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }

        /// <summary>
        ///     If this miner come to a new round, normally, there are three possible behaviour:
        ///     UPDATE_VALUE (most common)
        ///     TINY_BLOCK (happens if this miner is mining blocks for extra block time slot of previous round)
        ///     NEXT_ROUND (only happens in first round)
        /// </summary>
        /// <returns></returns>
        private AElfConsensusBehaviour HandleMinerInNewRound()
        {
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;

            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;

            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L58-82)
```csharp
    public Round GetTinyBlockRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = minerInRound.Pubkey,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight
                }
            }
        };

        foreach (var otherPubkey in RealTimeMinersInformation.Keys.Except(new List<string> { pubkey }))
            round.RealTimeMinersInformation.Add(otherPubkey, new MinerInRound());

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L8-47)
```csharp
    public Round ApplyNormalConsensusData(string pubkey, Hash previousInValue, Hash outValue, Hash signature)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return this;

        RealTimeMinersInformation[pubkey].OutValue = outValue;
        RealTimeMinersInformation[pubkey].Signature = signature;
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;

        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L131-135)
```csharp
    private List<MinerInRound> GetNotMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound == 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-112)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }

    #endregion

    #region UpdateTinyBlockInformation

    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
