### Title
Scheme Manager Can Bypass Minimum Lock Period by Calling CreateScheme Multiple Times

### Summary
The `CreateScheme` method in TokenHolderContract lacks validation to prevent duplicate scheme creation by the same manager. A scheme manager can call `CreateScheme` again with a different `MinimumLockMinutes` value, which overwrites the stored scheme parameters. This allows manipulation of the withdrawal timelock for existing token lockers, either trapping them with longer lock periods or allowing premature withdrawal.

### Finding Description

The vulnerability exists in the `CreateScheme` method which does not check if a scheme already exists for the caller: [1](#0-0) 

The method directly overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without verifying if a scheme already exists. Each call to `CreateScheme` also creates a new Profit contract scheme due to how scheme IDs are generated: [2](#0-1) 

The scheme ID is generated based on the count of existing schemes for that manager, meaning each call creates a unique scheme in the Profit contract. However, the TokenHolder contract only stores one scheme per manager address.

When users lock tokens via `RegisterForProfits`, they are registered to the FIRST Profit scheme, and their lock timestamp is recorded: [3](#0-2) 

The critical issue occurs during withdrawal. The `Withdraw` method retrieves the scheme and uses its `MinimumLockMinutes` value to validate the withdrawal timing: [4](#0-3) 

When `GetValidScheme` is called, it reads the current `TokenHolderProfitSchemes` entry which may have been overwritten with a new `MinimumLockMinutes` value: [5](#0-4) 

The `UpdateTokenHolderProfitScheme` method updates the SchemeId to point to the FIRST Profit scheme (where users are still registered), but the `MinimumLockMinutes` field comes from the overwritten TokenHolder scheme: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact:**
- Users who locked tokens expecting a specific minimum lock duration (e.g., 100,000 minutes) can have their withdrawal timing manipulated
- If `MinimumLockMinutes` is reduced, users can withdraw prematurely, breaking the economic assumptions of long-term staking
- If `MinimumLockMinutes` is increased, users are trapped beyond their agreed lock period

**Economic Model Breach:**
- Profit distribution schemes rely on predictable token lock durations to ensure fair dividend allocation
- Early withdrawal allows users to claim profits without maintaining the expected commitment period
- This undermines the incentive alignment between scheme participants

**Trust Violation:**
- Users enter locks with explicit expectations about withdrawal timing based on the scheme's `MinimumLockMinutes`
- Unilateral modification by the scheme manager breaks this social contract
- Affects all existing lockers in the scheme simultaneously

**Severity Justification:**
HIGH - This vulnerability allows scheme managers to arbitrarily manipulate the fundamental lock duration parameter affecting all existing participants, potentially enabling early withdrawal of locked funds or indefinite fund trapping.

### Likelihood Explanation

**Reachable Entry Point:**
The `CreateScheme` method is publicly callable by any address without special permissions. The scheme manager (who initially created the scheme) can call it again.

**Attacker Capabilities:**
- Attacker must be the scheme manager (the address that called `CreateScheme` initially)
- No additional privileges or governance approvals required
- Standard transaction execution with normal gas costs

**Attack Complexity:**
LOW - The exploit requires only two simple transactions:
1. Initial `CreateScheme` call with original `MinimumLockMinutes`
2. Second `CreateScheme` call with modified `MinimumLockMinutes`

**Feasibility Conditions:**
- Users must have already locked tokens in the scheme
- Manager must still control the original address
- No external dependencies or race conditions required

**Detection Constraints:**
- The overwrite happens through a normal `CreateScheme` call
- No events specifically indicate parameter changes to existing schemes
- Users may not notice until attempting withdrawal

**Probability:**
HIGH - This is trivially exploitable by any scheme manager with malicious intent or even accidentally through operational error (e.g., attempting to "update" scheme parameters).

### Recommendation

**Immediate Fix:**
Add a duplicate scheme check in the `CreateScheme` method:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add this check
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager. Cannot create duplicate scheme.");
    
    // Rest of existing code...
}
```

**Alternative Approach (if updates are intended):**
If scheme parameter updates are a desired feature, implement a separate `UpdateScheme` method with proper safeguards:
- Prevent updates if any users have active locks
- Require a grace period or user consent mechanism
- Emit events when parameters change
- Store the `MinimumLockMinutes` value per lock rather than per scheme

**Invariant Checks:**
- Verify that each manager address maps to at most one TokenHolderProfitScheme
- Ensure `MinimumLockMinutes` at withdrawal time matches the value when the lock was created

**Test Cases:**
- Test calling `CreateScheme` twice with the same manager (should fail)
- Test withdrawal timing with original vs modified `MinimumLockMinutes`
- Test that existing locks are unaffected by new scheme creation attempts

### Proof of Concept

**Initial State:**
- Manager address: `0xManager`
- User address: `0xUser`
- Current block time: T = 1000 minutes

**Transaction Sequence:**

1. **Manager creates scheme with long lock period**
   - Call: `CreateScheme(symbol="ELF", MinimumLockMinutes=100000)`
   - Sender: `0xManager`
   - Result: Profit SchemeA created, `TokenHolderProfitSchemes[0xManager] = {MinimumLockMinutes: 100000, SchemeId: null}`

2. **User locks tokens**
   - Call: `RegisterForProfits(schemeManager=0xManager, amount=1000)`
   - Sender: `0xUser`
   - Result: User registered in SchemeA, `LockTimestamp[lockId] = 1000`, expects to withdraw at T ≥ 101000

3. **Manager calls CreateScheme again with minimal lock period**
   - Call: `CreateScheme(symbol="ELF", MinimumLockMinutes=1)`
   - Sender: `0xManager`
   - Result: Profit SchemeB created, `TokenHolderProfitSchemes[0xManager] = {MinimumLockMinutes: 1, SchemeId: null}` (OVERWRITTEN)

4. **User attempts premature withdrawal**
   - Current block time: T = 1001 minutes (only 1 minute passed)
   - Call: `Withdraw(0xManager)`
   - Sender: `0xUser`
   - Assertion check: `LockTimestamp[lockId] + MinimumLockMinutes < CurrentBlockTime`
   - Evaluation: `1000 + 1 < 1001` → TRUE
   - **Result: WITHDRAWAL SUCCEEDS** (Expected: should fail until T ≥ 101000)

**Success Condition:**
The user successfully withdraws their locked tokens after only 1 minute instead of the expected 100,000 minutes, demonstrating that the scheme manager can bypass the minimum lock period for existing locks.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```
