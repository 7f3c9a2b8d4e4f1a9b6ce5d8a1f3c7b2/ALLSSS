# Audit Report

## Title
Vote Record Overwrite Enables Double-Counting in Delegated Voting

## Summary
The Vote contract allows sponsors of delegated voting items (IsLockToken=false) to call Vote() multiple times with the same VoteId but different voters. Each call unconditionally overwrites the previous voting record while still incrementing vote totals, causing permanent inflation of vote counts that persists even after withdrawal.

## Finding Description

The vulnerability exists in the `Vote()` method where voting records are stored without duplicate VoteId validation. [1](#0-0) 

For delegated voting scenarios (IsLockToken=false), the sponsor must provide both the Voter address and VoteId explicitly. [2](#0-1) 

The contract validates that the sender is the sponsor and that VoteId is not null, but crucially **does not check if the VoteId already exists** in State.VotingRecords before proceeding.

When Vote() is called, it always invokes UpdateVotingResult() which unconditionally increments vote counts regardless of whether this VoteId has been used before. [3](#0-2) 

The vote tallies (Results[option], VotersCount, VotesAmount) are incremented every time Vote() is called, even when overwriting an existing VoteId.

Additionally, UpdateVotedItems() adds the VoteId to the new voter's ActiveVotes list without checking if another voter already has this VoteId. [4](#0-3) 

This creates a scenario where:
1. Sponsor votes with VoteId=X for Voter Alice with amount 100
2. Vote counts increase by 100
3. Sponsor votes again with same VoteId=X for Voter Bob with amount 200  
4. VotingRecords[X] now points to Bob (Alice's record is overwritten)
5. Vote counts increase by another 200 (total now 300)
6. Alice still has VoteId X in her ActiveVotes but cannot withdraw (permission check will fail)
7. When Bob withdraws, only 200 is subtracted, leaving 100 phantom votes

For regular voting (IsLockToken=true), VoteIds are auto-generated using transaction-specific data, preventing collisions. [5](#0-4) 

However, this protection does not exist for delegated voting where sponsors provide their own VoteIds.

## Impact Explanation

**Vote Integrity Compromise**: A malicious sponsor can artificially inflate vote totals by reusing VoteIds with different voters. Each reuse adds to the aggregate vote count while only maintaining the last voter's record, creating phantom votes that cannot be traced back.

**Permanent State Corruption**: The withdrawal mechanism only subtracts the amount from the current voting record. [6](#0-5) 

When a duplicate VoteId is withdrawn, only the final voter's amount is subtracted, leaving previously counted votes permanently inflated in the results.

**Orphaned Vote Tracking**: Previous voters retain the VoteId in their ActiveVotes list but cannot withdraw because the withdrawal permission check validates against the current record's voter. [7](#0-6) 

This creates irrecoverable inconsistencies in voter state.

**Real-World Impact**: While the Election contract implements its own duplicate VoteId protection [8](#0-7) , any other contracts or users creating custom delegated voting items (DAOs, community governance, voting polls) would be vulnerable to vote manipulation. This breaks the fundamental voting integrity guarantee that each vote is counted exactly once.

## Likelihood Explanation

**Attack Feasibility**: The exploit requires only that a sponsor:
1. Create a delegated voting item by calling Register() with IsLockToken=false (any user can do this)
2. Call the public Vote() method multiple times with the same VoteId but different Voter addresses

No special permissions beyond being the sponsor of a voting item are needed.

**Access Control**: For delegated voting, only the sponsor can call Vote(), as enforced by the contract. [9](#0-8) 

However, any user can become a sponsor by creating their own voting item.

**Detection Difficulty**: The attack leaves minimal traces since VotingRecords only shows the final state. Off-chain monitoring would need to track all Vote() transactions and compare against stored records to detect the discrepancy.

**Realistic Scenario**: Custom voting systems built on top of the Vote contract (community polls, DAO governance, reputation systems) would be vulnerable if they don't implement Election-style duplicate checks in their own contracts.

## Recommendation

Add a duplicate VoteId check in the Vote() method before accepting sponsor-provided VoteIds:

```csharp
if (!votingItem.IsLockToken)
{
    Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
    Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
    Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
    Assert(State.VotingRecords[input.VoteId] == null, "Vote Id already exists."); // ADD THIS CHECK
}
```

This mirrors the protection pattern used by the Election contract and prevents sponsors from reusing VoteIds to inflate vote counts.

## Proof of Concept

```csharp
[Fact]
public async Task DelegatedVoting_VoteId_Reuse_Inflates_Counts()
{
    // Create delegated voting item (IsLockToken=false)
    var registerItem = await RegisterVotingItemAsync(100, 3, false, DefaultSender, 1);
    
    var voter1 = Accounts[10].Address;
    var voter2 = Accounts[11].Address;
    var voteId = HashHelper.ComputeFrom("duplicate_vote_id");
    
    // First vote with VoteId for voter1, amount 100
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = registerItem.VotingItemId,
        Voter = voter1,
        VoteId = voteId,
        Option = registerItem.Options[0],
        Amount = 100
    });
    
    // Check results after first vote
    var resultAfterFirst = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = registerItem.VotingItemId,
        SnapshotNumber = 1
    });
    resultAfterFirst.VotesAmount.ShouldBe(100);
    resultAfterFirst.VotersCount.ShouldBe(1);
    
    // Second vote with SAME VoteId for voter2, amount 200
    await VoteContractStub.Vote.SendAsync(new VoteInput
    {
        VotingItemId = registerItem.VotingItemId,
        Voter = voter2,
        VoteId = voteId, // SAME VOTE ID
        Option = registerItem.Options[0],
        Amount = 200
    });
    
    // Check results after second vote - VULNERABILITY: counts are inflated
    var resultAfterSecond = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = registerItem.VotingItemId,
        SnapshotNumber = 1
    });
    
    // VULNERABILITY PROOF: Total is 300 (100+200) but should be 200 (overwrite)
    resultAfterSecond.VotesAmount.ShouldBe(300); // Inflated!
    resultAfterSecond.VotersCount.ShouldBe(2); // Inflated!
    
    // The VotingRecord only shows voter2 with 200
    var record = await VoteContractStub.GetVotingRecord.CallAsync(voteId);
    record.Voter.ShouldBe(voter2);
    record.Amount.ShouldBe(200);
    
    // When voter2 withdraws, only 200 is subtracted
    await VoteContractStub.Withdraw.SendAsync(new WithdrawInput { VoteId = voteId });
    
    var resultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
    {
        VotingItemId = registerItem.VotingItemId,
        SnapshotNumber = 1
    });
    
    // PERMANENT CORRUPTION: 100 phantom votes remain
    resultAfterWithdraw.VotesAmount.ShouldBe(100); // Should be 0!
}
```

## Notes

The Election contract protects itself against this vulnerability by checking for duplicate VoteIds before calling the Vote contract. However, the base Vote contract vulnerability remains exploitable for any custom voting implementations that don't implement similar protections. This represents a design flaw where critical validation logic is delegated to callers rather than enforced at the contract level.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L117-117)
```csharp
        State.VotingRecords[input.VoteId] = votingRecord;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L146-161)
```csharp
    private void UpdateVotedItems(Hash voteId, Address voter, VotingItem votingItem)
    {
        var votedItems = State.VotedItemsMap[voter] ?? new VotedItems();
        var voterItemIndex = votingItem.VotingItemId.ToHex();
        if (votedItems.VotedItemVoteIds.ContainsKey(voterItemIndex))
            votedItems.VotedItemVoteIds[voterItemIndex].ActiveVotes.Add(voteId);
        else
            votedItems.VotedItemVoteIds[voterItemIndex] =
                new VotedIds
                {
                    ActiveVotes = { voteId }
                };

        votedItems.VotedItemVoteIds[voterItemIndex].WithdrawnVotes.Remove(voteId);
        State.VotedItemsMap[voter] = votedItems;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L197-200)
```csharp
        if (votingItem.IsLockToken)
            Assert(votingRecord.Voter == Context.Sender, "No permission to withdraw votes of others.");
        else
            Assert(votingItem.Sponsor == Context.Sender, "No permission to withdraw votes of others.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-222)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-388)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L432-433)
```csharp
        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
```
