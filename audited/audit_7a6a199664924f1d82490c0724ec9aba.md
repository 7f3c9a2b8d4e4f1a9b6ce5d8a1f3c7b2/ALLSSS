### Title
Zero Address Side Chain Creator Causes Denial of Service on Resource Token Donation and Governance

### Summary
The `InitializeFromParentChain()` function validates that `input.Creator` is not null but fails to validate that the address value is not empty, allowing a zero address to be set as the side chain creator. This does not enable unauthorized token creation, but causes permanent denial of service on the `DonateResourceToken` function and breaks side chain rental governance by creating an Association organization with a zero address member.

### Finding Description
The vulnerability exists in the validation logic at two levels:

**Primary Issue:** [1](#0-0) 

This check only validates that the Address object is not null, but does not validate that `input.Creator.Value.IsNullOrEmpty()` is false. An Address object can exist with an empty/zero value.

**Secondary Issue:** [2](#0-1) 

The `SetSideChainCreator` function accepts the input without validating the address value is not empty.

**Exploitation Path:**

1. When `PayRental()` is called during `DonateResourceToken` execution, it attempts to get the creator's balance: [3](#0-2) 

2. The `GetBalance` function validates the address and rejects empty addresses: [4](#0-3) 

The validation at line 168 calls: [5](#0-4) 

This assertion fails for a zero address, causing the entire `DonateResourceToken` transaction to revert.

3. Additionally, the zero address is used to create an Association organization for side chain rental governance: [6](#0-5) [7](#0-6) 

The zero address becomes an organization member (line 254) and proposer (line 265), potentially making the organization dysfunctional.

4. The `SetFeeReceiver` function becomes permanently locked: [8](#0-7) 

No valid transaction sender can equal a zero address, making this function uncallable.

**Note on Token Creation:**
The vulnerability does NOT enable unauthorized token creation. The check preventing direct token creation on side chains is: [9](#0-8) 

This check validates if the value is null (not whether it's empty), so even with a zero address creator, this assertion still blocks token creation since the Address object exists (is not null).

### Impact Explanation
**Operational Impact - High Severity:**

1. **Permanent DoS on Resource Token Donation**: Every call to `DonateResourceToken` (called by miners to donate resource tokens) will fail when attempting to charge rental from the zero address creator. This breaks the side chain's resource fee collection mechanism, preventing miners from properly donating collected resource tokens.

2. **Broken Side Chain Rental Governance**: The Association organization for managing side chain rental parameters (`UpdateRental`, `UpdateRentedResources`) is created with the zero address as a member. This creates a governance organization where:
   - One member address is invalid (zero address)
   - Proposals require unanimous approval from both members (line 258: `MinimalApprovalThreshold = proposers.Count`)
   - The organization may be unable to function properly

3. **Locked Fee Receiver Configuration**: The `SetFeeReceiver` function, which allows the side chain creator to configure where transaction fees are sent, becomes permanently inaccessible since the authorization check requires the sender to equal the zero address.

4. **Resource Token Accumulation**: Since `DonateResourceToken` fails, resource tokens cannot be properly donated to the consensus contract, causing them to accumulate in contract addresses rather than being distributed to miners.

The side chain initialization succeeds but results in a broken operational state for critical economic functions.

### Likelihood Explanation
**Likelihood: Medium**

**Preconditions:**
- Requires a Parliament proposal to call `InitializeFromParentChain` with a zero address as Creator
- Miners must approve and release the proposal
- Can only occur during initial side chain setup (before `InitializedFromParentChain` flag is set)

**Attack Complexity:**
- Low technical complexity - simply requires passing an Address object with empty Value in the proposal
- Requires social engineering or compromised miner approval to get the malicious proposal passed
- The error could also occur accidentally if proposal creators don't properly validate the Creator address

**Feasibility:**
The method can only be called through Parliament governance: [10](#0-9) 

This provides some protection but relies on miners properly validating proposal parameters. Historical governance attacks show that miners may approve proposals without thorough parameter validation.

**Detection:**
Once set, the DoS is immediately apparent on the first `DonateResourceToken` call, but by then the damage is permanent since the creator cannot be changed (protected by the "Creator already set" check at line 1131).

### Recommendation
**Immediate Fix:**
Add comprehensive address validation in `InitializeFromParentChain`:

```csharp
Assert(input.Creator != null && !input.Creator.Value.IsNullOrEmpty(), 
       "Creator address must not be null or empty.");
```

Add the same validation in `SetSideChainCreator` as a defense-in-depth measure:

```csharp
private void SetSideChainCreator(Address input)
{
    Assert(State.SideChainCreator.Value == null, "Creator already set.");
    Assert(input != null && !input.Value.IsNullOrEmpty(), 
           "Creator address must not be null or empty.");
    // ... rest of function
}
```

**Additional Safeguards:**
1. Add a view method to check if the side chain creator is properly initialized (non-zero)
2. Add parameter validation documentation for Parliament proposal creators
3. Consider adding an emergency governance function to update the creator address if it's set to zero (requires careful authorization design)

**Test Cases:**
1. Test `InitializeFromParentChain` with Address object having empty Value - should fail
2. Test `InitializeFromParentChain` with null Address - should fail (already covered)
3. Test successful `DonateResourceToken` after proper initialization
4. Test that zero address creator is rejected before Association organization creation

### Proof of Concept
**Initial State:**
- Side chain token contract deployed but not initialized
- Parliament contract operational
- Miner set has approval authority

**Attack Sequence:**

1. Attacker (or accidentally, a proposal creator) creates a Parliament proposal calling `InitializeFromParentChain` with:
```
{
    Creator: Address { Value: ByteString.Empty },  // Empty address value
    ResourceAmount: { "CPU": 1000, "NET": 1000 },
    RegisteredOtherTokenContractAddresses: { ... }
}
```

2. Miners approve and release the proposal (either maliciously or without proper validation)

3. Transaction executes:
   - Line 18 check passes (Address object is not null)
   - `SetSideChainCreator` stores the zero address
   - `InitializedFromParentChain` flag is set to true
   - Transaction succeeds

4. First miner attempts to call `DonateResourceToken`:
   - Execution reaches `PayRental()` at line 949
   - Line 1021: `creator = State.SideChainCreator.Value` (zero address)
   - Line 1022: null check passes (Address object exists)
   - Line 1044: calls `GetBalance(creator, symbol)`
   - `GetBalance` calls `AssertValidInputAddress(address)` at line 168
   - Assertion fails: "Invalid input address" because `address.Value.IsNullOrEmpty()` is true
   - **Transaction reverts with "Invalid input address"**

5. Any attempt to call `SetFeeReceiver`:
   - Line 1214: check `State.SideChainCreator.Value == Context.Sender` fails
   - No valid sender can equal the zero address
   - **Function permanently inaccessible**

**Expected Result:** Validation should reject zero address during initialization

**Actual Result:** Zero address is accepted, causing permanent DoS on `DonateResourceToken` and locked `SetFeeReceiver` function

**Success Condition for Attack:** Side chain operates with broken resource donation mechanism and inaccessible fee receiver configuration

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L18-18)
```csharp
        Assert(input.Creator != null, "creator should not be null");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L54-55)
```csharp
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1021-1044)
```csharp
        var creator = State.SideChainCreator.Value;
        if (creator == null) return;
        if (State.LastPayRentTime.Value == null)
        {
            // Initial LastPayRentTime first calling DonateResourceToken.
            State.LastPayRentTime.Value = Context.CurrentBlockTime;
            return;
        }

        // We need minutes.
        var duration = (Context.CurrentBlockTime - State.LastPayRentTime.Value).Seconds.Div(60);
        if (duration == 0)
        {
            return;
        }

        // Update LastPayRentTime if it is ready to charge rental.
        State.LastPayRentTime.Value += new Duration { Seconds = duration.Mul(60) };

        foreach (var symbol in Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName))
        {
            var donates = 0L;

            var availableBalance = GetBalance(creator, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1129-1142)
```csharp
    private void SetSideChainCreator(Address input)
    {
        Assert(State.SideChainCreator.Value == null, "Creator already set.");
        if (State.ParliamentContract.Value == null)
        {
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
        }

        Assert(Context.Sender == Context.GetZeroSmartContractAddress() ||
               Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            "No permission.");
        State.SideChainCreator.Value = input;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1212-1217)
```csharp
    public override Empty SetFeeReceiver(Address input)
    {
        Assert(State.SideChainCreator.Value == Context.Sender, "No permission.");
        State.FeeReceiver.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L166-172)
```csharp
    private long GetBalance(Address address, string symbol)
    {
        AssertValidInputAddress(address);
        var actualSymbol = GetActualTokenSymbol(symbol);
        Assert(!string.IsNullOrWhiteSpace(actualSymbol), "Invalid symbol.");
        return State.Balances[address][actualSymbol];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L37-41)
```csharp
        if (State.SideChainCreator.Value == null || State.SideChainRentalController.Value != null) return new Empty();
        var sideChainRentalController = GetDefaultSideChainRentalController(defaultParliamentController);
        CreateAssociationControllerForSideChainRental(State.SideChainCreator.Value,
            defaultParliamentController.OwnerAddress);
        State.SideChainRentalController.Value = sideChainRentalController;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L244-269)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetControllerCreateInputForSideChainRental(
        Address sideChainCreator, Address parliamentAddress)
    {
        var proposers = new List<Address> { parliamentAddress, sideChainCreator };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```
