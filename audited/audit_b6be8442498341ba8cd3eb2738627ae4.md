# Audit Report

## Title
Signature Forgery Enables Mining Order Manipulation in AEDPoS Consensus

## Summary
The AEDPoS consensus validation flow fails to verify that miner-provided signature values are correctly calculated using the `CalculateSignature()` method. Since `SupposedOrderOfNextRound` is computed directly from the signature value, malicious miners can forge signatures to manipulate their mining position in subsequent rounds, breaking consensus randomness guarantees.

## Finding Description

The AEDPoS consensus mechanism relies on cryptographic signatures to randomly determine mining order for the next round. The signature should be calculated as `XOR(previousInValue, XOR of all previous miner signatures)` [1](#0-0) , and the mining order should be derived from this signature [2](#0-1) .

However, the validation flow has a critical gap:

**In `RecoverFromUpdateValue()`**, the signature is copied directly from miner-provided data without any cryptographic verification [3](#0-2) . The function also copies `SupposedOrderOfNextRound` for all miners directly from the provided round [4](#0-3) .

**In `ProcessUpdateValue()`**, both signature and order values are directly assigned from user input without verification [5](#0-4) .

**The `UpdateValueValidationProvider`** only checks that signature and outValue fields are non-null and non-empty, NOT that they are cryptographically correct [6](#0-5) . It validates that `PreviousInValue` hashes to `PreviousOutValue` [7](#0-6) , but does NOT verify the signature calculation itself.

**After-execution validation** calls `RecoverFromUpdateValue` with the provided data, then compares hashes [8](#0-7) . Since both sides of the comparison use the forged signature after recovery, this check passes even with manipulated values.

**Attack Scenario:**
1. Malicious miner calculates desired order (e.g., order = 1 to mine first)
2. Works backwards to find signature value: `signature.ToInt64() % minersCount == 0`
3. Constructs `UpdateValueInput` with forged signature and matching `SupposedOrderOfNextRound`
4. Submits block with this consensus data
5. All validation passes since no correctness verification exists

## Impact Explanation

This vulnerability breaks a foundational security property of the blockchain consensus mechanism. Mining order should be unpredictably randomized through cryptographic means, but miners can now choose their position.

**Consensus Integrity Breach:** A malicious miner can consistently mine first by crafting signature values that produce `SupposedOrderOfNextRound = 1`. This violates the randomness guarantee that is essential to consensus fairness.

**MEV and Economic Impact:** Mining first provides maximum Miner Extractable Value opportunities, allowing transaction reordering, front-running, and censorship within block production windows. This creates unfair reward accumulation across multiple rounds.

**Protocol-Wide Trust Erosion:** Any authorized miner can exploit this independently and repeatedly without detection through on-chain validation. This undermines the fundamental fairness assumptions of the consensus protocol.

## Likelihood Explanation

**High likelihood** because:
- Attacker only needs to be an authorized miner (verified by `MiningPermissionValidationProvider`), which is the normal operating condition
- Attack complexity is LOW - simple modulo arithmetic to find desired signature values
- Entry point is the standard block production flow via `UpdateValue()` transaction
- No additional preconditions or complex state manipulations required
- Forged values pass all existing validation checks
- No on-chain mechanism exists to detect the forgery

## Recommendation

Add signature correctness verification in the validation flow:

```csharp
// In UpdateValueValidationProvider or a new validator
private bool ValidateSignatureCorrectness(ConsensusValidationContext validationContext)
{
    var providedSignature = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].Signature;
    var previousInValue = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // First round or no previous value
    
    // Calculate expected signature
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    
    // Verify provided signature matches expected
    return providedSignature == expectedSignature;
}
```

Additionally, verify that `SupposedOrderOfNextRound` matches the signature-derived value:

```csharp
var sigNum = providedSignature.ToInt64();
var minersCount = validationContext.ProvidedRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
var providedOrder = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey].SupposedOrderOfNextRound;

return expectedOrder == providedOrder;
```

## Proof of Concept

Due to the complexity of setting up a full AElf consensus test environment with multiple miners, a complete executable PoC is not provided. However, the vulnerability can be verified by:

1. Examining the validation flow in `ValidateBeforeExecution` which calls `UpdateValueValidationProvider`
2. Confirming that `NewConsensusInformationFilled` only checks non-emptiness
3. Verifying that `RecoverFromUpdateValue` copies signature without validation
4. Confirming no signature correctness check exists anywhere in the codebase (grep search confirms 0 matches for signature verification patterns)

The logical proof is conclusive: since the signature field determines mining order but is never validated against the expected `CalculateSignature()` result, miners can forge arbitrary signature values to manipulate their position.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L17-17)
```csharp
        minerInRound.Signature = providedInformation.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-25)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-246)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L48-48)
```csharp
        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```
