### Title
Quadratic Voting Cost Progression Broken for Locked Token Voting

### Summary
The quadratic voting implementation fails to enforce quadratic cost progression when `IsLockToken` is true. Each vote generates a unique `VoteId`, causing `QuadraticVotesCountMap` to always start at zero, resulting in constant cost (`TicketCost * 1`) instead of the intended increasing cost (`TicketCost * 1, 2, 3...`). This defeats the core purpose of quadratic voting: preventing wealthy voters from cheaply dominating votes.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

The quadratic voting cost tracking uses `VoteId` as the key in `QuadraticVotesCountMap` [2](#0-1) , but for locked token voting, each vote generates a **unique** `VoteId` based on the current `VotesAmount` [3](#0-2) .

**Execution Flow for IsLockToken=true, IsQuadratic=true:**

1. First vote by voter A:
   - Line 397: `VoteId` = `Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false))` → **Unique ID #1**
   - Line 100: `QuadraticVotesCountMap[UniqueID#1]` = 0 + 1 = 1
   - Line 102: `amount` = `TicketCost * 1`
   - Cost: **TicketCost**

2. Second vote by voter A:
   - Line 397: `VoteId` = new unique ID based on **updated** VotesAmount → **Unique ID #2**
   - Line 100: `QuadraticVotesCountMap[UniqueID#2]` = 0 + 1 = 1 (new entry!)
   - Line 102: `amount` = `TicketCost * 1`
   - Cost: **TicketCost** (same as first!)

3. Third vote: `TicketCost * 1` again...

**Why Protections Fail:**

The `Register` method accepts both `IsQuadratic` and `IsLockToken` flags without validation [4](#0-3) . The `AssertValidNewVotingItem` validation does not check for incompatible flag combinations [5](#0-4) .

**Contrast with Delegated Voting (IsLockToken=false):**

For delegated voting, the sponsor provides the `VoteId` in the input [6](#0-5) , allowing potential reuse to track cumulative votes per voter. However, this requires sponsor cooperation and still lacks proper voter-level tracking.

### Impact Explanation

**Harm:**
- **Token Economics Manipulation**: Voters can acquire unlimited votes at constant cost (`TicketCost` per vote) instead of quadratic cost (1, 2, 3... times `TicketCost`). Expected total cost for N votes: `TicketCost * N(N+1)/2` ≈ O(N²). Actual cost: `TicketCost * N` = O(N).
- **Governance Integrity Compromise**: Wealthy actors can cheaply dominate any voting item created with `IsQuadratic=true` and `IsLockToken=true`, nullifying the vote-buying resistance that quadratic voting provides.
- **Protocol Design Violation**: The feature is labeled "quadratic" but provides no quadratic cost progression.

**Quantified Damage:**

For a voter acquiring 100 votes with `TicketCost=1000` tokens:
- **Intended cost**: 1000 * (1+2+...+100) = 1000 * 5050 = **5,050,000 tokens**
- **Actual cost**: 1000 * 100 = **100,000 tokens**
- **Savings**: 4,950,000 tokens (98% discount!)

**Affected Parties:**
- Honest voters who vote few times (paying proportional cost)
- Voting sponsors expecting quadratic cost enforcement
- Protocol governance integrity

**Severity:** HIGH - Breaks core security property (quadratic cost progression), enables voting manipulation, no special permissions required.

### Likelihood Explanation

**Attacker Capabilities:**
- Any address can call `Register` to create a voting item [7](#0-6) 
- Any address can call `Vote` to participate [8](#0-7) 
- No special permissions required

**Attack Complexity:**
- **Trivial**: Two simple transactions
  1. `Register(IsQuadratic=true, IsLockToken=true, ...)`
  2. `Vote(...)` multiple times
- No sophisticated contract interactions needed

**Feasibility Conditions:**
- ✅ Public methods accessible to all
- ✅ No validation prevents flag combination
- ✅ No economic barriers (attacker controls `TicketCost` parameter)
- ✅ Works in current contract state without preconditions

**Detection:**
- Not easily detectable without analyzing `QuadraticVotesCountMap` state for each `VoteId`
- Appears as legitimate voting activity
- No on-chain alerts for constant cost voting in "quadratic" items

**Probability:** VERY HIGH - The vulnerability is exploitable in every voting item where both flags are true. An attacker (or even unaware sponsor) creating such an item immediately enables exploitation.

### Recommendation

**Primary Fix: Implement Per-Voter-Per-Item Tracking**

Modify `VoteContractState.cs`:
```csharp
// Replace or supplement QuadraticVotesCountMap with:
/// <summary>
/// (VotingItemId + Voter Address) -> Votes Count
/// </summary>
public MappedState<Hash, long> QuadraticVotesCountPerVoterMap { get; set; }
```

Modify `VoteContract.cs` Vote method (around line 99-102):
```csharp
else // IsQuadratic
{
    var voterItemKey = HashHelper.ConcatAndCompute(
        input.VotingItemId, 
        input.Voter.Value
    );
    var currentVotesCount = State.QuadraticVotesCountPerVoterMap[voterItemKey].Add(1);
    State.QuadraticVotesCountPerVoterMap[voterItemKey] = currentVotesCount;
    amount = votingItem.TicketCost.Mul(currentVotesCount);
}
```

**Secondary Fix: Add Validation**

In `AssertValidNewVotingItem`:
```csharp
if (input.IsQuadratic && input.IsLockToken)
{
    Assert(false, "Quadratic voting with locked tokens is not currently supported. Use delegated voting (IsLockToken=false) for quadratic voting.");
}
```

**Invariant Checks:**
- For quadratic voting: Verify cumulative cost ≈ `TicketCost * N(N+1)/2` for N votes
- Track per-voter vote counts, not per-VoteId
- Ensure each subsequent vote costs more than the previous

**Test Cases:**
1. Test: User votes 5 times on quadratic locked-token item → verify costs are 1x, 2x, 3x, 4x, 5x `TicketCost`
2. Test: Attempt to register with both flags → should fail after fix #2
3. Test: Cumulative token lock amount matches quadratic formula
4. Regression test: Delegated quadratic voting still works

### Proof of Concept

**Initial State:**
- Token Contract deployed and initialized
- Vote Contract deployed
- Attacker has 1,000,000 tokens

**Exploit Sequence:**

**Step 1: Register Vulnerable Voting Item**
```
Transaction: VoteContract.Register(
    start_timestamp: now,
    end_timestamp: now + 30 days,
    accepted_currency: "ELF",
    is_lock_token: true,        // ← Locked token voting
    is_quadratic: true,          // ← Quadratic voting enabled
    ticket_cost: 10000,          // ← 10k tokens per "ticket"
    options: ["OptionA", "OptionB"]
)
```

**Step 2: Cast Multiple Votes**
```
Transaction 1: Vote(voting_item_id: X, option: "OptionA")
→ VoteId generated: Hash#1
→ QuadraticVotesCountMap[Hash#1] = 1
→ Cost: 10000 * 1 = 10,000 tokens
→ 1 vote recorded for OptionA

Transaction 2: Vote(voting_item_id: X, option: "OptionA")
→ VoteId generated: Hash#2 (different!)
→ QuadraticVotesCountMap[Hash#2] = 1 (new entry!)
→ Cost: 10000 * 1 = 10,000 tokens (same!)
→ 2 votes total for OptionA

Transaction 3-100: Repeat...
→ Each costs 10,000 tokens
→ 100 votes acquired
```

**Expected vs Actual Result:**

**Expected (Quadratic Cost):**
- Vote 1: 10,000 tokens
- Vote 2: 20,000 tokens
- Vote 3: 30,000 tokens
- ...
- Vote 100: 1,000,000 tokens
- **Total: 50,500,000 tokens**

**Actual (Broken Implementation):**
- Vote 1-100: 10,000 tokens each
- **Total: 1,000,000 tokens**

**Success Condition:**
Attacker acquires 100 votes for 1,000,000 tokens instead of the intended 50,500,000 tokens (98% cost reduction), demonstrating broken quadratic progression.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L90-144)
```csharp
    public override Empty Vote(VoteInput input)
    {
        var votingItem = AssertValidVoteInput(input);
        var amount = 0L;
        if (!votingItem.IsQuadratic)
        {
            amount = input.Amount;
        }
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }

        var votingRecord = new VotingRecord
        {
            VotingItemId = input.VotingItemId,
            Amount = amount,
            SnapshotNumber = votingItem.CurrentSnapshotNumber,
            Option = input.Option,
            IsWithdrawn = false,
            VoteTimestamp = Context.CurrentBlockTime,
            Voter = input.Voter,
            IsChangeTarget = input.IsChangeTarget
        };

        State.VotingRecords[input.VoteId] = votingRecord;

        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
        UpdateVotedItems(input.VoteId, votingRecord.Voter, votingItem);

        if (votingItem.IsLockToken)
            // Lock voted token.
            State.TokenContract.Lock.Send(new LockInput
            {
                Address = votingRecord.Voter,
                Symbol = votingItem.AcceptedCurrency,
                LockId = input.VoteId,
                Amount = amount
            });

        Context.Fire(new Voted
        {
            VoteId = input.VoteId,
            VotingItemId = votingRecord.VotingItemId,
            Voter = votingRecord.Voter,
            Amount = votingRecord.Amount,
            Option = votingRecord.Option,
            SnapshotNumber = votingRecord.SnapshotNumber,
            VoteTimestamp = votingRecord.VoteTimestamp
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L384-389)
```csharp
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L390-398)
```csharp
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContractState.cs (L30-33)
```csharp
    /// <summary>
    ///     Vote Id -> Votes Count
    /// </summary>
    public MappedState<Hash, long> QuadraticVotesCountMap { get; set; }
```
