# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Race Condition in Contract Address Reservation Allows Conflicting Proposals

## Summary
The `ProposeNewContract` function validates contract address availability at proposal creation time but defers address reservation until deployment after governance approval. This creates a TOCTOU window where multiple proposals with identical deployer/salt combinations but different contract code can all pass validation, leading to deployment failures for all but the first approved proposal.

## Finding Description

The vulnerability exists in the contract deployment governance flow within the Genesis contract (BasicContractZero).

**Check Phase (Proposal Creation):**

When `ProposeNewContract` is called with a `ContractOperation` specifying a deployer address and salt, the function performs an availability check: [1](#0-0) 

This check computes the deterministic contract address and verifies it's unoccupied: [2](#0-1) 

However, this check does NOT reserve the address. The proposal is registered only by its input hash: [3](#0-2) 

The `RegisterContractProposingData` method stores proposals indexed by the hash of the complete input (category + code + contract operation): [4](#0-3) 

Since different contract codes produce different input hashes, multiple proposals with the same deployer/salt but different code are all allowed through this duplicate check.

**Time Gap:**

The default proposal expiration period is 259200 seconds (72 hours): [5](#0-4) 

During this window, multiple conflicting proposals can be created and approved through the two-stage governance process (ContractDeploymentController â†’ CodeCheckController).

**Use Phase (Deployment):**

When `DeploySmartContract` is eventually called after governance approval, it computes the same contract address and attempts deployment: [6](#0-5) 

The address is only reserved when `State.ContractInfos` is set: [7](#0-6) 

Only the first deployment succeeds; subsequent deployments with the same address fail the assertion at line 40, despite having passed all governance approvals.

**Security Constraint:**

The signature validation requires either the deployer's private key or an authorized signer: [8](#0-7) 

Authorized signers can be registered via `SetSigner`: [9](#0-8) 

## Impact Explanation

**Governance Resource Waste:**
Multiple proposals with conflicting deployer/salt combinations proceed through expensive two-stage governance (ContractDeploymentController approval, then CodeCheckController approval), consuming validator voting time, block producer code-checking resources, and transaction fees, only for all but one to fail at deployment.

**Operational Disruption:**
Users experience unexpected "Contract address exists" failures after successfully obtaining governance approval, creating unpredictable deployment outcomes and poor user experience.

**Griefing Vector:**
An attacker with signing authority (via private key access or `SetSigner` delegation) can intentionally create conflicting proposals to block legitimate deployments. This is realistic in scenarios with shared multisig deployers or delegated deployment rights.

**Severity:** Medium - No direct fund loss, but significant operational integrity impact on governance processes.

## Likelihood Explanation

**Required Capabilities:**
- Valid signing authority for the target deployer (private key OR registered as authorized signer via `SetSigner`)
- Ability to craft `ContractOperation` with valid signature
- Visibility of pending proposals (on-chain state or mempool monitoring)

**Realistic Attack Scenarios:**

1. **Delegated Signer Attack:** A party granted signer rights creates conflicting proposals to grief the deployer
2. **Shared Multisig Collision:** Multiple teams using the same multisig deployer accidentally create conflicting proposals
3. **Accidental Collision:** Same user submits conflicting proposals during testing/iteration
4. **Front-running:** Attacker monitors pending proposals and submits conflicting transaction with same deployer/salt

**Probability Assessment:** Medium likelihood - While signature requirement limits casual attacks, legitimate scenarios exist with multiple authorized signers (multisig wallets, delegated deployment, contract factories). The 72-hour time window significantly increases collision probability.

## Recommendation

Implement address reservation at proposal creation time by maintaining a mapping from contract addresses to proposal hashes:

```csharp
// In BasicContractZeroState.cs
public MappedState<Address, Hash> PendingContractAddresses { get; set; }

// In ProposeNewContract (after line 139)
if (input.ContractOperation != null)
{
    ValidateContractOperation(input.ContractOperation, 0, codeHash);
    RemoveOneTimeSigner(input.ContractOperation.Deployer);
    
    var contractAddress = AddressHelper.ComputeContractAddress(
        input.ContractOperation.Deployer, 
        input.ContractOperation.Salt);
    
    // Check not reserved by another proposal
    var existingProposal = State.PendingContractAddresses[contractAddress];
    Assert(existingProposal == null || 
           Context.CurrentBlockTime >= State.ContractProposingInputMap[existingProposal]?.ExpiredTime,
           "Contract address already reserved by another proposal.");
    
    // Reserve the address
    State.PendingContractAddresses[contractAddress] = proposedContractInputHash;
}

// In TryClearContractProposingData, release reservation
if (contractProposingInput != null && contractProposingInput.Deployer != null)
{
    var address = AddressHelper.ComputeContractAddress(
        contractProposingInput.Deployer, 
        contractProposingInput.Salt);
    State.PendingContractAddresses.Remove(address);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_MultipleProposalsWithSameDeployerSalt_OnlyFirstSucceeds()
{
    // Setup: Two different contract codes with same deployer/salt
    var deployer = SampleAddress.AddressList[0];
    var salt = HashHelper.ComputeFrom("test-salt");
    var codeA = Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value;
    var codeB = Codes.Single(kv => kv.Key.Contains("Profit")).Value; // Different code
    
    // Generate signatures for both
    var signatureA = GenerateSignature(deployer, salt, HashHelper.ComputeFrom(codeA), 1);
    var signatureB = GenerateSignature(deployer, salt, HashHelper.ComputeFrom(codeB), 1);
    
    // Proposal A
    var proposalInputA = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(codeA),
        ContractOperation = new ContractOperation
        {
            ChainId = ChainId,
            CodeHash = HashHelper.ComputeFrom(codeA),
            Deployer = deployer,
            Salt = salt,
            Version = 1,
            Signature = signatureA
        }
    };
    
    // Proposal B (same deployer/salt, different code)
    var proposalInputB = new ContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(codeB),
        ContractOperation = new ContractOperation
        {
            ChainId = ChainId,
            CodeHash = HashHelper.ComputeFrom(codeB),
            Deployer = deployer,
            Salt = salt,
            Version = 1,
            Signature = signatureB
        }
    };
    
    // Both proposals pass validation and get created
    var resultA = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract), proposalInputA);
    resultA.Status.ShouldBe(TransactionResultStatus.Mined); // PASSES
    
    var resultB = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
        nameof(BasicContractZero.ProposeNewContract), proposalInputB);
    resultB.Status.ShouldBe(TransactionResultStatus.Mined); // ALSO PASSES - VULNERABILITY
    
    // Both go through governance approval and code check...
    // (Approval steps omitted for brevity)
    
    // When deploying, only first succeeds
    var deployResultA = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
        nameof(BasicContractZero.DeploySmartContract), proposalInputA);
    deployResultA.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCESS
    
    var deployResultB = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
        nameof(BasicContractZero.DeploySmartContract), proposalInputB);
    deployResultB.Status.ShouldBe(TransactionResultStatus.Failed); // FAILS
    deployResultB.Error.ShouldContain("Contract address exists"); // Wasted governance
}
```

## Notes

The vulnerability is constrained by signature validation requirements, limiting attackers to those with legitimate signing authority. However, this does not eliminate the issue, as scenarios with shared multisig deployers, delegated signers, or accidental collisions are realistic in production environments. The 72-hour proposal window significantly amplifies collision probability compared to atomic operations.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L127-128)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L139-139)
```csharp
            AssertContractAddressAvailable(input.ContractOperation.Deployer, input.ContractOperation.Salt);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-544)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L34-40)
```csharp
        else
        {
            serialNumber = 0;
            contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        }

        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L70-70)
```csharp
        State.ContractInfos[contractAddress] = info;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L204-215)
```csharp
    private void RegisterContractProposingData(Hash proposedContractInputHash)
    {
        var registered = State.ContractProposingInputMap[proposedContractInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var expirationTimePeriod = GetCurrentContractProposalExpirationTimePeriod();
        State.ContractProposingInputMap[proposedContractInputHash] = new ContractProposingInput
        {
            Proposer = Context.Sender,
            Status = ContractProposingInputStatus.Proposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(expirationTimePeriod)
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L410-412)
```csharp
        Assert(
            recoveredAddress == contractOperation.Deployer ||
            State.SignerMap[contractOperation.Deployer] == recoveredAddress, "Invalid signature.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L440-444)
```csharp
    private void AssertContractAddressAvailable(Address deployer, Hash salt)
    {
        var contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L5-5)
```csharp
    public const int ContractProposalExpirationTimePeriod = 259200; // 60 * 60 * 72
```
