# Audit Report

## Title
Insufficient Validation in SetMinerIncreaseInterval Allows Negative Values Leading to Complete Consensus Halt

## Summary
The `SetMinerIncreaseInterval()` function lacks lower bound validation, allowing governance to set negative values for `MinerIncreaseInterval`. This causes `GetAutoIncreasedMinersCount()` to return a large negative miner count, which propagates through the consensus system. The negative count causes LINQ's `.Take()` operation in the Election contract to return an empty miner list, resulting in a consensus round with zero miners and permanent blockchain halt.

## Finding Description

**Root Cause - Missing Validation:**

The `SetMinerIncreaseInterval()` function only validates that the new value does not exceed the current value, but fails to enforce a positive lower bound. [1](#0-0) 

This allows values like -1 to pass validation since `-1 <= 31536000` (default value) evaluates to true.

**Negative Value Calculation:**

When `GetAutoIncreasedMinersCount()` executes with a negative `MinerIncreaseInterval`, it performs integer division with a negative divisor: [2](#0-1) 

With `MinerIncreaseInterval = -1` and blockchain age of 100,000 seconds, this calculates: `17 + (100000 / -1) * 2 = 17 - 200000 = -199,983`.

**Propagation to Election Contract:**

The negative miner count is calculated by `GetMinersCount(Round)` using the same vulnerable logic: [3](#0-2) 

This negative value is sent to the Election contract via `UpdateMinersCount`: [4](#0-3) 

The Election contract stores this value without validation: [5](#0-4) 

**Critical LINQ Behavior Exploitation:**

When `GetVictories()` attempts to select miners, it uses the stored negative count: [6](#0-5) 

C# LINQ's `.Take(n)` with negative `n` returns an empty sequence, producing a `MinerList` with zero miners.

**Consensus Termination:**

The empty miner list is used to generate the next consensus round: [7](#0-6) 

With `sortedMiners.Count = 0`, the for loop never executes, creating a `Round` object with no miners in `RealTimeMinersInformation`. Since no miners exist, no blocks can be produced, causing permanent consensus halt.

## Impact Explanation

**Complete Network Failure:**
The vulnerability causes total blockchain shutdown. With zero miners in the consensus round, block production permanently halts. All network participants (validators, users, dApps) are immediately affected.

**Unrecoverable State:**
Even governance cannot fix this through normal channels since executing governance proposals requires consensus. The system enters a deadlock requiring emergency node-level intervention or chain restart.

**Network-Wide Denial of Service:**
All blockchain operations cease: token transfers, smart contract executions, cross-chain messages, and governance actions become impossible. The impact is immediate at the next term transition (typically hours after the malicious parameter is set).

This represents a complete violation of the consensus protocol's fundamental invariant that the miner set must always contain at least one active miner.

## Likelihood Explanation

**Privilege Requirements:**
The attack requires control of the `MaximumMinersCountController` authority (default: Parliament's default organization). While this is a privileged role, the vulnerability exists in the code's missing validation logic.

**Direct Invariant Break:**
This is a directly reachable invariant break - a single authorized call to `SetMinerIncreaseInterval(-1)` deterministically breaks the fundamental invariant that miner count must be positive. The validation gap represents mis-scoped privileges: Parliament should configure valid parameters, not break consensus.

**Execution Simplicity:**
Once authorization is obtained, exploitation is trivial: a single function call with no complex transaction sequencing. The negative value persists in state and triggers failure at the next term transition.

**Detection Difficulty:**
The negative value is stored on-chain but may not immediately alert monitoring systems. The actual consensus failure occurs later when `GetAutoIncreasedMinersCount()` is invoked during term transition, creating a temporal gap between attack and manifestation.

## Recommendation

Add comprehensive input validation to `SetMinerIncreaseInterval()`:

```csharp
public override Empty SetMinerIncreaseInterval(Int64Value input)
{
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set miner increase interval.");
    Assert(input.Value > 0, "Miner increase interval must be positive.");
    Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
    State.MinerIncreaseInterval.Value = input.Value;
    return new Empty();
}
```

Additionally, add defensive validation in `UpdateMinersCount()` in the Election contract:

```csharp
public override Empty UpdateMinersCount(UpdateMinersCountInput input)
{
    Assert(
        Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
        "Only consensus contract can update miners count.");
    Assert(input.MinersCount > 0, "Miners count must be positive.");
    State.MinersCount.Value = input.MinersCount;
    SyncSubsidyInfoAfterReduceMiner();
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SetMinerIncreaseInterval_NegativeValue_CausesConsensusHalt()
{
    // Setup: Get current MinerIncreaseInterval
    var currentInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    currentInterval.Value.ShouldBeGreaterThan(0); // Verify positive initially
    
    // Attack: Parliament sets negative MinerIncreaseInterval
    var defaultOrganization = await ParliamentStubs.First().GetDefaultOrganizationAddress.CallAsync(new Empty());
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
        ContractMethodName = nameof(ConsensusStub.SetMinerIncreaseInterval),
        Params = new Int64Value { Value = -1 }.ToByteString(),
        ExpiredTime = TimestampHelper.GetUtcNow().AddDays(1),
        OrganizationAddress = defaultOrganization
    });
    
    // Verify negative value was set
    var newInterval = await ConsensusStub.GetMinerIncreaseInterval.CallAsync(new Empty());
    newInterval.Value.ShouldBe(-1);
    
    // Trigger calculation - this will compute negative miner count
    var autoIncreasedCount = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    autoIncreasedCount.Value.ShouldBeLessThan(0); // Negative miner count computed
    
    // Election contract will now have negative MinersCount
    var electionMinersCount = await ElectionStub.GetMinersCount.CallAsync(new Empty());
    electionMinersCount.Value.ShouldBeLessThan(0); // Negative value stored
    
    // GetVictories will return empty list due to .Take(negative) behavior
    var victories = await ElectionStub.GetVictories.CallAsync(new Empty());
    victories.Value.Count.ShouldBe(0); // Empty miner list - CONSENSUS HALT
}
```

## Notes

- The vulnerability exists due to missing positive value validation in a governance-controlled function
- While it requires governance authority, the missing validation represents a code defect that grants Parliament the unintended ability to break consensus
- This is a directly reachable invariant break: the fundamental requirement that miner count must be positive is violated by a single authorized function call
- The C# LINQ `.Take()` behavior with negative arguments (returning empty sequences) is the critical mechanism that translates the negative count into zero miners
- Existing tests only validate the "cannot increase" constraint but never test negative values
- The validation gap means even honest governance could accidentally trigger this through a proposal that appears to optimize the "miner growth rate"

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L23-26)
```csharp
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L61-61)
```csharp
        Assert(input.Value <= State.MinerIncreaseInterval.Value, "Invalid interval");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L92-94)
```csharp
        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L388-390)
```csharp
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L157-157)
```csharp
        State.MinersCount.Value = input.MinersCount;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-81)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-23)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
```
