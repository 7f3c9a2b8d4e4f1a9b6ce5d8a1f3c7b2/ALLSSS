### Title
Compromised System Contract Can Bypass Proposer Whitelist by Manipulating OriginProposer

### Summary
The `CreateProposalBySystemContract` method in Referendum (and Association/Parliament) contracts validates that `OriginProposer` is in the organization's whitelist but does not verify that `OriginProposer` matches the actual transaction originator (`Context.Origin`). A compromised system contract can exploit this by setting `OriginProposer` to any whitelisted address, completely bypassing the whitelist security control intended to restrict who can create proposals.

### Finding Description

**Root Cause:**

In `CreateProposalBySystemContract`, the whitelist validation checks the `input.OriginProposer` address provided by the calling system contract, without verifying it matches `Context.Origin` (the actual transaction signer). [1](#0-0) 

The method only validates:
1. That `Context.Sender` is a system contract (line 63)
2. That `input.OriginProposer` is in the whitelist (line 65) [2](#0-1) 

The whitelist check uses `Contains()` which simply validates membership: [3](#0-2) 

**Why Existing Protections Fail:**

While legitimate system contracts (Genesis, CrossChain) correctly set `OriginProposer = Context.Sender` (representing the user calling them): [4](#0-3) 

There is no enforcement that `OriginProposer` must equal `Context.Origin`. A search of the entire codebase confirms no such validation exists.

**Execution Path:**

1. Attacker controls a compromised system contract
2. Attacker calls `CreateProposalBySystemContract` on Referendum contract
3. Attacker sets `input.OriginProposer` to any address in the organization's whitelist (e.g., a legitimate proposer)
4. System contract check passes (compromised contract is still a system contract)
5. Whitelist check passes (chosen address is in whitelist)
6. Proposal is created with `Proposer = Context.Sender` (the compromised contract) [5](#0-4) 

7. Attacker can later release the approved proposal since they control the Proposer address [6](#0-5) 

### Impact Explanation

**Governance Authorization Bypass:**
The proposer whitelist is a critical governance control that restricts which addresses can create proposals for an organization. This vulnerability allows complete circumvention of this security mechanism.

**Concrete Impact:**
- An attacker with a compromised system contract can create proposals for ANY organization by impersonating whitelisted addresses
- The attacker can propose arbitrary contract calls (token transfers, parameter changes, contract upgrades, etc.)
- If the proposal gains approval votes, the attacker can execute it
- This violates the "Authorization & Governance" critical invariant requiring proper "proposer whitelist checks"

**Who Is Affected:**
All Referendum organizations (and similarly Association/Parliament organizations) that rely on proposer whitelists for access control. This affects governance decisions across consensus, economics, and system configuration.

**Severity Justification:**
Critical severity because it completely bypasses a fundamental authorization control, allowing unauthorized governance actions that could lead to fund theft, system misconfiguration, or consensus compromise.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of a compromised system contract (TokenContract, Genesis, CrossChain, or any other system contract)

**Attack Complexity:**
Once the precondition is met, exploitation is trivial:
1. Single call to `CreateProposalBySystemContract`
2. Set `OriginProposer` to any whitelisted address
3. No complex state manipulation or timing requirements

**Feasibility Conditions:**
- **High barrier:** Requires compromising a system contract, which should be rare given their security scrutiny
- **But:** The question explicitly scopes investigation to "if that contract is compromised"
- **Defense-in-depth principle:** Even trusted components should not enable privilege escalation if compromised
- System contracts already have extensive capabilities; this vulnerability provides additional unauthorized access to governance

**Detection Constraints:**
Difficult to detect - the proposal appears legitimate with a valid whitelisted proposer, only the actual `Proposer` field reveals the system contract origin.

**Probability Reasoning:**
While system contract compromise is a severe event, this vulnerability represents a failure of the least-privilege principle. The impact is significant because it amplifies the damage from a system contract compromise beyond what should be inherently possible.

### Recommendation

**Code-Level Mitigation:**

Add validation that `OriginProposer` matches the transaction originator in all three governance contracts:

```csharp
public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
{
    Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
        "Not authorized to propose.");
    Assert(input.OriginProposer == Context.Origin, 
        "Origin proposer must match transaction origin.");
    AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
    var proposalId = CreateNewProposal(input.ProposalInput);
    return proposalId;
}
```

Apply this fix to:
- `contract/AElf.Contracts.Referendum/Referendum.cs` (line 65)
- `contract/AElf.Contracts.Association/Association.cs` (line 118)
- `contract/AElf.Contracts.Parliament/Parliament.cs` (line 72)

**Invariant to Enforce:**
`OriginProposer == Context.Origin` in all `CreateProposalBySystemContract` calls, ensuring system contracts can only act on behalf of the actual transaction signer.

**Test Cases:**
Add tests verifying that `CreateProposalBySystemContract` fails when:
1. `OriginProposer` is in the whitelist but doesn't match `Context.Origin`
2. System contract attempts to set `OriginProposer` to a different address than transaction originator

### Proof of Concept

**Initial State:**
- Organization exists with Address A in proposer whitelist
- Address B (not in whitelist) controls a compromised system contract S
- Address A has never interacted with the system

**Attack Sequence:**

1. **Attacker (via compromised system contract S) calls CreateProposalBySystemContract:**
   ```
   Input:
   - OriginProposer = Address A (whitelisted, but not the actual caller)
   - ProposalInput = {arbitrary malicious proposal}
   Transaction signed by: Address B
   Context.Origin = Address B
   Context.Sender = System Contract S
   ```

2. **Expected behavior (current vulnerable code):**
   - System contract check: PASS (S is a system contract)
   - Whitelist check: PASS (Address A is in whitelist)
   - Proposal created with Proposer = S
   - **Result: SUCCESS** ❌ (Security violation)

3. **Expected behavior (with fix):**
   - System contract check: PASS (S is a system contract)
   - Origin validation: FAIL (Address A ≠ Context.Origin which is B)
   - **Result: FAILURE with "Origin proposer must match transaction origin"** ✓ (Security preserved)

**Success Condition for Attack:**
Proposal is created despite Address A never initiating the transaction, bypassing the whitelist's intent to authorize only Address A to create proposals.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L61-68)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L166-166)
```csharp
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L171-171)
```csharp
            Proposer = Context.Sender,
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Referendum/ProposerWhiteListExtensions.cs (L18-21)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L160-162)
```csharp
            },
            OriginProposer = Context.Sender
        };
```
