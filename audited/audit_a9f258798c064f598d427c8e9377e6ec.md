# Audit Report

## Title
Missed Time Slots Reset Without Evil Miner Detection at Term Boundaries

## Summary
The `ProcessNextTerm()` function resets `MissedTimeSlots` counters to zero for all miners when transitioning to a new term, but critically fails to check if any miner exceeded the evil threshold (4320 missed slots) before the reset. This allows miners with poor performance to avoid punishment by having their counters cleared at term boundaries without triggering the evil miner detection mechanism that only executes during round transitions.

## Finding Description

The AEDPoS consensus system has two distinct transition paths: round transitions (via `ProcessNextRound()`) and term transitions (via `ProcessNextTerm()`). Evil miner detection only occurs in one of these paths, creating a critical bypass vulnerability.

**During Round Transitions (Normal Operation):**

The `ProcessNextRound()` function correctly implements evil miner detection: [1](#0-0) 

This detection uses the `TryToDetectEvilMiners()` method which checks if any miner's `MissedTimeSlots` exceeds the tolerable threshold: [2](#0-1) 

The threshold is defined as 4320 slots (3 days at 1-minute intervals): [3](#0-2) 

**During Term Transitions (Vulnerability):**

However, the `ProcessNextTerm()` function follows a different code path that bypasses this check: [4](#0-3) 

Specifically, `ProcessNextTerm()` calls `CountMissedTimeSlots()` to increment the counter one final time: [5](#0-4) 

But then immediately resets all counters to zero without any evil detection check: [6](#0-5) 

**Why Existing Protections Fail:**

Missed time slots accumulate during normal round generation for miners who fail to produce blocks: [7](#0-6) 

While historical data is sent to the Election contract via `UpdateCurrentMinerInformationToElectionContract()`: [8](#0-7) 

The Election contract only accumulates this data for tracking purposes and does NOT trigger any automatic ban: [9](#0-8) 

The only banning mechanism requires explicit `IsEvilNode = true` flag: [10](#0-9) 

**Attack Execution Path:**

1. Attacker (current miner) strategically misses time slots during a term, accumulating up to ~4,319 missed slots
2. Term transition condition is triggered based on elapsed time: [11](#0-10) 
3. `ProcessNextTerm()` is called instead of `ProcessNextRound()`
4. `CountMissedTimeSlots()` may push the counter to 4,320+ 
5. Counter is immediately reset to 0 without `TryToDetectEvilMiners()` being invoked
6. Attacker continues in new term with clean slate (if re-elected)
7. Process repeats indefinitely across multiple terms

## Impact Explanation

This vulnerability breaks a **critical consensus integrity invariant**: miners must be held accountable for persistent poor performance through the evil node detection and banning mechanism.

**Direct Protocol Impact:**
- Miners can systematically underperform by missing ~4,300 slots per term across unlimited terms without facing the intended punishment
- With 1-minute time slots, this represents ~72 hours of continuous downtime per term
- The consensus mechanism's reliability is directly undermined as unreliable miners remain in the active set

**Affected Parties:**
- **Honest miners**: Disadvantaged as they maintain high availability while malicious miners reduce operational costs without consequence
- **Network users**: Experience degraded service quality with inconsistent block production
- **Economic model**: The entire reward and election system based on miner performance metrics is compromised

**Severity: HIGH** because:
- Completely bypasses an intended security mechanism (not a partial weakening)
- Allows indefinite exploitation across all future terms
- No automatic remediation - the punishment system is entirely circumvented
- Fundamentally undermines validator set trustworthiness

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a current miner in the active set (standard prerequisite for any consensus-level exploit)
- No additional privileges, tokens, or governance control required

**Attack Complexity: LOW**
1. Monitor own `MissedTimeSlots` counter via public round information queries
2. Intentionally miss time slots while staying just under 4,320 per term
3. Let natural term transitions reset the counter
4. Repeat indefinitely

**Feasibility: HIGH**
- **No timing precision required**: The vulnerability exists passively at every term boundary
- **No coordination needed**: Single miner acting alone can exploit
- **Strong economic incentive**: Reduce infrastructure/operational costs by running unreliable nodes
- **Detection difficult**: Requires manual cross-term historical analysis of accumulated missed slots

**Operational Constraints:**
Manual intervention is technically possible via the emergency response organization: [12](#0-11) 

However, this is reactive and requires:
- Continuous manual monitoring across term boundaries
- Governance process to identify and remove offenders
- Cannot prevent the underlying vulnerability from being exploited

**Probability: HIGH** - The combination of low complexity, passive exploitation, and strong economic incentive makes this highly likely to be exploited in a live environment.

## Recommendation

Add evil miner detection before counter reset in `ProcessNextTerm()`. The fix should mirror the logic in `ProcessNextRound()`:

**Recommended Fix Location:** `contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs`

Insert evil detection logic after `CountMissedTimeSlots()` (line 168) and before the counter reset (line 179):

```csharp
// Count missed time slot of current round.
CountMissedTimeSlots();

// ADD THIS: Detect evil miners before resetting counters
if (State.IsMainChain.Value && TryToGetCurrentRoundInformation(out var currentRound))
{
    if (currentRound.TryToDetectEvilMiners(out var evilMiners))
    {
        Context.LogDebug(() => "Evil miners detected at term boundary.");
        foreach (var evilMiner in evilMiners)
        {
            Context.LogDebug(() =>
                $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
            State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
            {
                Pubkey = evilMiner,
                IsEvilNode = true
            });
        }
    }
}

// Reset some fields of first two rounds of next term.
foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
{
    minerInRound.MissedTimeSlots = 0;
    minerInRound.ProducedBlocks = 0;
}
```

This ensures evil miners are detected and banned even when term transitions occur before they accumulate enough missed slots within a single round cycle.

## Proof of Concept

**Test Scenario:** A miner accumulates 4,320 missed slots across multiple rounds within a single term, then a term transition occurs.

**Expected Behavior:** The miner should be marked as an evil node and banned from consensus.

**Actual Behavior:** The miner's counter is reset to 0 without any ban, allowing them to continue in the next term.

**Code Evidence:**

The vulnerability can be confirmed by examining the two code paths:

1. **Round transition path** (includes evil detection): [13](#0-12) 

2. **Term transition path** (missing evil detection): [4](#0-3) 

A grep search confirms `TryToDetectEvilMiners()` is ONLY called in `ProcessNextRound()`, not in `ProcessNextTerm()`.

**Reproduction Steps:**
1. Deploy AEDPoS consensus contract in test environment
2. Create scenario where miner accumulates missed slots approaching 4,320 across multiple rounds
3. Trigger term transition before next round transition occurs
4. Verify miner's `MissedTimeSlots` counter is reset to 0
5. Verify no `EvilMinerDetected` event is fired
6. Verify miner remains in active set for next term

The vulnerability is confirmed by the asymmetric handling of the two transition types in the production code.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L87-96)
```csharp
    private void CountMissedTimeSlots()
    {
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return;

        foreach (var minerInRound in currentRound.RealTimeMinersInformation)
            if (minerInRound.Value.OutValue == null)
                minerInRound.Value.MissedTimeSlots = minerInRound.Value.MissedTimeSlots.Add(1);

        TryToUpdateRoundInformation(currentRound);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L52-55)
```csharp
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L115-118)
```csharp
        candidateInformation.ProducedBlocks = candidateInformation.ProducedBlocks.Add(input.RecentlyProducedBlocks);
        candidateInformation.MissedTimeSlots =
            candidateInformation.MissedTimeSlots.Add(input.RecentlyMissedTimeSlots);
        State.CandidateInformationMap[input.Pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L336-351)
```csharp
    public override Empty RemoveEvilNode(StringValue input)
    {
        Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
        var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Value));
        Assert(
            State.Candidates.Value.Value.Select(p => p.ToHex()).Contains(input.Value) ||
            State.InitialMiners.Value.Value.Select(p => p.ToHex()).Contains(input.Value),
            "Cannot remove normal node.");
        Assert(!State.BannedPubkeyMap[input.Value], $"{input.Value} already banned.");
        UpdateCandidateInformation(new UpdateCandidateInformationInput
        {
            Pubkey = input.Value,
            IsEvilNode = true
        });
        return new Empty();
    }
```
