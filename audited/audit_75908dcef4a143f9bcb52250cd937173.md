### Title
Domain Violation in GetAmountToPayFromReturn Causes DOS on Large Buy Orders

### Summary
The `GetAmountToPayFromReturn()` function in BancorHelper.cs fails to validate that the requested purchase amount is within the mathematical bounds of the Bancor formula. When a user attempts to buy more than approximately 50% of the available connector balance, the logarithm function throws an exception, causing all such buy transactions to revert with a cryptic error message.

### Finding Description

The vulnerability exists in the `GetAmountToPayFromReturn()` function where the calculation `x = bt / (bt - a)` at line 91 can produce values outside the valid domain of the natural logarithm function. [1](#0-0) 

The `Ln()` function has a strict domain requirement that its input must satisfy `0 < a < 2`, enforced by an exception: [2](#0-1) 

**Mathematical Analysis:**
- For `Ln(x)` to work: `0 < x < 2`
- Given `x = bt / (bt - a)` where `bt = toConnectorBalance` and `a = amountToReceive`
- For `x >= 2`: `bt / (bt - a) >= 2` → `bt >= 2(bt - a)` → `a >= bt/2`
- Therefore, when `amountToReceive >= toConnectorBalance/2`, the function throws

**Missing Protection:**
The function only validates that balances and amounts are positive, but does not check the upper bound: [3](#0-2) 

Note that the special case when connector weights are equal has a try-catch block with a clearer error message, but the general case at lines 91-93 lacks this protection: [4](#0-3) 

**Entry Point:**
The public `Buy()` function calls `GetAmountToPayFromReturn()` without validating the bounds: [5](#0-4) 

### Impact Explanation

**Operational DOS Impact:**
- Any buy transaction requesting more than ~50% of the available connector balance will fail with the error "must be 0 < a < 2"
- This creates a hard limit on purchase sizes that is not documented or enforced upfront
- Users receive cryptic mathematical error messages instead of clear validation failures

**Concrete Scenarios:**
1. **Small Balance Pools:** If `toConnectorBalance = 100` tokens, users cannot buy more than 49 tokens in a single transaction
2. **After Heavy Selling:** As connector balances get depleted through selling, the maximum purchaseable amount decreases proportionally
3. **Legitimate Large Purchases:** Institutional buyers or automated trading systems attempting large purchases will encounter unexplained failures

**Who is Affected:**
- Regular users attempting large purchases encounter DOS
- Protocol usability is degraded with confusing error messages
- Token liquidity is artificially constrained by the mathematical limitation

### Likelihood Explanation

**Attacker Capabilities Required:**
- None - any user can trigger this by calling the public `Buy()` function with appropriate parameters
- No special privileges or prior state manipulation needed

**Attack Complexity:**
- Trivial - single transaction with `input.Amount > toConnectorBalance/2`
- Can be triggered accidentally by legitimate users or intentionally by griefers

**Feasibility Conditions:**
- Entry point is the public `Buy()` method accessible to all users
- Only requires knowledge of current connector balance (publicly queryable)
- No economic cost to attempt (transaction just reverts)

**Probability:**
- HIGH - legitimate large purchases will naturally trigger this condition
- Becomes more likely as connector balances decrease through normal trading
- No detection or operational constraints prevent this

### Recommendation

**Add Explicit Bounds Validation:**

Add the following check in `GetAmountToPayFromReturn()` before line 91:

```csharp
// Validate that amountToReceive is within mathematical bounds
// x = bt/(bt-a) must be < 2, so a must be < bt/2
if (a >= bt / 2)
    throw new InvalidValueException(
        $"Amount to receive ({a}) must be less than half the connector balance ({bt/2})");

// Also check for complete depletion
if (a >= bt)
    throw new InvalidValueException(
        $"Amount to receive ({a}) exceeds available balance ({bt})");
```

**Alternative Approach:**

Implement the same try-catch pattern used in the equal-weights case (lines 81-89) for the general case, with a more descriptive error message.

**Test Cases to Add:**

1. Test buying exactly 50% of connector balance (boundary)
2. Test buying 50% + 1 (should fail with clear message)
3. Test buying more than total balance (should fail with clear message)
4. Test with very small connector balances to verify limits scale correctly

### Proof of Concept

**Initial State:**
- Token pair enabled (e.g., WRITE/ELF)
- `fromConnectorBalance` (ELF deposit) = 1,000,000
- `toConnectorBalance` (WRITE tokens) = 500,000
- `fromConnectorWeight` = 0.6
- `toConnectorWeight` = 0.5

**Exploitation Steps:**

1. User calls `Buy()` with parameters:
   - `input.Symbol = "WRITE"`
   - `input.Amount = 250,001` (more than half of 500,000)
   - `input.PayLimit = 0`

2. Execution trace:
   - `Buy()` calls `GetAmountToPayFromReturn(1000000, 0.6, 500000, 0.5, 250001)`
   - Line 91: `x = 500000 / (500000 - 250001) = 500000 / 249999 ≈ 2.00008`
   - Line 93: Calls `Ln(2.00008)`
   - Line 131 in `Ln()`: Check fails because `|1 - 2.00008| = 1.00008 >= 1`
   - Line 132: Throws `InvalidValueException("must be 0 < a < 2")`

**Expected Result:**
Transaction completes and user receives 250,001 WRITE tokens

**Actual Result:**
Transaction reverts with error: "must be 0 < a < 2"

**Success Condition:**
The Buy transaction fails with a cryptic mathematical error instead of a clear bounds validation error, demonstrating the DOS condition for large purchase amounts.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-73)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L80-89)
```csharp
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L131-132)
```csharp
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```
