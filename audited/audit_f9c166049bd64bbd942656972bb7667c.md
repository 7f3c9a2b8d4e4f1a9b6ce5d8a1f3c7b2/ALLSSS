### Title
Authorization Bypass: Unauthorized Miners Can Gain Extra Block Production Rights Through Premature NextRound Execution

### Summary
Any miner in the current round can gain unfair block production advantages by mining a NextRound block before the legitimately designated extra block producer. The system automatically assigns `ExtraBlockProducerOfPreviousRound` to whoever successfully mines the NextRound block without validating they are the legitimate extra block producer, granting them `(_maximumBlocksCount + blocksBeforeCurrentRound)` block production rights in the subsequent round.

### Finding Description

**Root Cause:**

The vulnerability stems from three critical gaps in the AEDPoS consensus mechanism:

1. **Unrestricted NextRound Behavior Assignment**: Any miner whose time slot has passed can obtain NextRound consensus behavior, not just the designated extra block producer. [1](#0-0) 

2. **Automatic ExtraBlockProducerOfPreviousRound Assignment**: When any miner mines a NextRound block, their pubkey is unconditionally set as `ExtraBlockProducerOfPreviousRound` without validation. [2](#0-1) 

3. **Privileged Block Production Rights**: In the next round, miners with their pubkey matching `ExtraBlockProducerOfPreviousRound` receive extended block production rights. [3](#0-2) 

**Why Protections Fail:**

The validation providers fail to prevent this attack:

- **TimeSlotValidationProvider**: For NextRound blocks (new round ID), only validates that the NEW round's time slots are properly structured, NOT the timing of when the NextRound block can be mined. [4](#0-3) 

- **RoundTerminateValidationProvider**: Only validates round number increment and that InValues are null, but does NOT validate who is authorized to call NextRound or whether `ExtraBlockProducerOfPreviousRound` is correctly set. [5](#0-4) 

- **PreCheck Authorization**: Only verifies the miner is in the current or previous miner list, not whether they are the designated extra block producer. [6](#0-5) 

- **Client-Side Timing**: The `MiningRequestService` validates `MiningDueTime` constraints, but this is client-side validation that malicious nodes can bypass. [7](#0-6) 

**Execution Path:**

1. Each round has one designated extra block producer determined by `CalculateNextExtraBlockProducerOrder()`. [8](#0-7) 

2. When GetConsensusBehaviour is invoked and the miner's time slot has passed but they haven't exhausted their blocks, the method returns `GetConsensusBehaviourToTerminateCurrentRound()` which yields NextRound behavior for ANY miner, not just the designated extra block producer. [9](#0-8) 

3. The NextRound transaction processes through `ProcessConsensusInformation` â†’ `ProcessNextRound`, which accepts the provided round information without validating the legitimacy of the round terminator. [10](#0-9) 

4. The `NextRoundInput.ToRound()` method propagates the `ExtraBlockProducerOfPreviousRound` field from the input (set by the attacker) into the new round state. [11](#0-10) 

### Impact Explanation

**Consensus Integrity Violation:**
- The attacker gains `(_maximumBlocksCount + blocksBeforeCurrentRound)` block production rights in the next round, while legitimate extra block producers lose their rightful privileges
- This breaks the fundamental fairness invariant of the AEDPoS consensus mechanism where block production opportunities should be distributed according to the deterministic extra block producer selection algorithm

**Quantified Damage:**
- If `_maximumBlocksCount` = 8 and `blocksBeforeCurrentRound` = 0, the attacker gains 8 extra tiny blocks per successful exploit
- Repeated exploitation across multiple rounds multiplies the advantage
- The attacker can produce more blocks than their fair share, gaining disproportionate mining rewards and transaction fee revenue
- Potential for block censorship and MEV (Miner Extractable Value) extraction through the extra blocks

**Affected Parties:**
- Legitimate extra block producers who lose their designated privileges
- Other miners who face unfair competition
- The overall network suffers from compromised consensus fairness
- DApp users may experience transaction censorship if the attacker uses extra blocks maliciously

**Severity Justification:**
CRITICAL - This vulnerability violates the core consensus invariant "Correct round transitions and time-slot validation, miner schedule integrity." It allows unauthorized miners to gain unfair block production advantages, undermining the security model of the AEDPoS consensus system.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be in the current miner list (realistic prerequisite for a consensus attack)
- Requires modifying node software to bypass client-side `MiningDueTime` validation and mine NextRound blocks prematurely
- Needs reasonable network connectivity to propagate blocks before the legitimate extra block producer

**Attack Complexity:**
- **MODERATE**: The attacker must:
  1. Run a modified node that ignores `ArrangedMiningTime` constraints
  2. Monitor for the moment their time slot passes
  3. Immediately mine and propagate a NextRound block
  4. Win the race against the legitimate extra block producer

**Feasibility Conditions:**
- The attack window opens when the attacker's time slot passes but before the designated extra block producer mines
- Network latency and block propagation speed determine success probability
- No cryptographic or economic barriers prevent execution

**Detection Constraints:**
- Difficult to distinguish from legitimate fallback scenarios where the designated extra block producer is offline
- The behavior appears as a "normal" round termination from an on-chain observer's perspective
- Off-chain monitoring could detect patterns of premature NextRound blocks from the same miner

**Probability Assessment:**
HIGH - Any miner in the consensus set can attempt this attack with reasonable success probability. The modified node software is straightforward to implement, and the attack can be repeated across rounds to accumulate advantages. The lack of on-chain validation makes detection and prevention challenging.

### Recommendation

**Immediate Mitigation:**

1. **Add Extra Block Producer Authorization Check**: In `GetConsensusExtraDataForNextRound`, verify that only the designated extra block producer (identified by `IsExtraBlockProducer = true`) can successfully mine NextRound blocks:

```csharp
// In AEDPoSContract_GetConsensusBlockExtraData.cs, before line 178
var extraBlockProducer = currentRound.GetExtraBlockProducerInformation();
Assert(extraBlockProducer.Pubkey == pubkey, 
    "Only the designated extra block producer can terminate the round.");
``` [12](#0-11) 

2. **Validate ExtraBlockProducerOfPreviousRound Field**: In `RoundTerminateValidationProvider.ValidationForNextRound`, add validation that the provided `ExtraBlockProducerOfPreviousRound` matches the sender:

```csharp
// In RoundTerminateValidationProvider.cs
if (extraData.Round.ExtraBlockProducerOfPreviousRound != 
    validationContext.SenderPubkey)
    return new ValidationResult { 
        Message = "ExtraBlockProducerOfPreviousRound must match block producer." 
    };
``` [5](#0-4) 

3. **Restrict NextRound Behavior**: In `ConsensusBehaviourProviderBase.GetConsensusBehaviour`, ensure only the designated extra block producer receives NextRound behavior under normal circumstances:

```csharp
// Before line 82, add:
var extraBlockProducer = CurrentRound.GetExtraBlockProducerInformation();
if (extraBlockProducer.Pubkey != _pubkey)
    // Only designated extra block producer or after significant timeout
    return AElfConsensusBehaviour.Nothing;
``` [1](#0-0) 

**Test Cases:**
- Test that non-extra-block-producers cannot mine NextRound blocks
- Test that `ExtraBlockProducerOfPreviousRound` validation rejects mismatched values
- Test fallback mechanism when designated extra block producer is offline (allow after timeout)
- Test that extra block production rights are only granted to legitimate extra block producers

### Proof of Concept

**Initial State:**
- Current round N with miners A, B, C, D, E
- Miner E is designated as extra block producer (IsExtraBlockProducer = true)
- Miner A has already mined their normal block in time slot 1
- Current time has passed Miner A's time slot but not yet reached the extra block time slot

**Attack Steps:**

1. **Miner A requests consensus command** at time T1 (after their slot but before extra block time):
   - Calls `GetConsensusCommand` 
   - Returns NextRound behavior (because time slot passed) [13](#0-12) 

2. **Miner A mines NextRound block prematurely**:
   - Modified node ignores `ArrangedMiningTime` constraint
   - Calls `GetConsensusExtraData` which sets `nextRound.ExtraBlockProducerOfPreviousRound = Miner A's pubkey`
   - Mines and propagates block immediately [14](#0-13) 

3. **Block validation passes**:
   - `TimeSlotValidationProvider` only checks new round's time slots, not timing of NextRound block itself
   - `RoundTerminateValidationProvider` validates round number and InValues, but not authorization
   - Block is accepted into blockchain [15](#0-14) 

4. **NextRound transaction processes**:
   - `ProcessNextRound` accepts the round with `ExtraBlockProducerOfPreviousRound = Miner A`
   - No validation that Miner A was the legitimate extra block producer [10](#0-9) 

5. **In Round N+1, Miner A exploits extra rights**:
   - When Miner A calls `GetConsensusBehaviour` in round N+1
   - Condition at lines 71-73 evaluates to true (ExtraBlockProducerOfPreviousRound == Miner A)
   - Miner A can produce `(_maximumBlocksCount + blocksBeforeCurrentRound)` blocks [3](#0-2) 

**Expected Result:**
- Only Miner E (designated extra block producer) should be able to terminate round N
- Only Miner E's pubkey should be set as `ExtraBlockProducerOfPreviousRound`
- Only Miner E should receive extra block production rights in round N+1

**Actual Result:**
- Miner A successfully mines NextRound block before Miner E
- Miner A's pubkey is set as `ExtraBlockProducerOfPreviousRound`
- In round N+1, Miner A gains unauthorized extra block production rights
- Miner E (legitimate extra block producer) loses their rightful privileges

**Success Condition:**
Miner A successfully produces more than `_maximumBlocksCount` blocks in round N+1 due to the condition at lines 71-73, confirming the authorization bypass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-34)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** src/AElf.Kernel/Miner/Application/IMiningRequestService.cs (L47-64)
```csharp
    private bool ValidateBlockMiningTime(Timestamp blockTime, Timestamp miningDueTime,
        Duration blockExecutionDuration)
    {
        if (miningDueTime - Duration.FromTimeSpan(TimeSpan.FromMilliseconds(250)) <
            blockTime + blockExecutionDuration)
        {
            Logger.LogDebug(
                "Mining canceled because mining time slot expired. MiningDueTime: {MiningDueTime}, BlockTime: {BlockTime}, Duration: {BlockExecutionDuration}",
                miningDueTime, blockTime, blockExecutionDuration);
            return false;
        }

        if (blockTime + blockExecutionDuration >= TimestampHelper.GetUtcNow()) return true;
        Logger.LogDebug(
            "Will cancel mining due to timeout: Actual mining time: {BlockTime}, execution limit: {BlockExecutionDuration} ms",
            blockTime, blockExecutionDuration.Milliseconds());
        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L59-65)
```csharp
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-92)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```
