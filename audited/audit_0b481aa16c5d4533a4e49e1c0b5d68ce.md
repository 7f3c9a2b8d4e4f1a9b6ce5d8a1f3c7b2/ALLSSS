### Title
Miner List Manipulation via Unvalidated NextTerm Input Allows Consensus Takeover

### Summary
The `NextTerm` method accepts miner list data in `NextTermInput` without validating it against election results from `ElectionContract.GetVictories()`. Any current miner can submit a `NextTerm` transaction with an arbitrary miner list, bypassing the election system to maintain indefinite control over consensus by repeatedly submitting fraudulent term transitions.

### Finding Description

The root cause is in the term transition flow where the new miner list is accepted without on-chain validation: [1](#0-0) 

At lines 188-190, `ProcessNextTerm` extracts the miner list directly from the `NextTermInput` parameter and calls `SetMinerList` without any validation against election results. The intended flow uses `GenerateFirstRoundOfNextTerm` (a view method) to obtain legitimate election results: [2](#0-1) 

This view method calls `TryToGetVictories` at line 228, which retrieves legitimate miners from the election contract: [3](#0-2) 

However, this entire flow occurs **off-chain**. The resulting `NextTermInput` is created off-chain and submitted in a transaction: [4](#0-3) 

The validation system fails to catch this manipulation. The `RoundTerminateValidationProvider` only validates term/round number increments: [5](#0-4) 

The validation checks at lines 40-46 only verify that the round number increments by 1 (via `ValidationForNextRound`) and the term number increments by 1. There is **no validation** that the miner list in `NextTermInput.RealTimeMinersInformation` matches the results from `ElectionContract.GetVictories()`.

The `ValidateConsensusAfterExecution` method also fails to validate election results: [6](#0-5) 

Lines 116-123 only validate within-term miner replacements (via `GetNewestPubkey`), not term transition miner lists against election results.

### Impact Explanation

**Consensus Integrity Compromise**: An attacker can completely bypass the election system, which is the fundamental security mechanism for determining legitimate block producers. The election system allows token holders to vote for validators, but this vulnerability renders those votes meaningless.

**Indefinite Control**: Once a miner gains control, they can perpetuate it indefinitely by:
- Including themselves in every subsequent term's miner list
- Excluding legitimate elected validators
- Including accomplice nodes to maintain majority control

**Protocol Damage**: 
- The 2/3 consensus threshold becomes meaningless when the miner set is attacker-controlled
- Treasury reward distribution is corrupted as rewards go to fraudulent miners
- Cross-chain security degrades as side chains rely on main chain miner integrity
- Token holder governance via elections is nullified

**Affected Parties**: All network participants lose security guarantees, legitimate validators lose mining rewards, and token holders lose their voting power.

### Likelihood Explanation

**Reachable Entry Point**: Any current round miner can call the public `NextTerm` method when term change conditions are met. [7](#0-6) 

**Feasible Preconditions**: The attacker must be:
1. A current miner in the active round (easily achievable through normal election initially)
2. At a term transition point (occurs periodically based on `PeriodSeconds` configuration)

**Execution Practicality**: 
1. Attacker monitors when `NeedToChangeTerm` becomes true
2. Attacker calls `GenerateFirstRoundOfNextTerm` off-chain to get the proper structure
3. Attacker modifies `NextTermInput.Round.RealTimeMinersInformation` to include desired miners
4. Attacker produces block with modified `NextTerm` transaction during their time slot
5. Block passes all validation (no miner list verification exists)
6. Fraudulent miner list is set via `SetMinerList`

**Detection Difficulty**: The attack appears as a normal term transition. Off-chain monitoring would need to compare on-chain miner lists with election results to detect the manipulation.

**Economic Rationality**: Mining rewards and consensus control far exceed the minimal cost of producing a single malicious block. The attacker gains ongoing block production rewards while excluding competitors.

### Recommendation

Add mandatory on-chain validation that the miner list in `NextTermInput` matches the election contract's results. Implement in `ProcessNextTerm` before calling `SetMinerList`:

1. **Add validation before miner list update** (in `AEDPoSContract_ProcessConsensusInformation.cs` around line 187):
   - Call `State.ElectionContract.GetVictories.Call(new Empty())` to retrieve legitimate election results
   - Extract pubkeys from both `nextRound.RealTimeMinersInformation.Keys` and the victories
   - Assert that the sets match exactly (order-independent comparison)
   - Reject the transaction if validation fails

2. **Add validation in RoundTerminateValidationProvider** (in `ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs`):
   - For `NextTerm` behavior, add election result validation
   - Call election contract during validation to get expected miner list
   - Compare against provided round's miner list
   - Return validation failure if mismatch detected

3. **Add test cases**:
   - Test that `NextTerm` with correct miner list succeeds
   - Test that `NextTerm` with modified miner list fails validation
   - Test that `NextTerm` excluding elected miners fails
   - Test that `NextTerm` including non-elected miners fails

### Proof of Concept

**Initial State**:
- Term N, Round X in progress
- Miner A is current validator with 10% vote weight
- Elections complete: Miner A received lowest votes, should be removed in Term N+1
- Miners B, C, D, E received highest votes and should form Term N+1 miner set

**Attack Sequence**:
1. **Miner A monitors term change**: Waits until `NeedToChangeTerm(blockchainStartTimestamp, termNumber, periodSeconds)` returns true
2. **Miner A queries election results**: Off-chain call to `GenerateFirstRoundOfNextTerm` reveals Miner A is excluded
3. **Miner A crafts malicious NextTermInput**: 
   - Copies structure from legitimate `GenerateFirstRoundOfNextTerm` output
   - Modifies `Round.RealTimeMinersInformation` to include Miner A and exclude Miner E
   - Maintains proper term/round number increments to pass `RoundTerminateValidationProvider`
4. **Miner A produces block**: During their time slot, produces block with `NextTerm` transaction containing malicious input
5. **Validation passes**: 
   - `MiningPermissionValidationProvider`: ✓ (Miner A is in current round)
   - `TimeSlotValidationProvider`: ✓ (within time slot)
   - `RoundTerminateValidationProvider`: ✓ (term/round numbers increment correctly)
   - Miner list validation: ✗ **MISSING**
6. **State updated**: `ProcessNextTerm` executes, `SetMinerList` accepts fraudulent list
7. **Result**: Term N+1 begins with Miner A included, legitimate Miner E excluded

**Expected vs Actual**:
- **Expected**: Term N+1 miner list = [B, C, D, E] per election results
- **Actual**: Term N+1 miner list = [A, B, C, D] per malicious `NextTermInput`
- **Success Condition**: Query `GetCurrentMinerList` shows Miner A present in Term N+1 despite election exclusion

**Repetition**: Miner A repeats this attack at every term transition, maintaining indefinite control over consensus while nullifying all elections.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L172-179)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
