### Title
Unvalidated Negative Order Assignment Enables Mining Schedule Corruption

### Summary
The `ProcessUpdateValue` function accepts arbitrary `int32` values in `TuneOrderInformation` and assigns them to miners' `FinalOrderOfNextRound` without validation. A malicious miner can inject negative values that bypass the `ableOrders` range check in `GenerateNextRoundInformation`, resulting in negative order assignments, past-dated mining timestamps, and corrupted consensus schedules.

### Finding Description

The vulnerability originates in the `ProcessUpdateValue` method where `TuneOrderInformation` values are applied without validation: [1](#0-0) 

The protobuf definition shows `tune_order_information` accepts `int32` values (which can be negative): [2](#0-1) 

Similarly, `final_order_of_next_round` is defined as `int32`: [3](#0-2) 

When `GenerateNextRoundInformation` processes these negative values, it directly assigns them to the next round's miner orders: [4](#0-3) 

The `ableOrders` range check only creates positive orders (1 to minersCount), so negative orders in `occupiedOrders` don't filter out any valid positions: [5](#0-4) 

This results in:
1. Miners assigned negative `Order` values
2. `ExpectedMiningTime` calculated with negative multipliers, producing timestamps in the past (line 33)
3. Missing order positions in the valid range (e.g., if 5 miners exist but one has order -1, position 5 is unassigned)
4. Potential failures in consensus logic expecting specific orders (lines 61, 79, 94)

The only access control is that the caller must be a legitimate miner: [6](#0-5) 

However, this doesn't prevent a malicious or compromised miner from exploiting this vulnerability.

### Impact Explanation

**Consensus Integrity Impact:**
- **Mining Schedule Corruption**: Miners with negative orders receive past-dated `ExpectedMiningTime` values, breaking the chronological mining sequence
- **Order Sequence Gaps**: Valid order positions remain unassigned (e.g., with 5 miners, if one gets order -1, order 5 is missing)
- **Extra Block Producer Selection Failure**: Logic expecting specific orders may fail to find matching miners
- **BreakContinuousMining Logic Failure**: Functions searching for miners at specific order positions (1, 2, minersCount, minersCount-1) may return null or throw exceptions

**Who is Affected:**
- All network participants experiencing disrupted consensus
- Honest miners unable to mine at their expected times
- The entire blockchain's block production schedule

**Severity Justification:**
Medium severity due to consensus disruption potential. While it doesn't directly steal funds, it can:
- Cause consensus deadlock or delays
- Force manual intervention to recover
- Undermine trust in the consensus mechanism
- Enable specific miners to manipulate block production order

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a legitimate miner (passes `PreCheck` validation)
- Can be a compromised miner or intentionally malicious node operator
- No additional privileges beyond being in the current miner list required

**Attack Complexity:**
- Low complexity: Single transaction calling `UpdateValue` with crafted `TuneOrderInformation`
- No timing dependencies or complex state manipulation needed
- Can target any miner's order by specifying their pubkey

**Feasibility Conditions:**
- Entry point is the public `UpdateValue` method accessible to all miners
- No rate limiting or value validation prevents repeated attacks
- Attack is undetectable until next round generation occurs

**Economic Rationality:**
- Minimal cost: One transaction with standard gas fees
- Potential gain: Disrupting competitors' mining, manipulating block order for MEV
- Risk: Detection possible through anomalous mining schedules, but attribution difficult

**Probability Assessment:**
Medium likelihood. While requiring miner status, the barrier is realistic given:
- Miner pools may have security vulnerabilities
- Economic incentives exist to manipulate mining order
- Attack is straightforward and unvalidated

### Recommendation

**Immediate Mitigation:**
Add validation in `ProcessUpdateValue` before applying `TuneOrderInformation`:

```csharp
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount, 
        $"Invalid order value: {tuneOrder.Value}. Must be in range [1, {minersCount}]");
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key), 
        "Cannot set order for non-existent miner");
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Checks:**
Validate in `GenerateNextRoundInformation` as defense-in-depth:

```csharp
foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
{
    var order = minerInRound.FinalOrderOfNextRound;
    Assert(order >= 1 && order <= minersCount, 
        $"Invalid FinalOrderOfNextRound: {order} for miner {minerInRound.Pubkey}");
    // ... rest of assignment
}
```

**Test Cases:**
1. Attempt `UpdateValue` with negative `TuneOrderInformation` values (should fail)
2. Attempt `UpdateValue` with values > minersCount (should fail)
3. Attempt `UpdateValue` with values = 0 (should fail)
4. Verify legitimate values [1, minersCount] still work correctly
5. Test that miners cannot set orders for non-existent pubkeys

### Proof of Concept

**Initial State:**
- 5 active miners: A, B, C, D, E in current round
- Miner A is malicious/compromised
- Current round in progress

**Attack Sequence:**

**Step 1:** Miner A produces block and calls `UpdateValue` with malicious input:
```
UpdateValueInput {
  // ... normal fields ...
  TuneOrderInformation: {
    "B's_Pubkey": -1,  // Negative order for miner B
    "D's_Pubkey": 0    // Zero order for miner D
  }
}
```

**Step 2:** `ProcessUpdateValue` executes without validation, setting:
- `currentRound.RealTimeMinersInformation[B's_Pubkey].FinalOrderOfNextRound = -1`
- `currentRound.RealTimeMinersInformation[D's_Pubkey].FinalOrderOfNextRound = 0`

**Step 3:** Next miner triggers round transition, calling `GenerateNextRoundInformation`

**Expected Result (Vulnerable):**
- Miner B gets `Order = -1` in nextRound
- Miner B's `ExpectedMiningTime` = currentTime + (miningInterval × -1) = time in the past
- Miner D gets `Order = 0` in nextRound  
- Valid orders [1, 5] have gaps (e.g., positions 4 and 5 unassigned)
- `BreakContinuousMining` fails at line 79 trying to find Order = 1

**Expected Result (After Fix):**
- Transaction reverts with "Invalid order value" assertion
- Current round state unchanged
- Mining schedule preserved

**Success Condition:**
Attack succeeds if nextRound contains miners with Order ≤ 0, confirming mining schedule corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-330)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** protobuf/aedpos_contract.proto (L289-290)
```text
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```
