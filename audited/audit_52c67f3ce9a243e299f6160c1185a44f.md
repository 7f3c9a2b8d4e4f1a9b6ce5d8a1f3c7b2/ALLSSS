### Title
Secret Sharing Information Permanently Stored On-Chain Enabling Retrospective InValue Recovery

### Summary
The `DeleteSecretSharingInformation()` method only clears encrypted and decrypted pieces from Round objects returned in consensus headers, but does not remove them from persistent blockchain storage in `State.Rounds`. This allows anyone to query historical round information via the public `GetRoundInformation` view method and recover miners' secret InValues using the stored decrypted pieces, completely undermining the secret sharing security mechanism.

### Finding Description

The vulnerability exists in how secret sharing information is managed across the consensus contract:

**Storage Path:** When miners produce blocks, their encrypted and decrypted pieces are stored to persistent blockchain state via `PerformSecretSharing`, which adds pieces to the Round object, followed by `TryToUpdateRoundInformation` that writes the complete Round (including all secret pieces) to `State.Rounds[roundNumber]`. [1](#0-0) [2](#0-1) [3](#0-2) 

**Deletion Path:** The `DeleteSecretSharingInformation()` method clears encrypted and decrypted pieces from Round objects, but is ONLY called when preparing consensus block extra data for headers (not for generating transactions), and only affects the returned object - not the already-persisted state. [4](#0-3) [5](#0-4) 

**Exposure Path:** The public view method `GetRoundInformation` directly returns Round objects from `State.Rounds` without any filtering, exposing all stored encrypted and decrypted pieces. [6](#0-5) [7](#0-6) [8](#0-7) 

**Recovery Mechanism:** The contract itself demonstrates how to recover InValues from decrypted pieces using `SecretSharingHelper.DecodeSecret`, requiring only 2/3 of miners' decrypted pieces. [9](#0-8) 

### Impact Explanation

This vulnerability has **HIGH severity** impact on consensus integrity:

1. **Secret Sharing Security Broken**: The entire purpose of the secret sharing mechanism is defeated. InValues are meant to remain secret until explicitly revealed, but all decrypted pieces are permanently stored on-chain.

2. **Retrospective Analysis**: Any party can reconstruct past InValues by querying historical rounds and using the publicly available `SecretSharingHelper.DecodeSecret` method with the stored decrypted pieces.

3. **Consensus Predictability**: InValues are used for random number generation in consensus. Recovering past InValues could enable analysis of consensus behavior patterns and potentially predict future randomness if there are implementation weaknesses in InValue generation.

4. **Protocol-Wide Exposure**: This affects all consensus rounds where secret sharing is enabled, potentially compromising the entire consensus history since deployment.

The impact is concrete because the secret sharing mechanism is explicitly designed to protect InValues, and this vulnerability completely bypasses that protection by permanently storing the decryption keys on-chain.

### Likelihood Explanation

The likelihood of exploitation is **VERY HIGH**:

1. **Zero Barrier Entry**: `GetRoundInformation` is a public view method with no authentication or permission checks. Any user can call it. [10](#0-9) 

2. **Trivial Execution**: Exploitation requires only:
   - Query `GetRoundInformation` for any past round number
   - Extract `DecryptedPieces` from the returned Round object
   - Use the publicly available recovery algorithm to reconstruct InValues

3. **No Detection**: Querying view methods leaves no transaction trace, making exploitation undetectable.

4. **Zero Cost**: View methods are free to call, requiring no transaction fees.

5. **Always Available**: Historical round data persists in `State.Rounds` for multiple rounds (controlled by `AEDPoSContractConstants.KeepRounds`), providing a wide window of exposure.

The attack is not theoretical - the contract storage, view method exposure, and recovery algorithm are all confirmed in the codebase.

### Recommendation

Implement a two-phase approach to properly sanitize stored Round data:

1. **Immediate Fix - Clear Before Storage**: Modify `ProcessUpdateValue` to clear secret sharing information from the Round object BEFORE calling `TryToUpdateRoundInformation`:

```csharp
// After line 283 in AEDPoSContract_ProcessConsensusInformation.cs
currentRound.DeleteSecretSharingInformation();
if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

2. **Long-term Fix - Separate Storage**: Store secret sharing information in a separate, non-persistent data structure (memory-only or time-limited cache) rather than in `State.Rounds`. Secret pieces should only exist in-memory during active consensus rounds and never be written to permanent blockchain state.

3. **Add Protection to View Method**: Modify `GetRoundInformation` to return sanitized Round objects by calling `DeleteSecretSharingInformation()` before returning:

```csharp
// In AEDPoSContract_ViewMethods.cs
public override Round GetRoundInformation(Int64Value input)
{
    if (!TryToGetRoundInformation(input.Value, out var round)) return new Round();
    round.DeleteSecretSharingInformation();
    return round;
}
```

4. **Invariant Check**: Add assertion that verifies secret pieces are cleared before storage operations.

5. **Regression Test**: Add test case that verifies `GetRoundInformation` never returns non-empty `EncryptedPieces` or `DecryptedPieces` collections.

### Proof of Concept

**Initial State:**
- AEDPoS consensus is running with secret sharing enabled
- Multiple rounds have completed with miners performing normal block production

**Exploitation Steps:**

1. Attacker queries any past round information:
   ```
   Call: GetRoundInformation(round_number)
   ```

2. From the returned Round object, extract decrypted pieces:
   ```
   For each miner in round.RealTimeMinersInformation:
       If miner.DecryptedPieces.Count >= 2/3 of total miners:
           Extract DecryptedPieces and corresponding orders
   ```

3. Use the contract's own recovery algorithm to reconstruct InValue:
   ```
   Call: SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount)
   Compute: InValue = Hash.ComputeFrom(decoded_secret)
   ```

**Expected Result:** Secret pieces should not be accessible from storage; the method should return empty collections.

**Actual Result:** Complete decrypted pieces are returned in the Round object, enabling full InValue reconstruction.

**Success Condition:** Attacker successfully recovers one or more miners' past InValues that were supposed to remain secret until explicitly revealed through the consensus mechanism.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L284-284)
```csharp
        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L66-70)
```csharp
    private bool TryToGetRoundInformation(long roundNumber, out Round round)
    {
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L26-29)
```csharp
    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L26-26)
```csharp
    public MappedState<long, Round> Rounds { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L13-54)
```csharp
    private void RevealSharedInValues(Round currentRound, string publicKey)
    {
        Context.LogDebug(() => "About to reveal shared in values.");

        if (!currentRound.RealTimeMinersInformation.ContainsKey(publicKey)) return;

        if (!TryToGetPreviousRoundInformation(out var previousRound)) return;

        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;

        foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
        {
            // Skip himself.
            if (pair.Key == publicKey) continue;

            if (!currentRound.RealTimeMinersInformation.Keys.Contains(pair.Key)) continue;

            var publicKeyOfAnotherMiner = pair.Key;
            var anotherMinerInPreviousRound = pair.Value;

            if (anotherMinerInPreviousRound.EncryptedPieces.Count < minimumCount) continue;
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
        }
    }
```

**File:** protobuf/aedpos_contract.proto (L78-80)
```text
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
```
