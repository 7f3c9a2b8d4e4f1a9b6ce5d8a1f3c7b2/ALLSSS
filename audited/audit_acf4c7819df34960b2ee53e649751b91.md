### Title
Round 1 ActualMiningTime Manipulation Allows Consensus Time Slot Bypass

### Summary
In Round 1 of AEDPoS consensus, the `IsTimeSlotPassed()` function relies on the first miner's `ActualMiningTimes` to determine if other miners' time slots have passed. Due to missing validation that the `ActualMiningTime` in consensus transactions matches the block header or `Context.CurrentBlockTime`, and the exclusion of `ActualMiningTimes` from round hash validation, a malicious first miner can manipulate this value to artificially advance or delay when other miners' time slots are considered passed, enabling out-of-order block production.

### Finding Description

**Root Cause**: Missing validation of `ActualMiningTime` field integrity between block header and transaction input, combined with disabled time slot validation in Round 1.

**Code Locations**:

1. **Round 1 special logic in `IsTimeSlotPassed()`**: [1](#0-0) 

The function uses the first miner's first `ActualMiningTime` as the reference point to calculate which mining orders should be active.

2. **No time slot validation in Round 1**: [2](#0-1) 

Time slot validation returns `true` immediately for the first round of current term (line 39), skipping all checks.

3. **ActualMiningTime committed from transaction input without validation**: [3](#0-2) 

At line 243, `ActualMiningTime` from `UpdateValueInput` is added to state without verifying it matches `Context.CurrentBlockTime`.

4. **ActualMiningTimes excluded from round hash validation**: [4](#0-3) 

Line 193 clears `ActualMiningTimes` before hash computation, preventing detection of mismatches between header and transaction values.

5. **After-execution validation doesn't check ActualMiningTime**: [5](#0-4) 

The hash comparison at lines 100-101 won't detect ActualMiningTime manipulation since these fields are excluded from the hash.

**Why Protections Fail**:
- Block header contains ActualMiningTime derived from `Context.CurrentBlockTime` (set during header generation)
- Consensus transaction contains separate ActualMiningTime field from `UpdateValueInput`
- No validation enforces these two values match
- ActualMiningTimes excluded from round hash means post-execution validation misses the discrepancy
- Round 1 skips time slot validation entirely

### Impact Explanation

**Consensus Integrity Compromise**: A malicious first miner in Round 1 can manipulate the consensus time reference, causing:

1. **Premature Time Slot Activation**: By setting `ActualMiningTime` to an earlier timestamp (e.g., 10 mining intervals earlier), the calculation `expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1)` returns inflated values, making miners with higher order numbers believe their slots have passed when they haven't.

2. **Out-of-Order Block Production**: Miners who shouldn't be able to produce blocks yet would pass the `IsTimeSlotPassed()` check, enabling them to mine out of sequence.

3. **Delayed Time Slot Activation**: Conversely, setting `ActualMiningTime` to a later timestamp prevents legitimate miners from recognizing their turn has arrived, causing missed blocks.

4. **Chain Startup Manipulation**: Since blockchain start timestamp is derived from the first miner's `ActualMiningTime` (line 121-123 in ProcessNextRound), manipulation affects all subsequent term timing calculations. [6](#0-5) 

**Severity**: HIGH - Violates the critical invariant of "Correct round transitions and time-slot validation, miner schedule integrity" by allowing manipulation of the consensus time reference that all Round 1 miners depend on.

### Likelihood Explanation

**Attacker Capabilities**: Requires being the first miner (Order == 1) in Round 1 of any term.

**Attack Complexity**: LOW
1. Produce block with legitimate header containing `Context.CurrentBlockTime` in consensus extra data
2. Include `UpdateValue` transaction with manipulated `ActualMiningTime` (e.g., current time - 300 seconds)
3. Block passes validation because:
   - Round 1 time slot checks return `true` immediately
   - ActualMiningTimes excluded from hash comparison
   - No explicit validation of ActualMiningTime against Context.CurrentBlockTime

**Feasibility**: HIGH
- Entry point is public consensus method (`UpdateValue`) accessible to any miner in the miner list [7](#0-6) 

- No economic cost beyond being in the initial miner set
- Block time constraints (4 seconds future limit) don't prevent setting transaction ActualMiningTime arbitrarily earlier [8](#0-7) 

- Attack surface exists at every term start when Round 1 begins

**Detection**: DIFFICULT - Manipulation only visible by comparing block header ActualMiningTime with state-committed value, which isn't routinely monitored.

### Recommendation

**1. Add ActualMiningTime Validation in ProcessUpdateValue/ProcessTinyBlock**:
```
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
       "ActualMiningTime must match block time");
```

**2. Include ActualMiningTimes in Round Hash Calculation** (alternative or complementary):
Remove or conditionally preserve ActualMiningTimes in `GetCheckableRound()` for validation purposes, ensuring header and state values must match.

**3. Add Round 1 Time Slot Validation**:
Don't skip time slot validation completely in Round 1. Instead, validate ActualMiningTime is within reasonable bounds of expected mining progression.

**4. Add Test Cases**:
- Test that UpdateValue with ActualMiningTime != Context.CurrentBlockTime fails
- Test Round 1 with manipulated ActualMiningTime is rejected
- Test IsTimeSlotPassed calculation correctness across Round 1 transition

### Proof of Concept

**Initial State**:
- Round 1, Term 1 just started
- Attacker is first miner (Order 1)
- Mining interval = 4000ms
- Miners 1-7 with expected orders

**Attack Sequence**:

1. **Attacker produces first block at actual time T = 1000 seconds**:
   - Block header: `Context.CurrentBlockTime = 1000s` (in consensus extra data)
   - Transaction: `UpdateValueInput.ActualMiningTime = 700s` (300 seconds earlier)
   
2. **Validation passes**:
   - `TimeSlotValidationProvider.CheckMinerTimeSlot()` returns `true` immediately (Round 1)
   - `ValidateConsensusAfterExecution()` hash comparison doesn't include ActualMiningTimes
   
3. **State committed with ActualMiningTime = 700s**

4. **Miner 3 checks at time T = 1004s**:
   ```
   actualStartTime = 700s
   currentBlockTime = 1004s
   runningTime = 1004 - 700 = 304s
   expectedOrder = 304 / 4 + 1 = 77
   Miner 3 (Order 3) < 77 â†’ IsTimeSlotPassed returns TRUE
   ```
   
5. **Expected**: Miner 3 should wait until ~1008s (Order 3 * 4s interval)
   **Actual**: Miner 3 can produce block immediately at 1004s

**Success Condition**: Miners with orders 1-76 all believe their time slots have passed when only orders 1-2 should be active, breaking the consensus schedule.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L88-98)
```csharp
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L117-137)
```csharp
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```
