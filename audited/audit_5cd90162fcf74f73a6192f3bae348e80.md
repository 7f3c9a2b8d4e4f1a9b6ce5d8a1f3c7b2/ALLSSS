### Title
Unvalidated Parent Chain Creation Height Allows Invalid State Initialization Causing Cross-Chain DoS

### Summary
The `Initialize()` function does not validate that `CreationHeightOnParentChain` is at least equal to the genesis block height before subtracting 1 to set `CurrentParentChainHeight`. This allows the contract to be initialized with a parent chain height of 0 (when `CreationHeightOnParentChain = 1`) or negative values, violating the invariant that block heights must be >= genesis height (1). This invalid state causes `GetAllChainsIdAndHeight()` to revert, creating a denial-of-service condition for cross-chain functionality.

### Finding Description

The vulnerability exists in the `Initialize()` method which sets the parent chain height without validation: [1](#0-0) 

At line 18, the code performs `State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1` with no validation that the result will be valid. The genesis block height is defined as 1: [2](#0-1) 

When `CreationHeightOnParentChain = 1` (side chain created at parent's genesis), `CurrentParentChainHeight` becomes 0. The `GetParentChainHeight()` function returns this value without validation: [3](#0-2) 

This invalid state (height < genesis height) causes `GetAllChainsIdAndHeight()` to fail with an assertion error: [4](#0-3) 

At line 125, the assertion `Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height")` will revert when `parentChainHeight = 0`.

### Impact Explanation

**Operational DoS Impact**: When the contract is initialized with `CreationHeightOnParentChain = 1`, all calls to `GetAllChainsIdAndHeight()` will permanently revert. This function is critical for cross-chain operations as it provides height information for all connected chains. The DoS affects:

1. Any external services or contracts that rely on `GetAllChainsIdAndHeight()` to coordinate cross-chain indexing
2. Block producers and validators attempting to determine which chains need indexing
3. Cross-chain monitoring and synchronization infrastructure

**Permanence**: This is a permanent condition set during initialization that cannot be fixed without redeploying the contract. Once initialized with an invalid height, the contract state is corrupted.

**Who is affected**: All participants in the cross-chain ecosystem including side chains, parent chains, validators, and users attempting cross-chain operations.

### Likelihood Explanation

**Reachable Entry Point**: The `Initialize()` function is a public method called during contract deployment. While typically called by trusted deployment scripts, the contract code itself does not enforce validation.

**Preconditions**: 
- Contract must be uninitialized (first-time initialization)
- `CreationHeightOnParentChain` parameter must be set to 1 (or 0 for negative height)
- No external validation enforces the constraint

**Execution Practicality**: This could occur through:
1. Misconfiguration in deployment scripts
2. Deliberate malicious initialization if the deployer is compromised
3. Edge case testing that accidentally uses genesis height

**Probability Assessment**: While production deployments would typically use `CreationHeightOnParentChain > 1`, the lack of contract-level validation means any deployment error or malicious action could trigger this. Given the critical nature of initialization and permanent impact, this warrants Medium severity despite lower probability.

### Recommendation

Add validation in the `Initialize()` function immediately after line 16:

```csharp
Assert(input.CreationHeightOnParentChain >= AElfConstants.GenesisBlockHeight, 
       "Creation height on parent chain must be at least genesis block height.");
```

Additional recommendations:
1. Add a similar check in `GetParentChainHeight()` to prevent returning invalid heights even if state is corrupted
2. Add unit tests verifying that initialization with `CreationHeightOnParentChain < 1` is rejected
3. Document the valid range for `CreationHeightOnParentChain` in the proto file comments [5](#0-4) 

### Proof of Concept

**Initial State**: 
- CrossChain contract is uninitialized
- Side chain is being created on parent chain at genesis block (height 1)

**Transaction Steps**:

1. Call `Initialize()` with:
   - `ParentChainId = 123` (any valid parent chain ID)
   - `CreationHeightOnParentChain = 1` (genesis height)
   - `IsPrivilegePreserved = false`

2. Observe contract state:
   - `State.CurrentParentChainHeight.Value = 1 - 1 = 0`
   - Contract is marked as initialized

3. Call `GetParentChainHeight()`:
   - Returns `Int64Value { Value = 0 }`
   - Success (no validation)

4. Call `GetAllChainsIdAndHeight()`:
   - Executes line 124: `var parentChainHeight = GetParentChainHeight(new Empty()).Value` → returns 0
   - Executes line 125: `Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height")`
   - Assertion fails: `Assert(0 > 1, ...)` → **REVERTS**

**Expected vs Actual Result**:
- **Expected**: `Initialize()` should reject `CreationHeightOnParentChain = 1` as invalid
- **Actual**: `Initialize()` succeeds, contract enters invalid state, `GetAllChainsIdAndHeight()` permanently reverts

**Success Condition**: The vulnerability is confirmed if initialization with `CreationHeightOnParentChain = 1` succeeds and subsequent `GetAllChainsIdAndHeight()` calls revert with "Invalid parent chain height" error.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L14-31)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.ParentChainId.Value = input.ParentChainId;
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
        State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();

        CreateInitialOrganizationForInitialControllerAddress();
        State.Initialized.Value = true;

        if (Context.CurrentHeight != AElfConstants.GenesisBlockHeight)
            return new Empty();

        State.GenesisContract.Value = Context.GetZeroSmartContractAddress();
        State.GenesisContract.SetContractProposerRequiredState.Send(
            new BoolValue { Value = input.IsPrivilegePreserved });
        return new Empty();
    }
```

**File:** src/AElf.Types/AElfConstants.cs (L1-10)
```csharp
namespace AElf
{

    public static class AElfConstants
    {
        public const long GenesisBlockHeight = 1;
        public const int HashByteArrayLength = 32;
        public const int AddressHashLength = 32;
    }
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L63-72)
```csharp
    public override Int64Value GetParentChainHeight(Empty input)
    {
        var parentChainId = State.ParentChainId.Value;
        Assert(parentChainId != 0, "Parent chain not exist.");
        var parentChainHeight = State.CurrentParentChainHeight.Value;
        return new Int64Value
        {
            Value = parentChainHeight
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L118-128)
```csharp
    public override ChainIdAndHeightDict GetAllChainsIdAndHeight(Empty input)
    {
        var dict = GetSideChainIdAndHeight(new Empty());

        if (State.ParentChainId.Value == 0)
            return dict;
        var parentChainHeight = GetParentChainHeight(new Empty()).Value;
        Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
        dict.IdHeightDict.Add(State.ParentChainId.Value, parentChainHeight);
        return dict;
    }
```

**File:** protobuf/cross_chain_contract.proto (L109-116)
```text
message InitializeInput {
    // The id of parent chain.
    int32 parent_chain_id = 1;
    // The height of side chain created on parent chain.
    int64 creation_height_on_parent_chain = 2;
    // True if chain privilege needed, otherwise false.
    bool is_privilege_preserved = 3;
}
```
