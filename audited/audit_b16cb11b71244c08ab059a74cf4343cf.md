### Title
Wildcard Approval Bypass Allows Unauthorized NFT Transfer Using Fungible Token Approvals

### Summary
The `DoTransferFrom` function's allowance resolution mechanism allows NFT items to be transferred using wildcard ("*") approvals that were intended for fungible tokens. When an NFT transfer is attempted, the `GetAllowance` function falls back to checking the "*" (all-symbol) approval, enabling a spender to transfer NFT items without explicit NFT-specific approval, violating NFT ownership rules.

### Finding Description

The vulnerability exists in the approval resolution chain across three key functions:

**Root Cause - Wildcard Approval Acceptance:** [1](#0-0) 

The `AssertApproveToken` function explicitly allows "*" as a valid symbol for approvals. When `symbol = "*"`, the validation passes because `symbolPrefix.Equals(allSymbolIdentifier)` returns true, and the function returns early without requiring a token to exist. [2](#0-1) 

**Vulnerable Allowance Resolution:** [3](#0-2) 

The `GetAllowance` function implements a fallback hierarchy: it first checks the specific symbol allowance, then for NFTs checks the collection-wide allowance ("NFT-*"), and finally falls back to checking the wildcard allowance ("*") at line 112. This fallback is applied to ALL token types, including NFTs.

**Exploitation Path:** [4](#0-3) 

When `DoTransferFrom` is called with an NFT symbol, it invokes `GetAllowance` at line 75, which returns the "*" allowance amount. If sufficient, the transfer proceeds and the wildcard allowance is decremented at line 94, allowing the spender to transfer NFTs using fungible token approvals.

**Symbol Type Determination:** [5](#0-4) 

The `GetSymbolType` function correctly identifies NFT items (e.g., "NFT-1") as `SymbolType.Nft`, but this classification doesn't prevent the wildcard approval fallback in `GetAllowance`.

### Impact Explanation

**Direct Fund Impact - NFT Theft:**
- An attacker who receives a wildcard ("*") approval for fungible tokens can immediately transfer ALL NFT items owned by the approver
- Each NFT (with unique value) can be stolen using just 1 unit of the wildcard allowance
- A single wildcard approval of 1,000,000 could allow theft of up to 1,000,000 distinct NFT items

**Ownership Model Violation:**
- NFTs are designed to have explicit, item-specific ownership and transfer controls
- This vulnerability completely bypasses NFT ownership rules, allowing token-level approvals to override NFT-specific authorization
- Users who approve spenders for fungible tokens unknowingly grant permission to transfer their entire NFT portfolio

**Affected Parties:**
- All NFT holders who have granted wildcard ("*") approvals for any purpose
- DeFi protocols, marketplaces, or contracts that request wildcard approvals for fungible token operations
- The entire NFT ecosystem built on AElf, as user trust in NFT ownership guarantees is compromised

**Severity Justification:**
This is CRITICAL because it enables direct theft of high-value NFT assets through a common approval pattern, fundamentally breaking the NFT ownership invariant specified in the security requirements.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires only that a victim has granted the attacker a wildcard ("*") approval for any amount
- No special privileges or contract admin rights required
- Standard user transaction - calling the public `TransferFrom` method

**Attack Complexity:**
- Extremely low - single transaction exploit
- Attacker simply calls `TransferFrom(victimAddress, attackerAddress, "NFT-1", 1, "")`
- No complex state manipulation or timing requirements needed

**Feasibility Conditions:**
- Wildcard approvals are likely common in practice, as they provide convenience for DeFi protocols and automated trading systems
- Users may approve "*" for staking contracts, DEX routers, or other integrations expecting only fungible token operations
- The approval mechanism is designed to support "*", indicating intended legitimate use cases

**Detection Constraints:**
- Attack leaves normal event logs (standard `Transferred` event)
- No obvious red flags distinguishing this from legitimate transfers
- Victim may not realize their wildcard approval enables NFT transfers

**Probability Assessment:**
HIGH - The conditions for exploitation (wildcard approval + NFT ownership) are likely to co-exist in real usage, and the attack is trivial to execute once these conditions are met.

### Recommendation

**Immediate Fix - Separate Approval Namespaces:**

Modify `GetAllowance` to prevent wildcard fallback for NFT items: [3](#0-2) 

Change the logic at line 112 to:
```csharp
if (tokenType == SymbolType.Token)
{
    allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
}
else
{
    allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
    // Remove line 112 - do NOT fall back to wildcard for NFTs
}
```

**Additional Safeguards:**

1. **Approval Validation Enhancement:** [1](#0-0) 

Add explicit documentation or validation that "*" approvals should only be used for fungible tokens, not NFTs.

2. **Test Cases:**
    - Test that wildcard approval CANNOT transfer NFT items
    - Test that NFT items require explicit symbol or collection-level approval
    - Test that fungible tokens CAN still use wildcard approvals
    - Test the hierarchy: specific symbol > collection wildcard > no fallback for NFTs

**Invariant Checks:**
Add assertion: `Assert(tokenType == SymbolType.Token || allowanceSymbol != "*", "NFT transfers require explicit approval")`

### Proof of Concept

**Initial State:**
- Alice owns NFT "NFT-1" (worth $10,000)
- Alice owns 1,000 ELF tokens
- Alice approves Bob for symbol="*" with amount=1,000,000 (intending this for ELF token staking)

**Attack Sequence:**

1. Bob calls `TransferFrom`:
   - `from = Alice`
   - `to = Bob` 
   - `symbol = "NFT-1"`
   - `amount = 1`
   - `memo = ""`

2. Execution in `DoTransferFrom`:
   - `GetAllowance(Alice, Bob, "NFT-1", 1, out allowanceSymbol)` called
   - Checks `State.Allowances[Alice][Bob]["NFT-1"]` = 0 (insufficient)
   - `GetSymbolType("NFT-1")` returns `SymbolType.Nft`
   - Checks `State.Allowances[Alice][Bob]["NFT-*"]` = 0 (insufficient)
   - Falls back to `State.Allowances[Alice][Bob]["*"]` = 1,000,000 (sufficient!)
   - Returns allowance = 1,000,000, allowanceSymbol = "*"

3. Transfer proceeds:
   - `DoTransfer(Alice, Bob, "NFT-1", 1, "")` executes
   - NFT-1 ownership transfers to Bob
   - `State.Allowances[Alice][Bob]["*"]` = 999,999

**Expected Result:**
Transaction should FAIL with "Insufficient allowance" because no explicit NFT approval exists.

**Actual Result:**
Transaction SUCCEEDS. Bob now owns NFT-1 (worth $10,000), and can repeat this for 999,999 more NFT items using the same approval.

**Success Condition:**
Bob successfully transfers Alice's NFT using only a wildcard approval that Alice intended for fungible token operations, demonstrating complete bypass of NFT ownership controls.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L54-74)
```csharp
    private void AssertApproveToken(string symbol)
    {
        Assert(!string.IsNullOrEmpty(symbol), "Symbol can not be null.");
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        var symbolPrefix = words[0];
        var allSymbolIdentifier = GetAllSymbolIdentifier();
        Assert(symbolPrefix.Length > 0 && (IsValidCreateSymbol(symbolPrefix) || symbolPrefix.Equals(allSymbolIdentifier)), "Invalid symbol.");
        if (words.Length == 1)
        {
            if (!symbolPrefix.Equals(allSymbolIdentifier))
            {
                ValidTokenExists(symbolPrefix);
            }
            return;
        }
        Assert(words.Length == 2, "Invalid symbol length.");
        var itemId = words[1];
        Assert(itemId.Length > 0 && (IsValidItemId(itemId) || itemId.Equals(allSymbolIdentifier)), "Invalid NFT Symbol.");
        var nftSymbol = itemId.Equals(allSymbolIdentifier) ? GetCollectionSymbol(symbolPrefix) : symbol;
        ValidTokenExists(nftSymbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L28-28)
```csharp
    public const char AllSymbolIdentifier = '*';
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L97-116)
```csharp
    private long GetAllowance(Address from, Address spender, string sourceSymbol, long amount,
        out string allowanceSymbol)
    {
        allowanceSymbol = sourceSymbol;
        var allowance = State.Allowances[from][spender][sourceSymbol];
        if (allowance >= amount) return allowance;
        var tokenType = GetSymbolType(sourceSymbol);
        if (tokenType == SymbolType.Token)
        {
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }
        else
        {
            allowance = GetNftCollectionAllSymbolAllowance(from, spender, sourceSymbol, out allowanceSymbol);
            if (allowance >= amount) return allowance;
            allowance = GetAllSymbolAllowance(from, spender, out allowanceSymbol);
        }

        return allowance;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```
