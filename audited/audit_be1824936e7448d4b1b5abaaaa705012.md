### Title
Permanent Loss of Profits Beyond 10th Detail Due to Hardcoded Claiming Limit

### Summary
The Profit contract limits profit claiming to the first 10 profit details per transaction through a hardcoded constant. Users with more than 10 active profit details—which commonly occurs through multiple votes in the Election contract—will permanently lose access to profits allocated to details beyond the 10th position, as those details never get processed when the first 10 remain continuously profitable.

### Finding Description

The vulnerability exists in the profit claiming mechanism across two critical functions:

**In `ClaimProfits`:** [1](#0-0) 

The function limits processing to only the first 10 profit details using a hardcoded constant: [2](#0-1) 

**In `GetAllProfitsMap`:** [3](#0-2) 

The same limit applies when calculating claimable profits.

**Root Cause:**

The loop that processes profit details only iterates up to `profitableDetailCount` (max 10): [4](#0-3) 

Details beyond index 10 are never processed in this loop, meaning their `LastProfitPeriod` is never updated. This becomes permanent when:

1. Users can accumulate >10 profit details through multiple actions. In the Election contract, each vote creates a separate profit detail: [5](#0-4) 

2. Profit details commonly have `EndPeriod = long.MaxValue` (essentially never expire): [6](#0-5) 

3. Details are only removed when `LastProfitPeriod > EndPeriod`: [7](#0-6) 

4. If the scheme continues distributing new periods, the first 10 details remain profitable indefinitely (their `LastProfitPeriod` advances but never exceeds `long.MaxValue`), blocking access to details 11+.

**Why Protections Fail:**

The view function correctly calculates ALL entitled profits (iterates through all details at line 125-131), but restricts claimable profits to only the first 10: [8](#0-7) 

This creates a discrepancy where users can SEE their full entitled profits but cannot CLAIM them all.

### Impact Explanation

**Direct Fund Loss:**
- Users with >10 profit details permanently lose access to profits from details beyond the 10th position
- If a user has 20 equal-weighted profit details, they lose approximately 50% of their entitled profits
- The view function shows the full amount (creating false expectations), but actual claiming is permanently limited

**Affected Users:**
- Election voters who vote multiple times (common for maximizing rewards or changing votes)
- Any beneficiary added to a profit scheme >10 times with different periods
- The issue scales with user engagement—more active participants suffer greater losses

**Severity Justification:**
- HIGH severity: Direct, permanent, and unrecoverable loss of entitled funds
- Affects normal user behavior (voting multiple times is expected and encouraged)
- No warning or error message—users silently lose funds
- Contract behaves as if functioning correctly (no transaction failures)

### Likelihood Explanation

**Attacker Capabilities:**
No special privileges required—this affects normal users through standard contract usage.

**Attack Complexity:**
Trivial—users naturally trigger this by:
1. Voting >10 times in the Election contract (each vote creates a profit detail)
2. Calling `ClaimProfits` when entitled to profits
3. No special sequence or timing required

**Feasibility Conditions:**
- Election contract encourages multiple votes (vote for different candidates, change votes, re-vote after withdrawal)
- Profit schemes (like CitizenWelfare) continuously distribute new periods
- Profit details with `EndPeriod = long.MaxValue` are the default configuration

**Detection/Operational Constraints:**
- Not easily detectable by users—view functions show full profits, giving false confidence
- No error or warning when profits are inaccessible
- Users may not realize they're losing funds until they check their unclaimed profit details count

**Probability:**
HIGH—This will affect any user who votes more than 10 times in the Election system, which is a common occurrence for engaged participants over time.

### Recommendation

**Immediate Mitigation:**

1. **Implement iterative claiming mechanism:**
   - Modify `ClaimProfits` to track which details have been processed across multiple transactions
   - Add a parameter to specify starting index for processing profit details
   - Allow users to call `ClaimProfits` multiple times until all details are processed

2. **Increase or make configurable the limit:**
   - Consider increasing `ProfitReceivingLimitForEachTime` to a more reasonable value (e.g., 50-100)
   - Make this a configurable scheme parameter rather than a global constant
   - Different schemes may have different needs based on expected detail counts

3. **Add explicit ordering/prioritization:**
   - Process profit details in order of oldest `LastProfitPeriod` first
   - Ensure details that haven't been claimed get priority over recently-processed ones
   - Implement logic to rotate through details fairly across multiple claim calls

**Invariant Checks:**

1. Add assertion: `claimedDetails + remainingDetails == totalProfitableDetails`
2. Emit event showing how many details were processed vs. remaining
3. Add view function to query unprocessed profit detail count for a beneficiary

**Test Cases:**

1. Test claiming with exactly 10 profit details (boundary)
2. Test claiming with >10 profit details across multiple transactions
3. Test that all details eventually get processed through repeated claims
4. Test with scheme that continuously distributes new periods while claiming
5. Verify no details are permanently inaccessible under any scenario

### Proof of Concept

**Initial State:**
- CitizenWelfare profit scheme exists (from Election contract initialization)
- Scheme distributes profits every period
- User has voted 15 times, creating 15 profit details, all with `EndPeriod = long.MaxValue`
- All 15 details have `StartPeriod = 1`, `LastProfitPeriod = 0`, `Shares = 100` each
- Scheme has distributed 20 periods, `CurrentPeriod = 21`

**Transaction Sequence:**

**Step 1:** User calls `GetAllProfitsMap`
- Expected: Shows total profits from all 15 details (e.g., 15,000 tokens)
- Shows claimable profits from only first 10 details (e.g., 10,000 tokens)

**Step 2:** User calls `ClaimProfits`
- Processes profit details 0-9 only
- Each detail claims periods 1-10 (limited by `maxProfitReceivingPeriodCount`)
- Details 0-9: `LastProfitPeriod` updated to 11
- Details 10-14: `LastProfitPeriod` remains 0 (NOT updated)
- User receives ~10,000 tokens

**Step 3:** Scheme distributes period 21
- `CurrentPeriod = 22`
- Details 0-9: still profitable (LastProfitPeriod=11 < CurrentPeriod=22)
- Details 10-14: still profitable (LastProfitPeriod=0 < CurrentPeriod=22)

**Step 4:** User calls `ClaimProfits` again
- `profitableDetails.Count = 15` (all still profitable)
- `profitableDetailCount = min(10, 15) = 10`
- Processes details 0-9 AGAIN (same details as before!)
- Details 0-9: claim periods 11-20, `LastProfitPeriod` updated to 21
- Details 10-14: STILL NOT processed, `LastProfitPeriod` remains 0
- User receives ~10,000 tokens from details 0-9

**Step 5-N:** Pattern repeats indefinitely
- As long as scheme distributes new periods, details 0-9 remain profitable
- Details 10-14 NEVER get processed
- User permanently loses ~5,000 tokens entitled to details 10-14

**Success Condition:**
User with 15 profit details can only claim from 10, permanently losing approximately 33% of entitled profits despite the view function showing the full amount.

### Notes

The vulnerability also affects the view function `GetAllProfitsMap` which creates user confusion by showing the full profit amount (`AllProfitsMap`) but limiting the claimable amount (`OneTimeClaimableProfitsMap`). Users may believe they can eventually claim the full amount shown, but in practice, profits from details beyond the 10th position remain permanently inaccessible when earlier details continuously have unclaimed periods.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L161-163)
```csharp
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-773)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L777-785)
```csharp
        for (var i = 0; i < profitableDetailCount; i++)
        {
            var profitDetail = profitableDetails[i];
            if (profitDetail.LastProfitPeriod == 0)
                // This detail never performed profit before.
                profitDetail.LastProfitPeriod = profitDetail.StartPeriod;

            ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-120)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L132-134)
```csharp
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```
