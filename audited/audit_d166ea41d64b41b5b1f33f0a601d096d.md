# Audit Report

## Title
Domain Constraint Violation in GetAmountToPayFromReturn Causes DoS for Large Buy Orders

## Summary
The TokenConverter contract's `GetAmountToPayFromReturn` function violates the mathematical domain constraint of the `Ln` function when users attempt to buy more than approximately 50% of a connector balance. This causes transactions to revert with the cryptic error "must be 0 < a < 2", preventing legitimate large purchases and resulting in wasted gas fees.

## Finding Description

The `GetAmountToPayFromReturn` function in BancorHelper calculates the amount to pay using the Bancor formula. [1](#0-0)  It computes `x = bt / (bt - a)` where `bt` is `toConnectorBalance` and `a` is `amountToReceive`. [2](#0-1) 

This value `x` is then passed to the `Ln` function through the expression `Exp(y * Ln(x))`. [3](#0-2) 

The `Ln` function uses a Taylor series approximation that enforces a strict domain constraint. [4](#0-3)  The function requires its input to be strictly within the range (0, 2), throwing an `InvalidValueException` with the message "must be 0 < a < 2" when this constraint is violated.

**Mathematical Analysis:**
- For `Ln(x)` to succeed: `0 < x < 2`
- Given `x = bt / (bt - a)` where `bt > a > 0`
- For `x < 2`: `bt / (bt - a) < 2` → `bt < 2(bt - a)` → `2a < bt` → `a < bt/2`
- **Therefore: when `amountToReceive >= toConnectorBalance / 2`, then `x >= 2`, violating the domain constraint**

The `Buy` method calls `GetAmountToPayFromReturn` without any validation on the maximum `amountToReceive` relative to the connector balance. [5](#0-4) 

The only input validation in `GetAmountToPayFromReturn` checks that balances and amounts are positive. [6](#0-5)  There is no validation to ensure `amountToReceive < toConnectorBalance / 2`, which is necessary to satisfy the Ln function's domain constraint.

## Impact Explanation

**Operational DoS:**
- Users cannot purchase more than ~50% of a token pool's balance in a single transaction
- All such attempts fail with the error "must be 0 < a < 2" - a cryptic message that doesn't explain the business constraint
- Users lose gas fees on these failed transactions without understanding why

**User Experience Impact:**
- No upfront validation or clear error messaging about the 50% limit
- Users must discover this limitation through trial and error with failed transactions
- Workaround requires splitting large purchases into multiple smaller transactions, increasing total gas costs

**Economic Impact:**
- Large legitimate trades are blocked, particularly affecting:
  - Whales or institutions attempting large purchases
  - Treasury operations or protocol-owned liquidity movements
  - Any user wanting to buy substantial portions of available liquidity
- Increased friction for high-volume traders
- Potential liquidity limitations during market volatility

While this doesn't result in fund theft or state corruption, it represents a significant operational limitation affecting core token conversion functionality. The severity is medium-to-high depending on expected use cases.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is easily triggered:
- No special permissions required - any user can call the public `Buy` method
- Attack complexity is extremely simple: just call `Buy` with `amount >= toConnectorBalance / 2`
- No sequence of operations required
- Deterministically triggered when the mathematical constraint is violated

**Feasibility:**
- Always feasible when connector balance exists
- More likely during low liquidity periods
- Cannot be detected until transaction execution

**Economic Rationality:**
While buying >50% of a pool would result in extreme price slippage in Bancor's bonding curve model, the constraint is never communicated to users. Users may have legitimate reasons (emergency treasury operations, large institutional purchases, etc.) that justify attempting such trades.

## Recommendation

Add input validation in the `GetAmountToPayFromReturn` function and/or the `Buy` method to check the domain constraint before performing calculations:

```csharp
// In GetAmountToPayFromReturn, after existing validations:
if (amountToReceive >= toConnectorBalance / 2)
    throw new InvalidValueException(
        "Amount to receive must be less than 50% of connector balance. " +
        "Please split large purchases into multiple transactions.");
```

Alternatively, add validation in the `Buy` method before calling `GetAmountToPayFromReturn`:

```csharp
// In Buy method, before line 120:
var toConnectorBalance = GetSelfBalance(toConnector);
Assert(input.Amount < toConnectorBalance / 2, 
    "Cannot buy more than 50% of connector balance in a single transaction.");
```

This provides clear, actionable error messages to users and prevents wasted gas fees.

## Proof of Concept

```csharp
[Fact]
public void Buy_LargeAmount_Exceeds_Domain_Constraint()
{
    // Setup: connector with 1000 balance
    long toConnectorBalance = 1000L;
    long fromConnectorBalance = 1000L;
    
    // Attempt to buy 500 or more (>= 50% of balance)
    long amountToBuy = 500L;
    
    // This will trigger the domain constraint violation
    // x = bt/(bt-a) = 1000/(1000-500) = 1000/500 = 2
    // Since x >= 2, Ln(x) throws "must be 0 < a < 2"
    
    Should.Throw<InvalidValueException>(() => 
        BancorHelper.GetAmountToPayFromReturn(
            fromConnectorBalance, 0.5m,
            toConnectorBalance, 0.5m,
            amountToBuy))
        .Message.ShouldContain("must be 0 < a < 2");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-73)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L77-79)
```csharp
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-91)
```csharp
        var x = bt / (bt - a);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L93-93)
```csharp
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L130-132)
```csharp
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```
