# Audit Report

## Title
Banned Candidates Can Be Selected As Active Miners Through Missing Ban Validation

## Summary
The `GetPreviousTermSnapshotWithNewestPubkey()` function in the Election contract replaces banned candidates with their newest pubkey without validating if the newest pubkey is also banned. This allows banned nodes to bypass the security mechanism and become active miners during consensus round generation, directly violating the fundamental invariant that banned entities cannot participate in block production.

## Finding Description

This vulnerability exists across a multi-step flow in the Election and Consensus contracts, with **three missing validation points** that compound to create a complete security bypass.

**Root Cause - Missing Ban Check #1:**
In `GetPreviousTermSnapshotWithNewestPubkey()`, when the function processes banned candidates from the previous term's election snapshot, it retrieves their newest pubkey via `GetNewestPubkey()` but fails to validate if this replacement pubkey is itself banned. [1](#0-0) 

The validation only checks if `newestPubkey == null`, `newestPubkey == bannedCandidate`, or if it already exists in the snapshot. There is no call to `IsPubkeyBanned(newestPubkey)` despite the function `IsPubkeyBanned()` being readily available. [2](#0-1) 

**Missing Ban Check #2:**
In `GetMinerReplacementInformation()`, alternative candidates are selected from the snapshot without any ban validation. The code filters out initial miners and current miners but completely omits the ban check. [3](#0-2) 

**Contrast this with the inconsistent handling of initial miners** in the same function, where ban validation IS performed: [4](#0-3) 

**Missing Ban Check #3:**
The consensus contract receives the alternative candidates and directly adds them to the active miner list without any validation: [5](#0-4) 

**Why Existing Protections Fail:**

When a pubkey is replaced via `ReplaceCandidatePubkey()`, the old pubkey is correctly banned: [6](#0-5) 

The replacement mapping chain is established: [7](#0-6) 

If the new pubkey is subsequently marked as evil via `UpdateCandidateInformation()`, it also becomes banned: [8](#0-7) 

However, the replacement mapping persists unchanged. When `GetNewestPubkey()` is called, it returns the banned replacement without any awareness of the ban status: [9](#0-8) 

## Impact Explanation

**Critical Consensus Integrity Violation:**
This vulnerability allows banned/evil nodes to become active miners and participate in block production, which fundamentally undermines the consensus security model. 

**Concrete Harms:**
- **Banned miners produce blocks**: Evil nodes marked as banned can continue mining and earning rewards
- **Security model breach**: The entire ban mechanism is rendered ineffective for replaced pubkeys
- **Continued malicious behavior**: Nodes identified as evil can continue participating in consensus, potentially enabling censorship attacks, block withholding, or manipulation of round information
- **Economic impact**: Banned entities receive mining rewards they should not be entitled to
- **Trust violation**: The protocol's guarantee that banned entities are excluded from consensus is broken

**Severity: HIGH** - This is a direct bypass of a critical security control mechanism. The ban system exists specifically to protect consensus integrity by removing malicious actors, and this vulnerability completely undermines that protection for a significant attack vector (pubkey replacement followed by evil marking).

## Likelihood Explanation

**Attack Requirements:**
1. Candidate announces election (public operation, no special privilege)
2. Candidate replaces pubkey A → B via admin permission (legitimate for all candidates)
3. Pubkey B is marked as evil through `UpdateCandidateInformation()` or `RemoveEvilNode()` (happens through normal consensus monitoring)
4. Pubkey A was in previous term's election snapshot with votes
5. Evil miner replacement occurs during consensus round generation

**Complexity: LOW-MEDIUM**
- All operations are standard, legitimate contract calls
- No privilege escalation required beyond normal candidate operations
- No timing constraints or race conditions
- Execution happens automatically during consensus flow

**Feasibility: HIGH**
- The scenario can occur naturally when a candidate legitimately replaces their pubkey (e.g., key rotation), and the new pubkey is later identified as evil
- It can also be deliberately orchestrated by an attacker who controls both pubkeys
- Detection is difficult as it appears as normal miner replacement

**Probability: MEDIUM-HIGH** - While requiring a specific sequence of events, all steps are routine operations that can occur naturally or be deliberately triggered. The automatic nature of consensus round generation means no additional attacker action is needed once the setup is complete.

## Recommendation

Add ban validation checks at all three identified locations:

**Fix #1 - In `GetPreviousTermSnapshotWithNewestPubkey()`:**
Add ban check before adding the newest pubkey to the snapshot:
```csharp
foreach (var bannedCandidate in bannedCandidates)
{
    var newestPubkey = GetNewestPubkey(bannedCandidate);
    // Add ban check for the newest pubkey
    if (newestPubkey == null || newestPubkey == bannedCandidate ||
        snapshot.ElectionResult.ContainsKey(newestPubkey) ||
        IsPubkeyBanned(newestPubkey)) continue;  // <-- ADD THIS CHECK
    var electionResult = snapshot.ElectionResult[bannedCandidate];
    snapshot.ElectionResult.Add(newestPubkey, electionResult);
    if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
}
```

**Fix #2 - In `GetMinerReplacementInformation()`:**
Add ban filter when selecting alternative candidates:
```csharp
var maybeNextCandidates = latestSnapshot.ElectionResult
    // Except initial miners.
    .Where(cs =>
        !State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
    // Except current miners.
    .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
    // Except banned candidates.
    .Where(cs => !State.BannedPubkeyMap[cs.Key])  // <-- ADD THIS CHECK
    .OrderByDescending(s => s.Value).ToList();
```

**Fix #3 - In consensus `GenerateNextRoundInformation()` (defense in depth):**
Add validation before adding alternative candidates to active miners:
```csharp
for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
{
    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
    
    // Validate alternative candidate is not banned (defense in depth)
    if (State.ElectionContract.IsPubkeyBanned.Call(new StringValue { Value = alternativeCandidatePubkey }).Value)
        continue;  // <-- ADD THIS CHECK
    
    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
    // ... rest of replacement logic
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following test scenario:

```csharp
// Test: Banned Replacement Pubkey Becomes Active Miner
public async Task BannedReplacementPubkeyBecomesActiveMiner()
{
    // 1. Setup: Candidate announces with pubkey A
    var candidatePubkeyA = "pubkey_a_hex";
    await ElectionContract.AnnounceElection(...);
    
    // 2. Candidate replaces A → B (A becomes banned)
    var candidatePubkeyB = "pubkey_b_hex";
    await ElectionContract.ReplaceCandidatePubkey(new ReplaceCandidatePubkeyInput {
        OldPubkey = candidatePubkeyA,
        NewPubkey = candidatePubkeyB
    });
    
    // Verify A is banned
    var aIsBanned = await ElectionContract.IsPubkeyBanned(candidatePubkeyA);
    Assert.True(aIsBanned);
    
    // 3. B is marked as evil (B becomes banned)
    await ConsensusContract.UpdateCandidateInformation(new UpdateCandidateInformationInput {
        Pubkey = candidatePubkeyB,
        IsEvilNode = true
    });
    
    // Verify B is banned
    var bIsBanned = await ElectionContract.IsPubkeyBanned(candidatePubkeyB);
    Assert.True(bIsBanned);
    
    // 4. Take snapshot with A in election results (A had votes in previous term)
    await ElectionContract.TakeSnapshot(...);
    
    // 5. Trigger evil miner replacement during consensus round generation
    var replacementInfo = await ElectionContract.GetMinerReplacementInformation(...);
    
    // VULNERABILITY: B (banned) appears in alternative candidates
    Assert.Contains(candidatePubkeyB, replacementInfo.AlternativeCandidatePubkeys);
    
    // 6. Consensus contract adds B to active miners
    await ConsensusContract.NextRound(...);
    var currentMiners = await ConsensusContract.GetCurrentMinerList();
    
    // VULNERABILITY CONFIRMED: Banned pubkey B is now an active miner
    Assert.Contains(candidatePubkeyB, currentMiners.Pubkeys);
}
```

The test demonstrates that a banned replacement pubkey successfully becomes an active miner, violating the fundamental security invariant.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L149-158)
```csharp
        foreach (var bannedCandidate in bannedCandidates)
        {
            var newestPubkey = GetNewestPubkey(bannedCandidate);
            // If newest pubkey not exists or same as old pubkey (which is banned), skip.
            if (newestPubkey == null || newestPubkey == bannedCandidate ||
                snapshot.ElectionResult.ContainsKey(newestPubkey)) continue;
            var electionResult = snapshot.ElectionResult[bannedCandidate];
            snapshot.ElectionResult.Add(newestPubkey, electionResult);
            if (snapshot.ElectionResult.ContainsKey(bannedCandidate)) snapshot.ElectionResult.Remove(bannedCandidate);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-377)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L387-391)
```csharp
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L280-291)
```csharp
    private void PerformReplacement(string oldPubkey, string newPubkey)
    {
        State.CandidateReplacementMap[newPubkey] = oldPubkey;

        // Initial pubkey is:
        // - miner pubkey of the first round (aka. Initial Miner), or
        // - the pubkey announced election

        var initialPubkey = State.InitialPubkeyMap[oldPubkey] ?? oldPubkey;
        State.InitialPubkeyMap[newPubkey] = initialPubkey;

        State.InitialToNewestPubkeyMap[initialPubkey] = newPubkey;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L353-357)
```csharp
    private string GetNewestPubkey(string pubkey)
    {
        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        return State.InitialToNewestPubkeyMap[initialPubkey] ?? initialPubkey;
    }
```
