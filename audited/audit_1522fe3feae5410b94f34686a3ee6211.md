# Audit Report

## Title
Continuous Blocks Validation Bypass via Negative RoundNumber in UpdateValue/TinyBlock Behaviors

## Summary
The `ContinuousBlocksValidationProvider` validation can be bypassed by an authorized miner providing a negative `RoundNumber` in consensus extra data for UpdateValue or TinyBlock behaviors. This allows the miner to produce more consecutive blocks than the maximum allowed threshold (8 blocks), defeating the anti-centralization mechanism designed to ensure fair block production distribution among miners.

## Finding Description
The AEDPoS consensus system enforces a limit on consecutive blocks a single miner can produce through `ContinuousBlocksValidationProvider`. However, this validation contains a critical bypass condition.

The `Round` protobuf message defines `RoundNumber` as `int64`, which accepts negative values without type-level constraints. [1](#0-0) 

The `ConsensusValidationContext` exposes `ProvidedRound` directly from block header extra data without validating that `RoundNumber` is positive or matches the actual current round number. [2](#0-1) 

For UpdateValue and TinyBlock behaviors, the validation pipeline includes `ContinuousBlocksValidationProvider` but does NOT include any validator that checks whether `ProvidedRound.RoundNumber` matches `BaseRound.RoundNumber` or is positive. [3](#0-2) 

The continuous blocks validation only executes when `ProvidedRound.RoundNumber > 2`. When a miner provides a negative `RoundNumber` (e.g., -1), this condition evaluates to false, causing the entire validation block to be skipped. [4](#0-3) 

The system tracks consecutive blocks through `LatestPubkeyToTinyBlocksCount.BlocksCount`, which decrements on each block. When negative, it indicates the miner exceeded the threshold and should trigger validation failure. [5](#0-4) 

**Attack Path:**
1. Authorized miner produces 8 consecutive blocks (MaximumTinyBlocksCount limit)
2. `BlocksCount` becomes negative (e.g., -1)
3. Miner crafts block header with TinyBlock/UpdateValue behavior and sets `Round.RoundNumber = -1`
4. Validation bypass: condition `-1 > 2` is false, validation skipped
5. Miner continues producing blocks beyond limit

In contrast, `RoundTerminateValidationProvider` explicitly validates `RoundNumber` increments correctly for NextRound/NextTerm behaviors, but this provider is NOT used for UpdateValue/TinyBlock. [6](#0-5) 

## Impact Explanation
**Severity: LOW**

A malicious miner who has reached the consecutive block limit can bypass the anti-centralization check by crafting block headers with negative `RoundNumber` values. This allows them to:

1. Produce blocks beyond the 8-block consecutive limit [7](#0-6) 
2. Dominate block production within their time slot
3. Reduce other miners' opportunities for block production

**Why LOW and not MEDIUM/HIGH:**
- The attacker must be a validly elected miner with mining permissions
- Time slot validation still applies (cannot mine outside assigned time)
- Mining permission validation still applies (must be in miner list)
- State integrity is maintained (actual round state uses `BaseRound` from state, not `ProvidedRound`)
- No direct fund theft, supply manipulation, or complete consensus break
- Impact is limited to consensus fairness and decentralization
- The attack is observable (negative `RoundNumber` values in block headers are anomalous)

The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods only merge specific fields (OutValue, Signature, ActualMiningTimes) and don't use the invalid `ProvidedRound.RoundNumber`, so state corruption is prevented. [8](#0-7) 

## Likelihood Explanation
**Likelihood: MODERATE**

The attack is practically exploitable:

**Attacker Capabilities Required:**
- Must be an authorized miner in the current miner list
- Must be within assigned time slot
- Must have technical capability to craft custom block headers with modified consensus extra data

**Attack Feasibility:**
- The consensus extra data generation includes `RoundNumber` in both `GetUpdateValueRound` and `GetTinyBlockRound` [9](#0-8) 
- However, miners have full control over block header content before broadcasting
- The protobuf format accepts any `int64` value without additional validation
- The extraction layer only validates sender pubkey matches signer, not `RoundNumber` validity [10](#0-9) 

**Economic Incentive:**
- Elected miners have incentive to maximize block production for increased rewards
- Cost is minimal (just modify consensus extra data)
- Benefit is increased block production share

**Detection:**
- Observable through negative `RoundNumber` in block headers
- May not trigger immediate detection if used sparingly
- Could be confused with legitimate early-round blocks (which also skip validation for RoundNumber â‰¤ 2)

## Recommendation
Add explicit validation of `ProvidedRound.RoundNumber` for UpdateValue and TinyBlock behaviors:

1. **Add RoundNumber validation provider** that checks `ProvidedRound.RoundNumber == BaseRound.RoundNumber` for all consensus behaviors
2. **Add positivity check** to ensure `RoundNumber > 0` before using it in validation logic
3. **Alternative fix:** Move the RoundNumber check outside the conditional in `ContinuousBlocksValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    // Validate RoundNumber is positive and reasonable
    if (validationContext.ProvidedRound.RoundNumber <= 0)
    {
        validationResult.Message = "Invalid RoundNumber in consensus extra data.";
        return validationResult;
    }
    
    // Validate RoundNumber matches expected value for UpdateValue/TinyBlock
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.UpdateValue ||
        validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
    {
        if (validationContext.ProvidedRound.RoundNumber != validationContext.BaseRound.RoundNumber)
        {
            validationResult.Message = "ProvidedRound RoundNumber does not match current round.";
            return validationResult;
        }
    }
    
    // Existing continuous blocks validation
    if (validationContext.ProvidedRound.RoundNumber > 2 && 
        validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
    {
        // ... rest of existing logic
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

## Proof of Concept
**Note:** This requires integration testing with a full AElf node environment to craft custom block headers.

**Conceptual PoC Steps:**
1. Set up AElf testnet with multiple miners
2. Become an elected miner
3. Produce 8 consecutive TinyBlocks to reach the limit
4. Verify `LatestPubkeyToTinyBlocksCount.BlocksCount` becomes negative
5. Craft a block header with:
   - Behavior: `TinyBlock` or `UpdateValue`
   - `Round.RoundNumber = -1`
   - Valid signature and other fields
6. Submit the block
7. Verify the block is accepted despite `BlocksCount < 0`
8. Confirm ability to produce additional consecutive blocks beyond the 8-block limit

**Expected Result:** Block validation should fail when `BlocksCount < 0`, but instead succeeds because the negative `RoundNumber` bypasses the validation check.

**Actual Result:** Block is accepted, allowing miner to exceed consecutive block production limits.

### Citations

**File:** protobuf/aedpos_contract.proto (L245-245)
```text
    int64 round_number = 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L27-27)
```csharp
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L13-24)
```csharp
        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L29-30)
```csharp
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-47)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }

    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L16-16)
```csharp
            RoundNumber = RoundNumber,
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L32-32)
```csharp
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```
