# Audit Report

## Title
Symbol Mismatch Causes Permanent Token Lock When Scheme is Recreated

## Summary
The TokenHolder contract allows scheme managers to recreate profit schemes with different token symbols, causing users' previously locked tokens to become permanently inaccessible. When the scheme symbol is changed after users have registered and locked tokens, withdrawal operations fail because the contract queries the new symbol's balance while the actual locked tokens remain under the original symbol.

## Finding Description

The vulnerability exists in the interaction between three critical functions in the TokenHolder contract:

**1. CreateScheme() - No Overwrite Protection**

The `CreateScheme()` function unconditionally overwrites the existing scheme without any validation: [1](#0-0) 

When a manager calls `CreateScheme()` multiple times, it directly overwrites `State.TokenHolderProfitSchemes[Context.Sender]` including the `Symbol` field, with no check for existing schemes or registered users.

**2. RegisterForProfits() - Locks Tokens with Current Symbol**

When users register for profits, tokens are locked using the scheme's symbol at registration time: [2](#0-1) 

The function retrieves the current scheme and locks tokens with that specific symbol. The lockId is stored to track the registration, and users cannot re-register due to the "Already registered" check at line 151.

**3. Withdraw() - Queries with New Symbol**

During withdrawal, the contract retrieves the **current** scheme and queries for locked tokens using the **current** symbol: [3](#0-2) 

The critical issue is at lines 220-225: `GetLockedAmount` is called with `scheme.Symbol`, which now reflects the new symbol from the recreated scheme, not the original symbol used during locking.

**4. GetLockedAmount() - Returns Zero for Wrong Symbol**

The MultiToken contract's `GetLockedAmount` function computes the virtual address correctly but queries the balance for the specified symbol: [4](#0-3) 

Since the virtual address contains tokens locked with the original symbol, querying for the new symbol returns zero balance.

**5. Unlock() - Fails on Zero Amount**

When attempting to unlock zero tokens, the MultiToken contract's validation fails: [5](#0-4) 

The `AssertValidToken` call at line 233 invokes `AssertValidSymbolAndAmount`: [6](#0-5) 

This assertion requires `amount > 0`, causing the transaction to fail with "Invalid amount."

**6. No Recovery Path**

- Users cannot re-register because the lockId still exists [7](#0-6) 
- The lockId is only removed on successful withdrawal [8](#0-7) 
- `RemoveBeneficiary` only removes profit distribution rights but does not unlock tokens [9](#0-8) 

## Impact Explanation

**Direct Fund Loss:**
- Users' locked tokens become permanently inaccessible, representing complete loss of funds
- All users who registered before scheme recreation are affected simultaneously  
- The tokens remain locked in virtual addresses with no mechanism to retrieve them

**Affected Parties:**
- All users who locked tokens under the original scheme symbol before it was changed
- The locked funds cannot be recovered through any contract function
- Even the scheme manager cannot help affected users recover their funds

**Severity: HIGH** because:
1. Complete and permanent loss of user funds
2. Affects all registered users of a scheme simultaneously
3. No recovery mechanism exists in the contract
4. Simple execution requiring minimal effort

## Likelihood Explanation

**Attacker Capabilities:**
- Any scheme manager can trigger this vulnerability
- Requires only calling `CreateScheme()` twice with different symbols
- No special permissions beyond being a scheme creator (standard functionality)

**Attack Complexity:**
- Trivial: Single transaction to recreate the scheme with a different symbol
- Can be intentional (malicious manager) or accidental (manager attempting to update scheme parameters)
- Immediate effect on all registered users upon scheme recreation

**Feasibility:**
- Users registering for profits is normal and expected usage
- Manager calling `CreateScheme()` again is a standard contract operation
- No special setup or preconditions required beyond normal operations

**Probability: HIGH** - The vulnerability can be triggered by any scheme manager with minimal effort, and the contract provides no safeguards against scheme recreation with different symbols.

## Recommendation

Add validation in `CreateScheme()` to prevent overwriting existing schemes that have registered users:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    var existingScheme = State.TokenHolderProfitSchemes[Context.Sender];
    Assert(existingScheme == null || existingScheme.SchemeId == null, 
        "Cannot recreate scheme with registered users. Remove all beneficiaries first.");
    
    // ... rest of the function
}
```

Alternatively, if scheme updates are intended:
1. Add an `UpdateScheme()` function that validates the symbol hasn't changed
2. Prevent symbol changes if any users are registered
3. Or add a migration mechanism that automatically updates lockIds with the new symbol

## Proof of Concept

```csharp
[Fact]
public async Task SymbolMismatchCausesPermanentLock_Test()
{
    // Step 1: Manager creates initial scheme with symbol "ELF"
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 0
    });
    
    // Step 2: User registers and locks 1000 ELF tokens
    var lockAmount = 1000L;
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        Amount = lockAmount,
        SchemeManager = Starter
    });
    
    // Verify tokens are locked
    var balanceAfterLock = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;
    
    // Step 3: Manager recreates scheme with different symbol "APP"
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "APP",
        MinimumLockMinutes = 0
    });
    
    // Step 4: User attempts to withdraw - this will fail
    var withdrawResult = await TokenHolderContractStub.Withdraw.SendWithExceptionAsync(Starter);
    
    // Verify withdrawal failed with "Invalid amount" error
    withdrawResult.TransactionResult.Error.ShouldContain("Invalid amount");
    
    // Step 5: Verify user cannot re-register
    var reregisterResult = await TokenHolderContractStub.RegisterForProfits.SendWithExceptionAsync(
        new RegisterForProfitsInput
        {
            Amount = lockAmount,
            SchemeManager = Starter
        });
    reregisterResult.TransactionResult.Error.ShouldContain("Already registered");
    
    // Tokens are permanently locked - user balance unchanged
    var finalBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Symbol = "ELF",
        Owner = Starter
    })).Balance;
    finalBalance.ShouldBe(balanceAfterLock); // Still locked, no way to recover
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-97)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-166)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-236)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L238-238)
```csharp
        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L224-233)
```csharp
    public override Empty Unlock(UnlockInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.Symbol), "Invalid input symbol.");
        AssertValidInputAddress(input.Address);
        AssertSystemContractOrLockWhiteListAddress(input.Symbol);
        
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");

        AssertValidToken(input.Symbol, input.Amount);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```
