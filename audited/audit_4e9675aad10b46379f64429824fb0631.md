### Title
Missing Bancor Protocol Invariant Validation: Connector Weight Sum Constraint Not Enforced

### Summary
The TokenConverter contract does not validate that the sum of connector weights in a pair is <= 1, as required by the Bancor protocol. While individual weights are validated to be between 0 and 1, connector pairs can be configured with weights that sum to greater than 1, violating the Bancor protocol's conservation of value principle and potentially causing pricing anomalies and arbitrage opportunities.

### Finding Description

The Bancor protocol requires that for a token pair with two connectors (reserves), the sum of their connector weights must be <= 1.0 to ensure proper bonding curve economics and conservation of value.

**Missing Validation in AddPairConnector:** [1](#0-0) 

The `AddPairConnector` method creates two connectors with `ResourceWeight` and `NativeWeight`. Each weight is individually validated through `AssertValidConnectorWeight`, but there is no check that their sum is <= 1. [2](#0-1) 

The `AssertValidConnectorWeight` method only validates that individual weights are between 0 and 1 (exclusive), using `IsBetweenZeroAndOne`: [3](#0-2) 

**Missing Validation in UpdateConnector:** [4](#0-3) 

The `UpdateConnector` method allows updating a connector's weight before activation, but does not verify that the updated weight, when combined with its related connector's weight, maintains the sum <= 1 invariant.

**Evidence from Tests:** [5](#0-4) 

The test suite uses connector weights of 0.5 and 0.6 (sum = 1.1, which exceeds 1.0) without any validation failure, demonstrating that the constraint is not enforced.

**Bancor Formula Usage:** [6](#0-5) 

The Bancor formulas use weight ratios (wf/wt) in exponential calculations. While the math works with any positive weights, the Bancor protocol's economic guarantees require the sum constraint.

### Impact Explanation

**Economic Impact:**
- Violates the Bancor protocol's conservation of value principle
- Bonding curve becomes more convex than intended, affecting price discovery
- Could enable arbitrage opportunities through carefully timed trades exploiting the incorrect curve
- Breaks theoretical foundations ensuring predictable token pricing

**Affected Parties:**
- Token traders using the converter experience unexpected price behavior
- Protocol loses economic stability guarantees
- Liquidity providers may face unexpected impermanent loss

**Severity Justification:**
MEDIUM severity because while it violates critical protocol invariants and can cause economic issues, it requires connector controller (governance) privileges to exploit and is not directly exploitable by untrusted users.

### Likelihood Explanation

**Access Requirements:** [7](#0-6) 

Both `AddPairConnector` and `UpdateConnector` are protected by `AssertPerformedByConnectorController()`, which restricts access to the connector controller (Parliament by default).

**Attack Complexity:**
- Requires governance-level access (not untrusted attacker)
- Could occur through:
  1. Governance configuration error (e.g., setting both weights to 0.6, each appearing individually safe)
  2. Malicious governance action
  3. Lack of awareness of Bancor protocol requirements

**Feasibility:**
MEDIUM likelihood - while requiring privileged access, governance could realistically make this configuration error, especially since:
- Tests demonstrate values > 1 are accepted
- No runtime error or warning occurs
- Each individual weight appears valid (between 0 and 1)

**Production Usage:** [8](#0-7) 

Current production initialization uses safe values (0.005 + 0.005 = 0.01), but nothing prevents future misconfiguration.

### Recommendation

**Add Sum Validation in AddPairConnector:**
After line 106 in `TokenConverterContract.cs`, add:
```csharp
var resourceWeight = decimal.Parse(resourceConnector.Weight);
var nativeWeight = decimal.Parse(nativeTokenToResourceConnector.Weight);
Assert(resourceWeight + nativeWeight <= decimal.One, 
    "Sum of connector weights must not exceed 1 as per Bancor protocol.");
```

**Add Sum Validation in UpdateConnector:**
After line 69 in `TokenConverterContract.cs`, when updating weight, add:
```csharp
if (!string.IsNullOrEmpty(input.Weight))
{
    var weight = AssertedDecimal(input.Weight);
    Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
    
    // Check sum constraint with related connector
    if (!string.IsNullOrEmpty(targetConnector.RelatedSymbol))
    {
        var relatedConnector = State.Connectors[targetConnector.RelatedSymbol];
        if (relatedConnector != null && !string.IsNullOrEmpty(relatedConnector.Weight))
        {
            var relatedWeight = AssertedDecimal(relatedConnector.Weight);
            Assert(weight + relatedWeight <= decimal.One,
                "Sum of connector weights in pair must not exceed 1 as per Bancor protocol.");
        }
    }
    
    targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
}
```

**Add Test Cases:**
Add negative test cases that verify:
1. `AddPairConnector` rejects pairs with ResourceWeight + NativeWeight > 1
2. `UpdateConnector` rejects updates that would cause sum > 1
3. Test boundary case where sum = 1.0 (should be accepted)
4. Test case where sum = 1.000001 (should be rejected)

### Proof of Concept

**Initial State:**
- TokenConverter contract initialized
- Caller has connector controller privileges (Parliament)

**Attack Steps:**

1. **Create connector pair with invalid weight sum:**
```
Call AddPairConnector with:
    - ResourceConnectorSymbol: "TEST"
    - ResourceWeight: "0.6"
    - NativeWeight: "0.6"
    - NativeVirtualBalance: 1000000
```

**Expected Result:**
Transaction should fail with error: "Sum of connector weights must not exceed 1 as per Bancor protocol."

**Actual Result:**
Transaction succeeds. Both connectors are created with weights 0.6 each (sum = 1.2), violating Bancor protocol invariant.

**Evidence of Success:** [5](#0-4) 

The test demonstrates connectors can be configured with weights 0.5 and 0.6 (sum = 1.1) and the Bancor helper functions execute without validation errors.

**Impact Demonstration:**
The resulting bonding curve will have exponent ratios of 0.6/0.6 = 1.0 in both directions, but with a sum of 1.2 instead of the expected <= 1.0, violating Bancor's economic model assumptions and potentially enabling arbitrage through the distorted price curve.

### Notes

The Bancor protocol specification requires connector weight sums <= 1 to ensure:
- When sum = 1: "Relay token" behavior with price determined purely by reserve ratio
- When sum < 1: Built-in token value appreciation
- When sum > 1: Violates conservation of value and breaks protocol guarantees

Current production deployments use safe values (0.005 + 0.005), but the missing validation creates risk for future configurations and violates defense-in-depth principles for critical economic invariants.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L15-32)
```csharp
        _writeConnector = new Connector
        {
            Symbol = "WRITE",
            VirtualBalance = 50_0000,
            Weight = "0.5",
            IsVirtualBalanceEnabled = false,
            IsPurchaseEnabled = true
        };

        _elfConnector = new Connector
        {
            Symbol = "ELF",
            VirtualBalance = 100_0000,
            Weight = "0.6",
            IsPurchaseEnabled = true,
            IsVirtualBalanceEnabled = false
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L230-249)
```csharp
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```
