### Title
Scheme Manager Can Permanently Lock User Funds by Recreating Scheme with Increased MinimumLockMinutes

### Summary
The `CreateScheme` function allows a scheme manager to call it multiple times, overwriting the `TokenHolderProfitSchemes` state with new parameters including `MinimumLockMinutes`. This enables a malicious manager to permanently lock all user funds by recreating the scheme with an arbitrarily large lock period after users have registered.

### Finding Description

The vulnerability exists in the `CreateScheme` function which lacks validation to prevent multiple invocations by the same manager: [1](#0-0) 

The function directly overwrites the state without checking if a scheme already exists: [2](#0-1) 

When `CreateScheme` is called multiple times, the underlying Profit contract creates a NEW scheme with a different `schemeId` each time (based on an incrementing count), but the TokenHolder state is unconditionally overwritten with the new `MinimumLockMinutes` value. [3](#0-2) 

During withdrawal, the `Withdraw` function retrieves the overwritten scheme state and uses its `MinimumLockMinutes` for the time check: [4](#0-3) 

The `GetValidScheme` function retrieves the TokenHolder state (which contains the NEW MinimumLockMinutes) and calls `UpdateTokenHolderProfitScheme`: [5](#0-4) 

Critically, `UpdateTokenHolderProfitScheme` only updates `SchemeId` and `Period` from the Profit contract but does NOT restore the original `MinimumLockMinutes`: [6](#0-5) 

This creates an inconsistency where the beneficiary relationship uses the FIRST Profit scheme (via `FirstOrDefault()`), but the withdrawal time check uses the OVERWRITTEN `MinimumLockMinutes` from the TokenHolder state.

### Impact Explanation

**Direct Fund Impact**: All user funds locked under a scheme become permanently inaccessible or locked for an extremely extended period. If a manager sets `MinimumLockMinutes` to `long.MaxValue` (9,223,372,036,854,775,807 minutes â‰ˆ 17.5 billion years), funds are effectively locked forever.

**Affected Users**: All users who called `RegisterForProfits` under the malicious manager's scheme before the attack. Once the manager recreates the scheme, no registered user can withdraw regardless of how long they've waited.

**Severity Justification**: High - This is a complete denial of service attack that results in permanent loss of access to user funds. The attack affects all participants in a scheme simultaneously and cannot be reversed without a contract upgrade.

### Likelihood Explanation

**Reachable Entry Point**: Yes - `CreateScheme` is a public method callable by any address multiple times. [7](#0-6) 

**Feasible Preconditions**: The attacker must be the scheme manager (the address that initially called `CreateScheme`). No special permissions or governance actions are required.

**Execution Practicality**: The attack is trivial to execute:
1. Manager creates legitimate scheme with reasonable `MinimumLockMinutes` (e.g., 100)
2. Users register and lock tokens via `RegisterForProfits`
3. Manager calls `CreateScheme` again with `MinimumLockMinutes = 999999999` or higher
4. All users cannot withdraw

**Economic Rationality**: The attack cost is minimal (only gas fees for one transaction). The attacker gains complete control over user fund accessibility, enabling rug-pull scenarios or ransom demands.

**Detection Constraints**: The attack is not immediately detectable. Users only discover they cannot withdraw when they attempt to do so after the expected lock period has passed.

### Recommendation

**Code-level Mitigation**: Add a check in `CreateScheme` to prevent recreating schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
           "Scheme already exists for this manager.");
    
    // ... existing code
}
```

**Invariant Checks**: 
1. Ensure `TokenHolderProfitSchemes[manager]` can only be set once per manager address
2. Add validation that `MinimumLockMinutes` cannot be modified after users have registered
3. Consider making `MinimumLockMinutes` immutable by storing it alongside the lock timestamp

**Test Cases**:
1. Test that calling `CreateScheme` twice from the same address fails with "Already exists" error
2. Test that users can withdraw after the ORIGINAL `MinimumLockMinutes` period, even if CreateScheme were somehow called again
3. Test withdrawal scenarios across scheme lifecycle to ensure time checks remain consistent

### Proof of Concept

**Initial State**: Manager and User both have sufficient ELF tokens approved for TokenHolder contract.

**Attack Sequence**:

1. Manager creates scheme with minimal lock time:
   ```
   CreateScheme({ Symbol: "ELF", MinimumLockMinutes: 0 })
   ```
   State: `TokenHolderProfitSchemes[Manager] = { MinimumLockMinutes: 0 }`

2. User registers and locks 1000 tokens at time T=1000:
   ```
   RegisterForProfits({ SchemeManager: Manager, Amount: 1000 })
   ```
   State: `LockTimestamp[lockId] = 1000`

3. Manager immediately recreates scheme with maximum lock time:
   ```
   CreateScheme({ Symbol: "ELF", MinimumLockMinutes: 9223372036854775807 })
   ```
   State: `TokenHolderProfitSchemes[Manager] = { MinimumLockMinutes: 9223372036854775807 }`

4. User attempts withdrawal at time T=1001 (after original 0-minute lock):
   ```
   Withdraw(Manager)
   ```
   
**Expected Result**: Withdrawal succeeds since 1 minute > 0 minutes lock period.

**Actual Result**: Withdrawal fails with "Cannot withdraw." error because the check evaluates:
```
Assert(1000 + 9223372036854775807 < 1001, "Cannot withdraw.")
```
which is false. User's 1000 tokens are permanently locked.

**Success Condition**: The assertion at line 227 fails, preventing withdrawal indefinitely.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-228)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L278-284)
```csharp
    private TokenHolderProfitScheme GetValidScheme(Address manager, bool updateSchemePeriod = false)
    {
        var scheme = State.TokenHolderProfitSchemes[manager];
        Assert(scheme != null, "Token holder profit scheme not found.");
        UpdateTokenHolderProfitScheme(ref scheme, manager, updateSchemePeriod);
        return scheme;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L286-299)
```csharp
    private void UpdateTokenHolderProfitScheme(ref TokenHolderProfitScheme scheme, Address manager,
        bool updateSchemePeriod)
    {
        if (scheme.SchemeId != null && !updateSchemePeriod) return;
        var originSchemeId = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = manager
        }).SchemeIds.FirstOrDefault();
        Assert(originSchemeId != null, "Origin scheme not found.");
        var originScheme = State.ProfitContract.GetScheme.Call(originSchemeId);
        scheme.SchemeId = originScheme.SchemeId;
        scheme.Period = originScheme.CurrentPeriod;
        State.TokenHolderProfitSchemes[Context.Sender] = scheme;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** protobuf/token_holder_contract.proto (L19-21)
```text
    // Create a scheme for distributing bonus.
    rpc CreateScheme (CreateTokenHolderProfitSchemeInput) returns (google.protobuf.Empty) {
    }
```
