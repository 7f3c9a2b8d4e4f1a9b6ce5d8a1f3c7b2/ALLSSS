# Audit Report

## Title
RemoveSubScheme Fails to Update CachedDelayTotalShares Causing Incorrect Profit Distribution in Delayed Distribution Schemes

## Summary
The `RemoveSubScheme` function removes a sub-scheme's shares from `TotalShares` but fails to update `CachedDelayTotalShares`, creating an inconsistency with `RemoveBeneficiary` which correctly maintains this cache. In schemes with delayed distribution (`DelayDistributePeriodCount > 0`), this causes future profit distributions to use inflated share denominators, resulting in beneficiaries receiving less profit than entitled and funds becoming permanently locked in period virtual addresses.

## Finding Description

The Profit contract maintains a delayed distribution mechanism where shares are cached for future periods. The vulnerability exists in `RemoveSubScheme` which only updates the current `TotalShares` without updating the cached values: [1](#0-0) 

In contrast, `RemoveBeneficiary` correctly updates `CachedDelayTotalShares` for all affected future periods: [2](#0-1) 

**How the Bug Manifests:**

When `DistributeProfits` is called with delayed distribution enabled, it caches the current `TotalShares` for use in future periods: [3](#0-2) 

When the delayed period arrives, it retrieves and uses the cached value, which is stored in `DistributedProfitsInfo.TotalShares`: [4](#0-3) 

During profit claiming, beneficiaries' shares are calculated using this cached (now-inflated) denominator: [5](#0-4) 

The calculation formula divides by the inflated `totalShares`: [6](#0-5) 

**Why Existing Protections Fail:**

While `RemoveSubScheme` removes the sub-scheme from the `SubSchemes` list and clears its `ProfitDetails` (preventing it from claiming), it doesn't update the already-cached share values. The removed sub-scheme's shares remain in the cached denominator, causing all other beneficiaries to receive proportionally less profit.

## Impact Explanation

**HIGH Severity** due to permanent financial loss and impact on core protocol mechanics:

**Direct Financial Harm:**
- All remaining beneficiaries receive less profit than entitled, proportional to the removed sub-scheme's shares
- Example scenario: Scheme has 100 total shares (50 from sub-scheme, 50 from beneficiaries). Sub-scheme is removed before delayed distribution occurs. Distribution of 1000 tokens results in beneficiaries receiving only (50/100) Ã— 1000 = 500 tokens instead of the expected 1000 tokens.

**Permanent Fund Lock:**
The "missing" 500 tokens cannot be recovered because:
1. The removed sub-scheme's `ProfitDetails` are cleared, making it unable to claim
2. Other beneficiaries have already calculated their shares using the inflated denominator
3. Period virtual addresses have no mechanism to redistribute unclaimed profits

**Affected Systems:**
- Staking reward distributions
- Voting profit-sharing schemes  
- Protocol treasury allocations
- Any profit scheme using delayed distribution with sub-schemes

## Likelihood Explanation

**HIGH Likelihood** - This can occur during normal protocol operations:

**Reachable Entry Point:**
The vulnerability triggers through the public `RemoveSubScheme` method callable by any scheme manager: [7](#0-6) 

**Realistic Preconditions:**
1. Scheme configured with `DelayDistributePeriodCount > 0` - common pattern demonstrated in existing tests: [8](#0-7) 

2. Scheme manager removes a sub-scheme during the delay period (legitimate operation)
3. Future distributions automatically use cached shares from before removal

**No Special Privileges Required:**
- Only requires being the scheme manager (legitimate, trusted role)
- Standard contract operations with normal parameters
- Can occur without malicious intent

**Detection Difficulty:**
- Transaction succeeds without errors
- Effects only manifest in future distribution periods when comparing expected vs. actual amounts
- Requires detailed accounting across multiple periods to detect

## Recommendation

Update `RemoveSubScheme` to mirror the logic in `RemoveBeneficiary` by updating `CachedDelayTotalShares` for all affected future periods:

```csharp
public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
{
    Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");
    
    var scheme = State.SchemeInfos[input.SchemeId];
    Assert(scheme != null, "Scheme not found.");
    Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");
    
    var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
    if (shares == null) return new Empty();
    
    var subSchemeId = input.SubSchemeId;
    var subScheme = State.SchemeInfos[subSchemeId];
    Assert(subScheme != null, "Sub scheme not found.");
    
    var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
    
    // Remove profit details
    State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
    scheme.SubSchemes.Remove(shares);
    scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
    
    // **FIX**: Update cached delay total shares for all affected periods
    if (scheme.DelayDistributePeriodCount > 0)
    {
        foreach (var cachedPeriod in scheme.CachedDelayTotalShares.Keys.ToList())
        {
            scheme.CachedDelayTotalShares[cachedPeriod] = 
                scheme.CachedDelayTotalShares[cachedPeriod].Sub(shares.Shares);
        }
    }
    
    State.SchemeInfos[input.SchemeId] = scheme;
    
    return new Empty();
}
```

## Proof of Concept

```csharp
[Fact]
public async Task RemoveSubScheme_With_DelayDistribution_Should_Update_CachedShares()
{
    const int delayDistributePeriodCount = 3;
    const int subSchemeShares = 50;
    const int beneficiaryShares = 50;
    const int totalAmount = 1000;
    
    var creator = Creators[0];
    
    // Create parent scheme with delayed distribution
    await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        DelayDistributePeriodCount = delayDistributePeriodCount,
        IsReleaseAllBalanceEveryTimeByDefault = true,
        ProfitReceivingDuePeriodCount = 100
    });
    
    var schemeId = (await creator.GetManagingSchemeIds.CallAsync(
        new GetManagingSchemeIdsInput { Manager = creator.GetAddress() })).SchemeIds.First();
    
    // Create and add sub-scheme
    var subSchemeId = await CreateSchemeAsync(1);
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = schemeId,
        SubSchemeId = subSchemeId,
        SubSchemeShares = subSchemeShares
    });
    
    // Add regular beneficiary
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = Accounts[0].Address,
            Shares = beneficiaryShares
        }
    });
    
    // Distribute in period 1 - this caches TotalShares=100 for period 4
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId,
        Amount = totalAmount,
        Symbol = "ELF"
    });
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        Period = 1
    });
    
    // Remove sub-scheme before period 4
    await creator.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = schemeId,
        SubSchemeId = subSchemeId
    });
    
    var schemeAfterRemoval = await creator.GetScheme.CallAsync(schemeId);
    schemeAfterRemoval.TotalShares.ShouldBe(beneficiaryShares); // Current shares updated correctly
    
    // Distribute in periods 2-4
    for (var period = 2; period <= 4; period++)
    {
        await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeId = schemeId,
            Amount = totalAmount,
            Symbol = "ELF"
        });
        await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeId = schemeId,
            Period = period
        });
    }
    
    // Check distributed info for period 4
    var distributedInfo = await creator.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId, Period = 4 });
    
    // BUG: TotalShares is still 100 (should be 50 after sub-scheme removal)
    distributedInfo.TotalShares.ShouldBe(100); // This passes, proving the bug
    // EXPECTED: distributedInfo.TotalShares.ShouldBe(50);
    
    // Beneficiary claims and gets only 50% instead of 100%
    await Accounts[0].Stub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = Accounts[0].Address
    });
    
    var beneficiaryBalance = (await TokenContractStub.GetBalance.CallAsync(
        new GetBalanceInput
        {
            Owner = Accounts[0].Address,
            Symbol = "ELF"
        })).Balance;
    
    // BUG: Beneficiary receives (50/100) * 1000 = 500 instead of expected 1000
    beneficiaryBalance.ShouldBe(500); // This passes, proving the bug
    // EXPECTED: beneficiaryBalance.ShouldBe(1000);
    
    // The missing 500 tokens remain locked in period 4 virtual address
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-257)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/SchemeTests.cs (L164-177)
```csharp
    [Fact]
    public async Task ProfitContract_DelayDistribution_Test()
    {
        const int delayDistributePeriodCount = 3;
        const int contributeAmountEachTime = 100_000;
        var creator = Creators[0];
        var creatorAddress = Address.FromPublicKey(CreatorKeyPair[0].PublicKey);

        await creator.CreateScheme.SendAsync(new CreateSchemeInput
        {
            IsReleaseAllBalanceEveryTimeByDefault = true,
            ProfitReceivingDuePeriodCount = 100,
            DelayDistributePeriodCount = delayDistributePeriodCount,
            CanRemoveBeneficiaryDirectly = true
```
