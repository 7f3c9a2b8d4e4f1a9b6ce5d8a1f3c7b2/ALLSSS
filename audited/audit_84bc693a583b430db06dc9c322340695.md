### Title
TokenHash Collision Across NFT Protocols Due to Insufficient Symbol Format Validation in CrossChainCreate

### Summary
The NFT contract calculates tokenHash by concatenating symbol and tokenId strings before hashing, which allows different protocols to produce identical tokenHashes. The `CrossChainCreate` method accepts symbols from cross-chain without validating their length format, enabling an attacker to create a protocol with a shorter symbol that can collide with existing protocol tokenHashes. This causes NFT data overwriting, balance corruption, and ownership confusion.

### Finding Description

**Root Cause Location:**

The tokenHash calculation uses simple string concatenation before hashing: [1](#0-0) 

This creates collision potential when symbols have different lengths. For example:
- Protocol A: symbol="AR123456789", tokenId=0 → Hash("AR1234567890")
- Protocol B: symbol="AR12345678", tokenId=90 → Hash("AR1234567890")

**Symbol Generation in Create():**

The `Create` method generates symbols with a fixed format (2-char NFT type + 9-digit random number): [2](#0-1) 

The minimum number length is 9 digits: [3](#0-2) 

**Vulnerability in CrossChainCreate():**

The `CrossChainCreate` method only validates that:
1. The symbol doesn't already exist in NftProtocolMap
2. The token exists in TokenContract
3. The first 2 characters are a valid NFT type prefix [4](#0-3) 

**Critical Missing Validation:** There is no check that the symbol follows the expected length format (2-char + 9-digit minimum). The method only extracts the first 2 characters and validates the NFT type, but accepts any numeric suffix length.

**Data Storage by TokenHash:**

All NFT data is keyed by tokenHash in state mappings: [5](#0-4) [6](#0-5) 

**Collision in GetNFTInfoByTokenHash:**

When a collision occurs, `GetNFTInfoByTokenHash` returns whichever NFT was minted last, as the state mapping only stores one value per key: [7](#0-6) 

**NFT Minting Overwrites Data:**

During minting, the tokenHash is calculated and used to store NFT info: [8](#0-7) [9](#0-8) 

If a collision exists, line 439 overwrites the previous NFT's data, and line 441 corrupts the balance accounting.

### Impact Explanation

**Direct Impact:**
- **NFT Data Loss**: The first NFT's metadata, URI, minter information, and quantity are completely overwritten by the second NFT with the same tokenHash
- **Balance Corruption**: Balance mappings keyed by tokenHash become incorrect, as both NFTs share the same balance storage location
- **Ownership Confusion**: Users who own the first NFT cannot retrieve correct information via `GetNFTInfoByTokenHash`, as it returns data from the wrong protocol
- **Protocol Integrity Violation**: Different NFT protocols are supposed to be isolated, but this vulnerability breaks that invariant

**Affected Parties:**
- NFT owners who lose access to their assets
- Protocol creators whose NFTs get overwritten
- Marketplace applications that rely on `GetNFTInfoByTokenHash` for token verification
- Cross-chain applications using NFT transfers

**Severity Justification:** HIGH
- Direct asset loss and data corruption
- Breaks fundamental uniqueness invariant
- No access control prevents exploitation
- Affects core NFT functionality

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Ability to create tokens on a sidechain via MultiToken contract
2. Ability to cross-chain tokens to mainchain
3. Ability to call `CrossChainCreate` on NFT contract
4. Knowledge of existing protocol symbols to craft collision

**Attack Complexity:** MEDIUM
- Requires cross-chain interaction but no privileged access
- Symbol collision requires calculating which tokenId values will collide
- Can be automated once the pattern is understood

**Feasibility Conditions:**
- MultiToken contract allows symbols up to 30 characters for NFTs: [10](#0-9) 

- No validation prevents symbols with varying numeric suffix lengths
- Cross-chain token creation is a standard operation

**Economic Rationality:**
- Attack cost is minimal (only gas fees for cross-chain operations)
- Potential gain includes disrupting competitor NFT protocols or causing confusion to manipulate NFT marketplaces
- Can target high-value NFTs by causing ownership disputes

**Probability:** HIGH - The vulnerability is exploitable through normal contract operations without requiring any special permissions or unlikely conditions.

### Recommendation

**Immediate Fix - Add Symbol Format Validation in CrossChainCreate:**

In `NFTContract_Create.cs`, add validation after line 79 to ensure the symbol follows the expected format:

```csharp
// After line 79, add:
var nftTypeShortName = input.Symbol.Substring(0, 2);
var numericPart = input.Symbol.Substring(2);
Assert(numericPart.Length >= 9, "Invalid NFT symbol format: numeric suffix must be at least 9 digits.");
Assert(long.TryParse(numericPart, out _), "Invalid NFT symbol format: suffix must be numeric.");
```

**Alternative Fix - Use Delimiter in TokenHash Calculation:**

Modify `CalculateTokenHash` to use a delimiter that prevents collision:

```csharp
private Hash CalculateTokenHash(string symbol, long tokenId)
{
    return HashHelper.ComputeFrom($"{symbol}:{tokenId}"); // Use delimiter
}
```

**Comprehensive Fix - Both Validations:**

Implement both the symbol format validation in `CrossChainCreate` AND add a delimiter in `CalculateTokenHash` to provide defense-in-depth.

**Test Cases to Add:**
1. Test that `CrossChainCreate` rejects symbols with numeric suffixes shorter than 9 digits
2. Test that tokenHash remains unique across protocols with similar symbol patterns
3. Test collision scenarios to ensure NFT data isolation is maintained
4. Test edge cases like "AR1" + "23456789" vs "AR12" + "3456789"

### Proof of Concept

**Initial State:**
- NFT contract deployed on mainchain
- Cross-chain infrastructure operational
- NFT type "AR" (Art) registered

**Attack Steps:**

**Step 1 - Create Protocol A on Mainchain:**
```
Call: NFTContract.Create({NftType: "Art", ...})
Result: Protocol A created with symbol "AR123456789" (2 + 9 digits)
```

**Step 2 - Create Token on Sidechain:**
```
Call: TokenContract.Create({Symbol: "AR12345678", ...}) on sidechain
Result: Token "AR12345678" created (2 + 8 digits)
```

**Step 3 - Cross-Chain Token to Mainchain:**
```
Call: TokenContract.CrossChainCreateToken(...) on mainchain
Result: Token "AR12345678" registered on mainchain MultiToken contract
```

**Step 4 - Register Protocol B:**
```
Call: NFTContract.CrossChainCreate({Symbol: "AR12345678"})
Result: Protocol B registered with symbol "AR12345678"
```

**Step 5 - Mint NFT from Protocol A:**
```
Call: NFTContract.Mint({Symbol: "AR123456789", TokenId: 0, ...})
TokenHash: Hash("AR1234567890")
Result: NFT stored at State.NftInfoMap[Hash("AR1234567890")]
```

**Step 6 - Mint NFT from Protocol B:**
```
Call: NFTContract.Mint({Symbol: "AR12345678", TokenId: 90, ...})
TokenHash: Hash("AR1234567890")
Result: COLLISION! Overwrites NFT from Step 5
```

**Verification:**
```
Call: GetNFTInfoByTokenHash(Hash("AR1234567890"))
Expected: Returns NFT from Protocol A (Symbol: "AR123456789", TokenId: 0)
Actual: Returns NFT from Protocol B (Symbol: "AR12345678", TokenId: 90)
```

**Success Condition:** The NFT info returned shows Protocol B's data instead of Protocol A's, proving the collision and data overwriting occurred.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L330-333)
```csharp
    private Hash CalculateTokenHash(string symbol, long tokenId)
    {
        return HashHelper.ComputeFrom($"{symbol}{tokenId}");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L393-394)
```csharp
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L439-441)
```csharp
        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-108)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L17-17)
```csharp
    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L22-22)
```csharp
    public MappedState<Hash, Address, long> BalanceMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L20-30)
```csharp
    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L20-20)
```csharp
    public const int NFTSymbolMaxLength = 30;
```
