### Title
Miners Can Manipulate FinalOrderOfNextRound to Control Next Round Mining Position

### Summary
Miners can arbitrarily set their `SupposedOrderOfNextRound` and manipulate other miners' `FinalOrderOfNextRound` values through the `UpdateValueInput` when calling `UpdateValue`. The contract lacks validation to verify that these values are correctly calculated from the miner's signature hash, allowing malicious miners to consistently secure favorable mining positions (e.g., first position) in subsequent rounds.

### Finding Description

**Root Cause:**

The `FinalOrderOfNextRound` field determines the mining order for the next round. [1](#0-0) 

This value is set during `ProcessUpdateValue` by directly accepting miner-provided values without validation. [2](#0-1) 

Additionally, miners can modify OTHER miners' `FinalOrderOfNextRound` through `TuneOrderInformation`. [3](#0-2) 

**Expected Behavior:**

The `SupposedOrderOfNextRound` should be deterministically calculated from the miner's signature hash using: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`. [4](#0-3) 

**Missing Validation:**

The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, but does NOT validate `SupposedOrderOfNextRound` or `TuneOrderInformation`. [5](#0-4) 

During validation, `RecoverFromUpdateValue` blindly copies miner-provided order values without recalculating them. [6](#0-5) 

The `NextRoundMiningOrderValidationProvider` only checks that the COUNT of miners with set orders matches miners who produced blocks, not whether the order values themselves are correct. [7](#0-6) 

**UpdateValueInput Structure:**

The protobuf definition allows miners to provide arbitrary values for `supposed_order_of_next_round` and `tune_order_information`. [8](#0-7) 

### Impact Explanation

**Consensus Integrity Breach:**
- Miners can consistently secure the first mining position (order=1) in every round, gaining unfair advantages in transaction ordering, MEV extraction, and block rewards
- Malicious miners can push competitors to unfavorable positions, disrupting the fair rotation of mining opportunities
- The deterministic order calculation from signature hashes is completely bypassed, breaking the consensus protocol's fairness guarantees

**Direct Economic Impact:**
- First miners in a round gain priority in transaction selection and fee collection
- Ability to consistently mine first enables MEV (Maximal Extractable Value) exploitation
- Other honest miners lose their fair share of mining opportunities and rewards

**Protocol Damage:**
- Undermines the randomness and fairness of the AEDPoS consensus mechanism
- Violates the critical invariant that "miner schedule integrity" must be maintained
- Allows persistent consensus manipulation across multiple rounds

### Likelihood Explanation

**Attacker Capabilities:**
- Any active miner in the consensus set can execute this attack
- Requires only the ability to craft a custom `UpdateValueInput` instead of using the helper function `ExtractInformationToUpdateConsensus` [9](#0-8) 

**Attack Complexity:**
- Low complexity: Simply set `SupposedOrderOfNextRound = 1` in `UpdateValueInput`
- Use `TuneOrderInformation` to reassign other miners to later positions
- No cryptographic bypass or complex state manipulation needed

**Feasibility:**
- The `UpdateValue` method is a public entry point called by miners during normal block production [10](#0-9) 
- Precondition check only verifies the miner is in the miner list [11](#0-10) 
- No additional authorization or timing constraints prevent the attack

**Detection Difficulty:**
- The manipulated values appear valid in format
- No on-chain comparison with expected values exists
- Attack is sustainable across multiple rounds without detection

### Recommendation

**Primary Fix:**
Add validation in `UpdateValueValidationProvider` or `ProcessUpdateValue` to verify the miner-provided `SupposedOrderOfNextRound` matches the deterministic calculation:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation or ProcessUpdateValue
var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
var signature = minerInRound.Signature;
var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(signature.ToInt64(), minersCount) + 1;

Assert(minerInRound.SupposedOrderOfNextRound == expectedOrder, 
    "SupposedOrderOfNextRound does not match signature-derived value");
```

**Secondary Fix:**
Validate `TuneOrderInformation` by verifying it only contains legitimate conflict resolutions. The contract should recalculate which miners have conflicts and ensure `TuneOrderInformation` matches the expected adjustments from `ApplyNormalConsensusData`. [12](#0-11) 

**Additional Checks:**
- Verify all `FinalOrderOfNextRound` values are unique and within valid range [1, minersCount]
- Ensure no miner can modify another miner's order unless there's a legitimate signature-based conflict
- Add integration tests that attempt to submit manipulated order values and verify they are rejected

### Proof of Concept

**Initial State:**
- 5 miners in current round: MinerA, MinerB, MinerC, MinerD, MinerE
- All miners have valid signatures
- Based on signatures, correct orders should be: MinerA→3, MinerB→1, MinerC→4, MinerD→2, MinerE→5

**Attack Steps:**

1. **MinerA produces their block and calls UpdateValue with malicious input:**
   ```
   UpdateValueInput {
     OutValue: [valid],
     Signature: [valid],
     SupposedOrderOfNextRound: 1,  // Should be 3 based on signature!
     TuneOrderInformation: {
       "MinerB": 5,  // Push competitor to last position
       "MinerD": 4   // Push another competitor back
     },
     [other fields valid]
   }
   ```

2. **Validation phase passes because:**
   - `UpdateValueValidationProvider` only checks OutValue, Signature, PreviousInValue
   - No validator recalculates expected order from signature
   - `RecoverFromUpdateValue` blindly copies the malicious values

3. **Execution phase accepts malicious values:**
   - Line 247 sets `MinerA.FinalOrderOfNextRound = 1`
   - Line 260 sets `MinerB.FinalOrderOfNextRound = 5` and `MinerD.FinalOrderOfNextRound = 4`

4. **When NextRound is called:**
   - `GenerateNextRoundInformation` orders miners by FinalOrderOfNextRound
   - MinerA mines first in next round (should have been 3rd)
   - MinerB mines last (should have been 1st)

**Expected Result:**
MinerA should be rejected or corrected to order 3 based on signature calculation.

**Actual Result:**
MinerA successfully manipulates their position to order 1 and can repeat this attack every round.

**Success Condition:**
After the attack, querying the next round information shows MinerA with Order=1 and earliest ExpectedMiningTime, despite their signature hash indicating they should be at a different position.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L205-208)
```text
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L16-51)
```csharp
    public UpdateValueInput ExtractInformationToUpdateConsensus(string pubkey, ByteString randomNumber)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey)) return null;

        var minerInRound = RealTimeMinersInformation[pubkey];

        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);

        return new UpdateValueInput
        {
            OutValue = minerInRound.OutValue,
            Signature = minerInRound.Signature,
            PreviousInValue = minerInRound.PreviousInValue ?? Hash.Empty,
            RoundId = RoundIdForValidation,
            ProducedBlocks = minerInRound.ProducedBlocks,
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
            SupposedOrderOfNextRound = minerInRound.SupposedOrderOfNextRound,
            TuneOrderInformation = { tuneOrderInformation },
            EncryptedPieces = { minerInRound.EncryptedPieces },
            DecryptedPieces = { decryptedPreviousInValues },
            MinersPreviousInValues = { minersPreviousInValues },
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
