### Title
Profit Scheme Frontrunning Vulnerability via Predictable Token-Based Scheme ID Generation

### Summary
The Profit contract's `CreateScheme` method allows attackers to hijack scheme management by frontrunning legitimate scheme creation transactions. When a `Token` value is provided in `CreateSchemeInput`, the resulting scheme ID is deterministic and independent of the manager address, enabling an attacker to create the scheme first with themselves as manager, causing the legitimate creation to fail.

### Finding Description

The vulnerability exists in the `GenerateSchemeId` and `CreateScheme` methods of the Profit contract. [1](#0-0) 

When `createSchemeInput.Token` is not null, the scheme ID is generated using `Context.GenerateId(Context.Self, createSchemeInput.Token)`. This scheme ID is **deterministic and depends only on the Token value**, not on who calls the function or who the manager is. [2](#0-1) 

The `CreateScheme` method performs the following operations:
1. Generates a scheme ID based on the input Token (line 56)
2. Sets the manager from input or defaults to caller (line 57)
3. Checks if scheme already exists (line 59)
4. Registers the scheme under the manager's address in `ManagingSchemeIds` (lines 62-71)

The root cause is that the scheme ID collision check at line 59 only validates that a scheme with that ID doesn't exist, but it does **not** validate that the caller has any legitimate claim to use that specific Token value. An attacker can observe or predict the Token value that will be used by a legitimate contract and register it first. [3](#0-2) 

The `Token` field is explicitly designed to generate deterministic scheme IDs, as documented in the ACS10 standard: [4](#0-3) 

### Impact Explanation

**Authorization & Governance Impact:**
An attacker who successfully hijacks a profit scheme gains full manager privileges, including:
- Adding/removing beneficiaries and controlling profit distribution shares
- Distributing profits to arbitrary addresses
- Adding/removing sub-schemes to redirect funds
- Resetting the manager to maintain permanent control [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

**Operational Impact:**
When the legitimate contract attempts to create its expected scheme, the transaction fails with "Already exists", causing:
- DoS of contract initialization for contracts that depend on specific scheme IDs
- Permanent inability for the legitimate contract to use that scheme ID
- Disruption of the protocol's profit distribution mechanism

**Direct Fund Impact:**
The attacker can redirect all profits intended for legitimate beneficiaries to addresses they control, resulting in theft of accumulated dividends and rewards.

### Likelihood Explanation

**Reachable Entry Point:** 
The `CreateScheme` method is publicly accessible and can be called by any address.

**Feasible Preconditions:**
1. The attacker needs to know or predict the Token value that will be used. This is highly feasible because:
   - Many contracts use predictable patterns like `HashHelper.ComputeFrom(Context.Self)`
   - Transactions in the mempool are visible before execution
   - Contract initialization code is often public or on-chain

**Execution Practicality:**
The attack requires:
1. Monitoring the mempool or predicting Token values
2. Submitting a `CreateScheme` transaction with the same Token but attacker as manager
3. Ensuring the attacker's transaction is mined first (via higher gas fees or validator cooperation)

**Economic Rationality:**
- Attack cost: Transaction fees only
- Potential gain: Control over scheme with accumulated profits
- The cost-benefit ratio heavily favors the attacker, especially for high-value schemes

**Detection Constraints:**
The attack is difficult to detect or prevent because:
- Scheme creation is permissionless
- There's no on-chain link between Token values and intended managers
- The attack appears as a legitimate scheme creation transaction

### Recommendation

**Primary Fix: Bind Scheme ID to Manager Address**

Modify `GenerateSchemeId` to include the manager address in the scheme ID generation when Token is provided:

```csharp
private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
{
    var manager = createSchemeInput.Manager ?? Context.Sender;
    if (createSchemeInput.Token != null)
        return Context.GenerateId(Context.Self, 
            HashHelper.ConcatAndCompute(createSchemeInput.Token, manager.ToByteString()));
    var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
    return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
}
```

**Alternative Fix: Manager Authorization Check**

Add a whitelist or authorization check that validates the caller has permission to use a specific Token value:

```csharp
public override Hash CreateScheme(CreateSchemeInput input)
{
    // ... existing validation ...
    
    if (input.Token != null && input.Manager != null && input.Manager != Context.Sender)
    {
        Assert(false, "Only the intended manager can create scheme with specified Token.");
    }
    
    // ... rest of method ...
}
```

**Invariant to Enforce:**
- Scheme IDs must be unique per manager, not globally unique
- Token-based scheme creation should only be allowed if caller is the intended manager

**Test Cases:**
1. Test that two different managers cannot create schemes with the same Token value
2. Test frontrunning scenario where attacker attempts to hijack scheme creation
3. Test that existing legitimate schemes continue to function after fix

### Proof of Concept

**Initial State:**
- Legitimate contract LegitContract at address ADDR_LEGIT plans to create a scheme
- Attacker monitors transactions or predicts Token value: `TOKEN = HashHelper.ComputeFrom(ADDR_LEGIT)`
- No scheme with this Token exists yet

**Attack Sequence:**

**Step 1 - Attacker Frontruns:**
```
Attacker calls: CreateScheme({
    Token: TOKEN,
    Manager: ATTACKER_ADDRESS,
    CanRemoveBeneficiaryDirectly: true,
    IsReleaseAllBalanceEveryTimeByDefault: true
})
```
**Result:** Scheme created with ID = `GenerateId(ProfitContract, TOKEN)`, manager = ATTACKER_ADDRESS

**Step 2 - Legitimate Creation Fails:**
```
LegitContract calls: CreateScheme({
    Token: TOKEN,
    Manager: ADDR_LEGIT,
    ...
})
```
**Result:** Transaction reverts with "Already exists." at line 59

**Step 3 - Attacker Exploits Control:**
```
Attacker calls: AddBeneficiary({
    SchemeId: GenerateId(ProfitContract, TOKEN),
    BeneficiaryShare: { Beneficiary: ATTACKER_ADDRESS, Shares: 1000000 }
})
```
**Result:** Attacker adds themselves as beneficiary with maximum shares

**Success Condition:**
- Attacker successfully created scheme with predictable ID
- Legitimate contract initialization failed
- Attacker can call all manager-only functions (AddBeneficiary, DistributeProfits, etc.)
- All profits contributed to the scheme are controllable by attacker

**Notes**

The vulnerability specifically affects schemes created with the `Token` parameter specified. Most system contracts (Treasury, TokenHolder) do not specify Token values and use auto-incremented scheme IDs based on manager's scheme count, making them immune to this attack. However, the ACS10 standard documentation actively encourages using Token for deterministic scheme ID generation, which makes any contracts following this pattern vulnerable to frontrunning attacks.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L44-84)
```csharp
    public override Hash CreateScheme(CreateSchemeInput input)
    {
        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        if (input.ProfitReceivingDuePeriodCount == 0)
            input.ProfitReceivingDuePeriodCount = ProfitContractConstants.DefaultProfitReceivingDuePeriodCount;
        else
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");

        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
        Assert(State.SchemeInfos[schemeId] == null, "Already exists.");
        State.SchemeInfos[schemeId] = scheme;

        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;

        Context.LogDebug(() => $"Created scheme {State.SchemeInfos[schemeId]}");

        Context.Fire(new SchemeCreated
        {
            SchemeId = scheme.SchemeId,
            Manager = scheme.Manager,
            IsReleaseAllBalanceEveryTimeByDefault = scheme.IsReleaseAllBalanceEveryTimeByDefault,
            ProfitReceivingDuePeriodCount = scheme.ProfitReceivingDuePeriodCount,
            VirtualAddress = scheme.VirtualAddress
        });
        return schemeId;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L91-129)
```csharp
    public override Empty AddSubScheme(AddSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");
        Assert(input.SubSchemeShares > 0, "Shares of sub scheme should greater than 0.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");
        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can add sub-scheme.");
        Assert(scheme.SubSchemes.All(s => s.SchemeId != input.SubSchemeId),
            $"Sub scheme {input.SubSchemeId} already exist.");

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Add profit details and total shares of the father scheme.
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });

        // Add a sub profit scheme.
        scheme.SubSchemes.Add(new SchemeBeneficiaryShare
        {
            SchemeId = input.SubSchemeId,
            Shares = input.SubSchemeShares
        });
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L417-499)
```csharp
    public override Empty DistributeProfits(DistributeProfitsInput input)
    {
        if (input.AmountsMap.Any())
            Assert(input.AmountsMap.All(a => !string.IsNullOrEmpty(a.Key)), "Invalid token symbol.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");

        ValidateContractState(State.TokenContract, SmartContractConstants.TokenContractSystemName);

        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }

        var totalShares = scheme.TotalShares;

        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }

        var releasingPeriod = scheme.CurrentPeriod;
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");

        var profitsReceivingVirtualAddress =
            GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, releasingPeriod);

        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);

        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L723-743)
```csharp
    public override Empty ResetManager(ResetManagerInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only scheme manager can reset manager.");
        Assert(input.NewManager.Value.Any(), "Invalid new sponsor.");

        // Transfer managing scheme id.
        var oldManagerSchemeIds = State.ManagingSchemeIds[scheme.Manager];
        oldManagerSchemeIds.SchemeIds.Remove(input.SchemeId);
        State.ManagingSchemeIds[scheme.Manager] = oldManagerSchemeIds;
        var newManagerSchemeIds = State.ManagingSchemeIds[input.NewManager] ?? new CreatedSchemeIds();
        newManagerSchemeIds.SchemeIds.Add(input.SchemeId);
        State.ManagingSchemeIds[input.NewManager] = newManagerSchemeIds;

        scheme.Manager = input.NewManager;
        State.SchemeInfos[input.SchemeId] = scheme;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L964-971)
```csharp
    private Hash GenerateSchemeId(CreateSchemeInput createSchemeInput)
    {
        var manager = createSchemeInput.Manager ?? Context.Sender;
        if (createSchemeInput.Token != null)
            return Context.GenerateId(Context.Self, createSchemeInput.Token);
        var createdSchemeCount = State.ManagingSchemeIds[manager]?.SchemeIds.Count ?? 0;
        return Context.GenerateId(Context.Self, createdSchemeCount.ToBytes(false));
    }
```

**File:** protobuf/profit_contract.proto (L120-133)
```text
message CreateSchemeInput {
    // Period of profit distribution.
    int64 profit_receiving_due_period_count = 1;
    // Whether all the schemes balance will be distributed during distribution each period.
    bool is_release_all_balance_every_time_by_default = 2;
    // Delay distribute period.
    int32 delay_distribute_period_count = 3;
    // The manager of this scheme, the default is the creator.
    aelf.Address manager = 4;
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 5;
    // Use to generate scheme id.
    aelf.Hash token = 6;
}
```

**File:** docs-sphinx/reference/acs/acs10.rst (L537-549)
```text
.. code:: c#

   State.ProfitContract.Value =
       Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
   var schemeToken = HashHelper.ComputeFrom(Context.Self);
   State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
   {
       Manager = Context.Self,
       CanRemoveBeneficiaryDirectly = true,
       IsReleaseAllBalanceEveryTimeByDefault = true,
       Token = schemeToken
   });
   State.ProfitSchemeId.Value = Context.GenerateId(State.ProfitContract.Value, schemeToken);
```
