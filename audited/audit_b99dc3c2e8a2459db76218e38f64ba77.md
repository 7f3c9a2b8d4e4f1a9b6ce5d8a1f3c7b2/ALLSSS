### Title
Side Chain NextRound Can Accept BlockchainAge = 0 for RoundNumber > 1 Due to Missing Field Initialization

### Summary
On side chains, when the main chain miner list changes during round transition, the `GenerateNextRoundInformation` method creates a new Round via `GenerateFirstRoundOfNewTerm` without setting the `BlockchainAge` field, causing it to default to 0. This Round is then passed to `NextRoundInput.Create()` which accepts it without validation, violating the critical invariant that blockchain age must increment with each round.

### Finding Description

The vulnerability exists in the side chain consensus round generation flow with three key components:

**1. Unvalidated Copy in NextRoundInput.Create():** [1](#0-0) 

The `Create()` method directly copies `BlockchainAge` from the input Round without any validation that it's non-zero when `RoundNumber > 1`.

**2. Missing BlockchainAge Initialization in Side Chain Path:** [2](#0-1) 

When on a side chain and the main chain miner list changes, the code calls `GenerateFirstRoundOfNewTerm` and returns immediately without setting `BlockchainAge`. 

**3. GenerateFirstRoundOfNewTerm Doesn't Set BlockchainAge:** [3](#0-2) 

This method creates a new Round and sets `RoundNumber`, `TermNumber`, and miner information, but never sets `BlockchainAge`, leaving it at the protobuf default of 0.

**4. Protobuf Default Value:** [4](#0-3) 

The `blockchain_age` field is an int64 that defaults to 0 when not explicitly set.

**5. Normal Path Sets BlockchainAge Correctly:** [5](#0-4) 

In contrast, the normal `GenerateNextRoundInformation` path properly calculates `BlockchainAge` as the time elapsed since blockchain start.

**6. No Validation in ProcessNextRound:** [6](#0-5) 

The `ProcessNextRound` method accepts the invalid Round and stores it without validating that `BlockchainAge` is appropriate for the `RoundNumber`.

### Impact Explanation

**Consensus Integrity Violation:**
- Breaks the fundamental invariant that `BlockchainAge` must monotonically increase with each round
- Creates inconsistent state where a side chain at round N+1 has the same (or lower) blockchain age as round N
- Could cause incorrect time-based calculations in subsequent consensus operations that rely on blockchain age

**Side Chain Specific:**
- Affects all side chains that synchronize with main chain miner list changes
- Creates divergence between side chain consensus state and expected invariants

**Severity Justification:**
- Medium severity because it violates a critical consensus invariant but requires specific conditions (side chain + main chain miner list change)
- Does not directly lead to fund theft but undermines consensus correctness
- Could cause monitoring/analysis systems to report incorrect metrics
- May affect future features that depend on accurate blockchain age tracking

### Likelihood Explanation

**Entry Point:**
The vulnerability is triggered through the standard consensus flow via the `GetConsensusCommand` and `GenerateConsensusTransactions` public methods, which any current miner can call.

**Preconditions:**
1. Chain must be a side chain (not main chain)
2. Main chain miner list must change between rounds
3. A miner produces a block triggering NextRound behavior

**Feasibility:**
- Side chains are a standard feature in AElf architecture
- Main chain miner list changes occur during normal operations (elections, term changes, miner replacements)
- No attacker capabilities required beyond being a legitimate miner on the side chain
- The code path is deterministic and will trigger whenever conditions are met

**Attack Complexity:**
- Low complexity - occurs automatically during normal consensus operations
- No special manipulation required
- Not dependent on timing or race conditions

**Detection:**
- Easy to detect by monitoring Round state and checking if `BlockchainAge` decreases or stays zero
- However, may go unnoticed if not explicitly monitored since consensus continues to function

**Probability:**
Medium-High probability of occurring on active side chains that experience main chain miner list changes.

### Recommendation

**Immediate Fix:**
Set `BlockchainAge` in the side chain miner list change path: [2](#0-1) 

After line 293, add:
```csharp
nextRound.BlockchainAge = GetBlockchainAge();
```

**Additional Validation:**
Add invariant check in `ProcessNextRound`: [7](#0-6) 

After line 110, add validation:
```csharp
Assert(nextRound.RoundNumber == 1 || nextRound.BlockchainAge > 0, 
    "BlockchainAge must be greater than 0 for rounds after the first.");
```

**Test Cases:**
1. Test side chain round transition when main chain miner list changes
2. Verify `BlockchainAge` is properly set and increases monotonically
3. Test that validation rejects rounds with `BlockchainAge = 0` when `RoundNumber > 1`

### Proof of Concept

**Initial State:**
- Side chain running at Round 5 with `BlockchainAge = 300` seconds
- Main chain performs miner list update
- Side chain synchronizes the new main chain miner list

**Exploitation Steps:**

1. Side chain miner calls `GetConsensusCommand` to get NextRound consensus command
2. Flow reaches `GenerateNextRoundInformation` in `AEDPoSContract_ViewMethods.cs`
3. Condition `!IsMainChain && IsMainChainMinerListChanged(currentRound)` evaluates to true
4. Code executes lines 290-294, calling `GenerateFirstRoundOfNewTerm` 
5. New Round created with:
   - `RoundNumber = 6`
   - `TermNumber = 2` (incremented)
   - `BlockchainAge = 0` (not set, defaults to 0)
6. This Round is passed to `NextRoundInput.Create()` which accepts it
7. `NextRound` transaction is generated and executed
8. `ProcessNextRound` stores the Round with `BlockchainAge = 0`

**Expected Result:**
Round 6 should have `BlockchainAge > 300` (continuing to increase)

**Actual Result:**
Round 6 has `BlockchainAge = 0`, violating the monotonic increase invariant

**Success Condition:**
Query `State.Rounds[6].BlockchainAge` returns 0 when `State.Rounds[6].RoundNumber` is 6.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-295)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** protobuf/aedpos_contract.proto (L250-251)
```text
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L23-23)
```csharp
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```
