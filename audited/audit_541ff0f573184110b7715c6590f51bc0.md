### Title
Vote Contract Option Capacity Exhaustion Enables Election System DoS

### Summary
The Vote contract enforces a hard limit of 64 options per voting item. An attacker can fill all 64 slots by announcing election with different keypairs, causing all subsequent `AnnounceElection` calls to fail when `AddCandidateAsOption` attempts to add more options. This creates a denial-of-service condition where legitimate candidates cannot join the election, disrupting the consensus mechanism.

### Finding Description

The vulnerability exists in the interaction between the Election contract's `AnnounceElection` method and the Vote contract's `AddOption` capacity limit.

**Root Cause:** [1](#0-0) 

The Vote contract enforces a maximum of 64 options per voting item. When a candidate calls `AnnounceElection`, the Election contract invokes `AddCandidateAsOption`: [2](#0-1) 

This calls the Vote contract's `AddOption` method: [3](#0-2) 

The assertion at line 285 enforces the capacity limit. When 64 options exist, any additional `AddOption` call fails with "The count of options can't greater than 64", causing the entire `AnnounceElection` transaction to revert.

**Why Protections Fail:**

1. **QuitElection requires candidate admin permission** - only the malicious actor can voluntarily free slots: [4](#0-3) 

2. **RemoveEvilNode does NOT remove Vote options** - it only removes from internal Election state: [5](#0-4) 

3. **Governance cannot directly call Vote contract's RemoveOption** - only the sponsor (Election contract) can: [6](#0-5) 

4. **ReplaceCandidatePubkey doesn't reduce count** - it removes one and adds one option atomically: [7](#0-6) 

**Execution Path:**
The developers acknowledged this limitation in comments but provided no mitigation: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- The election system becomes permanently DoS'd - no new candidates can announce election
- Existing consensus mechanism cannot onboard new miners
- Critical governance functionality is blocked indefinitely

**Quantified Damage:**
- Attack affects all future candidates and the entire election/consensus system
- No path to recovery without attacker cooperation (calling QuitElection to free slots)
- System-wide consensus and governance disruption

**Affected Parties:**
- All legitimate candidates attempting to join the election
- The AElf network's consensus security (cannot add new miners)
- Governance stakeholders who rely on open candidate participation

**Severity Justification:**
Medium-to-High severity. While the attack requires 6.4M ELF locked, the deposit is fully refundable via `QuitElection`. The attacker can maintain the DoS indefinitely at zero net cost, and there is no administrative or governance mechanism to forcibly remove malicious options from the Vote contract.

### Likelihood Explanation

**Attacker Capabilities:**
- Must possess 64 different keypairs (trivial to generate)
- Must have 6,400,000 ELF to lock (100,000 per candidate) [9](#0-8) 

**Attack Complexity:**
- Low complexity: repeatedly call `AnnounceElection` with different transaction signers
- Each call locks 100,000 ELF which is fully refundable [10](#0-9) 

**Feasibility Conditions:**
- Attacker needs temporary access to 6.4M ELF (but keeps full custody - tokens are locked to virtual addresses)
- No special permissions required - `AnnounceElection` is a public method
- No time constraints - attack can be executed at any time

**Detection/Operational Constraints:**
- Attack is easily detectable (64 candidates from same source)
- However, there is NO mechanism to remove options without attacker cooperation
- Governance is powerless to mitigate once capacity is filled

**Probability Reasoning:**
Medium-to-High likelihood. The economic barrier (6.4M ELF) is significant but the cost is fully recoverable. An attacker motivated to disrupt consensus or governance (competitor chain, malicious actor, political motivation) could execute this attack with zero net cost beyond transaction fees.

### Recommendation

**Immediate Mitigation:**
1. Add a governance-controlled emergency mechanism in the Election contract to remove options from the Vote contract:
   - Create a new method `RemoveOptionByGovernance(string pubkey)` callable only by Parliament or Emergency Response Organization
   - This method should call `State.VoteContract.RemoveOption.Send()` to free capacity

2. Implement per-address candidate limits to prevent single actors from filling capacity:
   - Track candidates per sponsor address
   - Enforce maximum 5-10 candidates per sponsor address

3. Consider increasing the Vote contract's `MaximumOptionsCount` to a higher value (e.g., 128 or 256) to make the attack more expensive.

**Code-Level Fix Example:**
Add to `ElectionContract_Maintainence.cs`:
```csharp
public override Empty RemoveOptionByGovernance(StringValue input)
{
    Assert(Context.Sender == GetEmergencyResponseOrganizationAddress(), "No permission.");
    Assert(State.BannedPubkeyMap[input.Value], "Can only remove banned candidates.");
    
    State.VoteContract.RemoveOption.Send(new RemoveOptionInput
    {
        VotingItemId = State.MinerElectionVotingItemId.Value,
        Option = input.Value
    });
    
    return new Empty();
}
```

**Invariant Checks:**
- Assert that governance can always remove options for banned candidates
- Enforce per-sponsor candidate limits in `AnnounceElection`

**Test Cases:**
- Test filling vote capacity to exactly 64 options and verify 65th fails
- Test RemoveOptionByGovernance successfully frees capacity after banning
- Test per-sponsor limits prevent single actor from monopolizing capacity

### Proof of Concept

**Required Initial State:**
- Election contract initialized and voting event registered
- Attacker has 6,400,000 ELF balance and 64 keypairs

**Transaction Steps:**
1. Generate 64 keypairs: `keypairs[0..63]`
2. For each keypair `i` (0 to 63):
   - Sign transaction with `keypairs[i]`
   - Call `ElectionContract.AnnounceElection(admin_address)` with 100,000 ELF approved
   - Transaction succeeds, locks 100,000 ELF, adds option to Vote contract
3. Verify: Vote contract now has 64 options for `MinerElectionVotingItemId`
4. Legitimate candidate (keypair 64) attempts to announce:
   - Call `ElectionContract.AnnounceElection(admin_address)`
   - **Expected**: Transaction succeeds
   - **Actual**: Transaction fails with error "The count of options can't greater than 64"

**Success Condition:**
- All 64 malicious candidates successfully announced (Vote contract at capacity)
- 65th legitimate candidate's `AnnounceElection` transaction reverts at `AddCandidateAsOption`
- Election system is DoS'd with no governance recovery mechanism
- Attacker retains all 6.4M ELF (can recover via `QuitElection` when desired)

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L86-89)
```csharp
    /// <summary>
    ///     Actually this method is for adding an option of the Voting Item.
    ///     Thus the limitation of candidates will be limited by the capacity of voting options.
    ///     The input is candidate admin, better be an organization address of Association Contract.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L197-209)
```csharp
    private void AddCandidateAsOption(string publicKey)
    {
        if (State.VoteContract.Value == null)
            State.VoteContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        // Add this candidate as an option for the the Voting Item.
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L305-306)
```csharp
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L308-317)
```csharp
            State.VoteContract.RemoveOption.Send(new RemoveOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = oldPubkey
            });
            State.VoteContract.AddOption.Send(new AddOptionInput
            {
                VotingItemId = State.MinerElectionVotingItemId.Value,
                Option = newPubkey
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
