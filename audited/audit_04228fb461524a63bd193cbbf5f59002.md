### Title
Weak Organization Controller Bypass via Insufficient Threshold Validation in ChangeMethodFeeController

### Summary
The `ChangeMethodFeeController` function in the AEDPoS consensus contract validates only that a new controller organization exists, but does not verify it has appropriate governance thresholds. This allows Parliament to approve (through confusion or social engineering) delegation of method fee control to attacker-controlled 1-of-1 organizations, enabling unilateral control over consensus transaction fees and potential denial-of-service attacks.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method where `CheckOrganizationExist` is called to validate the new controller organization: [1](#0-0) 

The `CheckOrganizationExist` helper function only validates that the organization exists by calling `ValidateOrganizationExist` on the governance contract: [2](#0-1) 

The `ValidateOrganizationExist` implementation in the Association contract performs only an existence check without any threshold validation: [3](#0-2) 

The Association contract's validation logic allows creation of organizations with minimal thresholds (MinimalApprovalThreshold=1, 1 member), providing complete unilateral control: [4](#0-3) 

The validation only requires `MinimalApprovalThreshold > 0` with no minimum multi-signature requirements. Test cases confirm that 1-of-1 organizations can successfully be used as controllers: [5](#0-4) 

### Impact Explanation

**Direct Governance Impact**: An attacker gains unilateral control over method fee configuration for the consensus contract, bypassing the intended multi-signature governance model.

**Operational Denial of Service**: The attacker can:
- Set method fees to zero, making consensus operations free and potentially enabling spam attacks on consensus mechanisms
- Set fees to prohibitively high amounts, making consensus participation economically infeasible and disrupting block production
- Manipulate fees to favor specific miners or disrupt the economic incentive structure

**Recovery Complexity**: Once the controller is changed to an attacker-controlled organization, recovering control requires either:
- The attacker's cooperation to propose changing back to Parliament control
- Complex emergency recovery mechanisms if they exist

**Affected Parties**: All network participants including miners, validators, and users who depend on consensus stability.

**Severity Justification**: HIGH - Controls critical consensus infrastructure with direct operational impact on network availability and economic security.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Create a 1-of-1 Association organization (publicly accessible, no special permissions)
2. Submit a Parliament proposal to change the MethodFeeController (requires being in proposer whitelist, typically miners)
3. Convince Parliament to approve the change (requires social engineering or confusion)

**Attack Complexity**: MEDIUM
- Technical execution is straightforward
- The challenge is obtaining Parliament approval
- Parliament members may not inspect organization threshold details when reviewing proposals
- Proposal parameters don't explicitly show the weakness of the target organization

**Feasibility Conditions**:
- Parliament votes on proposals without automatic threshold validation warnings
- No UI/tooling alerts Parliament members to weak organization thresholds
- Confusion about organization addresses vs. threshold security is plausible

**Detection Constraints**: The change itself is legitimate governance activity, making it difficult to detect malicious intent until fees are manipulated.

**Probability Assessment**: MEDIUM - While requiring Parliament approval raises the bar, the lack of technical safeguards and potential for governance confusion makes this a realistic attack vector, especially given the HIGH impact.

### Recommendation

**Code-Level Mitigation**:

Add minimum threshold validation in the `CheckOrganizationExist` function or introduce a new validation method:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Existing existence check
    var exists = Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
    
    if (!exists) return false;
    
    // Add threshold validation for Association organizations
    if (authorityInfo.ContractAddress == State.AssociationContract.Value)
    {
        var organization = Context.Call<Organization>(authorityInfo.ContractAddress,
            "GetOrganization", authorityInfo.OwnerAddress);
        
        // Enforce minimum multi-sig requirements
        Assert(organization.OrganizationMemberList.Count() >= 3, 
            "Organization must have at least 3 members");
        Assert(organization.ProposalReleaseThreshold.MinimalApprovalThreshold >= 2,
            "Organization must require at least 2 approvals");
    }
    
    return true;
}
```

**Invariant Checks to Add**:
1. Minimum member count (e.g., >= 3 members)
2. Minimum approval threshold (e.g., >= 2 approvals)
3. Ensure MinimalApprovalThreshold is at least 33% of member count for meaningful decentralization

**Test Cases to Prevent Regression**:
1. Test that ChangeMethodFeeController rejects 1-of-1 organizations
2. Test that ChangeMethodFeeController rejects organizations with < 3 members
3. Test that ChangeMethodFeeController requires minimum approval thresholds
4. Test successful change only with properly secured organizations

### Proof of Concept

**Initial State**:
- AEDPoS MethodFeeController is set to Parliament default organization (multi-sig)
- Attacker controls account `AttackerAddress`

**Transaction Sequence**:

1. **Attacker creates 1-of-1 Association organization**:
   ```
   AssociationContract.CreateOrganization({
     ProposalReleaseThreshold: {
       MinimalApprovalThreshold: 1,
       MinimalVoteThreshold: 1,
       MaximalAbstentionThreshold: 0,
       MaximalRejectionThreshold: 0
     },
     ProposerWhiteList: { AttackerAddress },
     OrganizationMemberList: { AttackerAddress }
   })
   → Returns: WeakOrgAddress (controlled by attacker)
   ```

2. **Attacker submits Parliament proposal**:
   ```
   ParliamentContract.CreateProposal({
     ToAddress: AEDPoSContractAddress,
     ContractMethodName: "ChangeMethodFeeController",
     Params: {
       OwnerAddress: WeakOrgAddress,
       ContractAddress: AssociationContractAddress
     },
     OrganizationAddress: ParliamentDefaultOrg
   })
   → Returns: ProposalId
   ```

3. **Parliament approves proposal** (through confusion/social engineering):
   ```
   Multiple miners call: ParliamentContract.Approve(ProposalId)
   ```

4. **Attacker releases approved proposal**:
   ```
   ParliamentContract.Release(ProposalId)
   → Executes: AEDPoSContract.ChangeMethodFeeController(WeakOrgAddress, AssociationContractAddress)
   → CheckOrganizationExist validates only that WeakOrgAddress exists (✓)
   → MethodFeeController is now set to WeakOrgAddress
   ```

5. **Attacker exploits control**:
   ```
   AssociationContract.CreateProposal({
     ToAddress: AEDPoSContractAddress,
     ContractMethodName: "SetMethodFee",
     Params: { fees set to 0 or extremely high values },
     OrganizationAddress: WeakOrgAddress
   })
   → Attacker approves (only needs own signature)
   → Attacker releases
   → Consensus fees are now under attacker's unilateral control
   ```

**Expected vs Actual Result**:
- **Expected**: ChangeMethodFeeController should reject organizations without sufficient multi-signature requirements
- **Actual**: ChangeMethodFeeController accepts any organization that exists, regardless of threshold weakness

**Success Condition**: Attacker achieves unilateral control over AEDPoS contract method fees, bypassing intended multi-signature governance requirements.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L841-877)
```csharp
    public async Task ChangeContractZeroOwnerByAssociation_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(AssociationContractAddress,
            nameof(AssociationContractImplContainer.AssociationContractImplStub.CreateOrganization),
            new Association.CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1,
                    MinimalVoteThreshold = 1
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { AnotherMinerAddress }
                },
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { AnotherMinerAddress }
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var contractDeploymentController = await GetContractDeploymentController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeContractDeploymentController);
        var proposalId = await CreateProposalAsync(Tester, contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = AssociationContractAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

```
