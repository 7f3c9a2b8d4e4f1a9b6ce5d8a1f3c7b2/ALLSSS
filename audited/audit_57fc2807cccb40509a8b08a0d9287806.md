### Title
Unbounded Loop in GetProfitsMap Causes View Method DoS for Long-Running Profit Schemes

### Summary
The `GetProfitsMap` view method calculates profits across all periods and token symbols without applying the same limits used by `ClaimProfits`, resulting in computational complexity that grows unboundedly with scheme age. For long-running schemes with high `CurrentPeriod` values, this causes view queries to exceed AElf's 15,000 branch count execution limit, rendering profit information unqueryable and wasting node resources on repeated failed queries.

### Finding Description
The vulnerability exists in the `GetAllProfitsMap` private helper method called by `GetProfitsMap`. [1](#0-0) 

The method loops through all `availableDetails` without limit [2](#0-1)  and for each detail, calls `ProfitAllPeriods` with `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)` as the period count parameter. [3](#0-2) 

Inside `ProfitAllPeriods`, the method iterates through periods from `LastProfitPeriod` to a maximum bounded by `scheme.CurrentPeriod - 1`, performing state reads and calculations for each symbol in `scheme.ReceivedTokenSymbols`. [4](#0-3) [5](#0-4) 

The `CurrentPeriod` increments by 1 with each `DistributeProfits` call [6](#0-5) , meaning it grows linearly with the number of distribution events. There are no limits on the number of `availableDetails` a beneficiary can have, the number of token symbols in `ReceivedTokenSymbols` [7](#0-6) , or the maximum `CurrentPeriod` value.

While `ClaimProfits` limits processing to 10 details [8](#0-7) [9](#0-8)  and divides the period count accordingly, `GetAllProfitsMap` applies no such bounds when calculating total profits.

AElf enforces execution limits of 15,000 method calls and 15,000 branch count transfers per transaction to prevent infinite loops. [10](#0-9)  These limits apply to view methods as well.

### Impact Explanation
**Operational Impact - DoS of View Method Queries:**

For a scheme running daily distributions over 10 years:
- `CurrentPeriod` = 3,650
- With 10 token symbols and 10 profit details
- Total iterations = 10 × 10 × 3,649 = 364,900
- This far exceeds the 15,000 branch count limit

When `GetProfitsMap` is called for such a beneficiary, the query fails with an execution observer limit exceeded error. This affects:

1. **Users:** Cannot query their accumulated profit information through the view method
2. **Integrations:** DApps and wallets relying on `GetProfitsMap` to display profit data receive failures
3. **Node Resources:** Repeated queries waste CPU cycles on computations that inevitably fail
4. **TokenHolder Contract:** Since `TokenHolderContract.GetProfitsMap` internally calls `ProfitContract.GetProfitsMap` [11](#0-10) , TokenHolder profit queries also fail

The `ClaimProfits` action method remains functional because it enforces stricter limits, so users can still claim profits—they just cannot query the total amounts beforehand.

Severity is **Medium** because while funds remain accessible through `ClaimProfits`, information availability is permanently degraded for long-running schemes, and node resources are wasted on failed queries at zero cost to attackers.

### Likelihood Explanation
**High Likelihood - Naturally Occurring Condition:**

1. **Reachable Entry Point:** `GetProfitsMap` is a public view method marked `(aelf.is_view) = true` [12](#0-11) , callable by any external party without authentication or fees.

2. **Feasible Preconditions:** 
   - Beneficiaries are commonly added with `EndPeriod = 0`, which defaults to `long.MaxValue` [13](#0-12) 
   - Schemes naturally accumulate multiple token symbols through contributions [14](#0-13) 
   - `CurrentPeriod` grows with each distribution, which happens regularly in active schemes

3. **Execution Practicality:** The condition arises passively as time passes—no active attack required. Moderate scenarios already trigger the issue:
   - Weekly distributions over 5 years: CurrentPeriod = 260
   - With 10 details and 5 symbols: 12,950 iterations (approaching 15,000 limit)
   - Hourly distributions over 1 month: CurrentPeriod = 720
   - With 5 details and 5 symbols: 17,975 iterations (exceeds limit)

4. **Economic Rationality:** Zero cost—view methods don't charge transaction fees, so repeated queries cost nothing.

5. **Detection Difficulty:** The issue manifests gradually as schemes age, and may not be noticed until `CurrentPeriod` reaches critical thresholds.

The probability is **high** because any long-running profit scheme will eventually hit this limit through normal operation.

### Recommendation
Apply the same iteration limits used by `ClaimProfits` to the `GetAllProfitsMap` view method:

1. **Limit Total Period Calculation:** When calculating `allProfitsDict`, cap the period count using `maxProfitReceivingPeriodCount` instead of using the unbounded `profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod)`:

```csharp
// In GetAllProfitsMap (line 130), change from:
var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, 
    profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod), true, symbol);

// To:
var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, 
    maxProfitReceivingPeriodCount, true, symbol);
```

2. **Add Detail Count Limit:** Apply the same `profitableDetailCount` limit to the outer loop (line 125) to prevent processing excessive details.

3. **Document Limitations:** Update the proto comments to clarify that `GetProfitsMap` and `GetAllProfitsMap` return profits up to the configured maximum period count, not necessarily all accumulated profits.

4. **Add Test Cases:** Create regression tests with high `CurrentPeriod` values (e.g., 10,000) to verify execution stays within observer limits.

### Proof of Concept
**Initial State:**
1. Create a profit scheme via `CreateScheme`
2. Add a beneficiary with `EndPeriod = 0` (defaults to `long.MaxValue`)

**Attack Steps:**
1. Call `DistributeProfits` 10,000 times sequentially to advance `CurrentPeriod` to 10,000
2. Contribute profits in 10 different token symbols via `ContributeProfits` (populating `ReceivedTokenSymbols`)
3. Call `GetProfitsMap` for the beneficiary

**Expected vs Actual Result:**
- **Expected:** Query returns accumulated profit map across all 10,000 periods
- **Actual:** Query fails with execution observer threshold exceeded (branch count or method call limit surpassed)
- **Success Condition:** Error message indicating execution limit violation, demonstrating the view method is permanently unqueryable for this beneficiary despite having legitimate profit claims

**Verification:** The beneficiary can still successfully call `ClaimProfits` to actually claim profits, confirming the issue is specific to the unbounded view method logic.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L88-96)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary);

        return new ReceivedProfitsMap
        {
            Value = { allProfitsMapResult.AllProfitsMap }
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L161-163)
```csharp
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L641-644)
```csharp
            if (!subScheme.ReceivedTokenSymbols.Contains(symbol))
            {
                subScheme.ReceivedTokenSymbols.Add(symbol);
                State.SchemeInfos[subSchemeShares.SchemeId] = subScheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L716-716)
```csharp
        if (!scheme.ReceivedTokenSymbols.Contains(input.Symbol)) scheme.ReceivedTokenSymbols.Add(input.Symbol);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-774)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L845-874)
```csharp
    private Dictionary<string, long> ProfitAllPeriods(Scheme scheme, ProfitDetail profitDetail, Address beneficiary, long maxProfitReceivingPeriodCount,
        bool isView = false, string targetSymbol = null)
    {
        var profitsMap = new Dictionary<string, long>();
        var lastProfitPeriod = profitDetail.LastProfitPeriod;

        var symbols = targetSymbol == null ? scheme.ReceivedTokenSymbols.ToList() : new List<string> { targetSymbol };

        foreach (var symbol in symbols)
        {
            var totalAmount = 0L;
            var targetPeriod = Math.Min(scheme.CurrentPeriod - 1, profitDetail.EndPeriod);
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L5-5)
```csharp
    public const int ProfitReceivingLimitForEachTime = 10;
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L10-15)
```text
Execution observer
------------------

- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L264-276)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var scheme = State.TokenHolderProfitSchemes[input.SchemeManager];
        var profitsMap = State.ProfitContract.GetProfitsMap.Call(new Profit.ClaimProfitsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary ?? Context.Sender
        });
        return new ReceivedProfitsMap
        {
            Value = { profitsMap.Value }
        };
    }
```

**File:** protobuf/profit_contract.proto (L105-108)
```text
    // Query all profit (up to 10 periods).
    rpc GetProfitsMap (ClaimProfitsInput) returns (ReceivedProfitsMap) {
        option (aelf.is_view) = true;
    }
```
