# Audit Report

## Title
Negative Period Values Bypass Validation Leading to DoS in Profit Claiming

## Summary
The `FixProfitDetail` method in the Profit contract lacks validation on `StartPeriod` and `EndPeriod` values, allowing scheme managers to set negative period values. When beneficiaries attempt to claim profits, these negative periods cause the `ProfitAllPeriods` loop to execute millions of iterations, resulting in gas exhaustion and denial of service.

## Finding Description

The root cause is the complete absence of input validation in the `FixProfitDetail` method. [1](#0-0) 

Unlike `AddBeneficiary`, which properly validates that `EndPeriod >= scheme.CurrentPeriod`, [2](#0-1)  the `FixProfitDetail` method accepts arbitrary period values without any bounds checking. [3](#0-2) 

When these malformed profit details are processed, the validation check in `GetAllProfitsMap` fails to filter them out. The condition `d.EndPeriod >= d.StartPeriod` evaluates to true even for cases like `EndPeriod=100, StartPeriod=-1000000` because `100 >= -1000000` is mathematically true. [4](#0-3) 

The period count calculation then produces extremely large values. When `GetAllProfitsMap` initializes `LastProfitPeriod` from the negative `StartPeriod` and calculates the period range, it produces a value like `100 - (-1000000) = 1000100`. [5](#0-4) 

This enormous count is passed to `ProfitAllPeriods`, where the loop iterates from the negative `LastProfitPeriod` to `maxProfitPeriod`, potentially executing over 1 million iterations. Each iteration performs hash computations and state lookups, causing gas exhaustion. [6](#0-5) 

## Impact Explanation

**Operational Disruption**: Affected beneficiaries cannot execute `ClaimProfits` to withdraw their legitimate profit shares. [7](#0-6)  The same validation logic is used in both view and state-changing functions, causing identical DoS in both contexts.

**View Function Failures**: All profit query functions (`GetAllProfitsMap`, `GetProfitAmount`, `GetAllProfitAmount`) fail with gas exhaustion, breaking user interfaces and preventing users from viewing their profit balances.

**Scope**: The impact is contained to beneficiaries within schemes controlled by malicious or compromised managers. However, this includes the TokenHolder contract which has manager privileges [8](#0-7)  and manages critical staking rewards.

**Severity Justification**: MEDIUM - This is a DoS vulnerability that prevents legitimate profit withdrawals. While funds are not stolen, they become inaccessible until the malformed ProfitDetail is manually corrected, and the attack can affect system-critical contracts.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must obtain scheme manager privileges, which can be achieved by: (1) creating their own scheme (trivial - any user can do this), or (2) compromising an existing manager account. Scheme managers are per-scheme roles, not globally trusted positions.

**Attack Complexity**: Extremely low - a single transaction calling `FixProfitDetail` with negative `StartPeriod` values is sufficient. The method is publicly accessible to authorized managers. [9](#0-8) 

**Feasibility Conditions**:
- For self-managed schemes: Requires victims to become beneficiaries in the attacker's scheme
- For existing schemes: Requires manager account compromise or malicious integration code
- TokenHolder contract integration presents highest risk if it calls `FixProfitDetail` with unsanitized parameters

**Probability Assessment**: MEDIUM - While obtaining manager role for one's own scheme is trivial, the impact is limited to that scheme's participants. Broader impact requires either social engineering or technical compromise.

## Recommendation

Add validation in the `FixProfitDetail` method to ensure period values are non-negative and reasonable:

```csharp
public override Empty FixProfitDetail(FixProfitDetailInput input)
{
    Assert(input.SchemeId != null, "Invalid scheme id.");
    var scheme = State.SchemeInfos[input.SchemeId];
    if (Context.Sender != scheme.Manager && Context.Sender !=
        Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
    {
        throw new AssertionException("Only manager or token holder contract can add beneficiary.");
    }

    // Add validation for period values
    if (input.StartPeriod != 0)
    {
        Assert(input.StartPeriod > 0, "StartPeriod must be positive.");
        Assert(input.StartPeriod >= scheme.CurrentPeriod, "StartPeriod cannot be in the past.");
    }
    
    if (input.EndPeriod != 0)
    {
        Assert(input.EndPeriod > 0, "EndPeriod must be positive.");
        Assert(input.EndPeriod >= scheme.CurrentPeriod, "EndPeriod cannot be in the past.");
    }

    // Rest of the method...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task NegativePeriod_CausesDoS_Test()
{
    // Setup: Create scheme and add beneficiary
    var creator = Creators[0];
    var beneficiary = Normal[0];
    var beneficiaryAddress = Address.FromPublicKey(NormalKeyPair[0].PublicKey);
    
    var schemeId = await CreateSchemeAsync();
    await ContributeProfits(schemeId, 1000);
    
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiaryAddress, Shares = 100 },
        EndPeriod = 100
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId,
        AmountsMap = { { ProfitContractTestConstants.NativeTokenSymbol, 100 } },
        Period = 1
    });
    
    // Attack: Manager sets negative StartPeriod via FixProfitDetail
    await creator.FixProfitDetail.SendAsync(new FixProfitDetailInput
    {
        SchemeId = schemeId,
        BeneficiaryShare = new BeneficiaryShare { Beneficiary = beneficiaryAddress, Shares = 100 },
        StartPeriod = -1000000,  // Negative period
        EndPeriod = 100
    });
    
    // Verify: ClaimProfits now fails with gas exhaustion
    var result = await beneficiary.ClaimProfits.SendWithExceptionAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId
    });
    
    // Transaction should fail due to excessive loop iterations
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    
    // View functions also fail
    var viewResult = await creator.GetProfitsMap.CallWithExceptionAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiaryAddress
    });
    // This call will timeout or fail due to gas exhaustion
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L265-306)
```csharp
    public override Empty FixProfitDetail(FixProfitDetailInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        var scheme = State.SchemeInfos[input.SchemeId];
        if (Context.Sender != scheme.Manager && Context.Sender !=
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName))
        {
            throw new AssertionException("Only manager or token holder contract can add beneficiary.");
        }

        // Try to get profitDetails by Id
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary];
        ProfitDetail fixingDetail = null;
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
        }

        if (fixingDetail == null)
        {
            // However, in the old time, profitDetail.Id is null, so use Shares.
            fixingDetail = profitDetails.Details.OrderBy(d => d.StartPeriod)
                .FirstOrDefault(d => d.Shares == input.BeneficiaryShare.Shares);
        }

        if (fixingDetail == null)
        {
            throw new AssertionException("Cannot find proper profit detail to fix.");
        }

        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L750-767)
```csharp
    public override Empty ClaimProfits(ClaimProfitsInput input)
    {
        var scheme = State.SchemeInfos[input.SchemeId];
        if (scheme == null) throw new AssertionException("Scheme not found.");
        var beneficiary = input.Beneficiary ?? Context.Sender;
        var profitDetails = State.ProfitDetailsMap[input.SchemeId][beneficiary];
        if (profitDetails == null) throw new AssertionException("Profit details not found.");

        Context.LogDebug(
            () => $"{Context.Sender} is trying to profit from {input.SchemeId.ToHex()} for {beneficiary}.");

        // LastProfitPeriod is set as 0 at the very beginning, and be updated as current period every time when it is claimed.
        // What's more, LastProfitPeriod can also be +1 more than endPeroid, for it always points to the next period to claim.
        // So if LastProfitPeriod is 0, that means this profitDetail hasn't be claimed before, so just check whether it is a valid one;
        // And if a LastProfitPeriod is larger than EndPeriod, it should not be claimed, and should be removed later.
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
        var profitableDetails = availableDetails.Where(d => d.LastProfitPeriod < scheme.CurrentPeriod).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L857-865)
```csharp
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L113-117)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod < scheme.CurrentPeriod && (d.LastProfitPeriod == 0
                ? d.EndPeriod >= d.StartPeriod
                : d.EndPeriod >= d.LastProfitPeriod)
        ).ToList();
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L128-130)
```csharp
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
```
