### Title
Insufficient Miner Selection in GetVictories() Leads to Undersized Consensus Round

### Summary
The `GetVictories()` function incorrectly limits backup miner selection to `currentMiners.Count` instead of the actual number of available backups. When `State.MinersCount.Value` increases over time but there are insufficient valid candidates, the function returns fewer miners than required, causing consensus rounds to be generated with an undersized miner set that violates the configured miner count invariant.

### Finding Description

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method. [1](#0-0) 

When there are insufficient valid candidates (line 62), the function attempts to fill the gap using backup miners. The root cause is on line 72, where it takes `Math.Min(diff, currentMiners.Count)` miners from the backups list, instead of taking `diff` or `Math.Min(diff, backups.Count)`.

The execution path is:
1. `State.MinersCount.Value` is dynamically increased over time via `GetMinersCount()` [2](#0-1) 
2. `UpdateMinersCount()` is called to update the Election contract [3](#0-2) 
3. During term transition, AEDPoS calls `GetVictories()` [4](#0-3) 
4. If `validCandidates.Count < State.MinersCount.Value` and `currentMiners.Count < diff`, the backups are insufficiently selected
5. The undersized miner list is used to generate the new consensus round [5](#0-4) 

No existing validation prevents this - the round generation accepts whatever miner count is provided.

### Impact Explanation

The harm is violation of consensus miner schedule integrity:
- **Consensus Degradation**: The blockchain operates with fewer block producers than configured, reducing decentralization and security
- **State Inconsistency**: `State.MinersCount.Value` indicates N miners should exist, but actual rounds have < N miners
- **Reward Misallocation**: Profit distribution schemes assume the configured miner count, causing incorrect per-miner reward calculations
- **Protocol Invariant Violation**: The critical invariant that consensus rounds must contain exactly `State.MinersCount.Value` miners is broken

Quantified example: If `State.MinersCount.Value = 10`, `validCandidates = 2`, `currentMiners.Count = 5`, and `backups.Count = 8`, the function returns only 7 miners (2 valid + min(8,5) backups) instead of 10, leaving 3 miner slots unfilled.

This is HIGH severity because it directly compromises consensus integrity, a critical invariant.

### Likelihood Explanation

This vulnerability has MEDIUM-HIGH likelihood:

**Attacker Capabilities**: None required - this is a logic bug that triggers under natural conditions, not an active attack.

**Feasibility Conditions**:
1. `State.MinersCount.Value` increases over time (happens automatically via `GetAutoIncreasedMinersCount()`) [6](#0-5) 
2. Low voter participation results in `validCandidates.Count < State.MinersCount.Value`
3. Previous term had fewer miners than the new target

**Probability Reasoning**: The AEDPoS miner count auto-increments every `MinerIncreaseInterval` seconds by 2 miners. In a growing network with insufficient candidate onboarding or low voter engagement, this condition is realistic. Test configurations show initial counts of 5 miners increasing to targets of 17+. [7](#0-6) 

**Detection**: The bug is logged but not prevented - debug logs show the incorrect miner count but no assertion validates it matches `State.MinersCount.Value`.

### Recommendation

**Code-Level Mitigation**:
Replace line 72 in `GetVictories()`:
```csharp
// BEFORE (buggy):
.Take(Math.Min(diff, currentMiners.Count))

// AFTER (fixed):
.Take(diff)
```

This allows selection of all available backups up to the required `diff` amount, since the `backups` list already contains sufficient entries from both `currentMiners` and `State.InitialMiners`.

**Invariant Check**:
Add assertion after line 76:
```csharp
Assert(victories.Count == State.MinersCount.Value, 
    $"Victory count {victories.Count} does not match required miners count {State.MinersCount.Value}");
```

**Test Cases**:
Create regression test covering:
- Scenario: `MinersCount = 10`, `validCandidates = 2`, `currentMiners = 5`, `InitialMiners = 5`
- Expected: `victories.Count == 10`
- Verify all 10 slots filled from valid candidates + backups

### Proof of Concept

**Initial State**:
- Chain initialized with 5 initial miners
- `State.MinersCount.Value = 5`
- `State.InitialMiners.Value` contains 5 pubkeys
- Several terms pass, auto-increment triggers

**Transaction Steps**:
1. Blockchain time advances sufficiently that `GetAutoIncreasedMinersCount()` returns 10
2. Consensus contract calls `UpdateMinersCount(10)` on Election contract
3. Only 2 candidates register and receive votes (become valid candidates)
4. Term transition occurs, AEDPoS calls `State.ElectionContract.GetVictories.Call(new Empty())`
5. Function executes with: `validCandidates.Count = 2`, `currentMiners.Count = 5`, `diff = 8`
6. Line 66-69 builds backups: 5 current + 5 initial = up to 10 available (minus any overlaps)
7. Line 72 takes `Math.Min(8, 5) = 5` from backups
8. Returns `victories` with 2 + 5 = 7 miners

**Expected Result**: `victories.Count == 10` (State.MinersCount.Value)

**Actual Result**: `victories.Count == 7` (< State.MinersCount.Value)

**Success Condition**: The consensus round generated from this miner list will have only 7 entries in `RealTimeMinersInformation` instead of the required 10, violating the miner schedule integrity invariant.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-280)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L381-391)
```csharp
    private int GetMinersCount(Round input)
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        if (!TryToGetRoundInformation(1, out _)) return 0;
        return Math.Min(input.RealTimeMinersInformation.Count < AEDPoSContractConstants.SupposedMinersCount
            ? AEDPoSContractConstants.SupposedMinersCount
            : AEDPoSContractConstants.SupposedMinersCount.Add(
                (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
                .Div(State.MinerIncreaseInterval.Value).Mul(2)), State.MaximumMinersCount.Value);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L149-160)
```csharp
    public override Empty UpdateMinersCount(UpdateMinersCountInput input)
    {
        Context.LogDebug(() =>
            $"Consensus Contract Address: {Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName)}");
        Context.LogDebug(() => $"Sender Address: {Context.Sender}");
        Assert(
            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName) == Context.Sender,
            "Only consensus contract can update miners count.");
        State.MinersCount.Value = input.MinersCount;
        SyncSubsidyInfoAfterReduceMiner();
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** test/AElf.Contracts.Economic.TestBase/EconomicContractsTestConstants.cs (L11-16)
```csharp
    public const int InitialCoreDataCenterCount = 5;
    public const int CoreDataCenterCount = 7;
    public const int ValidateDataCenterCount = 35;
    public const int ValidateDataCenterCandidateCount = 13;
    public const int VoterCount = 10;
    public const int SupposedMinersCount = 17;
```
