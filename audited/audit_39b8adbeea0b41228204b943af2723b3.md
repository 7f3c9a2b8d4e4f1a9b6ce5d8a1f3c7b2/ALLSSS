### Title
Unbounded Proposal Expiration Time Enables Permanent Storage Lock in Association Contract

### Summary
The Association contract's `CreateProposal` function accepts user-provided `ExpiredTime` values without enforcing a maximum bound, allowing whitelisted proposers to set expiration dates far in the future (up to year 9999). Since the `ClearProposal` cleanup mechanism requires `CurrentBlockTime >= ExpiredTime`, proposals with distant expiration times cannot be removed from storage for thousands of years, enabling permanent storage bloat attacks.

### Finding Description

The vulnerability exists in the proposal validation logic within the Association contract. When a proposal is created via `CreateNewProposal`, the `ExpiredTime` field is validated only to ensure it's non-null and in the future: [1](#0-0) 

This validation check at line 89 only ensures `Context.CurrentBlockTime < proposal.ExpiredTime`, with no upper bound validation. The proposal creation flow accepts the user-provided `ExpiredTime` directly from input: [2](#0-1) 

An attacker can set `ExpiredTime` to the maximum Timestamp value defined in the system: [3](#0-2) 

This maximum value of 253402300799 seconds corresponds to December 31, 9999, effectively making proposals permanent.

The cleanup mechanism in `ClearProposal` explicitly requires the proposal to be expired before removal: [4](#0-3) 

Line 286 enforces that `Context.CurrentBlockTime >= proposal.ExpiredTime` must be true, preventing cleanup of proposals with far-future expiration times.

Proposals are stored in an unbounded `MappedState` structure with no count limits: [5](#0-4) 

The same vulnerability pattern exists in Parliament and Referendum contracts, which use identical validation logic.

### Impact Explanation

An attacker with ProposerWhiteList membership can create multiple proposals with `ExpiredTime` set to year 9999, causing:

1. **Permanent Storage Consumption**: Each `ProposalInfo` object occupies storage containing addresses, parameters, title, description, and vote tracking lists. These proposals cannot be cleaned up until year 9999 (approximately 8,000 years from now).

2. **Unbounded Storage Growth**: There are no limits on the number of proposals a whitelisted proposer can create. By repeatedly calling `CreateProposal` with maximum expiration times, an attacker can continuously inflate storage.

3. **Organization-Specific Impact**: The attack affects the targeted organization's proposal storage in the `State.Proposals` mapping. While other organizations remain unaffected, the victim organization experiences degraded performance and increased operational costs.

4. **Economic Griefing**: The attack cost is limited to transaction fees (approximately 50 ELF per proposal based on test configurations), making it economically feasible as a griefing vector.

The severity is **Medium** because while the impact is real and permanent, it:
- Does not enable fund theft or unauthorized execution
- Requires ProposerWhiteList membership (partial trust assumption)
- Affects specific organizations rather than the entire protocol
- Does not compromise consensus or cross-chain integrity

### Likelihood Explanation

**Attacker Capabilities Required:**
- Membership in an organization's ProposerWhiteList
- This is a partially trusted role but can be compromised through account hacking or malicious insiders

**Attack Complexity:**
- Low - simply call `CreateProposal` with `ExpiredTime = new Timestamp { Seconds = 253402300799L }`
- No complex transaction sequences or timing requirements needed
- Can be repeated arbitrarily to create multiple locked proposals

**Feasibility Conditions:**
- The `CreateProposal` function is publicly accessible with only whitelist authorization [6](#0-5) 

- Transaction fees provide minimal economic deterrent
- ProposerWhiteList members may have legitimate reasons to be in the list but could act maliciously or be compromised

**Detection Constraints:**
- Proposals with far-future expiration times are valid according to current contract logic
- No monitoring or alerting mechanisms exist for abnormal expiration time values
- The attack would only become apparent when storage costs become burdensome

The likelihood is **Realistic** because ProposerWhiteList compromise scenarios (stolen keys, malicious insiders, or social engineering) are practical threat vectors in decentralized governance systems.

### Recommendation

**Immediate Mitigation:**

Add a maximum expiration time validation in the `Validate` function:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    var maxExpirationTime = Context.CurrentBlockTime.AddDays(30); // or configurable value
    return proposal.ExpiredTime != null && 
           Context.CurrentBlockTime < proposal.ExpiredTime &&
           proposal.ExpiredTime <= maxExpirationTime;
}
```

**Additional Protections:**

1. Add configurable maximum expiration period in organization settings:
   - Allow organizations to set their own maximum proposal lifetime
   - Default to reasonable value (e.g., 30 days)

2. Implement proposal count limits per proposer:
   - Track active proposal count per proposer address
   - Enforce maximum concurrent proposals per whitelisted member

3. Add monitoring and alerting:
   - Log warnings for proposals with expiration times beyond thresholds
   - Implement governance review for proposals with extended lifetimes

4. Consider forced cleanup mechanisms:
   - Allow organization members to vote for early proposal cleanup
   - Implement admin emergency cleanup with governance approval

**Test Cases to Add:**

1. Verify proposal creation fails when `ExpiredTime` exceeds maximum bound
2. Test proposal creation succeeds with reasonable expiration times
3. Validate cleanup mechanism works for both expired and max-bounded proposals
4. Test edge cases around maximum timestamp values

Apply the same fix to Parliament and Referendum contracts which share identical validation logic.

### Proof of Concept

**Initial State:**
- Attacker address is in the ProposerWhiteList of organization X
- Organization X has valid configuration with member list and thresholds

**Attack Steps:**

1. Create proposal with far-future expiration:
```
CreateProposalInput input = {
    ContractMethodName: "TestMethod",
    ToAddress: <any_valid_address>,
    Params: <any_params>,
    ExpiredTime: { Seconds: 253402300799, Nanos: 999999999 }, // Year 9999
    OrganizationAddress: <organization_X_address>,
    Title: "Locked Proposal",
    Description: "This will stay forever"
}

proposalId = AssociationContract.CreateProposal(input)
```

2. Verify proposal is created and stored:
```
proposal = AssociationContract.GetProposal(proposalId)
// Returns valid proposal with ExpiredTime = year 9999
```

3. Attempt cleanup (will fail):
```
AssociationContract.ClearProposal(proposalId)
// Fails with "Proposal clear failed" because CurrentBlockTime < ExpiredTime
```

4. Repeat steps 1-2 multiple times to create many locked proposals

**Expected vs Actual Result:**

**Expected:** Proposal creation should fail or expiration time should be bounded to a reasonable maximum (e.g., 30-90 days from current time).

**Actual:** Proposal is created successfully with year 9999 expiration and remains permanently in storage, consuming resources indefinitely until the year 9999.

**Success Condition:** 
The attack succeeds when `State.Proposals[proposalId]` contains a proposal that cannot be removed via `ClearProposal` for approximately 8,000 years, effectively achieving permanent storage lock.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Election/TimestampHelper.cs (L14-15)
```csharp
    /// </summary>
    public static Timestamp MaxValue => new() { Nanos = 999999999, Seconds = 253402300799L };
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationState.cs (L9-10)
```csharp
    public MappedState<Address, Organization> Organizations { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
```
