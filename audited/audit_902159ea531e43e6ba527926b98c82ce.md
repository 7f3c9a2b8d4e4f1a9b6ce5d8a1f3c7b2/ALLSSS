### Title
Insufficient Alternative Selection Allows Banned Miners to Remain Active in Consensus

### Summary
The `GetMinerReplacementInformation()` function can return fewer alternative candidates than the number of evil miners requiring replacement. The consensus contract only replaces miners up to the count of alternatives provided, allowing banned miners to remain active in the consensus mechanism and continue producing blocks.

### Finding Description

**Root Cause:**
In the Election contract's `GetMinerReplacementInformation()` function, the alternative selection logic uses `Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count)` to limit alternatives from the candidate pool. [1](#0-0) 

While the function attempts to fill the gap using initial miners, this fallback also uses `Math.Min(diff, State.InitialMiners.Value.Value.Count)`, which means if there aren't enough initial miners available (after filtering for banned and current miners), the total `alternativeCandidates.Count` will be less than `evilMinersPubKeys.Count`. [2](#0-1) 

**Why Existing Protections Fail:**
The consensus contract consumes this replacement information by iterating only through `AlternativeCandidatePubkeys.Count`, replacing evil miners one-by-one at matching indices. [3](#0-2) 

Evil miners at indices beyond `AlternativeCandidatePubkeys.Count` are never removed from `currentRound.RealTimeMinersInformation`, allowing them to remain in the active miner set.

The `PreCheck()` validation in the consensus contract only verifies that a miner exists in the current or previous round's miner list, but does not check if they are banned. [4](#0-3) 

**Relevant Execution Path:**
1. Miners are marked as evil/banned via `UpdateCandidateInformation()` with `IsEvilNode = true`, setting `State.BannedPubkeyMap[pubkey] = true` [5](#0-4) 
2. During round generation, consensus contract calls `GetMinerReplacementInformation()` [6](#0-5) 
3. If insufficient alternatives exist, some evil miners remain unreplaced
4. These miners continue passing validation checks and producing blocks

### Impact Explanation

**Consensus Integrity Breach:**
Banned miners who should be immediately removed from the active validator set can continue participating in consensus, producing blocks, and earning mining rewards. This fundamentally breaks the security guarantee that malicious or compromised miners are promptly excluded from the consensus mechanism.

**Quantified Damage:**
- **Ongoing Malicious Activity**: Evil miners banned for malicious behavior (detected attacks, double-signing, etc.) can continue their activities
- **Reward Misallocation**: Banned miners continue earning block production rewards and mining incentives that should go to legitimate validators
- **Consensus Security Degradation**: The Byzantine fault tolerance assumptions are violated if banned miners (potentially coordinating attackers) exceed safety thresholds

**Affected Parties:**
- All network participants suffer from reduced consensus security
- Legitimate miners lose potential rewards to banned miners
- Token holders bear the risk of consensus compromise

**Severity Justification:**
This is **CRITICAL** because it directly violates the core invariant of "miner schedule integrity" and allows explicitly banned miners to maintain control over block production, undermining the entire security model of the blockchain.

### Likelihood Explanation

**Attack Feasibility:**
This is not an active attack but a **protocol flaw** that occurs through normal operations:

**Realistic Triggering Conditions:**
1. **Multiple simultaneous bans**: When several miners are banned in quick succession (e.g., mass detection of coordinated misbehavior), alternatives may be insufficient
2. **Small candidate pool**: During low election participation or early chain stages, few qualified alternatives exist
3. **Depleted initial miners**: Initial miners may already be serving as active miners or themselves be banned

**Execution Practicality:**
- No special attacker capabilities required
- Occurs automatically during consensus round generation when banned miner count exceeds available alternatives
- No external transaction injection or timing manipulation needed

**Probability Assessment:**
- **Medium-to-High probability** in realistic scenarios:
  - Mainnet with 17+ miners where 5+ are simultaneously banned
  - Limited candidate pool (< 10 qualified candidates)
  - 5-7 initial miners with 2-3 already active or banned
  - Results in 2-3 unreplaced banned miners continuing consensus participation

### Recommendation

**Immediate Fix:**
Modify the consensus contract's miner replacement logic to handle insufficient alternatives gracefully:

```csharp
// In AEDPoSContract_ViewMethods.cs, after line 309:
if (minerReplacementInformation.EvilMinerPubkeys.Count > 
    minerReplacementInformation.AlternativeCandidatePubkeys.Count)
{
    // Force term change or emergency state if evil miners cannot all be replaced
    Assert(false, "Insufficient alternatives to replace all banned miners. Term change required.");
}
```

**Additional Safeguards:**
1. Add validation in `PreCheck()` to explicitly reject banned miners:
```csharp
// In AEDPoSContract_ProcessConsensusInformation.cs PreCheck():
if (State.ElectionContract.IsPubkeyBanned.Call(new StringValue 
    { Value = _processingBlockMinerPubkey }).Value)
    return false;
```

2. Implement an assertion in `GetMinerReplacementInformation()`:
```csharp
// After line 398 in ViewMethods.cs:
Assert(alternativeCandidates.Count >= evilMinersPubKeys.Count,
    $"Cannot find sufficient alternatives: need {evilMinersPubKeys.Count}, found {alternativeCandidates.Count}");
```

**Test Cases:**
1. Test scenario with 5 banned miners, 2 candidates, 1 available initial miner
2. Verify assertion triggers and prevents round progression
3. Test that banned miners cannot produce blocks even if in miner list
4. Verify emergency procedures activate when replacements insufficient

### Proof of Concept

**Initial State:**
- Active miner list: 17 miners (M1-M17)
- M13, M14, M15, M16, M17 are marked as banned (BannedPubkeyMap[Mi] = true)
- Candidate pool: 2 qualified candidates (C1, C2) with votes
- Initial miners: 7 total, with 5 already active as M1-M5, 1 banned (M13 was initial), leaving 1 available (I1)

**Execution Sequence:**

1. Consensus contract calls `GetMinerReplacementInformation()` during round generation [6](#0-5) 

2. Election contract identifies 5 evil miners: [M13, M14, M15, M16, M17] [7](#0-6) 

3. From candidates, selects min(5, 2) = 2 alternatives: [C1, C2] [1](#0-0) 

4. Calculates diff = 5 - 2 = 3, tries to add initial miners [8](#0-7) 

5. Only 1 initial miner available (I1), so adds 1: alternativeCandidates = [C1, C2, I1]

6. Returns: EvilMinerPubkeys = [M13, M14, M15, M16, M17], AlternativeCandidatePubkeys = [C1, C2, I1] [9](#0-8) 

7. Consensus loops for i=0 to 2 (AlternativeCandidatePubkeys.Count=3): [3](#0-2) 
   - i=0: Replace M13 with C1 ✓
   - i=1: Replace M14 with C2 ✓
   - i=2: Replace M15 with I1 ✓

**Expected Result:** All 5 banned miners (M13-M17) removed from active consensus

**Actual Result:** 
- M13, M14, M15 replaced successfully
- **M16 and M17 remain in currentRound.RealTimeMinersInformation**
- M16 and M17 pass PreCheck validation and continue producing blocks
- No error or alert raised about incomplete replacement

**Success Condition for Exploit:** M16 or M17 successfully produces a block after being banned, demonstrating continued consensus participation despite ban status.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L360-361)
```csharp
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L376-377)
```csharp
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L383-392)
```csharp
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L394-398)
```csharp
        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
