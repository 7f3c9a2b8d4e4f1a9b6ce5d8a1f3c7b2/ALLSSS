# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTermInput Allows Reward Manipulation

## Summary
The `NextTermInput.Create()` method and consensus validation providers fail to validate the `ExtraBlockProducerOfPreviousRound` field in term transition blocks. This allows a malicious miner producing a NextTerm block to manipulate this field, granting arbitrary miners extra tiny block production privileges before the round starts, thereby increasing their `ProducedBlocks` count and unfairly affecting reward distribution.

## Finding Description

The vulnerability exists across multiple consensus validation layers that collectively fail to ensure the integrity of the `ExtraBlockProducerOfPreviousRound` field during term transitions.

**1. No validation in NextTermInput.Create():**

The `Create()` method blindly copies `ExtraBlockProducerOfPreviousRound` from the input Round without any validation that it matches the actual block producer's pubkey. [1](#0-0) 

**2. RoundTerminateValidationProvider lacks field validation:**

The validation for NextTerm transitions only validates round number increment, term number increment, and that InValues are null - it completely omits validation of `ExtraBlockProducerOfPreviousRound`. [2](#0-1) 

**3. Field excluded from hash-based validation:**

The `GetCheckableRound()` method used for hash-based validation only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge`, explicitly excluding `ExtraBlockProducerOfPreviousRound`. [3](#0-2) 

**4. Field grants special mining privileges:**

When `ExtraBlockProducerOfPreviousRound` matches a miner's pubkey and the current time is before the round start time, that miner is granted permission to produce tiny blocks, bypassing normal time slot restrictions. [4](#0-3) [5](#0-4) 

**5. Tiny blocks increment ProducedBlocks counter:**

Each tiny block produced increments the miner's `ProducedBlocks` count, which is later used for reward calculations and reputation tracking. [6](#0-5) 

**6. Correct generation vs. actual usage:**

While `GenerateFirstRoundOfNextTerm()` correctly sets `ExtraBlockProducerOfPreviousRound` to the sender's pubkey, there is no enforcement that the actual NextTermInput received matches this expected value. [7](#0-6) 

**7. Manipulated data persisted to state:**

The `ProcessNextTerm` method converts the input to a Round object and stores it without validating `ExtraBlockProducerOfPreviousRound`, allowing the manipulated value to be persisted and used for subsequent mining permission checks. [8](#0-7) 

**8. ProducedBlocks affects rewards:**

The total mined blocks (sum of all miners' `ProducedBlocks`) is used to calculate mining rewards, and individual `ProducedBlocks` counts are reported to the Election contract where they influence reward distribution, reputation, and voting weights. [9](#0-8) [10](#0-9) 

## Impact Explanation

**Direct Reward Manipulation:**

The vulnerability enables direct manipulation of mining rewards and reputation through the following attack chain:

1. **Privilege Grant**: A malicious miner producing a NextTerm block can set `ExtraBlockProducerOfPreviousRound` to any miner's pubkey (including a colluding party or themselves under different identity)

2. **Extra Mining Opportunities**: The beneficiary miner gains the ability to produce tiny blocks before the round officially starts, a privilege normal miners don't have during this period

3. **Inflated Block Count**: Each tiny block increments the beneficiary's `ProducedBlocks` counter, artificially inflating their mining contribution

4. **Reward Misallocation**: The inflated `ProducedBlocks` count affects:
   - Total mining reward calculations donated to Treasury
   - Individual miner statistics reported to Election contract  
   - Proportional reward distribution based on mining contribution
   - Miner reputation and voting weight in governance

**Attack Scenarios:**

- **Collusion**: Attacker sets field to colluding miner's pubkey, both share the extra rewards
- **Self-enrichment**: Attacker sets field to their own pubkey (if different from NextTerm transaction sender)
- **Denial of Service**: Setting to non-existent pubkey prevents anyone from producing transition blocks, potentially stalling consensus

**Affected Parties:**

- Legitimate extra block producer loses rightful mining privileges and rewards
- Honest miners receive proportionally reduced rewards when attacker inflates block counts
- Protocol integrity compromised as rewards no longer reflect actual work performed

## Likelihood Explanation

**Attack Prerequisites:**

The attacker must be selected to produce the NextTerm block, which is a standard consensus role that rotates among miners during term transitions. This is not an exceptional privilege but rather a normal operational requirement.

**Execution Steps:**

1. Attacker's turn to produce NextTerm block arrives
2. Attacker calls `GetConsensusExtraData` which returns properly formatted Round data
3. Before signing the block, attacker modifies `ExtraBlockProducerOfPreviousRound` field in the consensus extra data
4. Modified block passes all validation:
   - `MiningPermissionValidationProvider` checks sender is in miner list (passes)
   - `RoundTerminateValidationProvider` validates round/term numbers and InValues (passes)
   - No validator checks `ExtraBlockProducerOfPreviousRound`
5. `ProcessNextTerm` executes, storing manipulated Round to state
6. In subsequent blocks, beneficiary miner exploits extra mining privileges

**Detection Difficulty:**

The manipulation is undetectable through normal validation because:
- Validation doesn't regenerate expected Round data to compare
- The field is excluded from hash-based integrity checks
- Block appears valid to all consensus validators
- No on-chain evidence of the expected vs. actual value

**Economic Rationality:**

The attack is economically rational because:
- Cost: Minimal (just modifying one field before block signing)
- Benefit: Direct increase in mining rewards through extra block production
- Risk: Low detection probability due to validation gaps
- Frequency: Every term transition provides an attack opportunity

## Recommendation

Implement comprehensive validation of `ExtraBlockProducerOfPreviousRound` in `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate ExtraBlockProducerOfPreviousRound matches the sender
    var senderPubkey = validationContext.SenderPubkey.ToHex();
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != senderPubkey)
        return new ValidationResult { Message = "ExtraBlockProducerOfPreviousRound must match sender pubkey." };
    
    return new ValidationResult { Success = true };
}
```

Additionally, consider including `ExtraBlockProducerOfPreviousRound` in `GetCheckableRound()` to enable hash-based validation as a defense-in-depth measure.

## Proof of Concept

The vulnerability can be demonstrated by creating a test that:

1. Sets up a term transition scenario with a current round
2. Creates a malicious miner who produces the NextTerm block
3. Constructs a `NextTermInput` with `ExtraBlockProducerOfPreviousRound` set to a different miner's pubkey (not the sender)
4. Calls `NextTerm` with the manipulated input
5. Verifies that the transaction succeeds and the manipulated value is stored
6. Confirms the beneficiary miner can now produce tiny blocks before the round starts
7. Shows the beneficiary's `ProducedBlocks` count increases unfairly

A complete test would require access to the AElf test infrastructure to mock the consensus validation pipeline, but the core exploitation logic follows the execution path traced above through the contract code.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L37-51)
```csharp
    private void UpdateCurrentMinerInformationToElectionContract(Round previousRound)
    {
        State.ElectionContract.UpdateMultipleCandidateInformation.Send(new UpdateMultipleCandidateInformationInput
        {
            Value =
            {
                previousRound.RealTimeMinersInformation.Select(i => new UpdateCandidateInformationInput
                {
                    Pubkey = i.Key,
                    RecentlyProducedBlocks = i.Value.ProducedBlocks,
                    RecentlyMissedTimeSlots = i.Value.MissedTimeSlots
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-120)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
```
