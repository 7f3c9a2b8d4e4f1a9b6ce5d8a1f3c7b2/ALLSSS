### Title
Proposal-Request Mismatch in ReleaseSideChainCreation Allows Token Creation for Wrong User

### Summary
The `ReleaseSideChainCreation()` function retrieves the side chain creation request from `Context.Sender`'s storage but releases a proposal specified by `input.ProposalId` without verifying these are associated. This allows an attacker with their own pending request to release any other user's approved proposal, causing token creation for the attacker's request while consuming the victim's proposal for side chain creation.

### Finding Description

The vulnerability exists in the `ReleaseSideChainCreation()` function where two independent operations are performed without correlation validation: [1](#0-0) 

The function retrieves the creation request from storage keyed by `Context.Sender`, regardless of which proposal ID is provided as input. [2](#0-1) 

Token creation uses the retrieved request from `Context.Sender`, but the proposal release uses `input.ProposalId` which may belong to a completely different user. There is no validation that `input.ProposalId` was created by or corresponds to `Context.Sender`'s stored request.

When a proposal is created via `ProposeNewSideChain()`, it stores both the proposal in the governance contract and the request state keyed by proposer: [3](#0-2) 

The proposal parameters include the proposer address: [4](#0-3) 

When the proposal is actually released and executed, `CreateSideChain()` is called with the proposer from the proposal parameters, not from `Context.Sender`: [5](#0-4) 

This creates a critical mismatch where token creation and side chain creation operate on different users' requests.

### Impact Explanation

**Direct Economic Impact**: If the side chain creation request includes token creation (when `IsPrivilegePreserved` is true and primary token is needed), the attacker can have their token created with their chosen parameters (symbol, supply, decimals) while consuming another user's approved governance proposal. If the token has economic value through initial distribution or other mechanisms, the attacker directly benefits.

**Governance Integrity Impact**: The attacker consumes a victim's approved proposal that underwent proper governance review, but applies it to create a side chain with the victim's parameters while getting their own token created. This breaks the atomicity assumption that a single proposal governs both token and chain creation.

**Affected Parties**:
- Victim: Their approved proposal is consumed but token is not created for them
- Attacker: Gets token created for their request without proper approval
- Protocol: Governance process is circumvented, creating unauthorized state changes

**Severity**: High - allows economic benefit theft and governance bypass with low execution complexity.

### Likelihood Explanation

**Attacker Capabilities Required**: 
- Must have their own pending side chain creation request (created via `RequestSideChainCreation()`)
- Must observe another user's approved proposal ID (publicly visible in blockchain state)
- Can call `ReleaseSideChainCreation()` with victim's proposal ID

**Attack Complexity**: Low - single transaction with publicly available proposal ID.

**Feasibility Conditions**:
- No authorization check on `ReleaseSideChainCreation()` (public method)
- Multiple users can have concurrent pending requests
- Proposal IDs are observable on-chain

**Detection**: The mismatch between token creator and side chain proposer would be visible in events, but by then the exploit is complete and irreversible.

**Economic Rationality**: If tokens have value (e.g., through initial distribution to issuer), or if getting governance approval is costly/difficult, the attack is economically rational. The attacker gets their token created "for free" by hijacking another's approval.

**Probability**: High - the conditions are easily met whenever multiple users have pending requests and at least one proposal is approved.

### Recommendation

Add validation in `ReleaseSideChainCreation()` to ensure the `input.ProposalId` corresponds to `Context.Sender`'s stored request:

1. **Store proposal ID with request state**: Modify `ProposeNewSideChain()` to store the generated proposal ID in `SideChainCreationRequestState` and persist it in state mapped by `Context.Sender`.

2. **Validate proposal ownership**: In `ReleaseSideChainCreation()`, after retrieving the request, add:
   ```csharp
   Assert(sideChainCreationRequest.ProposalId == input.ProposalId, 
          "Proposal does not belong to sender.");
   ```

3. **Add regression test**: Create a test case where User A creates a request/proposal, User B creates a different request/proposal, and verify that User B cannot call `ReleaseSideChainCreation()` with User A's proposal ID (should fail with "Proposal does not belong to sender" error).

### Proof of Concept

**Initial State**:
- Alice and Bob both have sufficient token allowance approved for the CrossChain contract
- Side chain governance controller (Parliament) is properly configured

**Transaction Sequence**:

1. **Alice creates her request**:
   - Alice calls `RequestSideChainCreation(requestA)` where requestA includes token symbol "ALICE_TOKEN"
   - Stores: `State.ProposedSideChainCreationRequestState[Alice] = {request: requestA, proposer: Alice}`
   - Creates ProposalA in governance contract

2. **Bob creates his request**:
   - Bob calls `RequestSideChainCreation(requestB)` where requestB includes token symbol "BOB_TOKEN"  
   - Stores: `State.ProposedSideChainCreationRequestState[Bob] = {request: requestB, proposer: Bob}`
   - Creates ProposalB in governance contract

3. **ProposalA gets approved** (by parliament miners voting)

4. **Bob exploits the vulnerability**:
   - Bob calls `ReleaseSideChainCreation(ProposalA)` with Alice's proposal ID
   - Function retrieves Bob's request from `State.ProposedSideChainCreationRequestState[Bob]`
   - Creates "BOB_TOKEN" with Bob as issuer
   - Releases ProposalA which executes `CreateSideChain(requestA, Alice)`
   - Alice's side chain is created, but Bob got his token created

**Expected Result**: Alice should get both her token "ALICE_TOKEN" and her side chain created atomically from ProposalA.

**Actual Result**: Bob gets "BOB_TOKEN" created for himself, and Alice gets only her side chain created (no token). Bob has hijacked the token creation benefit from Alice's approved proposal.

**Success Condition**: Transaction succeeds, `TokenCreated` event shows "BOB_TOKEN" with Bob as issuer, `SideChainCreatedEvent` shows Alice's chain created, proving the mismatch.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L93-94)
```csharp
        var sideChainCreationRequestState = ProposeNewSideChain(input, Context.Sender);
        State.ProposedSideChainCreationRequestState[Context.Sender] = sideChainCreationRequestState;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L100-101)
```csharp
        var sideChainCreationRequest = State.ProposedSideChainCreationRequestState[Context.Sender];
        Assert(sideChainCreationRequest != null, "Release side chain creation failed.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L106-110)
```csharp
            CreateSideChainToken(sideChainCreationRequest.SideChainCreationRequest, chainId,
                sideChainCreationRequest.Proposer);
            Context.SendInline(State.SideChainLifetimeController.Value.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release),
                input.ProposalId);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L126-127)
```csharp
        var proposedSideChainCreationRequestState = State.ProposedSideChainCreationRequestState[input.Proposer];
        State.ProposedSideChainCreationRequestState.Remove(input.Proposer);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L372-372)
```csharp
                    Params = new CreateSideChainInput { SideChainCreationRequest = request, Proposer = proposer }
```
