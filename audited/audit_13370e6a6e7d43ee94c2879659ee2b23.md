### Title
Governance Bypass via Unvalidated External Contract Call in ChangeSideChainRentalController

### Summary
The `ChangeSideChainRentalController()` function validates organization existence by calling an external contract address provided in the input, without verifying that the contract address is a legitimate governance contract (Parliament, Association, or Referendum). This allows the current controller to bypass organization existence checks by providing a malicious contract that always returns true, enabling them to set any arbitrary address as the new controller and permanently escape multi-signature governance constraints.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** 

The `CheckOrganizationExist()` method makes a cross-contract call to validate organization existence: [2](#0-1) 

The function accepts `authorityInfo.ContractAddress` from user input and calls `ValidateOrganizationExist` on that address without validating that the contract address is one of the legitimate system governance contracts.

**Why Protections Fail:**

1. No whitelist validation exists to ensure `authorityInfo.ContractAddress` is a system contract
2. The codebase demonstrates the correct pattern in other locations: [3](#0-2) 
3. This pattern validates that only system contracts can perform privileged operations, but `CheckOrganizationExist` lacks this validation

**Execution Path:**

1. Current controller calls `ChangeSideChainRentalController` with malicious `AuthorityInfo`
2. Authorization check passes at: [4](#0-3) 
3. `CheckOrganizationExist` calls the attacker-controlled contract address
4. Malicious contract's `ValidateOrganizationExist` returns true unconditionally
5. New controller address is set without being a real governance organization

### Impact Explanation

**Concrete Harm:**

The SideChainRentalController has authority over critical side chain economic parameters:
- `UpdateRental()` - controls rental fees paid by side chains: [5](#0-4) 
- `UpdateRentedResources()` - controls resource allocation for side chains: [6](#0-5) 

**Governance Degradation:**

The legitimate controller is initialized as an Association organization requiring multi-signature approval: [7](#0-6) 

By exploiting this vulnerability, the multi-sig requirement is permanently bypassed, allowing a single address to:
- Manipulate side chain rental economics without oversight
- Extract value through rental parameter manipulation  
- Block or extort side chain operations by setting prohibitive fees
- Make subsequent unilateral changes without governance approval

**Affected Parties:**
- Side chain operators paying rental fees
- Main chain economics through rental revenue manipulation
- Governance system integrity and trust model

### Likelihood Explanation

**Attacker Capabilities:**
- Must be current SideChainRentalController (Association organization)
- Requires multi-sig approval to pass initial malicious proposal
- Needs ability to deploy smart contracts

**Attack Complexity:**
- Deploy malicious contract with `ValidateOrganizationExist` returning true
- Propose controller change with malicious contract address as `ContractAddress`
- Execute proposal once approved

**Feasibility Conditions:**
1. **Partial Key Compromise:** Attackers compromise enough Association members to pass one proposal
2. **Social Engineering:** Disguise proposal as "governance contract upgrade" to legitimate governance structure
3. **Insider Attack:** Malicious insider with signing authority

**Detection Constraints:**
The attack appears as a legitimate governance action on-chain, making detection difficult until malicious rental parameter changes occur.

**Probability Reasoning:**
While requiring initial trusted role participation, the vulnerability enables ESCALATION from temporary influence to permanent control, violating the intended multi-sig security model. Historical blockchain governance compromises demonstrate feasibility of partial key compromise or social engineering attacks.

### Recommendation

**Code-Level Mitigation:**

Add validation that `authorityInfo.ContractAddress` is a legitimate system governance contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    var systemContracts = Context.GetSystemContractNameToAddressMapping().Values;
    Assert(systemContracts.Contains(authorityInfo.ContractAddress), 
        "Authority contract must be a system governance contract");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Checks:**

Optionally, restrict to specific governance contract types:
```csharp
Assert(authorityInfo.ContractAddress == State.ParliamentContract.Value ||
       authorityInfo.ContractAddress == State.AssociationContract.Value ||
       authorityInfo.ContractAddress == State.ReferendumContract.Value,
       "Invalid governance contract address");
```

**Test Cases:**
1. Test rejection when providing non-system contract address
2. Test rejection when providing arbitrary user contract
3. Test acceptance only for legitimate Parliament/Association/Referendum contracts
4. Regression test ensuring all controller change functions validate contract addresses

### Proof of Concept

**Required Initial State:**
- SideChainRentalController is initialized Association organization
- Attacker has sufficient Association member keys to pass one proposal

**Transaction Steps:**

1. **Deploy Malicious Contract:**
```
Contract MaliciousValidator {
    public BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true };  // Always returns true
    }
}
Address maliciousContract = DeployContract(MaliciousValidator);
```

2. **Create Malicious Proposal:**
```
AuthorityInfo maliciousAuthority = new AuthorityInfo {
    ContractAddress = maliciousContract,      // Attacker's contract
    OwnerAddress = attackerEOA                // Any arbitrary address
};

CreateProposal(ChangeSideChainRentalController, maliciousAuthority);
```

3. **Execute Approved Proposal:**
```
ApproveProposal(proposalId);  // Get multi-sig approval
ReleaseProposal(proposalId);  // Execute
```

**Expected vs Actual Result:**
- **Expected:** Proposal should fail because `maliciousContract` is not a legitimate governance contract
- **Actual:** Proposal succeeds, `attackerEOA` becomes controller with unilateral authority

**Success Condition:**
After execution, `State.SideChainRentalController.Value.OwnerAddress == attackerEOA` and the attacker can call `UpdateRental()` and `UpdateRentedResources()` without any multi-sig approval.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L53-59)
```csharp
    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L244-268)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetControllerCreateInputForSideChainRental(
        Address sideChainCreator, Address parliamentAddress)
    {
        var proposers = new List<Address> { parliamentAddress, sideChainCreator };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L98-99)
```csharp
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```
