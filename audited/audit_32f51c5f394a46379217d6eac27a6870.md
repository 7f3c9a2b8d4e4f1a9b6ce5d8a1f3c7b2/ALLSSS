### Title
Sponsor Can Terminate Voting Prematurely by Exhausting All Snapshots Before StartTimestamp

### Summary
The `TakeSnapshot()` function lacks timestamp validation, allowing the sponsor to immediately exhaust all snapshots after registration, even before `StartTimestamp` is reached. This effectively prevents all voting activity regardless of the configured `EndTimestamp`, causing a complete denial of service on the voting item.

### Finding Description

The vulnerability exists in the `TakeSnapshot()` function where the sponsor can terminate voting prematurely: [1](#0-0) 

The function only validates:
1. Sponsor authorization (line 245)
2. Snapshot count limit: `CurrentSnapshotNumber - 1 < TotalSnapshotNumber` (lines 247-248)
3. Snapshot number sequence (lines 256-257)

**Root Cause**: No timestamp validation exists. The function never checks if `Context.CurrentBlockTime` is within the voting period defined by `StartTimestamp` and `EndTimestamp`.

When a voting item is registered, it initializes with `CurrentSnapshotNumber = 1`: [2](#0-1) 

Each call to `TakeSnapshot()` increments `CurrentSnapshotNumber` (line 259). Once `CurrentSnapshotNumber > TotalSnapshotNumber`, the vote validation rejects all voting attempts: [3](#0-2) 

The check at lines 382-383 prevents voting when snapshots are exhausted, even if the current time is within `[StartTimestamp, EndTimestamp]`.

### Impact Explanation

**Concrete Impact**: Complete denial of service on voting functionality. Once the sponsor exhausts all snapshots:
- No participant can cast votes, despite the voting period being active
- The `EndTimestamp` becomes meaningless
- All voting attempts fail with "Current voting item already ended"
- Locked tokens cannot be used for their intended voting purpose

**Affected Parties**: All potential voters who expect to participate during the advertised voting window.

**Severity Justification**: HIGH - This completely defeats the purpose of time-bound voting. The sponsor can unilaterally terminate voting at registration time, making the entire voting mechanism unusable regardless of the configured time window.

### Likelihood Explanation

**Attacker Capabilities**: The sponsor (voting item creator) is the only required role - this is a feature abuse, not a privilege escalation.

**Attack Complexity**: Trivial. The sponsor simply calls `TakeSnapshot()` repeatedly immediately after calling `Register()`.

**Execution Steps**:
1. Sponsor calls `Register()` with `TotalSnapshotNumber = N`, `StartTimestamp = T1`, `EndTimestamp = T2`
2. Sponsor immediately calls `TakeSnapshot()` N times
3. `CurrentSnapshotNumber` becomes N+1
4. All subsequent `Vote()` calls fail

**Feasibility**: The attack requires only N transaction calls in sequence, with no time delays or complex preconditions. Test evidence confirms this is fully functional: [4](#0-3) [5](#0-4) 

**Probability**: VERY HIGH - No technical barriers exist, and the sponsor may do this intentionally or accidentally.

### Recommendation

**Code-Level Mitigation**: Add timestamp validation to `TakeSnapshot()`:

```csharp
public override Empty TakeSnapshot(TakeSnapshotInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");
    
    // Add timestamp validation
    Assert(Context.CurrentBlockTime >= votingItem.StartTimestamp, 
        "Cannot take snapshot before voting starts.");
    Assert(Context.CurrentBlockTime <= votingItem.EndTimestamp, 
        "Cannot take snapshot after voting ends.");
    
    Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
        "Current voting item already ended.");
    // ... rest of function
}
```

**Additional Invariants**:
1. Enforce minimum time duration between consecutive snapshots
2. Consider requiring snapshots to be taken at specific intervals based on `(EndTimestamp - StartTimestamp) / TotalSnapshotNumber`

**Regression Prevention**: Add test case verifying that `TakeSnapshot()` fails when called before `StartTimestamp` or after `EndTimestamp`.

### Proof of Concept

**Initial State**:
- Current block time: Block 100
- Sponsor has sufficient balance

**Attack Sequence**:
1. Sponsor calls `Register()`:
   - `TotalSnapshotNumber = 3`
   - `StartTimestamp = Block 1000` (future)
   - `EndTimestamp = Block 5000`
   - Result: `CurrentSnapshotNumber = 1`

2. Sponsor immediately calls `TakeSnapshot(snapshotNumber=1)`:
   - Check: `1 - 1 < 3` ✓ (passes)
   - Result: `CurrentSnapshotNumber = 2`

3. Sponsor calls `TakeSnapshot(snapshotNumber=2)`:
   - Check: `2 - 1 < 3` ✓ (passes)
   - Result: `CurrentSnapshotNumber = 3`

4. Sponsor calls `TakeSnapshot(snapshotNumber=3)`:
   - Check: `3 - 1 < 3` ✓ (passes)
   - Result: `CurrentSnapshotNumber = 4`

5. Voter attempts to `Vote()` at Block 1000 (within valid time window):
   - Check: `4 <= 3` ✗ (fails)
   - Error: "Current voting item already ended"

**Expected vs Actual**:
- **Expected**: Voting should be possible during `[Block 1000, Block 5000]`
- **Actual**: Voting is impossible at any time because all snapshots were exhausted at Block 100

**Success Condition**: The attack succeeds when `CurrentSnapshotNumber > TotalSnapshotNumber` while `Context.CurrentBlockTime < StartTimestamp`, preventing all future voting.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L36-54)
```csharp
        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L241-273)
```csharp
    public override Empty TakeSnapshot(TakeSnapshotInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);

        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can take snapshot.");

        Assert(votingItem.CurrentSnapshotNumber - 1 < votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");

        // Update previous voting going information.
        var previousVotingResultHash = GetVotingResultHash(input.VotingItemId, votingItem.CurrentSnapshotNumber);
        var previousVotingResult = State.VotingResults[previousVotingResultHash];
        previousVotingResult.SnapshotEndTimestamp = Context.CurrentBlockTime;
        State.VotingResults[previousVotingResultHash] = previousVotingResult;

        Assert(votingItem.CurrentSnapshotNumber == input.SnapshotNumber,
            $"Can only take snapshot of current snapshot number: {votingItem.CurrentSnapshotNumber}, but {input.SnapshotNumber}");
        var nextSnapshotNumber = input.SnapshotNumber.Add(1);
        votingItem.CurrentSnapshotNumber = nextSnapshotNumber;
        State.VotingItems[votingItem.VotingItemId] = votingItem;

        // Initial next voting going information.
        var currentVotingGoingHash = GetVotingResultHash(input.VotingItemId, nextSnapshotNumber);
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/SnapshotTests.cs (L78-101)
```csharp
    public async Task VoteContract_TakeSnapshot_Success_Test()
    {
        var registerItem = await RegisterVotingItemAsync(10, 4, true, DefaultSender, 3);
        for (var i = 0; i < 3; i++)
        {
            var transactionResult = (await VoteContractStub.TakeSnapshot.SendAsync(
                new TakeSnapshotInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    SnapshotNumber = i + 1
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.CurrentSnapshotNumber.ShouldBe(i + 2);
            var voteResult = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
            {
                VotingItemId = registerItem.VotingItemId,
                SnapshotNumber = i + 2
            });
            voteResult.SnapshotNumber.ShouldBe(i + 2);
        }
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L92-102)
```csharp
        //voting item have been out of date
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            await TakeSnapshot(registerItem.VotingItemId, 1);

            var voter = Accounts[11].KeyPair;
            var voteResult =
                await VoteWithException(voter, registerItem.VotingItemId, registerItem.Options[0], 100);
            voteResult.Status.ShouldBe(TransactionResultStatus.Failed);
            voteResult.Error.Contains("Current voting item already ended").ShouldBeTrue();
        }
```
