### Title
Permanent Token Lock When CandidateSponsorMap Is Null and Candidate Key Is Lost

### Summary
When a candidate announces election via `AnnounceElection` (not `AnnounceElectionFor`), the `CandidateSponsorMap` is never set. If the candidate subsequently loses their private key, the locked deposit of 100,000 tokens becomes permanently inaccessible, as `QuitElection` transfers tokens to the candidate's address by default, and no mechanism exists to redirect the funds to a recoverable address.

### Finding Description
The vulnerability exists in the token recovery mechanism across two announcement flows:

**Root Cause:** [1](#0-0) 

In `AnnounceElection`, tokens are locked from the sender but `CandidateSponsorMap` is never set (remains null). This contrasts with: [2](#0-1) 

Where `AnnounceElectionFor` explicitly sets `State.CandidateSponsorMap[input.Pubkey] = Context.Sender`.

**Failed Recovery Path:** [3](#0-2) 

In `QuitElection`, tokens are transferred to `State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes)`. When `CandidateSponsorMap` is null, the fallback destination is the candidate's own address.

**Insufficient Admin Recovery:** [4](#0-3) 

While Parliament can change the admin via `SetCandidateAdmin` to enable a new admin to call `QuitElection`: [5](#0-4) 

This authorization bypass doesn't help because the token destination is hardcoded based on `CandidateSponsorMap`.

**Virtual Address Cannot Self-Transfer:** [6](#0-5) 

The virtual address holding the tokens cannot directly transfer them via `TransferFrom` as it requires prior allowance approval, which virtual addresses (being computed addresses without private keys) cannot grant.

**No Setter Mechanism:**
There is no method to set or update `CandidateSponsorMap` after announcement - it's only assigned in `AnnounceElectionFor` and transferred during pubkey replacement.

### Impact Explanation
**Quantified Loss:** [7](#0-6) 

Each affected candidate loses 100,000 tokens (100_000_00000000 with 8 decimals) permanently.

**Who Is Affected:**
- Candidates who announced via `AnnounceElection` (self-sponsored or setting admin to their own address)
- Lost access to the address corresponding to their candidate public key
- Cannot recover their election deposit despite admin changeover capabilities

**Protocol Impact:**
- Violates token supply invariants as tokens become permanently inaccessible in virtual addresses
- Creates operational risk for candidates using the legitimate `AnnounceElection` method
- No recovery path exists even with governance intervention

**Severity Justification:**
Medium severity due to permanent fund loss (100,000 tokens per candidate) combined with realistic preconditions that don't require malicious behavior.

### Likelihood Explanation
**Realistic Preconditions:**
1. Using `AnnounceElection` is a documented, public method - candidates may choose it over `AnnounceElectionFor`
2. Private key loss is a well-known occurrence in blockchain systems (hardware failure, operational errors, security breaches)
3. Candidates often set their own address as admin initially when calling `AnnounceElection`

**Attack Complexity:**
This is not an exploit but an operational failure scenario. No attacker action is required - the conditions naturally occur through:
- Normal contract usage (choosing `AnnounceElection` over `AnnounceElectionFor`)
- Unfortunate but common key management failures

**Feasibility:**
- Entry point: Public `AnnounceElection` method
- Execution: No special privileges needed to trigger the vulnerable state
- Detection: The issue only manifests when key loss occurs and recovery is attempted

**Probability:**
Medium likelihood as it requires both conditions (using `AnnounceElection` without sponsor AND key loss), but both are realistic operational scenarios.

### Recommendation
**Immediate Mitigation:**
Add a governance-controlled recovery mechanism. Option 1 (Recommended):

Add a new method callable only by Parliament:
```csharp
public override Empty SetCandidateSponsor(SetCandidateSponsorInput input)
{
    Assert(Context.Sender == GetParliamentDefaultAddress(), "No permission.");
    Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey), "Not a valid candidate.");
    State.CandidateSponsorMap[input.Pubkey] = input.SponsorAddress;
    return new Empty();
}
```

This allows Parliament to designate a recovery address for candidates who lost their keys.

**Alternative Mitigation:**
Modify `AnnounceElection` to always set the sponsor: [8](#0-7) 

Add after `LockCandidateNativeToken()`:
```csharp
State.CandidateSponsorMap[pubkey] = Context.Sender;
```

**Invariant Check:**
Add assertion that sponsor can be resolved:
```csharp
Assert(State.CandidateSponsorMap[input.Value] != null || 
       CanAccessAddress(Address.FromPublicKey(pubkeyBytes)), 
       "Token recovery destination is inaccessible.");
```

**Test Cases:**
1. Test `AnnounceElection` followed by admin change and `QuitElection` with sponsor recovery
2. Test Parliament-initiated sponsor address update
3. Verify tokens go to designated sponsor, not candidate address

### Proof of Concept
**Initial State:**
- Candidate has ≥100,000 tokens with 8 decimals
- Candidate's public key: `candidatePubkey`
- Candidate's address: `candidateAddress = Address.FromPublicKey(candidatePubkey)`

**Step 1:** Candidate announces election (self-admin)
```
Tx from candidateAddress: AnnounceElection(adminAddress = candidateAddress)
→ Tokens locked from candidateAddress to virtual address
→ State.CandidateSponsorMap[candidatePubkey] = null (not set)
→ State.CandidateAdmins[candidatePubkey] = candidateAddress
```

**Step 2:** Candidate loses private key
```
candidateAddress private key is lost/inaccessible
```

**Step 3:** Parliament intervenes to enable recovery
```
Tx from Parliament: SetCandidateAdmin(candidatePubkey, newAdminAddress)
→ State.CandidateAdmins[candidatePubkey] = newAdminAddress
```

**Step 4:** New admin attempts to recover tokens
```
Tx from newAdminAddress: QuitElection(candidatePubkey)
→ Executes line 245: Transfer to State.CandidateSponsorMap[candidatePubkey] ?? Address.FromPublicKey(candidatePubkey)
→ Since CandidateSponsorMap[candidatePubkey] == null, tokens go to candidateAddress
```

**Expected Result:**
Tokens should be recoverable to an accessible address (e.g., newAdminAddress or a designated recovery address).

**Actual Result:**
Tokens are transferred to `candidateAddress`, which has a lost private key. The 100,000 tokens remain permanently inaccessible in the virtual address path, as no mechanism exists to authorize alternative transfers.

**Success Condition for Exploit:**
Tokens become permanently locked when:
- `State.CandidateSponsorMap[candidatePubkey]` is null (verified via GetSponsor query)
- Private key for `candidateAddress` is lost
- `QuitElection` transfers to inaccessible address

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L27-40)
```csharp
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L140-140)
```csharp
        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L236-236)
```csharp
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L74-89)
```csharp
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```
