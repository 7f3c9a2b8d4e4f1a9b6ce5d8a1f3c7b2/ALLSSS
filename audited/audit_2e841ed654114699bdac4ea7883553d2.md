### Title
Missing Cryptographic Verification Allows Miners to Manipulate Mining Order by Copying Consensus Values

### Summary
The `NewConsensusInformationFilled` validation function only checks that `OutValue` and `Signature` exist and are non-empty, but performs no cryptographic verification that these values were actually generated by the sender. [1](#0-0)  A legitimate miner can copy another miner's `OutValue` and `Signature` from a previous round and submit them in their own `ProvidedRound` entry, allowing them to manipulate their mining order in the next round.

### Finding Description

The consensus validation system has a critical flaw in how it validates `OutValue` and `Signature` values submitted by miners during `UpdateValue` behavior.

**Root Cause:**
The `NewConsensusInformationFilled` method only verifies that values are present and non-empty, without any cryptographic binding to the sender: [1](#0-0) 

The `ValidatePreviousInValue` method only validates the consistency of the sender's previous round values, not the current `OutValue`/`Signature`: [2](#0-1) 

**Why Protections Fail:**
1. No validation provider uses cryptographic verification (`RecoverPublicKey` or `VerifySignature`) to verify `OutValue`/`Signature` authenticity
2. The "signature" in AEDPoS is a hash value computed via XOR operations, not a cryptographic signature bound to the miner's private key: [3](#0-2) 
3. `ProvidedRound` comes from block header extra data controlled by the block producer: [4](#0-3) 
4. The `AEDPoSExtraDataExtractor` only verifies that `SenderPubkey` matches the block signer, but doesn't verify the `OutValue`/`Signature` values: [5](#0-4) 

**Execution Path:**
1. Attacker (legitimate miner) produces a block
2. Instead of using correct `OutValue`/`Signature`, they craft malicious block header with copied values from another miner's previous round
3. Validation passes through `ValidateBeforeExecution`: [6](#0-5) 
4. Transaction is generated extracting the copied values: [7](#0-6) 
5. `ProcessUpdateValue` stores the copied values directly to state: [8](#0-7) 
6. The copied `Signature` is used to calculate mining order for next round: [9](#0-8) 

### Impact Explanation

**Consensus Integrity Breach:**
- Miners can manipulate their position in the next round's mining schedule by selecting favorable `Signature` values
- The mining order calculation `GetAbsModulus(sigNum, minersCount) + 1` becomes controllable rather than random: [10](#0-9) 

**Economic Impact:**
- Attackers can position themselves for more frequent block production
- Leads to unfair distribution of block rewards and mining revenue
- Violates the fairness guarantees of the AEDPoS consensus mechanism

**Affected Parties:**
- Honest miners receive fewer mining opportunities and reduced rewards
- The entire network suffers from compromised consensus randomness
- Long-term trust in the consensus mechanism is undermined

**Severity Justification: Critical**
- Breaks a fundamental consensus invariant (mining schedule integrity)
- Exploitable by any authorized miner
- Direct economic impact through reward misallocation
- No recovery mechanism once invalid values are committed to state

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner (present in `BaseRound.RealTimeMinersInformation`)
- Requires ability to produce blocks and control block header contents
- Needs access to historical on-chain data to observe other miners' `OutValue`/`Signature` values

**Attack Complexity: Low**
- No special privileges beyond being a miner
- Simple modification of block header data structure
- No complex cryptographic operations required
- Can be automated once understood

**Feasibility Conditions:**
- Mining permission check passes because attacker is legitimate miner: [11](#0-10) 
- `RecoverFromUpdateValue` succeeds because attacker's pubkey exists in both rounds: [12](#0-11) 
- All validations pass due to lack of cryptographic verification

**Detection Constraints:**
- Hard to detect without comparing expected vs actual values
- Invalid values are indistinguishable from valid ones at the protocol level
- No automated detection mechanism exists

**Probability: High**
- Any of the authorized miners can exploit this
- Economic incentive is clear (more mining rewards)
- Low technical barrier to execution
- No penalties for attempting

### Recommendation

**Immediate Fix:**
Add cryptographic verification to `UpdateValueValidationProvider` to ensure `OutValue` and `Signature` are correctly derived from the sender's secret `InValue`:

```
In UpdateValueValidationProvider.NewConsensusInformationFilled:
1. Add verification that OutValue = Hash(some InValue known to sender)
2. Add verification that Signature was computed correctly using CalculateSignature
3. Implement a commitment-reveal scheme where miners commit to InValue before revealing
```

**Invariant Checks:**
1. Verify `Signature` matches `CalculateSignature(InValue)` from previous round
2. Ensure `OutValue` corresponds to a valid `InValue` that hashes to previous round's `OutValue`
3. Implement cryptographic binding between `OutValue`/`Signature` and miner's identity

**Additional Mitigations:**
1. Add monitoring to detect anomalous mining order patterns
2. Implement slashing mechanism for miners submitting invalid consensus data
3. Consider using VRF (Verifiable Random Function) for signature generation to ensure unpredictability and verifiability

**Test Cases:**
1. Test that copied `OutValue`/`Signature` values are rejected
2. Test that mining order manipulation is detected
3. Test consensus continues functioning correctly with enhanced validation
4. Regression test ensuring legitimate miners can still produce blocks normally

### Proof of Concept

**Initial State:**
- Miner A and Miner B are both authorized miners in current round N
- Miner A has produced blocks with `OutValue_A` and `Signature_A` in round N-1
- Miner B is scheduled to produce block in round N

**Attack Steps:**
1. Miner B observes Miner A's values from previous round: `OutValue_A = 0x123...`, `Signature_A = 0xabc...`
2. Miner B calculates that `GetAbsModulus(Signature_A.ToInt64(), minersCount)` gives favorable position 1
3. Miner B produces block N with malicious header:
   - `SenderPubkey = B's pubkey` (valid)
   - `ProvidedRound.RealTimeMinersInformation[B].OutValue = OutValue_A` (copied)
   - `ProvidedRound.RealTimeMinersInformation[B].Signature = Signature_A` (copied)
   - `ProvidedRound.RealTimeMinersInformation[B].PreviousInValue = Hash.Empty` (validation allows)
4. Block passes all validations (no cryptographic check)
5. `ProcessUpdateValue` commits copied values to state
6. Round N+1 generation uses `Signature_A` for Miner B's order calculation
7. Miner B is assigned position 1 in next round (favorable position stolen from Miner A's signature)

**Expected vs Actual Result:**
- Expected: Miner B's order determined by their own legitimate signature
- Actual: Miner B's order determined by copied signature, allowing position manipulation

**Success Condition:**
- Miner B's `FinalOrderOfNextRound` in round N+1 equals `GetAbsModulus(Signature_A.ToInt64(), minersCount) + 1` instead of their legitimate order, proving successful manipulation of mining schedule.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L21-33)
```csharp
    public ByteString ExtractConsensusExtraData(BlockHeader header)
    {
        var consensusExtraData =
            _blockExtraDataService.GetExtraDataFromBlockHeader(_consensusExtraDataProvider.BlockHeaderExtraDataKey,
                header);
        if (consensusExtraData == null)
            return null;

        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L137-147)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                Context.LogDebug(() =>
                    $"Previous in value in extra data:{round.RealTimeMinersInformation[pubkey.ToHex()].PreviousInValue}");
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-22)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-20)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```
