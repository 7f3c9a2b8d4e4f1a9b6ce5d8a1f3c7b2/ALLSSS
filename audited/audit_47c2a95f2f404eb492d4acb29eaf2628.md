### Title
Missing Individual Miner Order Validation Allows Consensus-Breaking Order Manipulation via TuneOrderInformation

### Summary
The `NextRoundMiningOrderValidationProvider` only validates aggregate counts of miner orders but fails to validate individual `FinalOrderOfNextRound` assignments for uniqueness, valid range, or proper assignment. Malicious miners can exploit user-provided `TuneOrderInformation` in `UpdateValueInput` to set duplicate or out-of-range orders, which are applied without validation, causing non-deterministic round generation and consensus failure.

### Finding Description

**Root Cause Location:**

The validation in `ValidateHeaderInformation()` only checks that the count of miners with `FinalOrderOfNextRound > 0` equals the count of miners who mined, without validating individual order values: [1](#0-0) 

The `Distinct()` call operates on `MinerInRound` objects (which are already distinct as dictionary values), not on the `FinalOrderOfNextRound` values themselves. This validation misses:
- Duplicate `FinalOrderOfNextRound` values across different miners
- Out-of-range orders (e.g., 0, negative, or > minersCount)
- Orders assigned to miners who didn't mine
- Non-continuous order sequences

**Exploitation Vector:**

User-provided `TuneOrderInformation` in `UpdateValueInput` is applied directly without validation in `ProcessUpdateValue`: [2](#0-1) 

The `UpdateValue` method accepts `UpdateValueInput` directly from users, including the `tune_order_information` field defined as `map<string, int32>`: [3](#0-2) [4](#0-3) 

**Why Existing Protections Fail:**

During `UpdateValue` behavior validation, `NextRoundMiningOrderValidationProvider` is NOT invoked - it only runs for `NextRound` behavior: [5](#0-4) 

This allows malicious order assignments to be persisted to state, which are then used during next round generation without proper validation.

**Impact Chain:**

When `GenerateNextRoundInformation` is called during round transition, it orders miners by their `FinalOrderOfNextRound`: [6](#0-5) 

If duplicate `FinalOrderOfNextRound` values exist, `OrderBy` produces non-deterministic ordering (the relative order of items with equal keys is undefined in LINQ), causing different nodes to generate different next rounds.

The conflict resolution in `ApplyNormalConsensusData` handles conflicts during initial order calculation but cannot prevent malicious manipulation via `TuneOrderInformation`: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation:**
- Duplicate or invalid `FinalOrderOfNextRound` values cause non-deterministic round generation
- Different nodes execute `OrderBy` with duplicate keys and may produce different orderings
- This leads to divergent `nextRound` state across the network
- Blockchain halts or forks as nodes cannot reach consensus on the next round structure

**Miner Order Manipulation:**
- Malicious miners can manipulate which miners get earlier/later time slots in next round
- Can influence who becomes the extra block producer (calculated based on round ordering)
- Time slot manipulation affects mining rewards and block production privileges

**Severity: HIGH**
- Breaks fundamental consensus determinism invariant
- Reachable by any authorized miner without special privileges
- Direct path to consensus failure and potential chain halt
- No recovery mechanism without manual intervention

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner in the current round (realistic - miners are expected participants)
- Requires ability to produce blocks and call `UpdateValue` (normal miner operation)
- No additional privileges or compromise of other parties needed

**Attack Complexity: LOW**
- Single transaction to `UpdateValue` with malicious `TuneOrderInformation`
- Can set `{"MinerB": 2, "MinerC": 2}` to create duplicate orders
- Or set out-of-range values like `{"MinerB": 0}` or `{"MinerB": 999}`
- No complex timing or coordination required

**Feasibility: HIGH**
- `UpdateValue` is a standard consensus method called by miners after producing blocks
- `UpdateValueInput` is user-provided, not contract-generated
- No validation blocks malicious `TuneOrderInformation` values
- Effect persists in state until `NextRound` is triggered

**Detection Difficulty:**
- Attack is subtle - corrupted orders look like normal consensus data
- No immediate failure until `NextRound` is executed
- Validation only checks aggregate counts, missing the actual corruption
- Different nodes may silently diverge without obvious error messages

**Economic Rationality:**
- Cost: Standard transaction fee for `UpdateValue` call
- Benefit: Can manipulate mining schedule, potentially gain extra block producer role, or cause chain disruption for competitive advantage
- Risk/reward highly favorable for malicious actors

### Recommendation

**Immediate Fix - Add Individual Order Validation:**

Modify `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` to validate individual orders:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    var minersCount = providedRound.RealTimeMinersInformation.Count;
    
    // Get miners who mined
    var minedMiners = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.OutValue != null).ToList();
    
    // Validate count (existing check)
    var minersWithOrders = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0).ToList();
    if (minersWithOrders.Count != minedMiners.Count)
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound count.";
        return validationResult;
    }
    
    // NEW: Validate individual orders
    var orderValues = minedMiners.Select(m => m.FinalOrderOfNextRound).ToList();
    
    // Check for duplicates
    if (orderValues.Count != orderValues.Distinct().Count())
    {
        validationResult.Message = "Duplicate FinalOrderOfNextRound values detected.";
        return validationResult;
    }
    
    // Check valid range [1, minersCount]
    if (orderValues.Any(order => order < 1 || order > minersCount))
    {
        validationResult.Message = "FinalOrderOfNextRound out of valid range.";
        return validationResult;
    }
    
    // Check orders only assigned to miners who mined
    var minersWithOrdersNotMined = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0 && m.OutValue == null).ToList();
    if (minersWithOrdersNotMined.Any())
    {
        validationResult.Message = "FinalOrderOfNextRound assigned to miner who didn't mine.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Additional Validation in ProcessUpdateValue:**

Add validation when applying `TuneOrderInformation` to reject invalid orders immediately:

```csharp
// Before applying tune orders, validate them
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate miner exists
    Assert(currentRound.RealTimeMinersInformation.ContainsKey(tuneOrder.Key),
        $"Invalid miner pubkey in TuneOrderInformation: {tuneOrder.Key}");
    
    // Validate order range
    Assert(tuneOrder.Value >= 1 && tuneOrder.Value <= minersCount,
        $"Order {tuneOrder.Value} out of valid range [1, {minersCount}]");
    
    // Apply the order
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}

// After applying all orders, check for duplicates
var finalOrders = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.OutValue != null)
    .Select(m => m.FinalOrderOfNextRound)
    .ToList();
Assert(finalOrders.Count == finalOrders.Distinct().Count(),
    "Duplicate FinalOrderOfNextRound values after tuning");
```

**Test Cases:**
1. Test duplicate order assignment rejection
2. Test out-of-range order assignment rejection  
3. Test order assignment to non-mining miner rejection
4. Test legitimate order conflict resolution
5. Test deterministic round generation with valid orders

### Proof of Concept

**Initial State:**
- 5 miners in network: A, B, C, D, E
- Current round N in progress
- Miners A, B, C successfully mine blocks (have `OutValue` set)
- Miners D, E fail to mine (no `OutValue`)
- Normal expected next round orders would be: A=1, B=2, C=3

**Attack Steps:**

1. **MinerA produces block and calls UpdateValue with malicious input:**
```
UpdateValueInput {
    out_value: [MinerA's legitimate out_value]
    signature: [MinerA's legitimate signature]
    round_id: [current round id]
    // MALICIOUS PAYLOAD:
    tune_order_information: {
        "MinerB_pubkey": 2,
        "MinerC_pubkey": 2  // Duplicate order!
    }
    [... other legitimate fields ...]
}
```

2. **Validation During UpdateValue Block:**
    - `ValidateBeforeExecution` runs with `AElfConsensusBehaviour.UpdateValue`
    - Only basic validators run (MiningPermission, TimeSlot, ContinuousBlocks, UpdateValue, LibInformation)
    - `NextRoundMiningOrderValidationProvider` NOT invoked
    - ✓ Validation passes

3. **ProcessUpdateValue Execution:**
    - Line 259-260 applies `TuneOrderInformation` without validation
    - State now corrupted:
  - `MinerA.FinalOrderOfNextRound = 1`
  - `MinerB.FinalOrderOfNextRound = 2`
  - `MinerC.FinalOrderOfNextRound = 2` (DUPLICATE!)

4. **NextRound Triggered (later block):**
    - Some miner calls `NextRound` to transition rounds
    - `ValidateBeforeExecution` runs with `AElfConsensusBehaviour.NextRound`
    - `NextRoundMiningOrderValidationProvider` validates:
  - `distinctCount = 3` (counting distinct MinerInRound objects A, B, C)
  - `minedCount = 3` (A, B, C have OutValue)
  - Check: `3 == 3` ✓ PASSES (incorrectly!)

5. **GenerateNextRoundInformation Execution:**
    - Line 26: `minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound)`
    - Ordering: MinerA(1), MinerB(2), MinerC(2)
    - **CRITICAL ISSUE:** `OrderBy` with duplicate keys is non-deterministic
    - Node 1 might order as: [A(1), B(2), C(2)] → assigns B=order:1, C=order:2
    - Node 2 might order as: [A(1), C(2), B(2)] → assigns C=order:1, B=order:2

**Result:**
- **Expected:** Deterministic next round generation across all nodes
- **Actual:** Different nodes generate different `nextRound` structures
- **Consequence:** Consensus breaks, nodes cannot agree on next round, chain halts or forks

**Success Condition:**
Attack succeeds if different nodes produce different next round structures with different miner order assignments, causing consensus failure and requiring manual intervention to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-101)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-88)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```
