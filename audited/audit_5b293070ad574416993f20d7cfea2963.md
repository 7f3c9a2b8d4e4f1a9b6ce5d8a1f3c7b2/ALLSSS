# Audit Report

## Title
Banned Miners Can Remain in Consensus When All Initial Miner Backups Are Unavailable

## Summary
The miner replacement mechanism fails to remove all banned miners when insufficient alternative candidates are available, allowing known malicious nodes to continue participating in consensus and earning rewards until the next term transition.

## Finding Description

The vulnerability exists in the interaction between the Election contract's `GetMinerReplacementInformation()` method and the Consensus contract's replacement execution logic.

When the Election contract identifies banned miners that need replacement, it attempts to find alternative candidates in two stages. First, it searches the previous term's election snapshot for valid candidates. [1](#0-0)  Second, if insufficient candidates are found, it attempts to use initial miners as backups, but explicitly filters out banned initial miners. [2](#0-1) 

The critical issue occurs when all available initial miners are either (1) already banned via `State.BannedPubkeyMap[k]` or (2) already serving as current miners. In this scenario, the `selectedInitialMiners` collection becomes empty or insufficient, resulting in `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`.

The Consensus contract's replacement loop only iterates up to `AlternativeCandidatePubkeys.Count`, meaning it can only replace as many evil miners as there are alternatives available. [3](#0-2)  Banned miners are only removed from `currentRound.RealTimeMinersInformation` when a replacement occurs. [4](#0-3)  Therefore, unreplaced banned miners persist in the active miner set.

The mining permission validation during block production only verifies that a miner's public key exists in `RealTimeMinersInformation.Keys` and does not check the `BannedPubkeyMap`. [5](#0-4)  Similarly, the `PreCheck()` method in consensus information processing only validates miner list membership without checking banned status. [6](#0-5) 

Miners are marked as banned through the `UpdateCandidateInformation` method when `IsEvilNode` is true, which sets `State.BannedPubkeyMap[input.Pubkey] = true`. [7](#0-6)  The evil miner detection logic identifies banned miners as those where `State.BannedPubkeyMap[p]` returns true. [8](#0-7) 

## Impact Explanation

This vulnerability has HIGH severity impact because it allows known malicious nodes to maintain active consensus participation after being explicitly banned by the protocol:

**Consensus Integrity Violation**: The core security invariant that banned miners are removed from active participation is violated. Nodes that have been detected as malicious (through consensus monitoring or governance action) can continue producing blocks and participating in consensus decisions.

**Permanent State Degradation**: Once this condition is reached, the system cannot self-heal within the current term. Banned miners remain active for the entire term duration until a new election cycle provides sufficient candidates. In production networks with term lengths of days or weeks, this represents extended exposure to known malicious actors.

**Economic Impact**: Banned miners continue earning block production rewards and consensus participation incentives despite being identified as bad actors. This undermines the economic security model that relies on removing misbehaving nodes from reward distributions.

**Attack Surface Expansion**: Malicious nodes that have already been detected maintain their ability to potentially coordinate further attacks, knowing they cannot be removed until the next term. This creates a window where the security assumption that "banned = removed" is false.

## Likelihood Explanation

The likelihood is MEDIUM to HIGH because this condition can emerge naturally from normal network operations without requiring any malicious action:

**Feasible Preconditions**:
1. Networks typically start with small initial miner sets (5-21 miners is common for production blockchains)
2. Active governance operations that ban multiple malicious miners over time are expected and desirable
3. Low election candidate participation is common during early network stages or market downturns
4. The condition becomes more likely as the network actively enforces security policies

**No Attack Required**: This is not an exploit that requires attacker action. It naturally emerges when legitimate security mechanisms (banning malicious miners) interact with network participation dynamics (low candidate availability).

**Real-World Scenario**: Consider a network with 7 initial miners A-G. If miners A, B, C are progressively banned for malicious behavior, and the current active set is D, E, F, G (the remaining initial miners), then when miner D exhibits malicious behavior, no unbanned alternatives exist. The system must choose between keeping a known bad actor or losing consensus capacity.

**Probability Factors**:
- Small initial miner sets (< 10): HIGH probability
- Active security enforcement: INCREASES probability  
- Low election participation periods: INCREASES probability
- Long-running networks that have banned multiple initial miners: HIGH probability

## Recommendation

Implement a banned status check in the mining permission validation to prevent banned miners from producing blocks:

**Fix 1 - Add Banned Status Check to Mining Permission Validation**:
```csharp
// In MiningPermissionValidationProvider.cs
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    
    if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
        return validationResult;
    }
    
    // Add banned status check
    if (State.ElectionContract.GetCandidateInformation.Call(new StringValue { Value = validationContext.SenderPubkey })?.IsBanned == true)
    {
        validationResult.Message = $"Sender {validationContext.SenderPubkey} is banned.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Fix 2 - Force Removal of Unreplaced Evil Miners**:
```csharp
// In GenerateNextRoundInformation() after the replacement loop
// Remove all remaining evil miners even if no alternatives exist
for (var i = minerReplacementInformation.AlternativeCandidatePubkeys.Count; 
     i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
{
    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
    Context.LogDebug(() => $"Removed evil miner {evilMinerPubkey} without replacement due to lack of alternatives");
}
```

**Fix 3 - Alternative: Graceful Degradation**:
Consider allowing the network to operate with fewer miners rather than keeping banned miners active. This would require adjustment to consensus threshold calculations but provides better security guarantees.

## Proof of Concept

```csharp
[Fact]
public async Task BannedMinersRemainActiveWhenNoAlternativesAvailable_Test()
{
    // Setup: 7 initial miners, ban 3 of them, current active set is remaining 4
    var initialMiners = InitialCoreDataCenterKeyPairs.Take(7).ToList();
    var bannedMiners = initialMiners.Take(3).ToList();
    var currentActiveMiners = initialMiners.Skip(3).ToList();
    
    // Initialize with 7 initial miners
    await InitializeCandidates();
    await ElectionContractStub.UpdateMinersCount.SendAsync(new UpdateMinersCountInput { MinersCount = 4 });
    
    // Ban first 3 initial miners
    foreach (var miner in bannedMiners)
    {
        await ElectionContractStub.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
        {
            Pubkey = miner.PublicKey.ToHex(),
            IsEvilNode = true
        });
    }
    
    // Verify they are banned
    foreach (var miner in bannedMiners)
    {
        var info = await ElectionContractStub.GetCandidateInformation.CallAsync(
            new StringValue { Value = miner.PublicKey.ToHex() });
        info.IsCurrentCandidate.ShouldBeFalse(); // Removed from candidates when banned
    }
    
    // Current active miners are the remaining 4 initial miners (all initial miners are either banned or active)
    var currentMinerList = currentActiveMiners.Select(m => m.PublicKey.ToHex()).ToList();
    
    // Ban one of the current active miners (simulate evil behavior detection)
    var newlyBannedMiner = currentActiveMiners.First();
    await ElectionContractStub.UpdateCandidateInformation.SendAsync(new UpdateCandidateInformationInput
    {
        Pubkey = newlyBannedMiner.PublicKey.ToHex(),
        IsEvilNode = true
    });
    
    // Call GetMinerReplacementInformation with current miner list
    var replacementInfo = await ElectionContractStub.GetMinerReplacementInformation.CallAsync(
        new GetMinerReplacementInformationInput { CurrentMinerList = { currentMinerList } });
    
    // VULNERABILITY: Should have 1 evil miner but 0 alternatives
    replacementInfo.EvilMinerPubkeys.Count.ShouldBe(1);
    replacementInfo.AlternativeCandidatePubkeys.Count.ShouldBe(0); // No alternatives available!
    
    // The banned miner remains in current miner list and can continue producing blocks
    // because validation only checks RealTimeMinersInformation, not BannedPubkeyMap
    var stillActivePublicKey = newlyBannedMiner.PublicKey.ToHex();
    currentMinerList.ShouldContain(stillActivePublicKey);
    
    // Verify the vulnerability: Mining permission would still pass for banned miner
    // because MiningPermissionValidationProvider doesn't check banned status
}
```

## Notes

The vulnerability is particularly concerning because it represents a **security mechanism bypass** rather than an implementation bug. The banning mechanism works correctly to mark miners as evil, but the enforcement mechanism (removal from active consensus) can fail under realistic conditions.

The issue compounds over time as more initial miners are banned, progressively narrowing the available backup pool until the system can no longer maintain the invariant that "banned miners do not participate in consensus."

This is distinct from the voluntary `ReplaceCandidatePubkey` mechanism (which allows candidates to rotate keys) and specifically affects the involuntary evil miner removal process during round generation within the same term.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L368-380)
```csharp
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L382-392)
```csharp
        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L17-21)
```csharp
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
