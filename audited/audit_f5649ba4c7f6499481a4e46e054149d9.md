### Title
Consensus Mining Order Manipulation via Unverified Signature Field

### Summary
The `UpdateValueValidationProvider` only checks that `minerInRound.Signature` is non-null and non-empty but does not verify its correctness, allowing malicious miners to provide arbitrary signature bytes and manipulated mining order values. This enables attackers to deterministically control their mining position in subsequent rounds, violating consensus fairness and miner schedule integrity.

### Finding Description

The vulnerability exists in the consensus validation flow where signature correctness is never verified: [1](#0-0) 

The validation only checks that the signature field contains data, not that it matches the expected value. The signature should be calculated as: [2](#0-1) 

However, during validation, the provided signature is directly copied without verification: [3](#0-2) 

The `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` values are also directly copied from provided data (lines 24-27) rather than being recalculated from the signature. During execution, these manipulated values are stored directly: [4](#0-3) 

The mining order directly determines time slots in the next round: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Violation**: A malicious authorized miner can manipulate their mining position to always mine first (order 1) or at any desired position in subsequent rounds, violating the "miner schedule integrity" critical invariant.

**Economic Advantage**: Earlier mining slots provide:
- Priority access to transactions for MEV extraction
- Ability to influence transaction ordering within their block
- Potential revenue advantages from fee prioritization

**Repeated Exploitation**: The attacker can continuously exploit this across rounds:
- Round N: Set order to 1 for round N+1
- Round N+1: Mine first, set order to 1 for round N+2
- Continues indefinitely

**Affected Parties**: All other miners suffer disadvantage as one miner dominates favorable time slots, and users may experience unfair transaction ordering.

**Severity**: Critical - violates core consensus fairness guarantees and allows deterministic schedule manipulation by any authorized miner.

### Likelihood Explanation

**Attacker Capabilities**: Any authorized miner in the current mining set can exploit this. No special privileges beyond being an active miner are required.

**Attack Complexity**: Low - attacker simply modifies the signature and order values in their block's consensus header data before signing the block. The block signature authentication still passes since they are an authorized miner.

**Feasibility**: 
- Entry point: Block production (UpdateValue consensus behavior)
- Preconditions: Attacker must be in the current miner set
- Execution: Modify consensus header data fields, produce block normally
- Detection: Difficult to detect as the signature field format is valid (just incorrect)

**Economic Rationality**: High likelihood - the cost is zero (just data manipulation) and benefits include ongoing MEV advantages and mining priority.

**Probability**: High - any malicious miner can exploit this repeatedly with no additional cost or detection risk.

### Recommendation

Add signature correctness verification in `UpdateValueValidationProvider.ValidateHeaderInformation`:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var providedRound = validationContext.ProvidedRound;
    var pubkey = validationContext.SenderPubkey;
    var minerInRound = providedRound.RealTimeMinersInformation[pubkey];
    
    if (minerInRound.PreviousInValue == null || minerInRound.PreviousInValue == Hash.Empty)
        return true; // First round or no previous in value
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(minerInRound.PreviousInValue);
    if (minerInRound.Signature != expectedSignature)
        return false;
    
    // Verify order matches signature
    var sigNum = minerInRound.Signature.ToInt64();
    var minersCount = providedRound.RealTimeMinersInformation.Count;
    var expectedOrder = Math.Abs(sigNum % minersCount) + 1;
    if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
        return false;
    
    return true;
}
```

Add this validation check in the main validation method and return validation failure if signature verification fails.

**Test Cases**:
1. Verify blocks with incorrect signatures are rejected
2. Verify blocks with manipulated order values are rejected  
3. Verify legitimate blocks with correct calculations pass validation
4. Test edge cases with first round and missing previous in values

### Proof of Concept

**Initial State**: 
- Network has 5 authorized miners
- Current round: Attacker is miner with order 3
- Previous round: Attacker's OutValue = Hash("ABC")

**Attack Steps**:
1. Attacker's turn to produce block in current round
2. Instead of calculating signature = `previousRound.CalculateSignature(previousInValue)`, attacker sets signature = arbitrary bytes that hash to value giving order 1
3. Attacker sets `SupposedOrderOfNextRound = 1` in consensus data
4. Attacker signs block normally and broadcasts

**Expected Result** (with proper validation):
- Block rejected: "Invalid signature - does not match previousRound.CalculateSignature(previousInValue)"

**Actual Result** (current implementation):
- Block accepted
- Validation only checks signature != null && signature.Length > 0 âœ“
- Attacker gets order 1 in next round
- Attacker mines first in next round with earlier time slot

**Success Condition**: Attacker successfully mines in position 1 in the next round despite signature not matching the deterministic calculation, demonstrating consensus schedule manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
