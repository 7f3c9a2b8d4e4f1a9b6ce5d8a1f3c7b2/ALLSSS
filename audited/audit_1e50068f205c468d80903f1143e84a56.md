# Audit Report

## Title
Missing Election Result Validation Allows Arbitrary Miner List Installation During Term Transitions

## Summary
The `ValidationForNextTerm()` function fails to validate that the miner list in `NextTermInput` matches election results from the Election contract, allowing any current or previous miner to install an arbitrary set of miners for the next term by submitting a maliciously crafted `NextTerm` transaction. This completely bypasses the election mechanism that determines block producer selection.

## Finding Description

The vulnerability exists in the consensus term transition validation logic. When a miner submits a `NextTerm` transaction to transition to a new term, the validation only checks that term and round numbers increment correctly, but completely fails to verify the miner list against election results. [1](#0-0) 

The legitimate flow generates the first round of a new term by calling `GenerateFirstRoundOfNextTerm()`, which retrieves elected miners via `TryToGetVictories()` from the Election contract and sets `IsMinerListJustChanged = true`: [2](#0-1) [3](#0-2) [4](#0-3) 

However, during transaction execution, `ProcessNextTerm()` extracts the miner list **directly from the input** without any verification against election results: [5](#0-4) 

The `SetMinerList()` function only checks if a miner list already exists for that term number, not whether it matches election results: [6](#0-5) 

The access control only requires the sender to be a current or previous miner: [7](#0-6) 

**Attack Sequence:**
1. Attacker (who is a current or previous miner) waits for term transition timing
2. Constructs a `NextTermInput` with correct term number (currentTerm + 1) and round number (currentRound + 1)
3. Includes arbitrary miner list in `RealTimeMinersInformation` field
4. Submits via public `NextTerm()` method
5. Validation passes (only checks term/round increments)
6. Arbitrary miner list is installed for the entire next term

## Impact Explanation

This is a **HIGH severity** vulnerability because it enables complete subversion of the blockchain's core election mechanism:

- **Consensus Integrity Violation**: The fundamental invariant that "miners must be elected through voting" is broken
- **Authority Hijacking**: Attacker gains control over who produces blocks for an entire term (potentially days/weeks)
- **Reward Theft**: Mining rewards that should go to legitimately elected miners are redirected to attacker-controlled addresses
- **Network-Wide Impact**: All participants are affected as the consensus mechanism's legitimacy is compromised
- **Persistent Effect**: The malicious miner set remains active for the full term duration

The attack directly violates the stated design that legitimate term transitions always retrieve election results via `TryToGetVictories()` and set `IsMinerListJustChanged = true`.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Attacker Requirements:**
- Must be a current or previous miner (verified by `PreCheck()`)
- This is a realistic precondition as current miners can become malicious

**Attack Complexity: LOW**
- Timing is predictable (based on `PeriodSeconds` and blockchain age)
- Only requires constructing input with correct term/round numbers
- No cryptographic challenges or race conditions
- Single transaction execution

**Feasibility:**
- The `NextTerm()` method is public and directly callable
- No additional authorization checks beyond being a current/previous miner
- The only race condition is if an honest miner submits first in the same block, but attacker can attempt at each term transition

**Detection Difficulty:**
- No built-in detection mechanisms exist
- Would only be discovered when wrong miners start producing blocks
- By then, the malicious miner set is already installed

## Recommendation

Add validation in `ValidationForNextTerm()` to verify:

1. **Verify IsMinerListJustChanged flag:**
```csharp
if (!extraData.Round.IsMinerListJustChanged)
    return new ValidationResult { Message = "IsMinerListJustChanged must be true for term transitions." };
```

2. **Validate miner list against election results:**
```csharp
// Get expected miner list from Election contract
var expectedMiners = State.ElectionContract.GetVictories.Call(new Empty());
var providedMiners = extraData.Round.RealTimeMinersInformation.Keys
    .Select(k => ByteStringHelper.FromHexString(k)).ToList();

// Verify the miner lists match
if (expectedMiners.Value.Count != providedMiners.Count || 
    !expectedMiners.Value.All(m => providedMiners.Any(p => p.Equals(m))))
{
    return new ValidationResult { 
        Message = "Provided miner list does not match election results." 
    };
}
```

This ensures term transitions can only install miners that were actually elected through the Election contract's voting mechanism.

## Proof of Concept

A malicious miner can create and submit a `NextTerm` transaction with the following attack flow:

```csharp
// 1. Construct arbitrary miner list
var maliciousMinerList = new Dictionary<string, MinerInRound>();
maliciousMinerList["attacker_pubkey_1"] = new MinerInRound { Order = 1, ... };
maliciousMinerList["attacker_pubkey_2"] = new MinerInRound { Order = 2, ... };

// 2. Create NextTermInput with correct numbers but malicious miners
var maliciousInput = new NextTermInput
{
    TermNumber = currentTerm + 1,
    RoundNumber = currentRound + 1,
    RealTimeMinersInformation = { maliciousMinerList },
    IsMinerListJustChanged = false, // Can be any value - not validated
    // ... other required fields
};

// 3. Submit transaction
consensusContract.NextTerm(maliciousInput);

// Result: Validation passes, malicious miners installed for next term
```

The validation in `RoundTerminateValidationProvider` will pass because it only checks term/round number increments. The `ProcessNextTerm()` method will extract the malicious miner list and install it via `SetMinerList()`, completely bypassing the election results that should have been retrieved via `TryToGetVictories()`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-191)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```
