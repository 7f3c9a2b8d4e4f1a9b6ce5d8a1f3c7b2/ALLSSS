### Title
Validators Can Manipulate Block Timestamps to Bypass Parliament Proposal Expiration

### Summary
Validators can set block timestamps backwards (within consensus rules) to bypass Parliament proposal expiration checks. The `CheckProposalNotExpired` function relies on `Context.CurrentBlockTime` which comes from the miner-controlled block header timestamp, and there is no validation preventing timestamps from going backwards relative to previous blocks, only a constraint preventing timestamps more than 4 seconds in the future.

### Finding Description

The Parliament contract's `Validate(ProposalInfo)` function checks proposal expiration using `CheckProposalNotExpired`: [1](#0-0) [2](#0-1) 

The check uses `Context.CurrentBlockTime`, which is set from the block header timestamp controlled by the block producer: [3](#0-2) 

**Root Cause**: Block validation only prevents timestamps more than 4 seconds **ahead** of UTC time, with no validation ensuring timestamps are monotonically increasing or preventing backwards time manipulation: [4](#0-3) 

The consensus time slot validation in `TimeSlotValidationProvider` only checks **previous** `ActualMiningTimes`, not the current block's timestamp: [5](#0-4) 

### Impact Explanation

**Governance Bypass**: Validators can vote on, approve, or release proposals after their intended expiration time by setting block timestamps before the expiration time. This undermines the proposal time-lock mechanism, a critical governance invariant.

**Affected Operations**:
- `Approve`, `Reject`, `Abstain`: Can vote on expired proposals [6](#0-5) 
- `Release`: Can execute expired proposals [7](#0-6) 
- `GetValidProposal`: Validates proposals using compromised time check [8](#0-7) 

**Severity**: High - Violates the "proposal lifetime/expiration" critical invariant for governance.

### Likelihood Explanation

**Attacker Capabilities**: Any validator with a mining slot can execute this attack. Block producers control their block header timestamps with no restrictions on setting them backwards.

**Attack Complexity**: Low - Simply requires setting the block header timestamp to a value before the proposal expiration time.

**Feasibility Conditions**:
- Attacker must be a validator with an active mining slot (realistic in AEDPoS)
- Proposal must have recently expired (within practical time manipulation bounds)
- No special setup or state manipulation required

**Detection Constraints**: While timestamp manipulation may be observable on-chain, there is no automatic validation that would reject such blocks, and the effect persists for the duration of that block.

**Probability**: High - The attack is straightforward for any validator to execute when they control a mining slot and a proposal they want to keep alive expires.

### Recommendation

**Add monotonic timestamp validation** in block validation to ensure block timestamps always increase:

```csharp
// In BlockValidationProvider.ValidateBeforeAttachAsync
var previousBlock = await _blockchainService.GetBlockByHashAsync(block.Header.PreviousBlockHash);
if (previousBlock != null && block.Header.Time <= previousBlock.Header.Time)
{
    Logger.LogDebug("Block timestamp must be greater than previous block");
    return Task.FromResult(false);
}
```

**Add timestamp proximity validation** in consensus to ensure block timestamps are reasonably close to expected mining times:

```csharp
// In TimeSlotValidationProvider.ValidateHeaderInformation
// Validate current block time against expected mining time
var expectedMiningTime = minerInRound.ExpectedMiningTime;
var maxAllowedDeviation = validationContext.BaseRound.GetMiningInterval();
if (currentBlockTime < expectedMiningTime.AddMilliseconds(-maxAllowedDeviation))
{
    return new ValidationResult { 
        Message = "Block timestamp too far before expected mining time" 
    };
}
```

**Add test cases** to verify blocks with backwards timestamps are rejected.

### Proof of Concept

**Initial State**:
- Parliament proposal with `ExpiredTime = 1000` seconds (Timestamp)
- Current blockchain at block N with `block.Header.Time = 995` seconds
- UTC time advances to 1005 seconds (past expiration)

**Attack Execution**:
1. Validator V's mining slot arrives at UTC time 1005
2. V produces block N+1 with `block.Header.Time = 998` seconds (before expiration)
3. Block validation passes:
   - `998 - 1005 = -7 seconds` (not > 4 seconds future) ✓
   - Consensus validation checks previous `ActualMiningTimes` only ✓
4. Block accepted with `Context.CurrentBlockTime = 998`
5. V calls `Parliament.Approve(proposalId)` or `Parliament.Release(proposalId)`
6. `CheckProposalNotExpired` checks: `998 < 1000` → TRUE
7. Proposal considered valid, vote/release succeeds

**Expected Result**: Proposal should be expired and operations should fail with "Invalid proposal"

**Actual Result**: Proposal is considered valid and operations succeed, bypassing expiration time-lock

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L157-166)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = CheckProposalNotExpired(proposal);
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L182-188)
```csharp
    private ProposalInfo GetValidProposal(Hash proposalId)
    {
        var proposal = State.Proposals[proposalId];
        Assert(proposal != null, "Proposal not found.");
        Assert(Validate(proposal), "Invalid proposal.");
        return proposal;
    }
```

**File:** src/AElf.Kernel.Core/Blockchain/Application/IBlockValidationProvider.cs (L133-139)
```csharp
        if (block.Header.Height != AElfConstants.GenesisBlockHeight &&
            block.Header.Time.ToDateTime() - TimestampHelper.GetUtcNow().ToDateTime() >
            KernelConstants.AllowedFutureBlockTimeSpan.ToTimeSpan())
        {
            Logger.LogDebug("Future block received {Block}, {BlockTime}", block, block.Header.Time.ToDateTime());
            return Task.FromResult(false);
        }
```

**File:** src/AElf.Kernel.Types/KernelConstants.cs (L19-19)
```csharp
    public static Duration AllowedFutureBlockTimeSpan = new() { Seconds = 4 };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L78-94)
```csharp
    public override Empty Approve(Hash input)
    {
        var parliamentMemberAddress = GetAndCheckActualParliamentMemberAddress();
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedByMember(proposal, parliamentMemberAddress);
        proposal.Approvals.Add(parliamentMemberAddress);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = parliamentMemberAddress,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
