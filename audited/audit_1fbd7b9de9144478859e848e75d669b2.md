### Title
Unbounded Iteration Over AutoDistributeThreshold Causes DoS in RegisterForProfits

### Summary
An attacker can create a TokenHolder scheme with AutoDistributeThreshold containing thousands of token symbol entries. When any user attempts to register for profits on this scheme, the RegisterForProfits function performs an unbounded iteration over all entries, making a cross-contract call for each one, resulting in execution time exhaustion and permanent DoS of the scheme.

### Finding Description

The vulnerability exists across two functions in the TokenHolder contract:

**CreateScheme Function** - The entry point accepts AutoDistributeThreshold as a map without validating the number of entries: [1](#0-0) 

The AutoDistributeThreshold is defined as an unbounded map in the protobuf specification: [2](#0-1) 

**RegisterForProfits Function** - The critical flaw occurs during profit registration where an unbounded foreach loop iterates over all AutoDistributeThreshold entries: [3](#0-2) 

Within this loop, each iteration performs a cross-contract call to TokenContract.GetBalance: [4](#0-3) 

**Root Cause**: No validation exists on the size of AutoDistributeThreshold during scheme creation, and no pagination or iteration limits exist during the auto-distribute check in RegisterForProfits.

**Why Protections Fail**: While AElf has a 128KB state size limit that automatically prevents extremely large state writes, an attacker can still store approximately 3,000-5,000 map entries within this limit. The state size validation occurs during CreateScheme but provides no protection against the subsequent iteration cost in RegisterForProfits. [5](#0-4) 

### Impact Explanation

**Operational DoS**: Any scheme created with thousands of AutoDistributeThreshold entries becomes permanently unusable. When users attempt to call RegisterForProfits, the unbounded iteration with thousands of cross-contract calls exceeds the block execution time limit, causing transaction failure.

**Affected Parties**:
- Legitimate users who want to register for profits on the poisoned scheme cannot do so
- The scheme manager loses the ability to distribute rewards through the auto-distribute mechanism
- The entire profit distribution functionality for that scheme is rendered inoperable

**Severity Justification**: This is a Medium severity issue because:
1. It causes permanent denial of service to a core protocol function (profit registration)
2. The attack requires minimal resources (single CreateScheme transaction)
3. Recovery requires creating a new scheme, losing existing configuration and state
4. It does not directly result in fund theft but breaks operational functionality

### Likelihood Explanation

**Attacker Capabilities Required**: 
- Ability to call the public CreateScheme function (any address)
- Sufficient tokens to pay transaction fees
- No special permissions or privileged access needed

**Attack Complexity**: Low
- Single transaction to CreateScheme with a large AutoDistributeThreshold map
- Map can contain 3,000-5,000 entries within the 128KB state limit
- No complex setup or timing requirements

**Feasibility Conditions**:
- Attack is immediately executable on any deployed TokenHolder contract
- Each symbol name entry (~10 bytes) + int64 value (8 bytes) + overhead (~5 bytes) = ~23 bytes per entry
- 128KB limit / 23 bytes â‰ˆ 5,565 maximum entries theoretically possible
- Even with 3,000 entries, the iteration would require 3,000+ cross-contract calls

**Detection/Operational Constraints**: 
- Attack is difficult to prevent as CreateScheme is a public function
- No monitoring exists for AutoDistributeThreshold size
- Once created, the malicious scheme persists permanently

**Probability**: High - the attack is practical, cheap, and requires no special privileges.

### Recommendation

**Immediate Mitigation**: Add validation to CreateScheme to limit the number of AutoDistributeThreshold entries:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    const int MaxAutoDistributeThresholdCount = 10; // Or other reasonable limit
    Assert(input.AutoDistributeThreshold == null || 
           input.AutoDistributeThreshold.Count <= MaxAutoDistributeThresholdCount,
           $"AutoDistributeThreshold cannot exceed {MaxAutoDistributeThresholdCount} entries.");
    
    // ... rest of the function
}
```

**Additional Hardening**: Consider adding pagination or breaking out of the loop after checking a maximum number of thresholds in RegisterForProfits:

```csharp
const int MaxThresholdChecksPerRegistration = 10;
int checksPerformed = 0;
foreach (var threshold in scheme.AutoDistributeThreshold)
{
    if (++checksPerformed > MaxThresholdChecksPerRegistration) break;
    // ... rest of loop
}
```

**Invariant to Enforce**: `AutoDistributeThreshold.Count <= MAX_THRESHOLD_COUNT` must hold for all schemes.

**Test Cases**:
1. Test CreateScheme rejection when AutoDistributeThreshold exceeds limit
2. Test RegisterForProfits executes successfully with maximum allowed entries
3. Gas/time profiling test for RegisterForProfits with boundary-case threshold count

### Proof of Concept

**Initial State**: 
- TokenHolder contract deployed and initialized
- Attacker has sufficient tokens to pay transaction fees

**Attack Steps**:

1. Attacker calls CreateScheme with malicious input:
```
CreateTokenHolderProfitSchemeInput {
    Symbol: "ELF",
    MinimumLockMinutes: 1,
    AutoDistributeThreshold: {
        "SYM0001": 1000,
        "SYM0002": 1000,
        ... (repeat for 3000-5000 entries)
        "SYM5000": 1000
    }
}
```

2. Scheme is created successfully (passes 128KB state limit)

3. Victim user attempts to register:
```
RegisterForProfitsInput {
    SchemeManager: <attacker_address>,
    Amount: 100
}
```

**Expected Result**: RegisterForProfits succeeds and user is registered as beneficiary

**Actual Result**: Transaction fails due to execution time exhaustion during the foreach loop iteration, as each of the 3000-5000 iterations performs a cross-contract GetBalance call

**Success Condition**: RegisterForProfits transaction consistently fails with timeout/gas exhaustion error for any user attempting to register on the poisoned scheme, effectively rendering the scheme unusable.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L27-32)
```csharp
        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L179-206)
```csharp
        if (scheme.AutoDistributeThreshold != null && scheme.AutoDistributeThreshold.Any())
        {
            var originScheme = State.ProfitContract.GetScheme.Call(scheme.SchemeId);
            var virtualAddress = originScheme.VirtualAddress;
            Profit.DistributeProfitsInput distributedInput = null;
            foreach (var threshold in scheme.AutoDistributeThreshold)
            {
                var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = virtualAddress,
                    Symbol = threshold.Key
                }).Balance;
                if (balance < threshold.Value) continue;
                if (distributedInput == null)
                    distributedInput = new Profit.DistributeProfitsInput
                    {
                        SchemeId = scheme.SchemeId,
                        Period = scheme.Period
                    };
                distributedInput.AmountsMap[threshold.Key] = 0;
                break;
            }

            if (distributedInput == null) return new Empty();
            State.ProfitContract.DistributeProfits.Send(distributedInput);
            scheme.Period = scheme.Period.Add(1);
            State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
        }
```

**File:** protobuf/token_holder_contract.proto (L63-70)
```text
message CreateTokenHolderProfitSchemeInput {
    // The token symbol.
    string symbol = 1;
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
    // Threshold setting for releasing dividends.
    map<string, int64> auto_distribute_threshold = 3;
}
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L1-50)
```csharp
namespace AElf.Kernel.SmartContract;

public class SmartContractConstants
{
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;

    public const int StateSizeLimit = 128 * 1024;

    // The prefix `vs` occupies 2 lengths.
    public const int StateKeyMaximumLength = 255 - 2;
}

```
