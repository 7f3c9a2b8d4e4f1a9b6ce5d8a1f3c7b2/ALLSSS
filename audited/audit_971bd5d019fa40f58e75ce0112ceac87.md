### Title
Duplicate Miner Entries in Victory List Cause Consensus DoS

### Summary
The `GetVictories` function in the Election contract adds Initial Miners to the backup pool without checking if they're already included in the valid candidates list. When an Initial Miner has received votes (is a valid candidate) but is not a current miner, it gets added to victories twice - once from validCandidates and once from the InitialMiners backup injection. This causes the consensus contract to fail with a duplicate key exception when generating the next term, resulting in a complete consensus halt.

### Finding Description [1](#0-0) 

The vulnerability exists in the private `GetVictories(List<string> currentMiners)` method. When there are insufficient valid candidates (diff > 0), the function:

1. Initializes victories with all validCandidates
2. Creates a backups list from currentMiners that are NOT in validCandidates  
3. Adds InitialMiners to backups, checking only `!backups.Contains(k)` but NOT checking `!validCandidates.Contains(k)`
4. Adds items from backups to victories [2](#0-1) 

The root cause is at lines 67-69 where the check only verifies the InitialMiner is not already in backups, but fails to verify it's not already in validCandidates (and thus already in victories from line 65). [3](#0-2) 

The `GetValidCandidates()` method returns candidates with votes > 0. Since InitialMiners are registered as candidates during initialization, they can receive votes and become valid candidates. [4](#0-3) 

When victories with duplicate entries are passed to the consensus contract: [5](#0-4) 

The consensus contract calls `GenerateFirstRoundOfNewTerm` which attempts to create a dictionary from the public keys: [6](#0-5) 

The `ToDictionary` operation will throw an `ArgumentException` when encountering the duplicate key, causing the consensus contract to fail.

### Impact Explanation

**Severity: HIGH - Consensus DoS**

The impact is a complete denial of service of the consensus mechanism:

1. **Consensus Halt**: When term transition occurs, the consensus contract cannot generate the next round due to the dictionary duplicate key exception, preventing any new blocks from being produced.

2. **Protocol-Wide Disruption**: All network operations cease as no new blocks can be mined, affecting all users and applications on the chain.

3. **Recovery Complexity**: The issue cannot be automatically recovered - it requires emergency intervention to either remove votes from the problematic InitialMiner or force a term transition with corrected miner lists.

4. **No Fund Theft**: While severe, this is a DoS vulnerability rather than a fund theft vector.

The vulnerability violates the critical invariant: "Correct round transitions and time-slot validation, miner schedule integrity" from the Consensus & Cross-Chain invariants.

### Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly likely to manifest under normal operation:

1. **Reachable Entry Point**: `GetVictories()` is a public view method called by the consensus contract during term transitions. [7](#0-6) 

2. **Feasible Preconditions**: 
   - An InitialMiner receives votes from voters (standard election behavior)
   - That InitialMiner is not currently in the active miner set (normal rotation)
   - Valid candidates < MinersCount (common in early chain operation or low participation)

3. **No Attacker Needed**: This occurs through normal system operation without malicious action. Any voter casting votes for an InitialMiner triggers the condition.

4. **Execution Practicality**: All steps execute under normal AElf contract semantics. No special privileges or unusual contract calls required.

5. **Economic Rationality**: Voting for InitialMiners is economically rational as they are typically reputable founding nodes. The cost is just normal voting transaction fees.

The scenario is particularly likely when:
- The chain is in early operation with few candidates
- InitialMiners have established reputation and receive votes
- Miner rotation has occurred, moving some InitialMiners out of current active set

### Recommendation

**Immediate Fix**: Modify line 69 to check both conditions:

```csharp
backups.AddRange(
    State.InitialMiners.Value.Value.Select(k => k.ToHex())
        .Where(k => !backups.Contains(k) && !validCandidates.Contains(k)));
```

This ensures InitialMiners are only added to backups if they are neither in the backups list NOR in the validCandidates list.

**Invariant Check**: Add assertion before returning victories to verify uniqueness:
```csharp
Assert(victories.Select(v => v.ToHex()).Distinct().Count() == victories.Count, 
    "Victory list contains duplicates");
```

**Test Cases**: Add regression tests covering:
1. InitialMiner with votes but not in currentMiners
2. InitialMiner with votes and in currentMiners  
3. InitialMiner without votes but not in currentMiners
4. Verify victories list has no duplicates in all scenarios

### Proof of Concept

**Initial State:**
- MinersCount = 5
- InitialMiners = [IM1, IM2, IM3, IM4, IM5]
- CurrentMiners = [IM3, IM4, IM5, NewC1, NewC2] (IM1 and IM2 rotated out)

**Transaction Steps:**

1. Voter casts votes for IM1 (InitialMiner): `Vote(IM1, amount=100, lockTime=90days)`
2. Voter casts votes for NewC1: `Vote(NewC1, amount=100, lockTime=90days)`  
3. Voter casts votes for NewC2: `Vote(NewC2, amount=100, lockTime=90days)`
4. Consensus contract calls `ElectionContract.GetVictories()` during term transition

**Execution Trace:**
- validCandidates = [IM1, NewC1, NewC2] (3 candidates with votes)
- diff = 5 - 3 = 2 (need 2 more)
- victories = [IM1, NewC1, NewC2] (from line 65)
- backups = [IM3, IM4, IM5] (from line 66, currentMiners not in validCandidates)
- Process InitialMiners:
  - IM1: NOT in backups → ADDED to backups
  - IM2: NOT in backups → ADDED to backups
  - IM3-5: IN backups → SKIPPED
- backups = [IM3, IM4, IM5, IM1, IM2]
- After sort and take(2), if IM1 is selected: victories.AddRange includes IM1
- **Final victories = [IM1, NewC1, NewC2, ..., IM1] - IM1 appears TWICE**

**Expected vs Actual:**
- Expected: victories = [IM1, NewC1, NewC2, IM3, IM4] (5 unique miners)
- Actual: victories = [IM1, NewC1, NewC2, IM1, IM2] (IM1 duplicated)

**Success Condition:**
When consensus contract calls `victories.GenerateFirstRoundOfNewTerm()`, the `ToDictionary` operation throws `ArgumentException: "An item with the same key has already been added"`, causing transaction failure and consensus halt.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L34-43)
```csharp
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```
