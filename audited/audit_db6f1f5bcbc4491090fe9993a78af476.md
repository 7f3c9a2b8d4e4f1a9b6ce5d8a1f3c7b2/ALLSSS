### Title
Secret Sharing Information Exposed Through Public View Methods Allowing Premature InValue Reconstruction

### Summary
The `DeleteSecretSharingInformation()` method correctly clears sensitive secret sharing data (EncryptedPieces and DecryptedPieces) from Round objects, but public view methods `GetCurrentRoundInformation()` and `GetRoundInformation()` return Round data directly from state without calling this cleanup method. This allows any external party to extract DecryptedPieces and reconstruct miners' unrevealed InValues, compromising the consensus random number generation security.

### Finding Description

The `DeleteSecretSharingInformation()` method only clears the secret sharing components (EncryptedPieces and DecryptedPieces): [1](#0-0) 

This method is correctly designed - InValue, PreviousInValue, and Signature are NOT secrets as they represent revealed values used for public consensus validation. The protobuf definition confirms InValue is "Generated by secret sharing and used for validation between miner" and PreviousInValue is explicitly "The InValue of the previous round": [2](#0-1) 

The critical issue is that `DeleteSecretSharingInformation()` is only called when preparing consensus block extra data (not for generating transactions): [3](#0-2) 

However, public view methods return Round data WITHOUT calling this cleanup method: [4](#0-3) 

These are public view methods accessible to anyone: [5](#0-4) 

When miners update consensus values, EncryptedPieces and DecryptedPieces are stored in state: [6](#0-5) 

The DecryptedPieces can be used to reconstruct unrevealed InValues using Shamir's Secret Sharing algorithm: [7](#0-6) 

### Impact Explanation

An attacker can compromise the AEDPoS consensus random number generation by:

1. **Extracting Secret Sharing Data**: Call `GetCurrentRoundInformation()` to obtain all miners' DecryptedPieces for the current round
2. **Reconstructing Unrevealed InValues**: Use the same `SecretSharingHelper.DecodeSecret()` logic to reconstruct any miner's current InValue before they reveal it
3. **Predicting Random Numbers**: With knowledge of unrevealed InValues, predict future random hashes used for consensus decisions

This breaks the fundamental security assumption that InValues remain secret until explicitly revealed as PreviousInValue in the next round. The random number generation depends on unpredictable InValues - if these can be reconstructed prematurely, the consensus random oracle is compromised.

**Affected parties**: All network participants relying on consensus randomness for fair block production ordering, election results, and any protocol decisions using random values.

**Severity**: Medium-High. While this doesn't directly steal funds, it undermines consensus integrity and could enable sophisticated attacks on protocols depending on unpredictable randomness.

### Likelihood Explanation

**Attack Complexity**: Very Low
- Attacker simply calls public view method `GetCurrentRoundInformation()` or `GetRoundInformation(roundNumber)`
- Extract `minerInRound.DecryptedPieces` for target miners
- Run standard Shamir Secret Sharing reconstruction (minimumCount = minersCount * 2/3 pieces required)

**Attacker Capabilities**: Minimal
- No special permissions required - these are public view methods
- No transaction submission needed (view methods are free queries)
- No timing constraints - Round data persists in state

**Feasibility**: Very High
- Direct API access through standard AElf node RPC
- DecryptedPieces are populated as miners produce blocks (normal consensus operation)
- Once sufficient miners have collected pieces, reconstruction is deterministic

**Detection**: Difficult
- View method calls are typically not logged or monitored
- No on-chain trace of the information extraction
- Attack is passive observation, not active manipulation

### Recommendation

**Immediate Fix**: Modify view methods to clean sensitive data before returning:

```csharp
public override Round GetCurrentRoundInformation(Empty input)
{
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        currentRound.DeleteSecretSharingInformation();
        return currentRound;
    }
    return new Round();
}

public override Round GetRoundInformation(Int64Value input)
{
    if (TryToGetRoundInformation(input.Value, out var round))
    {
        round.DeleteSecretSharingInformation();
        return round;
    }
    return new Round();
}
```

Apply the same pattern to `GetPreviousRoundInformation()`.

**Alternative Approach**: Create a separate method that returns a "sanitized" Round view: [8](#0-7) 

The existing `GetCheckableRound()` method already demonstrates this pattern - create similar public-facing view methods.

**Test Cases**: Add tests verifying view methods never expose EncryptedPieces or DecryptedPieces, while still returning other necessary consensus data.

### Proof of Concept

**Step 1 - Initial State**: AEDPoS consensus is running normally with N miners. Miners are producing blocks and performing secret sharing.

**Step 2 - Information Extraction**:
```
// Call public view method
var currentRound = aedposContract.GetCurrentRoundInformation(new Empty());

// For each miner in the round
foreach (var miner in currentRound.RealTimeMinersInformation)
{
    // Extract decrypted pieces
    var decryptedPieces = miner.Value.DecryptedPieces;
    
    // If miner has collected enough pieces (>= minersCount * 2/3)
    if (decryptedPieces.Count >= threshold)
    {
        // Attacker can reconstruct the miner's CURRENT unrevealed InValue
        var orders = ExtractOrders(decryptedPieces, currentRound);
        var sharedParts = decryptedPieces.Values.ToList();
        var revealedInValue = SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount);
        
        // Success: Obtained InValue before it should be revealed
        // This InValue won't be publicly revealed until the NEXT round
    }
}
```

**Expected Result**: View methods should return Round data with EncryptedPieces and DecryptedPieces cleared (empty maps).

**Actual Result**: View methods return complete Round data including all EncryptedPieces and DecryptedPieces, enabling premature InValue reconstruction.

**Success Condition**: Attacker obtains hash value matching what will later be published as PreviousInValue in the next round, proving they reconstructed it prematurely.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_GetLighterRound.cs (L7-14)
```csharp
    public void DeleteSecretSharingInformation()
    {
        var encryptedPieces = RealTimeMinersInformation.Values.Select(i => i.EncryptedPieces);
        foreach (var encryptedPiece in encryptedPieces) encryptedPiece.Clear();

        var decryptedPieces = RealTimeMinersInformation.Values.Select(i => i.DecryptedPieces);
        foreach (var decryptedPiece in decryptedPieces) decryptedPiece.Clear();
    }
```

**File:** protobuf/aedpos_contract.proto (L78-94)
```text
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round number.
    rpc GetCurrentRoundNumber (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round information.
    rpc GetCurrentRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the previous round information.
    rpc GetPreviousRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
```

**File:** protobuf/aedpos_contract.proto (L271-296)
```text
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L50-50)
```csharp
        if (!isGeneratingTransactions) information.Round.DeleteSecretSharingInformation();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L21-28)
```csharp
    public override Round GetCurrentRoundInformation(Empty input)
    {
        return TryToGetCurrentRoundInformation(out var currentRound) ? currentRound : new Round();
    }

    public override Round GetRoundInformation(Int64Value input)
    {
        return TryToGetRoundInformation(input.Value, out var round) ? round : new Round();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-296)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L161-176)
```csharp
            if (minerInRound.EncryptedPieces.Count < minimumCount) continue;
            if (minerInRound.DecryptedPieces.Count < minersCount) continue;

            // Reveal another miner's in value for target round:

            var orders = minerInRound.DecryptedPieces.Select((t, i) =>
                    round.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    minerInRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
