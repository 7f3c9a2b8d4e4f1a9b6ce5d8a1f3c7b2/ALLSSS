### Title
Insufficient Fee Protection for Unconfigured Methods in Genesis Contract

### Summary
The Genesis contract's `GetMethodFee` implementation returns null for unconfigured methods, causing the fee collection system to skip base method fees and only charge transaction size fees. This allows expensive operations like `DeployUserSmartContract` to be executed with minimal fees if governance fails to explicitly configure them, potentially enabling economic DoS attacks through under-priced contract deployments.

### Finding Description

The Genesis contract's fee provider implementation has a critical logic error in how it handles unconfigured method fees: [1](#0-0) 

When `State.TransactionFees[input.Value]` returns null (line 36), the method returns null for all methods except `ReleaseApprovedUserSmartContract`. This null return value propagates to the fee charging system: [2](#0-1) 

When `methodFees` is null, the `fee` dictionary remains empty (line 40), and `isSizeFeeFree` stays false (line 41). Subsequently, in `ChargeTransactionFeesToBill`: [3](#0-2) 

The base fee charging is skipped when `fee.Count == 0` (line 278), but size fees are still charged (line 292-297). This means unconfigured methods only incur transaction size fees, not method-specific base fees.

For expensive operations like `DeployUserSmartContract`, which is publicly callable on mainnet: [4](#0-3) [5](#0-4) 

This method performs expensive operations (code deployment, proposal creation, event firing) but can be called by any user on mainnet (lines 348-352) without restriction. If its fee is not explicitly configured, users pay only minimal size-based fees.

This contrasts with other contracts like Profit and Vote that return default fees when unconfigured: [6](#0-5) [7](#0-6) 

### Impact Explanation

**Economic Impact:**
- Users pay only transaction size fees (based on bytes) instead of base method fees (e.g., 1-10 ELF) for expensive operations
- For contract deployments with small code size, fees could be 100x-1000x cheaper than intended
- Attackers can spam expensive operations (contract deployments, proposals) at minimal cost

**Operational Impact:**
- DoS vector: Flood the network with cheap but computationally expensive operations
- Overwhelm code check proposal system with numerous pending user contract deployments
- Degrade network performance through under-priced state-changing operations
- Economic misallocation: Critical operations become nearly free if unconfigured

**Affected Parties:**
- Network validators (increased computational load without adequate compensation)
- Users paying proper fees for other operations (unfair advantage to exploiters)
- Governance system (proposal queue spam)

**Severity Justification:**
While not direct fund theft, this enables significant economic exploitation and potential network DoS through systematically under-priced expensive operations that governance assumed would have reasonable cost barriers.

### Likelihood Explanation

**Preconditions:**
- Governance must fail to explicitly configure fees for expensive methods via `SetMethodFee`
- No default fees are returned for unconfigured methods (current Genesis contract behavior)
- Expensive operations must be publicly callable (true for `DeployUserSmartContract` on mainnet)

**Attack Complexity: LOW**
- No special permissions required
- Direct method invocation on publicly deployed contract
- No cryptographic or timing requirements
- Simple transaction construction

**Feasibility: MEDIUM-HIGH**
- Depends entirely on governance oversight during initialization or subsequent updates
- Test files show fees are explicitly configured, but `DeployUserSmartContract` is not included: [8](#0-7) 

- The absence of explicit fee configuration testing for user contract deployment suggests this could be overlooked
- Once exploited, can be repeated until governance intervenes

**Detection:**
- Unusual spike in contract deployment transactions
- Abnormally low fee collection relative to operation count
- Monitoring can detect but cannot prevent initial exploitation

**Economic Rationality:**
- For small contract deployments, cost is negligible (only size fee)
- Attacker can spam multiple deployments for less than single properly-priced deployment
- Benefit (DoS impact, unfair economic advantage) outweighs minimal cost

### Recommendation

**Immediate Fix:**
Modify `GetMethodFee` in Genesis contract to return default fees when methods are unconfigured, consistent with Profit and Vote contracts:

```csharp
public override MethodFees GetMethodFee(StringValue input)
{
    var fees = State.TransactionFees[input.Value];
    if (fees != null) return fees;
    
    if (input.Value == nameof(ReleaseApprovedUserSmartContract))
    {
        return new MethodFees
        {
            MethodName = input.Value,
            IsSizeFeeFree = true
        };
    }
    
    // Return default fee for expensive operations
    if (input.Value == nameof(DeployUserSmartContract) || 
        input.Value == nameof(UpdateUserSmartContract) ||
        input.Value == nameof(ProposeNewContract) ||
        input.Value == nameof(ProposeUpdateContract))
    {
        return new MethodFees
        {
            MethodName = input.Value,
            Fees = { new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 } }
        };
    }
    
    // Default for other methods
    return new MethodFees
    {
        MethodName = input.Value,
        Fees = { new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 } }
    };
}
```

**Invariant Checks:**
- Add assertion in fee charging system to log/warn when methodFees is null for state-changing operations
- Implement initialization validation that ensures expensive methods have configured fees
- Add governance proposal validation to prevent unsetting fees for critical methods

**Test Cases:**
- Verify all publicly-callable expensive methods return non-null fees
- Test fee charging with unconfigured methods to ensure defaults apply
- Regression test for consistency across all ACS1 implementations
- Integration test: attempt contract deployment with and without configured fees

### Proof of Concept

**Initial State:**
1. Genesis contract deployed and initialized
2. No explicit fee configured for `DeployUserSmartContract` method via `SetMethodFee`
3. Attacker has minimal ELF balance (e.g., 0.1 ELF for size fees)

**Exploitation Steps:**

1. **Query current fee configuration:**
```csharp
var methodFee = await BasicContractZeroStub.GetMethodFee.CallAsync(
    new StringValue { Value = "DeployUserSmartContract" });
// Result: null (no fee configured)
```

2. **Deploy small user contract with minimal code:**
```csharp
var deployInput = new UserContractDeploymentInput
{
    Category = 0,
    Code = ByteString.CopyFrom(smallContractCode), // e.g., 1KB contract
    Salt = HashHelper.ComputeFrom("test1")
};

var result = await BasicContractZeroStub.DeployUserSmartContract.SendAsync(deployInput);
// Fee charged: ~0.001 ELF (size fee only)
// Expected fee: 10 ELF (base) + 0.001 ELF (size) = 10.001 ELF
```

3. **Repeat multiple times:**
```csharp
for (int i = 0; i < 100; i++)
{
    deployInput.Salt = HashHelper.ComputeFrom($"spam{i}");
    await BasicContractZeroStub.DeployUserSmartContract.SendAsync(deployInput);
}
// Total cost: ~0.1 ELF (size fees only)
// Expected cost: ~1000 ELF (100 * 10 ELF base fees + size fees)
```

**Expected Result:** Transaction should cost 10+ ELF including base method fee
**Actual Result:** Transaction costs only ~0.001 ELF (size fee based on transaction bytes)
**Success Condition:** Attacker deploys 100 contracts for cost of what should be 1 properly-priced deployment, demonstrating 100x cost reduction and DoS vector viability

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L34-47)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var fees = State.TransactionFees[input.Value];
        if (fees == null && input.Value == nameof(ReleaseApprovedUserSmartContract))
        {
            fees = new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        }

        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L278-300)
```csharp
        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        //For delegation, if the base fee fails to be charged, the size fee will not be charged
        if (delegations != null && !successToChargeBaseFee)
        {
            return false;
        }

        var successToChargeSizeFee = true;
        if (!isSizeFeeFree)
        {
            // If IsSizeFeeFree == true, do not charge size fee.
            successToChargeSizeFee =
                ChargeSizeFee(input, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }

        return successToChargeBaseFee && successToChargeSizeFee;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var methodFees = State.TransactionFees[input.Value];
        if (methodFees != null) return methodFees;

        switch (input.Value)
        {
            case nameof(CreateScheme):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L35-59)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        var tokenAmounts = State.TransactionFees[input.Value];
        if (tokenAmounts != null) return tokenAmounts;

        switch (input.Value)
        {
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
            default:
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 1_00000000 }
                    }
                };
        }
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/TransactionFeeProviderTests.cs (L110-122)
```csharp
    public async Task Genesis_FeeProvider_Test()
    {
        await ExecuteProposalForParliamentTransaction(ContractZeroAddress, MethodName, new MethodFees
        {
            MethodName = nameof(BasicContractZeroStub.DeploySmartContract),
            Fees = { TokenAmount }
        });
        var result = await BasicContractZeroStub.GetMethodFee.CallAsync(new StringValue
        {
            Value = nameof(BasicContractZeroStub.DeploySmartContract)
        });
        result.Fees.First().ShouldBe(TokenAmount);
    }
```
