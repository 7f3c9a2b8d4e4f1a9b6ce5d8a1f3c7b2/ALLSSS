### Title
Unvalidated ActualMiningTime Allows Miners to Manipulate Consensus Behavior and Gain Block Production Advantages

### Summary
Miners can report false `ActualMiningTime` values when calling `UpdateValue` or `UpdateTinyBlockInformation` because these timestamps are added to state without validation against `Context.CurrentBlockTime`. The validation system explicitly excludes `ActualMiningTimes` from hash comparisons, allowing manipulated timestamps to influence critical consensus decisions including tiny block production limits, time slot boundaries, and term change timing, granting unfair block production advantages and rewards.

### Finding Description

**Root Cause**: In `ProcessUpdateValue` and `ProcessTinyBlock`, the `ActualMiningTime` from transaction input is directly added to the miner's state record without any validation: [1](#0-0) [2](#0-1) 

The `UpdateValueInput.ActualMiningTime` is extracted from the Round object using `.Last()`: [3](#0-2) 

**Why Existing Protections Fail**:

1. **Hash Validation Excludes ActualMiningTimes**: The `GetCheckableRound` method explicitly clears `ActualMiningTimes` before computing the hash used in validation: [4](#0-3) 

2. **Time Slot Validation Checks Previous State**: The `TimeSlotValidationProvider` validates the LATEST ActualMiningTime from previous blocks, not the new timestamp being added: [5](#0-4) 

3. **After-Execution Validation Cannot Detect**: The `ValidateConsensusAfterExecution` compares hashes which exclude ActualMiningTimes: [6](#0-5) 

**Execution Path**: 
- Miner calls public method `UpdateValue(UpdateValueInput)` or `UpdateTinyBlockInformation(TinyBlockInput)`
- These route to `ProcessConsensusInformation` which processes the input
- False `ActualMiningTime` stored in state
- Subsequent consensus decisions use manipulated timestamps

### Impact Explanation

**Direct Consensus Integrity Impact**:

1. **Extra Tiny Block Production**: Miners can report timestamps before round start time to inflate `blocksBeforeCurrentRound`, allowing production of additional tiny blocks beyond the intended limit: [7](#0-6) 

2. **Time Slot Manipulation**: False timestamps affect whether a miner's time slot is considered passed, potentially extending mining windows or blocking other miners.

3. **Term Change Timing Manipulation**: False timestamps influence when term changes occur through consensus calculation: [8](#0-7) 

4. **Mining Order Manipulation**: In first rounds, false timestamps affect passed slot calculations that determine mining rights: [9](#0-8) 

**Quantified Impact**:
- Extra block production = unfair mining rewards (direct economic advantage)
- Potential to produce `_maximumBlocksCount + blocksBeforeCurrentRound` blocks instead of intended limit
- Distorts miner fairness and consensus round progression
- Can affect when terms change, influencing election outcomes

**Affected Parties**: All network participants affected by consensus integrity; honest miners disadvantaged; protocol governance potentially manipulated.

**Severity Justification**: HIGH - Breaks critical consensus invariant (time-slot validation and miner schedule integrity), provides direct economic advantage through unfair block production, and requires only mining permission without additional constraints.

### Likelihood Explanation

**Attacker Capabilities**: 
- Must be a valid miner with mining permission (standard threat model for consensus attacks)
- Full control over transaction parameters when producing blocks
- Can craft `UpdateValueInput` or `TinyBlockInput` with arbitrary `ActualMiningTime` values

**Attack Complexity**: LOW
- Direct manipulation via public entry points `UpdateValue` and `UpdateTinyBlockInformation`
- No cryptographic or complex constraints to bypass
- Simply requires changing timestamp value in transaction parameter

**Feasibility Conditions**:
- Miner is in current miner list (checked by `PreCheck()`)
- No additional preconditions required
- Can be executed on any block the miner produces

**Detection Constraints**: 
- Difficult to detect as validation explicitly excludes ActualMiningTimes from verification
- No logs or events specifically tracking timestamp discrepancies
- Would require off-chain monitoring comparing block times to reported ActualMiningTimes

**Economic Rationality**: Highly rational - extra block production directly increases mining rewards with minimal cost (no additional computational work required beyond normal block production).

**Probability**: HIGH - No technical barriers prevent exploitation; only requires mining permission which malicious miners inherently have.

### Recommendation

**Immediate Fix**: Add explicit validation in `ProcessUpdateValue` and `ProcessTinyBlock` to ensure `ActualMiningTime` matches `Context.CurrentBlockTime`:

```csharp
// In ProcessUpdateValue (after line 242)
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
    "ActualMiningTime must match current block time.");
minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);

// In ProcessTinyBlock (after line 303)  
Assert(tinyBlockInput.ActualMiningTime == Context.CurrentBlockTime,
    "ActualMiningTime must match current block time.");
minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**Invariant to Enforce**: `ActualMiningTime` in consensus update transactions MUST equal `Context.CurrentBlockTime` at execution.

**Additional Validation**: Consider including ActualMiningTimes in a separate validation hash or adding tolerance bounds (e.g., within mining interval) if exact equality causes issues with block timestamp precision.

**Test Cases**:
1. Test UpdateValue with ActualMiningTime != Context.CurrentBlockTime (should fail)
2. Test UpdateTinyBlockInformation with future timestamp (should fail)
3. Test UpdateValue with past timestamp (should fail)
4. Test legitimate UpdateValue with correct timestamp (should succeed)
5. Test that manipulated timestamps cannot increase tiny block production limits
6. Regression test for `blocksBeforeCurrentRound` calculation with various timestamp scenarios

### Proof of Concept

**Initial State**:
- Network has N miners in current round
- Malicious miner M is extra block producer of previous round
- M has produced K blocks where K < _maximumBlocksCount
- Current time is within M's time slot

**Attack Sequence**:

1. **Normal Flow (Honest Behavior)**:
   - M calls `GetConsensusExtraData` which sets `ActualMiningTime = Context.CurrentBlockTime` (current time T1)
   - M generates transaction via `GenerateConsensusTransactions` with `ActualMiningTime = T1`
   - M can produce blocks up to limit based on actual timing

2. **Attack Flow (Manipulated Timestamp)**:
   - M calls `GetConsensusExtraData` which sets `ActualMiningTime = T1` in consensus header
   - M crafts custom `UpdateValueInput` transaction with `ActualMiningTime = T0` where T0 < CurrentRound.GetRoundStartTime()
   - M includes manipulated transaction in block
   - Block executes: `ProcessUpdateValue` adds T0 to state (no validation)
   - `ValidateConsensusAfterExecution` passes (ActualMiningTimes excluded from hash)

3. **Exploitation Result**:
   - On next block production, `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` reads manipulated ActualMiningTimes
   - `blocksBeforeCurrentRound = ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime())` is artificially inflated
   - Check `ActualMiningTimes.Count.Add(1) < _maximumBlocksCount.Add(blocksBeforeCurrentRound)` passes
   - M can produce additional tiny blocks beyond intended limit
   - M earns extra mining rewards unfairly

**Expected vs Actual**:
- **Expected**: M limited to `_maximumBlocksCount` blocks in current round
- **Actual**: M can produce `_maximumBlocksCount + inflated_blocksBeforeCurrentRound` blocks

**Success Condition**: Malicious miner produces more blocks than `_maximumBlocksCount` by manipulating ActualMiningTime to be before round start time, thereby gaining unfair block production advantage and additional mining rewards.

### Notes

This vulnerability exploits the design decision to exclude `ActualMiningTimes` from hash-based validation (likely for performance or flexibility reasons) combined with the absence of explicit timestamp validation during transaction execution. The attack is particularly impactful for extra block producers who can leverage the `blocksBeforeCurrentRound` mechanism intended for legitimate cross-round block production into an unfair advantage through timestamp manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L304-304)
```csharp
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-79)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L196-210)
```csharp
            var latestMinedInfo =
                currentRound.RealTimeMinersInformation.Values.OrderByDescending(i => i.Order)
                    .FirstOrDefault(i => i.ActualMiningTimes.Any() && i.Pubkey != pubkey);
            if (latestMinedInfo != null)
            {
                var minersCount = currentRound.RealTimeMinersInformation.Count;
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
```
