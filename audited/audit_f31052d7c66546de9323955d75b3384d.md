### Title
Stale Vote References Persist After Candidate Quit/Rejoin Cycle Allowing Vote Inflation

### Summary
When a candidate quits election and later rejoins, the `CandidateVotes` state is not cleared, allowing stale vote references in `ObtainedActiveVotingRecordIds` to persist. This enables candidates to artificially inflate their vote counts by accumulating both old (pre-quit) and new (post-rejoin) votes, directly affecting miner selection results and reward distribution.

### Finding Description

The vulnerability exists across multiple contract methods in the Election contract:

**Root Cause - QuitElection Does Not Clear Vote State:**
When a candidate quits election, the `QuitElection` method only updates the candidate's status flag and removes them from the voting options list, but never clears their accumulated vote data. [1](#0-0) 

Specifically, at lines 252-254, only `IsCurrentCandidate` is set to false and the announcement transaction ID is cleared, while `State.CandidateVotes[pubkey]` remains completely untouched with all historical vote IDs and amounts intact.

**Rejoin Does Not Reset Vote State:**
When a candidate announces election again after quitting, if their `CandidateInformation` already exists (which it does after quitting), the code only sets `IsCurrentCandidate` back to true without clearing any vote data. [2](#0-1) 

**Vote Accumulation Logic Adds to Existing Data:**
When new votes are cast for a rejoined candidate, the `UpdateCandidateInformation` method checks if `CandidateVotes` already exists for that candidate. Since it does (containing stale data from before quitting), the method adds the new vote IDs and amounts to the existing collections rather than starting fresh. [3](#0-2) 

At lines 561-565, new votes are appended to `ObtainedActiveVotingRecordIds` and amounts are added to `ObtainedActiveVotedVotesAmount`, creating an inflated total.

**Inflated Votes Used in Miner Selection:**
The `GetVictories` method, which determines miner election results, sorts candidates by their `ObtainedActiveVotedVotesAmount` to select winners. [4](#0-3) 

This means the artificially inflated vote counts directly impact who becomes a miner.

### Impact Explanation

**Direct Consensus Impact:**
- Manipulation of miner election results through vote count inflation
- Candidates who quit and rejoin gain unfair competitive advantage over other candidates
- Undermines the integrity of the democratic miner selection process

**Reward Misallocation:**
- Miners selected based on inflated votes receive block production rewards they don't legitimately deserve
- The data center ranking system is corrupted, affecting backup subsidy distribution [5](#0-4) 

**Severity Justification:**
This is a **High severity** vulnerability because:
1. It directly compromises consensus integrity by affecting miner selection
2. No special privileges required - any candidate can exploit this
3. The impact compounds over time as candidates can repeat the quit/rejoin cycle
4. Affects core blockchain operation (block production) and economic incentives

### Likelihood Explanation

**Attacker Capabilities:**
- Any candidate can execute this attack using standard public methods
- No collusion with voters required - the stale votes persist automatically
- Requires only: announce election → receive votes → quit → wait → rejoin

**Attack Complexity:**
- Low complexity: 3 simple transaction sequence (announce, quit, rejoin)
- No timing constraints beyond standard lock periods
- Test evidence confirms rejoin functionality works as described [6](#0-5) 

**Feasibility Conditions:**
- Votes placed before quitting must still be locked (not withdrawn by voters)
- Economic cost is just the standard election deposit (which is returned on quit) [7](#0-6) 

**Economic Rationality:**
- Minimal cost: only transaction fees for quit/rejoin
- High reward: increased probability of becoming miner with associated block rewards
- Risk/reward ratio heavily favors exploitation

**Probability Assessment:**
High likelihood of exploitation because the economic incentives strongly favor this attack, especially for candidates with marginal vote counts who need an edge to become miners.

### Recommendation

**Immediate Fix:**
Add explicit clearing of `CandidateVotes` state in the `QuitElection` method:

```csharp
// In QuitElection method, after line 254:
State.CandidateVotes.Remove(pubkey);
```

Alternatively, if vote history needs preservation for analytics, clear only the active vote collections:

```csharp
var candidateVotes = State.CandidateVotes[pubkey];
if (candidateVotes != null)
{
    candidateVotes.ObtainedActiveVotingRecordIds.Clear();
    candidateVotes.ObtainedActiveVotedVotesAmount = 0;
    State.CandidateVotes[pubkey] = candidateVotes;
}
```

**Invariant Checks:**
Add assertion in `AnnounceElection` when rejoining to ensure clean state:
- Verify `ObtainedActiveVotingRecordIds` is empty before allowing rejoin
- Or implement explicit reset in `AnnounceElection` for rejoining candidates

**Test Cases:**
Add regression test covering:
1. Candidate announces → receives votes → quits
2. Verify `CandidateVotes` is cleared or reset after quit
3. Candidate rejoins → verify vote count starts at zero
4. New votes should not accumulate with old votes

### Proof of Concept

**Initial State:**
- Candidate Bob has not announced election
- Voter Alice has 10,000 tokens available

**Transaction Sequence:**

1. **Bob announces election**
   - Call `AnnounceElection(adminAddress)`
   - `State.CandidateVotes[Bob]` is initialized empty

2. **Alice votes for Bob**
   - Call `Vote(candidatePubkey=Bob, amount=10000, lockTime=365 days)`
   - `State.CandidateVotes[Bob].ObtainedActiveVotedVotesAmount = 10000`
   - `State.CandidateVotes[Bob].ObtainedActiveVotingRecordIds = [voteId_1]`

3. **Bob quits election (after 180 days)**
   - Call `QuitElection(Bob)`
   - `State.CandidateInformationMap[Bob].IsCurrentCandidate = false`
   - **BUG**: `State.CandidateVotes[Bob]` still contains 10000 votes and voteId_1

4. **Bob rejoins election (after another 30 days)**
   - Call `AnnounceElection(adminAddress)`
   - `State.CandidateInformationMap[Bob].IsCurrentCandidate = true`
   - **BUG**: `State.CandidateVotes[Bob]` STILL contains the stale 10000 votes

5. **Charlie votes for Bob**
   - Call `Vote(candidatePubkey=Bob, amount=5000, lockTime=90 days)`
   - `UpdateCandidateInformation` adds to existing votes
   - **RESULT**: `State.CandidateVotes[Bob].ObtainedActiveVotedVotesAmount = 15000` (10000 ghost + 5000 real)

6. **Query candidate votes**
   - Call `GetCandidateVote(Bob)`
   - Returns `ObtainedActiveVotedVotesAmount = 15000`
   - Call `GetVictories()` - Bob's ranking is based on inflated 15000 votes

**Expected Result:**
Bob should have 5000 votes (only Charlie's vote after rejoin)

**Actual Result:**
Bob has 15000 votes (Alice's pre-quit vote + Charlie's post-rejoin vote)

**Success Condition:**
The vulnerability is confirmed if `GetCandidateVote(Bob).ObtainedActiveVotedVotesAmount` includes votes from before the quit/rejoin cycle.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-162)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-279)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
        var candidateInformation = State.CandidateInformationMap[pubkey];

        // Unlock candidate's native token.
        var lockId = candidateInformation.AnnouncementTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });

        // Update candidate information.
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;

        // Remove candidate public key from the Voting Item options.
        State.VoteContract.RemoveOption.Send(new RemoveOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = pubkey
        });
        var dataCenterList = State.DataCentersRankingList.Value;
        if (dataCenterList.DataCenters.ContainsKey(pubkey))
        {
            dataCenterList.DataCenters[pubkey] = 0;
            UpdateDataCenterAfterMemberVoteAmountChanged(dataCenterList, pubkey, true);
            State.DataCentersRankingList.Value = dataCenterList;
        }

        var managedCandidatePubkey = State.ManagedCandidatePubkeysMap[Context.Sender];
        managedCandidatePubkey.Value.Remove(ByteString.CopyFrom(pubkeyBytes));
        if (managedCandidatePubkey.Value.Any())
            State.ManagedCandidatePubkeysMap[Context.Sender] = managedCandidatePubkey;
        else
            State.ManagedCandidatePubkeysMap.Remove(Context.Sender);

        State.CandidateSponsorMap.Remove(pubkey);

        return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L445-464)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L546-571)
```csharp
    private long UpdateCandidateInformation(string candidatePublicKey, long amount, Hash voteId)
    {
        var candidateVotes = State.CandidateVotes[candidatePublicKey];
        if (candidateVotes == null)
        {
            candidateVotes = new CandidateVote
            {
                Pubkey = ByteStringHelper.FromHexString(candidatePublicKey),
                ObtainedActiveVotingRecordIds = { voteId },
                ObtainedActiveVotedVotesAmount = amount,
                AllObtainedVotedVotesAmount = amount
            };
        }
        else
        {
            candidateVotes.ObtainedActiveVotingRecordIds.Add(voteId);
            candidateVotes.ObtainedActiveVotedVotesAmount =
                candidateVotes.ObtainedActiveVotedVotesAmount.Add(amount);
            candidateVotes.AllObtainedVotedVotesAmount =
                candidateVotes.AllObtainedVotedVotesAmount.Add(amount);
        }

        State.CandidateVotes[candidatePublicKey] = candidateVotes;

        return candidateVotes.ObtainedActiveVotedVotesAmount;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-81)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L104-119)
```csharp
    public async Task ElectionContract_AnnounceElectionAgain_Test()
    {
        await ElectionContract_QuiteElection_Test();

        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();

        var balanceBeforeAnnouncing = await GetNativeTokenBalance(candidatesKeyPair.PublicKey);
        balanceBeforeAnnouncing.ShouldBe(ElectionContractConstants.UserInitializeTokenAmount);

        await AnnounceElectionAsync(candidatesKeyPair);

        var balanceAfterAnnouncing = await GetNativeTokenBalance(candidatesKeyPair.PublicKey);

        // Check balance after announcing election.
        balanceBeforeAnnouncing.ShouldBe(balanceAfterAnnouncing + ElectionContractConstants.LockTokenForElection);
    }
```
