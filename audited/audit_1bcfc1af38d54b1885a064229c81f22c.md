# Audit Report

## Title
Unvalidated Secret Reconstruction in RevealSharedInValues Allows Consensus State Corruption

## Summary
The `RevealSharedInValues()` function reconstructs miners' InValues from DecryptedPieces using Shamir's Secret Sharing without validating that the reconstructed secret matches the original OutValue hash. A malicious miner can provide corrupted DecryptedPieces that cause incorrect PreviousInValue storage, leading to consensus state corruption when these values are used to generate miner signatures.

## Finding Description

The vulnerability exists in the AEDPoS consensus secret sharing mechanism. When miners reveal their previous InValues through secret sharing, the system fails to validate the reconstructed secrets against the committed OutValue hashes.

**Attack Flow:**

1. **DecryptedPieces Storage Without Validation**: When miners submit UpdateValue transactions, their DecryptedPieces are added directly to the round state without any validation. [1](#0-0) 

2. **Unvalidated Secret Reconstruction**: The `RevealSharedInValues` function extracts these DecryptedPieces and uses `SecretSharingHelper.DecodeSecret` to reconstruct InValues. [2](#0-1) 

3. **No Error Detection in Lagrange Interpolation**: The `DecodeSecret` implementation uses Lagrange interpolation which always succeeds and returns a result, even when input shares are corrupted. There is no error detection mechanism. [3](#0-2) 

4. **Missing Validation**: Critically, there is no validation that `Hash(reconstructed_secret) == original_OutValue`. The reconstructed value is stored directly as PreviousInValue without any verification. [4](#0-3) 

5. **Insufficient Validation Coverage**: The `UpdateValueValidationProvider` only validates the sender's own PreviousInValue against their own previous OutValue, not the revealed values of other miners. [5](#0-4) 

6. **Corrupted Value Usage**: The unvalidated PreviousInValue is later used in `SupplyCurrentRoundInformation` to calculate signatures for miners who failed to produce blocks. [6](#0-5) 

7. **Signature Calculation**: The signature calculation uses the corrupted value, which breaks the cryptographic chain. [7](#0-6) 

The security guarantee violated is: **Consensus integrity through verifiable secret sharing**. The system assumes that revealed InValues are correct because they were reconstructed from multiple shares, but Shamir's Secret Sharing scheme has no built-in verification. If even one share among the threshold shares is corrupted, the entire reconstruction produces an incorrect result with no indication of failure.

## Impact Explanation

**Critical Consensus State Corruption**: When corrupted DecryptedPieces cause incorrect PreviousInValue reconstruction, this incorrect value is used to calculate miner signatures in `SupplyCurrentRoundInformation`. These signatures are fundamental to consensus operation - they determine mining order through XOR operations and affect the cryptographic chain of consensus values.

**Affected Parties**: 
- All miners in the consensus set
- The entire consensus mechanism's integrity
- Miners who fail to produce blocks have their InValue/Signature fields auto-filled using the corrupted PreviousInValue

**Severity Justification**: This is Critical severity because:
1. It directly violates the "Consensus & Cross-Chain" invariant requiring "Correct round transitions and miner schedule integrity"
2. It compromises the verifiable randomness property of AEDPoS consensus
3. It can cause consensus state divergence between honest nodes
4. The corrupted signatures propagate through subsequent rounds via the signature calculation mechanism

## Likelihood Explanation

**Attacker Capabilities Required**:
- Must be a miner in the current consensus round
- Must be able to submit UpdateValue transactions (normal miner privilege)
- No additional permissions required

**Attack Complexity**: Low
- Attacker simply provides arbitrary byte arrays as DecryptedPieces values when calling UpdateValue
- No sophisticated cryptographic attack needed
- The attack is deterministic - corrupted shares always produce corrupted output

**Feasibility**: High
- Shamir's Secret Sharing reconstruction requires a threshold of shares (2/3 of miners minimum as indicated by the `minimumCount` calculation) [8](#0-7) 
- If an attacker corrupts just their own DecryptedPiece for a target miner, and that piece is included in the reconstruction set, the entire reconstructed secret will be incorrect
- The scheme has **no built-in error correction** - this is a fundamental property of Shamir's Secret Sharing without additional commitments

**Detection Difficulty**: High
- `DecodeSecret` succeeds without error regardless of input validity
- The incorrect PreviousInValue is stored normally in round state
- The corruption only manifests when signatures don't match expected values in subsequent consensus operations, making root cause analysis difficult

## Recommendation

Implement validation that the reconstructed secret matches the committed OutValue hash:

```csharp
private void RevealSharedInValues(Round currentRound, string publicKey)
{
    // ... existing code ...
    
    foreach (var pair in previousRound.RealTimeMinersInformation.OrderBy(m => m.Value.Order))
    {
        // ... existing code to collect shares ...
        
        var revealedInValue =
            HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
        
        // ADD VALIDATION: Verify reconstructed secret matches committed OutValue
        var expectedOutValue = anotherMinerInPreviousRound.OutValue;
        if (expectedOutValue != null && HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
        {
            Context.LogDebug(() => 
                $"Secret reconstruction failed for {publicKeyOfAnotherMiner}: hash mismatch");
            continue; // Skip this miner's reconstruction
        }
        
        currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
    }
}
```

Alternatively, implement Verifiable Secret Sharing (e.g., Feldman's VSS) which includes cryptographic commitments to detect corrupted shares before reconstruction.

## Proof of Concept

```csharp
[Fact]
public async Task Test_CorruptedDecryptedPieces_CausesWrongPreviousInValue()
{
    // Setup: Initialize consensus with miners
    var minerKeys = GenerateMiners(5);
    await InitializeConsensusRound(minerKeys);
    
    // Round N: Miners generate InValues and create encrypted shares
    var targetMiner = minerKeys[0];
    var attackerMiner = minerKeys[1];
    var targetInValue = HashHelper.ComputeFrom("correct_secret");
    var targetOutValue = HashHelper.ComputeFrom(targetInValue);
    
    // Target miner commits OutValue in Round N
    await SubmitUpdateValue(targetMiner, targetOutValue);
    await AdvanceToNextRound();
    
    // Round N+1: Attacker provides CORRUPTED DecryptedPiece
    var corruptedPiece = ByteString.CopyFrom(new byte[32]); // Wrong bytes
    var updateInput = new UpdateValueInput {
        DecryptedPieces = {
            { targetMiner.PublicKey, corruptedPiece } // Corrupted share
        }
    };
    
    // Submit attacker's UpdateValue with corrupted piece
    await SubmitUpdateValueWithPieces(attackerMiner, updateInput);
    
    // Trigger RevealSharedInValues by having another miner produce block
    await ProduceBlock(minerKeys[2]);
    
    // Verify: Check that PreviousInValue was set incorrectly
    var currentRound = await GetCurrentRound();
    var storedPreviousInValue = currentRound.RealTimeMinersInformation[targetMiner.PublicKey].PreviousInValue;
    
    // The stored value should NOT match the hash of correct InValue
    Assert.NotEqual(HashHelper.ComputeFrom(targetInValue), storedPreviousInValue);
    
    // Advance to next round where SupplyCurrentRoundInformation uses corrupted value
    await AdvanceToNextRound();
    
    // Verify: Signature calculated for target miner is corrupted
    var nextRound = await GetCurrentRound();
    var suppliedSignature = nextRound.RealTimeMinersInformation[targetMiner.PublicKey].Signature;
    
    // Calculate what signature SHOULD be with correct InValue
    var expectedSignature = CalculateExpectedSignature(targetInValue, previousRound);
    Assert.NotEqual(expectedSignature, suppliedSignature);
    
    // Consensus state is now corrupted
}
```

---

**Notes**

This vulnerability exploits a fundamental property of Shamir's Secret Sharing: the reconstruction algorithm always succeeds mathematically, regardless of whether the input shares are valid. Without additional verification (comparing reconstructed hash to committed OutValue) or using Verifiable Secret Sharing schemes with cryptographic commitments, there is no way to detect that shares have been corrupted. The attack is particularly insidious because it affects the consensus state silently - the corruption is stored normally and only manifests in downstream signature calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-293)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L21-23)
```csharp
        var minersCount = currentRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-65)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
                var denominator = BigInteger.One;
                for (var j = 0; j < threshold; j++)
                {
                    if (i == j) continue;

                    (numerator, denominator) =
                        MultiplyRational(numerator, denominator, orders[j], orders[j] - orders[i]);
                }

                result += RationalToWhole(numerator, denominator);
                result %= SecretSharingConsts.FieldPrime;
            }

            return result.ToBytesArray();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
