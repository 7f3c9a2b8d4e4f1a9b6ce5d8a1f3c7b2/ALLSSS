# Audit Report

## Title
Minter List State Pollution via Reference Mutation in GetMinterList

## Summary
The private `GetMinterList` method in the NFT contract mutates the cached state object by automatically adding the issuer to the minter list without using `.Clone()`, causing unintended persistent state changes. This creates an access control bypass where protocol creators cannot permanently revoke the issuer's minting permission via `RemoveMinters`.

## Finding Description

The vulnerability exists in the private `GetMinterList` helper function that retrieves and automatically modifies the minter list state. [1](#0-0) 

When this function accesses `State.MinterListMap[tokenInfo.Symbol]`, AElf's MappedState implementation returns a direct reference to the cached protobuf object. [2](#0-1) 

The critical issue is that modifying this cached object in-place causes the changes to be persisted to state during transaction finalization. The `GetChanges()` method detects modifications by comparing the cached `Value` against the `OriginalValue`. [3](#0-2) 

This function is called during minting operations through `PerformMint`, which is invoked by both the public `Mint` and `Assemble` methods. [4](#0-3) [5](#0-4) [6](#0-5) 

The contract demonstrates the correct pattern elsewhere by using `.Clone()` when reading from state to prevent unintended mutations, such as in the `Disassemble` and `Recast` functions. [7](#0-6) [8](#0-7) [9](#0-8) 

## Impact Explanation

This vulnerability creates an **access control bypass** in the NFT minting authorization system:

1. The protocol creator calls `RemoveMinters` to revoke the issuer's minting authorization. [10](#0-9) 

2. The next `Mint` or `Assemble` operation automatically re-adds the issuer to the persistent minter list through the `GetMinterList` mutation.

3. The issuer regains permanent minting permission, defeating the intended access control provided by `RemoveMinters`.

The impact is **LIMITED** because:
- No direct fund theft occurs
- Supply manipulation is still constrained by normal minting rules (total supply limits)
- The issuer is typically the protocol creator (a trusted role established during protocol creation) [11](#0-10) 

However, it violates the expected behavior of the access control system and prevents proper enforcement of minting authorization policies.

## Likelihood Explanation

This vulnerability triggers **automatically** with 100% likelihood:

- **Entry points**: The public `Mint` and `Assemble` functions are accessible to any authorized minter
- **Preconditions**: Only requires that a minter list exists in state (initialized during protocol creation)
- **Trigger mechanism**: No attacker action needed - the bug manifests through normal contract operation
- **Determinism**: The behavior occurs on every mint transaction after an attempt to remove the issuer from the minter list
- **Detection difficulty**: The mutation appears as a normal state update without error events

The MappedState reference behavior ensures this happens on every execution of the code path.

## Recommendation

Add `.Clone()` when retrieving the minter list from state to prevent reference mutation:

```csharp
private MinterList GetMinterList(TokenInfo tokenInfo)
{
    var minterList = (State.MinterListMap[tokenInfo.Symbol] ?? new MinterList()).Clone();
    if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);
    
    return minterList;
}
```

This follows the defensive coding pattern already established in other parts of the contract and ensures the cached state object is not modified.

## Proof of Concept

A test demonstrating this vulnerability would:

1. Create an NFT protocol with a creator as issuer
2. Call `RemoveMinters` to remove the issuer from the authorized minter list
3. Verify the issuer is removed by checking `GetMinterList`
4. Call `Mint` with another authorized minter
5. Check `GetMinterList` again - observe that the issuer has been automatically re-added to the persistent state

The issuer will have regained minting permission despite being explicitly removed, demonstrating the access control bypass.

---

## Notes

The severity is assessed as **LOW** rather than higher because:
- The issuer is typically the protocol creator (a trusted party)
- The issue affects authorization management, not fund security
- Minting is still subject to total supply constraints
- No external attacker can exploit this without already having minting permissions

However, this is a valid security issue that violates the intended access control semantics of the NFT contract and should be fixed to ensure proper authorization enforcement.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L12-19)
```csharp
    public override Hash Mint(MintInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var nftMinted = PerformMint(input);
        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-175)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L203-203)
```csharp
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L212-212)
```csharp
        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L268-268)
```csharp
        var oldMetadata = nftInfo.Metadata.Clone();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-398)
```csharp
        var minterList = GetMinterList(tokenInfo);
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-37)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
        }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L78-93)
```csharp
    internal override TransactionExecutingStateSet GetChanges()
    {
        var stateSet = new TransactionExecutingStateSet();
        foreach (var kv in Cache)
        {
            var key = GetSubStatePath(kv.Key.ToString()).ToStateKey(Context.Self);
            if (kv.Value.IsDeleted)
                stateSet.Deletes[key] = true;
            else if (!Equals(kv.Value.OriginalValue, kv.Value.Value))
                stateSet.Writes[key] = ByteString.CopyFrom(SerializationHelper.Serialize(kv.Value.Value));

            stateSet.Reads[key] = true;
        }

        return stateSet;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```
