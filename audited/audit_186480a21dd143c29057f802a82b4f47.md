# Audit Report

## Title
Consensus Corruption via Unvalidated Round Fields in NextRound Transition

## Summary
Critical consensus fields in the `Round` structure can be manipulated during NextRound transitions due to incomplete validation. A malicious block producer can inject arbitrary values for `ConfirmedIrreversibleBlockHeight`, `ExtraBlockProducerOfPreviousRound`, `MainChainMinersRoundNumber`, `IsMinerListJustChanged`, and `RoundIdForValidation` that bypass both before-execution and after-execution validation checks, enabling consensus state corruption with severe impact on block production, finality tracking, and secret sharing.

## Finding Description

The vulnerability stems from a fundamental gap in the consensus validation architecture where critical Round fields are excluded from hash-based integrity checks.

**Root Cause:**

The `NextRoundInput.Create()` and `ToRound()` methods perform direct field copying without validation. [1](#0-0) 

**Validation Gap - Before Execution:**

For NextRound behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are applied. [2](#0-1) 

The `RoundTerminateValidationProvider` only validates that round number increments by 1 and InValues are null. [3](#0-2) 

Critically, `LibInformationValidationProvider` does NOT run for NextRound behavior (only for UpdateValue), leaving `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` unvalidated. [4](#0-3) 

**Validation Gap - After Execution:**

The after-execution validation compares Round hashes using `GetHash()`. [5](#0-4) 

However, `GetCheckableRound()` only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge` in the hash calculation. [6](#0-5) 

The Round protobuf defines 10 fields, but 6 are excluded from validation. [7](#0-6) 

**Execution Path:**

When `NextRound` is called, `ProcessConsensusInformation` invokes `ProcessNextRound()` which calls `input.ToRound()` to convert the unvalidated input and writes it to state via `AddRoundInformation()`. [8](#0-7) 

**Attack Scenario:**

A malicious miner can:
1. Generate legitimate consensus extra data with correct RoundNumber (N+1) and null InValues
2. Craft a `NextRoundInput` transaction with the same validated fields but manipulated excluded fields
3. Include the transaction in their block alongside the legitimate extra data
4. Before-execution validation checks only the extra data's RoundNumber and InValues - passes
5. Transaction executes, writing the manipulated Round to state
6. After-execution validation compares hashes using `GetCheckableRound()` which excludes the manipulated fields - passes

## Impact Explanation

**HIGH Severity - Direct Consensus Corruption:**

1. **LIB Manipulation and DoS**: The `ConfirmedIrreversibleBlockHeight` field is used in blockchain health evaluation. [9](#0-8)  Setting this incorrectly high causes the blockchain to enter Abnormal or Severe status, reducing block production capacity to 1 block per miner and firing `IrreversibleBlockHeightUnacceptable` events, effectively causing a denial-of-service condition.

2. **Unauthorized Mining Privileges**: The `ExtraBlockProducerOfPreviousRound` field determines which miner can produce extra tiny blocks before the new round officially starts. [10](#0-9)  A malicious miner can set this to their own public key, granting themselves additional block production rights and extended time slots that should belong to the legitimate extra block producer.

3. **Secret Sharing Disruption**: The `IsMinerListJustChanged` flag controls whether secret sharing occurs. [11](#0-10)  Setting this incorrectly to `true` skips the `SecretSharingInformation` event, disrupting the cryptographic random number generation mechanism essential for consensus security.

4. **Cross-Chain State Corruption**: For side chains, `MainChainMinersRoundNumber` tracks synchronization with the main chain. Manipulation corrupts cross-chain consensus validation and miner list updates, potentially enabling side chain attacks.

The cumulative impact is severe consensus corruption affecting finality guarantees, mining fairness, random number security, and cross-chain integrity.

## Likelihood Explanation

**HIGH Likelihood:**

**Attacker Profile:** Any current block producer (miner) in the active miner set can execute this attack. No special privileges beyond legitimate mining rights are required.

**Attack Complexity:** LOW - The attacker simply needs to:
1. Use normal consensus API calls to get legitimate extra data
2. Manually construct a `NextRoundInput` with manipulated excluded fields
3. Include this transaction in their block instead of the auto-generated one

**Preconditions:** The attacker must be an active miner, which is the standard operational state for any current consensus participant.

**Detection:** NONE - The current validation logic has no mechanism to detect this manipulation. The malicious values are written to state and will affect subsequent consensus decisions without raising any alerts until the corruption manifests as observable consensus failures.

**Reproducibility:** This is deterministically reproducible on any AElf chain whenever a NextRound transition occurs and the block producer is malicious.

## Recommendation

Implement comprehensive validation for all consensus-critical Round fields during NextRound transitions:

1. **Add LibInformationValidationProvider for NextRound:** Extend the before-execution validation to include LIB field checks for NextRound behavior, not just UpdateValue.

2. **Expand GetCheckableRound() to include all critical fields:** Modify the hash calculation to include:
   - `ConfirmedIrreversibleBlockHeight`
   - `ConfirmedIrreversibleBlockRoundNumber`
   - `ExtraBlockProducerOfPreviousRound`
   - `IsMinerListJustChanged`
   - `MainChainMinersRoundNumber`
   - `RoundIdForValidation`

3. **Add explicit field validation in ProcessNextRound():** Before calling `AddRoundInformation()`, validate that the excluded fields match expected values based on current state and the legitimate consensus extra data.

4. **Implement cryptographic binding:** Consider adding a signature or hash commitment in the consensus extra data that covers ALL Round fields, ensuring the transaction must match the header data.

## Proof of Concept

This vulnerability can be demonstrated by constructing a test where:
1. A miner generates consensus extra data for round N+1 with legitimate values
2. The miner crafts a NextRoundInput with correct RoundNumber but sets `ConfirmedIrreversibleBlockHeight` to an arbitrary high value (e.g., current height + 1000000)
3. The miner includes this transaction in their block
4. Both `ValidateConsensusBeforeExecution` and `ValidateConsensusAfterExecution` pass
5. State verification shows the manipulated `ConfirmedIrreversibleBlockHeight` is written to the Round
6. Subsequent calls to `GetMaximumBlocksCount()` return 1 instead of the normal value, demonstrating DoS impact

The test would verify that the manipulated field bypasses validation and successfully corrupts consensus state, proving the vulnerability is exploitable.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-40)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }

    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-83)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** protobuf/aedpos_contract.proto (L243-264)
```text
message Round {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producersâ€™ expecting time (second).
    int64 round_id_for_validation = 10;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-67)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-178)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-115)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });
```
