# Audit Report

## Title
RemoveSubScheme Fails to Update CachedDelayTotalShares Leading to Profit Misallocation

## Summary
The `RemoveSubScheme` function in ProfitContract does not update the `CachedDelayTotalShares` map when removing a sub-scheme, unlike the analogous `RemoveBeneficiary` function. This inconsistency causes stale cached share values to persist and be used during profit distribution in schemes with delayed distribution enabled (`DelayDistributePeriodCount > 0`), resulting in inflated total shares calculations that cause legitimate beneficiaries to receive less than their entitled share of profits.

## Finding Description

The vulnerability stems from an implementation inconsistency between two related functions in the Profit contract:

**The Vulnerable Function - RemoveSubScheme:** [1](#0-0) 

This function removes a sub-scheme by:
1. Clearing the profit details for the sub-scheme's virtual address
2. Removing the sub-scheme from the `SubSchemes` list
3. Updating `TotalShares` to subtract the removed shares
4. **BUT does NOT update `CachedDelayTotalShares`**

**The Correct Implementation - RemoveBeneficiary:** [2](#0-1) 

This function properly handles delayed distribution by iterating through affected cached periods and subtracting the removed shares from each cached entry.

**How Delayed Distribution Works:**

When `DistributeProfits` is called for a scheme with `DelayDistributePeriodCount > 0`, it caches the current `TotalShares` for future periods: [3](#0-2) 

The cached `totalShares` value is then stored in `DistributedProfitsInfo.TotalShares`: [4](#0-3) 

When beneficiaries claim profits, this stored `TotalShares` is used as the denominator in the profit calculation: [5](#0-4) 

**Why AddSubScheme Also Participates:**

When adding a sub-scheme, the function internally calls `AddBeneficiary` which properly handles delayed distribution: [6](#0-5) 

This means when a sub-scheme is added, its shares are correctly cached for future periods. When it's removed via `RemoveSubScheme`, the cached values are NOT updated, leaving stale inflated totals.

**Production Impact - TreasuryContract:**

The TreasuryContract creates the Welfare scheme with delayed distribution enabled: [7](#0-6) 

The TreasuryContract also uses `RemoveSubScheme` in its `ResetWeight` function to adjust sub-scheme allocations: [8](#0-7) 

This demonstrates the vulnerability can occur in production during legitimate weight adjustment operations.

## Impact Explanation

**Direct Financial Impact:**

When a sub-scheme is added and subsequently removed before the delayed period arrives:

1. **Period N**: Sub-scheme added with X shares → `TotalShares` increases, cached as `CachedDelayTotalShares[N + DelayDistributePeriodCount]`
2. **Period N**: `DistributeProfits` called → caches the inflated total (including X shares)
3. **Period N+1**: Sub-scheme removed → `TotalShares` decreases, but cached value remains unchanged
4. **Period N+DelayDistributePeriodCount**: Distribution uses the stale cached value with inflated denominator
5. **Result**: Each beneficiary receives `(theirShares / inflatedTotal) * amount` instead of `(theirShares / actualTotal) * amount`

**Quantified Example:**
- Initial state: 100 shares from regular beneficiaries, `DelayDistributePeriodCount = 2`
- Period 1: Add sub-scheme with 100 shares → `TotalShares = 200`, `CachedDelayTotalShares[3] = 200`
- Period 1: Distribute 1000 ELF
- Period 2: Remove sub-scheme → `TotalShares = 100`, but `CachedDelayTotalShares[3]` still `= 200`
- Period 3: Distribution uses cached `totalShares = 200`
- **Impact**: Beneficiaries with 100 shares receive only 500 ELF (100/200 × 1000) instead of 1000 ELF
- **Loss**: 50% underpayment to legitimate beneficiaries, 500 ELF permanently locked in period virtual address

**Locked Funds:**
The unclaimed portion cannot be recovered because no beneficiary has sufficient shares to claim it under the inflated denominator calculation.

## Likelihood Explanation

**Triggering Conditions:**

1. **Scheme Configuration**: Requires `DelayDistributePeriodCount > 0` - confirmed in production (TreasuryContract Welfare scheme)
2. **Manager Permissions**: Requires scheme manager authority for `AddSubScheme`/`RemoveSubScheme` - this is by design
3. **Operational Sequence**: Normal operations like weight rebalancing via `ResetWeight` can trigger this

**Realistic Scenarios:**

1. **Legitimate Operations**: TreasuryContract's `ResetWeight` function legitimately calls `RemoveSubScheme` to adjust reward distribution weights between schemes. If this occurs during a delayed distribution period, the bug triggers automatically.

2. **Governance Changes**: Protocol governance may decide to adjust sub-scheme allocations for economic policy reasons, inadvertently triggering the vulnerability.

3. **No Detection**: The issue is silent - no transaction reverts, no events indicate the problem. Beneficiaries only discover underpayment when they claim and notice the shortfall.

**Probability Assessment:**

While requiring manager access, this is not a malicious attack scenario but rather a **logic bug that occurs during legitimate operations**. The TreasuryContract demonstrates this functionality is actively used in production. The probability of occurrence is MEDIUM-HIGH given:
- Production code uses both features together (delayed distribution + RemoveSubScheme)
- No warnings or checks prevent this scenario
- Can happen accidentally during routine adjustments

## Recommendation

Update `RemoveSubScheme` to mirror the `RemoveBeneficiary` logic for handling `CachedDelayTotalShares`. After line 152 in `RemoveSubScheme`, add:

```csharp
// Update cached delay total shares (similar to RemoveBeneficiary)
if (scheme.DelayDistributePeriodCount > 0)
{
    var currentPeriod = scheme.CurrentPeriod;
    for (var period = currentPeriod; 
         period < currentPeriod.Add(scheme.DelayDistributePeriodCount); 
         period++)
    {
        if (scheme.CachedDelayTotalShares.ContainsKey(period))
        {
            scheme.CachedDelayTotalShares[period] = 
                scheme.CachedDelayTotalShares[period].Sub(shares.Shares);
        }
    }
}
```

This ensures consistency with `RemoveBeneficiary` and prevents stale cached values from persisting.

## Proof of Concept

```csharp
[Fact]
public async Task RemoveSubScheme_DoesNotUpdate_CachedDelayTotalShares_Test()
{
    // Setup: Create scheme with delayed distribution
    var creator = Creators[0];
    var delayPeriods = 2;
    var schemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        IsReleaseAllBalanceEveryTimeByDefault = true,
        DelayDistributePeriodCount = delayPeriods
    });
    
    // Add regular beneficiary with 100 shares
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare
        {
            Beneficiary = Accounts[1].Address,
            Shares = 100
        },
        EndPeriod = long.MaxValue
    });
    
    // Period 1: Add sub-scheme with 100 shares
    var subSchemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput());
    await creator.AddSubScheme.SendAsync(new AddSubSchemeInput
    {
        SchemeId = schemeId.Output,
        SubSchemeId = subSchemeId.Output,
        SubSchemeShares = 100
    });
    
    var scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.TotalShares.ShouldBe(200); // 100 + 100
    
    // Period 1: Distribute - this caches TotalShares=200 for period 3
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Symbol = "ELF",
        Amount = 1000
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.CachedDelayTotalShares[3].ShouldBe(200); // Cached for period 3
    
    // Period 2: Remove sub-scheme
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = 2,
        AmountsMap = { { "ELF", 0 } }
    });
    
    await creator.RemoveSubScheme.SendAsync(new RemoveSubSchemeInput
    {
        SchemeId = schemeId.Output,
        SubSchemeId = subSchemeId.Output
    });
    
    scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.TotalShares.ShouldBe(100); // Updated correctly
    
    // BUG: CachedDelayTotalShares[3] should be 100 but remains 200
    scheme.CachedDelayTotalShares[3].ShouldBe(200); // VULNERABILITY CONFIRMED
    
    // Period 3: Distribution uses inflated cached value
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Symbol = "ELF",
        Amount = 1000,
        Period = 3
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = 3,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    var distributedInfo = await creator.GetDistributedProfitsInfo.CallAsync(
        new SchemePeriod { SchemeId = schemeId.Output, Period = 3 });
    
    // BUG: Uses inflated totalShares of 200 instead of correct 100
    distributedInfo.TotalShares.ShouldBe(200); // Should be 100
    
    // Beneficiary receives only 50% of what they should
    // Expected: (100/100) * 1000 = 1000 ELF
    // Actual: (100/200) * 1000 = 500 ELF
    // 500 ELF permanently locked
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L109-118)
```csharp
        AddBeneficiary(new AddBeneficiaryInput
        {
            SchemeId = input.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = subSchemeVirtualAddress,
                Shares = input.SubSchemeShares
            },
            EndPeriod = long.MaxValue
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L131-156)
```csharp
    public override Empty RemoveSubScheme(RemoveSubSchemeInput input)
    {
        Assert(input.SchemeId != input.SubSchemeId, "Two schemes cannot be same.");

        var scheme = State.SchemeInfos[input.SchemeId];
        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(Context.Sender == scheme.Manager, "Only manager can remove sub-scheme.");

        var shares = scheme.SubSchemes.SingleOrDefault(d => d.SchemeId == input.SubSchemeId);
        if (shares == null) return new Empty();

        var subSchemeId = input.SubSchemeId;
        var subScheme = State.SchemeInfos[subSchemeId];
        Assert(subScheme != null, "Sub scheme not found.");

        var subSchemeVirtualAddress = Context.ConvertVirtualAddressToContractAddress(subSchemeId);
        // Remove profit details
        State.ProfitDetailsMap[input.SchemeId][subSchemeVirtualAddress] = new ProfitDetails();
        scheme.SubSchemes.Remove(shares);
        scheme.TotalShares = scheme.TotalShares.Sub(shares.Shares);
        State.SchemeInfos[input.SchemeId] = scheme;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L60-67)
```csharp
            State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
            {
                IsReleaseAllBalanceEveryTimeByDefault = true,
                // Distribution of Citizen Welfare will delay one period.
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
                // Subsidy, Flexible Reward and Welcome Reward can remove beneficiary directly (due to replaceable.)
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L520-540)
```csharp
    private void ResetWeight(Hash parentSchemeId, Hash subSchemeId, int oldWeight,
        int newWeight)
    {
        if (oldWeight == newWeight)
            return;

        // old weight equals 0 indicates the subScheme has not been registered
        if (oldWeight > 0)
            State.ProfitContract.RemoveSubScheme.Send(new RemoveSubSchemeInput
            {
                SchemeId = parentSchemeId,
                SubSchemeId = subSchemeId
            });

        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = parentSchemeId,
            SubSchemeId = subSchemeId,
            SubSchemeShares = newWeight
        });
    }
```
