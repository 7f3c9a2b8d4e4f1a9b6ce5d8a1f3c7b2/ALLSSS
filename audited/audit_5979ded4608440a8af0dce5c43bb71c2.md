### Title
Unvalidated Parent Chain Creation Height Causes Permanent Cross-Chain System Failure

### Summary
The `Initialize` method does not validate that `CreationHeightOnParentChain` exceeds the genesis block height before computing `CurrentParentChainHeight`. If a side chain is initialized with `CreationHeightOnParentChain = 1` (genesis height), the resulting `CurrentParentChainHeight = 0` violates the invariant enforced by `GetAllChainsIdAndHeight()`, causing permanent failure of all cross-chain indexing operations.

### Finding Description

The vulnerability exists in the CrossChain contract initialization sequence:

**Root Cause:** [1](#0-0) 

The `Initialize` method sets `State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1` without validating that `input.CreationHeightOnParentChain` exceeds `AElfConstants.GenesisBlockHeight` (value = 1). [2](#0-1) 

**Invariant Violation:** [3](#0-2) 

The `GetAllChainsIdAndHeight()` method enforces a critical invariant at line 125: `Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height")`. This requires that if a parent chain exists, the recorded height must be greater than 1.

**Why Protections Fail:**
When `CreationHeightOnParentChain = 1` (a side chain created at parent chain genesis):
- Initialization sets: `CurrentParentChainHeight = 1 - 1 = 0`
- `GetParentChainHeight()` returns 0 (no validation) [4](#0-3) 
- `GetAllChainsIdAndHeight()` assertion fails: `0 > 1` is false

**Critical Execution Paths:** [5](#0-4) [6](#0-5) 

Both `FinishInitialSyncAsync()` and `UpdateCrossChainDataWithLibAsync()` call `GetAllChainIdHeightPairsAtLibAsync()`, which internally calls the failing `GetAllChainsIdAndHeight()` contract method.

### Impact Explanation

**Operational Harm:**
- Complete and permanent failure of cross-chain indexing system on the affected side chain
- The side chain cannot register or update parent chain heights in its cache
- All parent chain block data indexing operations fail
- Cross-chain transaction verification becomes impossible

**Severity Justification:**
This is a **High severity** vulnerability because:
1. It causes complete DoS of the cross-chain functionality, a core feature
2. The failure is **permanent** - it cannot be recovered without redeploying the entire side chain
3. It's a state corruption issue occurring at genesis (initialization)
4. No workaround exists once the contract is initialized with invalid height

**Affected Parties:**
- Side chain operators whose chain is created at parent chain genesis height
- All users attempting cross-chain operations on the affected side chain
- The broader AElf cross-chain ecosystem if misconfiguration occurs

### Likelihood Explanation

**Feasibility Conditions:**
This vulnerability manifests when:
1. A side chain is legitimately created immediately after parent chain genesis (rare but valid edge case)
2. The initialization data provider has a configuration error setting `CreationHeightOnParentChain = 1` or `0`
3. Testing/deployment on fresh chains where parent is at genesis

**Execution Practicality:**
- The `Initialize` method is called once at side chain genesis through the contract initialization provider [7](#0-6) 
- No attacker action required - this is a configuration/deployment issue
- Automatically triggers on first call to `GetAllChainsIdAndHeight()` during cross-chain sync

**Probability Assessment:**
- **Medium-Low** in production (most side chains created after parent has blocks)
- **Higher** in development/testing environments with fresh chains
- Once occurred, 100% reproducible failure on every cross-chain sync attempt

### Recommendation

**Validation Fix:**
Add input validation to the `Initialize` method immediately after the existing initialization check:

```csharp
public override Empty Initialize(InitializeInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    // ADD THIS VALIDATION:
    Assert(input.ParentChainId == 0 || input.CreationHeightOnParentChain > AElfConstants.GenesisBlockHeight, 
        "Creation height on parent chain must be greater than genesis height.");
    
    State.ParentChainId.Value = input.ParentChainId;
    State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
    // ... rest of initialization
}
```

**Test Case:**
Add regression test verifying initialization fails with invalid `CreationHeightOnParentChain`:
- Test with `CreationHeightOnParentChain = 0`: Should fail with clear error
- Test with `CreationHeightOnParentChain = 1`: Should fail with clear error  
- Test with `CreationHeightOnParentChain = 2`: Should succeed (minimum valid value)

**Additional Safeguard:**
Consider adding a defensive check in `GetParentChainHeight()` to detect corrupted state, though the proper fix is prevention at initialization.

### Proof of Concept

**Required Initial State:**
- Fresh AElf side chain deployment
- Parent chain at or near genesis height

**Transaction Steps:**
1. Deploy CrossChain contract with initialization call:
   - `input.ParentChainId = 123` (valid parent chain ID)
   - `input.CreationHeightOnParentChain = 1` (parent chain genesis height)

2. Initialization executes successfully but sets invalid state:
   - `State.ParentChainId.Value = 123`
   - `State.CurrentParentChainHeight.Value = 0` (violates invariant)

3. Cross-chain sync initialization attempts to call:
   - `CrossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync()`
   - Which calls `CrossChainContract.GetAllChainsIdAndHeight()`

**Expected Result:**
All cross-chain operations should work normally.

**Actual Result:**
`GetAllChainsIdAndHeight()` throws assertion error: "Invalid parent chain height" because `0 > 1` evaluates to false. This permanently breaks:
- Initial cross-chain synchronization
- All subsequent cross-chain cache updates
- Parent chain block indexing
- Cross-chain transaction verification

**Success Condition:**
The vulnerability is confirmed if calling `GetAllChainsIdAndHeight()` after initialization with `CreationHeightOnParentChain = 1` results in an assertion failure, making the cross-chain system permanently inoperable.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L14-31)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.ParentChainId.Value = input.ParentChainId;
        State.CurrentParentChainHeight.Value = input.CreationHeightOnParentChain - 1;
        State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();

        CreateInitialOrganizationForInitialControllerAddress();
        State.Initialized.Value = true;

        if (Context.CurrentHeight != AElfConstants.GenesisBlockHeight)
            return new Empty();

        State.GenesisContract.Value = Context.GetZeroSmartContractAddress();
        State.GenesisContract.SetContractProposerRequiredState.Send(
            new BoolValue { Value = input.IsPrivilegePreserved });
        return new Empty();
    }
```

**File:** src/AElf.Types/AElfConstants.cs (L1-10)
```csharp
namespace AElf
{

    public static class AElfConstants
    {
        public const long GenesisBlockHeight = 1;
        public const int HashByteArrayLength = 32;
        public const int AddressHashLength = 32;
    }
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L63-72)
```csharp
    public override Int64Value GetParentChainHeight(Empty input)
    {
        var parentChainId = State.ParentChainId.Value;
        Assert(parentChainId != 0, "Parent chain not exist.");
        var parentChainHeight = State.CurrentParentChainHeight.Value;
        return new Int64Value
        {
            Value = parentChainHeight
        };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L118-128)
```csharp
    public override ChainIdAndHeightDict GetAllChainsIdAndHeight(Empty input)
    {
        var dict = GetSideChainIdAndHeight(new Empty());

        if (State.ParentChainId.Value == 0)
            return dict;
        var parentChainHeight = GetParentChainHeight(new Empty()).Value;
        Assert(parentChainHeight > AElfConstants.GenesisBlockHeight, "Invalid parent chain height");
        dict.IdHeightDict.Add(State.ParentChainId.Value, parentChainHeight);
        return dict;
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataService.cs (L157-176)
```csharp
    public async Task<ChainIdAndHeightDict> GetAllChainIdHeightPairsAtLibAsync()
    {
        var isReadyToCreateChainCache =
            await _irreversibleBlockStateProvider.ValidateIrreversibleBlockExistingAsync();
        if (!isReadyToCreateChainCache)
            return new ChainIdAndHeightDict();
        var lib = await _irreversibleBlockStateProvider.GetLastIrreversibleBlockHashAndHeightAsync();
        return await _contractReaderFactory
            .Create(new ContractReaderContext
            {
                BlockHash = lib.BlockHash,
                BlockHeight = lib.BlockHeight,
                ContractAddress = await GetCrossChainContractAddressAsync(new ChainContext
                {
                    BlockHash = lib.BlockHash,
                    BlockHeight = lib.BlockHeight
                })
            }).GetAllChainsIdAndHeight
            .CallAsync(new Empty());
    }
```

**File:** src/AElf.CrossChain/Application/CrossChainService.cs (L26-48)
```csharp
    public async Task FinishInitialSyncAsync()
    {
        CrossChainConfigOptions.Value.CrossChainDataValidationIgnored = false;
        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();
        foreach (var chainIdHeight in chainIdHeightPairs.IdHeightDict)
            // register new chain
            _crossChainCacheEntityService.RegisterNewChain(chainIdHeight.Key, chainIdHeight.Value);
    }

    public async Task UpdateCrossChainDataWithLibAsync(Hash blockHash, long blockHeight)
    {
        if (CrossChainConfigOptions.Value.CrossChainDataValidationIgnored
            || blockHeight <= AElfConstants.GenesisBlockHeight)
            return;

        _crossChainIndexingDataService.UpdateCrossChainDataWithLib(blockHash, blockHeight);

        var chainIdHeightPairs =
            await _crossChainIndexingDataService.GetAllChainIdHeightPairsAtLibAsync();

        await _crossChainCacheEntityService.UpdateCrossChainCacheAsync(blockHash, blockHeight, chainIdHeightPairs);
    }
```

**File:** src/AElf.CrossChain.Core/CrossChainContractInitializationProvider.cs (L23-39)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        var initializationData = _crossChainContractInitializationDataProvider.GetContractInitializationData();
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(CrossChainContractImplContainer.CrossChainContractImplStub.Initialize),
                Params = new InitializeInput
                {
                    ParentChainId = initializationData.ParentChainId,
                    CreationHeightOnParentChain = initializationData.CreationHeightOnParentChain,
                    IsPrivilegePreserved = initializationData.IsPrivilegePreserved
                }.ToByteString()
            }
        };
    }
```
