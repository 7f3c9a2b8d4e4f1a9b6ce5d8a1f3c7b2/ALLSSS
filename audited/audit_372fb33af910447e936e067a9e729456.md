### Title
Unauthorized PreviousInValue Manipulation Breaks VRF Commit-Reveal Protocol in AEDPoS Consensus

### Summary
The `RecoverFromUpdateValue()` function unconditionally overwrites `PreviousInValue` for ALL miners from the provided round data, but validation only checks the sender's `PreviousInValue`. This allows a malicious miner to inject fake `PreviousInValue` data for other miners who haven't revealed yet, breaking the VRF commit-reveal protocol and enabling manipulation of consensus randomness.

### Finding Description

**Root Cause:**

The `RecoverFromUpdateValue()` function overwrites `PreviousInValue` for all miners in the round without any validation: [1](#0-0) 

When a miner produces a block, `GetUpdateValueRound()` includes `PreviousInValue` for ALL miners from the block producer's local state: [2](#0-1) 

**Validation Failure:**

During block validation, `UpdateValueValidationProvider` ONLY validates the sender's `PreviousInValue`, not other miners': [3](#0-2) 

The validation explicitly checks only the sender's public key and ignores all other miners' `PreviousInValue` data.

**Exploitation Path:**

1. During validation before execution, `RecoverFromUpdateValue` is called, overwriting all miners' `PreviousInValues`: [4](#0-3) 

2. During block execution, `PerformSecretSharing` applies `MinersPreviousInValues` to all miners without validation: [5](#0-4) 

3. The `MinersPreviousInValues` dictionary is populated from the block producer's local round state, which can be manipulated: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Compromise:**

- **VRF Randomness Manipulation**: `PreviousInValue` is used to calculate signatures that feed into random number generation via VRF. An attacker can influence consensus randomness by setting fake `PreviousInValues` for other miners.

- **Commit-Reveal Protocol Violation**: The AEDPoS protocol requires each miner to commit to their `InValue` (via `OutValue`) in one round and reveal it (via `PreviousInValue`) when they mine. Allowing any miner to reveal or set fake values for others completely breaks this cryptographic guarantee.

- **State Corruption**: Once injected, fake `PreviousInValues` persist in blockchain state and propagate to subsequent blocks, as they are collected and redistributed via `MinersPreviousInValues`.

- **No Authentication**: There is no cryptographic proof that the party setting a `PreviousInValue` actually knows the corresponding `InValue` or has any authority to reveal it.

**Affected Parties:**
- All honest miners whose `PreviousInValues` can be forged
- The entire consensus mechanism relying on VRF randomness
- Any protocol features depending on unpredictable random numbers (election outcomes, block producer selection, etc.)

### Likelihood Explanation

**Attack Requirements:**
- Attacker controls at least one miner node (realistic in PoS/DPoS systems)
- Attacker can modify their node's consensus state (standard assumption for malicious node operators)
- No special timing or coordination required

**Execution Practicality:**
- Attacker waits for their scheduled time slot
- Modifies local round state to include fake `PreviousInValues` for target miners
- Produces block normally; validation passes because only sender's `PreviousInValue` is checked
- Fake values become part of canonical blockchain state

**Detection Difficulty:**
- No cryptographic validation of other miners' `PreviousInValues`
- Validators cannot distinguish fake from legitimate values without additional checks
- Attack leaves no obvious trace in logs or events

**Economic Rationality:**
- Attack cost: standard block production cost
- Potential gain: influence over consensus randomness, which affects block producer selection and election outcomes
- Highly profitable for an attacker seeking to manipulate validator selection or predict/influence future random values

### Recommendation

**Immediate Fix:**

1. **Remove lines 28-29** from `RecoverFromUpdateValue()` that unconditionally overwrite all miners' `PreviousInValues`. Only the sender should be allowed to set their own `PreviousInValue`. [7](#0-6) 

2. **Validate other miners' PreviousInValues** in `PerformSecretSharing` by checking that they can only be set through legitimate secret sharing reveals, not arbitrary input: [8](#0-7) 

Modify line 296 to only accept `PreviousInValue` if it's either:
- Already set (don't overwrite existing values)
- Being set via cryptographic secret sharing with sufficient decrypted pieces
- Being set by the miner themselves during their own block production

3. **Add cryptographic validation** that when a miner sets another's `PreviousInValue` via secret sharing, verify that the revealed value correctly hashes to the previously committed `OutValue`.

4. **Audit GetUpdateValueRound** to ensure it doesn't include other miners' `PreviousInValues` in simplified rounds unless absolutely necessary and properly validated: [9](#0-8) 

**Test Cases:**
- Verify that a miner cannot set `PreviousInValue` for another miner who hasn't mined yet
- Verify that attempting to overwrite an existing legitimate `PreviousInValue` fails validation
- Verify that secret sharing reveals properly validate the hash relationship between `InValue` and `OutValue`
- Verify that `MinersPreviousInValues` dictionary only propagates validated values

### Proof of Concept

**Initial State:**
- Round N with miners A, B, C
- Miner B has committed `OutValue_B` in round N-1 but hasn't mined in round N yet (no `PreviousInValue_B` set)
- Miner A's time slot arrives

**Attack Steps:**

1. Attacker (Miner A) modifies their node to set fake `PreviousInValue_B = Hash("fake")` in local round state

2. Miner A produces block at their time slot:
   - `GetUpdateValueRound()` called, includes fake `PreviousInValue_B` at line 51
   - Block header contains simplified round with fake value

3. Validators process the block:
   - `ValidateBeforeExecution` calls `RecoverFromUpdateValue` at line 47
   - Lines 28-29 overwrite `PreviousInValue_B` with fake value
   - `UpdateValueValidationProvider` validates ONLY Miner A's `PreviousInValue`, not B's
   - Validation passes

4. Block execution:
   - `ProcessUpdateValue` called
   - `PerformSecretSharing` applies `MinersPreviousInValues` at lines 295-296
   - Fake `PreviousInValue_B` written to blockchain state

**Expected Result:**
Validation should reject the block because Miner A has no authority to reveal Miner B's `PreviousInValue`

**Actual Result:**
Block is accepted and fake `PreviousInValue_B` becomes part of canonical blockchain state, breaking the commit-reveal protocol and allowing Miner A to manipulate randomness calculation

**Success Condition:**
Query blockchain state after block execution shows `RealTimeMinersInformation[B].PreviousInValue == Hash("fake")` instead of the legitimate value Miner B would have revealed

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L35-53)
```csharp
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L30-33)
```csharp
        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```
