### Title
State Inconsistency in RemoveBeneficiary Allows Orphaned Lock State and Profit Loss

### Summary
The `RemoveBeneficiary` function removes or reduces a beneficiary's profit shares in the Profit contract but fails to unlock their tokens or clean up the `LockIds` mapping when called on users who registered via `RegisterForProfits`. This creates an orphaned state where users have locked tokens without corresponding profit shares, causing them to lose expected dividends while their funds remain locked for the `MinimumLockMinutes` period.

### Finding Description

The vulnerability exists in the `RemoveBeneficiary` function which only updates profit distribution shares without managing the associated token locks and state mappings. [1](#0-0) 

When a user calls `RegisterForProfits`, three state changes occur:
1. Tokens are locked in the MultiToken contract
2. A `LockIds` mapping entry is created
3. The user is added as a beneficiary in the Profit contract [2](#0-1) 

The `LockIds` mapping stores the relationship between scheme managers, users, and their lock IDs: [3](#0-2) 

However, `RemoveBeneficiary` only interacts with the Profit contract to remove or reduce beneficiary shares (lines 74-95). It does NOT:
- Unlock tokens in the MultiToken contract
- Remove the `LockIds` mapping entry  
- Update the locked token amount

This creates an inconsistent state where:
- `State.LockIds[schemeManager][user]` still exists
- User's tokens remain locked with the MultiToken contract
- User is removed/reduced in the Profit contract and receives no/reduced profits

The `Withdraw` function expects to clean up this state but requires `MinimumLockMinutes` to elapse: [4](#0-3) 

The Profit contract's `RemoveBeneficiary` silently succeeds even if the beneficiary is already removed, masking the inconsistency: [5](#0-4) 

### Impact Explanation

**Financial Impact:**
- Users lose expected profit distributions for the entire duration their tokens remain locked (up to `MinimumLockMinutes`)
- If a scheme distributes profits multiple times during the lock period, users receive none of these profits despite having locked tokens
- Opportunity cost: tokens are locked and cannot be used elsewhere while generating no returns

**State Consistency Impact:**
- Violates the invariant that locked tokens should earn profit shares
- Creates orphaned `LockIds` entries that reference locked tokens with no corresponding profit beneficiary status
- Token lock amount and profit shares become desynchronized

**Affected Parties:**
- Any user who called `RegisterForProfits` and had the scheme manager subsequently call `RemoveBeneficiary` on them
- In schemes with long `MinimumLockMinutes` values (e.g., 90 days), users could lose months of profit distributions

The documentation provides no warning about this behavior: [6](#0-5) 

### Likelihood Explanation

**Attacker Capabilities:**
- Requires the scheme manager to call `RemoveBeneficiary` on users who registered via `RegisterForProfits`
- Scheme manager is set at scheme creation time to `Context.Sender` [7](#0-6) 

**Feasibility:**
- The scheme manager role is a privileged position, but could be:
  - A malicious actor from the start
  - A compromised account
  - An automated contract with flawed logic
- Users lock tokens trusting they will receive profits, but have no protection against this scenario
- There are no checks preventing `RemoveBeneficiary` from being called on users with locked tokens

**Detection:**
- Users would notice when they don't receive expected profit distributions
- However, by the time they notice, their tokens are already locked and cannot be withdrawn until `MinimumLockMinutes` expires
- No test coverage exists for the `RegisterForProfits` + `RemoveBeneficiary` scenario, indicating this case was not considered

### Recommendation

**Code-Level Mitigation:**

Add a check in `RemoveBeneficiary` to prevent removal of beneficiaries who have locked tokens via `RegisterForProfits`:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens via RegisterForProfits
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, 
        "Cannot remove beneficiary with locked tokens. User must withdraw first.");
    
    // ... rest of existing logic
}
```

**Invariant Checks:**
- Enforce that `LockIds` entry exists if and only if user is a beneficiary with shares equal to locked amount
- Add assertion: if `State.LockIds[manager][user]` exists, user must be a beneficiary in the Profit contract
- Validate that token unlock operations always accompany beneficiary removal for users who locked tokens

**Test Cases:**
1. Test that `RemoveBeneficiary` fails when called on a user who registered via `RegisterForProfits`
2. Test that only `Withdraw` (called by the user) can remove a beneficiary who has locked tokens
3. Test state consistency: verify `LockIds`, locked tokens, and profit shares remain synchronized
4. Test that `RemoveBeneficiary` still works correctly for beneficiaries added via `AddBeneficiary` (no token locks)

### Proof of Concept

**Initial State:**
- Scheme manager creates a scheme with `MinimumLockMinutes = 129600` (90 days)
- User has 1000 ELF tokens

**Attack Sequence:**

1. User calls `RegisterForProfits` with 1000 ELF
   - Expected: Tokens locked, user added as beneficiary with 1000 shares
   - State: `LockIds[manager][user] = lockId`, locked amount = 1000 ELF, profit shares = 1000

2. Scheme manager calls `RemoveBeneficiary` with user's address and amount = 0 (full removal)
   - Expected: Should fail or unlock tokens
   - Actual: Succeeds, user removed from Profit contract
   - State: `LockIds[manager][user]` still exists, locked amount = 1000 ELF, profit shares = 0

3. Scheme distributes profits via `DistributeProfits`
   - Expected: User should receive profits proportional to their 1000 locked tokens
   - Actual: User receives nothing (not a beneficiary)

4. User attempts to call `Withdraw` immediately
   - Expected: Should recover tokens
   - Actual: Fails due to `MinimumLockMinutes` check - "Cannot withdraw"
   - User must wait 90 days while receiving no profits on locked tokens

**Success Condition:**
User's tokens remain locked for 90 days without earning any profit distributions, while `LockIds` entry remains orphaned, demonstrating the state inconsistency vulnerability.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-244)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-15)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-235)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** docs/resources/smart-contract-apis/token-holder.md (L35-50)
```markdown
## **RemoveBeneficiary**

```Protobuf
rpc RemoveBeneficiary (RemoveTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) { }

message RemoveTokenHolderBeneficiaryInput {
    aelf.Address beneficiary = 1;
    sint64 amount = 2;
}
```

Note: this method can be used to remove a beneficiary or update its shares.

**RemoveTokenHolderBeneficiaryInput**:
- **beneficiary**: the beneficiary to remove or update.
- **amount**: 0 to remove the beneficiary. A positive integer, smaller than the current shares. 
```
