# Audit Report

## Title
Cross-Chain Token Creation Bypasses TokenName Length Validation Allowing Unbounded Names

## Summary
The `CrossChainCreateToken` method does not validate the `TokenName` length against the 80-character protocol limit, allowing tokens with arbitrarily large names to be created via cross-chain transfers. This creates a validation inconsistency where locally-created tokens enforce strict name length limits while cross-chain imported tokens do not.

## Finding Description

The vulnerability exists due to a validation bypass in the cross-chain token creation path compared to the local token creation path.

**Local Token Creation Path (Protected):**
The `CreateToken` method enforces token name length validation [1](#0-0)  by calling `AssertValidCreateInput`, which validates that token names do not exceed the maximum length [2](#0-1) . The constant `TokenNameLength` is defined as 80 characters [3](#0-2) .

**Cross-Chain Token Creation Path (Vulnerable):**
The `CrossChainCreateToken` method constructs a `TokenInfo` object directly from the cross-chain input and calls `RegisterTokenInfo` without any length validation [4](#0-3) . The `RegisterTokenInfo` method only validates that the `TokenName` is not empty, but does not check the maximum length [5](#0-4) .

**Root Cause:**
The cross-chain verification only validates the merkle proof cryptographically, not the semantic validity of token parameters against local chain validation rules. The protobuf definition has no length constraint on the token_name field [6](#0-5) , allowing unbounded strings to be transmitted.

**Attack Scenario:**
A malicious or compromised side chain operator can create tokens with excessively long names (e.g., 10,000+ characters) on their side chain, then use legitimate cross-chain mechanisms to propagate these tokens to the main chain. The main chain will accept them because the merkle proof is cryptographically valid, even though the token violates the protocol's semantic constraints.

## Impact Explanation

This vulnerability has **Medium severity** operational impact:

1. **Storage Bloat**: Token names of unlimited length consume excessive contract storage, permanently increasing state size. Each oversized token name represents irreversible state pollution.

2. **Gas Inefficiency**: All operations that read or write the token information (transfers, queries, approvals) will consume significantly more gas due to larger string operations, affecting all users interacting with the malicious token.

3. **UI/Display Issues**: Frontend applications and block explorers may crash or malfunction when attempting to display extremely long token names, degrading user experience across the ecosystem.

4. **Protocol Invariant Violation**: The protocol establishes a clear rule that token names should not exceed 80 characters. This inconsistency creates two classes of tokens with different validation rules, breaking the security model's uniformity.

While this does not directly enable fund theft, it represents a significant denial-of-service vector through permanent state growth and creates operational problems that cannot be easily remediated once malicious tokens are registered.

## Likelihood Explanation

The likelihood is **Medium** based on the following factors:

**Required Attacker Capabilities:**
- Control or compromise of a side chain registered in the cross-chain whitelist
- Ability to create tokens on that side chain
- Ability to submit valid merkle proofs to the main chain

**Feasibility Assessment:**
While controlling a side chain is a high barrier, it is realistic in a multi-chain ecosystem where:
- Side chains may be operated by different organizations with varying security standards
- Malicious side chain operators could pass initial governance review
- Existing side chains could be compromised through governance attacks or security breaches
- Side chains are NOT in the protocol's trusted roles list (genesis, Parliament, consensus contracts)

The `CrossChainCreateToken` method is a public function callable by anyone with valid merkle proofs, and the cross-chain infrastructure is operational and actively used. Once side chain access is obtained, the attack complexity is low with no sophisticated cryptographic manipulation required.

## Recommendation

Add token name length validation to the cross-chain token creation path:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing merkle proof validation ...
    
    var validateTokenInfoExistsInput =
        ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
    
    // Add validation for TokenName length
    Assert(validateTokenInfoExistsInput.TokenName.Length <= TokenContractConstants.TokenNameLength,
        "Invalid token name length.");
    
    // ... rest of the method ...
}
```

Alternatively, add the length check to `RegisterTokenInfo` to ensure all paths enforce the constraint:

```csharp
private void RegisterTokenInfo(TokenInfo tokenInfo)
{
    Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
        "Invalid symbol.");
    Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
    Assert(tokenInfo.TokenName.Length <= TokenContractConstants.TokenNameLength,
        "Token name exceeds maximum length.");
    // ... rest of validation ...
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_Should_Reject_Oversized_TokenName()
{
    // Setup: Create a token on side chain with TokenName > 80 characters
    var oversizedTokenName = new string('A', 1000); // 1000 character name
    var tokenInfo = new TokenInfo
    {
        Symbol = "EVIL",
        TokenName = oversizedTokenName,
        Decimals = 8,
        Issuer = SideChainTester.GetAddress(SideChainKeyPair),
        TotalSupply = 1000000,
        IsBurnable = true,
        IssueChainId = ChainHelper.ConvertBase58ToChainId("AELF")
    };
    
    // Create validation transaction on side chain
    var validateTransaction = await SideChainTokenContractStub.ValidateTokenInfoExists.SendAsync(
        new ValidateTokenInfoExistsInput
        {
            Symbol = tokenInfo.Symbol,
            TokenName = oversizedTokenName,
            Decimals = tokenInfo.Decimals,
            Issuer = tokenInfo.Issuer,
            TotalSupply = tokenInfo.TotalSupply,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId
        });
    
    // Generate merkle proof
    var merklePath = GetMerklePath(validateTransaction.TransactionResult.BlockNumber, 
        validateTransaction.TransactionResult.TransactionId);
    
    // Attempt to create token on main chain via CrossChainCreateToken
    var result = await MainChainTokenContractStub.CrossChainCreateToken.SendAsync(
        new CrossChainCreateTokenInput
        {
            FromChainId = SideChainId,
            ParentChainHeight = validateTransaction.TransactionResult.BlockNumber,
            TransactionBytes = validateTransaction.Transaction.ToByteString(),
            MerklePath = merklePath
        });
    
    // Vulnerability: This should fail but currently succeeds
    // The token with 1000-char name gets registered on main chain
    var registeredToken = await MainChainTokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = "EVIL" });
    
    // Assert: Token name should have been rejected but wasn't
    Assert.Equal(1000, registeredToken.TokenName.Length); // Demonstrates the vulnerability
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-50)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-508)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-277)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L5-5)
```csharp
    public const int TokenNameLength = 80;
```

**File:** protobuf/token_contract_impl.proto (L251-270)
```text
message ValidateTokenInfoExistsInput{
    // The symbol of the token.
    string symbol = 1;
    // The full name of the token.
    string token_name = 2;
    // The total supply of the token.
    int64 total_supply = 3;
    // The precision of the token.
    int32 decimals = 4;
    // The address that has permission to issue the token.
    aelf.Address issuer = 5;
    // A flag indicating if this token is burnable.
    bool is_burnable = 6;
    // The chain id of the token.
    int32 issue_chain_id = 7;
    // The external information of the token.
    map<string, string> external_info = 8;
    // The address that owns the token.
    aelf.Address owner = 9;
}
```
