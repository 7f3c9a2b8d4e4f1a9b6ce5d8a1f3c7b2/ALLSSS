### Title
Transaction Fee Free Allowance Overflow Causes DoS Due to Missing Sum Validation

### Summary
The `TransactionFeeFreeAllowancesConfigMap` allows parliament to configure multiple threshold symbols, each granting free allowances for the same token. When calculating total allowances via `GetFreeFeeAllowanceAmount`, these values are summed without validating that the total stays within `long` bounds. If the sum exceeds `long.MaxValue`, checked arithmetic throws `OverflowException`, causing transaction fee charging to fail and creating a denial-of-service for affected users.

### Finding Description

The transaction fee system allows parliament to configure free allowances through multiple threshold symbols. The state structure is: [1](#0-0) [2](#0-1) 

Each `TransactionFeeFreeAllowanceConfig` contains a map of token symbols to allowance amounts (int64). When a user qualifies for multiple threshold symbols (by holding sufficient balances), the system sums all their allowances for a given token: [3](#0-2) 

The summing uses checked arithmetic via the `Add` extension method: [4](#0-3) 

During configuration, parliament provides allowance amounts with minimal validation: [5](#0-4) 

**Root Cause:** No validation exists to ensure the sum of allowances across all threshold symbols for a given token stays within `long.MaxValue` (9,223,372,036,854,775,807). Parliament could configure:
- Threshold "ELF": grants 5×10^18 "TOKEN" allowance
- Threshold "USDT": grants 5×10^18 "TOKEN" allowance  
- Total: 10×10^18 > long.MaxValue → Overflow

**Execution Path:** The overflow occurs during transaction fee charging when `GetFreeFeeAllowanceAmount` is called from multiple locations: [6](#0-5) [7](#0-6) [8](#0-7) 

### Impact Explanation

**Harm:** Users who qualify for multiple threshold symbols cannot submit transactions. When their transaction attempts to charge fees, the allowance calculation throws `OverflowException`, causing transaction failure.

**Affected Users:** Any user holding sufficient balances in multiple threshold tokens to qualify for cumulative allowances exceeding `long.MaxValue`.

**Severity:** Medium - This creates a denial-of-service but requires governance misconfiguration (not malicious attack). The impact is operational disruption rather than fund loss. However, affected users are completely unable to transact, which is severe for those users.

### Likelihood Explanation

**Preconditions:** Parliament must configure multiple threshold symbols where the sum of allowances for any single token exceeds `long.MaxValue` (approximately 9.22×10^18).

**Feasibility:** While parliament is trusted governance, configuration mistakes are realistic. With tokens using 8 decimals, amounts like 10^17 (1 billion tokens) are plausible. Configuring 100 such thresholds would cause overflow. As shown in tests, multiple threshold symbols are a supported use case: [9](#0-8) 

**Probability:** Low-Medium. Requires governance to inadvertently configure excessive cumulative allowances, but the system provides no warnings or safeguards against this.

### Recommendation

Add validation in `ConfigTransactionFeeFreeAllowances` to prevent overflow:

```csharp
// After line 1254, before storing config:
var existingConfigs = State.TransactionFeeFreeAllowancesSymbolList.Value?.Symbols ?? new RepeatedField<string>();
foreach (var allowance in allowances.TransactionFeeFreeAllowances.Value)
{
    long totalAllowance = allowance.Amount;
    foreach (var existingSymbol in existingConfigs)
    {
        if (existingSymbol == allowances.Symbol) continue; // Skip current being updated
        var existingConfig = State.TransactionFeeFreeAllowancesConfigMap[existingSymbol];
        if (existingConfig?.FreeAllowances?.Map?.TryGetValue(allowance.Symbol, out var existing) == true)
        {
            totalAllowance = totalAllowance.Add(existing.Amount); // Will throw if overflow
        }
    }
    Assert(totalAllowance >= 0, $"Total allowance overflow for symbol {allowance.Symbol}");
}
```

Alternatively, calculate totals during runtime with try-catch and graceful degradation, or cap individual allowance amounts to `long.MaxValue / MaxThresholdSymbols`.

**Test Case:** Configure 10 threshold symbols each granting `long.MaxValue / 9` allowance for the same token. Verify user qualifying for all thresholds can still transact without `OverflowException`.

### Proof of Concept

**Initial State:**
1. Parliament configures threshold symbol "ELF" with 5×10^18 "TOKEN" allowance, threshold = 100 ELF
2. Parliament configures threshold symbol "USDT" with 5×10^18 "TOKEN" allowance, threshold = 100 USDT

**Execution:**
1. User holds 200 ELF and 200 USDT (qualifies for both thresholds)
2. User submits transaction requiring "TOKEN" fee
3. System calls `CalculateTransactionFeeFreeAllowances(user)`
4. System calls `GetFreeFeeAllowanceAmount(map, "TOKEN")`
5. Calculation: 5×10^18 + 5×10^18 = 10×10^18
6. `allowance.Add(5×10^18)` throws `OverflowException` when allowance is already 5×10^18

**Expected:** Transaction processes successfully with capped or validated allowances
**Actual:** Transaction fails with `OverflowException`, user cannot transact

**Success Condition:** Transaction completes or fails gracefully with clear error message about configuration issue, rather than unexpected overflow exception.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState_ChargeFee.cs (L50-50)
```csharp
    public MappedState<string, TransactionFeeFreeAllowanceConfig> TransactionFeeFreeAllowancesConfigMap { get; set; }
```

**File:** protobuf/token_contract_impl.proto (L384-393)
```text
message TransactionFeeFreeAllowanceConfig {
    string symbol = 1;
    TransactionFeeFreeAllowanceMap free_allowances = 2;
    int64 refresh_seconds = 3;
    int64 threshold = 4;
}

message TransactionFeeFreeAllowanceMap {
    map<string, TransactionFeeFreeAllowance> map = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L131-131)
```csharp
        var freeAllowanceAmount = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L179-194)
```csharp
    private long GetFreeFeeAllowanceAmount(TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, string symbol)
    {
        var allowance = 0L;
        var map = transactionFeeFreeAllowancesMap.Map;

        if (map == null) return allowance;

        foreach (var freeAllowances in map.Values)
        {
            freeAllowances.Map.TryGetValue(symbol, out var freeAllowance);

            allowance = allowance.Add(freeAllowance?.Amount ?? 0L);
        }

        return allowance;
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L728-728)
```csharp
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L767-767)
```csharp
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1236-1254)
```csharp
            ValidateToken(allowances.Symbol);
            Assert(
                allowances.TransactionFeeFreeAllowances?.Value != null &&
                allowances.TransactionFeeFreeAllowances.Value.Count > 0,
                "Invalid input allowances");
            Assert(allowances.Threshold >= 0, "Invalid input threshold");
            Assert(allowances.RefreshSeconds >= 0, "Invalid input refresh seconds");

            var config = new TransactionFeeFreeAllowanceConfig
            {
                Symbol = allowances.Symbol,
                Threshold = allowances.Threshold,
                RefreshSeconds = allowances.RefreshSeconds,
                FreeAllowances = new TransactionFeeFreeAllowanceMap()
            };

            foreach (var allowance in allowances.TransactionFeeFreeAllowances!.Value!)
            {
                config.FreeAllowances.Map.TryAdd(allowance.Symbol, allowance);
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest_FreeAllowance.cs (L239-273)
```csharp
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = NativeTokenSymbol,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        RefreshSeconds = 600,
                        Threshold = 1_00000000
                    },
                    new ConfigTransactionFeeFreeAllowance
                    {
                        Symbol = USDT,
                        TransactionFeeFreeAllowances = new TransactionFeeFreeAllowances
                        {
                            Value =
                            {
                                new TransactionFeeFreeAllowance
                                {
                                    Symbol = NativeTokenSymbol,
                                    Amount = 1_00000000
                                }
                            }
                        },
                        RefreshSeconds = 300,
                        Threshold = 1_000000
                    }
                }
```
