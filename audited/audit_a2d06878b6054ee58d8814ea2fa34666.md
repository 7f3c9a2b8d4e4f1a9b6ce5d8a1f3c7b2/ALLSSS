# Audit Report

## Title
Missing Option Length Validation in Vote Contract Registration Allows Permanent Storage Bloat

## Summary
The `Register()` function in the Vote contract fails to validate option string lengths during voting item creation, while all other option-related methods enforce a 1024-character limit. This inconsistency allows attackers to register voting items with arbitrarily large option strings, causing permanent blockchain storage bloat that cannot be cleaned up.

## Finding Description

The vulnerability exists in the `Register()` function where options from user input are directly copied into the voting item without any length validation. [1](#0-0) 

The validation helper `AssertValidNewVotingItem()` only checks timestamp validity and voting item uniqueness, but completely omits option length validation. [2](#0-1) 

In contrast, other option management methods enforce proper validation. The `AddOption()` function validates option length through `AssertOption()`: [3](#0-2) 

The `AssertOption()` helper enforces the 1024-character limit defined in the contract constants: [4](#0-3) 

The constant is defined as: [5](#0-4) 

Similarly, `AddOptions()` validates each option through the same validation path: [6](#0-5) 

**Critical Design Flaw**: The `RemoveOption()` function validates the input option length BEFORE checking if the option exists in storage, creating a permanent lock scenario: [7](#0-6) 

At line 307, the length validation occurs before the existence check at line 308. This means if an oversized option (>1024 characters) is stored via `Register()`, the sponsor cannot remove it because the removal call will fail at the length validation before ever checking if that option exists.

The `Vote()` function also validates option length, preventing users from voting on oversized options: [8](#0-7) 

## Impact Explanation

**Storage Bloat**: An attacker can register voting items with option strings containing millions of characters, consuming excessive blockchain storage that all nodes must maintain permanently. Each character increases the state size unnecessarily.

**Permanent State Pollution**: Once registered, these oversized options cannot be removed because `RemoveOption()` validates the input option length (line 307) before checking if the option exists (line 308). To remove an option, the sponsor must provide the exact option string, but if that string exceeds 1024 characters, the transaction fails at the length validation and never reaches the existence check.

**Non-Functional Voting Items**: The voting items become unusable because:
- Users cannot vote for oversized options (Vote() validates length at line 380)
- The sponsor cannot remove oversized options (RemoveOption() validates length at line 307)
- The voting item persists in storage but serves no legitimate purpose

**Griefing Attack Vector**: This is a cost-effective griefing attack where malicious actors can bloat blockchain state at minimal cost (only standard transaction fees), affecting all node operators who must store this data permanently. The attack cannot be mitigated or reversed.

## Likelihood Explanation

**Reachable Entry Point**: The `Register()` function is a public RPC method defined in the proto contract interface, callable by any blockchain user. [9](#0-8) 

**Low Preconditions**: The only requirement is that the accepted currency token must be in the whitelist, checked at lines 29-34 of VoteContract.cs. For common tokens like the native chain token, this requirement is trivially satisfied and poses no barrier to attackers.

**Simple Execution**: An attacker needs only to:
1. Construct a `VotingRegisterInput` with valid timestamps and a whitelisted token symbol
2. Include option strings exceeding 1024 characters (e.g., millions of repetitive characters)
3. Call the `Register()` RPC method
4. Pay standard transaction fees

**No Prevention Mechanism**: There is no validation, rate limiting, or detection mechanism that would prevent or flag this attack before the oversized options are committed to permanent blockchain storage.

## Recommendation

Add option length validation to the `Register()` function by validating each option in the input before storing the voting item. The fix should be applied in the `AssertValidNewVotingItem()` helper or directly in `Register()`:

```csharp
private Hash AssertValidNewVotingItem(VotingRegisterInput input)
{
    var votingItemId = input.GetHash(Context.Sender);
    Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");
    
    // Validate option lengths
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
    }
    
    if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;
    Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");
    Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");
    return votingItemId;
}
```

Alternatively, reuse the existing `AssertOption()` validation within a voting item validation context.

## Proof of Concept

```csharp
[Fact]
public async Task Register_WithOversizedOptions_ShouldSucceed_ButCannotBeRemoved()
{
    // Arrange: Create a massive option string (10,000 characters - well beyond the 1024 limit)
    var oversizedOption = new string('A', 10000);
    
    var registerInput = new VotingRegisterInput
    {
        StartTimestamp = TimestampHelper.GetUtcNow(),
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(7),
        AcceptedCurrency = "ELF", // Assume ELF is whitelisted
        IsLockToken = true,
        TotalSnapshotNumber = 1,
        Options = { oversizedOption, "ValidOption" }
    };
    
    // Act: Register voting item with oversized option - THIS SHOULD FAIL BUT DOESN'T
    var registerResult = await VoteContractStub.Register.SendAsync(registerInput);
    
    // Assert: Registration succeeds (demonstrates vulnerability)
    registerResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    var votingItemId = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(registerInput), 
        HashHelper.ComputeFrom(DefaultSender)
    );
    
    var votingItem = await VoteContractStub.GetVotingItem.CallAsync(new GetVotingItemInput 
    { 
        VotingItemId = votingItemId 
    });
    
    votingItem.Options.Count.ShouldBe(2);
    votingItem.Options[0].ShouldBe(oversizedOption);
    
    // Attempt to remove the oversized option - THIS WILL FAIL
    var removeInput = new RemoveOptionInput
    {
        VotingItemId = votingItemId,
        Option = oversizedOption
    };
    
    var removeResult = await VoteContractStub.RemoveOption.SendWithExceptionAsync(removeInput);
    
    // Assert: Removal fails due to length validation (permanent lock)
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Invalid input");
    
    // The oversized option is now permanently stuck in storage
}
```

This test demonstrates that oversized options can be registered and then cannot be removed, validating both the storage bloat vulnerability and the permanent lock scenario.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-290)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-312)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), "Option doesn't exist.");
        votingItem.Options.Remove(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-324)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L377-401)
```csharp
    private VotingItem AssertValidVoteInput(VoteInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(input.Option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
        Assert(votingItem.CurrentSnapshotNumber <= votingItem.TotalSnapshotNumber,
            "Current voting item already ended.");
        if (!votingItem.IsLockToken)
        {
            Assert(votingItem.Sponsor == Context.Sender, "Sender of delegated voting event must be the Sponsor.");
            Assert(input.Voter != null, "Voter cannot be null if voting event is delegated.");
            Assert(input.VoteId != null, "Vote Id cannot be null if voting event is delegated.");
        }
        else
        {
            var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
            var votingResult = State.VotingResults[votingResultHash];
            // Voter = Transaction Sender
            input.Voter = Context.Sender;
            // VoteId = Transaction Id;
            input.VoteId = Context.GenerateId(Context.Self, votingResult.VotesAmount.ToBytes(false));
        }

        return votingItem;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L6-6)
```csharp
    public const int OptionLengthLimit = 1024;
```

**File:** protobuf/vote_contract.proto (L20-21)
```text
    rpc Register (VotingRegisterInput) returns (google.protobuf.Empty) {
    }
```
