# Audit Report

## Title
NFT Burn Function Incorrectly Requires Minter Status, Preventing Legitimate Token Owners from Burning Their Own Assets

## Summary
The NFT contract's `Burn()` function enforces an overly restrictive authorization check that requires callers to be in the minter list, even when they legitimately own the NFTs. This prevents non-minter owners from burning their own assets, violating fundamental ownership rights and breaking the `Disassemble()` functionality.

## Finding Description

The `Burn()` function in the NFT contract contains a flawed authorization check that conflates two separate concerns: ownership and minting privileges. [1](#0-0) 

The authorization logic requires BOTH conditions to be satisfied:
1. The caller must have sufficient balance (legitimate ownership verification)
2. The caller must be in the minter list (inappropriate restriction) [2](#0-1) 

This is inconsistent with the MultiToken contract, which only requires the token to be burnable and the caller to have sufficient balance: [3](#0-2) 

**How Non-Minters Legitimately Acquire NFTs:**

1. **Direct minting to non-minter owners:** The `PerformMint()` function allows minters to specify a different owner: [4](#0-3) 

2. **Transfer operations:** Any owner can transfer NFTs to non-minters, with no minter status checks: [5](#0-4) 

3. **TransferFrom operations:** Approved spenders can transfer to non-minters: [6](#0-5) 

**Cascading Impact on Disassemble:**

The `Disassemble()` function internally calls `Burn()`, preventing non-minter owners from recovering underlying assets: [7](#0-6) 

**Protocol Design Intent Violation:**

NFT protocols are created with an `IsBurnable` flag that suggests owner-level burning should be possible: [8](#0-7) [9](#0-8) 

The protocol definition includes this burnable flag without any indication that only minters can burn: [10](#0-9) 

## Impact Explanation

**HIGH SEVERITY** - This vulnerability fundamentally breaks ownership rights for NFT holders:

1. **Ownership Rights Violation:** Legitimate NFT owners cannot destroy assets they possess, contradicting basic digital asset ownership principles

2. **Protocol Inconsistency:** The `IsBurnable` flag becomes meaningless for the majority of NFT holders (non-minters), creating a misleading protocol design

3. **Asset Lock-in:** Users who assemble NFTs (locking underlying assets) cannot disassemble them to recover those assets, resulting in permanent inaccessibility

4. **Economic Impact:** Owners cannot reduce token supply or exit positions, affecting token economics and user autonomy

5. **Widespread Affected Users:** In typical NFT ecosystems, the vast majority of holders are not minters, making this issue affect nearly all NFT owners

## Likelihood Explanation

**VERY HIGH** - This is not an attack scenario but a design flaw affecting normal operations:

1. **Trivial to Trigger:** Any non-minter owner attempting to burn their NFT encounters this issue immediately

2. **Common Scenario:** NFT transferability is a core feature, and most NFT owners in any ecosystem are not minters

3. **No Preconditions Required:** Simply owning an NFT as a non-minter is sufficient to encounter this restriction

4. **By Design:** The contract explicitly allows minting to non-minter addresses and transferring to anyone, making this scenario intentional in the protocol flow

## Recommendation

Remove the minter list check from the `Burn()` function. The authorization should only verify:
1. The NFT protocol is burnable
2. The caller has sufficient balance

Modified authorization check:
```csharp
Assert(
    State.BalanceMap[tokenHash][Context.Sender] >= input.Amount,
    "Insufficient balance.");
```

The minter list should only control who can mint new tokens, not who can burn tokens they own. This aligns with the MultiToken contract behavior and preserves fundamental ownership rights.

## Proof of Concept

```csharp
[Fact]
public async Task NonMinterOwnerCannotBurnNFT()
{
    // Create NFT protocol with IsBurnable = true
    var symbol = await CreateTest();
    
    // Add MinterAddress to minter list
    await NFTContractStub.AddMinters.SendAsync(new AddMintersInput
    {
        Symbol = symbol,
        MinterList = new MinterList { Value = { MinterAddress } }
    });
    
    // Minter mints NFT to User1Address (non-minter)
    var mintResult = await MinterNFTContractStub.Mint.SendAsync(new MintInput
    {
        Symbol = symbol,
        Owner = User1Address,  // Non-minter owner
        Quantity = 1
    });
    mintResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify User1 owns the NFT
    var balance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User1Address,
        Symbol = symbol,
        TokenId = 1
    });
    balance.Balance.ShouldBe(1);
    
    // User1 (non-minter owner) attempts to burn their NFT
    var user1Stub = GetTester<NFTContractContainer.NFTContractStub>(NFTContractAddress, User1KeyPair);
    var burnResult = await user1Stub.Burn.SendWithExceptionAsync(new BurnInput
    {
        Symbol = symbol,
        TokenId = 1,
        Amount = 1
    });
    
    // Burn fails despite User1 owning the NFT
    burnResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    burnResult.TransactionResult.Error.ShouldContain("No permission");
    
    // Verify NFT still exists (not burned)
    balance = await NFTContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = User1Address,
        Symbol = symbol,
        TokenId = 1
    });
    balance.Balance.ShouldBe(1);  // Still owned, cannot be burned by owner
}
```

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L57-80)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var operatorList = State.OperatorMap[input.Symbol][input.From];
        var isOperator = operatorList?.Value.Contains(Context.Sender) ?? false;
        if (!isOperator)
        {
            var allowance = State.AllowanceMap[tokenHash][input.From][Context.Sender];
            Assert(allowance >= input.Amount, "Not approved.");
            State.AllowanceMap[tokenHash][input.From][Context.Sender] = allowance.Sub(input.Amount);
        }

        DoTransfer(tokenHash, input.From, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = input.From,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-198)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L440-441)
```csharp
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L318-337)
```csharp
    public override Empty Burn(BurnInput input)
    {
        return Burn(Context.Sender, input.Symbol, input.Amount);
    }

    private Empty Burn(Address address, string symbol, long amount)
    {
        var tokenInfo = AssertValidToken(symbol, amount);
        Assert(tokenInfo.IsBurnable, "The token is not burnable.");
        ModifyBalance(address, symbol, -amount);
        tokenInfo.Supply = tokenInfo.Supply.Sub(amount);

        Context.Fire(new Burned
        {
            Burner = address,
            Symbol = symbol,
            Amount = amount
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L28-28)
```csharp
            IsBurnable = input.IsBurnable,
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L50-50)
```csharp
            IsBurnable = tokenCreateInput.IsBurnable,
```

**File:** protobuf/nft_contract.proto (L118-119)
```text
    // A flag indicating if this token is burnable.
    bool is_burnable = 5;
```
