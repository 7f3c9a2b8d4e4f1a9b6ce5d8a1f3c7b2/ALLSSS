# Audit Report

## Title
Insufficient Secret Sharing State Validation Allows DoS and Consensus Corruption in Round Transitions

## Summary
The `ValidationForNextRound()` function only validates that `InValue` is null for miners in the next round, but fails to verify that other secret sharing fields (`EncryptedPieces`, `DecryptedPieces`, `OutValue`, `Signature`) are in their expected clean state. A malicious miner serving as extra block producer can pre-populate these fields with garbage data, causing legitimate miners' `UpdateValue` transactions to fail via duplicate key exceptions and corrupting the secret sharing recovery mechanism.

## Finding Description

The AEDPoS consensus contract validates round transitions through `RoundTerminateValidationProvider.ValidationForNextRound()`, which only checks that `InValue` fields are null: [1](#0-0) 

However, the `MinerInRound` protobuf structure contains additional secret sharing fields that should also be empty in a new round: [2](#0-1) 

When a new round is legitimately generated via `GenerateNextRoundInformation()`, only basic fields are initialized (Pubkey, Order, ExpectedMiningTime, ProducedBlocks, MissedTimeSlots), leaving all secret sharing fields in their default null/empty state: [3](#0-2) 

The `NextRoundInput` structure allows these fields to be populated, and `ToRound()` directly copies all fields without sanitization: [4](#0-3) 

**Attack Path:**

1. A malicious miner becomes the extra block producer (rotates periodically based on `CalculateNextExtraBlockProducerOrder()`)

2. The attacker crafts a `NextRoundInput` with pre-populated secret sharing fields (e.g., `EncryptedPieces` with keys matching other miners' pubkeys)

3. The validation passes because it only checks `InValue == null`, not the other fields

4. The round is stored with pre-populated garbage data via `ProcessNextRound()`: [5](#0-4) 

5. When legitimate miners produce blocks via `UpdateValue`, the `PerformSecretSharing` method attempts to add encrypted pieces using protobuf's `MapField.Add()`: [6](#0-5) 

6. The `Add()` operation on protobuf `MapField` throws `ArgumentException` when duplicate keys exist, causing the transaction to fail

7. For `DecryptedPieces`, pre-populated garbage data corrupts the secret recovery mechanism in `RevealSharedInValues`: [7](#0-6) 

The `SecretSharingHelper.DecodeSecret()` would either fail or produce incorrect InValue recovery, corrupting consensus randomness.

## Impact Explanation

**Primary Impact - Denial of Service:**
- Legitimate miners cannot successfully produce blocks because their `UpdateValue` transactions fail with `ArgumentException` when attempting to add encrypted pieces to maps that already contain duplicate keys
- The attacker can target specific miners by pre-populating their `EncryptedPieces` with keys corresponding to other miners' pubkeys
- If enough miners are blocked, consensus can stall completely as insufficient miners can produce blocks
- The round remains stuck until manual intervention or timeout mechanisms activate

**Secondary Impact - Secret Sharing Corruption:**
- Pre-populated garbage in `DecryptedPieces` causes `RevealSharedInValues` to compute incorrect previous InValues using corrupted input to Shamir's secret sharing reconstruction
- This corrupts the consensus signature calculation and random number generation chain
- Affects the integrity of the randomness used for miner ordering and extra block producer selection in subsequent rounds
- Could enable manipulation of miner selection if the attacker controls the corrupted values

**Affected Parties:**
- All honest miners in the affected round lose mining rewards due to failed transactions
- The entire network suffers from reduced block production or complete consensus halt
- Cross-chain operations depending on timely block finalization are delayed

**Severity:** HIGH - Combines operational DoS with cryptographic security degradation affecting consensus integrity.

## Likelihood Explanation

**Attacker Capabilities Required:**
- Must be selected as the extra block producer at the end of a round, which rotates among miners based on signatures: [8](#0-7) 

- Requires being part of the active miner set
- No additional privileges beyond normal miner role needed

**Attack Complexity:**
- LOW - Simply modify the `NextRoundInput` protobuf message before submission to include pre-populated secret sharing fields
- No cryptographic breaks or complex timing attacks required
- The validation explicitly does NOT check these fields, making exploitation straightforward

**Feasibility Conditions:**
- Attacker mines blocks normally to reach extra block producer position (happens periodically, approximately every N rounds where N is the number of miners)
- The secret sharing feature must be enabled, controlled by configuration: [9](#0-8) 

**Economic Rationality:**
- Attack cost: Normal mining operation costs until gaining extra block producer position
- Attack benefit: Can block specific competitors from mining, potentially increasing attacker's relative rewards and influence
- Detection: Likely detectable through blockchain analysis showing round with pre-populated fields, but damage is already done by that point

**Probability:** MEDIUM - Requires periodic opportunity (extra block producer rotation) but execution is trivial once positioned.

## Recommendation

Add comprehensive validation of all secret sharing fields in `ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Check round number
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Check all secret sharing fields are in clean state
    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        if (miner.InValue != null)
            return new ValidationResult { Message = "Incorrect next round information: InValue must be null." };
        
        if (miner.OutValue != null)
            return new ValidationResult { Message = "Incorrect next round information: OutValue must be null." };
            
        if (miner.Signature != null)
            return new ValidationResult { Message = "Incorrect next round information: Signature must be null." };
            
        if (miner.EncryptedPieces.Count > 0)
            return new ValidationResult { Message = "Incorrect next round information: EncryptedPieces must be empty." };
            
        if (miner.DecryptedPieces.Count > 0)
            return new ValidationResult { Message = "Incorrect next round information: DecryptedPieces must be empty." };
    }
    
    return new ValidationResult { Success = true };
}
```

Alternatively, implement explicit sanitization in `NextRoundInput.ToRound()` to ensure only the expected fields are copied for a new round, clearing all secret sharing fields.

## Proof of Concept

A proof of concept would demonstrate:

1. Setup: Deploy AEDPoS contract with secret sharing enabled and multiple miners
2. Normal operation: Mine through several rounds until test miner becomes extra block producer
3. Attack execution:
   - Create `NextRoundInput` with legitimate round data
   - Pre-populate `MinerInRound.EncryptedPieces` for a target miner with keys that will be used by other miners
   - Submit `NextRound` transaction - it passes validation
4. Impact verification:
   - Target miner attempts `UpdateValue` in the new round
   - Transaction fails with `ArgumentException` on `EncryptedPieces.Add()` due to duplicate keys
   - Observe consensus stall if sufficient miners are blocked

The test would verify that the validation gap exists and that pre-populated secret sharing fields cause subsequent mining operations to fail as described.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L32-34)
```csharp
        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
```

**File:** protobuf/aedpos_contract.proto (L293-296)
```text
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L29-36)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-293)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```
