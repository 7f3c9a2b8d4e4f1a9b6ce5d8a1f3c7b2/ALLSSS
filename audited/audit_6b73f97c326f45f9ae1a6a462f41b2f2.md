### Title
TokenHolder RemoveBeneficiary Allows Profit Rights Revocation While Tokens Remain Locked

### Summary
The `RemoveBeneficiary` function in TokenHolderContract allows scheme managers to remove a user's beneficiary status and profit rights while their tokens remain locked, violating the core invariant that locked tokens should always entitle holders to profits. This creates a state inconsistency where users have tokens forcibly locked without receiving any profit distributions until the minimum lock period expires.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**
The `RemoveBeneficiary` function removes a user from the profit scheme's beneficiary list but performs no validation that the user doesn't have locked tokens, nor does it unlock those tokens or remove the associated lockId from state. [1](#0-0) 

When a user calls `RegisterForProfits`, three state changes occur:
1. Tokens are locked via MultiToken contract
2. LockId is stored in `State.LockIds[schemeManager][user]`
3. User is added as beneficiary with shares equal to locked amount [2](#0-1) 

However, `RemoveBeneficiary` only reverses step 3 (removes beneficiary status), leaving steps 1 and 2 intact. The function retrieves profit details to determine shares, calls the Profit contract to remove the beneficiary, and optionally re-adds with reduced shares, but never checks or modifies the lock state. [3](#0-2) 

**Why Protections Fail:**
There is no check in `RemoveBeneficiary` to verify whether the beneficiary has an active lock. The only place where lockIds are removed is in the `Withdraw` function. [4](#0-3) 

Users cannot directly unlock their tokens from the MultiToken contract because the virtual address used for locking is computed from the TokenHolder contract's address, not the user's address. The unlock authorization check in MultiToken requires either the sender to be in the lock whitelist or the origin to match the locked address, but the virtual address computation still depends on the original sender (TokenHolder). [5](#0-4) [6](#0-5) 

**Relevant Execution Path:**
When `Withdraw` is eventually called, it attempts to remove the beneficiary again, but the Profit contract's `RemoveBeneficiary` gracefully handles the case where the beneficiary doesn't exist by returning early without error. [7](#0-6) 

This means the withdrawal succeeds even after the beneficiary was already removed, but only after the minimum lock period has elapsed. [8](#0-7) 

### Impact Explanation

**Direct Harm:**
- Users' tokens are forcibly locked without receiving profit rights
- Profits that should be distributed to the affected user are instead redistributed proportionally to remaining beneficiaries, effectively stealing the user's share
- Users cannot access their locked tokens until the minimum lock period expires, which is configurable per scheme [9](#0-8) 

**Quantified Damage:**
If a scheme has profits distributed during the lock period, the removed user receives 0% of their expected share while their tokens remain locked. For example:
- User locks 1000 tokens (10% of total locked)
- Manager removes user as beneficiary
- 10,000 tokens are distributed as profits
- User receives 0 instead of expected 1,000 tokens
- Other beneficiaries receive the user's 1,000 tokens

**Affected Parties:**
Any user who has called `RegisterForProfits` is vulnerable to having their profit rights revoked by the scheme manager while their tokens remain locked.

**Severity Justification:**
This is CRITICAL because it violates the fundamental economic invariant that locked tokens should always entitle holders to profits. The scheme design explicitly states that `RegisterForProfits` locks tokens AND adds beneficiary status together as an atomic operation, creating the reasonable expectation that these states remain synchronized. [10](#0-9) 

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be the scheme manager, which is set when `CreateScheme` is called. While this is a privileged role, it represents a realistic threat model where:
- A scheme manager becomes malicious or compromised
- A scheme manager makes an honest mistake not realizing tokens remain locked
- A multi-sig scheme manager has one malicious member who exploits this [11](#0-10) 

**Attack Complexity:**
The attack requires only a single transaction calling `RemoveBeneficiary` with `amount = 0` to completely remove the user. [12](#0-11) 

**Feasibility Conditions:**
- User must have previously called `RegisterForProfits` (normal operation)
- Attacker must be the scheme manager (privileged but realistic)
- No additional preconditions required

**Detection Constraints:**
The operation appears legitimate - managers are expected to be able to manage beneficiaries. There's no clear signal that this creates a locked-without-profits state.

**Probability Reasoning:**
HIGH likelihood because:
1. The functionality is explicitly provided (not an edge case)
2. Scheme managers have clear economic incentive to increase their own profit share
3. The operation is indistinguishable from legitimate beneficiary management
4. No audit trail or warning is generated

### Recommendation

**Code-Level Mitigation:**
Add a validation check in `RemoveBeneficiary` to prevent removing users who have locked tokens:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // NEW: Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    Assert(lockId == null, "Cannot remove beneficiary with locked tokens. User must withdraw first.");
    
    var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
    {
        Beneficiary = input.Beneficiary,
        SchemeId = scheme.SchemeId
    }).Details.Single();
    // ... rest of function
}
```

**Invariant Checks to Add:**
1. `RemoveBeneficiary` must assert that `State.LockIds[schemeManager][beneficiary]` is null
2. Alternatively, `RemoveBeneficiary` should automatically trigger token unlock if lockId exists
3. Add test to verify that attempting to remove a beneficiary with locked tokens fails

**Test Cases to Prevent Regression:**
```csharp
[Fact]
public async Task RemoveBeneficiary_With_Locked_Tokens_Should_Fail()
{
    // Setup: User registers for profits (locks tokens)
    await TokenHolderContractStub.RegisterForProfits.SendAsync(...);
    
    // Attempt to remove beneficiary while tokens locked
    var result = await TokenHolderContractStub.RemoveBeneficiary
        .SendWithExceptionAsync(...);
    
    // Should fail with appropriate error
    result.TransactionResult.Error.ShouldContain(
        "Cannot remove beneficiary with locked tokens");
}
```

### Proof of Concept

**Required Initial State:**
1. Scheme manager creates a TokenHolder profit scheme with `MinimumLockMinutes = 1440` (1 day)
2. User has sufficient token balance and has approved TokenHolder contract
3. Scheme has been funded with profits to distribute

**Transaction Steps:**
1. **T0**: User calls `RegisterForProfits(schemeManager, amount=1000)`
   - 1000 tokens locked in MultiToken virtual address
   - LockId stored: `State.LockIds[schemeManager][user] = lockId`
   - User added as beneficiary with 1000 shares

2. **T0+1min**: Scheme manager calls `RemoveBeneficiary(beneficiary=user, amount=0)`
   - User removed from profit scheme beneficiaries
   - LockId still exists: `State.LockIds[schemeManager][user]` unchanged
   - Tokens remain locked in MultiToken contract

3. **T0+2min**: Scheme manager calls `DistributeProfits(amounts={"ELF": 10000})`
   - User receives 0 tokens (not a beneficiary)
   - Remaining beneficiaries split user's share

4. **T0+1day**: User calls `Withdraw(schemeManager)`
   - User can now unlock tokens (minimum lock period passed)
   - User receives back original 1000 tokens but lost all profit distributions

**Expected vs Actual Result:**
- **Expected**: User cannot be removed as beneficiary while tokens are locked, OR removal automatically unlocks tokens
- **Actual**: User is removed as beneficiary, tokens remain locked, user loses profit rights for the entire lock duration

**Success Condition:**
After step 2, verify:
- `GetProfitDetails(user)` returns empty (user not a beneficiary) ✓
- `GetLockedAmount(user, lockId)` returns 1000 (tokens still locked) ✓
- User cannot call `Withdraw` yet (minimum lock period not elapsed) ✓

This demonstrates the state inconsistency where a user has locked tokens but no profit rights.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-24)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L238-238)
```csharp
        State.LockIds[input].Remove(Context.Sender);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L230-231)
```csharp
        Assert(IsInLockWhiteList(Context.Sender) || Context.Origin == input.Address,
            "Unlock behaviour should be initialed by origin address.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L234-235)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** protobuf/token_holder_contract.proto (L27-30)
```text
    // Removes a beneficiary from a scheme.
    // Note: amount > 0: update the weight of the beneficiary, amount = 0: remove the beneficiary.
    rpc RemoveBeneficiary (RemoveTokenHolderBeneficiaryInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_holder_contract.proto (L66-67)
```text
    // Minimum lock time for holding token.
    int64 minimum_lock_minutes = 2;
```
