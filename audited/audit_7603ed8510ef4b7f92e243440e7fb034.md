# Audit Report

## Title
TermNumber Increment Bypass via NextRound Behavior Validation Gap

## Summary
A malicious miner can craft a consensus block with NextRound behavior but an incremented TermNumber, bypassing validation to skip critical term transition logic including mining reward distribution, election snapshots, miner list updates, and missed time slot penalties, while causing persistent state inconsistency.

## Finding Description

The AEDPoS consensus contract contains a validation gap in `RoundTerminateValidationProvider` that fails to verify TermNumber consistency for NextRound behavior transitions. When a block header specifies `AElfConsensusBehaviour.NextRound`, the validation immediately returns `ValidationForNextRound()` results without checking whether the TermNumber remains unchanged. [1](#0-0) 

The `ValidationForNextRound()` method only validates that the round number increments by exactly 1 and that InValues are null. It does NOT validate TermNumber consistency: [2](#0-1) 

In contrast, `ValidationForNextTerm()` explicitly checks TermNumber consistency, demonstrating this is a critical invariant: [3](#0-2) 

When legitimate NextRound data is generated, `GenerateNextRoundInformation()` explicitly preserves the current TermNumber, confirming NextRound transitions should NOT change terms: [4](#0-3) 

However, `NextRoundInput.ToRound()` blindly copies the TermNumber from input without validation: [5](#0-4) 

During execution, `ProcessNextRound()` updates `State.CurrentRoundNumber` but never calls `TryToUpdateTermNumber()`, creating desynchronization: [6](#0-5) 

The malicious round with incremented TermNumber is stored directly via `AddRoundInformation()`: [7](#0-6) 

**Attack Execution**:
1. Miner obtains legitimate NextRound consensus data from `GetConsensusBlockExtraData`
2. Miner modifies `extraData.Round.TermNumber` to increment it by 1
3. Miner submits the block with modified header
4. Validation passes because `ValidationForNextRound()` doesn't check TermNumber
5. `ProcessNextRound()` executes, storing the malicious TermNumber but not updating `State.CurrentTermNumber`

**Result**: `State.CurrentTermNumber` remains at the old value while `State.Rounds[currentRoundNumber].TermNumber` is incremented, creating persistent state inconsistency.

## Impact Explanation

**State Inconsistency**: The desynchronization between `State.CurrentTermNumber` and the stored round's TermNumber corrupts term-based lookups throughout the consensus system. This affects election snapshots, miner list mappings, and reward calculations.

**Bypassed Critical Term Logic**: The attacker skips all term transition operations in `ProcessNextTerm()`:

1. **Mining Reward Misallocation**: `DonateMiningReward()` and `TreasuryContract.Release()` are not executed, preventing proper mining reward distribution and treasury fund releases: [8](#0-7) 

2. **Election Corruption**: `ElectionContract.TakeSnapshot()` is skipped, breaking the election snapshot mechanism that records mined blocks and voting power: [9](#0-8) 

3. **Miner List Desynchronization**: `SetMinerList()` and `State.FirstRoundNumberOfEachTerm` updates are skipped: [10](#0-9) 

4. **Missed Penalty Evasion**: `CountMissedTimeSlots()` is not called: [11](#0-10) 

This breaks the economic model, governance integrity, and miner accountability mechanisms.

## Likelihood Explanation

**Attacker Capabilities**: The attacker must be an elected miner and be selected as the extra block producer for a round. Both conditions are achievable:
- Miners are elected through the normal election process
- Extra block producer selection is deterministic based on signatures

**Feasibility**: The attack requires no special economic cost beyond normal block production. Miners control block header creation and can modify the consensus data before submitting blocks. The validation gap guarantees success.

**Detection Difficulty**: The modified TermNumber appears in stored round data but `State.CurrentTermNumber` remains unchanged, creating subtle inconsistencies that may not immediately trigger alerts.

The validation logic confirms no TermNumber check exists for NextRound behavior: [12](#0-11) 

## Recommendation

Add TermNumber validation to `ValidationForNextRound()`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Validate round number increment
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Validate TermNumber remains unchanged for NextRound behavior
    if (validationContext.BaseRound.TermNumber != extraData.Round.TermNumber)
        return new ValidationResult { Message = "TermNumber must remain unchanged for NextRound behavior." };

    // Validate InValues are null
    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating a test miner in the elected set
2. Generating legitimate NextRound consensus data
3. Modifying the TermNumber field to increment it
4. Submitting the block and verifying it passes validation
5. Confirming `State.CurrentTermNumber` remains unchanged while `State.Rounds[roundNumber].TermNumber` is incremented
6. Verifying that term transition logic (rewards, snapshots, penalties) is not executed

The code evidence confirms all validation providers registered for NextRound behavior, and none check TermNumber consistency.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L14-14)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L21-22)
```csharp
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L167-168)
```csharp
        // Count missed time slot of current round.
        CountMissedTimeSlots();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-193)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
