# Audit Report

## Title
Missing Signature and Mining Order Validation Allows Manipulation of Consensus Schedule

## Summary
The AEDPoS consensus contract fails to validate that the `Signature` field matches the expected value calculated from previous round signatures, and does not verify that `SupposedOrderOfNextRound` correctly derives from the signature. This allows any miner to manipulate their mining position in the next round by providing arbitrary signature and order values, breaking the fairness and unpredictability guarantees of the consensus mechanism.

## Finding Description

The AEDPoS consensus relies on signature-based randomization to determine mining order. The intended design calculates a miner's order for the next round using the formula `GetAbsModulus(signature.ToInt64(), minersCount) + 1`, where the signature should be computed as `previousRound.CalculateSignature(previousInValue)`. [1](#0-0) [2](#0-1) 

However, when `ProcessUpdateValue` executes, it blindly accepts the signature and order values from `UpdateValueInput` without validating their correctness: [3](#0-2) 

The validation pipeline only performs superficial checks. The `UpdateValueValidationProvider` merely verifies that the signature field is non-empty, not that it was correctly calculated: [4](#0-3) 

Similarly, the `TuneOrderInformation` field, which allows modifying other miners' `FinalOrderOfNextRound`, is applied without any validation: [5](#0-4) 

The `NextRoundMiningOrderValidationProvider` only checks that the count of miners with orders equals the count of miners who mined, not whether each individual order was calculated correctly: [6](#0-5) 

A malicious miner can exploit this by:
1. Choosing any signature value where `GetAbsModulus(signature.ToInt64(), minersCount) + 1` equals their desired position
2. Setting `SupposedOrderOfNextRound` to match this desired position
3. Submitting these manipulated values through their consensus transaction

The contract accepts these values because no on-chain validation verifies that the signature matches `previousRound.CalculateSignature(previousInValue)` or that the order matches the signature-derived calculation.

## Impact Explanation

This vulnerability fundamentally breaks the consensus schedule integrity:

1. **Mining Position Manipulation**: A malicious miner can guarantee themselves position 1 in every round by choosing a signature where `signature.ToInt64() % minersCount == 0`. This allows them to always produce the first block, potentially gaining MEV (Miner Extractable Value) advantages.

2. **Consensus Fairness Violation**: The signature-based randomization is designed to ensure unpredictable and fair mining order distribution. By allowing arbitrary signature values, the entire fairness mechanism is circumvented.

3. **Schedule Manipulation**: Through the unvalidated `TuneOrderInformation` field, a miner can push competing miners to less favorable positions or later time slots.

4. **Consensus Integrity Breach**: The mining schedule becomes deterministically controllable by any miner, rather than being cryptographically randomized as intended. This represents a fundamental failure of the consensus security model.

## Likelihood Explanation

**Likelihood: HIGH**

**Reachable Entry Point**: The `UpdateValue` method is accessible to any miner during their designated time slot, as enforced by the time slot validation. [7](#0-6) 

**Feasible Preconditions**: The attacker only needs to be a valid miner in the current miner list - a normal operational role requiring no additional privileges beyond what any consensus participant already has.

**Execution Practicality**: A malicious miner can modify their consensus node implementation to:
- Skip the legitimate signature calculation in `GetConsensusExtraDataToPublishOutValue`
- Generate a signature value that produces their desired mining order
- Construct the `UpdateValueInput` with these manipulated values
- Submit the transaction through the normal consensus flow

The contract will accept these values because the validation providers only check for non-empty fields and proper previous in-value hashing, not signature correctness.

**Economic Rationality**: The attack cost is minimal (just standard transaction fees), while benefits include favorable mining positions, potential MEV extraction, and the ability to disrupt competitors' mining schedules.

**Detection Difficulty**: The manipulated values are stored in contract state as if legitimate. Only by independently re-computing the expected signature and comparing with stored values could the manipulation be detected, requiring off-chain monitoring infrastructure.

## Recommendation

Add validation in `ProcessUpdateValue` or `UpdateValueValidationProvider` to verify:

1. **Signature Correctness**: Validate that the provided signature matches the expected value:
```
var expectedSignature = previousRound.CalculateSignature(updateValueInput.PreviousInValue);
Assert(updateValueInput.Signature == expectedSignature, "Invalid signature value");
```

2. **Order Derivation**: Verify that `SupposedOrderOfNextRound` correctly derives from the signature:
```
var minersCount = currentRound.RealTimeMinersInformation.Count;
var expectedOrder = GetAbsModulus(updateValueInput.Signature.ToInt64(), minersCount) + 1;
Assert(updateValueInput.SupposedOrderOfNextRound == expectedOrder, "Invalid supposed order");
```

3. **TuneOrderInformation Validation**: Add bounds checking and conflict resolution validation for the tune order information to prevent arbitrary manipulation of other miners' positions.

These checks should be added to the validation pipeline before the values are stored in contract state.

## Proof of Concept

A malicious miner would execute the following attack:

1. When their turn to mine arrives, instead of calling the legitimate consensus command generation
2. Manually construct an `UpdateValueInput` with:
   - `Signature`: A hash value chosen such that `Hash.ToInt64() % minersCount == 0` (to get position 1)
   - `SupposedOrderOfNextRound`: 1
   - All other required fields populated normally
3. Submit this transaction to `UpdateValue`
4. The validation pipeline checks only that signature is non-empty (passes)
5. `ProcessUpdateValue` stores the manipulated signature and order values
6. In the next round, the attacker mines in position 1

The attack succeeds because:
- `UpdateValueValidationProvider` only checks signature is non-null/non-empty
- No validation compares the signature against `previousRound.CalculateSignature(previousInValue)`
- No validation verifies the order matches `GetAbsModulus(signature.ToInt64(), minersCount) + 1`

## Notes

This vulnerability represents a critical consensus security failure. The signature-based randomization mechanism is fundamental to fair mining schedule distribution in AEDPoS. Without validation of signature correctness, any miner can deterministically control their mining position, undermining the entire consensus fairness model. The issue is exacerbated by the fact that detection requires off-chain computation and comparison, making real-time prevention difficult.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L244-247)
```csharp
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```
