### Title
Incomplete Evil Miner Replacement Due to Insufficient Alternative Candidates

### Summary
The `GetMinerReplacementInformation` function can return fewer alternative candidates than evil miners when candidate pools are exhausted. The consensus contract's replacement loop only iterates for the count of alternatives, leaving unreplaced evil miners in the active miner set. This compromises consensus integrity and network liveness by retaining offline or malicious miners.

### Finding Description

The vulnerability exists in the miner replacement flow between the Election and Consensus contracts.

In the Election contract, `GetMinerReplacementInformation` attempts to find replacement candidates for banned miners through two sources:
1. Candidates from the election snapshot (excluding initial miners and current miners)
2. Initial miners as fallback (excluding banned and current miners) [1](#0-0) 

The function identifies evil miners via `GetEvilMinersPubkeys`, which returns all miners in the current list marked as banned: [2](#0-1) 

However, the candidate selection logic can fail to produce enough alternatives when:
- Election snapshot candidates are scarce after filtering
- Initial miners are exhausted (already banned or in current miner list)

The critical flaw manifests in the consensus contract's replacement implementation: [3](#0-2) 

The loop at lines 311-339 only iterates `AlternativeCandidatePubkeys.Count` times, using index `i` to pair alternatives with evil miners. If `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, only the first N evil miners get replaced, while the remaining ones stay in the round's miner list.

Evil miners are detected based on missed time slots: [4](#0-3) 

The threshold is set to 3 days worth of missed slots: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Degradation:**
- Unreplaced evil miners remain in the active consensus round but won't produce blocks
- If 10 evil miners exist but only 3 get replaced, 7 unreliable miners stay active
- This reduces effective block production capacity by ~33% in a 21-miner system
- Increased block times and potential consensus stalls

**Network Liveness Risk:**
- With sufficient unreplaced evil miners, the network may fail to meet consensus requirements
- Could prevent the 2/3+ agreement needed for block finalization
- Critical for network operation as it affects all transactions and state transitions

**Affected Parties:**
- All network participants (validators, users, dApps)
- Treasury and reward distribution (dependent on reliable consensus)
- Cross-chain operations (require stable consensus for indexing)

**Severity Justification:**
HIGH - Directly compromises the consensus invariant "miner schedule integrity" and can cause operational DoS of the entire blockchain. No fund theft occurs, but network functionality is severely impaired.

### Likelihood Explanation

**Feasibility Conditions:**
The vulnerability triggers under realistic network conditions:
1. **Multiple Miner Failures:** Extended network issues, infrastructure failures, or coordinated attacks causing 10+ miners to go offline for 3+ days
2. **Depleted Candidate Pool:** Low election participation or most candidates already serving as miners
3. **Initial Miner Exhaustion:** Initial miners already in service or previously banned

**Attack Complexity:**
MEDIUM - Doesn't require direct attacker action. Natural network degradation or coordinated DDoS against miners can trigger the condition. An adversary could:
- DDoS multiple miners to force them offline
- Wait 3 days for them to be marked as evil
- Ensure low alternative candidate availability through economic disincentives

**Execution Practicality:**
The flow executes automatically during round generation without special permissions: [6](#0-5) 

**Detection Constraints:**
The issue is observable through monitoring but may not trigger immediate alarms. System continues operating with reduced capacity rather than failing completely, making the degradation subtle.

**Probability Assessment:**
MEDIUM-HIGH - In mature networks with stable miner sets, the candidate pool naturally shrinks. During network stress events (infrastructure failures, attacks), multiple miners can become evil simultaneously, making this scenario increasingly likely over time.

### Recommendation

**Immediate Fix:**
Modify the replacement logic in `GenerateNextRoundInformation` to validate sufficient alternatives before proceeding:

```csharp
// After line 308 in AEDPoSContract_ViewMethods.cs
if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
{
    // Add validation
    Assert(minerReplacementInformation.AlternativeCandidatePubkeys.Count >= 
           minerReplacementInformation.EvilMinerPubkeys.Count,
           "Insufficient alternative candidates for miner replacement.");
    
    for (var i = 0; i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
    {
        // ... existing replacement logic
    }
}
```

**Alternative Approaches:**
1. **Graceful Degradation:** Keep evil miners in place but mark them with reduced block production probability
2. **Emergency Pool:** Maintain a reserve of pre-approved backup validators
3. **Partial Replacement:** Allow rounds to continue with fewer miners if replacement is impossible

**Invariant Checks:**
Add monitoring assertion: `ActiveMinersCount >= MinimumViableMinersCount` after each round generation.

**Test Cases:**
1. Simulate 10 evil miners with only 3 alternatives available
2. Verify assertion triggers and prevents incomplete replacement
3. Test edge case: all initial miners banned or active
4. Validate consensus continues correctly after full replacement

### Proof of Concept

**Initial State:**
- Network has 21 active miners
- 10 miners go offline due to infrastructure failure
- These miners accumulate 4320+ missed time slots over 3 days
- Election snapshot contains 3 valid candidates (after filtering)
- All 21 initial miners are either: (a) already in current miner list, or (b) previously banned
- No additional candidates available

**Transaction Sequence:**

1. **Round N completes:** Evil miner detection runs during consensus information processing [7](#0-6) 
   
2. **Evil miners marked:** `UpdateCandidateInformation` called with `IsEvilNode=true` for all 10 miners, setting `BannedPubkeyMap[pubkey]=true` [8](#0-7) 

3. **Round N+1 generation:** `GenerateNextRoundInformation` calls `GetMinerReplacementInformation` with current miner list

4. **Replacement info returned:**
   - `EvilMinerPubkeys`: [M1, M2, M3, M4, M5, M6, M7, M8, M9, M10] (10 miners)
   - `AlternativeCandidatePubkeys`: [C1, C2, C3] (3 candidates)

5. **Replacement loop executes:** Only 3 iterations (i=0,1,2), replacing M1→C1, M2→C2, M3→C3

6. **Round N+1 miner list:** Contains C1, C2, C3, M4, M5, M6, M7, M8, M9, M10, and 11 other miners

**Expected Result:** All 10 evil miners replaced with 10 alternative candidates

**Actual Result:** Only 3 evil miners replaced; 7 evil miners (M4-M10) remain in active consensus round

**Success Condition:** Round N+1 begins with 7 unreliable miners still in the miner set, reducing effective block production capacity by 33% (7/21 miners offline).

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L401-404)
```csharp
    private List<string> GetEvilMinersPubkeys(IEnumerable<string> currentMinerList)
    {
        return currentMinerList.Where(p => State.BannedPubkeyMap[p]).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-306)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```
