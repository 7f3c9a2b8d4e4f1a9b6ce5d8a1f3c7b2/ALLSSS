### Title
Precision Loss in Bancor Formula Causes Zero Token Return for Small Trades with Large Connector Balances

### Summary
When connector balances grow very large relative to the payment amount in `GetReturnFromPaid`, the Bancor formula returns zero tokens due to integer truncation, causing users to lose their paid tokens without receiving anything in return. This occurs in both the simplified equal-weights formula and the general exponential formula when the calculated return value is less than 1 but greater than 0.

### Finding Description
The vulnerability exists in the `GetReturnFromPaid` function in BancorHelper.cs. [1](#0-0) 

**Root Cause:**
When `fromConnectorBalance (bf)` is much larger than `paidAmount (a)`, the Bancor return calculation produces a decimal value less than 1.0, which truncates to 0 when cast to `long`.

For the simplified case when weights are equal: [2](#0-1) 

The formula `bt / (bf + a) * a` returns 0 when: `a < bf / bt`

**Example with realistic values:**
- `fromConnectorBalance (bf)` = 100_000_00000000 (10^15) [3](#0-2) 
- `toConnectorBalance (bt)` = 1_000_00000000 (10^13)
- `paidAmount (a)` = 50 units

Calculation: `(10^13 / (10^15 + 50)) * 50 ≈ (10^13 / 10^15) * 50 = 0.5`
Cast to long: `(long)0.5 = 0`

The user pays 50 units but receives 0 tokens.

**Execution Path:**
1. User calls `Sell()` with a small amount [4](#0-3) 
2. `GetReturnFromPaid` is invoked with large connector balances [5](#0-4) 
3. Formula calculates value < 1.0
4. Cast to `long` truncates to 0
5. `amountToReceive = 0`
6. If user set `ReceiveLimit = 0` (no limit), transaction succeeds [6](#0-5) 
7. User's tokens are burned, but they receive 0 in return

**Why existing protections fail:**
The `ReceiveLimit` check only protects users who explicitly set a non-zero minimum. [6](#0-5)  Users who set `ReceiveLimit = 0` (meaning "no limit") are vulnerable.

### Impact Explanation
**Direct Fund Loss:**
Users lose their paid token amount while receiving 0 tokens in return. This is a permanent, unrecoverable loss of user funds.

**Quantified Damage:**
The threshold for zero return depends on connector balance ratios. With connector balances initialized at 10^13 to 10^15 range [7](#0-6) , payments below approximately 100-1000 units can return 0 tokens.

As connector balances grow through normal trading activity, the threshold increases. For balances reaching 10^17 (realistic for resource tokens with total supply of 5×10^17 [8](#0-7) ), payments below thousands or tens of thousands of units would return 0.

**Who is Affected:**
- Users making small trades (e.g., testing, micro-transactions, dust amounts)
- Users who don't set `ReceiveLimit` or set it to 0
- Impact worsens as protocol matures and connector balances grow

**Severity Justification: Medium**
- Direct loss of user funds (high impact)
- Requires specific conditions: large connector balances relative to payment (medium likelihood)
- Self-inflicted if users don't use `ReceiveLimit`, but protocol shouldn't allow zero returns on valid payments

### Likelihood Explanation
**Feasibility:**
No attacker is required. This is a natural consequence of:
1. Connector balances growing through normal protocol operation [9](#0-8) 
2. Users making small legitimate trades
3. Integer truncation in the return calculation [10](#0-9) 

**Conditions:**
- Connector balances reach levels where `bf / bt` ratio is large (happens naturally over time)
- User makes payment where `a < bf / bt` (for equal weights)
- User doesn't set appropriate `ReceiveLimit`

**Probability:**
- **Initially Low**: With initial virtual balances of 10^13, threshold is ~100 units
- **Increasing**: As real balances accumulate, threshold grows
- **Eventually Common**: For mature connectors with large balances, affects all small trades

**Detection:**
Users may not immediately notice if they don't check return amounts carefully. Transaction succeeds without error.

### Recommendation
**Immediate Fix:**
Add minimum return validation before the cast to `long`:

```csharp
public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
    long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
{
    // ... existing code ...
    
    if (wf == wt)
    {
        decimal returnValue = bt / (bf + a) * a;
        if (returnValue < 1m && paidAmount > 0)
            throw new InvalidValueException("Trade amount too small relative to connector balances. Minimum return would be zero.");
        return (long)returnValue;
    }
    
    var x = bf / (bf + a);
    var y = wf / wt;
    decimal result = bt * (decimal.One - Exp(y * Ln(x)));
    if (result < 1m && paidAmount > 0)
        throw new InvalidValueException("Trade amount too small relative to connector balances. Minimum return would be zero.");
    return (long)result;
}
```

**Alternative Fix:**
Calculate and enforce minimum trade amounts based on current connector balances:
```csharp
// In Sell method, before calling GetReturnFromPaid:
long minimumTradeAmount = CalculateMinimumTrade(fromConnector, toConnector);
Assert(input.Amount >= minimumTradeAmount, $"Trade amount must be at least {minimumTradeAmount}");
```

**Invariant to Add:**
For all successful trades where `paidAmount > 0`, the return value must satisfy: `returnAmount > 0`

**Test Cases:**
1. Test with large connector balances (10^15) and small payments (1-1000 units)
2. Test boundary conditions where return is exactly 1 unit
3. Test with growing connector balances to verify threshold changes
4. Verify error messages guide users toward valid trade sizes

### Proof of Concept
**Initial State:**
- ResourceConnector balance: 100_000_00000000 (10^15 units)
- NativeConnector balance: 1_000_00000000 (10^13 units)
- Both weights: 0.5
- User has 1000 units of resource token

**Exploit Steps:**
1. User calls `Sell()` with:
   - `Symbol`: "RESOURCE"
   - `Amount`: 50 (units to sell)
   - `ReceiveLimit`: 0 (no minimum required)

2. `GetReturnFromPaid` calculates:
   - `bf = 10^15`, `a = 50`, `bt = 10^13`, `wf = wt = 0.5`
   - Equal weights, so: `return (long)(10^13 / (10^15 + 50) * 50)`
   - = `(long)(10^13 / 10^15 * 50)`
   - = `(long)(0.5)`
   - = `0`

3. `amountToReceive = 0`
4. Check passes: `0 >= 0` (ReceiveLimit check) [6](#0-5) 
5. Transfer 0 base tokens to user [11](#0-10) 
6. Burn user's 50 resource tokens [12](#0-11) 

**Expected vs Actual:**
- **Expected**: User receives some base tokens proportional to their 50 unit payment
- **Actual**: User receives 0 base tokens, loses 50 resource tokens permanently

**Success Condition:**
User's resource token balance decreases by 50, base token balance increases by 0, confirming fund loss.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L5-16)
```csharp
    public const long NativeTokenConnectorInitialVirtualBalance = 100_000_00000000;

    // Token Converter Contract related.
    public const string TokenConverterFeeRate = "0.005";

    // Resource token related.
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;

    public const int ResourceTokenDecimals = 8;

    //resource to sell
    public const long ResourceTokenInitialVirtualBalance = 100_000;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-172)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L180-180)
```csharp
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L186-192)
```csharp
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                To = Context.Sender,
                Amount = amountToReceive
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L196-203)
```csharp
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = input.Symbol,
                From = Context.Sender,
                To = Context.Self,
                Amount = input.Amount
            });
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
