### Title
Last Irreversible Block Height Calculation Fails When Miner Set Changes Due to Mismatched Consensus Threshold

### Summary
The `LastIrreversibleBlockHeightCalculator` uses the current round's miner count to calculate `MinersCountOfConsent` threshold, but collects implied irreversible block heights from the previous round. When the miner set changes significantly between rounds (especially at term transitions), new miners have no entries in the previous round, making it impossible to meet the threshold based on the new miner count, causing LIB to remain at zero and blocking cross-chain operations.

### Finding Description

The vulnerability exists in the LIB calculation logic where a logical inconsistency occurs between the data source and the threshold calculation.

**Root Cause Location:** [1](#0-0) 

The `MinersCountOfConsent` property is calculated as `(count * 2 / 3) + 1` based on the current round's miner count: [2](#0-1) 

**Execution Path:**

1. When a term changes, new miners are elected and can differ completely from previous miners: [3](#0-2) 

2. The first round of the new term is generated with the new miner set and `IsMinerListJustChanged = true`: [4](#0-3) 

3. During block production in the new round, `ProcessUpdateValue` calls the LIB calculator: [5](#0-4) 

4. The calculator collects miners who have mined in the current round, then attempts to fetch their implied heights from the previous round: [6](#0-5) 

5. The `GetSortedImpliedIrreversibleBlockHeights` method filters by public keys that exist in the previous round: [7](#0-6) 

**Why Protections Fail:**

The code does not account for miner set changes when calculating the threshold. The `IsMinerListJustChanged` flag is set but not checked in the LIB calculator: [8](#0-7) 

**Concrete Example:**
- Previous round (Term N): 5 miners {A, B, C, D, E}, MinersCountOfConsent = 4
- New round (Term N+1): 7 miners {A, B, C, F, G, H, I}, MinersCountOfConsent = 5
- When calculating LIB: Only miners A, B, C can contribute implied heights from previous round (max 3)
- Check: 3 < 5 fails, so `libHeight = 0`
- LIB cannot advance because the threshold of 5 can never be met with only 3 continuing miners

### Impact Explanation

**Consensus/Cross-Chain Integrity Impact:**
- LIB fails to advance for the entire round following a miner set change
- Cross-chain operations that depend on irreversible block confirmation are blocked
- Transaction finality guarantees are delayed

**Operational Impact:**
- DoS on cross-chain indexing and verification flows that wait for LIB
- If miner set changes are frequent (through term changes or evil miner replacement), LIB advancement can be significantly degraded
- Parent/side-chain communication is disrupted during affected rounds

**Severity Justification:**
This is a HIGH severity issue because:
1. It breaks the fundamental consensus invariant that LIB must advance
2. Cross-chain operations are core functionality and their blocking affects the entire network
3. The issue occurs naturally without attacker intervention at every term change with significant miner turnover
4. The election system allows complete miner set replacement, making worst-case scenarios achievable

### Likelihood Explanation

**Feasible Preconditions:**
- Occurs naturally at term transitions when elected miners change
- No special attacker capabilities required
- Election contract allows arbitrary miner set changes based on votes: [9](#0-8) 

**Execution Practicality:**
- Happens automatically during normal consensus operations
- Term changes occur periodically (every term period)
- Tests confirm miners can change between terms: [10](#0-9) 

**Probability Assessment:**
- Guaranteed to occur when: `(new_miners - overlap_miners) > (old_miners / 3)`
- With election-based miner selection, significant turnover is expected
- Higher probability when miner count increases between terms
- No detection or mitigation mechanisms in place

### Recommendation

**Code-Level Mitigation:**

Modify the LIB calculator to use an appropriate threshold when miner set changes:

```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

    var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    
    // Use previous round's threshold when miner list just changed
    var requiredConsent = _currentRound.IsMinerListJustChanged 
        ? _previousRound.MinersCountOfConsent 
        : _currentRound.MinersCountOfConsent;
    
    if (impliedIrreversibleHeights.Count < requiredConsent)
    {
        libHeight = 0;
        return;
    }

    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

**Alternative Solution:**

Calculate threshold based on the intersection of current and previous miner sets:

```csharp
var continuingMinersCount = _currentRound.RealTimeMinersInformation.Keys
    .Intersect(_previousRound.RealTimeMinersInformation.Keys).Count();
var requiredConsent = (continuingMinersCount.Mul(2).Div(3)).Add(1);
```

**Invariant Checks to Add:**
1. Verify that LIB advances within expected time bounds during normal operation
2. Add explicit handling for `IsMinerListJustChanged` flag in LIB calculation
3. Ensure cross-chain operations detect and handle LIB stalls gracefully

**Test Cases:**
1. Test term change with 100% miner replacement
2. Test term change with >33% miner replacement
3. Test term change with gradual miner count increase
4. Verify LIB advances correctly in round following miner set change
5. Test evil miner replacement mid-term scenarios

### Proof of Concept

**Initial State:**
- Term N, Round R with 5 miners: {A, B, C, D, E}
- All miners have mined and set ImpliedIrreversibleBlockHeight
- Current LIB: height 1000

**Transaction Steps:**

1. **Term Change Occurs:**
   - Election results: 7 miners {A, B, C, F, G, H, I} (4 new miners)
   - ProcessNextTerm called with new miner list
   - Round R+1 created with IsMinerListJustChanged = true
   - MinersCountOfConsent for Round R+1 = (7 * 2 / 3) + 1 = 5

2. **First Block Produced in Round R+1 (by miner F):**
   - F calls UpdateValue with their ImpliedIrreversibleBlockHeight
   - ProcessUpdateValue invokes LastIrreversibleBlockHeightCalculator
   - minedMiners = [F] (only F has mined so far)
   - impliedIrreversibleHeights from Round R = [] (F doesn't exist in Round R)
   - Check: 0 < 5, so libHeight = 0

3. **More Blocks Produced:**
   - Even when all 7 miners have produced blocks in Round R+1
   - Only A, B, C have entries in Round R (3 miners)
   - impliedIrreversibleHeights.Count = 3
   - Check: 3 < 5, so libHeight = 0

**Expected Result:**
LIB should advance to reflect consensus among available miners

**Actual Result:**
LIB remains at 0 (or doesn't advance) throughout Round R+1 because the threshold of 5 can never be met with only 3 continuing miners

**Success Condition:**
LIB fails to advance despite sufficient consensus among miners present in both rounds, blocking cross-chain operations for the entire round duration.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L52-84)
```csharp
    private List<ByteString> GetVictories(List<string> currentMiners)
    {
        var validCandidates = GetValidCandidates();

        List<ByteString> victories;

        Context.LogDebug(() => $"Valid candidates: {validCandidates.Count} / {State.MinersCount.Value}");

        var diff = State.MinersCount.Value - validCandidates.Count;
        // Valid candidates not enough.
        if (diff > 0)
        {
            victories =
                new List<ByteString>(validCandidates.Select(v => ByteStringHelper.FromHexString(v)));
            var backups = currentMiners.Where(k => !validCandidates.Contains(k)).ToList();
            if (State.InitialMiners.Value != null)
                backups.AddRange(
                    State.InitialMiners.Value.Value.Select(k => k.ToHex()).Where(k => !backups.Contains(k)));

            victories.AddRange(backups.OrderBy(p => p)
                .Take(Math.Min(diff, currentMiners.Count))
                // ReSharper disable once ConvertClosureToMethodGroup
                .Select(v => ByteStringHelper.FromHexString(v)));
            Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
            return victories;
        }

        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L107-109)
```csharp
        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L117-118)
```csharp
            minerCount = currentRound.RealTimeMinersInformation.Count;
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);
```
