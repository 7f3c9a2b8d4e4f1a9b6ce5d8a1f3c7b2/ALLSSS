### Title
Governance Bypass via Malicious Contract in MethodFeeController Validation

### Summary
The `ChangeMethodFeeController()` function allows an attacker to permanently bypass governance controls by providing a malicious contract address that always returns true for organization validation. Once exploited, the attacker gains unilateral control over method fees without requiring future governance approvals, effectively hijacking a critical protocol parameter.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` function [1](#0-0) 

The root cause is in the `CheckOrganizationExist()` helper method which makes an unconstrained cross-contract call to the caller-provided contract address [2](#0-1) 

The function accepts an `AuthorityInfo` input structure containing two fields: `contract_address` (the governance contract) and `owner_address` (the organization address) [3](#0-2) 

**Why existing protections fail:**

1. The sender authorization check only validates that the caller is the current controller's owner address, not that the new controller's contract address is legitimate [4](#0-3) 

2. The validation at line 28-29 calls `CheckOrganizationExist()` on the attacker-provided `AuthorityInfo`, where the `ContractAddress` field points to a malicious contract deployed by the attacker

3. The malicious contract can implement a fake `ValidateOrganizationExist` method that always returns true for any address, bypassing the assertion

4. No whitelist validation exists to restrict the `ContractAddress` to known governance contracts (Parliament, Association, or Referendum) [5](#0-4) 

**Contrast with secure implementation:**

The CrossChain contract demonstrates the correct pattern by explicitly validating that the new controller's contract address equals the Parliament contract address before accepting it [6](#0-5) 

### Impact Explanation

**Critical Auth/Governance Impact:**

1. **Permanent governance bypass**: The attacker gains complete, unilateral control over method fees for all token contract operations, bypassing all future governance requirements

2. **Economic manipulation**: The attacker can arbitrarily set transaction fees to:
   - Zero (enabling free transactions and potential spam attacks)
   - Extremely high values (causing DoS by making transactions economically infeasible)
   - Discriminatory rates that favor certain operations

3. **Protocol-wide disruption**: Method fees affect ALL token operations including transfers, approvals, minting, and burning. This impacts every user and application on the chain

4. **Irreversible damage**: Once the malicious controller is set, it cannot be changed back through legitimate governance since the attacker's fake contract controls the approval process

5. **Cascading failures**: Other contracts that depend on the token contract's fee structure may malfunction or be exploited

The severity is **Critical** because it permanently compromises a fundamental protocol parameter that affects all chain participants, with no recovery mechanism through legitimate governance channels.

### Likelihood Explanation

**Preconditions:**
- The attacker must be able to execute a transaction as the current `MethodFeeController.OwnerAddress`, which is typically a Parliament/Association/Referendum organization address
- This requires getting a malicious proposal approved through the current governance system

**Attack feasibility:**

1. **Reachable entry point**: The `ChangeMethodFeeController()` method is a public function exposed through the ACS1 standard interface [7](#0-6) 

2. **Realistic attacker capabilities**: 
   - Governance manipulation through social engineering or proposal content obfuscation is a known attack vector
   - A single approved malicious proposal is sufficient to execute the attack
   - The attacker can deploy their malicious validation contract beforehand

3. **Execution practicality**:
   - Deploy malicious contract with fake `ValidateOrganizationExist` method
   - Submit governance proposal to call `ChangeMethodFeeController` with malicious `AuthorityInfo`
   - Once approved and released, the attack is complete

4. **Economic rationality**: 
   - Cost: Minimal (contract deployment + governance proposal)
   - Benefit: Complete control over protocol-critical parameter
   - The attack permanently escalates a one-time governance compromise into perpetual unilateral control

5. **Detection difficulty**: The malicious contract may not be obviously malicious until after it's set as the controller, and standard governance processes provide no defense mechanism

The likelihood is **High** in any scenario where an attacker can achieve temporary governance influence, as this single-use access converts into permanent control.

### Recommendation

**Primary fix** - Add explicit contract address validation:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known governance contract
    var allowedContracts = new[] {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(allowedContracts.Contains(authorityInfo.ContractAddress), 
        "Contract address must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Alternative fix** - Follow the CrossChain contract pattern and restrict to Parliament only:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value = 
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    
    Assert(input.ContractAddress == State.ParliamentContract.Value, 
        "Only Parliament contract is allowed.");
    Assert(CheckOrganizationExist(input), "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Required test cases:**
1. Test attempting to set controller with non-governance contract address (should fail)
2. Test attempting to set controller with Association contract (should succeed with primary fix, fail with alternative)
3. Test attempting to set controller with arbitrary contract address (should fail)
4. Verify existing legitimate controller changes still work

### Proof of Concept

**Initial state:**
- Token contract deployed with default Parliament controller
- Current controller: `{ ContractAddress: ParliamentContract, OwnerAddress: DefaultOrganization }`

**Attack sequence:**

1. **Deploy malicious contract** with fake validation:
```csharp
public BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true }; // Always returns true
}
```

2. **Create governance proposal** through current Parliament organization:
   - Method: `ChangeMethodFeeController`
   - Parameter: `{ ContractAddress: MaliciousContract, OwnerAddress: AttackerAddress }`

3. **Get proposal approved** (through social engineering, vote manipulation, or exploiting governance process)

4. **Release proposal** - Parliament contract calls `ChangeMethodFeeController`

5. **Validation bypass occurs**:
   - Line 27: Check passes (sender is Parliament organization) [4](#0-3) 
   - Line 28: Calls malicious contract's `ValidateOrganizationExist` [8](#0-7) 
   - Line 29: Assertion passes (malicious contract returned true) [9](#0-8) 
   - Line 31: New malicious controller is set [10](#0-9) 

**Expected result:** Transaction should fail with "Invalid authority input"

**Actual result:** Transaction succeeds, attacker now controls method fees unilaterally

**Success validation:**
- Call `GetMethodFeeController()` - returns `{ ContractAddress: MaliciousContract, OwnerAddress: AttackerAddress }`
- Attacker can now call `SetMethodFee()` without any governance approval [11](#0-10) 
- Legitimate governance can no longer change the controller

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/authority_info.proto (L5-9)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-36)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");

    public static readonly Hash VoteContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Vote");
    public static readonly Hash ProfitContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Profit");

    public static readonly Hash CrossChainContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.CrossChain");

    public static readonly Hash TokenConverterContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.TokenConverter");

    public static readonly Hash EconomicContractSystemHashName = HashHelper.ComputeFrom("AElf.ContractNames.Economic");

    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L61-73)
```csharp
    public override Empty ChangeCrossChainIndexingController(AuthorityInfo input)
    {
        AssertCrossChainIndexingControllerAuthority(Context.Sender);
        SetContractStateRequired(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(
            input.ContractAddress == State.ParliamentContract.Value &&
            ValidateParliamentOrganization(input.OwnerAddress), "Invalid authority input.");
        State.CrossChainIndexingController.Value = input;
        Context.Fire(new CrossChainIndexingControllerChanged
        {
            AuthorityInfo = input
        });
        return new Empty();
```

**File:** protobuf/acs1.proto (L25-27)
```text
    // Change the method fee controller, the default is parliament and default organization.
    rpc ChangeMethodFeeController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
```
