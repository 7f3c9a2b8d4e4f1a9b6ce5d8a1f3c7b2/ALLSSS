# Audit Report

## Title
Case-Sensitive Pubkey Comparison Allows Banned Initial Miners to Bypass Ban and Replace Their Public Key

## Summary
The Election contract's ban system can be bypassed by banned initial miners using case-variant hex strings. The `IsPubkeyBanned()` function performs case-sensitive dictionary lookups, but the consensus contract stores banned pubkeys in lowercase format using `ToHex()`. This allows a banned initial miner to use uppercase hex variants of their pubkey to pass ban checks in `SetCandidateAdmin` and `ReplaceCandidatePubkey`, enabling them to replace their banned pubkey with a new one and continue participating in consensus.

## Finding Description

The root cause is a case-sensitivity mismatch in pubkey handling across the Election and Consensus contracts.

The `IsPubkeyBanned()` helper performs direct case-sensitive dictionary lookups on `BannedPubkeyMap`: [1](#0-0) 

However, when the consensus contract bans evil miners, it uses pubkeys generated by `ToHex()`, which produces lowercase hex strings: [2](#0-1) 

The formula at lines 38 and 41 adds `0x20` (32 in decimal) to convert uppercase hex characters to lowercase (e.g., 'A' becomes 'a').

Evil miners are detected and banned with lowercase pubkeys in the consensus contract: [3](#0-2) 

The `evilMiner` values come from `MinerInRound.Pubkey` fields, which are assigned using `ToHex()` during round generation: [4](#0-3) 

The ban is stored in lowercase: [5](#0-4) 

**Why protections fail:**

`SetCandidateAdmin` checks the ban without normalizing the input: [6](#0-5) 

The permission check at line 32 uses `HexStringToByteArray`, which is **case-insensitive**: [7](#0-6) 

`Convert.ToByte(string, 16)` in C# accepts both uppercase and lowercase hex strings, treating "ABC123" and "abc123" as identical bytes.

`IsCurrentCandidateOrInitialMiner` also uses case-insensitive byte conversion: [8](#0-7) 

`ReplaceCandidatePubkey` has the same case-sensitivity issues: [9](#0-8) 

The replacement proceeds successfully, removing the old pubkey from InitialMiners and adding the new one: [10](#0-9) 

## Impact Explanation

This vulnerability directly compromises **consensus integrity**, which is a critical security boundary in the blockchain system.

**Attack Scenario:**
1. Initial miner with pubkey bytes is banned by consensus as lowercase "abc123..." in `BannedPubkeyMap`
2. Attacker calls `SetCandidateAdmin(Pubkey="ABC123...", Admin=AttackerAddress)` - bypasses ban check due to case difference
3. Attacker calls `ReplaceCandidatePubkey(OldPubkey="ABC123...", NewPubkey="newkey...")` - replacement succeeds
4. Banned evil miner is now participating in consensus with a new identity

**Consequences:**
- **Consensus security violation**: Evil miners can evade permanent exclusion
- **Critical invariant broken**: The system's guarantee that detected evil miners are permanently banned is violated
- **No economic cost**: Attacker only needs transaction fees, no tokens at risk
- **Privilege escalation**: Initial miners (highest consensus privilege) can bypass punishment

**Severity Assessment: HIGH** - This breaks a fundamental consensus security guarantee. Initial miners are the most trusted consensus participants, and allowing them to bypass bans undermines the entire evil node detection and punishment mechanism.

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an initial miner (set during chain initialization)
- Must control the private key of a banned pubkey
- Must be detected as evil and banned by the consensus contract

**Attack Complexity: LOW**
- Requires only two simple contract calls: `SetCandidateAdmin` then `ReplaceCandidatePubkey`
- No timing constraints or race conditions
- No need for collusion or compromised trusted roles
- The uppercase transformation is trivial

**Feasibility: HIGH**
- Initial miners exist in every AElf chain deployment
- Evil node detection is an active, documented feature in the consensus contract
- Banned miners have strong incentives (rewards, influence) to return to consensus
- The attack is deterministic and easily reproducible

**Detection Difficulty: HIGH**
- The lowercase ban remains in `BannedPubkeyMap`, appearing legitimate
- State changes (admin updates, pubkey replacements) look normal
- Only careful case-by-case analysis would reveal the bypass

**Overall Likelihood: HIGH** - Given the low complexity and high feasibility, this is highly likely to be exploited by any banned initial miner.

## Recommendation

Normalize all pubkey strings to lowercase before using them as dictionary keys or in comparisons. Apply this consistently across all pubkey operations.

**Recommended fix for `IsPubkeyBanned`:**
```csharp
private bool IsPubkeyBanned(string pubkey)
{
    return State.BannedPubkeyMap[pubkey.ToLower()];
}
```

**Recommended fix for `SetCandidateAdmin`:**
```csharp
public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
{
    var normalizedPubkey = input.Pubkey.ToLower();
    Assert(IsCurrentCandidateOrInitialMiner(normalizedPubkey),
        "Pubkey is neither a current candidate nor an initial miner.");
    Assert(!IsPubkeyBanned(normalizedPubkey), "Pubkey is already banned.");
    
    // Continue with normalizedPubkey...
}
```

Apply similar normalization in:
- `ReplaceCandidatePubkey` (both old and new pubkeys)
- `AnnounceElection` / `AnnounceElectionFor`
- `QuitElection`
- `RemoveEvilNode`
- Any other method that accepts pubkey strings as input

Additionally, normalize pubkeys when storing in `BannedPubkeyMap` to ensure consistency:
```csharp
State.BannedPubkeyMap[input.Pubkey.ToLower()] = true;
```

## Proof of Concept

```csharp
[Fact]
public async Task BannedInitialMiner_CanBypassBan_UsingUppercaseVariant()
{
    // Setup: Initialize election contract with initial miner
    var initialMinerKeyPair = SampleECKeyPairs.KeyPairs[0];
    var initialMinerPubkeyLowercase = initialMinerKeyPair.PublicKey.ToHex(); // lowercase
    var initialMinerPubkeyUppercase = initialMinerPubkeyLowercase.ToUpper(); // uppercase variant
    
    await InitializeElectionContract(new List<string> { initialMinerPubkeyLowercase });
    
    // Step 1: Consensus contract bans the initial miner (using lowercase)
    await ConsensusContractStub.UpdateCandidateInformation.SendAsync(
        new UpdateCandidateInformationInput
        {
            Pubkey = initialMinerPubkeyLowercase,
            IsEvilNode = true
        });
    
    // Verify: Lowercase variant is banned
    var isBannedLowercase = await ElectionContractStub.IsPubkeyBanned.CallAsync(
        new StringValue { Value = initialMinerPubkeyLowercase });
    isBannedLowercase.Value.ShouldBeTrue();
    
    // Attack Step 1: Use uppercase variant to set admin (bypasses ban check)
    var attackerAddress = Accounts[1].Address;
    var result1 = await ElectionContractStub.SetCandidateAdmin.SendAsync(
        new SetCandidateAdminInput
        {
            Pubkey = initialMinerPubkeyUppercase, // uppercase variant
            Admin = attackerAddress
        });
    result1.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCEEDS!
    
    // Attack Step 2: Replace banned pubkey with new one
    var newKeyPair = SampleECKeyPairs.KeyPairs[10];
    var newPubkey = newKeyPair.PublicKey.ToHex();
    
    var attackerStub = GetElectionContractStub(Accounts[1].KeyPair);
    var result2 = await attackerStub.ReplaceCandidatePubkey.SendAsync(
        new ReplaceCandidatePubkeyInput
        {
            OldPubkey = initialMinerPubkeyUppercase, // uppercase variant
            NewPubkey = newPubkey
        });
    result2.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined); // SUCCEEDS!
    
    // Verify: Banned miner successfully replaced their pubkey
    var initialMiners = await ElectionContractStub.GetInitialMiners.CallAsync(new Empty());
    initialMiners.Value.Select(p => p.ToHex()).ShouldNotContain(initialMinerPubkeyLowercase);
    initialMiners.Value.Select(p => p.ToHex()).ShouldContain(newPubkey);
    
    // Impact: Banned evil miner can now participate in consensus with new identity
}
```

## Notes

This vulnerability is particularly severe because:

1. **Initial miners are privileged**: They are set during chain initialization and have the highest consensus authority
2. **Complete bypass**: The ban system is entirely circumvented, not just weakened
3. **Permanent damage**: Once replaced, the evil miner has a clean identity with no ban history
4. **Difficult to detect**: Requires analyzing case variations in pubkey strings
5. **Affects all AElf chains**: Any deployment with initial miners is vulnerable

The fix requires careful normalization of all pubkey strings throughout the Election contract, with particular attention to user-provided inputs in `SetCandidateAdmin`, `ReplaceCandidatePubkey`, and related methods.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-40)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L61-64)
```csharp
    private bool IsPubkeyBanned(string pubkey)
    {
        return State.BannedPubkeyMap[pubkey];
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L75-82)
```csharp
    private bool IsCurrentCandidateOrInitialMiner(string pubkey)
    {
        var isCurrentCandidate = State.CandidateInformationMap[pubkey] != null &&
                                 State.CandidateInformationMap[pubkey].IsCurrentCandidate;
        var isInitialMiner = State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey)));
        return isCurrentCandidate || isInitialMiner;
    }
```

**File:** src/AElf.Types/Extensions/ByteExtensions.cs (L21-45)
```csharp
        public static string ToHex(this byte[] bytes, bool withPrefix = false)
        {
            var offset = withPrefix ? 2 : 0;
            var length = bytes.Length * 2 + offset;
            var c = new char[length];

            byte b;

            if (withPrefix)
            {
                c[0] = '0';
                c[1] = 'x';
            }

            for (int bx = 0, cx = offset; bx < bytes.Length; ++bx, ++cx)
            {
                b = (byte)(bytes[bx] >> 4);
                c[cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);

                b = (byte)(bytes[bx] & 0x0F);
                c[++cx] = (char)(b > 9 ? b + 0x37 + 0x20 : b + 0x30);
            }

            return new string(c);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-38)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L220-226)
```csharp
        var initialMiners = State.InitialMiners.Value;
        if (initialMiners.Value.Contains(oldPubkeyBytes))
        {
            initialMiners.Value.Remove(oldPubkeyBytes);
            initialMiners.Value.Add(newPubkeyBytes);
            State.InitialMiners.Value = initialMiners;
        }
```

**File:** src/AElf.Types/Helper/ByteArrayHelper.cs (L8-19)
```csharp
        public static byte[] HexStringToByteArray(string hex)
        {
            if (hex.Length >= 2 && hex[0] == '0' && (hex[1] == 'x' || hex[1] == 'X'))
                hex = hex.Substring(2);
            var numberChars = hex.Length;
            var bytes = new byte[numberChars / 2];

            for (var i = 0; i < numberChars; i += 2)
                bytes[i / 2] = Convert.ToByte(hex.Substring(i, 2), 16);

            return bytes;
        }
```
