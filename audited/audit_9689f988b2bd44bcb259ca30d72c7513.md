### Title
Excessive Grace Period Enables Accumulation of Expired Profit Details Leading to DOS on Beneficiary Operations

### Summary
The `MaximumProfitReceivingDuePeriodCount` constant of 1024 periods creates an excessively long grace period (approximately 19+ years for election terms) during which fully-claimed profit details remain in storage before cleanup. Users who accumulate hundreds of vote/profit details over time will eventually face transaction failures when attempting to add new beneficiaries due to the O(N*M) complexity of the cleanup operation exceeding gas limits.

### Finding Description

The root cause lies in the cleanup mechanism within the `AddBeneficiary` method: [1](#0-0) 

This cleanup only removes profit details that satisfy:
- `EndPeriod != long.MaxValue` (not perpetual)
- `LastProfitPeriod >= EndPeriod` (fully claimed)  
- `EndPeriod + ProfitReceivingDuePeriodCount < CurrentPeriod` (beyond grace period)

With the maximum value defined as: [2](#0-1) 

This creates a 1024-period window where fully-claimed details persist in storage. In the election context where each vote creates a profit detail: [3](#0-2) 

Users can accumulate hundreds of `ProfitDetail` entries over time. The `Details` field is a protobuf `RepeatedField`: [4](#0-3) 

The cleanup operation has O(N*M) complexity where N is total details and M is expired details to remove. Each `Remove()` call on a `RepeatedField` is O(N), resulting in potentially millions of operations when processing hundreds of accumulated details. The entire updated `ProfitDetails` must be written back to state: [5](#0-4) 

### Impact Explanation

When a scheme is configured with `ProfitReceivingDuePeriodCount = 1024` and users accumulate hundreds of profit details through voting or staking activities, the following harm occurs:

1. **Denial of Service on Voting/Staking**: After the grace period expires (1024+ periods), any attempt to call `AddBeneficiary` (triggered by voting, staking, or scheme participation) will execute expensive cleanup operations that may exceed AElf transaction gas limits, causing the transaction to fail.

2. **User Lockout**: Affected users cannot participate in new voting or staking activities because the `AddBeneficiary` operation becomes effectively blocked. This prevents normal protocol participation.

3. **Protocol Operation Disruption**: Election and token holder schemes rely on beneficiary additions for reward distribution. Users with accumulated details face permanent operational barriers.

The severity is Medium because while the impact is significant (operational DOS), the likelihood is constrained by the extremely long timeframe (1024 periods â‰ˆ 19+ years for election terms) required for the vulnerability to manifest.

### Likelihood Explanation

**Attacker Capabilities**: No attacker is required - this is a design issue affecting normal users through regular protocol usage.

**Attack Complexity**: 
1. User participates in elections/staking, creating profit details via normal voting
2. User claims profits regularly (or details expire naturally)
3. System continues operating for 1024+ periods
4. User attempts new voting/staking operation, triggering cleanup

**Feasibility Conditions**:
- Scheme configured with maximum `ProfitReceivingDuePeriodCount = 1024` (validated in scheme creation): [6](#0-5) 

- User accumulates 200+ profit details over time (realistic for active voters)
- System operates continuously for 1024+ periods without parameter changes
- The extremely long timeframe (19+ years if periods are 7-day election terms) significantly reduces practical likelihood

**Detection/Operational Constraints**: While `ClaimProfits` is limited to processing 10 details per call to manage gas costs: [7](#0-6) 

The `AddBeneficiary` cleanup has no such limit, creating an asymmetric risk.

**Probability**: Low in short-term (requires multi-year accumulation), but inevitable if the system operates with these parameters long enough without governance intervention.

### Recommendation

**Immediate Mitigation**:
1. Reduce the maximum grace period constant to a more reasonable value (e.g., 100 periods):
```csharp
public const int MaximumProfitReceivingDuePeriodCount = 100; // ~2 years for election terms
```

2. Add batch size limits to the cleanup operation in `AddBeneficiary`, similar to `ClaimProfits`:
```csharp
// Remove details too old (limit to prevent gas exhaustion)
var oldProfitDetails = currentProfitDetails.Details.Where(
    d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
         d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod)
    .Take(ProfitContractConstants.ProfitReceivingLimitForEachTime) // Limit cleanup batch
    .ToList();
```

3. Implement a separate cleanup function callable by users to proactively remove expired details without adding new beneficiaries.

**Test Cases**:
- Verify gas consumption remains acceptable with 500+ accumulated profit details
- Test that cleanup gracefully handles large batches without exceeding gas limits
- Confirm users can eventually clean up all details through multiple calls if needed

### Proof of Concept

**Initial State**:
- Election scheme created with `ProfitReceivingDuePeriodCount = 1024`
- Current period: 1

**Transaction Sequence**:
1. User votes 300 times over periods 1-1000, creating 300 profit details
2. User calls `ClaimProfits` multiple times (30+ calls at 10 details each) to claim all profits
3. All 300 details now have `LastProfitPeriod >= EndPeriod` 
4. System advances to period 2025 (beyond 1024-period grace for earliest votes)
5. User attempts to vote again, calling `AddBeneficiary` via election contract
6. Cleanup operation attempts to remove 250+ expired details with O(300*250) = O(75,000) operations
7. Transaction fails with out-of-gas error

**Expected Result**: User can vote successfully

**Actual Result**: Transaction reverts due to excessive gas consumption in cleanup operation, permanently blocking user from future voting until manual intervention

**Success Condition**: The vulnerability is confirmed if accumulated profit details cause `AddBeneficiary` transactions to consistently fail after the grace period expires due to cleanup gas costs.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L51-54)
```csharp
            Assert(
                input.ProfitReceivingDuePeriodCount > 0 &&
                input.ProfitReceivingDuePeriodCount <= ProfitContractConstants.MaximumProfitReceivingDuePeriodCount,
                "Invalid profit receiving due period count.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L209-209)
```csharp
        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-774)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L7-7)
```csharp
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** protobuf/profit_contract.proto (L233-236)
```text
message ProfitDetails {
    // The profit information.
    repeated ProfitDetail details = 1;
}
```
