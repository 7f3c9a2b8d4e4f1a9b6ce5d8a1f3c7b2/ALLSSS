### Title
Zero Block Production Limit During Abnormal Consensus Status Due to Disjoint Miner Sets

### Summary
The `GetMaximumBlocksCount()` function can return zero when there is no overlap between miners who produced blocks in the last two consecutive rounds during Abnormal blockchain status. This severely limits block production to only 1 block per miner (down from 8), exacerbating consensus issues precisely when the blockchain needs increased throughput to recover.

### Finding Description

The vulnerability exists in the Abnormal status calculation path where the maximum tiny blocks count is computed based on miner participation. [1](#0-0) 

The factor calculation multiplies `minersOfLastTwoRounds` (the count of miners who appear in both round N-1 and N-2) by a positive threshold value. While the question posed concerns whether `SevereStatusRoundsThreshold.Sub(currentRoundNumber.Sub(libRoundNumber))` can equal zero, analysis of the Abnormal status boundary conditions shows this subtraction ranges from 1 to `SevereStatusRoundsThreshold - 3`, never reaching zero. [2](#0-1) 

However, the actual vulnerability occurs when `minersOfLastTwoRounds` equals zero - which happens when the miner sets in rounds N-1 and N-2 are completely disjoint (no common miners). The intersection operation can legitimately return zero: [3](#0-2) 

When `minersOfLastTwoRounds = 0`, the entire factor becomes zero regardless of the threshold value. The `Ceiling(0, divisor)` function returns 0: [4](#0-3) 

This causes `GetMaximumBlocksCount()` to return `Math.Min(8, 0) = 0`. This value is then used by the consensus behaviour providers to determine if miners can produce tiny blocks: [5](#0-4) 

With `_maximumBlocksCount = 0`, the condition `ActualMiningTimes.Count < 0` is always false, preventing miners from producing any tiny blocks after their initial UpdateValue block.

### Impact Explanation

**Operational Impact - Severe Block Production Throttling:**

When this condition triggers, each miner's block production capacity drops from the normal maximum of 8 tiny blocks to just 1 block (the initial UpdateValue transaction). This represents an 87.5% reduction in throughput per miner time slot. [6](#0-5) 

The impact is particularly severe because:
1. This occurs during **Abnormal blockchain status** - when the chain is already struggling with consensus (LIB rounds falling behind)
2. Reduced block production further delays LIB progression, potentially pushing the system into Severe status
3. In Severe status, production drops to 1 block total (not per miner type), halting normal operations [7](#0-6) 

The economic impact includes delayed transaction processing, increased latency for cross-chain operations, and potential failure to process time-sensitive governance or economic transactions during the recovery period.

### Likelihood Explanation

**High Likelihood During Specific Network Conditions:**

The condition `minersOfLastTwoRounds = 0` occurs when miner sets in consecutive rounds have zero overlap. This is realistic in several scenarios:

1. **Term Transitions**: When the entire miner set changes between terms, rounds spanning the transition boundary will have different miner sets. The `RecordMinedMinerListOfCurrentRound()` function records actual miners who produced blocks: [8](#0-7) 

The `GetMinedMiners()` method filters for miners who actually produced blocks: [9](#0-8) 

2. **Consensus Issues**: During network partitions or severe synchronization problems (the very conditions that cause Abnormal status), different subsets of miners may successfully produce blocks in different rounds, creating disjoint sets.

3. **No Attacker Required**: This is a natural consequence of the protocol's state transitions, not requiring any malicious action.

The preconditions are:
- Blockchain in Abnormal status (occurs when `libRoundNumber + 2 < currentRoundNumber < libRoundNumber + SevereStatusRoundsThreshold`)
- Complete miner set change or severe consensus fragmentation between two consecutive rounds
- Both conditions are realistic during problematic network periods

### Recommendation

**Add a minimum threshold to prevent zero maximum blocks count:**

```csharp
// In GetMaximumBlocksCount() Abnormal status block (around line 51-52)
var count = Math.Max(1, Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
    Ceiling(factor, currentRound.RealTimeMinersInformation.Count)));
```

This ensures miners can always produce at least 1 tiny block (plus the initial UpdateValue), maintaining minimum throughput of 2 blocks per time slot even when miner sets are disjoint.

**Additional safeguards:**
1. Add null checks before accessing `State.MinedMinerListMap` entries to prevent crashes
2. Add logging when `minersOfLastTwoRounds = 0` to detect and monitor this condition
3. Consider using a weighted average or time-decay factor instead of strict intersection to smooth miner set transitions

**Test cases to add:**
- Test Abnormal status calculation with zero miner set intersection
- Test term transition scenarios where all miners change
- Test consensus recovery with reduced maximum blocks count
- Verify minimum throughput maintained under all status conditions

### Proof of Concept

**Initial State:**
- Chain operating normally in term N with miners: {A, B, C, D, E}
- LIB at round 100, current round 105 (Abnormal status: 100 + 2 < 105 < 100 + 8)

**Exploitation Sequence:**

1. **Round 103**: Term N ends, miners {A, B, C, D, E} produce blocks
   - `RecordMinedMinerListOfCurrentRound()` stores: Pubkeys = {A, B, C, D, E}

2. **Round 104**: Term N+1 begins with completely new miner set {F, G, H, I, J}
   - New miners produce blocks
   - `RecordMinedMinerListOfCurrentRound()` stores: Pubkeys = {F, G, H, I, J}

3. **Round 105**: Miner F requests consensus command
   - `GetMaximumBlocksCount()` called during `GetConsensusCommand()`
   - Status evaluates to Abnormal (105 - 100 = 5, which is > 2 and < 8)
   - Loads: `previousRoundMinedMinerList = {F, G, H, I, J}` (round 104)
   - Loads: `previousPreviousRoundMinedMinerList = {A, B, C, D, E}` (round 103)
   - Intersection: `{F,G,H,I,J} ∩ {A,B,C,D,E} = ∅` → count = 0
   - Factor: `0 * (8 - 5) = 0 * 3 = 0`
   - Ceiling: `Ceiling(0, 5) = 0`
   - Returns: `Math.Min(8, 0) = 0`

4. **Miner F's first block**: Produces UpdateValue (OutValue = null → UpdateValue)

5. **Miner F's second block attempt**: 
   - `ActualMiningTimes.Count = 1`
   - Check: `1 < 0` → FALSE
   - Cannot produce TinyBlock
   - Must wait to terminate round

**Expected vs Actual:**
- **Expected**: Miner F should produce up to 8 tiny blocks in their time slot during Abnormal status
- **Actual**: Miner F can only produce 1 block total, severely limiting throughput when the chain needs recovery

**Success Condition**: All miners in round 105 are limited to 1 block each instead of 8, resulting in 87.5% reduction in block production capacity during Abnormal consensus status.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L57-67)
```csharp
        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L81-85)
```csharp
    private static int Ceiling(int num1, int num2)
    {
        var flag = num1 % num2;
        return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L117-128)
```csharp
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L223-230)
```csharp
    private void RecordMinedMinerListOfCurrentRound()
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        State.MinedMinerListMap.Set(currentRound.RoundNumber, new MinerList
        {
            Pubkeys = { currentRound.GetMinedMiners().Select(m => ByteStringHelper.FromHexString(m.Pubkey)) }
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```
