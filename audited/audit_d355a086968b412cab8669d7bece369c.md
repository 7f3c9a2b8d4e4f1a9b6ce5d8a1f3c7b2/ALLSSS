# Audit Report

## Title
Miner Time Manipulation via Unvalidated ActualMiningTime in Consensus Extra Data

## Summary
Miners can manipulate their `ActualMiningTimes` by crafting consensus extra data with false timestamps that differ from `Context.CurrentBlockTime`. The consensus validation logic fails to verify that the reported `ActualMiningTime` matches the actual block time, enabling manipulation of term transitions, time slot calculations, and consensus timing mechanisms.

## Finding Description

The vulnerability exists in how `ActualMiningTime` values are validated when miners produce blocks. The protocol assumes that `ActualMiningTime` represents the actual block production time (`Context.CurrentBlockTime`), but this invariant is never enforced.

**Legitimate Flow:**
When generating consensus extra data, the system legitimately adds `Context.CurrentBlockTime` to the miner's `ActualMiningTimes` collection. [1](#0-0) 

The `ExtractInformationToUpdateConsensus` method then extracts the last `ActualMiningTime` to include in the `UpdateValueInput`. [2](#0-1) 

**Missing Validation - Root Cause:**

The critical flaw is that no validation exists to ensure the provided `ActualMiningTime` equals `Context.CurrentBlockTime`. The validation gaps are:

1. **Hash Comparison Bypass**: The `GetCheckableRound` method explicitly clears all `ActualMiningTimes` before computing the hash, meaning hash comparison cannot detect manipulated timestamps. [3](#0-2) 

2. **Insufficient Time Slot Validation**: The `TimeSlotValidationProvider` only validates that the timestamp falls within the miner's allocated time slot bounds, not that it equals the actual current block time. [4](#0-3) 

3. **Direct State Update**: The `ProcessUpdateValue` method directly adds the provided `ActualMiningTime` to state without any validation. [5](#0-4) 

**Attack Execution:**
A malicious miner can craft custom `AElfConsensusHeaderInformation` with a manipulated `ActualMiningTime` value (e.g., 10 seconds earlier or later than `Context.CurrentBlockTime`, but still within their time slot). The block will pass all validations because:
- The miner has legitimate mining permission
- The timestamp is within their allocated time slot
- Hash validation excludes `ActualMiningTimes`
- No validator checks equality to `Context.CurrentBlockTime`

## Impact Explanation

**HIGH SEVERITY** - This vulnerability directly compromises consensus integrity through three attack vectors:

1. **Term Transition Manipulation**: The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` from each miner to determine when to change consensus terms. [6](#0-5)  If two-thirds of miners report manipulated timestamps, they can delay or accelerate term changes, violating the protocol's term transition timing.

2. **Round 1 Time Slot Distortion**: In the first round, `IsTimeSlotPassed` uses `FirstMiner().ActualMiningTimes.First()` as the reference time. [7](#0-6)  If the first miner manipulates this timestamp, all subsequent miners' time slot calculations are affected, potentially allowing or denying mining opportunities incorrectly.

3. **Consensus Behavior Manipulation**: Time-based decisions throughout the consensus mechanism rely on accurate `ActualMiningTimes`. Manipulation affects whether miners can produce tiny blocks, terminate rounds, and schedule subsequent mining operations.

The manipulated values are permanently stored in state and affect all future consensus calculations that depend on historical mining times.

## Likelihood Explanation

**MEDIUM-HIGH** - This vulnerability is highly exploitable:

**Attacker Profile**: Any scheduled miner in the AEDPoS consensus system can execute this attack during their allocated block production time slot. No special privileges beyond normal miner status are required.

**Attack Complexity**: LOW
1. Wait for scheduled mining turn
2. Craft custom `AElfConsensusHeaderInformation` with manipulated `ActualMiningTime` (within time slot bounds)
3. Produce and broadcast block with crafted consensus extra data
4. Block passes all validations and manipulated timestamp is stored

**Preconditions**: 
- Attacker must be in the current miner list (normal operational requirement)
- No governance control or special permissions needed

**Detection Difficulty**: HIGH - The manipulated timestamps appear as legitimate mining activity in contract state without external timestamp monitoring.

**Economic Rationality**: Attack cost is negligible (normal block production cost) while potential gains include extended mining windows, strategic term transition control, and competitive advantage in consensus timing.

## Recommendation

Add explicit validation that enforces `ActualMiningTime` equals `Context.CurrentBlockTime` when processing consensus information. 

**Implementation Options:**

1. **In ProcessUpdateValue**: Add validation before storing the timestamp:
```csharp
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
    "ActualMiningTime must equal current block time");
minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

2. **In TimeSlotValidationProvider**: Extend validation to check not just time slot bounds but also equality:
```csharp
// After recovering the new ActualMiningTime
var newActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).Last();
Assert(newActualMiningTime == validationContext.CurrentBlockTime, 
    "ActualMiningTime must match current block time");
```

3. **In UpdateValueValidationProvider**: Add a dedicated check for ActualMiningTime consistency:
```csharp
private bool ValidateActualMiningTime(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound
        .RealTimeMinersInformation[validationContext.SenderPubkey];
    var providedTime = minerInRound.ActualMiningTimes.Last();
    return providedTime == validationContext.CurrentBlockTime;
}
```

The fix should be applied at the validation layer (option 2 or 3) to prevent invalid data from entering the system, with an additional assertion in ProcessUpdateValue (option 1) as defense-in-depth.

## Proof of Concept

A proof of concept would demonstrate:
1. Create a test miner with valid mining permissions
2. Craft `AElfConsensusHeaderInformation` with `ActualMiningTime` set to `Context.CurrentBlockTime - 10 seconds` (but still within the time slot)
3. Call the consensus validation methods (ValidateConsensusBeforeExecution, ValidateConsensusAfterExecution)
4. Verify that validation passes despite the timestamp mismatch
5. Call ProcessUpdateValue to store the manipulated timestamp
6. Query the stored round information to confirm the false timestamp was persisted
7. Demonstrate that NeedToChangeTerm uses this manipulated value in its calculations

The test would prove that a miner can successfully inject false timing data into the consensus state without triggering any validation failures, confirming the vulnerability is exploitable in practice.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L193-193)
```csharp
            checkableMinerInRound.ActualMiningTimes.Clear();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```
