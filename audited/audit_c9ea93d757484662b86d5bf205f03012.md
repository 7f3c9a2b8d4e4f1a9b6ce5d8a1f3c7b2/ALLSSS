# Audit Report

## Title
Secret Sharing Manipulation Through Selective Decrypted Piece Withholding

## Summary
The `RevealSharedInValues()` function incorrectly requires 100% miner participation to reveal InValues, despite Shamir's Secret Sharing only needing a 2/3 threshold. This allows any single malicious miner to selectively withhold decrypted pieces, forcing targeted miners to use deterministic fake values that manipulate consensus randomness and mining order for subsequent rounds.

## Finding Description

The vulnerability exists in the threshold mismatch within the secret sharing revelation logic. The `RevealSharedInValues` function checks whether all miners (100%) have provided decrypted pieces before attempting InValue reconstruction: [1](#0-0) 

However, the underlying Shamir's Secret Sharing scheme only requires a 2/3 threshold (`minimumCount`) for successful reconstruction: [2](#0-1) [3](#0-2) 

This mismatch creates an exploitable attack vector. During the `UpdateValue` consensus behavior, miners provide their decrypted pieces through `UpdateValueInput`. The processing logic accepts whatever decrypted pieces are provided without validation: [4](#0-3) 

The validation provider only checks OutValue and PreviousInValue fields, not the completeness of DecryptedPieces: [5](#0-4) 

When InValue revelation fails due to insufficient decrypted pieces, miners must use a deterministic fake value: [6](#0-5) 

This fake value directly affects signature calculation, which determines mining order for the next round: [7](#0-6) [8](#0-7) 

**Attack Execution:**
1. A malicious miner's off-chain service decrypts all encrypted pieces from other miners (standard operation): [9](#0-8) 

2. The attacker calculates mining orders under two scenarios for each target miner:
   - Scenario A: Provide the decrypted piece (allows InValue revelation)
   - Scenario B: Withhold the decrypted piece (forces fake value usage)

3. The attacker selectively omits decrypted pieces from their `UpdateValueInput` where withholding produces more favorable mining orders for themselves

4. Since the fake value is deterministic (based on pubkey and block height), the attacker can predict the exact impact on signatures and resulting mining order

## Impact Explanation

This vulnerability directly breaks the consensus randomness and miner schedule integrity guarantees:

**Consensus Manipulation:** The mining order for round N+1 is determined by signatures calculated using InValues (or fake values) from round N. By forcing specific miners to use predictable fake values instead of their actual InValues, an attacker can influence the XOR-based signature calculation and manipulate which miners receive favorable or unfavorable mining positions.

**Economic Impact:** Mining order directly affects:
- Block reward capture frequency
- Transaction fee collection (earlier positions typically process more transactions)
- Ability to produce consecutive blocks for increased revenue

**Protocol Invariant Violation:** The secret sharing scheme is designed to ensure that as long as 2/3 of miners participate honestly, InValues can be revealed correctly. The implementation requiring 100% participation allows any single miner (even <5% of the network) to selectively block revelations, completely bypassing the intended cryptographic threshold security property.

## Likelihood Explanation

**Attacker Capabilities:** Any single miner in the active consensus set can execute this attack with minimal modifications:
- The standard consensus node already decrypts all pieces off-chain
- Attack requires only filtering which decrypted pieces to include in the on-chain transaction
- No special cryptographic capabilities or computational power needed beyond normal mining operations

**Attack Complexity:** Trivial implementation:
1. Modify the off-chain secret sharing service to selectively filter decrypted pieces before calling `UpdateValue`
2. Calculate expected mining orders for different withholding strategies
3. Submit `UpdateValueInput` with strategically omitted decrypted pieces

**Detection Probability:** Zero. The system has no mechanism to distinguish between:
- An honest miner who legitimately failed to decrypt due to technical issues
- A malicious miner intentionally withholding valid decryptions

Evil miner detection only tracks missed time slots, not decrypted piece withholding: [10](#0-9) 

**Economic Rationality:** High incentive with zero cost:
- Benefit: Improved mining positions directly increase block rewards and fee capture
- Cost: Zero (no transaction fees, no stake slashing, no detection risk)
- Opportunity: Every round provides new manipulation opportunities

## Recommendation

Modify the `RevealSharedInValues` function to match the cryptographic threshold requirement:

**Fix Option 1 (Recommended):** Change the threshold check to use `minimumCount` instead of `minersCount`:
```csharp
// Line 36 of AEDPoSContract_SecretSharing.cs
// Change from:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;

// To:
if (anotherMinerInPreviousRound.DecryptedPieces.Count < minimumCount) continue;
```

**Fix Option 2 (Additional Protection):** Implement on-chain validation in `PerformSecretSharing` to verify miners provide all available decrypted pieces they should possess based on the previous round's encrypted pieces.

**Fix Option 3 (Detection):** Add economic penalties for miners whose decrypted piece contribution rate falls below expected thresholds over multiple rounds.

## Proof of Concept

Due to the complexity of setting up a full AElf consensus test environment with multiple miners and secret sharing, a complete executable PoC would require:

1. Initialize consensus with multiple miners (at least 3)
2. Setup round N with each miner publishing encrypted pieces
3. In round N+1, have one attacker miner call `UpdateValue` with selectively omitted `DecryptedPieces`
4. Verify that `RevealSharedInValues` skips revelation for targeted miners (line 36 check fails)
5. Show affected miners use fake values in subsequent blocks
6. Demonstrate mining order manipulation in round N+2

The vulnerability can be verified by code inspection showing:
- Line 36 requires `minersCount` (100%) but line 50 only needs `minimumCount` (2/3)
- No validation exists that miners provide all decrypted pieces they possess
- Fake values are deterministic and used in mining order calculation

**Notes:**
- The core issue is the architectural mismatch between the cryptographic security guarantee (2/3 threshold sufficient) and the implementation requirement (100% participation mandatory)
- This vulnerability affects both main chain and side chain consensus
- The deterministic nature of fake values is critical - if fake values were truly random, mining order manipulation would not be possible
- The off-chain nature of piece decryption makes this attack undetectable without protocol changes

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L22-23)
```csharp
        var minimumCount = minersCount.Mul(2).Div(3);
        minimumCount = minimumCount == 0 ? 1 : minimumCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L36-36)
```csharp
            if (anotherMinerInPreviousRound.DecryptedPieces.Count < minersCount) continue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-50)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L96-107)
```csharp
                var fakePreviousInValue = HashHelper.ComputeFrom(pubkey.Append(Context.CurrentHeight.ToString()));
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) && previousRound.RoundNumber != 1)
                {
                    var appointedPreviousInValue = previousRound.RealTimeMinersInformation[pubkey].InValue;
                    if (appointedPreviousInValue != null) fakePreviousInValue = appointedPreviousInValue;
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
                else
                {
                    // This miner appears first time in current round, like as a replacement of evil miner.
                    signature = previousRound.CalculateSignature(fakePreviousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-114)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L125-138)
```csharp
            if (!secretSharingInformation.PreviousRound.RealTimeMinersInformation.ContainsKey(pubkey)) continue;

            var encryptedShares =
                secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].EncryptedPieces;
            if (!encryptedShares.Any() || !encryptedShares.ContainsKey(selfPubkey)) continue;
            var interestingMessage = encryptedShares[selfPubkey];
            var senderPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);

            var decryptedPiece =
                await _accountService.DecryptMessageAsync(senderPublicKey, interestingMessage.ToByteArray());
            decryptedPieces[pubkey] = decryptedPiece;
            secretSharingInformation.PreviousRound.RealTimeMinersInformation[pubkey].DecryptedPieces[selfPubkey]
                = ByteString.CopyFrom(decryptedPiece);
        }
```
