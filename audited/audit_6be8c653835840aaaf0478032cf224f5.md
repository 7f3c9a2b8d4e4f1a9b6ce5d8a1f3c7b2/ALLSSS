### Title
State Size Limit Denial of Service via Large Voting Result Aggregation

### Summary
The Vote contract allows registration of voting items with up to 64 options of 1024 characters each. When votes are aggregated, the VotingResult's results map stores option strings as keys, causing the serialized state to exceed the 128 KB state size limit. This results in transaction failures and denial of service for the voting system once sufficient options receive votes.

### Finding Description

The Vote contract defines two constants that create a vulnerable state size scenario: [1](#0-0) 

During vote aggregation in `UpdateVotingResult`, the VotingResult structure stores a map where option strings (up to 1024 characters) become map keys: [2](#0-1) 

The VotingResult protobuf message contains a `map<string, int64> results` field where the full option strings are used as keys: [3](#0-2) 

When storing VotingResult to state (line 180), the AElf runtime automatically calls `ValidateStateSize` which enforces a 128 KB limit: [4](#0-3) 

The state size limit is defined as: [5](#0-4) 

**Size Calculation (Worst Case):**
- 64 options with 1024 characters each using multi-byte UTF-8 encoding (e.g., Chinese characters, emoji)
- Per option in results map: 1024 chars × 4 bytes/char (UTF-8 max) = 4,096 bytes per key
- 64 entries: 64 × 4,096 = 262,144 bytes (just for keys)
- Plus int64 values: 64 × 8 = 512 bytes
- Plus protobuf overhead and other VotingResult fields: ~200 bytes
- **Total: ~262,856 bytes (exceeds 128 KB limit by 2×)**

Even with 2-byte UTF-8 characters or ASCII strings approaching 1024 characters, the serialized size can reach or exceed the limit once most options receive votes.

### Impact Explanation

**Operational DoS Impact:**
- Once VotingResult size exceeds 128 KB, all subsequent `Vote()` transactions fail with `StateOverSizeException`
- Legitimate voters cannot cast votes, effectively freezing the voting process
- Existing vote results become unmodifiable through normal voting operations
- Withdrawal operations may also fail if they attempt to update the oversized VotingResult
- No recovery mechanism exists without manual intervention or contract upgrade

**Affected Parties:**
- All voters who wish to participate in the affected voting item
- The sponsor who created the voting item (legitimate or malicious)
- Any contracts or systems depending on voting results

**Severity Justification:**
This is a HIGH severity vulnerability because:
1. It completely disables core contract functionality (voting)
2. The impact is irreversible without external intervention
3. Multiple voting items could be affected simultaneously
4. The attack parameters are within contract-specified limits

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be able to create a voting item (sponsor role)
- Requires crafting 64 option strings approaching 1024 characters using multi-byte UTF-8
- Needs multiple voters to vote for different options (could coordinate or wait for organic votes)

**Attack Complexity:**
- **Medium complexity** - requires understanding of UTF-8 encoding and state size limits
- Option strings can be programmatically generated
- No special privileges beyond sponsor role required

**Feasibility Conditions:**
- The contract enforces the limits that enable this attack: [6](#0-5) [7](#0-6) 

- Multi-byte UTF-8 strings are valid input (no encoding restrictions)
- The contract cannot prevent voters from voting for different options once registered

**Economic Rationality:**
- Attack cost is minimal: transaction fees for registration and initial votes
- No token lockup required if `IsLockToken = false` (delegated voting)
- Could be used maliciously to disrupt governance or strategically to prevent unfavorable voting outcomes

**Probability:** HIGH - The attack is straightforward, uses intended contract functionality, and requires only sponsor-level access.

### Recommendation

**Immediate Mitigations:**

1. **Reduce combined limits** to ensure maximum possible VotingResult size stays under 128 KB:
```
MaximumOptionsCount = 32 (reduced from 64)
OptionLengthLimit = 512 (reduced from 1024)
```

2. **Add proactive size validation** in `Register` method to estimate maximum VotingResult size: [8](#0-7) 

Add validation after line 49:
```csharp
// Estimate maximum VotingResult size
var estimatedMaxSize = input.Options.Sum(o => Encoding.UTF8.GetByteCount(o) + 8) + 200;
Assert(estimatedMaxSize < SmartContractConstants.StateSizeLimit * 0.8, 
    "Options would create oversized voting result");
```

3. **Architectural improvement** - Store option indices instead of full strings in results map:
    - Modify VotingResult.results to use `map<int32, int64>` (option index -> votes)
    - Reference full option strings from VotingItem when needed
    - This reduces results map size to ~1 KB regardless of option string lengths

4. **Add monitoring** in `UpdateVotingResult` to warn when approaching size limits: [2](#0-1) 

**Test Cases:**
- Test voting with 64 options of 1000 characters each (multi-byte UTF-8)
- Verify registration fails with size estimation check
- Test that maximum allowed configuration stays under 128 KB limit with all options voted

### Proof of Concept

**Initial State:**
- Sponsor account with sufficient balance for transaction fees
- Vote contract deployed with current constants (MaximumOptionsCount=64, OptionLengthLimit=1024)

**Attack Steps:**

1. **Register malicious voting item:**
```
Call: Register()
Input:
    - accepted_currency: "ELF"
    - is_lock_token: false (to avoid token requirements)
    - total_snapshot_number: 1
    - start_timestamp: current time
    - end_timestamp: current time + 30 days
    - options: [64 strings, each containing 1000+ multi-byte UTF-8 characters like Chinese/emoji]
```

2. **Coordinate initial votes** (50-60 different voters):
```
Each voter calls: Vote()
Input:
    - voting_item_id: [from step 1]
    - option: [different option for each voter]
    - amount: 1
```

3. **Trigger state size failure:**
```
Additional voter calls: Vote()
Input:
    - voting_item_id: [from step 1]
    - option: [any option]
    - amount: 1

Expected: Transaction succeeds
Actual: Transaction fails with "State size {size} exceeds limit of 131072"
```

**Success Condition:**
Vote transactions begin failing with `StateOverSizeException` once VotingResult serialization exceeds 128 KB, which occurs after approximately 50-60 options (each ~1000 multi-byte characters) receive votes.

### Notes

The vulnerability stems from the protobuf map structure storing full option strings as keys in the aggregated results. While the initial security question mentioned "gas exhaustion," the actual issue is state size limit exhaustion, which has the same practical effect: transaction failure and DoS. The AElf runtime enforces state size limits during write operations, not gas limits during read operations, since `GetVotingResult` is a view method that doesn't consume transaction gas.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-181)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L294-294)
```csharp
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
```

**File:** protobuf/vote_contract.proto (L162-177)
```text
message VotingResult {
    // The voting activity id.
    aelf.Hash voting_item_id = 1;
    // The voting result, option -> amount of votes,
    map<string, int64> results = 2;
    // The snapshot number.
    int64 snapshot_number = 3;
    // The total number of voters.
    int64 voters_count = 4;
    // The start time of this snapshot.
    google.protobuf.Timestamp snapshot_start_timestamp = 5;
    // The end time of this snapshot.
    google.protobuf.Timestamp snapshot_end_timestamp = 6;
    // Total votes received during the process of this snapshot.
    int64 votes_amount = 7;
}
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
