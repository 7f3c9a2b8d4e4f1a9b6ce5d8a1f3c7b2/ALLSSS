# Audit Report

## Title
Consensus DoS via Missing Validation of Extra Block Producer Uniqueness in Round Data

## Summary
The AEDPoS consensus contract fails to validate that exactly one miner has the `IsExtraBlockProducer` flag set to true when processing NextRound transitions. A malicious extra block producer can inject round data with multiple miners marked as extra block producers, which passes all validation checks but causes system transactions to fail with a fatal exception in subsequent rounds, halting the entire blockchain.

## Finding Description

The consensus system properly generates round data with exactly one extra block producer [1](#0-0) , but lacks validation to enforce this invariant when miners submit round data.

**Attack Execution Path:**

1. A malicious miner designated as extra block producer generates NextRound consensus data via `GetConsensusBlockExtraData` [2](#0-1) 

2. The attacker modifies the `NextRoundInput` structure to set multiple miners' `IsExtraBlockProducer = true` before submitting the block

3. The block passes validation because `ValidateBeforeExecution` [3](#0-2)  applies validation providers that do not check `IsExtraBlockProducer` uniqueness:
   - `MiningPermissionValidationProvider` only checks miner list membership [4](#0-3) 
   - `TimeSlotValidationProvider` only validates timing [5](#0-4) 
   - `RoundTerminateValidationProvider` only checks round number increments [6](#0-5) 

4. The corrupted round is stored via `AddRoundInformation` [7](#0-6) 

5. In subsequent rounds, the system automatically generates `ClaimTransactionFees` transactions [8](#0-7) 

6. These transactions call `AssertSenderIsCurrentMiner` which invokes `IsCurrentMiner` [9](#0-8) 

7. The `IsCurrentMiner` method uses `.Single()` to retrieve the extra block producer [10](#0-9) , which throws `InvalidOperationException` when multiple miners have `IsExtraBlockProducer = true`

8. The system transaction fails, causing block validation to fail [11](#0-10) 

9. All blocks are rejected by the processing pipeline [12](#0-11) , halting the chain

## Impact Explanation

**Severity: CRITICAL**

This vulnerability causes a complete blockchain halt that cannot self-recover:

- **Complete Consensus Failure**: All miners fail to produce valid blocks because system transactions automatically included in every block throw exceptions
- **No Recovery Path**: The corrupted round data persists in state, preventing any subsequent block from being accepted through normal consensus mechanisms
- **Network-Wide Impact**: All network participants lose the ability to transact, validators cannot produce blocks, and dependent applications become unavailable
- **Manual Intervention Required**: Recovery requires either a hard fork or manual state correction, both requiring coordinated off-chain action

The severity is justified because:
1. The attack permanently halts all blockchain operations
2. It affects the entire network simultaneously
3. No on-chain mechanism can resolve the corrupted state
4. It breaks the fundamental consensus invariant that the chain should always progress

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is highly feasible with low technical barriers:

**Attacker Requirements:**
- Must be a miner (achievable through normal election/staking mechanisms)
- Must wait to be designated as extra block producer (happens through deterministic rotation)

**Attack Complexity:**
- LOW - The attacker only needs to modify the `NextRoundInput` structure before block submission
- No cryptographic or signature barriers prevent modification of the round data
- The attack is deterministic - if executed correctly, it guarantees chain halt

**Detection:**
- The vulnerability is only detected when it's too late (during execution in the next round)
- No proactive monitoring can prevent the attack once the corrupted block is accepted
- The corrupted round data passes all validation checks

**Feasibility Factors:**
- Extra block producer designation rotates among all miners, giving every miner periodic opportunity
- A single malicious or compromised miner can execute this attack
- The attack requires no special resources beyond normal miner operations
- Success is guaranteed if the attacker correctly modifies the round data

The likelihood is not higher only because it requires the attacker to first become a miner and wait for their extra block producer slot, but once in position, execution is trivial and success is certain.

## Recommendation

Add validation to enforce the `IsExtraBlockProducer` uniqueness invariant. Implement a new validation provider for NextRound behavior:

```csharp
public class ExtraBlockProducerValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        
        if (validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextRound &&
            validationContext.ExtraData.Behaviour != AElfConsensusBehaviour.NextTerm)
        {
            validationResult.Success = true;
            return validationResult;
        }
        
        var extraBlockProducerCount = validationContext.ExtraData.Round
            .RealTimeMinersInformation.Values
            .Count(m => m.IsExtraBlockProducer);
            
        if (extraBlockProducerCount != 1)
        {
            validationResult.Message = 
                $"Invalid extra block producer count: {extraBlockProducerCount}. Expected exactly 1.";
            return validationResult;
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Add this provider to the validation list in `ValidateBeforeExecution`:

```csharp
switch (extraData.Behaviour)
{
    case AElfConsensusBehaviour.NextRound:
        validationProviders.Add(new NextRoundMiningOrderValidationProvider());
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new ExtraBlockProducerValidationProvider()); // Add here
        break;
    case AElfConsensusBehaviour.NextTerm:
        validationProviders.Add(new RoundTerminateValidationProvider());
        validationProviders.Add(new ExtraBlockProducerValidationProvider()); // And here
        break;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MultipleExtraBlockProducers_ShouldCauseChainHalt()
{
    // Setup: Initialize consensus with miners
    await InitializeConsensusAsync();
    
    // Get current round and identify extra block producer
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var extraBlockProducer = currentRound.RealTimeMinersInformation.Values
        .First(m => m.IsExtraBlockProducer);
    
    // Attacker is the extra block producer
    var attackerKeyPair = MissionedECKeyPairs[extraBlockProducer.Pubkey];
    var attackerStub = GetConsensusContractTester(attackerKeyPair);
    
    // Generate next round data
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(attackerKeyPair.PublicKey),
        Behaviour = AElfConsensusBehaviour.NextRound
    };
    
    var nextRoundData = await attackerStub.GetConsensusExtraData.CallAsync(
        triggerInfo.ToBytesValue());
    var headerInfo = AElfConsensusHeaderInformation.Parser.ParseFrom(nextRoundData.Value);
    
    // ATTACK: Set multiple miners as extra block producers
    var miners = headerInfo.Round.RealTimeMinersInformation.Values.Take(3).ToList();
    foreach (var miner in miners)
    {
        miner.IsExtraBlockProducer = true;
    }
    
    // Submit corrupted round (this should pass validation but is incorrect)
    var nextRoundInput = NextRoundInput.Create(headerInfo.Round, ByteString.Empty);
    var result = await attackerStub.NextRound.SendAsync(nextRoundInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Move to next round where the attack manifests
    await ProduceNormalBlock();
    
    // Any miner trying to claim fees will now fail with InvalidOperationException
    var nextMiner = GetNextMinerKeyPair();
    var nextMinerStub = GetTokenContractTester(nextMiner);
    
    // This should throw InvalidOperationException from .Single() call
    var claimResult = await nextMinerStub.ClaimTransactionFees.SendWithExceptionAsync(
        new TotalTransactionFeesMap());
    
    // Verify the chain cannot progress
    claimResult.TransactionResult.Error.ShouldContain("InvalidOperationException");
    
    // All subsequent blocks will fail validation
    var blockResult = await ProduceBlockWithExceptionAsync();
    blockResult.ShouldBe(null); // Block processing returns null on validation failure
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-92)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/ClaimFeeTransactionGenerator.cs (L28-73)
```csharp
    public async Task<List<Transaction>> GenerateTransactionsAsync(Address from, long preBlockHeight,
        Hash preBlockHash)
    {
        var generatedTransactions = new List<Transaction>();

        if (preBlockHeight < AElfConstants.GenesisBlockHeight)
            return generatedTransactions;

        var chainContext = new ChainContext
        {
            BlockHash = preBlockHash,
            BlockHeight = preBlockHeight
        };

        var tokenContractAddress = await _smartContractAddressService.GetAddressByContractNameAsync(chainContext,
            TokenSmartContractAddressNameProvider.StringName);

        if (tokenContractAddress == null)
            return generatedTransactions;

        var totalTxFeesMap = await _totalTransactionFeesMapProvider.GetTotalTransactionFeesMapAsync(chainContext);
        if (totalTxFeesMap == null || !totalTxFeesMap.Value.Any() || totalTxFeesMap.BlockHeight != preBlockHeight ||
            totalTxFeesMap.BlockHash != preBlockHash)
        {
            Logger.LogDebug(
                "Won't generate ClaimTransactionFees because no tx fee charged in previous block.");
            // If previous block doesn't contain logEvent named TransactionFeeCharged, won't generate this tx.
            return new List<Transaction>();
        }

        generatedTransactions.AddRange(new List<Transaction>
        {
            new()
            {
                From = from,
                MethodName = nameof(TokenContractImplContainer.TokenContractImplStub.ClaimTransactionFees),
                To = tokenContractAddress,
                RefBlockNumber = preBlockHeight,
                RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
                Params = totalTxFeesMap.ToByteString()
            }
        });

        Logger.LogTrace("Tx ClaimTransactionFees generated.");
        return generatedTransactions;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L897-906)
```csharp
    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/ClaimTransactionFeesValidationProvider.cs (L58-92)
```csharp
    public async Task<bool> ValidateBlockAfterExecuteAsync(IBlock block)
    {
        var tokenContractAddress =
            await _smartContractAddressService.GetAddressByContractNameAsync(new ChainContext
            {
                BlockHash = block.GetHash(),
                BlockHeight = block.Header.Height
            }, TokenSmartContractAddressNameProvider.StringName);
        if (tokenContractAddress == null) return true;

        var hashFromState = await _contractReaderFactory.Create(new ContractReaderContext
        {
            BlockHash = block.GetHash(),
            BlockHeight = block.Header.Height,
            ContractAddress = tokenContractAddress
        }).GetLatestTotalTransactionFeesMapHash.CallAsync(new Empty());

        var totalTransactionFeesMapFromProvider =
            await _totalTransactionFeesMapProvider.GetTotalTransactionFeesMapAsync(new ChainContext
            {
                BlockHash = block.Header.PreviousBlockHash,
                BlockHeight = block.Header.Height - 1
            });
        if (totalTransactionFeesMapFromProvider == null)
        {
            Logger.LogDebug("totalTransactionFeesMapFromProvider == null");
            return hashFromState.Value.IsEmpty;
        }

        var hashFromProvider = HashHelper.ComputeFrom(totalTransactionFeesMapFromProvider);
        var result = hashFromProvider == hashFromState;
        if (!result) Logger.LogDebug($"Hash from provider: {hashFromProvider}\nHash from state: {hashFromState}");

        return result;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockchainExecutingService.cs (L128-156)
```csharp
    private async Task<BlockExecutedSet> ProcessBlockAsync(Block block)
    {
        var blockHash = block.GetHash();
        // Set the other blocks as bad block if found the first bad block
        if (!await _blockValidationService.ValidateBlockBeforeExecuteAsync(block))
        {
            Logger.LogDebug($"Block validate fails before execution. block hash : {blockHash}");
            return null;
        }

        var blockExecutedSet = await ExecuteBlockAsync(block);

        if (blockExecutedSet == null)
        {
            Logger.LogDebug($"Block execution failed. block hash : {blockHash}");
            return null;
        }

        if (!await _blockValidationService.ValidateBlockAfterExecuteAsync(block))
        {
            Logger.LogDebug($"Block validate fails after execution. block hash : {blockHash}");
            return null;
        }

        await _transactionResultService.ProcessTransactionResultAfterExecutionAsync(block.Header,
            block.Body.TransactionIds.ToList());

        return blockExecutedSet;
    }
```
