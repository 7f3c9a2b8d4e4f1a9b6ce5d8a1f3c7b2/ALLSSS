### Title
Resource Token Accumulation in Consensus Contract Due to Integer Division Rounding Loss

### Summary
The `DistributeResourceTokensToPreviousMiners()` function uses integer division to split resource tokens among miners, causing remainder tokens to permanently accumulate in the consensus contract. [1](#0-0)  With no recovery mechanism available in the contract, these funds become permanently locked over time as cross-chain updates occur regularly.

### Finding Description

The vulnerability exists in the `DistributeResourceTokensToPreviousMiners()` private method which is called during each cross-chain consensus information update on side chains. [2](#0-1) 

**Root Cause:**
At line 81, the contract calculates the distribution amount using integer division: `var amount = balance.Div(minerList.Count);` [1](#0-0) 

The `Div` method performs standard integer division for `long` types, which truncates any remainder. [3](#0-2) 

**Why Protections Fail:**
The function distributes tokens in a loop to each miner, but never handles or tracks the remainder amount (balance % minerList.Count). [4](#0-3) 

**Execution Path:**
1. Resource tokens (transaction fees and rental fees) accumulate in the consensus contract on side chains through the `PayResourceTokens()` function in the MultiToken contract. [5](#0-4) 
2. The CrossChain contract calls `UpdateInformationFromCrossChain()` regularly to sync main chain consensus information. [6](#0-5) 
3. This triggers `DistributeResourceTokensToPreviousMiners()` which distributes tokens using integer division. [7](#0-6) 
4. The remainder from each distribution stays in the consensus contract balance permanently.

**No Recovery Mechanism:**
Analysis of the AEDPoS contract proto definition shows no methods for withdrawing or recovering stuck tokens. [8](#0-7)  The only way tokens exit the consensus contract is through the same `DistributeResourceTokensToPreviousMiners()` function that causes the accumulation.

### Impact Explanation

**Direct Fund Loss:**
For each distribution cycle and token symbol:
- Example: If balance = 1,000,000,000 tokens and there are 17 miners
- Amount per miner = 1,000,000,000 / 17 = 58,823,529 (integer division)
- Total distributed = 58,823,529 Ã— 17 = 999,999,993
- **Permanently stuck = 7 tokens per distribution**

**Accumulation Over Time:**
- The function processes multiple token symbols (PayTxFeeSymbolList and PayRentalSymbolList). [9](#0-8) 
- Cross-chain updates occur regularly as the side chain syncs with main chain consensus.
- Each update that has accumulated resource tokens will lose the remainder.
- Over months/years of operation, this accumulates to a significant amount across all token types.

**Who Is Affected:**
- The stuck tokens belong to users who paid transaction fees and rental fees on the side chain.
- The accumulated funds are effectively removed from circulation without benefiting any party.
- Miners receive slightly less than their entitled share on each distribution.

**Severity Justification:**
Medium severity because:
- The per-distribution loss is relatively small (< 1% typically)
- However, the loss is **permanent** and **cumulative**
- No administrative recovery function exists
- The issue is unavoidable under normal protocol operation

### Likelihood Explanation

**Certainty of Occurrence:**
This is not an attack but a deterministic flaw that occurs naturally:
- No attacker action required
- Happens automatically whenever `balance % minerList.Count != 0`
- Given that token amounts and miner counts are independent values, remainders are statistically common

**Execution Frequency:**
- Triggered on every `UpdateInformationFromCrossChain()` call that follows resource token accumulation. [10](#0-9) 
- On active side chains, this occurs regularly (potentially every round update from main chain)
- Multiple token symbols are processed each time

**Realistic Conditions:**
- Only requires normal side chain operation
- The test suite confirms this behavior occurs in practice. [11](#0-10) 
- Side chains inherently need to distribute accumulated resource tokens to miners as part of their economic model

**Probability: 100%**
This will definitely occur on every side chain that:
- Receives transaction fees or rental fees (standard operation)
- Has cross-chain consensus updates enabled (required for side chains)
- Has a balance that is not perfectly divisible by the miner count

### Recommendation

**Immediate Fix:**
Modify the `DistributeResourceTokensToPreviousMiners()` function to handle remainders explicitly:

```csharp
private void DistributeResourceTokensToPreviousMiners()
{
    if (State.TokenContract.Value == null)
        State.TokenContract.Value = Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

    var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
    foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                 .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
    {
        var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.Self,
            Symbol = symbol
        }).Balance;
        var amount = balance.Div(minerList.Count);
        var remainder = balance.Sub(amount.Mul(minerList.Count)); // Calculate remainder
        
        if (amount <= 0) continue;
        
        for (int i = 0; i < minerList.Count; i++)
        {
            var pubkey = minerList[i];
            var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
            var distributionAmount = amount;
            
            // Distribute remainder to first N miners (where N = remainder)
            if (i < remainder)
                distributionAmount = distributionAmount.Add(1);
                
            State.TokenContract.Transfer.Send(new TransferInput
            {
                To = address,
                Amount = distributionAmount,
                Symbol = symbol
            });
        }
    }
}
```

**Alternative Recovery Mechanism:**
Add an administrative function to recover accumulated tokens, callable only by governance:

```csharp
public override Empty RecoverStuckTokens(RecoverStuckTokensInput input)
{
    AssertParliamentPermission(); // Or other governance check
    State.TokenContract.Transfer.Send(new TransferInput
    {
        To = input.Recipient,
        Amount = input.Amount,
        Symbol = input.Symbol,
        Memo = "Recovery of stuck tokens from rounding"
    });
    return new Empty();
}
```

**Testing Requirements:**
- Add unit tests verifying perfect distribution with various balance/miner count combinations
- Test cases where balance % minerList.Count = 0, 1, and minerList.Count - 1
- Verify no tokens remain in consensus contract after distribution
- Test with multiple token symbols simultaneously

### Proof of Concept

**Initial State:**
- Side chain is initialized with 3 miners
- Consensus contract has accumulated 1,000,000,000 tokens of symbol "READ"
- This represents collected transaction fees from users

**Transaction Sequence:**

1. CrossChain contract calls `UpdateInformationFromCrossChain()` with new main chain consensus information [6](#0-5) 

2. This triggers `DistributeResourceTokensToPreviousMiners()` internally [2](#0-1) 

3. Distribution calculation:
   - Balance: 1,000,000,000 tokens
   - Miner count: 3
   - Amount per miner: 1,000,000,000 / 3 = 333,333,333 (integer division) [1](#0-0) 

4. Distribution execution:
   - Miner 1 receives: 333,333,333 tokens
   - Miner 2 receives: 333,333,333 tokens  
   - Miner 3 receives: 333,333,333 tokens
   - Total distributed: 999,999,999 tokens

**Expected Result:**
All 1,000,000,000 tokens should be distributed to miners (333,333,333 or 333,333,334 each).

**Actual Result:**
Only 999,999,999 tokens are distributed, leaving **1 token permanently stuck** in the consensus contract balance. [12](#0-11) 

**Success Condition:**
Query the consensus contract token balance after distribution - it will show the remainder (1 token in this example) with no mechanism to withdraw it. This remainder accumulates on every subsequent distribution cycle.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-63)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1000-1005)
```csharp
                    {
                        Context.LogDebug(() => $"Adding {amount} of {symbol}s to consensus address account.");
                        // Side Chain
                        receiver =
                            Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
                        ModifyBalance(receiver, symbol, amount);
```

**File:** protobuf/aedpos_contract.proto (L17-181)
```text
service AEDPoSContract {
    
    option (aelf.csharp_state) = "AElf.Contracts.Consensus.AEDPoS.AEDPoSContractState";
    
    // Initialize the consensus contract. 
    rpc InitialAElfConsensusContract (InitialAElfConsensusContractInput) returns (google.protobuf.Empty) {
    }
    
    // Initializes the consensus information in the first round.
    rpc FirstRound (Round) returns (google.protobuf.Empty) {
    }
    
    // Update consensus information.
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }

    // Update consensus information, create a new round.
    rpc NextRound (NextRoundInput) returns (google.protobuf.Empty) {
    }

    // Update consensus information, create a new term.
    rpc NextTerm (NextTermInput) returns (google.protobuf.Empty) {
    }

    // Update consensus tiny block information.
    rpc UpdateTinyBlockInformation (TinyBlockInput) returns (google.protobuf.Empty) {
    }
    
    // Set the maximum count of miners, by default, is unlimited. 
    // If you want to control the count of miners, you need to set it through parliament.
    rpc SetMaximumMinersCount (google.protobuf.Int32Value) returns (google.protobuf.Empty) {
    }
    
    // The authority information for SetMaximumMinersCount, by default, is governed by parliament.
    rpc ChangeMaximumMinersCountController (AuthorityInfo) returns (google.protobuf.Empty) {
    }
    
    // Set miner increase interval
    rpc SetMinerIncreaseInterval (google.protobuf.Int64Value) returns (google.protobuf.Empty){
    }
    
    // Election Contract can notify AEDPoS Contract to aware candidate replacement happened.
    rpc RecordCandidateReplacement (RecordCandidateReplacementInput) returns (google.protobuf.Empty) {
    }

    // Get the list of current miners.
    rpc GetCurrentMinerList (google.protobuf.Empty) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of current miners (hexadecimal format).
    rpc GetCurrentMinerPubkeyList (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of current miners and current round number.
    rpc GetCurrentMinerListWithRoundNumber (google.protobuf.Empty) returns (MinerListWithRoundNumber) {
        option (aelf.is_view) = true;
    }
    
    // Get information of the round according to round number.
    rpc GetRoundInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round number.
    rpc GetCurrentRoundNumber (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the current round information.
    rpc GetCurrentRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the previous round information.
    rpc GetPreviousRoundInformation (google.protobuf.Empty) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get the current term number.
    rpc GetCurrentTermNumber (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the welfare reward the current term.
    rpc GetCurrentTermMiningReward (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of miners according to term number.
    rpc GetMinerList (GetMinerListInput) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of miner in previous term.
    rpc GetPreviousMinerList (google.protobuf.Empty) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the amount of mined blocks in previous term.
    rpc GetMinedBlocksOfPreviousTerm (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the miner that produces the next block.
    rpc GetNextMinerPubkey (google.protobuf.Empty) returns (google.protobuf.StringValue) {
        option (aelf.is_view) = true;
    }
    
    // Check to see if the account address is on the miner list for the current round.
    rpc IsCurrentMiner (aelf.Address) returns (google.protobuf.BoolValue) {
        option (aelf.is_view) = true;
    }
    
    // Query the left time before the next election takes effects (seconds).
    rpc GetNextElectCountDown (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
    
    // Get term information according term number.
    rpc GetPreviousTermInformation (google.protobuf.Int64Value) returns (Round) {
        option (aelf.is_view) = true;
    }
    
    // Get random hash (Keep this for compatibility).
    rpc GetRandomHash (google.protobuf.Int64Value) returns (aelf.Hash) {
        option (aelf.is_view) = true;
    }
    
    // Get the maximum of tiny blocks produced by a miner each round.
    rpc GetMaximumBlocksCount (google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }

    // Get the maximum count of miners.
    rpc GetMaximumMinersCount (google.protobuf.Empty) returns (google.protobuf.Int32Value) {
        option (aelf.is_view) = true;
    }
    
    // Get the authority information for SetMaximumMinersCount.
    rpc GetMaximumMinersCountController (google.protobuf.Empty) returns (AuthorityInfo) {
        option (aelf.is_view) = true;
    }
    
    // Get miner increase interval
    rpc GetMinerIncreaseInterval (google.protobuf.Empty) returns (google.protobuf.Int64Value){
        option (aelf.is_view) = true;
    }
    
    // Gets the list of miners in the main chain.
    rpc GetMainChainCurrentMinerList (google.protobuf.Empty) returns (MinerList) {
        option (aelf.is_view) = true;
    }
    
    // Get the list of miners in the previous term.
    rpc GetPreviousTermMinerPubkeyList (google.protobuf.Empty) returns (PubkeyList) {
        option (aelf.is_view) = true;
    }
    
    // Query the current mining reward for each block.
    rpc GetCurrentMiningRewardPerBlock (google.protobuf.Empty) returns (google.protobuf.Int64Value) {
        option (aelf.is_view) = true;
    }
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L13-14)
```csharp
    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L35-88)
```csharp
    public async Task UpdateInformationFromCrossChainTest()
    {
        SetToSideChain();
        InitialContracts();
        InitialAcs3Stubs();
        var mockedCrossChain = SampleAccount.Accounts.Last();
        var mockedCrossChainStub =
            GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
                ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
                mockedCrossChain.KeyPair);

        var headerInformation = new AElfConsensusHeaderInformation
        {
            Round = new Round
            {
                RoundNumber = 2,
                RealTimeMinersInformation =
                {
                    { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
                }
            }
        };

        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.First().PublicKey)
        });
        await CreateAndIssueToken("ELF");
        await CreateAndIssueToken("READ");
        await TokenStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "READ",
            Amount = 10_00000000,
            To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
        });

        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = headerInformation.ToByteString()
        });

        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex()).ShouldBe(headerInformation.Round.RealTimeMinersInformation.Keys);

        var balance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.Skip(1).First().PublicKey),
            Symbol = "READ"
        });
        balance.Balance.ShouldBe(2_00000000);
    }
```
