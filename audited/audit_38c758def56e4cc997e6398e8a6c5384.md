### Title
Finality Stall Attack via Unvalidated ImpliedIrreversibleBlockHeight Manipulation

### Summary
Malicious miners controlling a 2/3+ majority can stall chain finality indefinitely by providing stale `ImpliedIrreversibleBlockHeight` values in `UpdateValueInput` transactions. The `LibInformationValidationProvider` only prevents decreasing values but does not enforce progression or validate that reported heights match the current block height, allowing attackers to freeze the Last Irreversible Block (LIB) while passing all validation checks.

### Finding Description

**Root Cause:**

The vulnerability exists in the validation logic for `ImpliedIrreversibleBlockHeight` in UpdateValue transactions. When generating consensus data, the contract correctly sets `ImpliedIrreversibleBlockHeight = Context.CurrentHeight`: [1](#0-0) 

However, miners receive this Round data off-chain and construct their `UpdateValueInput` by extracting the field: [2](#0-1) 

Miners can arbitrarily modify this value before submitting their transaction. The only validation is in `LibInformationValidationProvider`: [3](#0-2) 

This check only fails if the provided value is LESS than the base round's value. It allows the value to remain equal (stagnant), which passes validation.

**Why Protections Fail:**

1. The validation uses `>` (strictly greater than) rather than `>=`, allowing equality to pass
2. There is no validation that `ImpliedIrreversibleBlockHeight` must equal or be near `Context.CurrentHeight`
3. The `UpdateValueValidationProvider` does not check this field at all [4](#0-3) 

**Execution Path:**

When `ProcessUpdateValue` executes, it directly stores the attacker-provided value: [5](#0-4) 

The LIB calculation then uses these stale values. The `LastIrreversibleBlockHeightCalculator` calculates the LIB by taking the value at index `(count-1)/3` of sorted implied heights: [6](#0-5) 

If 2/3+ miners provide the same stale value (e.g., 1000), the calculated `libHeight` remains at 1000. The check at line 272 prevents updating `ConfirmedIrreversibleBlockHeight`: [7](#0-6) 

### Impact Explanation

**Direct Harm:**
- Chain finality completely stalls - no new blocks become irreversible
- Cross-chain operations that depend on LIB heights for security become blocked
- Users cannot rely on transaction finality, creating uncertainty for high-value transfers
- The blockchain's security guarantee degrades to chain reorganization risk

**Quantified Damage:**
- All transactions after the stalled LIB height remain reversible indefinitely
- Cross-chain indexing and verification operations freeze (depends on confirmed irreversible block heights)
- Economic damage includes: inability to finalize cross-chain transfers, lost user confidence, potential for long-range reorg attacks

**Affected Parties:**
- All network participants lose finality guarantees
- Cross-chain users have funds/assets stuck
- Applications requiring transaction finality cannot operate safely
- Network validators experience degraded consensus security

**Severity Justification:**
Critical - This breaks a fundamental blockchain invariant (finality progression). The attack requires only 2/3+ miner collusion with no cost per attack execution, and completely disables finality guarantees while remaining undetectable through validation.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires control of 2/3+ consensus miners (67%+ majority)
- For a small/new chain or during election transitions, this threshold may be achievable
- On established chains with strong validator sets, this requires significant collusion

**Attack Complexity:**
- Low technical complexity - attackers simply modify a field in `UpdateValueInput` before submission
- No sophisticated cryptographic or timing attacks required
- Can be automated in mining software

**Feasibility Conditions:**
- Entry point is the public `UpdateValue` method that all miners must call
- No special permissions beyond being an active miner
- Attack leaves no detectible on-chain evidence in validation logs
- Can be executed continuously without cost (beyond normal mining operations)

**Detection/Operational Constraints:**
- The attack is invisible to validation - all transactions pass validation checks
- Monitoring would require off-chain detection of LIB stagnation patterns
- Once started, requires governance intervention or fork to resolve

**Probability Reasoning:**
- On small/nascent chains: HIGH probability (easier to achieve 2/3+ collusion)
- On established chains with diverse validator sets: MEDIUM probability (requires significant coordination)
- Economic incentives for attack: varies (could be used for cross-chain exploits or to extort the network)

### Recommendation

**Code-Level Mitigation:**

1. Add strict validation in `LibInformationValidationProvider` that `ImpliedIrreversibleBlockHeight` must match or be within a reasonable bound of `Context.CurrentHeight`:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation()
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var currentHeight = validationContext.ExtraData.BlockHeight; // or access from context
    
    // Must be current block or within small tolerance (e.g., 1-2 blocks for reorg safety)
    if (providedHeight < currentHeight - 2 || providedHeight > currentHeight)
    {
        validationResult.Message = "Implied lib height must match current block height.";
        return validationResult;
    }
    
    // Original check still needed
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > providedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
}
```

2. Consider adding monitoring for LIB progression rate in block validation

**Invariant Checks:**
- `ImpliedIrreversibleBlockHeight` must equal `Context.CurrentHeight` (with small tolerance for reorgs)
- `ConfirmedIrreversibleBlockHeight` must progress within N rounds (e.g., every 100 rounds)
- Alert/halt if LIB hasn't progressed in X blocks

**Test Cases:**
- Test that UpdateValue with stale `ImpliedIrreversibleBlockHeight` is rejected
- Test that UpdateValue with future `ImpliedIrreversibleBlockHeight` is rejected  
- Test that LIB progression continues under attack attempts
- Regression test ensuring proper validation of this field

### Proof of Concept

**Initial State:**
- Chain has been running normally
- Current block height: 2000
- ConfirmedIrreversibleBlockHeight: 1900
- 7 miners in consensus set

**Attack Sequence:**

1. Attacker controls 5 out of 7 miners (>2/3 majority)

2. At block height 2000, honest miner produces block:
   - UpdateValueInput with ImpliedIrreversibleBlockHeight = 2000
   - Stored in state

3. At block height 2001, attacker's miner produces block:
   - Receives consensus command with ImpliedIrreversibleBlockHeight = 2001
   - **Modifies** UpdateValueInput to ImpliedIrreversibleBlockHeight = 1900 (stale value)
   - Submits transaction
   - Validation check: baseRound[miner].ImpliedIrreversibleBlockHeight (1900) > providedRound[miner].ImpliedIrreversibleBlockHeight (1900) = FALSE
   - **Validation passes**, value stored as 1900

4. Steps continue for blocks 2002-2100 with attacker's miners providing 1900

5. At block 2101, LIB calculation occurs:
   - Collects ImpliedIrreversibleBlockHeight from miners who mined: [2000, 1900, 1900, 1900, 1900, 1900, 1900]
   - Sorts: [1900, 1900, 1900, 1900, 1900, 1900, 2000]
   - Takes index (7-1)/3 = 2: value is 1900
   - Check: currentRound.ConfirmedIrreversibleBlockHeight (1900) < libHeight (1900) = FALSE
   - **LIB not updated**, remains at 1900

**Expected vs Actual Result:**
- **Expected**: LIB should progress to approximately block 2000-2090 range
- **Actual**: LIB frozen at 1900, no finality progression for 200+ blocks

**Success Condition:**
- ConfirmedIrreversibleBlockHeight remains unchanged despite 200+ new blocks
- All validation checks pass
- Chain continues to produce blocks but without finality progression

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L48-48)
```csharp
            ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L248-248)
```csharp
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
