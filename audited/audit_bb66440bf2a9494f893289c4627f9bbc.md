### Title
Assembled NFTs Can Be Burned Directly, Permanently Locking Component NFTs

### Summary
The `Burn` method can be called directly on assembled NFTs, bypassing the `Disassemble` flow. This destroys the assembled NFT without returning the locked component NFTs/FTs, causing `AssembledNftsMap` entries to become orphaned while the locked assets remain permanently trapped in the contract. The vulnerability exists because assembled NFT creators are automatically added as minters and can thus burn their own assembled NFTs.

### Finding Description

The NFT contract allows users to create "assembled" NFTs by locking other NFTs and fungible tokens into a new composite NFT. The locked components are stored in `AssembledNftsMap` for later retrieval. [1](#0-0) 

During the `Assemble` operation, component NFTs are transferred from the user to the contract itself (`Context.Self`), and the mapping is stored: [2](#0-1) [3](#0-2) 

When minting the assembled NFT via `PerformMint`, the assembler (caller) is automatically added to the minter list: [4](#0-3) 

The intended flow for retrieving locked NFTs is through `Disassemble`, which burns the assembled NFT and transfers locked components back: [5](#0-4) 

**Root Cause:** The `Burn` method validates that the caller is in the minter list and has sufficient balance, but does NOT check if the NFT being burned is an assembled NFT that has locked components: [6](#0-5) 

The `Burn` method:
1. Does not check `AssembledNftsMap` for the token hash
2. Does not return locked NFTs to the owner
3. Does not remove the orphaned `AssembledNftsMap` entry

Since the assembler is a minter and owns the assembled NFT, they can call `Burn` directly, which:
- Destroys the assembled NFT
- Leaves `AssembledNftsMap[tokenHash]` entry intact but orphaned
- Permanently locks the component NFTs in the contract (no way to retrieve them)
- Creates a mismatch: the map claims NFTs are locked for a non-existent token

### Impact Explanation

**Direct Fund Impact:** NFTs and fungible tokens locked during assembly become permanently inaccessible. The value depends on what was assembled but could be substantial (rare NFTs, large FT amounts). The locked assets remain in the contract's balance but cannot be retrieved by anyone.

**Who is Affected:** 
- Users who accidentally call `Burn` instead of `Disassemble`
- Malicious actors who intentionally burn assembled NFTs to grief the protocol
- The contract itself accumulates unrecoverable locked assets

**Severity Justification:** HIGH
- Permanent loss of funds (NFTs cannot be recovered)
- No admin function to rescue locked assets
- Simple to trigger (single transaction)
- Breaks the core invariant that locked NFTs must be retrievable
- Contract balance will permanently exceed sum of all valid `AssembledNftsMap` entries

### Likelihood Explanation

**Reachable Entry Point:** The public `Burn` method can be called by any minter with sufficient balance.

**Feasible Preconditions:**
1. User creates an assembled NFT (becomes a minter automatically)
2. User owns the assembled NFT (minted to them)
3. Protocol must be burnable (set during creation)

**Execution Practicality:** Trivially simple - single transaction calling `Burn` with the assembled NFT's symbol and token ID.

**Attack Complexity:** LOW
- No special privileges needed beyond normal user operations
- No timing constraints
- No need to exploit race conditions

**Economic Rationality:** 
- Could occur accidentally (user confusion between Burn and Disassemble)
- Malicious griefing is cheap (only costs transaction fees)
- No financial benefit to attacker, but causes permanent fund loss

**Probability:** HIGH - This can happen through:
1. User error (calling wrong method)
2. UI/UX issues if interfaces don't clearly distinguish Burn vs Disassemble
3. Malicious intent (griefing attack)

### Recommendation

**Code-Level Mitigation:**

Add a check in the `Burn` method to prevent burning assembled NFTs:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // NEW: Prevent burning assembled NFTs
    Assert(State.AssembledNftsMap[tokenHash] == null, 
        "Cannot burn assembled NFT directly. Use Disassemble instead.");
    
    var nftInfo = GetNFTInfoByTokenHash(tokenHash);
    // ... rest of existing burn logic
}
```

**Alternative Mitigation (if burning assembled NFTs should be allowed):**

Modify `Burn` to automatically disassemble when burning an assembled NFT:

```csharp
public override Empty Burn(BurnInput input)
{
    var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
    
    // Check if assembled
    var assembledNfts = State.AssembledNftsMap[tokenHash];
    var assembledFts = State.AssembledFtsMap[tokenHash];
    
    if (assembledNfts != null || assembledFts != null)
    {
        // Return locked components before burning
        if (assembledNfts != null)
        {
            foreach (var pair in assembledNfts.Value)
                DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, Context.Sender, pair.Value);
            State.AssembledNftsMap.Remove(tokenHash);
        }
        if (assembledFts != null)
        {
            foreach (var pair in assembledFts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = Context.Sender
                });
            State.AssembledFtsMap.Remove(tokenHash);
        }
    }
    
    // ... rest of existing burn logic
}
```

**Invariant Checks to Add:**

1. Contract balance of any NFT should equal sum of all user balances plus locked amounts in `AssembledNftsMap`
2. Every entry in `AssembledNftsMap` must correspond to an existing (non-burned) NFT
3. Add view function to query contract's total locked NFT amounts for auditing

**Test Cases to Prevent Regression:**

1. Test burning assembled NFT directly - should fail or auto-disassemble
2. Test that only `Disassemble` can retrieve locked components
3. Test balance reconciliation after assemble/disassemble operations
4. Negative test: verify burned assembled NFT cannot be disassembled

### Proof of Concept

**Required Initial State:**
- NFT protocol created with `IsBurnable = true`
- User is added as minter
- User has minted at least one NFT (tokenId=1) to lock
- User has approved NFT contract for ELF tokens

**Attack Steps:**

1. User mints NFT with tokenId=1 (e.g., Symbol="HUMAN", TokenId=1)

2. User calls `Assemble`:
   - Symbol: "HUMAN"
   - AssembledNfts: {[Hash("HUMAN1")]: 1}
   - AssembledFts: {["ELF"]: 100}
   - Result: Creates assembled NFT with tokenId=2, locks tokenId=1 NFT in contract

3. User calls `Burn` directly (bypassing Disassemble):
   - Symbol: "HUMAN"
   - TokenId: 2
   - Amount: 1
   - Result: Assembled NFT (tokenId=2) is destroyed

4. User attempts to call `Disassemble`:
   - Symbol: "HUMAN"  
   - TokenId: 2
   - Result: FAILS - cannot burn non-existent NFT

5. Check contract state:
   - `State.AssembledNftsMap[Hash("HUMAN2")]` still contains entry for tokenId=1
   - `State.BalanceMap[Hash("HUMAN1")][ContractAddress]` = 1 (locked NFT remains)
   - No way to retrieve the locked NFT (tokenId=1)

**Expected vs Actual Result:**
- Expected: Locked NFTs should only be destroyed if returned to owner via Disassemble
- Actual: Locked NFTs permanently trapped in contract, `AssembledNftsMap` orphaned

**Success Condition for Exploit:**
- Assembled NFT burned successfully
- Locked component NFTs remain in contract balance
- `AssembledNftsMap` entry still exists but references destroyed NFT
- No method can retrieve the locked NFTs

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L32-32)
```csharp
    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L130-130)
```csharp
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L176-176)
```csharp
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-209)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L423-423)
```csharp
                Minters = { Context.Sender },
```
