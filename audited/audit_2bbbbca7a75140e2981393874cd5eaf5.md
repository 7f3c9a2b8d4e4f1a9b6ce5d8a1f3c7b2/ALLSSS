### Title
Integer Division Rounding Causes Permanent Token Accumulation in Consensus Contract

### Summary
The `DistributeResourceTokensToPreviousMiners()` function uses integer division to distribute resource tokens to miners, causing remainders to be truncated and permanently locked in the consensus contract. [1](#0-0)  Over time, these dust amounts accumulate across multiple token types with no recovery mechanism, resulting in permanent fund lockup.

### Finding Description

**Location and Root Cause:**

The vulnerability exists in the `DistributeResourceTokensToPreviousMiners()` method [2](#0-1) , specifically at the division operation [1](#0-0) .

The balance returned from `GetBalance` is of type `long` (int64), and the `Div` extension method performs standard C# integer division with truncation toward zero [3](#0-2) . When the balance is not perfectly divisible by the number of miners, the remainder is silently discarded.

**Execution Path:**

The function is called from `UpdateInformationFromCrossChain()` [4](#0-3) , which is invoked by the CrossChain contract when side chains synchronize miner lists from the main chain [5](#0-4) .

**Why Protections Fail:**

The accumulation affects all resource token symbols in both PayTxFeeSymbolList and PayRentalSymbolList [6](#0-5) . The only token transfer operation in the entire AEDPoS contract is within this distribution function [7](#0-6) , meaning there is no alternative mechanism to withdraw accumulated tokens. The contract implements only standard consensus interfaces (ACS1, ACS4, ACS6, ACS10, ACS11) [8](#0-7) , none of which provide token recovery functionality.

### Impact Explanation

**Concrete Harm:**

For each distribution with a typical miner count of 17 [9](#0-8) , up to 16 token units can be permanently lost per token symbol per call (remainder < miner count). 

Example calculation:
- Balance: 1,000,000,000 units
- Miners: 17
- Per miner: 1,000,000,000 ÷ 17 = 58,823,529 (truncated)
- Total distributed: 58,823,529 × 17 = 999,999,993
- **Permanently locked: 7 units**

**Affected Parties:**

Resource tokens (READ, WRITE, STORAGE, TRAFFIC, etc.) that should be distributed to miners are instead permanently locked. This affects all miners on side chains who should receive these fee rewards.

**Severity Justification:**

Medium severity because:
1. Individual amounts are small (< miner count per occurrence)
2. However, accumulation is unbounded and affects multiple token types
3. Funds are permanently and irrecoverably lost
4. Occurs automatically in normal operation without any recovery path

### Likelihood Explanation

**Occurrence Conditions:**

This issue occurs deterministically during normal side chain operation whenever `UpdateInformationFromCrossChain()` is called and the consensus contract holds token balances that are not perfectly divisible by the number of miners. No attacker action is required.

**Frequency:**

The function is invoked when the CrossChain contract updates side chain consensus information from the main chain [10](#0-9) , which happens regularly as miner lists are synchronized.

**Attack Complexity:**

Not applicable - this is not an exploitable vulnerability but rather a design flaw that causes inevitable token loss during normal operation. The likelihood is CERTAIN for any non-zero balance that is not perfectly divisible by the miner count.

### Recommendation

**Code-Level Mitigation:**

1. **Distribute remainder to a designated address:** Modify the distribution logic to send any remainder to a treasury, charity, or burn address:

```csharp
var amount = balance.Div(minerList.Count);
var totalDistributed = amount.Mul(minerList.Count);
var remainder = balance.Sub(totalDistributed);

// Distribute to miners
foreach (var pubkey in minerList) { ... }

// Send remainder to treasury or burn
if (remainder > 0) {
    State.TokenContract.Transfer.Send(new TransferInput {
        To = State.TreasuryContract.Value,
        Amount = remainder,
        Symbol = symbol
    });
}
```

2. **Add a recovery mechanism:** Implement a governance-controlled method to withdraw accumulated tokens:

```csharp
public override Empty RecoverAccumulatedTokens(RecoverTokensInput input) {
    Assert(Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()), 
           "Unauthorized.");
    State.TokenContract.Transfer.Send(new TransferInput {
        To = input.Recipient,
        Amount = input.Amount,
        Symbol = input.Symbol
    });
    return new Empty();
}
```

**Invariant to Add:**

Ensure consensus contract balance for resource tokens remains bounded or trends toward zero over time, not unbounded growth.

**Test Cases:**

1. Test distribution with balance not divisible by miner count, verify no dust accumulation
2. Test RecoverAccumulatedTokens with governance approval
3. Regression test to ensure all token transfers from consensus contract are accounted for

### Proof of Concept

**Initial State:**
- Side chain consensus contract deployed
- Resource token READ with balance: 1,000,000,000 units transferred to consensus contract
- Miner list contains 17 miners

**Transaction Steps:**

1. CrossChain contract calls `UpdateInformationFromCrossChain()` with new miner list
2. Function calls `DistributeResourceTokensToPreviousMiners()` [4](#0-3) 
3. Balance 1,000,000,000 is divided by 17 miners: `amount = 1,000,000,000.Div(17) = 58,823,529`
4. Each miner receives 58,823,529 units via Transfer [11](#0-10) 
5. Total distributed: 58,823,529 × 17 = 999,999,993 units

**Expected vs Actual Result:**

- **Expected:** All 1,000,000,000 units distributed or remainder sent elsewhere
- **Actual:** 999,999,993 units distributed, 7 units permanently locked in consensus contract

**Success Condition:**

Query consensus contract balance after distribution: `GetBalance(ConsensusContractAddress, "READ")` returns 7 units with no method available to recover them. This demonstration is observable in the test [12](#0-11)  where distribution occurs but remainder handling is not verified.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-90)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
    }
```

**File:** protobuf/aedpos_contract_impl.proto (L21-30)
```text
service AEDPoSContractImpl {
    option (aelf.csharp_state) = "AElf.Contracts.Consensus.AEDPoS.AEDPoSContractState";
    option (aelf.base) = "acs1.proto";
    option (aelf.base) = "acs4.proto";
    option (aelf.base) = "acs6.proto";
    // Dividend pool for side chain.
    option (aelf.base) = "acs10.proto";
    // Interact with Cross Chain module.
    option (aelf.base) = "acs11.proto";
    option (aelf.base) = "aedpos_contract.proto";
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/SideChainConsensusInformationTest.cs (L35-88)
```csharp
    public async Task UpdateInformationFromCrossChainTest()
    {
        SetToSideChain();
        InitialContracts();
        InitialAcs3Stubs();
        var mockedCrossChain = SampleAccount.Accounts.Last();
        var mockedCrossChainStub =
            GetTester<AEDPoSContractImplContainer.AEDPoSContractImplStub>(
                ContractAddresses[ConsensusSmartContractAddressNameProvider.Name],
                mockedCrossChain.KeyPair);

        var headerInformation = new AElfConsensusHeaderInformation
        {
            Round = new Round
            {
                RoundNumber = 2,
                RealTimeMinersInformation =
                {
                    { Accounts[0].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[1].KeyPair.PublicKey.ToHex(), new MinerInRound() },
                    { Accounts[2].KeyPair.PublicKey.ToHex(), new MinerInRound() }
                }
            }
        };

        await ParliamentStubs.First().Initialize.SendAsync(new InitializeInput
        {
            ProposerAuthorityRequired = false,
            PrivilegedProposer = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.First().PublicKey)
        });
        await CreateAndIssueToken("ELF");
        await CreateAndIssueToken("READ");
        await TokenStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "READ",
            Amount = 10_00000000,
            To = ContractAddresses[ConsensusSmartContractAddressNameProvider.Name]
        });

        await mockedCrossChainStub.UpdateInformationFromCrossChain.SendAsync(new BytesValue
        {
            Value = headerInformation.ToByteString()
        });

        var minerList = await ConsensusStub.GetMainChainCurrentMinerList.CallAsync(new Empty());
        minerList.Pubkeys.Select(m => m.ToHex()).ShouldBe(headerInformation.Round.RealTimeMinersInformation.Keys);

        var balance = await TokenStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(MissionedECKeyPairs.InitialKeyPairs.Skip(1).First().PublicKey),
            Symbol = "READ"
        });
        balance.Balance.ShouldBe(2_00000000);
    }
```
