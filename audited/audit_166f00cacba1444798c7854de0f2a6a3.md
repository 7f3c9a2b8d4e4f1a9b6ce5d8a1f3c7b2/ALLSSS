### Title
Missing Pubkey Uniqueness Validation in RealTimeMinersInformation Allows Consensus DoS

### Summary
The `RealTimeMinersInformation` dictionary in Round objects accepts external input without validating that dictionary keys match their corresponding `MinerInRound.Pubkey` values or that Pubkey values are unique. A single malicious miner can submit a NextRound with duplicate Pubkey entries, causing immediate consensus failure when any miner attempts to generate subsequent blocks, resulting in a complete chain halt.

### Finding Description

**Root Cause:**
The protocol defines `RealTimeMinersInformation` as `map<string, MinerInRound>` where keys should equal their values' Pubkey fields [1](#0-0) , and internal code generation maintains this invariant [2](#0-1) . However, when accepting external Round objects via `NextRound` or `NextTerm`, no validation enforces this invariant.

The validation providers check round numbers, term numbers, and InValue nullity [3](#0-2) , but never verify that RealTimeMinersInformation keys match Pubkey fields or that Pubkeys are unique across values.

**Critical Failure Point:**
When miners generate consensus transactions via `ExtractInformationToUpdateConsensus`, the code creates dictionaries using `RealTimeMinersInformation.Values.Where(...).ToDictionary(m => m.Pubkey, ...)` [4](#0-3) . If duplicate Pubkey values exist, `ToDictionary` throws an `ArgumentException`, preventing block generation. This occurs in three separate dictionary constructions within the same method [5](#0-4) .

**Secondary Issue:**
The `GetSortedImpliedIrreversibleBlockHeights` function iterates over `.Values` and filters by `specificPublicKeys.Contains(i.Pubkey)` [6](#0-5) , causing double-counting if duplicate Pubkeys exist, which affects LIB calculations [7](#0-6) .

### Impact Explanation

**Primary Impact - Consensus DoS:**
A malicious Round with duplicate Pubkeys causes all subsequent miners to fail when calling `ExtractInformationToUpdateConsensus` during normal block production, resulting in complete chain halt. No blocks can be produced until the malformed Round is manually removed from state through emergency intervention or rollback.

**Secondary Impact - LIB Manipulation:**
Before the DoS occurs, duplicate entries inflate the heights list in LIB calculations, potentially advancing the Last Irreversible Block height prematurely. This violates the 2/3+ consensus assumption and could affect cross-chain operations that rely on LIB finality.

**Affected Parties:**
- All network participants (complete chain halt)
- Cross-chain operations dependent on accurate LIB
- Economic activities requiring chain liveness

**Severity:** High - Single malicious actor can halt entire chain with one transaction.

### Likelihood Explanation

**Attacker Capabilities:**
Attacker must be a current miner (validated by `PreCheck`) [8](#0-7)  who can produce blocks at the appropriate time to submit NextRound.

**Attack Complexity:**
Low - Attacker simply crafts a `NextRoundInput` with duplicate Pubkey entries in RealTimeMinersInformation and submits via the public `NextRound` method [9](#0-8) . The malformed Round passes all validation checks and is stored in state [10](#0-9) .

**Feasibility:**
While requiring miner privileges, blockchain consensus typically assumes up to 1/3 Byzantine miners. This attack requires only ONE malicious (or buggy) miner, not 1/3+ collusion. Additionally, this could occur accidentally through buggy client software generating malformed consensus data.

**Detection:**
The attack is detected immediately when block production fails, but by then the damage is done - the chain is halted and requires manual intervention.

### Recommendation

**Immediate Fix:**
Add validation in `RoundTerminateValidationProvider` or a new dedicated validator for NextRound/NextTerm behaviors:

```csharp
// In RoundTerminateValidationProvider or new validator
private ValidationResult ValidateRealTimeMinersInformationIntegrity(Round round)
{
    // Check 1: Keys must match Pubkey values
    foreach (var kvp in round.RealTimeMinersInformation)
    {
        if (kvp.Key != kvp.Value.Pubkey)
            return new ValidationResult { Message = $"Key {kvp.Key} does not match Pubkey {kvp.Value.Pubkey}" };
    }
    
    // Check 2: All Pubkey values must be unique
    var pubkeys = round.RealTimeMinersInformation.Values.Select(m => m.Pubkey).ToList();
    if (pubkeys.Count != pubkeys.Distinct().Count())
        return new ValidationResult { Message = "Duplicate Pubkey values found in RealTimeMinersInformation" };
    
    return new ValidationResult { Success = true };
}
```

Register this validator in `ValidateBeforeExecution` for NextRound and NextTerm behaviors [11](#0-10) .

**Test Cases:**
1. Submit NextRound with key != Pubkey value → should reject
2. Submit NextRound with duplicate Pubkey values → should reject
3. Submit valid NextRound with unique keys matching Pubkeys → should accept

### Proof of Concept

**Required Initial State:**
- AEDPoS consensus initialized with active miners
- Attacker is a valid miner in current round

**Attack Steps:**
1. Attacker waits for their time slot to produce a block with NextRound behavior
2. Attacker crafts `NextRoundInput` with malformed RealTimeMinersInformation:
   ```
   {
     "minerA": MinerInRound { Pubkey = "minerA", ... },
     "minerB": MinerInRound { Pubkey = "minerB", ... },
     "fakeKey1": MinerInRound { Pubkey = "minerA", ImpliedIrreversibleBlockHeight = 200, ... },
     "fakeKey2": MinerInRound { Pubkey = "minerB", ImpliedIrreversibleBlockHeight = 250, ... }
   }
   ```
3. Attacker submits transaction calling `NextRound(malformedInput)`
4. Transaction passes all validation checks and malformed Round is stored
5. Next miner attempts to produce block:
   - Calls consensus transaction generation
   - Reaches `ExtractInformationToUpdateConsensus`
   - `ToDictionary(m => m.Pubkey, ...)` throws ArgumentException due to duplicate "minerA"
   - Block generation fails
6. All subsequent miners encounter same failure
7. Chain halted - no new blocks produced

**Expected vs Actual:**
- **Expected:** NextRound with duplicate Pubkeys rejected during validation
- **Actual:** NextRound accepted, consensus breaks on next block, chain halts

**Success Condition:**
Chain stops producing blocks after malicious NextRound is accepted, with all miners failing at consensus transaction generation.

### Citations

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L30-37)
```csharp
            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-33)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L14-16)
```csharp
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-91)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```
