### Title
Side Chain Miners Can Bypass Main Chain Authority by Overwriting Synced Miner List Through Unauthorized NextTerm Calls

### Summary
Side chain miners can exploit the lack of `IsMainChain` enforcement in `SetMinerList` by manually invoking `NextTerm` to overwrite the main chain miner list that was legitimately synced via cross-chain indexing. This allows outdated miners to maintain control of the side chain indefinitely, bypassing the security model where side chains should follow main chain authority for miner selection.

### Finding Description

The vulnerability exists across two locations:

**Location 1: Missing IsMainChain check in SetMinerList** [1](#0-0) 

The `SetMinerList` function contains a comment stating "Only Main Chain can perform this action" but **lacks any actual enforcement check**. Line 76 unconditionally sets `State.MainChainCurrentMinerList.Value = minerList` regardless of whether the contract is running on main chain or side chain.

**Location 2: The protection mechanism that gets bypassed** [2](#0-1) 

When `GenerateNextRoundInformation` detects that the side chain's current miner list differs from the stored main chain miner list, it correctly forces a switch to use the main chain miners. However, this protection is defeated when `SetMinerList` overwrites the stored value.

**Root Cause:**

The consensus contract properly syncs the main chain miner list via cross-chain indexing: [3](#0-2) 

This updates `State.MainChainCurrentMinerList.Value` with the legitimate main chain miners. However, when `ProcessNextTerm` is called (via the public `NextTerm` method), it invokes `SetMinerList` which overwrites this synced value: [4](#0-3) 

**Why Existing Protections Fail:**

1. **No architectural restriction:** While side chains normally only use `NextRound` behavior: [5](#0-4) 

The `NextTerm` method itself is public and only checks if the caller is a current/previous miner: [6](#0-5) 

2. **Validation doesn't prevent side chain NextTerm:** The validation provider only verifies round/term number increments: [7](#0-6) 

There is no check preventing side chains from processing `NextTerm` transactions.

### Impact Explanation

**Consensus Integrity Breach:**
- Side chain miners [A, B, C] who should have been replaced by main chain's new miners [D, E, F] can maintain indefinite control
- Breaks the fundamental security assumption that side chains derive their authority from the main chain
- Outdated miners can continue producing blocks, collecting rewards, and making consensus decisions

**Severity Justification:**
- **High severity** because it allows unauthorized miners to control side chain consensus
- Legitimate main chain miners [D, E, F] are prevented from taking over despite proper election/selection on main chain
- Can be sustained indefinitely through repeated exploitation
- Affects the entire side chain's security model and trust relationship with main chain

**Affected Parties:**
- Side chain users who expect main chain security guarantees
- Legitimate miners elected on main chain who should control the side chain
- Cross-chain applications relying on synchronized consensus authority

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be a current miner on the side chain (already in the "outdated" miner set [A, B, C])
- Ability to craft and submit transactions to the side chain
- Other colluding miners must include the malicious transaction in blocks

**Attack Complexity:**
- **Low complexity**: Simply call the public `NextTerm` method with properly incremented term/round numbers
- No special privileges needed beyond being a current miner (which attackers already are if they want to maintain control)
- Transaction passes all existing validation checks

**Feasibility Conditions:**
- Side chain must have recently synced a new main chain miner list via cross-chain indexing
- Attackers must act before the next normal round generation that would force the miner list switch
- Can be repeated indefinitely each time new main chain miner lists are synced

**Economic Rationality:**
- **Highly rational**: Outdated miners maintain their privileged position, continuing to earn consensus rewards
- Cost is minimal (one transaction per attack)
- Benefit is retaining control of entire side chain consensus

**Probability Assessment:**
- **High probability** if any side chain miner is malicious or has economic incentive to maintain control
- Detection is difficult as `NextTerm` appears to be a valid consensus operation
- No operational constraints prevent exploitation

### Recommendation

**Primary Fix: Add IsMainChain check in SetMinerList**

Modify `SetMinerList` to enforce the documented restriction:

```csharp
private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
{
    // Enforce main chain only restriction
    Assert(State.IsMainChain.Value, "Only main chain can update miner list.");
    
    var minerListFromState = State.MinerListMap[termNumber];
    if (gonnaReplaceSomeone || minerListFromState == null)
    {
        State.MainChainCurrentMinerList.Value = minerList;
        State.MinerListMap[termNumber] = minerList;
        return true;
    }
    return false;
}
```

**Secondary Fix: Prevent NextTerm on side chains**

Add explicit check in `NextTerm` method:
```csharp
public override Empty NextTerm(NextTermInput input)
{
    Assert(State.IsMainChain.Value, "Side chains cannot perform term changes.");
    SupplyCurrentRoundInformation();
    ProcessConsensusInformation(input);
    return new Empty();
}
```

**Validation Enhancement:**

Add side chain specific validation in `RoundTerminateValidationProvider`:
```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    // Reject NextTerm for side chains
    if (!validationContext.IsMainChain)
        return new ValidationResult { Message = "Side chains cannot perform term transitions." };
        
    // ... existing validation
}
```

**Test Cases:**
1. Verify side chain `NextTerm` call fails with assertion
2. Verify `SetMinerList` fails when called on side chain
3. Verify main chain miner list updates via cross-chain indexing are not overwritten
4. Verify side chain correctly switches to main chain miner list when they differ

### Proof of Concept

**Initial State:**
- Side chain initialized and running with miners [Alice, Bob, Carol]
- Main chain updates its miner list to [Dave, Eve, Frank]
- Cross-chain indexing successfully syncs this update:
  - `State.MainChainCurrentMinerList.Value = [Dave, Eve, Frank]`
  - `State.MainChainRoundNumber.Value = 1000`

**Attack Steps:**

1. **Before next round forces switch:** Alice (current side chain miner) crafts `NextTermInput`:
   - `TermNumber = CurrentTermNumber + 1` (e.g., 5 → 6)
   - `RoundNumber = CurrentRoundNumber + 1` (e.g., 100 → 101)
   - Include current miners [Alice, Bob, Carol] in round information

2. **Submit NextTerm transaction:** Alice calls `NextTerm(input)`
   - Passes `PreCheck()` (Alice is in current miner list)
   - Passes validation (term/round numbers increment correctly)
   - Executes `ProcessNextTerm` → `SetMinerList([Alice, Bob, Carol], 6)`

3. **State corruption:** `SetMinerList` executes line 76:
   - `State.MainChainCurrentMinerList.Value = [Alice, Bob, Carol]` (overwrites [Dave, Eve, Frank]!)
   - `State.MinerListMap[6] = [Alice, Bob, Carol]`

4. **Bypass protection:** Next round generation calls `GenerateNextRoundInformation`:
   - Checks `IsMainChainMinerListChanged(currentRound)` at line 288
   - Compares: current miners [Alice, Bob, Carol] == stored [Alice, Bob, Carol]
   - Returns `false` - no change detected!
   - **Expected:** Should switch to [Dave, Eve, Frank]
   - **Actual:** Continues with [Alice, Bob, Carol]

**Success Condition:**
Side chain continues operating under control of [Alice, Bob, Carol] despite main chain having elected [Dave, Eve, Frank] as the legitimate miner set. The attack can be repeated each time cross-chain indexing updates the miner list, permanently preventing the side chain from following main chain authority.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L63-82)
```csharp
    /// <summary>
    ///     Only Main Chain can perform this action.
    /// </summary>
    /// <param name="minerList"></param>
    /// <param name="termNumber"></param>
    /// <param name="gonnaReplaceSomeone"></param>
    /// <returns></returns>
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L288-294)
```csharp
        if (!IsMainChain && IsMainChainMinerListChanged(currentRound))
        {
            nextRound = State.MainChainCurrentMinerList.Value.GenerateFirstRoundOfNewTerm(
                currentRound.GetMiningInterval(), currentBlockTime, currentRound.RoundNumber);
            nextRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
            nextRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
            return;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L55-61)
```csharp
        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L188-190)
```csharp
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/SideChainConsensusBehaviourProvider.cs (L20-23)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return AElfConsensusBehaviour.NextRound;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```
