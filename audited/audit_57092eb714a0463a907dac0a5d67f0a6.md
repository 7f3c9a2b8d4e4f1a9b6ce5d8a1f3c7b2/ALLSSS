# Audit Report

## Title
NFT Type Removal Breaks Cross-Chain Protocol Synchronization

## Summary
The NFT contract's `RemoveNFTType` method allows Parliament to remove NFT types from the registry, but when `CrossChainCreate` attempts to synchronize existing protocols using those types to side chains, it fails with an assertion error because the type lookup returns null. The `InitialNFTTypeNameMap()` helper does not restore removed types, creating a permanent denial-of-service for cross-chain NFT synchronization until Parliament re-adds the type.

## Finding Description

The NFT contract maintains three state mappings for NFT types: `NFTTypes` (a dictionary), `NFTTypeFullNameMap` (short name → full name), and `NFTTypeShortNameMap` (full name → short name). [1](#0-0) 

Parliament can remove NFT types through `RemoveNFTType`, which removes entries from all three mappings but leaves `State.NFTTypes.Value` as a non-null dictionary object. [2](#0-1) 

**Root Cause:**

When `CrossChainCreate` is called on a side chain to synchronize an NFT protocol, it calls `InitialNFTTypeNameMap()` which returns early if `State.NFTTypes.Value != null`. Since `RemoveNFTType` only removes dictionary entries (not the dictionary itself), the initialization never runs and removed types are not restored. [3](#0-2) 

The method then extracts the 2-character short name from the symbol and looks it up in `NFTTypeFullNameMap`. If the type was removed, the lookup returns null and an assertion error is thrown: "Full name of {shortName} not found. Use AddNFTType to add this new pair." [4](#0-3) 

**Execution Path:**
1. User creates NFT protocol on mainchain with type "Art" → symbol "AR123456" is generated
2. Protocol info is stored with `nftType = "Art"` [5](#0-4) 
3. Parliament calls `RemoveNFTType("AR")` → removes "AR" from all mappings
4. Token is cross-chain created on side chain via MultiToken contract (succeeds)
5. User/system calls `CrossChainCreate("AR123456")` on side chain
6. Method extracts "AR" and looks it up → returns null → assertion fails

## Impact Explanation

**Direct Impact:** NFT protocols created on the mainchain before type removal cannot be synchronized to side chains. The `CrossChainCreate` method will revert with an assertion error, preventing the NFT protocol info from being created on the side chain.

**Protocol Damage:** While the MultiToken contract may successfully create the token on the side chain through standard cross-chain mechanisms, the NFT-specific protocol information (minter lists, metadata, NFT type) will not exist. This breaks NFT-specific operations on side chains including:
- Minting new NFTs (requires minter list)
- Querying NFT protocol info (returns null)
- NFT metadata and type information access

**Affected Users:** All users who created NFT protocols using a type that was subsequently removed by Parliament. Side chain users cannot access NFT functionality for these protocols, while mainchain functionality remains unaffected.

**Severity Justification - Medium:**
- Requires Parliament governance action (high barrier but realistic for cleanup)
- Impact is limited to cross-chain synchronization (mainchain protocols continue functioning)
- Breaks a core feature (cross-chain NFT support) for affected protocols
- Recovery requires Parliament to re-add the type via `AddNFTType`
- Permanent denial-of-service until governance intervention

## Likelihood Explanation

**Governance Action Required:** The vulnerability requires Parliament to approve and execute `RemoveNFTType`, which needs miner consensus through the default Parliament organization. [6](#0-5) 

**Realistic Scenario:** Parliament might legitimately deprecate obsolete or unused NFT types for cleanup purposes without realizing that:
1. Existing protocols on mainchain use those types
2. Cross-chain synchronization will fail for those protocols  
3. No validation exists in `RemoveNFTType` to prevent removing types that are in use

**Attack Complexity:** Low - single governance transaction execution via Parliament proposal and approval.

**Feasibility Conditions:**
- Parliament approves type removal (requires miner consensus)
- At least one NFT protocol exists using the removed type
- User attempts to synchronize that protocol to a side chain

**Detection Constraints:** The issue only manifests when attempting cross-chain synchronization after type removal. There is no test coverage for this scenario in the codebase (verified via grep search showing no RemoveNFTType tests). The error message even suggests adding the type back as a solution.

**Probability:** Medium-to-High for inadvertent breakage during legitimate governance cleanup operations, especially given the lack of validation and test coverage.

## Recommendation

Add validation to `RemoveNFTType` to check if any existing NFT protocols are using the type before allowing removal:

```csharp
public override Empty RemoveNFTType(StringValue input)
{
    AssertSenderIsParliamentDefaultAddress();
    InitialNFTTypeNameMap();
    Assert(input.Value.Length == 2, "Incorrect short name.");
    Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
    
    // NEW: Validate no protocols are using this type
    // Note: This requires iterating through protocols or maintaining a reverse mapping
    // Alternative: Document that types should never be removed, only deprecated
    
    var fullName = State.NFTTypeFullNameMap[input.Value];
    State.NFTTypeFullNameMap.Remove(input.Value);
    State.NFTTypeShortNameMap.Remove(fullName);
    var nftTypes = State.NFTTypes.Value;
    nftTypes.Value.Remove(input.Value);
    State.NFTTypes.Value = nftTypes;
    Context.Fire(new NFTTypeRemoved
    {
        ShortName = input.Value
    });
    return new Empty();
}
```

Alternatively, fix `InitialNFTTypeNameMap` to always restore default types regardless of whether `State.NFTTypes.Value` is null:

```csharp
private NFTTypes InitialNFTTypeNameMap()
{
    // Remove the early return check to always initialize missing types
    var nftTypes = State.NFTTypes.Value ?? new NFTTypes();
    
    // Add default types if they don't exist
    if (!nftTypes.Value.ContainsKey("XX")) nftTypes.Value.Add("XX", NFTType.Any.ToString());
    if (!nftTypes.Value.ContainsKey("AR")) nftTypes.Value.Add("AR", NFTType.Art.ToString());
    // ... add checks for all default types
    
    State.NFTTypes.Value = nftTypes;
    
    foreach (var pair in nftTypes.Value)
    {
        if (State.NFTTypeShortNameMap[pair.Value] == null)
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
        if (State.NFTTypeFullNameMap[pair.Key] == null)
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
    }
    
    return nftTypes;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreate_FailsAfterTypeRemoval_Test()
{
    // Step 1: Create NFT protocol on mainchain with Art type
    var createResult = await NFTContractStub.Create.SendAsync(new CreateInput
    {
        BaseUri = "ipfs://test/",
        NftType = NFTType.Art.ToString(),
        ProtocolName = "TestArt",
        TotalSupply = 1000,
        IsBurnable = true
    });
    var symbol = createResult.Output.Value;
    
    // Verify protocol created successfully
    var protocolInfo = await NFTContractStub.GetNFTProtocolInfo.CallAsync(new StringValue { Value = symbol });
    protocolInfo.Symbol.ShouldBe(symbol);
    protocolInfo.NftType.ShouldBe(NFTType.Art.ToString());
    
    // Step 2: Parliament removes the Art type ("AR")
    await NFTContractStubWithParliamentAuth.RemoveNFTType.SendAsync(new StringValue { Value = "AR" });
    
    // Step 3: Attempt CrossChainCreate on side chain with the same symbol
    // This should succeed but will fail with assertion error
    var exception = await Assert.ThrowsAsync<AssertionException>(async () =>
    {
        await SideChainNFTContractStub.CrossChainCreate.SendAsync(new CrossChainCreateInput
        {
            Symbol = symbol
        });
    });
    
    // Verify the expected error message
    exception.Message.ShouldContain($"Full name of AR not found. Use AddNFTType to add this new pair.");
}
```

**Notes:**
- The vulnerability occurs at the intersection of governance operations and cross-chain synchronization
- Parliament is a trusted role, but this represents a legitimate governance mistake rather than malicious action
- The issue highlights missing validation logic that should prevent removing types still in active use
- No test coverage exists for the `RemoveNFTType` functionality in the codebase

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L35-40)
```csharp
    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-169)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-41)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;
```
