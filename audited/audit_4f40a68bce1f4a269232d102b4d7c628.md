### Title
Permanent Contract Lock Due to Missing Null/Empty Address Validation in SetContractAuthor

### Summary
The `SetContractAuthor()` function lacks validation to prevent setting `input.NewAuthor` to null or an address with empty `Value`, which causes permanent denial-of-service by making the contract un-updatable through all update paths. Once the author is set to null/empty, no entity (including the original author or governance) can ever update the contract again, as all authorization checks fail.

### Finding Description

**Root Cause:**
The `SetContractAuthor()` function does not validate that `input.NewAuthor` is non-null and has a non-empty `Value` before assigning it to the contract's author field. [1](#0-0) 

This violates the standard validation pattern used consistently throughout the codebase. Compare with `SetSigner()` which correctly validates: [2](#0-1) 

The standard validation pattern `Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.")` is used extensively across the codebase: [3](#0-2) [4](#0-3) 

**Why Protection Fails:**
Once `info.Author` becomes null/empty, all contract update mechanisms become permanently blocked:

1. **ProposeUpdateContract path fails** at the authority check: [5](#0-4) [6](#0-5) 

When `contractInfo.Author` is null, both conditions fail: `null == Context.Self` (false) and `Context.Sender == null` (false, since Context.Sender cannot be null).

2. **UpdateUserSmartContract path fails** at permission check: [7](#0-6) 

When `info.Author` is null, `Context.Sender == null` is always false.

3. **SetContractAuthor itself cannot be called again** to fix the issue, failing at the same permission check on line 524.

4. The `UpdateSmartContract` public function also requires authorization: [8](#0-7) 

The protobuf Address type can be null when not set in the message: [9](#0-8) [10](#0-9) 

### Impact Explanation

**Permanent Denial of Service:**
- The contract becomes permanently un-updatable - no one can ever update the contract code again
- This affects ALL contracts where the author can be set (both system contracts and user contracts)
- There is no recovery mechanism or administrative override
- Even governance proposals cannot fix this state because `ProposeUpdateContract` fails before creating a proposal

**Affected Parties:**
- Contract authors lose the ability to fix bugs or add features
- Users of the contract are stuck with potentially vulnerable or incomplete code forever
- The entire chain's ability to evolve and fix issues in affected contracts is eliminated

**Severity Justification:**
This is a HIGH severity issue because:
1. The impact is permanent and irreversible
2. It affects critical authorization invariants (Authorization & Governance)
3. It causes complete operational denial of service
4. No mitigation or recovery path exists once triggered

### Likelihood Explanation

**Attacker Capabilities:**
The legitimate contract author must call `SetContractAuthor()` with a null or empty address. This can occur through:
- **Application bugs**: Contract management tools or scripts that incorrectly construct the protobuf message
- **Malicious intent**: A compromised or malicious author intentionally locking the contract
- **Incorrect message construction**: Developers accidentally creating `SetContractAuthorInput` messages without setting `NewAuthor`

**Attack Complexity:**
LOW - A single transaction from the current contract author is sufficient.

**Feasibility Conditions:**
- Author must have access to their private key (standard precondition)
- No additional governance approval or multi-sig is required
- The transaction is straightforward to execute

**Probability Reasoning:**
While this requires the author to explicitly set a null/empty address, the risk is MEDIUM because:
1. Protobuf messages default to null for unset fields, making accidental triggers possible
2. Many contracts in the ecosystem could be vulnerable simultaneously
3. The codebase shows this validation is standard practice everywhere else, suggesting awareness that null addresses are a real concern
4. The permanent, unrecoverable nature means even a single occurrence is catastrophic

### Recommendation

**Immediate Fix:**
Add validation to `SetContractAuthor()` following the established pattern used throughout the codebase:

```csharp
public override Empty SetContractAuthor(SetContractAuthorInput input)
{
    var info = State.ContractInfos[input.ContractAddress];
    Assert(info != null, "Contract not found.");
    Assert(input.NewAuthor != null && !input.NewAuthor.Value.IsNullOrEmpty(), 
           "Invalid new author address.");
    var oldAuthor = info.Author;
    Assert(Context.Sender == info.Author, "No permission.");
    info.Author = input.NewAuthor;
    State.ContractInfos[input.ContractAddress] = info;
    Context.Fire(new AuthorUpdated()
    {
        Address = input.ContractAddress,
        OldAuthor = oldAuthor,
        NewAuthor = input.NewAuthor
    });
    return new Empty();
}
```

**Invariant to Enforce:**
Contract author addresses must always be valid (non-null with non-empty Value).

**Test Cases:**
1. Test that `SetContractAuthor` rejects null `NewAuthor`
2. Test that `SetContractAuthor` rejects `NewAuthor` with empty `Value`
3. Test that contracts with valid authors can still be updated after author changes
4. Regression test ensuring the same validation exists in any future author-modification functions

### Proof of Concept

**Initial State:**
- Contract deployed with valid author address (e.g., address A)
- Author A has full control over the contract

**Attack Steps:**

1. **Author locks the contract** (can be accidental or malicious):
   ```
   Transaction: SetContractAuthor
   Input: {
     ContractAddress: <target_contract>,
     NewAuthor: null  // or Address with empty Value
   }
   Sender: Author A
   Result: SUCCESS - info.Author is now null
   ```

2. **Attempt to propose contract update** (by anyone, including original author):
   ```
   Transaction: ProposeUpdateContract
   Input: {
     Address: <target_contract>,
     Code: <updated_code>,
     ...
   }
   Sender: Any address (including former author A)
   Expected: Should create proposal
   Actual: FAILS with "No permission." at AssertAuthorityByContractInfo check
   ```

3. **Attempt to update user contract directly**:
   ```
   Transaction: UpdateUserSmartContract
   Input: {
     Address: <target_contract>,
     Code: <updated_code>,
     ...
   }
   Sender: Any address
   Expected: Should update contract (for authorized user)
   Actual: FAILS with "No permission." at Context.Sender == info.Author check
   ```

4. **Attempt to fix by setting author again**:
   ```
   Transaction: SetContractAuthor
   Input: {
     ContractAddress: <target_contract>,
     NewAuthor: <valid_address>
   }
   Sender: Any address (including former author A)
   Expected: Should restore valid author
   Actual: FAILS with "No permission." at Context.Sender == info.Author check
   ```

**Success Condition:**
After step 1, all subsequent operations (steps 2-4) fail permanently. The contract can never be updated again, demonstrating the permanent DOS vulnerability.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L175-184)
```csharp
    public override Hash ProposeUpdateContract(ContractUpdateInput input)
    {
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);

        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-452)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-535)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
        info.Author = input.NewAuthor;
        State.ContractInfos[input.ContractAddress] = info;
        Context.Fire(new AuthorUpdated()
        {
            Address = input.ContractAddress,
            OldAuthor = oldAuthor,
            NewAuthor = input.NewAuthor
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L537-545)
```csharp
    public override Empty SetSigner(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input.");

        if (State.SignerMap[Context.Sender] == input) return new Empty();

        State.SignerMap[Context.Sender] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L395-413)
```csharp
    private void ValidateContractOperation(ContractOperation contractOperation, int currentVersion, Hash codeHash)
    {
        Assert(contractOperation.Deployer != null && !contractOperation.Deployer.Value.IsNullOrEmpty(),
            "Invalid input deploying address.");
        Assert(contractOperation.Salt != null && !contractOperation.Salt.Value.IsNullOrEmpty(), "Invalid input salt.");
        Assert(contractOperation.CodeHash != null && !contractOperation.CodeHash.Value.IsNullOrEmpty(),
            "Invalid input code hash.");
        Assert(!contractOperation.Signature.IsNullOrEmpty(), "Invalid input signature.");

        Assert(contractOperation.Version == currentVersion + 1, "Invalid input version.");
        Assert(contractOperation.ChainId == Context.ChainId, "Invalid input chain id.");
        Assert(contractOperation.CodeHash == codeHash, "Invalid input code hash.");

        var recoveredAddress = RecoverAddressFromSignature(contractOperation);

        Assert(
            recoveredAddress == contractOperation.Deployer ||
            State.SignerMap[contractOperation.Deployer] == recoveredAddress, "Invalid signature.");
    }
```

**File:** protobuf/acs0.proto (L310-313)
```text
message SetContractAuthorInput{
    aelf.Address contract_address = 1;
    aelf.Address new_author = 2;
}
```

**File:** src/AElf.Types/Types/Address.cs (L96-99)
```csharp
        public static bool operator ==(Address address1, Address address2)
        {
            return address1?.Equals(address2) ?? ReferenceEquals(address2, null);
        }
```
