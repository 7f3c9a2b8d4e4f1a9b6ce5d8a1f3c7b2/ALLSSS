### Title
Missing Contract Address Validation in ChangeMethodFeeController Allows Governance Bypass

### Summary
The `ChangeMethodFeeController` function fails to validate that the provided `AuthorityInfo.ContractAddress` is one of the legitimate governance contracts (Parliament, Association, or Referendum) before calling `ValidateOrganizationExist`. This allows an attacker with temporary governance control to permanently bypass future governance by setting the controller to a malicious contract that always validates as true.

### Finding Description

The `ChangeMethodFeeController` function in `TokenHolderContract_ACS1_TransactionFeeProvider.cs` calls `CheckOrganizationExist` to validate the new authority without verifying the contract address: [1](#0-0) 

The `CheckOrganizationExist` method directly calls `ValidateOrganizationExist` on whatever contract address is provided in the input: [2](#0-1) 

**Root Cause**: The code accepts any contract address in `authorityInfo.ContractAddress` and calls its `ValidateOrganizationExist` method without first verifying that this address corresponds to one of the three legitimate system governance contracts (Parliament, Association, or Referendum).

**Why Protection Fails**: While the function requires the caller to be the current `MethodFeeController.OwnerAddress`, there is no validation that the NEW controller's `ContractAddress` is legitimate. An attacker can deploy a malicious contract with a fake `ValidateOrganizationExist` method that always returns `true`, bypassing the organization existence check entirely.

This same vulnerability pattern exists across multiple contracts: [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

### Impact Explanation

**Governance Bypass and Persistent Backdoor**: Once an attacker gains temporary control of the MethodFeeController (through legitimate governance or any means), they can use this vulnerability to make that control permanent and independent of future governance decisions. They deploy a malicious contract, set it as the new controller, and can then set arbitrary method fees forever.

**Economic Manipulation**: With permanent control over method fees, an attacker can:
- Set prohibitively high fees on critical functions (DoS attack)
- Make essential operations like token transfers or staking unusable
- Disrupt the protocol's economic model and user experience
- Extract value by forcing users to pay exorbitant fees

**Scope**: This affects all AElf contracts implementing ACS1, including TokenHolder, Parliament, Association, Referendum, MultiToken, Genesis, Economic, Election, Treasury, TokenConverter, CrossChain, Consensus, Profit, Vote, and Configuration contracts.

### Likelihood Explanation

**Attacker Capabilities**: Requires initial control of the current MethodFeeController organization (by default, the Parliament default organization controlled by elected Block Producers).

**Attack Complexity**: Low once precondition is met:
1. Deploy a malicious contract with `ValidateOrganizationExist()` returning `true`
2. Call `ChangeMethodFeeController` with malicious contract address
3. Validation passes, controller is changed
4. Attacker maintains permanent control

**Feasibility Conditions**: 
- Attacker must first gain legitimate control of MethodFeeController (e.g., through governance vote)
- No special privileges beyond that initial control are needed
- Attack is undetectable until executed, as malicious contract appears valid

**Economic Rationality**: Very high - the cost to deploy a simple malicious contract is minimal compared to the value of permanent governance control over method fees across all system contracts.

**Probability**: HIGH - This is a privilege escalation vulnerability. Once any entity gains temporary governance control (which is expected in decentralized governance), they can exploit this to make it permanent.

### Recommendation

**Code-Level Mitigation**: Add contract address validation in `CheckOrganizationExist` before calling `ValidateOrganizationExist`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is one of the legitimate governance contracts
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid authorization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant to Add**: AuthorityInfo.ContractAddress MUST be one of the three system governance contracts (Parliament, Association, or Referendum) before accepting it as a new controller.

**Test Cases**: Add tests verifying that `ChangeMethodFeeController` fails when provided with:
- An arbitrary user contract address
- A malicious contract implementing fake `ValidateOrganizationExist`
- System contracts other than governance contracts

Apply this fix to all affected contracts implementing ACS1.

### Proof of Concept

**Initial State**:
- Current MethodFeeController is Parliament default organization
- Attacker gains control through legitimate governance vote

**Attack Steps**:
1. Attacker deploys MaliciousContract with:
```csharp
public BoolValue ValidateOrganizationExist(Address input) 
{
    return new BoolValue { Value = true };  // Always returns true
}
```

2. Attacker (as current controller) calls `ChangeMethodFeeController` with:
```csharp
new AuthorityInfo 
{
    ContractAddress = MaliciousContractAddress,
    OwnerAddress = AttackerControlledAddress
}
```

3. `CheckOrganizationExist` calls `MaliciousContract.ValidateOrganizationExist(AttackerControlledAddress)` which returns `true`

4. Validation passes, MethodFeeController is now set to attacker's address

**Expected Result**: Transaction should fail with "Invalid authorization contract address"

**Actual Result**: Transaction succeeds, attacker gains permanent control of method fees, independent of future governance decisions

**Success Condition**: Attacker can now call `SetMethodFee` with arbitrary fees, bypassing all governance constraints.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```
