### Title
Permanent Loss of Welcome Rewards When All Miners Excluded from Basic Reward Distribution

### Summary
When no new miners are elected, the `UpdateWelcomeRewardWeights` function redirects Welcome Reward funds to BasicReward as a fallback. However, if all miners are excluded from BasicReward (all receiving 0 shares from `CalculateShares`), the funds are permanently burned rather than locked, resulting in irrecoverable loss of mining rewards. This occurs when BasicReward's `totalShares` equals zero, triggering the Profit contract's burn mechanism.

### Finding Description

The vulnerability exists in the Welcome Reward redistribution logic [1](#0-0)  where funds are redirected to BasicReward when no new miners exist, without validating that BasicReward has beneficiaries with non-zero shares.

**Execution Flow:**

1. In `UpdateBasicMinerRewardWeights`, all previous beneficiaries are removed [2](#0-1) , then new beneficiaries are added with shares calculated via `CalculateShares` [3](#0-2) 

2. The `CalculateShares` function returns 0 shares for miners producing less than half the average blocks [4](#0-3) 

3. If all miners produce 0 blocks (or all below average/2), all beneficiaries receive 0 shares, resulting in BasicReward's `totalShares = 0`

4. When WelcomeReward distributes to BasicReward (as its sub-scheme), funds are transferred to BasicReward's virtual address

5. When BasicReward attempts distribution with `totalShares <= 0`, the Profit contract's `DistributeProfits` function detects this condition [5](#0-4)  and calls `BurnProfits`

6. The `BurnProfits` function permanently destroys the tokens [6](#0-5) , transferring them to the contract and burning them

**Root Cause:** No validation exists to ensure BasicReward has beneficiaries with positive shares before redirecting WelcomeReward funds to it.

### Impact Explanation

**Direct Financial Impact:** Permanent, irrecoverable loss of mining rewards allocated to WelcomeReward scheme. The funds are not merely locked but completely destroyed through the token burn mechanism.

**Affected Parties:** All miners who would have been entitled to mining rewards in that distribution period lose their compensation permanently.

**Severity Justification:** HIGH severity because:
- Funds are permanently destroyed (worse than temporary locking)
- Affects core protocol economics (mining rewards)
- No recovery mechanism exists once tokens are burned
- Violates the invariant that mining rewards should be distributed to eligible participants

### Likelihood Explanation

**Triggering Conditions:**
- No new miners elected in the current term (triggers WelcomeReward â†’ BasicReward redirect)
- ALL miners produce 0 blocks OR all miners produce less than half the average (resulting in all receiving 0 shares)

**Realistic Scenarios:**
1. **Network Halt:** Complete consensus failure where all miners produce 0 blocks
2. **Catastrophic Network Degradation:** Severe network issues causing widespread miner failures

**Complexity:** LOW - No attacker action required; occurs automatically during normal protocol operation under specific network conditions

**Probability:** MEDIUM-LOW - Requires catastrophic network conditions, but mathematically possible. The scenario where all miners produce 0 blocks is the most straightforward path.

**Detection:** Would be visible in distribution logs showing negative amounts in `DistributedProfitsInfo.AmountsMap` (indicating burns).

### Recommendation

**Immediate Fix:** Add validation in `UpdateWelcomeRewardWeights` to check BasicReward's viability before redirection:

```csharp
else
{
    // Check if BasicReward has beneficiaries with non-zero shares
    var basicRewardScheme = State.ProfitContract.GetScheme.Call(State.BasicRewardHash.Value);
    if (basicRewardScheme.TotalShares > 0)
    {
        Context.LogDebug(() => "Welcome reward will go to Basic Reward.");
        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.BasicRewardHash.Value,
            SubSchemeShares = 1
        });
    }
    else
    {
        Context.LogDebug(() => "Welcome reward retained due to no valid beneficiaries.");
        // Alternative: redirect to Welfare or retain in WelcomeReward scheme
        State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
        {
            SchemeId = State.VotesWeightRewardHash.Value,
            SubSchemeId = State.WelfareHash.Value,
            SubSchemeShares = 1
        });
    }
}
```

**Additional Safeguards:**
1. Add similar validation in `UpdateFlexibleRewardWeights` [7](#0-6) 
2. Modify Profit contract to prevent burning when scheme has received tokens but has zero shares (accumulate instead)
3. Add regression test for zero-block-production scenario

### Proof of Concept

**Initial State:**
- Current term has 5 active miners
- No new miners elected (WelcomeReward redirects to BasicReward)
- All 5 miners experience network issues and produce 0 blocks each

**Execution Steps:**
1. Term ends, `Release()` is called by AEDPoS contract
2. `UpdateBasicMinerRewardWeights` calculates average = 0, assigns 0 shares to all miners
3. BasicReward's `totalShares = 0`
4. `UpdateWelcomeRewardWeights` redirects WelcomeReward to BasicReward (lines 881-890)
5. `ReleaseTreasurySubProfitItems` distributes all schemes
6. WelcomeReward distributes 100,000 ELF to BasicReward's virtual address
7. BasicReward attempts distribution with `totalShares = 0`
8. Profit contract triggers `BurnProfits` (line 485-486)
9. 100,000 ELF permanently burned

**Expected Result:** Mining rewards distributed to eligible beneficiaries or held for next valid distribution

**Actual Result:** 100,000 ELF permanently destroyed, no miners receive compensation

**Success Condition:** Token burn transaction succeeds, reducing total supply; funds irrecoverable

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L780-787)
```csharp
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L793-821)
```csharp
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L835-846)
```csharp
    private long CalculateShares(long producedBlocksCount, long averageProducedBlocksCount)
    {
        if (producedBlocksCount < averageProducedBlocksCount.Div(2))
            // If count < (1/2) * average_count, then this node won't share Basic Miner Reward.
            return 0;

        if (producedBlocksCount < averageProducedBlocksCount.Div(5).Mul(4))
            // If count < (4/5) * average_count, then ratio will be (count / average_count)
            return producedBlocksCount.Mul(producedBlocksCount).Div(averageProducedBlocksCount);

        return producedBlocksCount;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L881-890)
```csharp
        else
        {
            Context.LogDebug(() => "Welcome reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.VotesWeightRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L926-935)
```csharp
        else
        {
            Context.LogDebug(() => "Flexible reward will go to Basic Reward.");
            State.ProfitContract.AddSubScheme.Send(new AddSubSchemeInput
            {
                SchemeId = State.ReElectionRewardHash.Value,
                SubSchemeId = State.BasicRewardHash.Value,
                SubSchemeShares = 1
            });
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L517-558)
```csharp
    private Empty BurnProfits(long period, Dictionary<string, long> profitsMap, Scheme scheme,
        Address profitsReceivingVirtualAddress)
    {
        scheme.CurrentPeriod = period.Add(1);

        var distributedProfitsInfo = new DistributedProfitsInfo
        {
            IsReleased = true
        };
        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            if (amount > 0)
            {
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
                Context.SendVirtualInline(scheme.SchemeId, State.TokenContract.Value,
                    nameof(State.TokenContract.Transfer), new TransferInput
                    {
                        To = Context.Self,
                        Amount = amount,
                        Symbol = symbol
                    }.ToByteString());
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
            }
        }

        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
    }
```
