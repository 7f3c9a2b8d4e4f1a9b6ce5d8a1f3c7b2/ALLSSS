### Title
Zero Method Fee Configuration Enables Economic DoS Attack Through Unrestricted Transaction Spam

### Summary
The `SetMethodFee()` function allows the MethodFeeController (Parliament by default) to set method fees to zero without any minimum fee floor enforcement. This enables economic DoS attacks where adversaries can spam expensive computational methods at no cost, exhausting network resources and disrupting chain operations.

### Finding Description
The `SetMethodFee()` function in the Genesis contract validates only that fee amounts are non-negative, but does not enforce any minimum fee threshold: [1](#0-0) 

The validation function `AssertValidToken()` only checks `amount >= 0`, explicitly allowing zero fees: [2](#0-1) 

System contracts including Genesis, AEDPoS, and Token implement ACS1 (method fees charged to users) but do NOT implement ACS8 (resource tokens charged to contracts): [3](#0-2) 

When fees are zero, no charges are deducted from users: [4](#0-3) 

Test confirmation that zero fees result in no balance changes: [5](#0-4) 

While per-transaction computational limits exist (15,000 method calls and branch operations), these do not prevent spam attacks: [6](#0-5) 

Block producers can disable pre-execution validation for performance, bypassing validation before pool acceptance: [7](#0-6) [8](#0-7) 

### Impact Explanation
Setting method fees to zero for expensive Genesis contract methods (e.g., `ProposeNewContract`, `DeploySystemSmartContract`) creates a critical economic attack vector:

1. **Network Resource Exhaustion**: Attackers can submit unlimited transactions at zero cost, consuming network bandwidth, node CPU/memory, and transaction pool capacity (5,120 transaction limit).

2. **Transaction Pool Flooding**: Spam transactions fill the pool, preventing legitimate transactions from being processed and causing transaction delays for all users.

3. **Block Producer Resource Waste**: Even with computational limits per transaction, block producers must spend CPU time validating and executing each spam transaction up to the execution observer limits before rejection.

4. **Service Disruption**: Critical chain operations (contract deployment, governance proposals, cross-chain operations) can be significantly delayed or blocked by the spam flood.

The severity is HIGH because the attack cost is zero while the impact affects all network participants and core chain functionality.

### Likelihood Explanation
**Preconditions**: Requires Parliament (2/3 block producer approval) to set fees to zero through the standard governance process. While this is a trusted governance role, several realistic scenarios make exploitation feasible:

1. **Well-intentioned governance decisions**: Temporary zero fees for promotional periods, testing, or user onboarding initiatives.

2. **Governance mistakes**: Misconfigured proposals that accidentally set fees to zero for critical methods.

3. **Defense-in-depth failure**: No technical safeguard exists to prevent economic attacks even when governance is functioning properly.

**Attack Execution**: Once fees are zero, attack execution is trivial - adversaries simply submit many transactions calling expensive methods. If block producers have disabled `EnableTransactionExecutionValidation` for performance optimization, the attack bypasses pre-execution validation entirely.

**Economic Cost**: Zero for the attacker (no transaction fees), while causing significant operational disruption to the network.

**Detection Difficulty**: Distinguishing malicious spam from legitimate zero-fee usage is challenging until resource exhaustion symptoms appear.

### Recommendation
Implement a governance-configurable minimum fee floor to prevent zero-fee configurations:

1. **Add minimum fee validation in `SetMethodFee()`**:
   ```
   Assert(amount >= State.MinimumMethodFee.Value, 
          $"Fee amount {amount} below minimum {State.MinimumMethodFee.Value}");
   ```

2. **Add state variable and configuration method**:
   ```
   State.MinimumMethodFee = 1000; // e.g., 0.0001 ELF in smallest unit
   
   public override Empty SetMinimumMethodFee(Int64Value input) {
       RequireMethodFeeControllerPermission();
       Assert(input.Value > 0, "Minimum fee must be positive");
       State.MinimumMethodFee.Value = input.Value;
       return new Empty();
   }
   ```

3. **Alternatively, enforce minimum fee calculation based on computational cost** using execution observer metrics multiplied by a base rate, ensuring economic cost proportional to resource consumption.

4. **Add regression test** verifying that `SetMethodFee()` rejects zero or below-minimum fee configurations.

### Proof of Concept
**Initial State**: 
- Chain initialized with standard configuration
- Attacker address has minimal ELF balance (for transaction signing only)

**Attack Steps**:
1. Parliament proposes and approves `SetMethodFee()` setting Genesis contract's `ProposeNewContract` method fee to zero (base fee = 0, all fee symbols)

2. Attacker submits 5,000+ transactions concurrently calling `ProposeNewContract` with varying contract deployment proposals

3. Transactions consume zero fees (verified by unchanged attacker balance)

4. Transaction pool fills to 5,120 limit, blocking legitimate transactions

5. Block producers waste CPU cycles executing each transaction up to 15,000 method call limit before computational threshold rejection

6. Network bandwidth saturated with spam transaction propagation

**Expected Result**: Method fee validation rejects zero-fee configuration OR minimum fee charged per transaction

**Actual Result**: Zero fees accepted, spam transactions cost attacker nothing, network resources exhausted, legitimate transactions delayed/rejected

**Success Condition**: Attacker balance unchanged after 5,000 transactions; transaction pool full; legitimate user transactions timing out or rejected with "pool full" errors

### Notes
While this vulnerability requires governance action (Parliament setting zero fees), it represents a defense-in-depth failure where no technical safeguard prevents economic attacks. Best security practices suggest enforcing minimum fees at the protocol level even when governance is trusted, protecting against governance mistakes, temporary misconfigurations, or promotional periods that inadvertently enable attack vectors. The computational limits per transaction do not prevent aggregate resource exhaustion from many zero-cost transactions.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L73-82)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** protobuf/basic_contract_zero_impl.proto (L19-24)
```text
service BasicContractZeroImpl {
    option (aelf.csharp_state) = "AElf.Contracts.Genesis.BasicContractZeroState";
    option (aelf.base) = "acs0.proto";
    option (aelf.base) = "acs1.proto";
    option (aelf.base) = "basic_contract_zero.proto";
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L278-283)
```csharp
        if (fee.Count != 0)
        {
            // If base fee is set before, charge base fee.
            successToChargeBaseFee =
                ChargeBaseFee(fee, fromAddress, ref bill, freeAllowancesMap, ref allowanceBill, delegations);
        }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L466-488)
```csharp
    public async Task Method_Fee_Set_Zero_ChargeFee_Should_Be_Zero()
    {
        await DeployTestContractAsync();
        await SetMethodFee_Successful(0);

        var tokenContractStub = await GetTokenContractStubAsync();
        var before = await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });

        var dummy = await _testContractStub.DummyMethod.SendAsync(new Empty()); // This will deduct the fee
        dummy.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        await _testContractStub.DummyMethod.SendAsync(new Empty());

        var after = await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = DefaultSender,
            Symbol = "ELF"
        });
        before.Balance.ShouldBe(after.Balance);
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L10-15)
```text
Execution observer
------------------

- AElf's contract patcher will patch method call count observer for your contract. This is used to prevent infinitely method call like recursion. The number of method called in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.

- AElf's contract patcher will patch method branch count observer for your contract. This is used to prevent infinitely loop case. The number of code control transfer in your contract will be counted during transaction execution. The observer will pause transaction execution if the number exceeds 15,000. The limit adjustment is governed by ``Parliament``.
```

**File:** src/AElf.Kernel.TransactionPool/TransactionOptions.cs (L15-19)
```csharp
    /// <summary>
    ///     Bp Node can disable this flag to make best performance.
    ///     But common node needs to enable it to prevent transaction flood attack
    /// </summary>
    public bool EnableTransactionExecutionValidation { get; set; } = true;
```

**File:** src/AElf.Kernel.TransactionPool/Infrastructure/TransactionExecutionValidationProvider.cs (L31-34)
```csharp
    public async Task<bool> ValidateTransactionAsync(Transaction transaction, IChainContext chainContext)
    {
        if (!_transactionOptions.EnableTransactionExecutionValidation)
            return true;
```
