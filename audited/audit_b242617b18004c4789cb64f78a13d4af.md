### Title
Malicious Contract Address Bypass in ChangeMethodFeeController Allows Governance Evasion

### Summary
The `ChangeMethodFeeController` function validates new controllers by calling `ValidateOrganizationExist` on a user-provided contract address without verifying it is a legitimate governance contract. An attacker can deploy a malicious contract that always returns true, then submit a governance proposal using this malicious contract address to bypass organization validation and install an arbitrary address as the MethodFeeController, gaining direct control over method fees without further governance oversight.

### Finding Description

The vulnerability exists in the `CheckOrganizationExist` helper method which is called by `ChangeMethodFeeController` [1](#0-0) 

The `CheckOrganizationExist` method calls `Context.Call` with the `authorityInfo.ContractAddress` provided directly from user input, without validating that this address corresponds to a legitimate governance contract (Parliament, Association, or Referendum) [2](#0-1) 

Legitimate governance contracts implement `ValidateOrganizationExist` by checking if the organization exists in their state storage [3](#0-2) [4](#0-3) [5](#0-4) 

However, an attacker can deploy a malicious contract that implements this method to always return true, regardless of the input address. When a governance proposal is created with `AuthorityInfo` containing the malicious `ContractAddress` and an arbitrary `OwnerAddress` (such as the attacker's personal address), the validation passes even though the OwnerAddress is not a valid governance organization.

The same vulnerable pattern exists across multiple system contracts [6](#0-5) [7](#0-6) 

### Impact Explanation

This vulnerability enables complete governance bypass for method fee control:

1. **Direct Authority Compromise**: The attacker gains unilateral control over method fees without requiring governance approval for subsequent changes [8](#0-7) 

2. **Fee Manipulation**: The attacker can set arbitrary transaction fees, either extracting excessive value from users or setting fees to zero to drain contract resources.

3. **Denial of Service**: By setting exorbitant fees, the attacker can effectively disable contract functionality for legitimate users.

4. **Persistence**: Once the malicious controller is installed, reverting control requires the attacker's cooperation (since they control the OwnerAddress that must approve any subsequent changes) or requires emergency measures.

5. **Systemic Risk**: The same vulnerability affects multiple system contracts (MultiToken, Genesis, Election, etc.), potentially allowing coordinated attacks across the protocol.

The severity is HIGH because it violates the critical invariant of "method-fee provider authority" and enables unauthorized configuration changes without proper governance oversight.

### Likelihood Explanation

**Attack Complexity**: Medium
- Requires deploying a malicious contract (low complexity)
- Requires creating a governance proposal (standard process)
- Requires proposal approval by Parliament members (social engineering or oversight failure)

**Feasibility Conditions**:
The attack requires Parliament approval, which depends on:
1. Whether governance members verify the `ContractAddress` field matches a known system contract
2. Proposal review thoroughness
3. Social engineering effectiveness (e.g., disguising the malicious address)

**Detection Constraints**:
Tests demonstrate the expected pattern uses legitimate contract addresses [9](#0-8) , but no validation enforces this requirement.

**Probability Assessment**: MEDIUM-HIGH
While requiring governance approval adds friction, the lack of code-level validation means the system relies entirely on human vigilance. Security should not depend on governance members manually verifying contract addresses - proper validation must be enforced in the smart contract logic itself.

### Recommendation

**Immediate Fix**: Add validation to verify the `ContractAddress` is a legitimate governance contract before trusting its response:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a known governance contract
    ValidateContractState(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
    ValidateContractState(State.AssociationContract, SmartContractConstants.AssociationContractSystemName);
    ValidateContractState(State.ReferendumContract, SmartContractConstants.ReferendumContractSystemName);
    
    var validContracts = new[] {
        State.ParliamentContract.Value,
        State.AssociationContract.Value,
        State.ReferendumContract.Value
    };
    
    Assert(validContracts.Contains(authorityInfo.ContractAddress), 
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Additional Safeguards**:
1. Apply the same fix to all affected contracts (MultiToken, Genesis, Election, Vote, etc.)
2. Add test cases that explicitly attempt to use non-governance contract addresses and verify they are rejected
3. Consider using the Genesis Contract's system contract validation mechanism for additional assurance

**Test Case**:
```csharp
[Fact]
public async Task ChangeMethodFeeController_WithMaliciousContract_ShouldFail()
{
    // Deploy malicious contract (returns true for any input)
    var maliciousContract = await DeployMaliciousValidatorContract();
    
    // Attempt to change controller with malicious contract
    var result = await ProfitContractStub.ChangeMethodFeeController.SendWithExceptionAsync(
        new AuthorityInfo
        {
            ContractAddress = maliciousContract,
            OwnerAddress = DefaultSender
        });
    
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Invalid governance contract address");
}
```

### Proof of Concept

**Initial State**: ProfitContract initialized with Parliament default organization as MethodFeeController [10](#0-9) 

**Attack Sequence**:

1. **Deploy Malicious Contract**: Attacker deploys a contract implementing:
   ```
   ValidateOrganizationExist(Address input) returns BoolValue { Value = true }
   ```

2. **Create Proposal**: Attacker creates Parliament proposal to call `ChangeMethodFeeController` with:
   - `ContractAddress` = Malicious contract address
   - `OwnerAddress` = Attacker's personal address (e.g., 0xAttacker...)

3. **Proposal Approval**: Parliament members approve the proposal (assuming they don't verify ContractAddress)

4. **Proposal Release**: Proposal is released, executing `ChangeMethodFeeController`

5. **Validation Bypass**: 
   - Line 26: `CheckOrganizationExist` is called
   - Lines 92-94: `Context.Call` invokes malicious contract's `ValidateOrganizationExist`
   - Malicious contract returns `true`
   - Line 27: Assertion passes
   - Line 29: `State.MethodFeeController.Value` is set to attacker's AuthorityInfo

6. **Authority Gained**: Attacker's personal address is now the MethodFeeController

**Expected Result**: Validation should fail with "Invalid governance contract address"

**Actual Result**: Validation passes, attacker gains control over method fees

**Success Verification**: 
- Call `GetMethodFeeController()` returns attacker's address as OwnerAddress
- Attacker can directly call `SetMethodFee()` without governance approval
- Legitimate governance has no mechanism to revoke control without attacker's consent

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L22-31)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L71-83)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        ValidateContractState(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L90-95)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L116-121)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** test/AElf.Contracts.Profit.Tests/BVT/ACS1Tests.cs (L79-85)
```csharp
            const string proposalCreationMethodName = nameof(ProfitContractStub.ChangeMethodFeeController);
            var proposalId = await CreateProposalAsync(ProfitContractAddress,
                methodFeeController.OwnerAddress, proposalCreationMethodName, new AuthorityInfo
                {
                    OwnerAddress = organizationAddress,
                    ContractAddress = ParliamentContractAddress
                });
```
