### Title
Bootstrap Mining Dominance Attack via Relaxed Validation in Genesis Rounds 1-2

### Summary
During network genesis rounds 1-2, both continuous block validation and time slot validation are intentionally relaxed to facilitate network startup. A malicious initial miner can exploit this window to produce excessive blocks (up to 80 blocks in a 4-second time slot vs. the intended 8), gaining disproportionate mining rewards. The inflated `ProducedBlocks` count persists and determines reward distribution at term end, allowing the attacker to capture 5-10x their fair share of mining rewards.

### Finding Description

**Root Cause:**
The validation bypass occurs through three coordinated mechanisms:

1. **Continuous Blocks Validation Skip**: The `ContinuousBlocksValidationProvider` explicitly skips validation when `RoundNumber <= 2`: [1](#0-0) 

2. **Time Slot Validation Bypass**: The `TimeSlotValidationProvider` bypasses time slot enforcement in round 1 by returning `true` for the first round of any term: [2](#0-1) [3](#0-2) 

3. **GetConsensusCommand Enforcement Bypass**: The consensus command logic doesn't force `NextRound` behavior based on negative `BlocksCount` until round 3: [4](#0-3) 

**Attack Execution Path:**
A malicious miner (who must be configured as an initial miner in the genesis block) can produce blocks at the minimum interval of 50 milliseconds: [5](#0-4) 

During their time slot (typically 4000ms based on default mining interval), they can produce approximately 80 blocks instead of the intended 8 blocks (MaximumTinyBlocksCount). Each block increments their `ProducedBlocks` counter by exactly 1: [6](#0-5) 

**Why Protections Fail:**
- The `ResetLatestProviderToTinyBlocksCount` method correctly tracks and decrements `BlocksCount`, but the validation and command enforcement that depend on it are disabled in rounds 1-2: [7](#0-6) 

- Both validation providers are added to the validation pipeline but their internal logic explicitly bypasses enforcement in early rounds: [8](#0-7) 

### Impact Explanation

**Direct Reward Misallocation:**
The `ProducedBlocks` count is used for reward distribution at the end of each term. A malicious miner producing 80 blocks while other miners produce 8 each results in severe reward distortion:

- **10 Initial Miners Scenario**: Malicious miner captures 80/(80+72) = 52.6% of rewards instead of fair 10% share
- **20 Initial Miners Scenario**: Malicious miner captures 80/(80+152) = 34.5% of rewards instead of fair 5% share

This represents a **5-10x reward inflation** at the expense of honest miners.

**Protocol-Level Impact:**
- **Economic Unfairness**: Honest initial miners receive significantly reduced rewards despite equal participation
- **Trust Damage**: Genesis behavior sets precedent for network trustworthiness
- **Mining Centralization Risk**: Excessive early rewards compound through reinvestment in voting/staking

The `ProducedBlocks` metric is persisted in the consensus state and reported to the Election contract, affecting voter perception: [9](#0-8) 

### Likelihood Explanation

**Attacker Prerequisites:**
1. **Initial Miner Status**: Attacker must be configured in the genesis block's initial miner list. This is a privileged position but realistic as:
   - Initial miners are typically early project participants/validators
   - Genesis configuration may involve multiple stakeholders
   - Compromised or malicious participant can exploit this
   
The initial miner list is set via configuration and locked into the first round: [10](#0-9) 

**Attack Complexity:**
- **Technical**: Moderate - requires modifying node software to ignore `GetConsensusCommand` output and continuously produce `TinyBlock` transactions
- **Detection**: High - excessive block production is visible on-chain but damage occurs before detection
- **Reversibility**: None - rewards are distributed based on immutable `ProducedBlocks` history

**Timing Window:**
The attack is only effective in round 1 (optimal) or round 2 (partial). After round 2, validation activates: [11](#0-10) 

**Operational Constraints:**
The 50ms minimum interval is enforced by consensus command timing but not validated during rounds 1-2, making rapid block production physically feasible.

### Recommendation

**Immediate Fix:**
Apply continuous blocks validation from round 1 by removing the round number check. Replace the validation logic:

```diff
- if (validationContext.ProvidedRound.RoundNumber > 2 && 
+ if (validationContext.ProvidedRound.RoundNumber > 0 && 
     validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
``` [12](#0-11) 

**Enhanced Protection:**
Enforce `MaximumBlocksCount` limit in `GetConsensusCommand` from round 1:

```diff
if (currentRound.RealTimeMinersInformation.Count != 1 &&
-   currentRound.RoundNumber > 2 &&
+   currentRound.RoundNumber > 0 &&
    State.LatestPubkeyToTinyBlocksCount.Value != null &&
``` [4](#0-3) 

**Invariant to Enforce:**
- Each miner's `ProducedBlocks` in a single round must not exceed `MaximumTinyBlocksCount + 2` (accounting for UpdateValue block)
- Time slot boundaries must be enforced from round 1, with only the special single-node startup case bypassing validation

**Test Cases:**
1. Genesis attack test: Verify malicious miner cannot produce >10 blocks in round 1 time slot
2. Multi-miner genesis: Verify fair block distribution across all initial miners
3. Round transition test: Verify validation correctly activates at round 1

### Proof of Concept

**Initial State:**
- Network at genesis with 10 initial miners configured
- Mining interval: 4000ms per miner
- MaximumTinyBlocksCount: 8
- Current round: 1

**Attack Sequence:**
1. Malicious miner calls `UpdateTinyBlockInformation` at T=0ms (first block, establishes `ActualMiningTime`)
2. Malicious miner repeatedly calls `UpdateTinyBlockInformation` every 50ms:
   - T=50ms: Block 2 (BlocksCount decrements to 6)
   - T=100ms: Block 3 (BlocksCount decrements to 5)
   - ...
   - T=400ms: Block 9 (BlocksCount becomes negative: -1)
   - T=450ms: Block 10 (BlocksCount: -2)
   - ...continues until T=4000ms (end of time slot)
   - Total blocks produced: ~80 blocks

3. Each block passes `ValidateBeforeExecution` because:
   - `MiningPermissionValidationProvider`: Passes (miner in list)
   - `TimeSlotValidationProvider.CheckMinerTimeSlot`: Returns true (round 1 bypass)
   - `ContinuousBlocksValidationProvider`: Skips validation (round 1 bypass)

4. After round 1 completes, malicious miner's `ProducedBlocks` = 80, while honest miners have 8 each

**Expected vs Actual Result:**
- **Expected**: Each miner produces ~8 blocks, fair reward distribution (10% each)
- **Actual**: Malicious miner produces 80 blocks, captures 52.6% of term rewards

**Success Condition:**
Query `State.Rounds[1].RealTimeMinersInformation[maliciousMinerPubkey].ProducedBlocks` returns value significantly exceeding `MaximumTinyBlocksCount`, demonstrating validation bypass and confirming excessive block production during genesis.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L39-39)
```csharp
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L53-58)
```csharp
    private bool IsFirstRoundOfCurrentTerm(out long termNumber, ConsensusValidationContext validationContext)
    {
        termNumber = validationContext.CurrentTermNumber;
        return validationContext.PreviousRound.TermNumber != termNumber ||
               validationContext.CurrentRoundNumber == 1;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L29-35)
```csharp
        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L22-22)
```csharp
        protected const int TinyBlockMinimumInterval = 50;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L250-252)
```csharp
        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-92)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);

        Context.LogDebug(() =>
            $"Initial Miners: {input.RealTimeMinersInformation.Keys.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");

        return new Empty();
    }
```
