### Title
NextRound Validation Fails to Verify Miner Participation Against Trusted State

### Summary
The `NextRoundMiningOrderValidationProvider` only performs internal consistency checks on the untrusted `ProvidedRound` without comparing it against the trusted `BaseRound` from StateDb. This allows a malicious miner producing a NextRound block to manipulate the next round's miner schedule by including miners who didn't participate or excluding miners who did participate in the current round, breaking consensus integrity. [1](#0-0) 

### Finding Description

The validation occurs in `ValidateHeaderInformation()` and only examines the `ProvidedRound` (untrusted data from block header): [2](#0-1) 

**Root Cause**: The validation checks that within `ProvidedRound`, the count of miners with `FinalOrderOfNextRound > 0` equals the count with `OutValue != null`. However, when a NextRound is properly generated via `GenerateNextRoundInformation()`, these fields are NOT populated in the new round - only `Order`, `Pubkey`, `ExpectedMiningTime`, etc. are set: [3](#0-2) 

This means the validation effectively checks `0 == 0`, which always passes.

**Why Protections Fail**: The validation never compares against `BaseRound` (the trusted current round from StateDb) to verify that:
1. The miners included in `ProvidedRound` match those who actually participated in `BaseRound` (having `SupposedOrderOfNextRound != 0` or `OutValue != null`)
2. Their assigned orders in `ProvidedRound` correspond to their `FinalOrderOfNextRound` values from `BaseRound`

The validation context provides both `BaseRound` and `ProvidedRound`, but only `ProvidedRound` is used: [4](#0-3) 

**Execution Path**: During NextRound behavior, the validator is added but BaseRound is NOT recovered (unlike UpdateValue/TinyBlock behaviors): [5](#0-4) [6](#0-5) 

After validation passes, `ProcessNextRound()` directly stores the malicious round: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation**: A malicious miner can manipulate who gets to produce blocks in the next round:
- **Exclude legitimate miners**: Miners who participated in the current round can be removed from the next round, denying them expected mining rewards and reducing network decentralization
- **Include non-participating miners**: Miners who missed their slots or didn't participate can be included, violating the fundamental consensus rule that participation determines next-round eligibility  
- **Reorder mining schedule**: Manipulate which miners get favorable positions (e.g., extra block producer assignment), affecting reward distribution

**Who is Affected**: 
- All miners in the network (unfair schedule manipulation)
- Network consensus security (violation of expected miner rotation)
- Reward distribution fairness (miners receive incorrect amounts)

**Severity Justification**: HIGH - This breaks a critical consensus invariant that miner participation should determine next-round scheduling, as documented in the validation comment itself. [9](#0-8) 

### Likelihood Explanation

**Attacker Capabilities**: Any miner who produces a NextRound block (typically the extra block producer) can execute this attack. The extra block producer role rotates among miners based on deterministic calculation: [10](#0-9) 

**Attack Complexity**: LOW - The attacker simply needs to:
1. Wait for their turn to produce the NextRound block
2. Craft a `ProvidedRound` with manipulated miner assignments instead of calling the legitimate `GenerateNextRoundInformation()`
3. The ineffective validation (0 == 0 check) passes automatically
4. The malicious round is stored via `AddRoundInformation()`

**Feasibility**: PRACTICAL - No special preconditions required beyond being a miner. The attack is deterministic and leaves no uncertainty.

**Detection**: DIFFICULT - The manipulated round structure looks valid (all fields properly populated), making it hard to distinguish from legitimate rounds without comparing against expected state.

**Probability**: HIGH - Every NextRound transition is an opportunity. With rotating extra block producer roles, all miners eventually get the chance to exploit this.

### Recommendation

**Code-Level Mitigation**: Modify `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` to cross-validate against `BaseRound`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    var baseRound = validationContext.BaseRound;
    
    // Get miners who actually participated in BaseRound
    var minersWhoMined = baseRound.RealTimeMinersInformation.Values
        .Where(m => m.SupposedOrderOfNextRound != 0)
        .OrderBy(m => m.FinalOrderOfNextRound)
        .Select(m => m.Pubkey)
        .ToList();
    
    // Get miners assigned to ProvidedRound (in order)
    var providedMiners = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.Order > 0)
        .OrderBy(m => m.Order)
        .Select(m => m.Pubkey)
        .Take(minersWhoMined.Count)
        .ToList();
    
    // Verify the sets match and ordering is consistent
    if (!minersWhoMined.SequenceEqual(providedMiners))
    {
        validationResult.Message = "ProvidedRound miner assignments don't match miners who participated in BaseRound";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

**Invariant Checks**: Ensure that for NextRound transitions:
1. The set of miners in `ProvidedRound` (first N positions) exactly matches miners with `SupposedOrderOfNextRound != 0` in `BaseRound`
2. Their order in `ProvidedRound` matches their `FinalOrderOfNextRound` values from `BaseRound`
3. Miners who didn't participate (`SupposedOrderOfNextRound == 0`) are placed in remaining positions

**Test Cases**: Add integration tests verifying:
- NextRound validation rejects when ProvidedRound excludes a miner who participated
- NextRound validation rejects when ProvidedRound includes a miner who didn't participate  
- NextRound validation rejects when miner order doesn't match FinalOrderOfNextRound from BaseRound
- NextRound validation accepts only when ProvidedRound correctly reflects BaseRound participation

### Proof of Concept

**Initial State (BaseRound in StateDb)**:
- MinerA: `OutValue = Hash("A")`, `SupposedOrderOfNextRound = 2`, `FinalOrderOfNextRound = 2`
- MinerB: `OutValue = Hash("B")`, `SupposedOrderOfNextRound = 1`, `FinalOrderOfNextRound = 1`  
- MinerC: `OutValue = null`, `SupposedOrderOfNextRound = 0` (didn't mine)
- Total: 3 miners, 2 participated

**Attack Steps**:
1. MinerB is assigned as extra block producer for NextRound transition
2. Instead of calling legitimate `GenerateNextRoundInformation()`, MinerB crafts malicious `ProvidedRound`:
   - Assigns MinerC to Order 1 (even though C didn't participate!)
   - Assigns MinerA to Order 2  
   - Excludes themselves (MinerB) from next round
3. In the crafted `ProvidedRound`, no miners have `FinalOrderOfNextRound` or `OutValue` set (it's a fresh next round)
4. Validation executes: `Count(FinalOrderOfNextRound > 0) == Count(OutValue != null)` → `0 == 0` → PASSES
5. `ProcessNextRound()` calls `AddRoundInformation(maliciousRound)` and stores it to StateDb

**Expected vs Actual Result**:
- **Expected**: Validation rejects because MinerC didn't participate in BaseRound and MinerB should be included
- **Actual**: Validation passes; next round proceeds with manipulated miner schedule where a non-participating miner gets priority position and a participating miner is excluded

**Success Condition**: After the NextRound block is processed, query the new current round from StateDb and observe that it contains the manipulated miner assignments instead of the legitimate ones based on BaseRound participation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L25-37)
```csharp
        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-27)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-112)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```
