# Audit Report

## Title
Missing Validation in Secret Sharing Allows Consensus Randomness Manipulation via PreviousInValue Corruption

## Summary
The AEDPoS consensus contract's `PerformSecretSharing` method unconditionally accepts and stores `PreviousInValue` entries for arbitrary miners from UpdateValue transactions without cryptographic validation. When combined with the `SupplyCurrentRoundInformation` mechanism that fills missing miner data during round transitions, this allows a malicious miner to corrupt consensus randomness by injecting fake `PreviousInValue` data that gets used in signature calculations affecting mining order determination.

## Finding Description

The vulnerability exists due to missing validation in the secret sharing flow:

**Root Cause:** The `PerformSecretSharing` method unconditionally overwrites `PreviousInValue` for any miner specified in the `MinersPreviousInValues` dictionary without validating that these values are cryptographically correct: [1](#0-0) 

**Validation Gap:** The `UpdateValueValidationProvider` only validates the transaction sender's own `PreviousInValue` against their previous round's `OutValue`, but does not validate entries in `MinersPreviousInValues` for other miners: [2](#0-1) 

The validation explicitly uses `validationContext.SenderPubkey`, checking only the sender's value and ignoring all other entries in the `MinersPreviousInValues` map.

**Impact Manifestation:** The corrupted `PreviousInValue` becomes exploitable when `SupplyCurrentRoundInformation` is called during round transitions for miners who failed to produce blocks. This method reads the potentially corrupted value from state and uses it to calculate the miner's signature: [3](#0-2) 

The corrupted signature then affects mining order calculation through the modulo operation in `ApplyNormalConsensusData`: [4](#0-3) 

**Attack Execution Path:**
1. Round N: Victim miner produces block with legitimate `OutValue`
2. Round N+1: Attacker (active miner) submits UpdateValue transaction with malicious `MinersPreviousInValues[victim] = fake_hash`
3. Contract stores fake value without validation via `PerformSecretSharing`
4. Round N+2: Victim goes offline or misses their block slot
5. Another miner calls `NextRound`, triggering `SupplyCurrentRoundInformation`
6. Method reads corrupted `PreviousInValue` from state and calculates fake signature
7. Fake signature propagates to mining order calculation, affecting consensus randomness

## Impact Explanation

**Consensus Integrity Breach:**
- Corrupted `PreviousInValue` leads to incorrect signature calculation when miners miss blocks
- The signature directly determines mining order via `GetAbsModulus(sigNum, minersCount) + 1`
- Attackers can bias mining order selection to favor themselves or specific miners
- The corruption persists in the round state and cannot be retroactively corrected

**Severity: Medium-High**
- Requires victim to miss a block (realistic due to network issues, maintenance)
- Affects core consensus randomness mechanism
- Can be repeated across multiple rounds/victims
- Limited by requirement that victim must actually miss their time slot
- No direct fund loss, but undermines consensus fairness guarantees

## Likelihood Explanation

**Attacker Requirements:**
- Must be an active consensus miner (moderate barrier)
- Needs ability to construct malicious UpdateValue transactions with fake `MinersPreviousInValues`
- Requires victim to subsequently miss a block

**Attack Feasibility:**
- **Complexity: Low** - Attacker modifies off-chain transaction construction logic
- **Detection: Difficult** - No immediate on-chain validation signals the manipulation
- **Preconditions: Moderate** - Secret sharing must be enabled, victim must miss block

**Probability: Medium**
The attack is practical when targeting miners with known reliability issues or during network congestion periods where missed blocks are more common.

## Recommendation

Add validation for all entries in `MinersPreviousInValues` before storing them:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
    string publicKey, Round previousRound)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);

    // Add validation for MinersPreviousInValues
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        // Validate that Hash(previousInValue) == previousRound.OutValue for this miner
        if (previousRound != null && 
            previousRound.RealTimeMinersInformation.ContainsKey(previousInValue.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[previousInValue.Key].OutValue;
            if (expectedOutValue != null && 
                HashHelper.ComputeFrom(previousInValue.Value) != expectedOutValue)
            {
                // Skip invalid entries
                continue;
            }
        }
        round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
}
```

Update the method signature to pass `previousRound` and validate each entry against the corresponding miner's `OutValue` from the previous round before accepting it.

## Proof of Concept

```csharp
[Fact]
public async Task MaliciousMinerCanCorruptVictimPreviousInValue()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMiners(3);
    var attacker = miners[0];
    var victim = miners[1];
    
    // Round N: Victim produces block normally
    await ProduceNormalBlock(victim);
    var roundN = await GetCurrentRound();
    var victimOutValue = roundN.RealTimeMinersInformation[victim].OutValue;
    
    // Round N+1: Attacker creates malicious UpdateValue with fake PreviousInValue
    var fakeHash = HashHelper.ComputeFrom("malicious_data");
    var maliciousInput = new UpdateValueInput
    {
        // ... normal fields for attacker ...
        MinersPreviousInValues = {
            { victim, fakeHash } // Inject fake value for victim
        }
    };
    
    // Submit attacker's malicious transaction
    await attacker.UpdateValue(maliciousInput);
    
    // Verify: Fake value is stored without validation
    var roundNPlus1 = await GetCurrentRound();
    Assert.Equal(fakeHash, roundNPlus1.RealTimeMinersInformation[victim].PreviousInValue);
    
    // Round N+2: Victim misses block, NextRound is called
    await SimulateVictimMissedBlock(victim);
    await miners[2].NextRound(nextRoundInput);
    
    // Verify: SupplyCurrentRoundInformation used fake value for signature calculation
    var roundNPlus2 = await GetCurrentRound();
    var victimSignature = roundNPlus2.RealTimeMinersInformation[victim].Signature;
    
    // Signature was calculated from fake PreviousInValue, not real one
    var expectedSignature = roundNPlus1.CalculateSignature(fakeHash);
    Assert.Equal(expectedSignature, victimSignature);
    
    // This corrupted signature affects mining order calculation
    var corruptedOrder = (int)(victimSignature.ToInt64() % miners.Count) + 1;
    Assert.NotEqual(victim.ExpectedOrder, corruptedOrder); // Order was manipulated
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L295-296)
```csharp
        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-200)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
