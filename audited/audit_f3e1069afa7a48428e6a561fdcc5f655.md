### Title
Improper Stale Miner Check Bypass When Miner List Changes Leads to Transaction Failures and Unauthorized Actions

### Summary
The `IsMinerListJustChanged` flag set at line 341 does propagate correctly through round generation, but its usage in `IsCurrentMiner` is flawed. When set to true, the safety check verifying miner existence in the current round is bypassed, causing KeyNotFoundException for replaced miners attempting to access miner-only functions. Additionally, replaced miners who were extra block producers can perform unauthorized actions during the round transition window.

### Finding Description

The vulnerability exists in the `IsCurrentMiner` private method [1](#0-0) 

When miners are replaced during round generation, the flag is correctly set [2](#0-1)  and properly propagated to the next round via the extension method [3](#0-2)  which stores it [4](#0-3) 

However, the flaw occurs when `IsCurrentMiner` is invoked. The method `ConvertAddressToPubkey` searches for miners in both current and previous rounds [5](#0-4) , allowing replaced miners (present in previous round but removed from current round) to have their pubkey returned.

When `IsCurrentMiner` is called with a replaced miner's pubkey, the containment check is bypassed due to the flag being true. Execution then attempts to access the miner's information from the current round dictionary [6](#0-5) , causing a KeyNotFoundException since the replaced miner doesn't exist in the current round.

The same vulnerability exists in subsequent dictionary accesses [7](#0-6)  and [8](#0-7) 

### Impact Explanation

**Primary Impact - Transaction Failure DoS**: Replaced miners attempting to call miner-only functions like `ClaimTransactionFees` [9](#0-8) , `DonateResourceToken` [10](#0-9) , or cross-chain indexing operations [11](#0-10)  will experience transaction failures due to unhandled KeyNotFoundException.

**Secondary Impact - Unauthorized Actions During Transition**: Replaced miners who are the extra block producer of the previous round can pass the transition check [12](#0-11)  and perform miner-only actions during the brief window before the new round officially starts, even after being removed from the miner list. The extra block producer is set [13](#0-12)  before miner replacement occurs [14](#0-13) 

This affects miner schedule integrity, as replaced (potentially evil) miners retain privileges during transition, and creates ungraceful failures exposing a logic error in permission validation.

### Likelihood Explanation

**Attacker Capabilities**: A replaced miner (attacker) needs only to call standard public contract methods. No special privileges required beyond having been a miner in the previous round.

**Attack Complexity**: Low - the replaced miner simply invokes miner-only functions after replacement. The PreCheck validation [15](#0-14)  allows miners from the previous round to pass, making the attack straightforward.

**Feasibility Conditions**: 
- Miner replacement must occur (when evil miners are detected via `GetMinerReplacementInformation` [16](#0-15) )
- The `IsMinerListJustChanged` flag must be true (set for one round after replacement)
- Replaced miner attempts to invoke miner-only functions

**Detection Constraints**: The window is limited to one round after replacement. However, miner replacement occurs whenever evil miners are detected, making this a recurring vulnerability.

**Probability**: Medium - miner replacement is a regular occurrence in the consensus mechanism when miners miss time slots or behave maliciously.

### Recommendation

**Code-Level Mitigation**: Modify the `IsCurrentMiner` method to properly validate replaced miners:

```csharp
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
{
    if (!currentRound.IsMinerListJustChanged)
        return false;
    
    // When miner list just changed, verify this is a NEW miner, not a REMOVED one
    if (TryToGetPreviousRoundInformation(out var prevRound) && 
        prevRound.RealTimeMinersInformation.ContainsKey(pubkey))
    {
        // This miner was in previous round but not current = replaced/removed
        // Only allow during transition if they're the extra block producer
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
            return true;
        return false;
    }
    // This is a new miner - allow only during transition window
    if (!(Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
          currentRound.ExtraBlockProducerOfPreviousRound == pubkey))
        return false;
}
```

**Invariant Checks**: Add explicit validation before all dictionary accesses to miners not confirmed to exist in current round.

**Test Cases**: 
1. Test replaced miner calling ClaimTransactionFees after replacement
2. Test replaced extra block producer attempting actions during transition
3. Test new miner joining when IsMinerListJustChanged is true

### Proof of Concept

**Initial State**:
- Round N active with miners A, B, C, D
- Miner C has accumulated missed time slots marking them for replacement

**Attack Sequence**:
1. Miner B produces extra block to end Round N
2. During extra block generation, `GenerateNextRoundInformation` is called
3. `GetMinerReplacementInformation` identifies C as evil miner to replace with E
4. Round N+1 is generated with miners A, B, E, D and `IsMinerListJustChanged = true`
5. Round N+1 is persisted via `AddRoundInformation` [17](#0-16) 
6. Replaced miner C attempts to call `ClaimTransactionFees`
7. `AssertSenderIsCurrentMiner` invokes `IsCurrentMiner` via cross-contract call [18](#0-17) 
8. `ConvertAddressToPubkey` finds C in previous round and returns C's pubkey
9. `IsCurrentMiner(C)` bypasses containment check (line 142-144)
10. Code attempts to access `currentRound.RealTimeMinersInformation[C]` (line 158)

**Expected Result**: Transaction should cleanly reject replaced miner with "No permission" or similar message

**Actual Result**: Transaction fails with KeyNotFoundException due to attempting dictionary access with non-existent key, exposing an unhandled error path and confirming the flag does not properly prevent stale miner checks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L127-130)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-158)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L205-205)
```csharp
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-305)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L337-341)
```csharp
                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L345-346)
```csharp
        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L14-14)
```csharp
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L24-24)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-869)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L905-905)
```csharp
        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L913-915)
```csharp
    public override Empty DonateResourceToken(TotalResourceTokensMaps input)
    {
        AssertSenderIsCurrentMiner();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L286-286)
```csharp
        AssertAddressIsCurrentMiner(Context.Sender);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L176-176)
```csharp
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```
