### Title
Partial Token Burns in BurnProfits() Leading to Inconsistent Scheme State

### Summary
The `BurnProfits()` function silently skips tokens with insufficient balance instead of reverting the entire transaction, allowing partial burns where some tokens are burned while others are not. This creates inconsistent state as the scheme's period advances regardless of burn success, and there is no mechanism to retry failed burns or notify users of the partial execution.

### Finding Description

The vulnerability exists in the `BurnProfits()` private method which is called from `DistributeProfits()` when either `input.Period < 0` or `totalShares <= 0`. [1](#0-0) 

The `BurnProfits()` function increments the scheme's period immediately upon entry, then iterates through the `profitsMap` to burn each token type. [2](#0-1) 

For each token, the function checks if the scheme's balance is sufficient. If the balance is less than the amount to burn, it simply continues to the next token without reverting or logging an error: [3](#0-2) 

Only successfully burned tokens are recorded in the `distributedProfitsInfo.AmountsMap`: [4](#0-3) 

The state is then saved regardless of how many burns actually succeeded: [5](#0-4) 

The `profitsMap` can contain amounts exceeding actual balance when the manager explicitly provides `AmountsMap` with non-zero values in `DistributeProfits()`: [6](#0-5) 

When `amount.Value != 0`, the provided amount is used directly without validating against actual balance.

### Impact Explanation

**Direct Fund Impact**: Tokens intended to be burned remain in circulation within the scheme's virtual address, affecting token economics and supply calculations. If the intention was to permanently remove tokens from circulation, only partial removal occurs.

**Inconsistent State**: The scheme's `CurrentPeriod` advances to the next period even when not all intended burns complete. The `DistributedProfitsInfo` for that period will only show negative amounts for successfully burned tokens, creating an incomplete historical record.

**Operational Impact**: 
- No mechanism exists to retry failed burns for the same period since the period has already advanced
- Future profit distributions may inadvertently distribute tokens that should have been burned
- Silent failure means managers and users have no visibility into which tokens failed to burn
- Accounting discrepancies make it difficult to track actual vs. intended token burns

**Affected Parties**: All scheme beneficiaries and the protocol's token economics are affected, particularly when multi-token burns are intended for schemes managing diverse asset portfolios.

**Severity Justification**: Medium severity is appropriate because while this doesn't allow theft or unauthorized access, it violates the atomicity invariant of burn operations and creates persistent state inconsistencies that affect future operations and token supply tracking.

### Likelihood Explanation

**Reachable Entry Point**: The vulnerability is triggered through the public `DistributeProfits()` method, callable by the scheme manager or TokenHolder contract. [7](#0-6) 

**Feasible Preconditions**:
1. Scheme manager calls `DistributeProfits()` with explicit `AmountsMap` containing amounts greater than actual balances for some tokens
2. OR scheme has zero beneficiaries (`totalShares <= 0`) triggering automatic burn
3. OR manager explicitly sets `Period < 0` to force burning

**Execution Practicality**: This can occur naturally through:
- Manager miscalculating expected balances before calling `DistributeProfits()`
- Balances changing between calculation and execution due to other transactions
- Testing/development errors where explicit amounts are hardcoded incorrectly
- Multi-token schemes where tracking individual token balances becomes complex

**Detection Constraints**: The partial failure is silent with no events emitted or errors thrown, making it difficult to detect without manually querying balances before and after.

**Probability**: Medium-High probability in production environments managing multiple token types with explicit amount specifications, especially as scheme complexity increases.

### Recommendation

**Immediate Fix**: Add validation to ensure all tokens have sufficient balance before performing any burns, making the operation atomic (all-or-nothing):

```csharp
// Add before line 526: Pre-validate all balances
foreach (var profits in profitsMap)
{
    if (profits.Value > 0)
    {
        var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = scheme.VirtualAddress,
            Symbol = profits.Key
        }).Balance;
        Assert(balance >= profits.Value, 
            $"Insufficient balance to burn {profits.Key}: required {profits.Value}, available {balance}");
    }
}

// Then proceed with burns, removing the continue statement at line 538
```

**Alternative Approach**: If partial burns are intentionally desired, add proper tracking:
- Emit events for each skipped token
- Record failed burn attempts in `distributedProfitsInfo`
- Add a separate field to track partial vs. complete burn status
- Provide a mechanism to retry failed burns

**Invariant Check**: Add assertion that `distributedProfitsInfo.AmountsMap` contains entries for all tokens in `profitsMap` before saving state.

**Test Cases**: Add regression tests covering:
- Multi-token burn with one token having insufficient balance (should revert)
- Multi-token burn with all tokens having sufficient balance (should succeed completely)
- Explicit `AmountsMap` with values exceeding actual balances
- Verification that period does not advance on failed burns

### Proof of Concept

**Initial State**:
1. Create a scheme with `IsReleaseAllBalanceEveryTimeByDefault = false`
2. Contribute 1000 ELF and 300 USDT to the scheme
3. Scheme has zero beneficiaries (`totalShares = 0`)

**Attack Sequence**:
1. Manager calls `DistributeProfits()` with:
   - `SchemeId`: target scheme
   - `Period`: 1
   - `AmountsMap`: `{"ELF": 1000, "USDT": 500}`

**Expected vs Actual Result**:

**Expected**: Transaction should revert with "Insufficient balance" error since USDT balance (300) is less than requested burn amount (500).

**Actual**: 
- Transaction succeeds
- 1000 ELF is burned successfully
- USDT burn is silently skipped (300 USDT remains in scheme)
- Scheme's `CurrentPeriod` advances from 1 to 2
- `DistributedProfitsInfo` for period 1 shows: `{"ELF": -1000}` (no USDT entry)
- No error or event indicates partial failure

**Success Condition**: Query the scheme's token balances and period after transaction:
- ELF balance: 0 (burned)
- USDT balance: 300 (not burned, should be 0)
- CurrentPeriod: 2 (advanced despite partial failure)
- Token supply for ELF decreased by 1000, but USDT supply unchanged when it should have decreased

This demonstrates the inconsistent state where the operation completed partially without proper atomicity or error handling.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L426-428)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can distribute profits.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L433-445)
```csharp
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-486)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L520-520)
```csharp
        scheme.CurrentPeriod = period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L532-538)
```csharp
                var balanceOfToken = State.TokenContract.GetBalance.Call(new GetBalanceInput
                {
                    Owner = scheme.VirtualAddress,
                    Symbol = symbol
                });
                if (balanceOfToken.Balance < amount)
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L546-551)
```csharp
                State.TokenContract.Burn.Send(new BurnInput
                {
                    Amount = amount,
                    Symbol = symbol
                });
                distributedProfitsInfo.AmountsMap.Add(symbol, -amount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L555-557)
```csharp
        State.SchemeInfos[scheme.SchemeId] = scheme;
        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInfo;
        return new Empty();
```
