### Title
Insufficient Time Slot Validation Allows Zero Intervals Between Miners in Subsequent Pairs

### Summary
The `CheckRoundTimeSlots()` function validates that the first mining interval (between miners[0] and miners[1]) is positive, but subsequent miner pairs are only checked for relative difference from the base interval, not for being positive. This allows a malicious extra block producer to inject a Round where two or more miners have identical `ExpectedMiningTime` values (zero interval), violating the fundamental AEDPoS consensus property that each miner must have a distinct time slot.

### Finding Description

The vulnerability exists in the `CheckRoundTimeSlots()` method [1](#0-0) 

The function performs two validation steps:
1. Line 46-47: Validates that `baseMiningInterval <= 0` for the first pair (miners[1] - miners[0])
2. Lines 49-55: For subsequent pairs, only validates that `Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval`

The critical flaw is in the second check. If `baseMiningInterval = 1000ms` and a subsequent `miningInterval = 0` (two miners with identical `ExpectedMiningTime`):
- `Math.Abs(0 - 1000) = 1000`
- `1000 > 1000` evaluates to `false`
- Validation passes despite the zero interval

The check uses strict inequality (`>`) rather than greater-or-equal (`>=`), creating a boundary condition where intervals exactly equal to zero pass validation. Negative intervals generally fail because `|negative - positive| > positive` for most negative values, but zero specifically satisfies the boundary condition.

When a NextRound behavior is processed, the `TimeSlotValidationProvider` calls this function [2](#0-1) 

The provided Round data comes from the block's consensus extra data [3](#0-2) , which the extra block producer includes when triggering the NextRound transition. While honest nodes generate proper rounds via `GenerateNextRoundInformation` [4](#0-3) , a malicious miner can modify the Round data before including it in their block.

### Impact Explanation

**Consensus Integrity Violation**: Multiple miners would share the same `ExpectedMiningTime`, violating the core AEDPoS invariant that each miner must have a unique, isolated time slot for block production. This causes:

1. **Timing Conflicts**: Two or more miners would simultaneously believe it is their turn to produce blocks, leading to competing blocks at the same height
2. **Consensus Disruption**: The blockchain could fork as different nodes accept different miners' blocks, or blocks may be rejected due to timing validation failures
3. **Schedule Corruption**: Once the malicious round is accepted and stored [5](#0-4) , it becomes the active round information, affecting all subsequent block production until the next round transition

**Affected Parties**: All network participants are affected - honest miners cannot produce blocks reliably, validators see inconsistent state, and the entire chain's liveness is compromised.

**Severity**: Medium-High, as this directly breaks consensus time slot isolation, a critical invariant, though it requires the attacker to be the extra block producer.

### Likelihood Explanation

**Attacker Capabilities**: The attacker must be:
1. A current block producer (miner in the active round)
2. Specifically, the extra block producer who triggers the NextRound transition
3. Able to modify the consensus extra data before block submission

**Attack Complexity**: Low to Medium
- The attacker calls `GetConsensusBlockExtraData` to obtain the legitimate Round data [6](#0-5) 
- They modify the `ExpectedMiningTime` values to create zero intervals (e.g., set miners[2].ExpectedMiningTime = miners[1].ExpectedMiningTime)
- They include this modified Round in their block's consensus extra data
- The block passes validation because `CheckRoundTimeSlots()` has the boundary condition bug
- All nodes accept the malicious round since they all run the same validation logic

**Feasibility**: The attack is practically executable because:
- Extra block producers rotate deterministically, so any miner will eventually get the opportunity
- No cryptographic signatures protect the Round structure's integrity (signatures protect block authorship and randomness, not Round field values)
- The validation bug affects all nodes equally, so the malicious round would be universally accepted

**Detection**: The attack would be immediately visible as multiple miners attempt to produce blocks simultaneously, but by then the malicious round is already stored in state.

### Recommendation

**Code-Level Fix**: Modify the validation loop to explicitly check that all mining intervals are positive:

```csharp
for (var i = 1; i < miners.Count - 1; i++)
{
    var miningInterval =
        (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
    
    // Add explicit positive check
    if (miningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must be greater than 0 for all miner pairs.\n{this}" };
    
    if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
        return new ValidationResult { Message = "Time slots are so different." };
}
```

**Alternative Fix**: Change the inequality to be inclusive:
```csharp
if (Math.Abs(miningInterval - baseMiningInterval) >= baseMiningInterval)
```

However, the explicit positive check is clearer and more robust.

**Invariant Check**: Add assertion that all ExpectedMiningTime values are strictly increasing when ordered by miner Order.

**Test Cases**: Add regression tests covering:
1. Round with zero interval between miners[1] and miners[2] (should fail)
2. Round with zero interval between miners[n-2] and miners[n-1] (should fail)
3. Round with very small positive intervals (should pass if within tolerance)
4. Round with negative intervals (should fail)

### Proof of Concept

**Initial State**:
- Active round with 5 miners, miningInterval = 4000ms
- Miner A is the extra block producer for current round
- Miner A will trigger NextRound transition

**Attack Steps**:

1. Miner A produces the final block of the current round
2. Miner A calls `GetConsensusBlockExtraData` with `AElfConsensusBehaviour.NextRound`
3. Contract returns proper NextRound data with evenly spaced time slots:
   - miners[0].ExpectedMiningTime = T + 4000ms
   - miners[1].ExpectedMiningTime = T + 8000ms
   - miners[2].ExpectedMiningTime = T + 12000ms
   - miners[3].ExpectedMiningTime = T + 16000ms
   - miners[4].ExpectedMiningTime = T + 20000ms

4. **Malicious Modification**: Miner A modifies the Round before submitting:
   - miners[2].ExpectedMiningTime = T + 8000ms (same as miners[1])
   - All other values unchanged

5. Miner A includes this modified Round in the block's consensus extra data
6. Block is validated via `ValidateBeforeExecution` [7](#0-6) 
7. `CheckRoundTimeSlots()` executes:
   - baseMiningInterval = 8000 - 4000 = 4000ms ✓ (passes: 4000 > 0)
   - i=1: miningInterval = 8000 - 8000 = 0ms
     - `Math.Abs(0 - 4000) = 4000`
     - `4000 > 4000` = false ✓ (incorrectly passes!)
   - i=2: miningInterval = 12000 - 8000 = 4000ms ✓ (passes)
   - i=3: miningInterval = 16000 - 12000 = 4000ms ✓ (passes)

8. All validation passes, malicious round is stored
9. **Expected Result**: Validation should reject the round due to zero interval
10. **Actual Result**: Validation passes, miners[1] and miners[2] now have identical ExpectedMiningTime values

**Success Condition**: The malicious Round is accepted and stored in State.Rounds, causing miners[1] and miners[2] to both attempt block production at timestamp T + 8000ms, creating a consensus conflict.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L24-27)
```csharp
    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```
