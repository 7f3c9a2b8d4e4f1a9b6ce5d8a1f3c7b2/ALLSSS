# Audit Report

## Title
Unvalidated SupposedOrderOfNextRound Enables Consensus Denial of Service

## Summary
The AEDPoS consensus contract accepts `SupposedOrderOfNextRound` and `TuneOrderInformation` values from miner-submitted `UpdateValueInput` without validation. A malicious miner can inject invalid order values that corrupt the round state, causing `BreakContinuousMining()` to throw exceptions during next round generation, resulting in complete consensus halt.

## Finding Description

The vulnerability exists in the consensus update value processing flow where order information for the next round is accepted from miner input without proper validation.

**Missing Validation in UpdateValueValidationProvider:**
The validation provider for UpdateValue behavior only checks cryptographic fields (`OutValue`, `Signature`, `PreviousInValue`) but does not validate the `SupposedOrderOfNextRound` field or `TuneOrderInformation` map. [1](#0-0) 

**Direct Acceptance of Unvalidated Values:**
The `ProcessUpdateValue()` method directly assigns `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` from the input without any bounds checking or validity verification. [2](#0-1) 

Additionally, the method processes `TuneOrderInformation` to modify other miners' `FinalOrderOfNextRound` values without validation: [3](#0-2) 

**Correct Calculation in Normal Flow:**
The system correctly calculates `SupposedOrderOfNextRound` using the formula `GetAbsModulus(sigNum, minersCount) + 1` to ensure values are in the valid range [1, minersCount]: [4](#0-3) 

However, malicious miners can bypass this calculation by providing arbitrary values in their consensus extra data.

**Consensus Failure Mechanism:**
When `GenerateNextRoundInformation` constructs the next round, it relies on `FinalOrderOfNextRound` values to assign miner positions: [5](#0-4) 

Miners with `SupposedOrderOfNextRound == 0` are excluded from the "mined" list: [6](#0-5) 

The `BreakContinuousMining()` function then expects specific order positions to exist and uses `.First()` which throws `InvalidOperationException` if no matching element is found: [7](#0-6) 

If invalid order values result in missing Order == 1 or Order == 2 positions, the exception halts next round generation.

## Impact Explanation

**Severity: High** - Complete Consensus Denial of Service

This vulnerability enables a malicious miner to cause permanent consensus failure:

1. **Immediate Impact**: When invalid order values cause exceptions in `BreakContinuousMining()`, the next round cannot be generated, halting all block production
2. **Network-Wide Effect**: All nodes attempting to generate the next round will encounter the same exception due to corrupted state
3. **Persistence**: The corrupted round state persists in the blockchain state, requiring manual intervention or chain rollback to recover
4. **No Automatic Recovery**: Unlike temporary network issues, this corruption cannot self-heal as the invalid values are part of the consensus state

The attack compromises the fundamental availability guarantee of the blockchain - the ability to produce new blocks and process transactions.

## Likelihood Explanation

**Likelihood: Medium** - Requires Miner Access but Single-Actor Attack

While the attack requires the adversary to be an active block producer, it has relatively low complexity:

**Attacker Requirements:**
- Must be selected as an active miner in the current term (significant but achievable barrier)
- Ability to modify node software to inject malicious consensus data (moderate technical skill)
- No need for majority control or coordination with other miners

**Attack Execution:**
A malicious miner can craft consensus extra data with invalid `SupposedOrderOfNextRound` values when producing their block. The consensus system generates transactions automatically, but miners control what data goes into their block headers: [8](#0-7) 

The block will pass validation because the validation logic is insufficient: [9](#0-8) 

**Success Probability:**
Once a malicious miner submits a block with corrupted order data that passes validation, the attack succeeds deterministically. The corrupted state propagates to all nodes, and the next round generation will fail consistently across the network.

## Recommendation

**Implement Strict Validation of Order Values:**

Add validation to `UpdateValueValidationProvider` to verify that:
1. `SupposedOrderOfNextRound` is within the valid range [1, minersCount]
2. `SupposedOrderOfNextRound` matches the expected value calculated from the miner's signature: `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. `TuneOrderInformation` contains only valid order adjustments for miners with actual conflicts

**Recommended Fix:**

```csharp
public class UpdateValueValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };
        
        // NEW: Validate SupposedOrderOfNextRound
        if (!ValidateSupposedOrderOfNextRound(validationContext))
            return new ValidationResult { Message = "Invalid SupposedOrderOfNextRound value." };

        return new ValidationResult { Success = true };
    }
    
    private bool ValidateSupposedOrderOfNextRound(ConsensusValidationContext validationContext)
    {
        var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var minersCount = validationContext.BaseRound.RealTimeMinersInformation.Count;
        
        // Validate range
        if (minerInRound.SupposedOrderOfNextRound < 1 || 
            minerInRound.SupposedOrderOfNextRound > minersCount)
            return false;
        
        // Validate it matches the expected calculation
        if (minerInRound.Signature != null)
        {
            var sigNum = minerInRound.Signature.ToInt64();
            var expectedOrder = GetAbsModulus(sigNum, minersCount) + 1;
            if (minerInRound.SupposedOrderOfNextRound != expectedOrder)
                return false;
        }
        
        return true;
    }
    
    private static int GetAbsModulus(long longValue, int intValue)
    {
        return (int)Math.Abs(longValue % intValue);
    }
}
```

## Proof of Concept

**Attack Scenario:**

1. Malicious miner modifies their node to set `SupposedOrderOfNextRound = 1000` (out of valid range) when producing an UpdateValue block
2. The block passes `ValidateBeforeExecution` because `UpdateValueValidationProvider` doesn't check this field
3. `ProcessUpdateValue` stores the invalid value: `minerInRound.FinalOrderOfNextRound = 1000`
4. When the extra block producer attempts to generate NextRound, `GenerateNextRoundInformation` assigns `Order = 1000` to the malicious miner
5. Other miners fill orders 1 through N normally
6. `BreakContinuousMining` calls `.First(i => i.Order == 2)` but if order 2 is missing due to order assignment conflicts, it throws `InvalidOperationException: Sequence contains no matching element`
7. All nodes attempting to generate the next round encounter the same exception
8. Consensus halts - no new blocks can be produced

**Test Case Structure:**
```csharp
[Fact]
public async Task MaliciousSupposedOrderOfNextRound_CausesConsensusFailure()
{
    // 1. Setup: Initialize consensus with multiple miners
    // 2. Malicious miner produces UpdateValue with SupposedOrderOfNextRound = 999
    // 3. Verify block is accepted (validation doesn't catch it)
    // 4. Attempt to generate next round
    // 5. Assert: GenerateNextRoundInformation throws exception
    // 6. Assert: Consensus cannot progress to next round
}
```

The test would demonstrate that invalid order values bypass validation and cause consensus failure when the next round is generated.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L78-90)
```csharp
        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L61-75)
```csharp
    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```
