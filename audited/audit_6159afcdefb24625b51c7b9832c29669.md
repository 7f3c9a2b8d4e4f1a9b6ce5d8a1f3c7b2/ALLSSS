### Title
TokenHolder Lock-Beneficiary State Desynchronization Allows Capital Lockup Without Profit Accrual

### Summary
The `RemoveBeneficiary` function in TokenHolderContract can remove a user's beneficiary status from the profit scheme without unlocking their tokens, creating a state where users' capital remains locked but earns no profits. This violates the fundamental invariant that locked tokens in TokenHolder schemes should always be earning profit shares proportional to their locked amount.

### Finding Description

The vulnerability exists in the `RemoveBeneficiary` function which only removes profit scheme beneficiary status without synchronizing the token lock state. [1](#0-0) 

When a user calls `RegisterForProfits`, three state changes occur atomically:
1. Tokens are locked via the Token contract [2](#0-1) 

2. LockId mapping is stored [3](#0-2) 

3. User is added as beneficiary to profit scheme [4](#0-3) 

However, when the scheme manager calls `RemoveBeneficiary`, only the beneficiary status is removed from the Profit contract. The function does NOT:
- Unlock the tokens from the Token contract
- Remove the `State.LockIds` mapping
- Clear the `State.LockTimestamp` entry

The scheme is created with `CanRemoveBeneficiaryDirectly = true`, allowing immediate removal: [5](#0-4) 

In the Profit contract, this flag enables immediate beneficiary removal: [6](#0-5) 

Users cannot withdraw until the minimum lock period expires: [7](#0-6) 

The `Withdraw` function would succeed after the minimum period even if beneficiary was already removed, because ProfitContract.RemoveBeneficiary handles non-existent beneficiaries gracefully: [8](#0-7) 

### Impact Explanation

**Direct Financial Impact:**
- Users lose expected profit distributions during the lock period. If a scheme distributes 10% APY and tokens are locked for 30 days after RemoveBeneficiary is called, users lose ~0.83% of their locked capital value.
- Opportunity cost: Users cannot deploy capital elsewhere (staking, liquidity provision, trading) during forced lock period.

**Operational Impact:**
- Breaks the core TokenHolder contract invariant that locked tokens always earn proportional profit shares.
- Users experience forced capital lockup without compensation, undermining trust in the staking mechanism.

**Who is Affected:**
- Any user who has called `RegisterForProfits` and can be arbitrarily removed by the scheme manager before their minimum lock period expires.
- Particularly severe for schemes with long `MinimumLockMinutes` values.

**Severity Justification - Critical:**
- Violates fundamental lock/unlock correctness invariant
- Scheme managers have unilateral control without user consent
- Direct financial loss through missed profit distributions
- No cryptographic or economic barriers to exploitation

### Likelihood Explanation

**Attacker Capabilities:**
- Requires scheme manager privileges (realistic - all TokenHolder schemes have managers)
- Single function call execution with no additional preconditions
- No special timing requirements or complex state setup

**Attack Complexity:**
- Trivial: One transaction calling `RemoveBeneficiary(beneficiary=victim, amount=0)`
- Works against any registered user at any time

**Feasibility Conditions:**
- Scheme must exist (normal operation)
- User must be registered via `RegisterForProfits` (normal operation)
- Attacker is scheme manager (by design)

**Detection/Operational Constraints:**
- On-chain action is visible but may appear as legitimate scheme management
- Users have no warning or protection mechanism
- No timelock or governance delay

**Probability Reasoning:**
- Malicious manager: Direct attack vector with immediate execution
- Accidental/mistaken removal: Scheme managers may not realize tokens remain locked
- Either scenario results in the same harmful outcome

This is a high-probability vulnerability given the low barriers to exploitation and realistic attacker model.

### Recommendation

**Code-Level Mitigation:**

Add token unlocking logic to `RemoveBeneficiary`:

```csharp
public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // Check if beneficiary has locked tokens
    var lockId = State.LockIds[Context.Sender][input.Beneficiary];
    if (lockId != null)
    {
        // Get locked amount
        var lockedAmount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = input.Beneficiary,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;
        
        // Unlock tokens before removing beneficiary
        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address: input.Beneficiary,
            LockId = lockId,
            Amount = lockedAmount,
            Symbol = scheme.Symbol
        });
        
        // Clean up lock state
        State.LockIds[Context.Sender].Remove(input.Beneficiary);
        State.LockTimestamp.Remove(lockId);
    }
    
    // Existing beneficiary removal logic...
    var detail = State.ProfitContract.GetProfitDetails.Call(...);
    // ... rest of function
}
```

**Invariant Checks to Add:**

1. Before removing beneficiary, assert either:
   - No locked tokens exist for this beneficiary, OR
   - Tokens are being unlocked atomically in the same transaction

2. After `RemoveBeneficiary`, verify:
   - `State.LockIds[schemeManager][beneficiary]` is null
   - `State.ProfitDetailsMap[schemeId][beneficiary]` is null or empty
   - Token contract shows zero locked amount for the beneficiary under this scheme's lockId

**Test Cases to Prevent Regression:**

1. Test: Call `RemoveBeneficiary` on a user who called `RegisterForProfits` before minimum lock period expires
   - Verify tokens are unlocked
   - Verify lockId mapping is cleared
   - Verify beneficiary is removed from profit scheme

2. Test: Attempt to remove beneficiary who was added via `AddBeneficiary` (not via `RegisterForProfits`)
   - Should succeed without unlocking (no tokens were locked)
   - Verify only profit scheme state is modified

3. Test: User calls `Withdraw` after scheme manager called `RemoveBeneficiary`
   - Should succeed without errors (idempotent beneficiary removal)
   - Verify user receives their tokens

### Proof of Concept

**Required Initial State:**
- TokenHolder scheme exists with manager address M
- User U has approved TokenHolder contract and has 1000 ELF tokens
- Scheme has `MinimumLockMinutes = 1440` (1 day lock period)

**Transaction Steps:**

1. User U calls `RegisterForProfits`:
   ```
   RegisterForProfits(schemeManager=M, amount=1000)
   ```
   - Result: 1000 ELF locked, U added as beneficiary with 1000 shares
   - State: `LockIds[M][U] = lockId`, `ProfitDetailsMap[schemeId][U] = {shares: 1000}`

2. Immediately after (same day), Manager M calls `RemoveBeneficiary`:
   ```
   RemoveBeneficiary(beneficiary=U, amount=0)
   ```
   - Result: U removed from profit scheme
   - State: `LockIds[M][U] = lockId` (STILL EXISTS), `ProfitDetailsMap[schemeId][U] = null`
   - Tokens: 1000 ELF STILL LOCKED in Token contract

3. User U attempts to withdraw:
   ```
   Withdraw(schemeManager=M)
   ```
   - Result: Transaction FAILS with "Cannot withdraw" because minimum lock time hasn't passed
   - User U's tokens remain locked for remaining ~24 hours

4. During the 24-hour period between steps 2-4:
   - If scheme distributes profits, U receives NONE (not a beneficiary)
   - U cannot use the 1000 ELF for any other purpose (locked)
   - Expected loss: ~0.27% if scheme yields 10% APY

**Expected vs Actual Result:**
- **Expected:** RemoveBeneficiary should unlock tokens OR fail if tokens are locked
- **Actual:** RemoveBeneficiary succeeds but leaves tokens locked without profit accrual

**Success Condition for Vulnerability:**
After step 2, verify:
1. `State.LockIds[M][U]` returns a non-null lockId
2. Token contract shows 1000 ELF locked for user U under the lockId
3. `State.ProfitDetailsMap[schemeId][U]` returns null or empty (no profit details)
4. User U cannot claim any profits distributed after step 2

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-165)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L166-167)
```csharp
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L168-176)
```csharp
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L233-235)
```csharp
        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```
