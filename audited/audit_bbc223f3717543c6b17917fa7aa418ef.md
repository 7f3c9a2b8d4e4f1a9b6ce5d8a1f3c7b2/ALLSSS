# Audit Report

## Title
Duplicate Mining Order Validation Bypass Allows Consensus Disruption

## Summary
The `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` method incorrectly uses `Distinct()` on entire `MinerInRound` objects instead of on `FinalOrderOfNextRound` values, allowing a malicious miner to inject duplicate mining orders that bypass validation and corrupt the consensus state, causing multiple miners to receive identical time slots in subsequent rounds and disrupting blockchain progression.

## Finding Description

The validation logic attempts to verify that miners who produced blocks have determined unique next round orders. [1](#0-0) 

However, `Distinct()` operates on entire `MinerInRound` protobuf objects containing 17 fields (pubkey, order, expected_mining_time, produced_blocks, in_value, out_value, signature, etc.). [2](#0-1) 

Protobuf-generated C# classes implement `Equals()` and `GetHashCode()` comparing all fields. Therefore, two miners with identical `FinalOrderOfNextRound` values but different `Pubkey` fields are considered distinct by `Distinct()`, allowing the validation to pass incorrectly.

**Evidence of Design Intent:**

The codebase explicitly handles `FinalOrderOfNextRound` conflicts during normal consensus data updates, proving the system requires unique order values: [3](#0-2) 

This conflict resolution mechanism reassigns miners when duplicates are detected, confirming that duplicate `FinalOrderOfNextRound` values violate the consensus invariant.

**Exploitation Path:**

1. The validation provider is registered during NextRound behavior transitions: [4](#0-3) 

2. A malicious miner (any active miner can call NextRound) produces a block with consensus extra data containing duplicate `FinalOrderOfNextRound` values across different miner entries

3. The flawed validation passes because `Distinct()` sees different objects (different pubkeys)

4. The corrupt round data is persisted to blockchain state: [5](#0-4) 

5. During next round generation, each miner's `FinalOrderOfNextRound` is directly assigned as their `Order` in the new round: [6](#0-5) 

6. Multiple miners receive identical `Order` and `ExpectedMiningTime` values

7. The logic for calculating available orders uses `Contains()` which only checks membership, not counting duplicate occurrences: [7](#0-6) 

**Consensus Breakdown:**

Once duplicate orders exist, miners with the same order attempt to mine simultaneously. Time slot validation relies on unique orders per miner. [8](#0-7) 

Extra block producer selection becomes ambiguous when using `FirstOrDefault()` on an order that maps to multiple miners. [9](#0-8) 

## Impact Explanation

**Critical Consensus Violation:**
- Multiple miners receive identical mining time slots, creating competing blocks at the same height
- Extra block producer selection fails when multiple miners share the designated order
- Round progression halts as the scheduling invariant (unique order per miner) is violated
- Chain experiences persistent forking or complete stall

**Network-Wide Effects:**
- All network participants cannot achieve consensus on block production sequence
- Transaction finality is compromised due to competing blocks
- dApp functionality and user transactions fail
- Manual intervention required to restore consensus state

This breaks the fundamental "Correct round transitions and miner schedule integrity" invariant required for AEDPoS consensus operation.

## Likelihood Explanation

**Attacker Profile:**
- Must be an active miner (obtainable through staking and election)
- No special privileges required beyond normal miner capabilities
- Can execute during any NextRound transition when scheduled

**Attack Simplicity:**
- Single transaction with crafted `NextRoundInput` containing duplicate `FinalOrderOfNextRound` values
- No timing dependencies or complex state manipulation
- Deterministic success due to validation flaw

**Operational Feasibility:**
- The NextRound method is publicly accessible: [10](#0-9) 
- Permission check only requires being in the miner list: [11](#0-10) 
- No rate limiting or additional duplicate-detection mechanisms exist beyond the flawed validation

**Likelihood: High** - Any miner can execute this attack with trivial effort and guaranteed success.

## Recommendation

Modify the validation to check for distinct `FinalOrderOfNextRound` values rather than distinct objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Extract just the order value
    .Distinct()
    .Count();
```

This ensures the validation correctly detects duplicate order values regardless of other field differences between miner objects.

## Proof of Concept

```csharp
[Fact]
public void DuplicateFinalOrderOfNextRound_ShouldFailValidation()
{
    // Setup: Create a round with miners having duplicate FinalOrderOfNextRound
    var round = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation = 
        {
            ["miner1"] = new MinerInRound 
            { 
                Pubkey = "miner1",
                FinalOrderOfNextRound = 3,
                OutValue = Hash.FromString("test1")
            },
            ["miner2"] = new MinerInRound 
            { 
                Pubkey = "miner2",
                FinalOrderOfNextRound = 3,  // DUPLICATE ORDER
                OutValue = Hash.FromString("test2")
            },
            ["miner3"] = new MinerInRound 
            { 
                Pubkey = "miner3",
                FinalOrderOfNextRound = 1,
                OutValue = Hash.FromString("test3")
            }
        }
    };
    
    var context = new ConsensusValidationContext 
    { 
        ProvidedRound = round 
    };
    
    var provider = new NextRoundMiningOrderValidationProvider();
    var result = provider.ValidateHeaderInformation(context);
    
    // Current buggy behavior: validation passes despite duplicates
    Assert.True(result.Success);  // BUG: Should be False
    
    // After fix: should fail
    // Assert.False(result.Success);
    // Assert.Contains("duplicate", result.Message.ToLower());
}
```

**Notes:**

The vulnerability is confirmed valid through complete code path tracing. The protobuf equality semantics, validation logic, round generation logic, and state persistence flow all confirm the exploit path. The existence of explicit conflict resolution in `ApplyNormalConsensusData` proves the design intent that `FinalOrderOfNextRound` values must be unique, yet the validation fails to enforce this requirement for externally-provided NextRound data.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** protobuf/aedpos_contract.proto (L266-300)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L23-40)
```csharp
        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-156)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-41)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L60-65)
```csharp
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
