# Audit Report

## Title
Missing Per-Round Block Production Limit Validation in Consensus System

## Summary
The AEDPoS consensus validation system fails to enforce per-round block production limits during validation. While the limit check exists in command generation logic, no validator verifies if a miner has exceeded their allowed `ActualMiningTimes.Count` based on `_maximumBlocksCount`. This allows malicious miners to bypass honest command generation and directly submit blocks exceeding their round allocation, particularly extra block producers with multiple time slots.

## Finding Description

The vulnerability exists in the validation architecture where block production limits are enforced only during honest command generation but not during validation before execution.

**The Missing Check:**

In `ConsensusBehaviourProviderBase.GetConsensusBehaviour()`, the limit is enforced during command generation: [1](#0-0) 

For extra block producers with two time slots, there's an extended limit: [2](#0-1) 

**However, during validation:**

The `ValidateBeforeExecution` method instantiates validators: [3](#0-2) 

None of these validators check `ActualMiningTimes.Count` against maximum limits:

- `MiningPermissionValidationProvider` only checks miner list membership: [4](#0-3) 

- `ContinuousBlocksValidationProvider` checks continuous blocks across miners (via `LatestPubkeyToTinyBlocksCount`), not per-round per-miner limits: [5](#0-4) 

**Exploitation Path:**

A malicious miner can directly call the public entry point: [6](#0-5) 

This processes through `ProcessTinyBlock`, which unconditionally adds the mining time: [7](#0-6) 

The maximum blocks count constant is: [8](#0-7) 

## Impact Explanation

**Consensus Integrity Violation:** The AEDPoS consensus mechanism assumes bounded block production per miner per round. By exceeding these limits, a malicious miner undermines the fairness guarantees where each participant has equal production capacity within their time slots.

**Mining Reward Misallocation:** Each block produced generates mining rewards. With the default limit of 8 blocks per time slot, and extra block producers having two slots (previous round's extra slot + current round's normal slot), the intended maximum is approximately 16 blocks per round. A malicious extra block producer could produce significantly more blocks, extracting additional rewards not allocated to them by the protocol's economic model.

**Block Production Monopolization:** By producing excessive blocks within their time slots, a malicious miner reduces the effective time available for other miners and can dominate block production, centralizing control within the consensus round.

## Likelihood Explanation

**Reachable Entry Point:** The `UpdateTinyBlockInformation` method is a public consensus contract method callable by any active miner. No special privileges beyond being in the current miner list are required.

**Low Attack Complexity:** The exploit requires only submitting additional `TinyBlockInput` transactions beyond the intended limit. The attacker doesn't need to compromise cryptographic primitives, bypass signature validation, or manipulate state in complex ways.

**Feasible Preconditions:** The attacker must be an active miner in the current round, which is a realistic capability for consensus participants. Election and staking mechanisms make this achievable for motivated attackers.

**Detection Challenges:** Since blocks are validated individually and the validation system doesn't check cumulative counts, detecting this attack requires external monitoring systems to track per-miner `ActualMiningTimes.Count` across the round, which may not be immediately apparent to honest nodes.

## Recommendation

Add a new validation provider that enforces per-round block production limits:

```csharp
public class BlockProductionLimitValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var maximumBlocksCount = GetMaximumBlocksCount(); // Get current limit
        
        // Check basic limit
        if (minerInRound.ActualMiningTimes.Count >= maximumBlocksCount)
        {
            // Check if extra block producer with extended limit
            var isExtraBlockProducer = validationContext.BaseRound.ExtraBlockProducerOfPreviousRound == validationContext.SenderPubkey;
            if (!isExtraBlockProducer || validationContext.BaseRound.IsMinerListJustChanged)
            {
                validationResult.Message = "Miner exceeded block production limit for current round.";
                return validationResult;
            }
            
            var blocksBeforeCurrentRound = minerInRound.ActualMiningTimes
                .Count(t => t <= validationContext.BaseRound.GetRoundStartTime());
            var extendedLimit = maximumBlocksCount + blocksBeforeCurrentRound;
            
            if (minerInRound.ActualMiningTimes.Count >= extendedLimit)
            {
                validationResult.Message = "Extra block producer exceeded extended limit for current round.";
                return validationResult;
            }
        }
        
        validationResult.Success = true;
        return validationResult;
    }
}
```

Then add this provider to the validation list in `ValidateBeforeExecution` for `TinyBlock` behavior:

```csharp
if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
{
    validationProviders.Add(new BlockProductionLimitValidationProvider());
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanExceedBlockProductionLimit()
{
    // Setup: Initialize consensus with a miner
    var miner = SampleAccount.Accounts.First();
    var maximumBlocksCount = 8; // AEDPoSContractConstants.MaximumTinyBlocksCount
    
    // Get current round
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Produce blocks exceeding the limit
    for (int i = 0; i < maximumBlocksCount + 5; i++) // Produce 13 blocks (exceeds limit of 8)
    {
        var tinyBlockInput = new TinyBlockInput
        {
            ActualMiningTime = TimestampHelper.GetUtcNow(),
            ProducedBlocks = i + 1,
            RoundId = currentRound.RoundIdForValidation,
            RandomNumber = HashHelper.ComputeFrom(i.ToString()).ToByteString()
        };
        
        // This should fail after 8 blocks but doesn't due to missing validation
        await ConsensusStub.UpdateTinyBlockInformation.SendAsync(tinyBlockInput);
    }
    
    // Verify: Check ActualMiningTimes count exceeds limit
    var updatedRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    var minerInfo = updatedRound.RealTimeMinersInformation[miner.PublicKey.ToHex()];
    
    // This assertion passes, proving the vulnerability
    Assert.True(minerInfo.ActualMiningTimes.Count > maximumBlocksCount);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-62)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L71-79)
```csharp
                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L65-75)
```csharp
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L108-112)
```csharp
    public override Empty UpdateTinyBlockInformation(TinyBlockInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
