### Title
Sponsor Can Manipulate Voting Outcomes Through Unrestricted Option Modification During Active Voting

### Summary
The Vote contract allows sponsors to add or remove voting options at any time without validating whether voting is active or votes have been cast. This enables sponsors to collude with voters by adding new options mid-vote or invalidate existing votes by removing options, directly undermining the integrity of the voting process and enabling manipulation of voting outcomes.

### Finding Description

The option modification methods `AddOption`, `RemoveOption`, `AddOptions`, and `RemoveOptions` only verify sponsor authorization but lack critical timing and state validations. [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) 

While voting items contain `StartTimestamp` and `EndTimestamp` fields to define the voting period [5](#0-4) , none of the option modification methods validate against these timestamps or check whether votes have been cast.

The `Vote` method enforces that voters can only vote for options that currently exist in `votingItem.Options` [6](#0-5) . This creates an exploitable inconsistency window where sponsors can modify options while voting is ongoing.

When votes are cast, they are stored in `VotingResult.Results` mapping by option name [7](#0-6) . If a sponsor removes an option after votes have been cast for it, those votes remain in the results map but the option is removed from the visible options list, effectively invalidating those votes while still counting toward total vote amounts.

### Impact Explanation

**Governance Manipulation**: The sponsor can directly manipulate voting outcomes through two primary attack vectors:

1. **Late Option Addition for Collusion**: After honest voters have cast their votes for existing options, the sponsor can add a new option and coordinate with colluding voters to vote for it. Honest voters who voted earlier have no knowledge of this new option and cannot adjust their votes.

2. **Vote Invalidation via Option Removal**: The sponsor can remove options that are winning or have received significant votes. While the votes remain in the underlying results data structure, the option is removed from the visible options list retrieved via `GetVotingItem` [8](#0-7) , effectively hiding those votes and preventing new voters from selecting that option.

**Affected Parties**: All voters are affected as their voting decisions can be retroactively invalidated or rendered meaningless through sponsor manipulation. The integrity of any governance decision relying on this voting system is compromised.

**Severity**: HIGH - This directly undermines the fundamental purpose of the voting system (fair and transparent democratic decision-making) and enables systematic manipulation of governance outcomes.

### Likelihood Explanation

**Attacker Capabilities**: The sponsor role is a standard participant who creates voting items [9](#0-8) . No special privileges beyond sponsor status are required.

**Attack Complexity**: LOW - The exploit requires only calling public methods (`AddOption`, `RemoveOption`, `AddOptions`, `RemoveOptions`) with standard transaction costs. No complex setup or timing precision is needed.

**Execution Practicality**: The attack is fully executable within AElf contract semantics using standard method calls. The option modification methods are public entry points [10](#0-9) [11](#0-10) .

**Detection Constraints**: There are no events emitted when options are modified, making it difficult for voters to detect mid-vote manipulation unless they continuously monitor the voting item state.

**Economic Rationality**: The cost is minimal (standard transaction fees), while the benefit is potentially enormous (controlling governance decisions, election outcomes, or other vote-dependent processes).

### Recommendation

**Add Temporal and State Validations**:

Modify all option modification methods to include the following checks:

```csharp
// In AddOption, RemoveOption, AddOptions, RemoveOptions
Assert(Context.CurrentBlockTime < votingItem.StartTimestamp, 
    "Cannot modify options after voting has started.");
```

Alternatively, if options need to be modifiable during voting for legitimate reasons, implement a more nuanced approach:

```csharp
// Check if any votes have been cast
var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
var votingResult = State.VotingResults[votingResultHash];
Assert(votingResult.VotesAmount == 0, 
    "Cannot modify options after votes have been cast.");
```

**Add Event Emission**:
Emit events when options are added or removed so voters can be alerted to changes:

```csharp
Context.Fire(new OptionModified
{
    VotingItemId = votingItem.VotingItemId,
    ModificationType = "Added/Removed",
    Option = input.Option,
    Timestamp = Context.CurrentBlockTime
});
```

**Add Regression Tests**:
Create test cases that verify:
- Options cannot be added after `StartTimestamp`
- Options cannot be removed after votes have been cast
- Attempting to modify options mid-vote fails with appropriate error messages

### Proof of Concept

**Initial State**:
1. Sponsor creates voting item with `StartTimestamp = T1`, `EndTimestamp = T10`, `Options = ["A", "B", "C"]`

**Attack Sequence 1 - Late Option Addition**:
1. At T2 (after voting started), 100 honest voters vote for option "A", 50 for "B", 30 for "C"
2. At T3, sponsor observes results and calls `AddOption` to add option "D" (bypasses all checks at line 283)
3. Sponsor coordinates with 150 colluding voters who vote for "D"
4. Final results: "D" has 150 votes, "A" has 100 votes
5. **Expected**: Option modification should fail after `StartTimestamp`
6. **Actual**: Option "D" is successfully added and receives votes, manipulating the outcome

**Attack Sequence 2 - Vote Invalidation**:
1. Voters cast 200 votes for "A", 50 for "B", 30 for "C"
2. Sponsor sees "A" is winning and calls `RemoveOption` for option "A" (bypasses checks at line 306)
3. The 200 votes remain in `VotingResult.Results["A"]` but option "A" is removed from `votingItem.Options`
4. New voters cannot vote for "A" (blocked by check at line 381)
5. Querying `GetVotingItem` shows only options ["B", "C"], hiding the 200 votes for "A"
6. **Expected**: Option removal should fail when votes exist for that option
7. **Actual**: Option "A" is removed, effectively invalidating 200 votes while they still count toward `VotesAmount`

**Success Condition**: Both attack sequences succeed without any validation errors, demonstrating the sponsor's ability to manipulate voting outcomes through unrestricted option modification.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L39-39)
```csharp
            Sponsor = Context.Sender,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L46-47)
```csharp
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L174-180)
```csharp
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-280)
```csharp
    public override Empty AddOption(AddOptionInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L283-283)
```csharp
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L303-303)
```csharp
    public override Empty RemoveOption(RemoveOptionInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L306-306)
```csharp
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L317-317)
```csharp
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L329-329)
```csharp
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L381-381)
```csharp
        Assert(votingItem.Options.Contains(input.Option), $"Option {input.Option} not found.");
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L27-31)
```csharp
    public override VotingItem GetVotingItem(GetVotingItemInput input)
    {
        var votingEvent = State.VotingItems[input.VotingItemId];
        Assert(votingEvent != null, "Voting item not found.");
        return votingEvent;
```
