### Title
Missing Validation of NextTerm Round State Allows Consensus Manipulation

### Summary
The `ProcessNextTerm` function accepts `NextTermInput` and directly commits the round data from `ToRound()` without validating it matches the expected new term state derived from election results. Validation only checks that round and term numbers increment by 1, but does not verify the miner list, mining order, expected mining times, or other critical round fields match what should be generated for the new term. This allows a malicious block producer to inject arbitrary consensus state during term transitions.

### Finding Description

The vulnerability exists in the NextTerm consensus flow where round data is committed without content validation: [1](#0-0) 

At line 163, `ProcessNextTerm` calls `input.ToRound()` which simply copies all fields from the input: [2](#0-1) 

The validation that occurs before execution only checks numerical increments: [3](#0-2) [4](#0-3) 

The `ValidationForNextTerm` only validates that `TermNumber` equals `BaseRound.TermNumber + 1` and calls `ValidationForNextRound` which checks `RoundNumber` increments and `InValue` fields are null. It does NOT validate:
- Miner list matches election results from `TryToGetVictories()`
- Miner order follows the deterministic sorting in `GenerateFirstRoundOfNewTerm()`
- Expected mining times are correctly calculated
- Other round fields match expected state

The expected round generation happens in: [5](#0-4) [6](#0-5) 

However, validating nodes never independently regenerate this expected round to compare against the input. The miner list is blindly accepted and committed: [7](#0-6) 

### Impact Explanation

**Consensus Integrity Violation (HIGH)**: A malicious miner producing a NextTerm block can manipulate critical consensus state including:
- **Miner List**: Add/remove miners arbitrarily, bypassing election results
- **Mining Order**: Place themselves or colluding miners in favorable positions
- **Expected Mining Times**: Allocate more time slots to preferred miners
- **Block Production Rights**: Alter which miners can produce blocks in the new term

This breaks the fundamental security property that consensus state reflects legitimate election results. An attacker could:
- Gain disproportionate block production rights (revenue manipulation)
- Exclude legitimate miners (censorship/DoS)
- Establish control over future term transitions (persistent attack)
- Violate the decentralization guarantee of the consensus mechanism

The impact persists until the next term transition by an honest miner, potentially lasting for an entire term period (configured by `State.PeriodSeconds.Value`).

### Likelihood Explanation

**Attack Requirements**:
- Attacker must be an active miner in the current term
- Attacker must win the right to produce the NextTerm extra block (occurs when round terminates)
- Attacker runs modified consensus contract code that manipulates `GetConsensusExtraDataForNextTerm` output

**Attack Complexity**: MEDIUM
- Requires code modification on attacker's node to return manipulated round data
- No protocol-level cryptographic barriers prevent this
- Existing validation is insufficient to detect the manipulation

**Feasibility**: The attack is practical because:
1. NextTerm blocks occur regularly (every term period)
2. Any active miner has chance to produce the NextTerm block
3. Modified contract code can arbitrarily alter the round data returned by `GenerateFirstRoundOfNextTerm`
4. Honest validators will accept the manipulated block since they only check number increments

**Detection**: The manipulation would be detectable off-chain by comparing committed miner list against election contract state, but no on-chain validation prevents it.

### Recommendation

**Immediate Fix**: Add validation in `ProcessNextTerm` that regenerates the expected round and compares it with the input:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // ADDED: Validate round matches expected state
    var expectedRound = GenerateFirstRoundOfNextTerm(
        Context.RecoverPublicKey().ToHex(), 
        State.MiningInterval.Value
    );
    
    // Validate critical fields match
    Assert(expectedRound.TermNumber == nextRound.TermNumber, 
        "Term number mismatch");
    Assert(expectedRound.RoundNumber == nextRound.RoundNumber, 
        "Round number mismatch");
    Assert(expectedRound.RealTimeMinersInformation.Count == 
        nextRound.RealTimeMinersInformation.Count, 
        "Miner count mismatch");
    
    // Validate miner list matches
    var expectedMiners = expectedRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var actualMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    Assert(expectedMiners.SequenceEqual(actualMiners), 
        "Miner list mismatch with election results");
    
    // Continue with existing logic...
    RecordMinedMinerListOfCurrentRound();
    // ...
}
```

**Alternative Fix**: Add the validation in `ValidateBeforeExecution` by extending `RoundTerminateValidationProvider.ValidationForNextTerm` to perform the same comparison.

**Invariant to Enforce**: NextTerm round state must be deterministically derived from current election contract state and verifiable by all validators.

**Test Cases**:
1. Test that NextTerm with manipulated miner list is rejected
2. Test that NextTerm with manipulated mining order is rejected  
3. Test that NextTerm with manipulated timing is rejected
4. Test that legitimate NextTerm from election results is accepted

### Proof of Concept

**Initial State**:
- Current term has miners [A, B, C] based on election
- Next term election results show miners [D, E, F] should win
- Malicious miner A produces the NextTerm extra block

**Attack Steps**:
1. Miner A modifies their node's `GetConsensusExtraDataForNextTerm` to return manipulated round:
   - Instead of election winners [D, E, F], return [A, B, G]
   - Place A first in mining order
   
2. Miner A produces NextTerm block with this manipulated round data in consensus extra data

3. Honest validators receive the block and call `ValidateConsensusBeforeExecution`:
   - `RoundTerminateValidationProvider` checks only that TermNumber = CurrentTerm + 1 ✓
   - Checks RoundNumber increments correctly ✓
   - Does NOT check miner list matches election results
   - Validation passes

4. Block is executed, `ProcessNextTerm` is called:
   - Converts input to round via `ToRound()` (no validation)
   - Updates term/round numbers
   - Commits manipulated miner list [A, B, G] to state at line 190
   - Stores manipulated round information at line 196

**Result**: 
- Expected: New term uses election winners [D, E, F]
- Actual: New term uses manipulated list [A, B, G]
- Success Condition: `State.MinerListMap[newTermNumber]` contains manipulated miners instead of election results

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```
