### Title
Side Chain Disposal Returns Funds to Proposer Without Paying Indexer Debt

### Summary
When a side chain is disposed via `DisposeSideChain()`, the `UnlockTokenAndResource()` function returns all remaining deposited tokens to the original proposer without checking or paying outstanding arrears owed to indexers. This allows indexers who provided indexing services during periods of insufficient balance to lose their earned fees, while the proposer recovers funds that should rightfully go to creditors. Additionally, `GetSideChainBalance()` returns gross deposit balance without accounting for debt, potentially misleading governance during disposal decisions.

### Finding Description

The vulnerability exists in two related components:

**Primary Issue - Unpaid Debt During Disposal:** [1](#0-0) 

The `UnlockTokenAndResource()` function retrieves the deposit balance and transfers the entire amount to the side chain proposer. It does not check the `ArrearsInfo` field in `SideChainInfo`, which tracks debt owed to indexers who continued indexing when the deposit was insufficient. [2](#0-1) 

When `DisposeSideChain()` is called, it only validates that the chain status is not already `Terminated`, then immediately calls `UnlockTokenAndResource()` without any debt verification.

**Debt Accumulation Mechanism:** [3](#0-2) 

When indexing occurs and the deposit is exhausted, the contract continues to allow indexing but records the unpaid fees in `ArrearsInfo` (mapping proposer addresses to owed amounts) and sets the chain status to `IndexingFeeDebt`. These arrears should be paid to indexers before any funds are returned to the proposer.

**Secondary Issue - Misleading Balance Information:** [4](#0-3) 

The `GetSideChainBalance()` view function returns only the deposit amount without subtracting debt. [5](#0-4) 

While `GetSideChainIndexingFeeDebt()` separately returns the total arrears, the balance view does not present the net position (deposit minus debt), potentially misleading governance or users about the chain's true solvency.

**Why Existing Protections Fail:**

The `Recharge()` function does properly handle debt: [6](#0-5) 

It pays arrears to creditors before allowing normal operations to resume. However, this protection only applies when `Recharge()` is called - the disposal flow completely bypasses this debt settlement mechanism.

### Impact Explanation

**Direct Financial Loss to Indexers:**
- Indexers who provided cross-chain indexing services during periods when the side chain had insufficient deposits are owed fees recorded in `ArrearsInfo`
- When the chain is disposed, these creditors never receive payment despite having performed the service
- This represents direct theft of earned fees from service providers

**Benefit to Proposer:**
- The original side chain proposer recovers any remaining deposited funds even though those funds should first be used to pay outstanding debt
- This creates a perverse incentive where proposers can allow chains to accumulate debt and then dispose them to recover deposits

**Magnitude:**
- The amount at risk equals the minimum of: (remaining deposit balance) or (total arrears owed)
- In cases where recharge occurred after debt accumulation but disposal happened before proper settlement, the full arrears amount could be lost
- Severity: **HIGH** - Direct misallocation of funds from legitimate creditors to the proposer

### Likelihood Explanation

**Entry Point:** `DisposeSideChain()` is a public function callable by the SideChainLifetimeController (typically Parliament governance organization).

**Preconditions:**
1. A side chain exists with recorded arrears in `ArrearsInfo` (achievable by indexing beyond available deposit)
2. The chain has some remaining balance (from partial recharge, direct transfers, or remaining initial deposit)
3. Governance approves disposal proposal (routine operational activity)

**Exploitation Scenarios:**

*Malicious:* A proposer could intentionally create a side chain with minimal deposit, allow indexing to accumulate large debt, add some funds back to the virtual address, then lobby for disposal through governance to recover funds while leaving indexers unpaid.

*Accidental:* More likely, during legitimate chain lifecycle management, governance may approve disposal of inactive or problematic chains without realizing unpaid debt exists, especially since `GetSideChainBalance()` shows a misleading gross balance figure.

**Attack Complexity:** Low - The vulnerability is in the core disposal logic and triggers automatically when any chain with debt is disposed.

**Economic Feasibility:** The exploit requires only standard token operations and governance participation. No sophisticated attack vectors are needed.

**Detection Difficulty:** High - The debt information (`ArrearsInfo`) is stored in state but not prominently surfaced during disposal decisions. Governance would need to separately query `GetSideChainIndexingFeeDebt()` to know debt exists.

**Likelihood Assessment:** MEDIUM-HIGH - While it requires governance approval (reducing malicious likelihood), the lack of on-chain validation means accidental occurrences are probable during routine chain lifecycle management.

### Recommendation

**Fix 1: Pay Arrears Before Returning Funds in UnlockTokenAndResource()**

Modify `UnlockTokenAndResource()` in `CrossChainContract_Helper.cs`:

```
private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
{
    var chainId = sideChainInfo.SideChainId;
    var balance = GetSideChainIndexingFeeDeposit(chainId);
    if (balance <= 0)
        return;
    
    // NEW: Pay arrears first
    long arrearsAmount = 0;
    foreach (var arrears in sideChainInfo.ArrearsInfo)
    {
        arrearsAmount += arrears.Value;
        if (balance >= arrears.Value)
        {
            TransferDepositToken(new TransferInput
            {
                To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                Symbol = Context.Variables.NativeSymbol,
                Amount = arrears.Value,
                Memo = "Arrears payment on disposal."
            }, chainId);
            balance -= arrears.Value;
        }
    }
    
    // Return remaining balance to proposer
    if (balance > 0)
    {
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
}
```

**Fix 2: Add Debt Check in DisposeSideChain()**

Add validation in `DisposeSideChain()` to prevent disposal with unpaid debt:

```
Assert(info.ArrearsInfo.Count == 0 || GetSideChainIndexingFeeDeposit(chainId) == 0,
    "Cannot dispose chain with unpaid arrears. Recharge to settle debt first.");
```

**Fix 3: Correct GetSideChainBalance() to Return Net Position**

Modify `GetSideChainBalance()` to return net balance:

```
public override Int64Value GetSideChainBalance(Int32Value input)
{
    var chainId = input.Value;
    var sideChainInfo = State.SideChainInfo[chainId];
    Assert(sideChainInfo != null, "Side chain not found.");
    
    var deposit = GetSideChainIndexingFeeDeposit(chainId);
    var debt = sideChainInfo.ArrearsInfo.Values.Sum();
    var netBalance = deposit - debt;
    
    return new Int64Value { Value = Math.Max(0, netBalance) };
}
```

**Testing Requirements:**
1. Test disposal of chain with arrears confirms debt payment to creditors
2. Test disposal of chain with arrears exceeding balance
3. Test that `GetSideChainBalance()` correctly reflects net position
4. Test prevention of disposal with unpaid debt (if using Fix 2)

### Proof of Concept

**Initial State:**
- Side chain created with deposit of 10 tokens, indexing price = 1 token per block
- Chain ID = X, Proposer = Alice

**Step 1: Exhaust Deposit and Create Debt**
- Index 12 blocks through normal `ReleaseCrossChainIndexingProposal` flow
- First 10 blocks consume the 10 token deposit
- Blocks 11-12 create debt of 2 tokens owed to indexer Bob
- `SideChainInfo[X].ArrearsInfo["Bob"] = 2`
- `SideChainInfo[X].SideChainStatus = IndexingFeeDebt`

**Step 2: Add Balance Without Proper Recharge**
- Someone transfers 5 tokens directly to the virtual address: `Context.ConvertVirtualAddressToContractAddress(HashHelper.ComputeFrom(X))`
- Deposit balance = 5 tokens
- Arrears still = 2 tokens (not automatically cleared)

**Step 3: Dispose Chain**
- Governance approves and executes: `DisposeSideChain(X)`
- `UnlockTokenAndResource()` is called
- Gets balance = 5 tokens
- Transfers all 5 tokens to Alice (proposer)

**Expected Result:**
- 2 tokens paid to Bob (creditor)
- 3 tokens returned to Alice (proposer)

**Actual Result:**
- 0 tokens paid to Bob (creditor loses earned fees)
- 5 tokens returned to Alice (proposer receives funds that should pay debt)

**Success Condition:** Bob's balance increases by 0 instead of expected 2 tokens, demonstrating the unpaid debt vulnerability.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L73-86)
```csharp
    private void UnlockTokenAndResource(SideChainInfo sideChainInfo)
    {
        // unlock token
        var chainId = sideChainInfo.SideChainId;
        var balance = GetSideChainIndexingFeeDeposit(chainId);
        if (balance <= 0)
            return;
        TransferDepositToken(new TransferInput
        {
            To = sideChainInfo.Proposer,
            Amount = balance,
            Symbol = Context.Variables.NativeSymbol
        }, chainId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L816-893)
```csharp
    private List<SideChainBlockData> IndexSideChainBlockData(IList<SideChainBlockData> sideChainBlockDataList,
        Address proposer, int chainId)
    {
        var indexedSideChainBlockData = new List<SideChainBlockData>();

        {
            var formattedProposerAddress = proposer.ToByteString().ToBase64();
            long indexingFeeAmount = 0;

            var sideChainInfo = State.SideChainInfo[chainId];
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            long arrearsAmount = 0;
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }

                currentSideChainHeight++;
                indexedSideChainBlockData.Add(sideChainBlockData);
            }

            if (indexingFeeAmount > 0)
                TransferDepositToken(new TransferInput
                {
                    To = proposer,
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = indexingFeeAmount,
                    Memo = "Index fee."
                }, chainId);

            if (arrearsAmount > 0)
            {
                if (sideChainInfo.ArrearsInfo.TryGetValue(formattedProposerAddress, out var amount))
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = amount + arrearsAmount;
                else
                    sideChainInfo.ArrearsInfo[formattedProposerAddress] = arrearsAmount;
            }

            State.SideChainInfo[chainId] = sideChainInfo;
            State.CurrentSideChainHeight[chainId] = currentSideChainHeight;
            
            Context.Fire(new SideChainIndexed
            {
                ChainId = chainId,
                IndexedHeight = currentSideChainHeight
            });
        }

        if (indexedSideChainBlockData.Count > 0)
            Context.LogDebug(() =>
                $"Last indexed height {indexedSideChainBlockData.Last().Height} for side chain {chainId}");

        return indexedSideChainBlockData;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L222-242)
```csharp
    public override Int32Value DisposeSideChain(Int32Value input)
    {
        AssertSideChainLifetimeControllerAuthority(Context.Sender);

        var chainId = input.Value;
        var info = State.SideChainInfo[chainId];
        Assert(info != null, "Side chain not found.");
        Assert(info.SideChainStatus != SideChainStatus.Terminated, "Incorrect chain status.");

        if (TryGetIndexingProposal(chainId, out _))
            ResetChainIndexingProposal(chainId);

        UnlockTokenAndResource(info);
        info.SideChainStatus = SideChainStatus.Terminated;
        State.SideChainInfo[chainId] = info;
        Context.Fire(new Disposed
        {
            ChainId = chainId
        });
        return new Int32Value { Value = chainId };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L81-87)
```csharp
    public override Int64Value GetSideChainBalance(Int32Value input)
    {
        var chainId = input.Value;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");
        return new Int64Value { Value = GetSideChainIndexingFeeDeposit(chainId) };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L89-99)
```csharp
    public override Int64Value GetSideChainIndexingFeeDebt(Int32Value input)
    {
        var chainId = input.Value;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null, "Side chain not found.");

        return new Int64Value
        {
            Value = sideChainInfo.ArrearsInfo.Values.Sum()
        };
    }
```
