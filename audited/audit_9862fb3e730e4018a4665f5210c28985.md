### Title
Association Governance Bypass via Post-Vote Member List Manipulation

### Summary
The Association contract's `IsReleaseThresholdReached()` function recalculates rejection counts based on the current organization member list rather than a snapshot at voting time. This allows an organization to bypass rejection thresholds by removing members who voted to reject a proposal, enabling execution of proposals that should have been permanently rejected.

### Finding Description

The root cause lies in the rejection threshold calculation logic. [1](#0-0) 

The `IsProposalRejected()` function filters rejection votes by current membership: [2](#0-1) 

This creates a critical time-of-check/time-of-use vulnerability because:

1. **At voting time**: Members vote and their addresses are stored in `proposal.Rejections` list
2. **Between voting and release**: The organization can modify its member list using `RemoveMember`, `AddMember`, or `ChangeMember` [3](#0-2) 

3. **At release time**: The rejection count is recalculated by filtering stored rejection addresses against the CURRENT member list [4](#0-3) 

The member manipulation functions do not validate whether active proposals exist and contain NO safeguards against manipulation during voting periods. [5](#0-4) 

The organization can call these member manipulation functions on itself through the proposal release mechanism using `SendVirtualInlineBySystemContract`.

### Impact Explanation

**Governance Integrity Breach**: This vulnerability completely undermines the rejection threshold protection mechanism, which is a fundamental governance safeguard. Organizations can execute arbitrary proposals that were legitimately rejected by sufficient members.

**Concrete Attack Scenario**: 
- Organization with 10 members, `MaximalRejectionThreshold = 3`
- Proposal A receives 6 approvals and 4 rejections (exceeds threshold, should be blocked)
- Organization creates Proposal B to remove one rejector (gets 6 approvals, 3 rejections - passes)
- After releasing Proposal B, Proposal A's rejection count drops to 3 (filtering out removed member)
- Proposal A can now be released despite originally having excessive rejections

**Affected Parties**: All organizations using the Association contract for multi-signature governance, particularly those relying on rejection thresholds to prevent harmful actions.

**Severity Justification**: CRITICAL - This breaks a core governance invariant (rejection threshold enforcement) and enables unauthorized execution of rejected proposals without requiring compromise of private keys or exploitation of external systems.

### Likelihood Explanation

**Attacker Capabilities Required**: The attack requires coordination among members who control enough votes to pass the member manipulation proposal (meeting `MinimalApprovalThreshold`). This is not an external attacker but rather a collusion of existing organization members.

**Attack Complexity**: MEDIUM
- Create a normal proposal that receives excessive rejections
- Create a second proposal targeting `RemoveMember` for one or more rejectors
- Ensure the removal proposal gets sufficient approvals (easier than the first proposal)
- Release the removal proposal first
- Release the original proposal with manipulated vote counts

**Feasibility Conditions**: 
- Requires multiple proposals to be active simultaneously (confirmed possible)
- No time restrictions prevent sequential proposal releases
- The virtual call mechanism enables self-modification
- No checks prevent member changes during active proposal periods

**Detection Constraints**: The manipulation leaves an audit trail (member removal events) but may not be detected in real-time before the vulnerable proposal is released.

**Economic Rationality**: The attack cost is only the transaction fees for creating and releasing proposals. The benefit is executing a proposal that a significant minority opposed, potentially controlling high-value assets or protocol parameters.

### Recommendation

**Code-Level Mitigation**:

1. **Snapshot Voting Counts at Proposal Creation**: Store the organization member list hash with each proposal and validate it hasn't changed at release time, OR store counts instead of addresses:

```csharp
// In CreateNewProposal, add:
proposal.OrganizationMemberListHash = HashHelper.ComputeFrom(organization.OrganizationMemberList);

// In Release, add before line 188:
var currentMemberListHash = HashHelper.ComputeFrom(organization.OrganizationMemberList);
Assert(proposal.OrganizationMemberListHash == currentMemberListHash, 
    "Organization membership changed since proposal creation.");
```

2. **Alternative: Lock Member List During Active Proposals**: Add validation in member manipulation functions:

```csharp
// In RemoveMember/AddMember/ChangeMember, add:
Assert(!HasActiveProposals(Context.Sender), 
    "Cannot modify members while proposals are active.");
```

3. **Alternative: Store Vote Counts Not Addresses**: Change the proposal structure to store counts at voting time rather than filtering at release time.

**Invariant Checks to Add**:
- Verify organization member list immutability between proposal voting start and release
- Assert vote counts remain stable throughout proposal lifecycle
- Validate that member manipulations do not affect pending proposals

**Test Cases to Prevent Regression**:
- Test removing a member who rejected a proposal, verify the proposal remains rejected
- Test adding members after voting, verify thresholds still use original member count
- Test parallel proposals where one modifies membership affecting another

### Proof of Concept

**Initial State**:
- Organization with 10 members: M1-M10
- `ProposalReleaseThreshold`: `MinimalApprovalThreshold=6`, `MaximalRejectionThreshold=3`, `MinimalVoteThreshold=8`

**Transaction Sequence**:

1. **Create Proposal A** (target to manipulate)
   - Parameters: Call critical function X
   - Expected: Normal governance vote

2. **Vote on Proposal A**:
   - M1-M6: Approve (6 approvals)
   - M7-M10: Reject (4 rejections)
   - Result: 4 rejections > 3 threshold → **Cannot be released**

3. **Create Proposal B** (manipulation vector)
   - Parameters: Call `RemoveMember(M10)` on Association contract
   - ToAddress: Association contract address

4. **Vote on Proposal B**:
   - M1-M6: Approve (6 approvals)
   - M7-M9: Reject (3 rejections)
   - Result: 3 rejections ≤ 3 threshold AND 6 approvals ≥ 6 threshold → **Can be released**

5. **Release Proposal B**:
   - Executes `RemoveMember(M10)`
   - Organization now has 9 members: M1-M9

6. **Attempt Release of Proposal A**:
   - Stored votes: Approvals=[M1-M6], Rejections=[M7,M8,M9,M10]
   - Recalculated: `rejectionMemberCount = Count([M7,M8,M9,M10] filtered by [M1-M9]) = 3`
   - Check: 3 ≤ 3 threshold → **Not rejected**
   - Check: 6 approvals ≥ 6 threshold → **Approved**
   - Result: **Proposal A is released successfully**

**Expected vs Actual**:
- **Expected**: Proposal A remains permanently blocked with 4 rejections
- **Actual**: Proposal A becomes releasable after member manipulation reduces effective rejection count to 3

**Success Condition**: Proposal A executes despite originally receiving rejections exceeding `MaximalRejectionThreshold`, demonstrating complete bypass of the rejection threshold governance control.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
