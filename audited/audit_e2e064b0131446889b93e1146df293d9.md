### Title
Missing ActualMiningTimes Validation in Next Round Allows Consensus Manipulation

### Summary
The `ValidationForNextRound()` function only validates that `InValue` is null for miners in the next round but fails to check whether `ActualMiningTimes` is empty or contains only the extra block producer's timestamp. This allows malicious miners to pre-fill `ActualMiningTimes` for arbitrary miners when transitioning rounds, enabling manipulation of term change logic and tiny block production permissions.

### Finding Description

The validation gap exists in the `ValidationForNextRound()` method which only checks two aspects when validating next round information: [1](#0-0) 

The validation only ensures: (1) round number is incremented, and (2) `InValue` is null for all miners. However, it does not validate that `ActualMiningTimes` is empty for miners who haven't produced blocks yet in the next round.

When a next round is legitimately generated, the `GenerateNextRoundInformation()` method creates new `MinerInRound` objects that do not explicitly initialize `ActualMiningTimes`: [2](#0-1) 

Only the extra block producer legitimately adds their `ActualMiningTime` when producing the transition block: [3](#0-2) 

However, the `NextRound()` method processes the input by directly converting it to a `Round` object via `ToRound()` which copies all fields including any pre-filled `ActualMiningTimes`: [4](#0-3) [5](#0-4) 

The manipulated round information is then stored without any validation of `ActualMiningTimes`.

### Impact Explanation

Pre-filled `ActualMiningTimes` directly affects critical consensus mechanisms:

**1. Term Change Manipulation**: The `NeedToChangeTerm()` method uses the last `ActualMiningTime` of each miner to determine if a term change should occur: [6](#0-5) 

By pre-filling timestamps, an attacker can force premature term changes (future timestamps) or prevent legitimate term changes (past timestamps), disrupting the consensus election cycle.

**2. Tiny Block Production Denial**: The consensus behavior logic uses `ActualMiningTimes.Count` to determine if miners can produce tiny blocks: [7](#0-6) 

By inflating `ActualMiningTimes.Count` to equal or exceed `maximumBlocksCount`, an attacker can prevent targeted miners from producing tiny blocks, reducing network throughput and potentially causing consensus delays.

**3. First Round Time Calculations**: Time slot validation for the first round relies on `ActualMiningTimes`: [8](#0-7) 

Manipulated timestamps can disrupt the initial round timing calculations.

The vulnerability affects all network participants by allowing manipulation of consensus round transitions, term changes, and block production schedules.

### Likelihood Explanation

**Attacker Capabilities**: Any miner who produces the extra block and transitions to the next round can execute this attack. The miner generates the consensus extra data locally before submitting the `NextRound` transaction: [9](#0-8) 

**Attack Complexity**: Low. The attacker simply needs to:
1. Generate legitimate next round information via normal consensus flow
2. Modify the `NextRoundInput.RealTimeMinersInformation` map to add fake timestamps to `ActualMiningTimes` for target miners
3. Submit the modified `NextRound` transaction

**Feasibility**: The attack is practical because:
- The `NextRound()` method is a public entry point callable during normal consensus operation
- No authorization beyond being a current miner is required
- The validation explicitly fails to check `ActualMiningTimes`
- The protobuf structure allows the repeated `actual_mining_times` field to be arbitrarily populated: [10](#0-9) 

**Detection Constraints**: The attack may go undetected initially as the manipulated `ActualMiningTimes` is stored in state and treated as legitimate data by all subsequent consensus logic.

### Recommendation

Add validation in `ValidationForNextRound()` to ensure `ActualMiningTimes` is properly initialized:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // Existing checks
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };

    // NEW: Validate ActualMiningTimes
    // Only the extra block producer (sender) should have ActualMiningTimes set
    var senderPubkey = validationContext.SenderPubkey;
    foreach (var minerInfo in extraData.Round.RealTimeMinersInformation)
    {
        if (minerInfo.Key == senderPubkey)
        {
            // Sender should have exactly 1 ActualMiningTime (the current block time)
            if (minerInfo.Value.ActualMiningTimes.Count != 1)
                return new ValidationResult { Message = "Extra block producer must have exactly one actual mining time." };
        }
        else
        {
            // All other miners should have empty ActualMiningTimes
            if (minerInfo.Value.ActualMiningTimes.Count != 0)
                return new ValidationResult { Message = "Non-producing miners cannot have preset actual mining times." };
        }
    }

    return new ValidationResult { Success = true };
}
```

Additionally, add integration tests that verify:
- NextRound transactions with pre-filled `ActualMiningTimes` for non-producing miners are rejected
- Only the extra block producer's `ActualMiningTime` is accepted
- Term change logic is not affected by manipulated timestamps

### Proof of Concept

**Initial State**:
- Current round number: N
- Miner A is designated as extra block producer for round N
- Miners B, C, D are regular miners in the round

**Attack Steps**:

1. Miner A produces the extra block and generates next round information via `GetConsensusExtraDataForNextRound()`, which creates `NextRoundInput` with:
   - Round N+1 
   - Miner A has 1 entry in `ActualMiningTimes` (current block time)
   - Miners B, C, D have empty `ActualMiningTimes`

2. **Malicious Modification**: Before submitting, Miner A modifies the `NextRoundInput`:
   ```
   nextRoundInput.RealTimeMinersInformation["MinerB"].ActualMiningTimes.Add(futureTimestamp1);
   nextRoundInput.RealTimeMinersInformation["MinerB"].ActualMiningTimes.Add(futureTimestamp2);
   // ... up to maximumBlocksCount times
   ```

3. Miner A submits the modified `NextRound(nextRoundInput)` transaction

4. **Expected Result**: Validation should reject the transaction because Miner B has non-zero `ActualMiningTimes`

5. **Actual Result**: Validation passes because `ValidationForNextRound()` only checks `InValue`: [11](#0-10) 

6. **Impact Materialization**: In round N+1, Miner B cannot produce tiny blocks because: [12](#0-11) 
   
   The condition `ActualMiningTimes.Count < maximumBlocksCount` evaluates to false, preventing legitimate block production.

**Success Condition**: The attack succeeds if Miner B's `ActualMiningTimes.Count` in round N+1 equals or exceeds the maximum before they produce any actual blocks, preventing them from exercising their tiny block production rights.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-203)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L88-99)
```csharp
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-79)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```
