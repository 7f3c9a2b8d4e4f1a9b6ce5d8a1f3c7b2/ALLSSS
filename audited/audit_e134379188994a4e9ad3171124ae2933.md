# Audit Report

## Title
Incomplete WritePaths Declaration Enables Race Conditions in Token Transfer Callbacks

## Summary
The `GetResourceInfo` method in the MultiToken contract fails to account for transfer callbacks when declaring state modifications for parallel execution. When tokens have callbacks configured via `ExternalInfo`, multiple parallel transfers can simultaneously invoke the same callback contract without proper isolation, causing race conditions and state corruption in the callback contract.

## Finding Description

The AElf parallel execution system relies on `GetResourceInfo` to declare all state paths that a transaction will modify. [1](#0-0)  The `ResourceExtractionService` calls this method before execution to determine which transactions can safely run in parallel. [2](#0-1) 

However, the `Transfer` method invokes `DealWithExternalInfoDuringTransfer` which checks if the token has a `TransferCallbackExternalInfoKey` configured and executes a cross-contract callback via `Context.SendInline`. [3](#0-2) [4](#0-3)  The callback mechanism is configured using the `TransferCallbackExternalInfoKey` constant. [5](#0-4)  and contains a contract address and method name. [6](#0-5) 

The same issue affects `TransferFrom`, which also calls `DealWithExternalInfoDuringTransfer` through the `DoTransferFrom` helper method. [7](#0-6) 

**The Critical Flaw**: While `GetResourceInfo` has access to contract state (as proven by its call to `GetPrimaryTokenSymbol` which reads from state), [8](#0-7)  it does NOT check whether the token has a transfer callback configured in `State.TokenInfos[symbol].ExternalInfo.Value`, and therefore does NOT declare any WritePaths for state that the callback contract will modify.

**Execution Flow**:
1. Multiple transfers of a callback-enabled token are submitted
2. `GetResourceInfo` declares identical WritePaths (balances, fees) for all
3. Transaction grouper places them in the same parallel execution group
4. All transfers execute simultaneously and invoke their callbacks
5. Callbacks modify shared state in the callback contract without isolation
6. Race conditions occur, causing state corruption

## Impact Explanation

This vulnerability violates the fundamental correctness guarantee of the parallel execution system. When multiple transfers execute in parallel and invoke callbacks to the same contract:

- **State Corruption**: The callback contract's state can become corrupted due to concurrent modification without proper isolation
- **Non-Deterministic Behavior**: Execution outcomes depend on race conditions and timing, making behavior unpredictable
- **Broken Invariants**: Callback contracts may maintain internal invariants (e.g., total balance equals sum of user balances) that break under concurrent execution
- **Impossible to Defend**: Callback contracts cannot protect themselves since they have no way to know their methods are being invoked from parallel transactions

The severity is HIGH because:
- It undermines the reliability of the entire parallel execution framework
- Affects any token configured with transfer callbacks
- Cannot be detected or prevented by the affected callback contracts
- Results in unpredictable state corruption that may only manifest intermittently

## Likelihood Explanation

The vulnerability can be triggered if:
1. A token exists with `TransferCallbackExternalInfoKey` configured (set by token creator during `Create`) [9](#0-8) 
2. The callback contract has state susceptible to race conditions
3. Multiple transfers of that token are submitted in the same block
4. The transactions are grouped for parallel execution (will occur since WritePaths don't conflict)

**Feasibility**: 
- Both `Transfer` and `TransferFrom` are public methods callable by anyone [10](#0-9) [11](#0-10) 
- Token creators can freely configure callbacks during creation; the callback feature is an intentional design [12](#0-11) 
- Exploitation complexity is low: simply submit multiple transfers of a callback-enabled token
- Detection is difficult as race conditions are inherently intermittent

**Probability**: MEDIUM-HIGH if callback-enabled tokens are deployed in production; otherwise depends on adoption of the callback feature.

## Recommendation

Modify the `GetResourceInfo` method to check if the token has a transfer callback configured and mark such transactions as non-parallelizable:

```csharp
case nameof(Transfer):
{
    var args = TransferInput.Parser.ParseFrom(txn.Params);
    
    // Check if token has transfer callback configured
    var tokenInfo = State.TokenInfos[args.Symbol];
    if (tokenInfo?.ExternalInfo?.Value.ContainsKey(
        TokenContractConstants.TransferCallbackExternalInfoKey) == true)
    {
        return new ResourceInfo { NonParallelizable = true };
    }
    
    var resourceInfo = new ResourceInfo
    {
        WritePaths = { /* existing paths */ }
    };
    // ... rest of existing logic
    return resourceInfo;
}
```

Apply the same fix to `TransferFrom`, `Lock`, and `Unlock` cases which also invoke callbacks.

**Alternative**: If performance is critical, the system could be enhanced to allow callback contracts to implement `GetResourceInfo` and have the MultiToken contract query it to get the callback's WritePaths. However, marking as non-parallelizable is the simpler and safer immediate fix.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a token with a transfer callback configured to a counter contract
2. The counter contract increments a counter on each callback invocation
3. Submitting multiple transfers of this token in the same block
4. Observing that due to race conditions, the final counter value is less than the number of transfers (lost updates)

```csharp
// Simplified test outline
[Fact]
public async Task Transfer_Callback_RaceCondition_Test()
{
    // Setup: Create token with callback to CounterContract
    var tokenSymbol = "RACE";
    var callbackInfo = new CallbackInfo 
    { 
        ContractAddress = CounterContractAddress,
        MethodName = "IncrementCounter" 
    };
    
    await TokenContract.Create(new CreateInput
    {
        Symbol = tokenSymbol,
        ExternalInfo = new ExternalInfo
        {
            Value = { 
                [TokenContractConstants.TransferCallbackExternalInfoKey] 
                    = JsonFormatter.Default.Format(callbackInfo) 
            }
        }
        // ... other required fields
    });
    
    // Execute: Submit 10 parallel transfers
    var transfers = Enumerable.Range(0, 10)
        .Select(_ => TokenContract.Transfer(new TransferInput
        {
            Symbol = tokenSymbol,
            Amount = 1,
            To = ReceiverAddress
        }))
        .ToList();
    
    await Task.WhenAll(transfers);
    
    // Verify: Counter should be 10, but due to race conditions may be less
    var counterValue = await CounterContract.GetCounter();
    Assert.True(counterValue < 10); // Race condition causes lost updates
}
```

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L11-38)
```csharp
    public override ResourceInfo GetResourceInfo(Transaction txn)
    {
        switch (txn.MethodName)
        {
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L86-89)
```csharp
        var symbols = GetTransactionFeeSymbols(methodName);
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        if (_primaryTokenSymbol != string.Empty && !symbols.Contains(primaryTokenSymbol))
            symbols.Add(primaryTokenSymbol);
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L160-163)
```csharp
            var txContext = GetTransactionContext(chainContext, transaction.To, transaction.ToByteString());
            var resourceInfo = await executive.GetTransactionResourceInfoAsync(txContext, transaction.GetHash());
            // Try storing in cache here
            return resourceInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L180-193)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenInfo = AssertValidToken(input.Symbol, input.Amount);
        DoTransfer(Context.Sender, input.To, tokenInfo.Symbol, input.Amount, input.Memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = tokenInfo.Symbol,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L254-254)
```csharp
    public override Empty TransferFrom(TransferFromInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-13)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L69-95)
```csharp
    private void DoTransferFrom(Address from, Address to, Address spender, string symbol, long amount, string memo)
    {
        AssertValidInputAddress(from);
        AssertValidInputAddress(to);
        
        // First check allowance.
        var allowance = GetAllowance(from, spender, symbol, amount, out var allowanceSymbol);
        if (allowance < amount)
        {
            if (IsInWhiteList(new IsInWhiteListInput { Symbol = symbol, Address = spender }).Value)
            {
                DoTransfer(from, to, symbol, amount, memo);
                DealWithExternalInfoDuringTransfer(new TransferFromInput()
                    { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
                return;
            }

            Assert(false,
                $"[TransferFrom]Insufficient allowance. Token: {symbol}; {allowance}/{amount}.\n" +
                $"From:{from}\tSpender:{spender}\tTo:{to}");
        }

        DoTransfer(from, to, symbol, amount, memo);
        DealWithExternalInfoDuringTransfer(new TransferFromInput()
            { From = from, To = to, Symbol = symbol, Amount = amount, Memo = memo });
        State.Allowances[from][spender][allowanceSymbol] = allowance.Sub(amount);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```
