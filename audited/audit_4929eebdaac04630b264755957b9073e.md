### Title
Authorization Bypass in Treasury Initialization Allows Complete Treasury Takeover via Malicious Profit Scheme Injection

### Summary
The `InitialMiningRewardProfitItem()` function in TreasuryContract lacks caller authorization checks and only validates that `State.TreasuryHash.Value == null`. An attacker can exploit this by directly creating 7 malicious profit schemes via the Profit contract with `manager` set to the Treasury contract address, then calling `InitialMiningRewardProfitItem()` before legitimate initialization to inject these malicious scheme IDs into the Treasury's core state variables, gaining complete control over all treasury fund distributions.

### Finding Description

**Root Cause:**

The `InitialMiningRewardProfitItem()` function only checks initialization state but performs no caller authorization: [1](#0-0) 

The function retrieves schemes managed by the Treasury contract and assigns them to state variables without validating their legitimacy: [2](#0-1) 

**Attack Vector:**

The Profit contract's `CreateScheme()` allows anyone to specify an arbitrary manager address: [3](#0-2) 

The Profit contract's `CreateSchemeInput` proto definition includes an optional manager field: [4](#0-3) 

When `GetManagingSchemeIds` is called, it simply returns all schemes for the specified manager without validating their origin: [5](#0-4) 

**Why Protections Fail:**

1. No authorization check on who can call `InitialMiningRewardProfitItem()`
2. No validation that retrieved schemes were created by legitimate initialization
3. Profit contract allows arbitrary manager specification in scheme creation
4. Only checks initialization state, not caller identity

The proto definition confirms these methods are publicly accessible without restrictions: [6](#0-5) 

### Impact Explanation

**Direct Fund Impact - Critical:**

The injected malicious scheme IDs control all treasury operations:
- Mining reward distributions via `State.RewardHash.Value`
- Subsidy payments via `State.SubsidyHash.Value`  
- Welfare distributions via `State.WelfareHash.Value`
- Basic, welcome, and flexible reward schemes [7](#0-6) 

The attacker controls:
1. **Beneficiary addresses** - can set themselves as sole beneficiaries in the malicious schemes
2. **Share distributions** - can allocate 100% of shares to their addresses
3. **Distribution timing** - can manipulate when and how funds are released
4. **Sub-scheme relationships** - BuildTreasury() uses the malicious schemes to establish the entire treasury hierarchy [8](#0-7) 

**Complete Loss Scenario:**
- All mining rewards (20% of total supply over time)
- All transaction fees donated to treasury
- All resource consumption payments
- Theft of hundreds of millions to billions of dollars worth of ELF tokens over the protocol's lifetime

### Likelihood Explanation

**Feasibility Conditions:**

The attack is exploitable when the Treasury contract is deployed but not yet initialized, which occurs in:

1. **Manual/Non-Atomic Deployments:** Testnet, development, or sidechain deployments where initialization is not atomic
2. **Emergency Scenarios:** State reset requiring re-initialization
3. **Deployment Errors:** Any gap between deployment and initialization transactions

**Attack Complexity: Low**

1. Attacker calls `ProfitContract.CreateScheme()` 7 times with:
   - `manager = TreasuryContractAddress`
   - Different `token` values for unique scheme IDs
   - Attacker as primary beneficiary with maximum shares

2. Attacker calls `TreasuryContract.InitialMiningRewardProfitItem()`
   - Passes initialization check (State.TreasuryHash.Value still null)
   - Retrieves attacker's 7 schemes
   - Assigns malicious scheme IDs to treasury state

3. Legitimate initialization is permanently blocked (State.TreasuryHash.Value no longer null)

**Probability Assessment:**
- **Mainnet genesis:** Low (atomic deployment)
- **Testnets/Sidechains:** Medium to High (often manual deployment)
- **Overall:** Medium (realistic in several deployment scenarios)

While the normal genesis initialization provider enforces order, the public methods lack authorization: [9](#0-8) 

### Recommendation

**Immediate Fix:**

Add caller authorization to both initialization functions. Restrict to contract deployer or genesis contract:

```csharp
public override Empty InitialMiningRewardProfitItem(Empty input)
{
    // Add authorization check
    Assert(Context.Sender == Context.GetZeroSmartContractAddress() ||
           Context.Sender == State.GenesisOwner.Value,
           "No permission to initialize.");
    
    Assert(State.TreasuryHash.Value == null, "Already initialized.");
    // ... rest of function
}
```

**Additional Protections:**

1. Add scheme origin validation - verify schemes were created by the Treasury contract itself during InitialTreasuryContract()
2. Store scheme creation context (creator address, block height) in Profit contract
3. Validate scheme configurations match expected defaults before assignment
4. Add initialization transaction atomicity enforcement in deployment scripts

**Test Cases:**

1. Verify unauthorized caller cannot call InitialMiningRewardProfitItem()
2. Verify attacker cannot inject malicious schemes via Profit contract
3. Verify legitimate initialization succeeds with proper authorization
4. Verify state remains secure if initialization is called out of order

### Proof of Concept

**Required Initial State:**
- Treasury contract deployed but not initialized
- Profit contract deployed and functional
- Attacker has standard transaction submission capability

**Attack Transaction Sequence:**

1. **Create Malicious Schemes (7 transactions):**
   ```
   Call: ProfitContract.CreateScheme()
   Input: {
     manager: <TreasuryContractAddress>,
     token: <unique_value_1_through_7>,
     profit_receiving_due_period_count: 1,
     is_release_all_balance_every_time_by_default: true,
     // Attacker-controlled configuration
   }
   Expected: 7 scheme IDs created with Treasury as manager
   ```

2. **Inject Malicious Schemes:**
   ```
   Call: TreasuryContract.InitialMiningRewardProfitItem()
   Input: Empty
   Expected: Function succeeds, assigns malicious scheme IDs to:
     - State.TreasuryHash.Value
     - State.RewardHash.Value
     - State.SubsidyHash.Value
     - State.WelfareHash.Value
     - State.BasicRewardHash.Value
     - State.VotesWeightRewardHash.Value
     - State.ReElectionRewardHash.Value
   ```

3. **Verify Takeover:**
   ```
   Call: TreasuryContract.GetTreasurySchemeId()
   Actual Result: Returns attacker's malicious scheme ID
   Expected Result: Should return legitimate scheme ID from InitialTreasuryContract()
   ```

4. **Legitimate Initialization Blocked:**
   ```
   Call: TreasuryContract.InitialMiningRewardProfitItem()
   Actual Result: Fails with "Already initialized"
   Impact: Legitimate schemes orphaned, malicious schemes control treasury
   ```

**Success Condition:**
All subsequent treasury operations (donations, distributions, rewards) use attacker-controlled schemes, allowing complete fund theft through manipulated beneficiary lists and share allocations.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L80-82)
```csharp
    public override Empty InitialMiningRewardProfitItem(Empty input)
    {
        Assert(State.TreasuryHash.Value == null, "Already initialized.");
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L83-96)
```csharp
        var managingSchemeIds = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = Context.Self
        }).SchemeIds;

        Assert(managingSchemeIds.Count == 7, "Incorrect schemes count.");

        State.TreasuryHash.Value = managingSchemeIds[0];
        State.RewardHash.Value = managingSchemeIds[1];
        State.SubsidyHash.Value = managingSchemeIds[2];
        State.WelfareHash.Value = managingSchemeIds[3];
        State.BasicRewardHash.Value = managingSchemeIds[4];
        State.VotesWeightRewardHash.Value = managingSchemeIds[5];
        State.ReElectionRewardHash.Value = managingSchemeIds[6];
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L129-134)
```csharp
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.TreasuryHash.Value,
            Period = input.PeriodNumber,
            AmountsMap = { State.SymbolList.Value.Value.ToDictionary(s => s, s => 0L) }
        });
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L688-703)
```csharp
    private void BuildTreasury()
    {
        if (State.DividendPoolWeightSetting.Value == null)
        {
            var dividendPoolWeightSetting = GetDefaultDividendPoolWeightSetting();
            ResetSubSchemeToTreasury(dividendPoolWeightSetting);
            State.DividendPoolWeightSetting.Value = dividendPoolWeightSetting;
        }

        if (State.MinerRewardWeightSetting.Value == null)
        {
            var minerRewardWeightSetting = GetDefaultMinerRewardWeightSetting();
            ResetSubSchemeToMinerReward(minerRewardWeightSetting);
            State.MinerRewardWeightSetting.Value = minerRewardWeightSetting;
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L56-58)
```csharp
        var schemeId = GenerateSchemeId(input);
        var manager = input.Manager ?? Context.Sender;
        var scheme = GetNewScheme(input, schemeId, manager);
```

**File:** protobuf/profit_contract.proto (L120-133)
```text
message CreateSchemeInput {
    // Period of profit distribution.
    int64 profit_receiving_due_period_count = 1;
    // Whether all the schemes balance will be distributed during distribution each period.
    bool is_release_all_balance_every_time_by_default = 2;
    // Delay distribute period.
    int32 delay_distribute_period_count = 3;
    // The manager of this scheme, the default is the creator.
    aelf.Address manager = 4;
    // Whether you can directly remove the beneficiary.
    bool can_remove_beneficiary_directly = 5;
    // Use to generate scheme id.
    aelf.Hash token = 6;
}
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L12-15)
```csharp
    public override CreatedSchemeIds GetManagingSchemeIds(GetManagingSchemeIdsInput input)
    {
        return State.ManagingSchemeIds[input.Manager];
    }
```

**File:** protobuf/treasury_contract.proto (L20-25)
```text
    rpc InitialTreasuryContract (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
    
    // Initialize the sub-item of the bonus scheme.
    rpc InitialMiningRewardProfitItem (google.protobuf.Empty) returns (google.protobuf.Empty) {
    }
```

**File:** src/AElf.EconomicSystem/TreasuryContractInitializationProvider.cs (L15-30)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(TreasuryContractContainer.TreasuryContractStub.InitialTreasuryContract),
                Params = ByteString.Empty
            },
            new()
            {
                MethodName = nameof(TreasuryContractContainer.TreasuryContractStub.InitialMiningRewardProfitItem),
                Params = ByteString.Empty
            }
        };
    }
```
