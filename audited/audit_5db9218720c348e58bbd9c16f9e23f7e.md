### Title
Missing ProposerWhiteList Size Limit Enables Governance DOS via Execution Branch Threshold Exhaustion

### Summary
The Association contract lacks size validation on the `ProposerWhiteList` during organization creation, allowing an attacker to create organizations with thousands of proposers (up to ~3,700 addresses within the 128KB state size limit). When proposal creation occurs, the `AssertIsAuthorizedProposer` function performs a linear `Contains()` search through the entire whitelist, consuming 8,000-12,000+ branches for large lists and either exceeding the 15,000 branch execution threshold or making proposal creation economically prohibitive, effectively DOSing governance for that organization.

### Finding Description

The vulnerability exists in the proposal authorization check flow: [1](#0-0) 

The `AssertIsAuthorizedProposer` function is called during proposal creation: [2](#0-1) 

The `Contains()` method performs a linear search through the proposer list: [3](#0-2) 

During organization creation, the `Validate()` function only checks for empty lists and duplicates, but has NO size limit: [4](#0-3) 

The state size limit is 128KB: [5](#0-4) 

The branch execution threshold is 15,000: [6](#0-5) 

**Root Cause**: The `Validate()` function checks `ProposerWhiteList.Empty()` and `ProposerWhiteList.AnyDuplicate()` but never validates the list size. Given an Address is ~32 bytes, the 128KB state limit allows approximately 3,700-4,000 addresses in the combined Organization object (including both ProposerWhiteList and OrganizationMemberList).

**Why Protections Fail**: A linear `Contains()` search through 3,700 addresses requires at least 2-3 branches per iteration (load, compare, loop), consuming 7,400-11,100 branches just for the authorization check. Combined with other CreateProposal operations (validation, state writes, event firing ~2,000-4,000 branches), the total execution approaches or exceeds the 15,000 branch limit.

### Impact Explanation

**Operational Impact - Governance DOS:**
- An attacker creates an organization with a ProposerWhiteList containing ~3,500-3,700 addresses (maximum possible within state size limit)
- Any proposer attempting to call `CreateProposal` triggers the `Contains()` iteration consuming 10,000+ branches
- Combined with normal proposal creation operations, transactions either:
  1. **Fail completely**: Exceed the 15,000 branch execution threshold, causing transaction failure
  2. **Become prohibitively expensive**: Consume excessive resource tokens (READ operations), making proposals economically infeasible

**Who is Affected:**
- All proposers authorized in that organization cannot create proposals
- The organization's governance is effectively paralyzed
- While this affects only specific organizations (not system-wide), it can target critical governance bodies

**Severity Justification**: Medium severity because:
- Impact is high for affected organizations (complete governance DOS)
- Scope is limited (per-organization, not system-wide)
- Users might detect and avoid obviously malicious organizations with thousands of proposers
- However, attack could be subtle if introduced gradually via `ChangeOrganizationProposerWhiteList` governance actions

### Likelihood Explanation

**Attacker Capabilities Required:**
- Standard user account with sufficient transaction fees to create an organization
- Ability to generate ~3,700 addresses (trivial)
- No special privileges required

**Attack Complexity**: Low
1. Prepare CreateOrganizationInput with ProposerWhiteList containing 3,500-3,700 addresses
2. Call `CreateOrganization` (transaction size <5MB limit, passes all validation)
3. Organization is successfully created and stored
4. Any subsequent `CreateProposal` call becomes DOS'd

**Feasibility Conditions:**
- Transaction must fit within 5MB transaction size limit: 3,700 addresses × 35 bytes ≈ 127KB ✓
- Organization must fit within 128KB state size limit: ~127KB total ✓
- All validation checks pass: Empty check ✓, Duplicate check ✓, No size check ✗

**Economic Rationality**: Cost to create such an organization is standard creation fees (~hundreds of transactions worth of fees for the large input), but the impact (disabling governance for that organization indefinitely) is disproportionately high.

**Detection/Operational Constraints**: 
- Users examining the organization would see the enormous ProposerWhiteList
- However, if introduced gradually through governance votes, might not be immediately obvious
- No automatic detection mechanisms exist in the contract

**Probability**: Medium - While technically feasible and economically rational, requires users to adopt/use the malicious organization, which sophisticated users would avoid.

### Recommendation

**Code-Level Mitigation:**

Add a maximum size constant and validation check in `AssociationConstants.cs`:
```csharp
public const int MaxProposerWhiteListSize = 100; // Reasonable limit
```

Modify the `Validate()` function to enforce the limit: [7](#0-6) 

Add size validation:
```csharp
if (organization.ProposerWhiteList.Empty() ||
    organization.ProposerWhiteList.Count() > AssociationConstants.MaxProposerWhiteListSize ||
    organization.ProposerWhiteList.AnyDuplicate() ||
    organization.OrganizationMemberList.Empty() ||
    organization.OrganizationMemberList.Count() > AssociationConstants.MaxOrganizationMemberListSize ||
    organization.OrganizationMemberList.AnyDuplicate())
    return false;
```

**Invariant Checks to Add:**
- `ProposerWhiteList.Count() <= MaxProposerWhiteListSize` in all validation paths
- Same check for `OrganizationMemberList`
- Apply to both `CreateOrganization` and `ChangeOrganizationProposerWhiteList`

**Test Cases:**
1. Test organization creation with ProposerWhiteList size = MaxLimit (should succeed)
2. Test organization creation with ProposerWhiteList size = MaxLimit + 1 (should fail)
3. Test ChangeOrganizationProposerWhiteList exceeding limit (should fail)
4. Performance test: verify CreateProposal with max-size whitelist stays well under branch threshold

### Proof of Concept

**Required Initial State:**
- Attacker has a funded account with transaction fees
- Association contract is deployed

**Transaction Steps:**

1. **Create malicious organization:**
```csharp
var maliciousProposers = new ProposerWhiteList();
for (int i = 0; i < 3700; i++) {
    maliciousProposers.Proposers.Add(GenerateAddress(i));
}

var createInput = new CreateOrganizationInput {
    OrganizationMemberList = new OrganizationMemberList {
        OrganizationMembers = { AttackerAddress }
    },
    ProposalReleaseThreshold = new ProposalReleaseThreshold {
        MinimalApprovalThreshold = 1,
        MinimalVoteThreshold = 1,
        MaximalAbstentionThreshold = 0,
        MaximalRejectionThreshold = 0
    },
    ProposerWhiteList = maliciousProposers
};

var orgAddress = await AssociationContract.CreateOrganization(createInput);
// Success: Organization created with 3,700 proposers
```

2. **Victim attempts to create proposal:**
```csharp
var proposalInput = new CreateProposalInput {
    OrganizationAddress = orgAddress,
    ContractMethodName = "SomeMethod",
    ToAddress = targetContract,
    ExpiredTime = Timestamp.FromDateTime(DateTime.UtcNow.AddDays(7))
};

// Execution trace:
// - AssertIsAuthorizedProposer called
// - Contains() iterates through 3,700 addresses: ~10,500 branches
// - CreateNewProposal operations: ~2,500 branches
// - Total: ~13,000-14,500 branches
// - If proposal has complex params or additional logic: EXCEEDS 15,000 → Transaction fails
```

**Expected Result:** Proposal creation succeeds with low branch count (<5,000)

**Actual Result:** Transaction either fails with "execution branch threshold exceeded" or succeeds but consumes 13,000+ branches (86%+ of budget), making complex proposals impossible and all proposals economically expensive.

**Success Condition:** CreateProposal transaction fails or consumes >80% of branch execution budget, demonstrating governance DOS.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Extensions.cs (L29-32)
```csharp
    public static bool Contains(this ProposerWhiteList proposerWhiteList, Address address)
    {
        return proposerWhiteList.Proposers.Contains(address);
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L7-7)
```csharp
    public const int ExecutionBranchThreshold = 15000;
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```
