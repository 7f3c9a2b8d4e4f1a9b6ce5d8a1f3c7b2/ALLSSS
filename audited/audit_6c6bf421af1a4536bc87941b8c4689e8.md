### Title
Insufficient Validation Allows Duplicate FinalOrderOfNextRound Values Leading to Consensus Manipulation

### Summary
The `ValidateHeaderInformation()` function in `NextRoundMiningOrderValidationProvider` uses `.Distinct()` on full `MinerInRound` objects instead of on `FinalOrderOfNextRound` values, failing to detect duplicate mining orders among different miners. This allows a malicious miner to construct a `NextRound` input with duplicate orders that passes validation, causing legitimate miners to be excluded from subsequent rounds and breaking consensus integrity.

### Finding Description

The validation logic in `NextRoundMiningOrderValidationProvider.ValidateHeaderInformation()` attempts to verify that miners who determined the order for the next round match those who mined blocks in the current round: [1](#0-0) 

**Root Cause:** The validation calls `.Distinct()` on the collection of `MinerInRound` objects after filtering by `FinalOrderOfNextRound > 0`. Since `MinerInRound` is a protobuf-generated class where each instance represents a different miner (with different pubkeys), this will always count all miners even if they have duplicate `FinalOrderOfNextRound` values. The validation should call `.Select(m => m.FinalOrderOfNextRound).Distinct()` to count unique order values, not unique miner objects.

**Why Protections Fail:** When the validated round is used to generate the next round, duplicate orders cause silent miner exclusion: [2](#0-1) 

The loop iterates through miners ordered by `FinalOrderOfNextRound`. If two miners have the same order value (e.g., both have order 1), when the second miner is processed, it overwrites the first miner's entry in the dictionary since the key is the miner's pubkey but the order is used as the value. Then the "available orders" calculation becomes incorrect: [3](#0-2) 

The `occupiedOrders` list will contain duplicate values, causing the `ableOrders` calculation to misidentify available slots, potentially assigning non-mining miners to incorrect positions while legitimate miners are excluded.

**Attack Vector:** A malicious miner can introduce duplicate `FinalOrderOfNextRound` values through the `TuneOrderInformation` mechanism during `UpdateValue`: [4](#0-3) 

Or when producing the extra block that triggers `NextRound`, the attacker can directly construct a round with duplicate values.

**Validation Provider Usage:** This provider is invoked during consensus validation before execution for `NextRound` behavior: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Violation:** This vulnerability allows manipulation of the miner schedule for subsequent rounds. By constructing a `NextRound` input with duplicate `FinalOrderOfNextRound` values:

1. **Miner Exclusion:** One or more legitimate miners who produced blocks are silently excluded from the next round when their dictionary entries are overwritten by miners with duplicate orders
2. **Schedule Corruption:** The mining order becomes incorrect, with wrong miners assigned to time slots
3. **Security Degradation:** Reducing the active miner count makes the network more vulnerable to further attacks (e.g., easier to achieve majority control)
4. **Reward Misallocation:** Excluded miners lose mining rewards they should have earned, while miners who didn't actually mine may incorrectly receive positions

**Protocol Damage:** This breaks the fundamental AEDPoS consensus invariant that miners who successfully produced blocks in round N should be assigned valid, unique positions in round N+1. The attack can be repeated across multiple rounds to systematically exclude targeted miners or manipulate the mining schedule for strategic advantage.

**Affected Parties:** All network participants are affected through degraded consensus security, but specifically excluded miners suffer direct economic loss from missed rewards.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Attacker must be an active miner in the current round
- Attacker must be selected as the extra block producer (to produce the `NextRound` block), OR
- Attacker can manipulate `TuneOrderInformation` during their `UpdateValue` call

**Attack Complexity:** Medium. The attacker needs to:
1. Wait until they are the extra block producer for round termination
2. Construct a `NextRound` input with duplicate `FinalOrderOfNextRound` values (straightforward manipulation)
3. Submit the transaction, which will pass the flawed validation

**Feasibility Conditions:**
- Extra block producer role rotates among miners, so any malicious miner will eventually have opportunity
- The protobuf message can be manually constructed with duplicate values
- No additional protections exist beyond the flawed validation

**Detection Constraints:** The attack is difficult to detect because:
- The validation passes (incorrectly)
- The round generation completes without errors
- Only careful comparison of expected vs actual miner lists would reveal the exclusion
- No events are emitted for the silent miner exclusion

**Probability:** Medium-High. While requiring miner status, the attack is technically simple once in position, requires no special resources beyond block production capability, and can be repeated whenever the attacker is the extra block producer.

### Recommendation

**Code-Level Mitigation:**

Modify the validation logic to check for duplicate `FinalOrderOfNextRound` values:

```csharp
var distinctOrderCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
var minersWhoMinedCount = providedRound.RealTimeMinersInformation.Values
    .Count(m => m.OutValue != null);
if (distinctOrderCount != minersWhoMinedCount)
{
    validationResult.Message = "Invalid FinalOrderOfNextRound: duplicate or missing orders detected.";
    return validationResult;
}
```

**Additional Invariant Checks:**

1. Validate that all `FinalOrderOfNextRound` values are in the range [1, minerCount]
2. Verify that the set of orders exactly covers [1, N] where N is the count of miners who mined
3. Add explicit check in `Round_Generation.cs` to detect and reject rounds with duplicate orders before processing

**Test Cases to Prevent Regression:**

1. Test with two miners having the same `FinalOrderOfNextRound` value (should fail)
2. Test with all miners having `FinalOrderOfNextRound = 0` (should fail)
3. Test with `FinalOrderOfNextRound` values outside valid range [1, minerCount] (should fail)
4. Test with gaps in the order sequence [1, 3, 4] when 3 miners mined (should fail)
5. Test with normal case where all orders are unique and sequential (should pass)
6. Test with empty `RealTimeMinersInformation` collection (should handle gracefully)

### Proof of Concept

**Initial State:**
- Round N with 5 miners: [A, B, C, D, E]
- Miners A, B, C, D successfully mine blocks (have non-null `OutValue`)
- Miner E is the extra block producer and is malicious

**Attack Steps:**

1. Miner E constructs a `NextRoundInput` where:
   - Miner A: `FinalOrderOfNextRound = 1`
   - Miner B: `FinalOrderOfNextRound = 1` (duplicate!)
   - Miner C: `FinalOrderOfNextRound = 2`
   - Miner D: `FinalOrderOfNextRound = 3`

2. Miner E calls `NextRound` with this crafted input

3. The validation runs:
   - `distinctCount = 4` (counts distinct MinerInRound objects: A, B, C, D)
   - `OutValue count = 4` (miners A, B, C, D have OutValue)
   - Validation passes: 4 == 4 âœ“ (incorrect!)

4. Round generation executes:
   - Processes Miner A: assigns order 1 to `nextRound.RealTimeMinersInformation["A"]`
   - Processes Miner B: assigns order 1 to `nextRound.RealTimeMinersInformation["B"]` (overwrites A's entry!)
   - Processes Miner C: assigns order 2
   - Processes Miner D: assigns order 3
   - Calculates available orders: `occupiedOrders = [1, 1, 2, 3]`, `ableOrders = [4]`
   - Assigns Miner E to order 4

**Expected Result:** All five miners should have unique orders in round N+1

**Actual Result:** 
- Round N+1 contains only 4 miners: [B, C, D, E]
- Miner A is completely excluded despite successfully mining in round N
- Consensus integrity is compromised

**Success Condition:** The `NextRound` transaction succeeds, and subsequent queries show Miner A is missing from round N+1's miner list, demonstrating successful consensus manipulation through the validation bypass.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-20)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-46)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-86)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
```
