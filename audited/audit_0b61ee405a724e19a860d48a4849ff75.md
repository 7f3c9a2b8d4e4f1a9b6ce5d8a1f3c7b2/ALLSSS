### Title
Mathematically Impossible Length Increase Check Permanently Caps NFT Protocol Symbol Space at 900 Million

### Summary
The `GetCurrentNumberLength()` function contains a mathematically flawed condition that will never trigger, preventing the symbol number length from increasing beyond the initial value of 9. This permanently caps the NFT protocol symbol space at approximately 900 million symbols, causing eventual denial of service when the number space approaches exhaustion.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

The function initializes `CurrentSymbolNumberLength` to `NumberMinLength` (which equals 9) [2](#0-1)  and sets `NftProtocolNumberFlag` to 10^(length-1) = 100,000,000 [3](#0-2) 

The critical flaw is at the length increase check: [4](#0-3) 

**Mathematical Proof of Failure:**
- For length n, flag = 10^(n-1)
- upperNumberFlag = 2 × 10^(n-1) = 0.2 × 10^n
- Since 0.2 × 10^n < 10^n, upperNumberFlag always has exactly n digits
- A number needs ≥ 10^n to have n+1 digits
- Therefore, `upperNumberFlag.ToString().Length > n` is always false

**Concrete Example (n=9):**
- flag = 10^8 = 100,000,000
- upperNumberFlag = 200,000,000 (9 digits)
- Check: "200000000".Length (9) > 9? **FALSE**
- The condition never triggers

The flag is only updated when length increases (which never happens), creating an impossible circular dependency. [5](#0-4) 

**Execution Path:**
`Create()` → `GetSymbol()` → `GenerateSymbolNumber()` → `GetCurrentNumberLength()` [6](#0-5) [7](#0-6) [8](#0-7) 

### Impact Explanation

**Operational Impact - Denial of Service:**

The symbol generation space is permanently capped at [100,000,000, 1,000,000,000), providing only 900 million possible protocol symbols. [9](#0-8) 

**Progressive Degradation:**
1. As symbols are created, they're marked as used in `IsCreatedMap`
2. The do-while loop keeps retrying until finding an unused number
3. As space fills up (birthday paradox), collision probability increases exponentially
4. Eventually, the loop becomes unable to find unused numbers, causing transaction timeouts
5. Once ~900 million protocols are created, new protocol creation permanently fails

**Who Is Affected:**
- All users attempting to create new NFT protocols after space exhaustion
- The entire NFT ecosystem becomes unable to expand
- No new NFT collections can be registered

**Severity Justification:**
While 900 million is a large number, this represents a hard cap with no recovery mechanism. The intended dynamic expansion logic is completely non-functional, violating the design invariant that the system should scale as needed.

### Likelihood Explanation

**Certainty:** The vulnerability is deterministic and always present due to the mathematical impossibility of the condition.

**Preconditions:** None required beyond normal system operation.

**Feasibility:** This is not an active attack but an inevitable consequence of the flawed logic. As the protocol grows and more NFT collections are created, the space will eventually fill.

**Timeline Consideration:** While reaching 900 million protocols may take considerable time in practice, the bug fundamentally breaks the intended auto-scaling mechanism. Earlier impact occurs through:
- Increased collision rates causing slower symbol generation (quadratic degradation)
- Unpredictable transaction failures as space fills
- System behavior diverging from design expectations

**Economic Rationality:** No attack cost—this occurs through normal usage patterns.

### Recommendation

**Fix the Mathematical Check:**

Replace the flawed multiplication-based check with a proper exhaustion detection mechanism. Option 1 - Track actual usage:

```csharp
private int GetCurrentNumberLength()
{
    if (State.CurrentSymbolNumberLength.Value == 0) 
        State.CurrentSymbolNumberLength.Value = NumberMinLength;
    
    var currentLength = State.CurrentSymbolNumberLength.Value;
    var maxNumbers = CalculateMaxNumbers(currentLength); // 9 * 10^(n-1)
    var usedCount = State.UsedSymbolCount.Value;
    
    // Increase length when 80% capacity reached
    if (usedCount >= maxNumbers * 8 / 10)
    {
        var newLength = currentLength.Add(1);
        State.CurrentSymbolNumberLength.Value = newLength;
        return newLength;
    }
    
    return currentLength;
}
```

Option 2 - Fix the flag increment logic by tracking highest number generated and checking when it approaches the upper bound.

**Invariant to Add:**
- Assert that symbol space has not exceeded (1 - threshold) of capacity
- Monitor and log collision rates to detect approaching exhaustion

**Test Cases:**
1. Create protocols until length should increase, verify it actually increases
2. Test collision handling under high load
3. Verify length transitions from 9→10→11 correctly
4. Test mathematical boundary conditions (flag at 499,999,999 should trigger increase)

### Proof of Concept

**Initial State:**
- `CurrentSymbolNumberLength` = 0 (uninitialized)
- `NftProtocolNumberFlag` = 0 (uninitialized)

**Step 1:** Call `Create()` for first protocol
- Initializes `CurrentSymbolNumberLength` = 9
- Initializes `NftProtocolNumberFlag` = 100,000,000
- Calculates `upperNumberFlag` = 200,000,000
- Checks: "200000000".Length (9) > 9? **FALSE**
- Returns length 9

**Step 2:** Call `Create()` repeatedly (simulate 899 million times)
- Each call: length remains 9
- `NftProtocolNumberFlag` remains 100,000,000 (never updated)
- Check always evaluates to FALSE

**Step 3:** Attempt to create protocol after ~900 million created
- Symbol generation enters infinite loop in do-while trying to find unused number
- Transaction times out
- Protocol creation permanently fails

**Expected vs Actual:**
- **Expected:** Length increases to 10 when space is exhausted, expanding range to 10 billion symbols
- **Actual:** Length permanently stuck at 9, causing DoS after 900 million symbols

**Success Condition for Exploit:** System reaches high symbol usage and Create() calls begin failing/timing out due to collision loops.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-36)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-67)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L68-82)
```csharp
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L87-116)
```csharp
    private int GetCurrentNumberLength()
    {
        if (State.CurrentSymbolNumberLength.Value == 0) State.CurrentSymbolNumberLength.Value = NumberMinLength;

        var flag = State.NftProtocolNumberFlag.Value;

        if (flag == 0)
        {
            // Initial protocol number flag.
            var protocolNumber = 1;
            for (var i = 1; i < State.CurrentSymbolNumberLength.Value; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            flag = protocolNumber;
        }

        var upperNumberFlag = flag.Mul(2);
        if (upperNumberFlag.ToString().Length > State.CurrentSymbolNumberLength.Value)
        {
            var newSymbolNumberLength = State.CurrentSymbolNumberLength.Value.Add(1);
            State.CurrentSymbolNumberLength.Value = newSymbolNumberLength;
            var protocolNumber = 1;
            for (var i = 1; i < newSymbolNumberLength; i++) protocolNumber = protocolNumber.Mul(10);

            State.NftProtocolNumberFlag.Value = protocolNumber;
            return newSymbolNumberLength;
        }

        return State.CurrentSymbolNumberLength.Value;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-20)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
```
