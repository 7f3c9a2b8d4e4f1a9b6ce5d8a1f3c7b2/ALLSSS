### Title
Stale BlockHeight Bypass in SetTransactionFeeDelegations Allows Immediate Use of Updated Delegations

### Summary
The `SetTransactionFeeDelegations()` function fails to update the `BlockHeight` field when modifying existing delegation amounts, while the corresponding security check in `ChargeFromDelegations()` relies on this field to prevent same-block delegation usage. This allows updated delegations to bypass the confirmation period requirement, enabling immediate exploitation in the same block as the update.

### Finding Description

In `SetTransactionFeeDelegations()`, when an existing delegatee's delegation is updated (the else branch starting at line 66), the function modifies delegation amounts but returns success without updating the `BlockHeight` field: [1](#0-0) 

The `BlockHeight` is only set when a NEW delegatee is added (line 54): [2](#0-1) 

However, the security check in `ChargeFromDelegations()` compares `Context.Transaction.RefBlockNumber` with `delegations.BlockHeight` to prevent same-block delegation usage: [3](#0-2) 

This creates an inconsistency: the newer `SetTransactionFeeDelegateInfos()` method correctly updates `BlockHeight` on BOTH add AND update operations: [4](#0-3) 

The protobuf documentation confirms `BlockHeight` tracks "height when added": [5](#0-4) 

Test cases demonstrate the expected behavior requires RefBlockNumber to be at least 2 blocks after delegation creation: [6](#0-5) 

### Impact Explanation

**Operational Impact - Security Control Bypass:**

When a delegator updates an existing delegation (e.g., increasing limits from 100 ELF to 10,000 ELF), the stale `BlockHeight` allows the delegatee to use the increased delegation immediately without the required confirmation period. 

For example:
- Block 100: Delegation created with {ELF: 100}, BlockHeight = 100
- Block 500: Delegation updated to {ELF: 10000}, BlockHeight remains 100
- Block 500: Delegatee can immediately charge 10,000 ELF because RefBlockNumber (498-499) >= 100

This bypasses the intended security mechanism that requires waiting for block confirmation before using delegations. This enables:
1. **Front-running attacks**: Coordinated delegation update + usage in the same block
2. **Atomicity exploitation**: Multi-step attacks that should require multiple blocks can execute atomically
3. **Inconsistent security**: Different behavior between `SetTransactionFeeDelegations` and `SetTransactionFeeDelegateInfos`

While this doesn't directly enable fund theft, it undermines a critical security control designed to prevent same-block manipulation.

### Likelihood Explanation

**Medium Likelihood:**

The vulnerability is triggered through a public method reachable by any delegatee: [7](#0-6) 

Attack requirements:
1. Delegator must update (not create) an existing delegation via `SetTransactionFeeDelegations()`
2. Delegatee submits a transaction using the updated delegation in the same block
3. The delegatee's transaction `RefBlockNumber` only needs to be >= original BlockHeight (not >= current block)

While the delegator controls when to update delegations, exploitation scenarios include:
- Compromised delegator contracts that can be manipulated
- Coordinated attacks between delegator and delegatee
- Race conditions where delegatee monitors for updates

The inconsistency with `SetTransactionFeeDelegateInfos` strongly indicates this is unintended behavior rather than a design choice.

### Recommendation

Update the `SetTransactionFeeDelegations()` function to set `BlockHeight` to current height whenever delegations are modified, consistent with `SetTransactionFeeDelegateInfos()`:

```csharp
// In the else branch (lines 66-98), after updating delegations (line 80), add:
allDelegateesMap[delegateeAddress].BlockHeight = currentHeight;

// Also fire an update event to maintain consistency with SetTransactionFeeDelegateInfos
Context.Fire(new TransactionFeeDelegationUpdated()
{
    Caller = Context.Sender,
    Delegatee = Context.Sender,
    Delegator = input.DelegatorAddress
});
```

Specifically, modify lines 83-90 to: [8](#0-7) 

Add the BlockHeight update before the state save at line 83, and add event firing for the update case similar to lines 92-97.

Add test cases verifying:
1. Updated delegations cannot be used until RefBlockNumber >= new BlockHeight + 2
2. BlockHeight is updated on every delegation modification
3. Behavior matches `SetTransactionFeeDelegateInfos()`

### Proof of Concept

**Initial State:**
- Block 100: Delegator calls `SetTransactionFeeDelegations({Delegations: {ELF: 100}})`
- Result: New delegatee created with BlockHeight = 100

**Attack Sequence:**
1. Block 500: Delegator calls `SetTransactionFeeDelegations({Delegations: {ELF: 10000}})` (update)
   - Expected: BlockHeight should update to 500
   - Actual: BlockHeight remains 100 (bug!)

2. Block 500: Delegatee submits transaction to charge 10,000 ELF fees with RefBlockNumber = 498
   - Security check: `498 < 100` ? No
   - Expected result: Should fail (498 < 500)
   - Actual result: **Succeeds** (498 >= 100)

3. Block 501: Transaction using delegation succeeds immediately without confirmation period

**Success Condition:**
The delegatee successfully charges fees using the updated delegation limits in the same block as the update, bypassing the intended 2+ block confirmation requirement demonstrated in test cases.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L12-13)
```csharp
    public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
        SetTransactionFeeDelegationsInput input)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L54-54)
```csharp
                allDelegateesMap[delegateeAddress].BlockHeight = currentHeight;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L66-91)
```csharp
        else // This delegatee exists, so update
        {
            var delegationsMap = allDelegateesMap[delegateeAddress].Delegations;
            foreach (var (key, value) in delegationsToInput)
            {
                if (value <= 0 && delegationsMap.ContainsKey(key))
                {
                    delegationsMap.Remove(key);
                }
                else if (value > 0)
                {
                    AssertValidToken(key, value);
                    delegationsMap[key] = value;
                }
            }

            // Set and Fire logEvent
            State.TransactionFeeDelegateesMap[input.DelegatorAddress] = allDelegatees;

            // If a delegatee has no delegations, remove it!
            if (allDelegateesMap[delegateeAddress].Delegations.Count != 0)
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = true
                };
            State.TransactionFeeDelegateesMap[input.DelegatorAddress].Delegatees.Remove(delegateeAddress);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L304-304)
```csharp
        existDelegateInfo.BlockHeight = Context.CurrentHeight;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L183-186)
```csharp
        foreach (var (delegatee, delegations) in delegationInfo)
        {
            // compare current block height with the block height when the delegatee added
            if (Context.Transaction.RefBlockNumber < delegations.BlockHeight) continue;
```

**File:** protobuf/token_contract.proto (L661-668)
```text
message TransactionFeeDelegations{
    // delegation, symbols and its' amount
    map<string, int64> delegations = 1;
    // height when added
    int64 block_height = 2;
    //Whether to pay transaction fee continuously
    bool isUnlimitedDelegate = 3;
}
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L751-751)
```csharp
            if (chargeFeeRetDefault.Transaction.RefBlockNumber >= delegationResult.BlockHeight + 2)
```
