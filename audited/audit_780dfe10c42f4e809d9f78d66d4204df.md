# Audit Report

## Title
Cross-Chain Token Creation Bypasses Case-Insensitive Duplicate Check, Enabling Phishing Token Creation

## Summary
The `CrossChainCreateToken` function only performs exact symbol matching when checking for existing tokens, failing to validate against the case-insensitive token existence mapping. This allows attackers to register case-variant tokens (e.g., "TOKEN" and "token") on the same chain by bringing them from different source chains, violating the protocol's token uniqueness guarantee and enabling phishing attacks.

## Finding Description

The AElf MultiToken contract enforces case-insensitive token uniqueness through a dedicated state mapping. The `CheckTokenExists` helper function validates both exact and case-insensitive symbol existence: [1](#0-0) 

During normal token creation via `Create`, this validation is properly enforced: [2](#0-1) 

The `RegisterTokenInfo` function sets both the exact symbol entry and the case-insensitive flag: [3](#0-2) 

However, `CrossChainCreateToken` bypasses this protection by only checking the exact symbol match: [4](#0-3) 

**Attack Scenario:**

1. Legitimate token "TOKEN" exists on Chain A (created via normal `Create` method)
   - `State.TokenInfos["TOKEN"]` is set
   - `State.InsensitiveTokenExisting["TOKEN"]` = true

2. Attacker creates phishing token "token" (lowercase) on Chain B
   - Requires seed NFT or whitelist access on Chain B
   - Successfully creates "token" on Chain B

3. Attacker calls `CrossChainCreateToken` on Chain A with valid merkle proof
   - Line 506 check: `State.TokenInfos["token"] == null` evaluates to true (only exact match)
   - Line 508: `RegisterTokenInfo` is called
   - Sets `State.TokenInfos["token"]` and overwrites `State.InsensitiveTokenExisting["TOKEN"]` = true (no error)

4. Result: Both "TOKEN" and "token" coexist on Chain A, violating the case-insensitive uniqueness invariant

## Impact Explanation

This vulnerability breaks a fundamental security guarantee of the token system:

**Direct User Impact:**
- Users with case-insensitive wallets/UIs may confuse "TOKEN" with "token", leading to incorrect token interactions
- Legitimate "TOKEN" holders could mistakenly approve allowances or transfer funds to the phishing "token"
- dApps performing case-insensitive symbol lookups will exhibit undefined behavior

**Ecosystem Impact:**
- DEX integrations may display incorrect pricing or liquidity for case-variant tokens
- Smart contracts using case-insensitive token matching may operate on wrong tokens
- Erosion of user trust when phishing tokens can exist alongside legitimate ones

**Severity: High** because:
1. Direct fund loss is possible through user confusion and misdirection
2. Undermines the protocol's token uniqueness guarantee
3. Many blockchain UIs normalize token symbols to uppercase, making the exploit invisible to users
4. Attackers can target high-value tokens to maximize phishing impact

## Likelihood Explanation

**Attack Complexity: Medium**

**Prerequisites:**
1. Control over token creation on at least one chain (Chain B) to create the phishing token
   - Requires either seed NFT possession (purchasable) or whitelist access
2. Ability to generate valid cross-chain merkle proofs (standard cross-chain mechanism)

**Feasibility: High**
- Entry point `CrossChainCreateToken` is a public method accessible to any actor
- Cross-chain token creation is a legitimate, documented feature
- Seed NFTs can be obtained through marketplace or direct purchase
- Attack uses standard cross-chain verification flows, making detection difficult

**Economic Rationality:**
- Cost: Seed NFT price + transaction fees on two chains
- Potential gain: Phishing high-value token holders, especially those with large balances
- Attack becomes profitable when targeting tokens with significant holder bases

**Detection Difficulty:**
- Exploit uses legitimate cross-chain mechanisms
- No on-chain alarm triggers since both token creations appear valid
- Users must manually verify exact symbol capitalization (error-prone)

**Likelihood Assessment: Medium to High** - The attack requires cross-chain setup and initial investment in seed NFTs, but is economically rational and technically feasible for motivated attackers targeting valuable tokens.

## Recommendation

Add case-insensitive duplicate checking to `CrossChainCreateToken` before token registration. The function should validate against `State.InsensitiveTokenExisting` similar to the normal creation path:

```csharp
public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
{
    // ... existing validation code ...
    
    var tokenInfo = new TokenInfo
    {
        Symbol = validateTokenInfoExistsInput.Symbol,
        // ... other fields ...
    };
    
    var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
    if (State.TokenInfos[tokenInfo.Symbol] == null)
    {
        // ADD THIS CHECK:
        CheckTokenExists(tokenInfo.Symbol);  // Validates case-insensitive uniqueness
        
        RegisterTokenInfo(tokenInfo);
        // ... rest of token creation logic ...
    }
    // ...
}
```

This ensures consistent case-insensitive validation across all token creation paths (direct and cross-chain).

## Proof of Concept

```csharp
[Fact]
public async Task CrossChainCreateToken_AllowsCaseVariantDuplicates_Test()
{
    const string upperCaseSymbol = "PHISH";
    const string lowerCaseSymbol = "phish";
    
    // Setup: Create token "PHISH" on main chain
    await CreateTokenOnMainChain(upperCaseSymbol);
    
    // Verify "PHISH" exists
    var upperTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = upperCaseSymbol });
    upperTokenInfo.Symbol.ShouldBe(upperCaseSymbol);
    
    // Setup side chain and create lowercase variant "phish" on side chain
    var sideChainId = await GenerateSideChainAsync();
    await RegisterSideChainContractAddressOnMainChainAsync();
    await CreateTokenOnSideChain(lowerCaseSymbol);
    
    // Prepare cross-chain proof to bring "phish" to main chain
    var tokenValidationTx = await CreateTokenValidationTransaction(lowerCaseSymbol);
    var merklePath = GetTransactionMerklePathAndRoot(tokenValidationTx, out var blockRoot);
    await MainAndSideIndexAsync(sideChainId, blockHeight, blockRoot);
    
    var crossChainInput = new CrossChainCreateTokenInput
    {
        FromChainId = sideChainId,
        ParentChainHeight = blockHeight,
        TransactionBytes = tokenValidationTx.ToByteString(),
        MerklePath = merklePath
    };
    
    // VULNERABILITY: CrossChainCreateToken allows "phish" despite "PHISH" existing
    var result = await TokenContractStub.CrossChainCreateToken.SendAsync(crossChainInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // PROOF: Both case variants now exist on main chain
    var lowerTokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(
        new GetTokenInfoInput { Symbol = lowerCaseSymbol });
    lowerTokenInfo.Symbol.ShouldBe(lowerCaseSymbol); // Should FAIL but succeeds
    
    // Case-insensitive uniqueness violated
    upperTokenInfo.ShouldNotBeNull();
    lowerTokenInfo.ShouldNotBeNull();
}
```

## Notes

This vulnerability represents an inconsistency in security enforcement between different token creation paths. While the normal `Create` function properly enforces case-insensitive uniqueness through `CheckTokenExists`, the `CrossChainCreateToken` function relies solely on exact symbol matching. This architectural gap allows the protocol's token uniqueness invariant to be violated through legitimate cross-chain mechanisms.

The issue is particularly severe because:
1. It exploits a standard, documented cross-chain feature
2. The attack leaves no obvious on-chain traces (both tokens appear "valid")
3. Many user interfaces normalize token symbols, making case variants indistinguishable
4. The vulnerability affects all chains in the AElf ecosystem that support cross-chain token transfers

The fix is straightforward: ensure `CrossChainCreateToken` calls `CheckTokenExists` before `RegisterTokenInfo`, maintaining consistent validation across all token registration paths.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L87-88)
```csharp
        CheckTokenExists(tokenInfo.Symbol);
        RegisterTokenInfo(tokenInfo);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L506-508)
```csharp
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
```
