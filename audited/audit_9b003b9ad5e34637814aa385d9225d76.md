# Audit Report

## Title
Inconsistent Vote Counting Allows Governance Bypass Through Member Removal

## Summary
The Association contract contains a critical vote counting inconsistency where rejection/approval votes are filtered by current membership, but the total vote count for `MinimalVoteThreshold` includes all historical votes regardless of membership status. This allows legitimately rejected proposals to become releasable by removing members who voted to reject after voting has occurred.

## Finding Description

The vulnerability exists in the vote threshold validation logic within `IsReleaseThresholdReached()` and its helper methods. [1](#0-0) 

The `IsProposalRejected()` method filters rejection votes to count only those from current organization members using `.Count(organization.OrganizationMemberList.Contains)`. [2](#0-1) 

Similarly, `IsProposalAbstained()` filters abstention votes by current membership. [3](#0-2) 

However, `CheckEnoughVoteAndApprovals()` contains a critical inconsistency. While it correctly filters approval votes by current membership, the total vote count check for `MinimalVoteThreshold` uses `.Count()` on all concatenated votes WITHOUT filtering by membership status. [4](#0-3) 

Members can be removed from an organization via the `RemoveMember()` method, which is callable by the organization itself through proposals. [5](#0-4) 

The `Release()` method enforces these threshold checks before executing any proposal. [6](#0-5) 

Vote lists are permanently stored in `ProposalInfo` as repeated address fields. [7](#0-6) 

**Attack Execution Path:**
1. Organization members cast votes on a controversial proposal
2. Proposal is initially rejected (rejection count > `MaximalRejectionThreshold`)
3. Coalition creates and passes a member removal proposal targeting rejecting members
4. After removal, `IsProposalRejected()` now counts fewer rejections (only current members)
5. `CheckEnoughVoteAndApprovals()` still counts all historical votes toward `MinimalVoteThreshold`
6. Original proposal becomes releasable despite legitimate rejection

## Impact Explanation

**HIGH Severity** - This vulnerability directly undermines the governance security model by allowing rejection threshold bypass.

**Concrete Scenario:**
- Organization: 10 members
- Thresholds: `MinimalVoteThreshold=7`, `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=3`
- Proposal receives: 4 approvals, 4 rejections (8 total votes)
- Status: REJECTED (4 rejections > 3 threshold)
- Attack: Remove 3 rejecting members
- New calculation: 4 approvals (current members), 1 rejection (current member only), 8 total votes (ALL historical)
- Result: Proposal becomes releasable (1 rejection ≤ 3 threshold, 4 approvals ≥ 4 threshold, 8 votes ≥ 7 threshold)

**Broken Invariant:** The "Organization thresholds" governance invariant is violated - proposals that were democratically rejected through proper threshold mechanisms can be executed by post-voting manipulation.

**Affected Parties:** All Association contract organizations, as their rejection/abstention thresholds can be circumvented through strategic member removal after voting completes.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**

**Attacker Requirements:**
- Sufficient voting power to pass member removal proposals
- Coordination between voting on target proposal and removing dissenting members
- No requirement for elevated privileges beyond standard organization membership

**Feasibility:** The attack is deterministic and requires no external dependencies. Both voting and member removal are standard organization operations that appear legitimate individually.

**Realistic Conditions:** 
- Organizations where a coalition controls enough votes for proposals but faces minority opposition
- No time-lock or cooling-off mechanisms prevent sequential proposal execution
- Member management through proposals is an inherent design feature, not a misconfiguration

**Detection Difficulty:** The attack uses authorized operations in their intended manner - the vulnerability lies in the logical inconsistency, not unauthorized access.

## Recommendation

Apply consistent filtering logic across all vote counting methods. The total vote count for `MinimalVoteThreshold` should also filter by current membership:

```csharp
private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
{
    var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
    var isApprovalEnough =
        approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
    if (!isApprovalEnough)
        return false;

    // FIX: Filter total votes by current membership
    var totalCurrentMemberVotes = 
        proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
        proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
        proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
    
    var isVoteThresholdReached =
        totalCurrentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
    return isVoteThresholdReached;
}
```

This ensures all vote counting operates on the same membership snapshot, preventing post-voting manipulation.

## Proof of Concept

```csharp
[Fact]
public async Task GovernanceBypass_ThroughMemberRemoval_Test()
{
    // Setup: 10 members, thresholds designed to require consensus
    var minimalApproveThreshold = 4;
    var minimalVoteThreshold = 7;
    var maximalRejectionThreshold = 3;
    var maximalAbstentionThreshold = 1;
    
    var member1 = Accounts[1].Address;
    var member2 = Accounts[2].Address;
    var member3 = Accounts[3].Address;
    var member4 = Accounts[4].Address;
    var member5 = Accounts[5].Address;
    var member6 = Accounts[6].Address;
    var member7 = Accounts[7].Address;
    var member8 = Accounts[8].Address;
    var member9 = Accounts[9].Address;
    var member10 = Accounts[10].Address;
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { member1, member2, member3, member4, member5, member6, member7, member8, member9, member10 }
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = minimalApproveThreshold,
            MinimalVoteThreshold = minimalVoteThreshold,
            MaximalAbstentionThreshold = maximalAbstentionThreshold,
            MaximalRejectionThreshold = maximalRejectionThreshold
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { member1 } }
    };
    
    var organizationAddress = (await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput)).Output;
    
    // Create controversial proposal
    var proposalId = await CreateProposalAsync(Accounts[1].KeyPair, organizationAddress);
    
    // Vote: 4 approvals, 4 rejections (exceeds MaximalRejectionThreshold of 3)
    await GetAssociationContractTester(Accounts[1].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[2].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[3].KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[4].KeyPair).Approve.SendAsync(proposalId);
    
    await GetAssociationContractTester(Accounts[5].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[6].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[7].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[8].KeyPair).Reject.SendAsync(proposalId);
    
    // Verify proposal is correctly rejected
    var proposalBeforeRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalBeforeRemoval.ToBeReleased.ShouldBeFalse(); // 4 rejections > 3 threshold
    
    // Attack: Remove 3 of the 4 rejecting members through organization proposal
    var orgStub = GetAssociationContractTester(Accounts[1].KeyPair);
    orgStub = await orgStub.SetTransactionSender(organizationAddress);
    await orgStub.RemoveMember.SendAsync(member5);
    await orgStub.RemoveMember.SendAsync(member6);
    await orgStub.RemoveMember.SendAsync(member7);
    
    // Verify vulnerability: Proposal now releasable despite legitimate rejection
    var proposalAfterRemoval = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposalAfterRemoval.ToBeReleased.ShouldBeTrue(); // VULNERABILITY: Now releasable!
    // Rejection count: 1 (only member8 remains) <= 3 threshold
    // Total votes: 8 (all historical) >= 7 threshold
    // Approvals: 4 >= 4 threshold
    
    // Proposal can now be released despite being legitimately rejected
    var releaseResult = await GetAssociationContractTester(Accounts[1].KeyPair).Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

## Notes

This vulnerability affects only the Association contract as analyzed. The Parliament and Referendum contracts should be audited for similar inconsistencies in their respective vote counting implementations. The root cause is an architectural design flaw where historical vote records are maintained but membership filtering is applied inconsistently across different threshold checks.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-39)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L41-45)
```csharp
    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L91-96)
```text
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```
