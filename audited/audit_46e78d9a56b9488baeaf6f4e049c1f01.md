### Title
Denial of Service via Gas Exhaustion in RemoveBeneficiary with Excessive ProfitDetails

### Summary
If a beneficiary has accumulated thousands of ProfitDetails across many periods, the RemoveBeneficiary function—via RemoveProfitDetails—will iterate over all eligible ProfitDetails in a single transaction with no batching or iteration limit. This unbounded loop can easily exceed gas constraints and prevent the successful removal of such a beneficiary, leading to a denial of service.

### Finding Description
- The public RemoveBeneficiary method is accessible to managers and the TokenHolder contract, and calls the private RemoveProfitDetails method to handle the removal of a beneficiary from a profit scheme.  
- RemoveProfitDetails retrieves the entire list of ProfitDetails for the beneficiary and, depending on scheme rules, iterates through **all removable entries** in a single synchronous loop. It sets flags, modifies entries, or removes them from the list, but crucially, there is no hard cap or batching mechanism limiting how many details can be processed per call.  
- With no upper bound, if an attacker or ordinary user accumulates thousands of ProfitDetails (e.g., via repeated AddBeneficiary calls with distinct end periods), RemoveBeneficiary will attempt to process all of those in one transaction. If the number is large, the transaction will exceed gas or step limits and revert, leaving the beneficiary unremovable and causing a persistent DoS condition.
- Unlike ClaimProfits, which has a hard per-call cap and processes ProfitDetails in small batches, RemoveBeneficiary and RemoveProfitDetails have **no such safety net.**

**Relevant Code Locations:**
- RemoveBeneficiary public entry point & direct call to RemoveProfitDetails  
- RemoveProfitDetails iterates all "removable" details for the target, with no controlled batching or limit
- AddBeneficiary allows unbounded accumulation of ProfitDetails per beneficiary (see core loop, old-expired details only cleaned up selectively)

### Impact Explanation
- If the beneficiary collects thousands of ProfitDetails, RemoveBeneficiary is guaranteed to revert due to gas or resource exhaustion on all standard execution environments.  
- This locks that beneficiary in the scheme, threatening accurate share accounting, and potentially interferes with governance or economic flows that rely on timely removal of participants, especially in large-scale or DAO/governance scenarios.
- Severity is medium: This can block governance/economic flows and allow malicious or careless users to disable their own removal, but it does not allow fund theft or direct cross-user impact unless forced removals are business-critical.

### Likelihood Explanation
- The entry point is a public method (RemoveBeneficiary); attacker simply needs to accumulate a large count of ProfitDetails—fully possible with valid contract calls and no rate limits.    
- Complexity is low; no need for privileged access or contract upgrades. Steps are simple, and the attack can be automated.
- Scenario is practical for real attackers or even accidental DoS by high-beneficiary churn inactivity.

### Recommendation
- Batch the removal of ProfitDetails, mirroring the protections of ClaimProfits. Enforce a hard cap (e.g. 10) on the number of ProfitDetails processed per call to RemoveBeneficiary/RemoveProfitDetails.
- Introduce a status indicating partial removal is in progress, and require callers to re-invoke RemoveBeneficiary until all details are processed.
- Add test cases with several thousand details to verify that gas never exhausts, and that eventual progress is always possible, regardless of profit detail accumulation.

### Proof of Concept
**Initial State:**  
- Scheme S has a manager, beneficiary B.  
- B is added as a beneficiary repeatedly with different end periods and/or via automated scripts until B holds several thousand ProfitDetails in S.

**Attack Steps:**  
1. Manager calls RemoveBeneficiary for B in S.
2. RemoveProfitDetails loops over all thousands of ProfitDetails in memory, exceeding gas limit, and transaction reverts.
3. B cannot be removed, no matter how many times RemoveBeneficiary is called.

**Expected Result:**  
Beneficiary B is wholly removed after one call.

**Actual Result:**  
Transaction always fails due to gas, creating a permanent DoS on B's removal from the scheme.

**Success Condition:**  
RemoveBeneficiary for B always reverts when B holds a large number (>1000) ProfitDetails.

---

#### Supporting Evidence (do not reproduce code, cite only): [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3)

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L224-263)
```csharp
    public override Empty RemoveBeneficiary(RemoveBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.Beneficiary != null, "Invalid Beneficiary address.");

        var scheme = State.SchemeInfos[input.SchemeId];

        Assert(scheme != null, "Scheme not found.");

        var currentDetail = State.ProfitDetailsMap[input.SchemeId][input.Beneficiary];

        if (scheme == null || currentDetail == null) return new Empty();

        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");

        var removedDetails = RemoveProfitDetails(scheme, input.Beneficiary, input.ProfitDetailId);

        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }

        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L308-386)
```csharp
    private RemovedDetails RemoveProfitDetails(Scheme scheme, Address beneficiary, Hash profitDetailId = null)
    {
        var removedDetails = new RemovedDetails();

        var profitDetails = State.ProfitDetailsMap[scheme.SchemeId][beneficiary];
        if (profitDetails == null)
        {
            return removedDetails;
        }
        
        // remove all removalbe profitDetails.
        // If a scheme can be cancelled, get all available profitDetail.
        // else, get those available and out of date ones.
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        //id == null
        if (scheme.CanRemoveBeneficiaryDirectly && profitDetailId != null)
        {
            detailsCanBeRemoved = detailsCanBeRemoved.All(d => d.Id != profitDetailId)
                ? detailsCanBeRemoved.Where(d => d.Id == null).ToList()
                : detailsCanBeRemoved.Where(d => d.Id == profitDetailId).ToList();
        }

        // remove the profitDetail with the profitDetailId, and de-duplicate it before involving.
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
        }

        if (detailsCanBeRemoved.Any())
        {
            foreach (var profitDetail in detailsCanBeRemoved)
            {
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
            }

            Context.LogDebug(() => $"ProfitDetails after removing expired details: {profitDetails}");
        }

        var weightCanBeRemoved = profitDetails.Details
            .Where(d => d.EndPeriod == scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        foreach (var profitDetail in weightCanBeRemoved)
        {
            profitDetail.IsWeightRemoved = true;
        }

        var weights = weightCanBeRemoved.Sum(d => d.Shares);
        removedDetails.Add(0, weights);


        // Clear old profit details.
        if (profitDetails.Details.Count != 0)
        {
            State.ProfitDetailsMap[scheme.SchemeId][beneficiary] = profitDetails;
        }
        else
        {
            State.ProfitDetailsMap[scheme.SchemeId].Remove(beneficiary);
        }

        return removedDetails;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L3-10)
```csharp
public class ProfitContractConstants
{
    public const int ProfitReceivingLimitForEachTime = 10;
    public const int DefaultProfitReceivingDuePeriodCount = 10;
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
    public const int TokenAmountLimit = 5;
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
}
```
