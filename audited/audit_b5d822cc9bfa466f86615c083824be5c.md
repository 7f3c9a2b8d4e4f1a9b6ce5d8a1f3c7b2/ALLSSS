### Title
Cross-Chain NFT Protocol Event Data Forgery via Unvalidated ExternalInfo

### Summary
The `CrossChainCreate` function trusts tokenInfo data from cross-chain verified tokens without validating consistency between the NFT type stored in ExternalInfo metadata and the type derived from the symbol prefix. An attacker can create a token on the mainchain with a symbol suggesting one NFT type (e.g., "AR" prefix for Art) while embedding different type metadata in ExternalInfo, causing the sidechain to emit misleading `NFTProtocolCreated` events with inconsistent categorization data.

### Finding Description

The vulnerability exists in the `CrossChainCreate` function where it processes cross-chain NFT protocol registration. [1](#0-0) 

The root cause is a missing validation check. The function:
1. Retrieves tokenInfo from the sidechain's TokenContract (which was populated via verified cross-chain data) [2](#0-1) 
2. Extracts the NFT type short name from the first 2 characters of the symbol [3](#0-2) 
3. Looks up the full type name in the sidechain's local mapping
4. Creates NFTProtocolInfo using the locally-derived type but includes the original ExternalInfo in Metadata [4](#0-3) 
5. Emits an event with both the derived `NftType` field and the original `Metadata` containing ExternalInfo [5](#0-4) 

**Why protections fail:**

The cross-chain verification only ensures data integrity during transfer (merkle proof validation), not semantic correctness. [6](#0-5) 

An attacker can bypass the NFT contract's proper creation flow by creating tokens directly via the TokenContract on the mainchain. The TokenContract's symbol validation only checks alphanumeric format [7](#0-6) , allowing symbols like "AR123456789" that appear to be NFT protocol symbols but don't enforce any correlation with ExternalInfo content.

The NFT contract's `GetTokenExternalInfo` on mainchain properly sets consistent data [8](#0-7) , but this is only used when creating through the NFT contract's `Create` method, not when creating directly via TokenContract.

### Impact Explanation

**Concrete harm:**
- **Event Data Inconsistency**: The `NFTProtocolCreated` event will contain `NftType="Art"` (derived from "AR" prefix) while `Metadata` contains `NftTypeMetadataKey="Music"` (attacker-controlled value)
- **Categorization Manipulation**: NFT indexers, marketplaces, and explorers that parse the `NftType` field will categorize the protocol as one type, while those parsing the `Metadata.NftTypeMetadataKey` will see a different type
- **UI/UX Deception**: End users may be misled about the actual category of NFT protocols
- **Logic Bypass**: If dependent contracts or dApps implement type-specific restrictions or features based on either field, attackers can bypass intended logic by exploiting the inconsistency

**Who is affected:**
- NFT marketplace operators and users relying on protocol categorization
- Indexing services and blockchain explorers
- Third-party contracts that depend on NFT type information from events
- End users making decisions based on displayed NFT categories

**Severity justification (Medium):**
No direct fund loss or critical system compromise occurs, but the integrity of protocol metadata and event data is violated, leading to operational confusion and potential manipulation of type-based business logic across the ecosystem.

### Likelihood Explanation

**Attacker capabilities:**
- Must obtain a seed NFT to create tokens on the mainchain (or be in the create whitelist) [9](#0-8) 
- Seed NFTs are available through normal acquisition means and represent a reasonable economic cost
- No special privileges beyond normal token creation access required

**Attack complexity:**
1. Acquire seed NFT on mainchain
2. Call `TokenContract.Create()` directly with:
   - Symbol: "AR123456789" (or any pattern matching NFT protocol format)
   - ExternalInfo containing misleading `NftTypeMetadataKey`, `NftBaseUriMetadataKey`, etc.
3. Call `ValidateTokenInfoExists` to prepare cross-chain transfer
4. Index the transaction and generate merkle proof
5. Call `CrossChainCreateToken` on sidechain with valid proof
6. Call `NFTContract.CrossChainCreate` on sidechain
7. Observe inconsistent event emission

**Feasibility:** 
All steps are straightforward and executable within normal AElf contract semantics. The cross-chain verification will succeed because the data integrity is maintained (merkle proofs are valid); only the semantic consistency is violated.

**Detection constraints:**
The attack produces valid transactions and events; only careful comparison of the `NftType` field against `Metadata` content reveals the inconsistency.

### Recommendation

**Code-level mitigation:**

Add validation in `CrossChainCreate` after line 90 to verify consistency between the stored metadata and derived type:

```csharp
var nftTypeShortName = input.Symbol.Substring(0, 2);
var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
if (nftTypeFullName == null)
    throw new AssertionException(
        $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

// ADD THIS VALIDATION:
if (tokenInfo.ExternalInfo.Value.ContainsKey(NftTypeMetadataKey))
{
    var storedNftType = tokenInfo.ExternalInfo.Value[NftTypeMetadataKey];
    Assert(storedNftType == nftTypeFullName, 
        $"NFT type mismatch: symbol prefix indicates {nftTypeFullName} but metadata contains {storedNftType}");
}
```

**Invariant checks to add:**
- `tokenInfo.ExternalInfo[NftTypeMetadataKey] == nftTypeFullName` must hold when both values exist
- The first 2 characters of the symbol must correspond to the NFT type stored in ExternalInfo

**Test cases to prevent regression:**
1. Attempt cross-chain creation with mismatched symbol prefix ("AR") and ExternalInfo type ("Music") - should fail
2. Verify legitimate cross-chain creations with matching data continue to work
3. Test edge cases where ExternalInfo keys are missing or malformed
4. Validate that only properly created mainchain NFT protocols can be cross-chained

### Proof of Concept

**Initial state:**
- Attacker has acquired a seed NFT on mainchain
- Both mainchain and sidechain have standard NFT type mappings (AR→Art, MU→Music, etc.)

**Transaction sequence:**

1. **Mainchain - Create malicious token:**
   ```
   Call: TokenContract.Create()
   Input: {
     Symbol: "AR123456789",
     TokenName: "Fake Protocol",
     ExternalInfo: {
       "aelf_nft_type": "Music",           // Mismatched!
       "aelf_nft_base_uri": "http://evil.com",
       "aelf_nft_token_id_reuse": "True"
     }
   }
   ```

2. **Mainchain - Prepare for cross-chain:**
   ```
   Call: TokenContract.ValidateTokenInfoExists()
   Input: { Symbol: "AR123456789" }
   ```

3. **Cross-chain indexing:**
   - Wait for transaction inclusion in merkle tree
   - Generate merkle proof

4. **Sidechain - Register token:**
   ```
   Call: TokenContract.CrossChainCreateToken()
   Input: { TransactionBytes, MerklePath, ParentChainHeight, FromChainId }
   Result: Token registered on sidechain with ExternalInfo intact
   ```

5. **Sidechain - Create NFT protocol:**
   ```
   Call: NFTContract.CrossChainCreate()
   Input: { Symbol: "AR123456789" }
   ```

**Expected result (vulnerable):**
Event emitted:
```
NFTProtocolCreated {
  Symbol: "AR123456789",
  NftType: "Art",                          // From symbol prefix "AR"
  Metadata: {
    "aelf_nft_type": "Music",              // Inconsistent!
    "aelf_nft_base_uri": "http://evil.com",
    ...
  }
}
```

**Success condition:**
The event contains inconsistent type information where `NftType` field shows "Art" but `Metadata["aelf_nft_type"]` contains "Music", demonstrating successful event data forgery.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L184-201)
```csharp
    private ExternalInfo GetTokenExternalInfo(CreateInput input)
    {
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var tokenExternalInfo = input.Metadata == null
            ? new ExternalInfo()
            : new ExternalInfo
            {
                Value = { input.Metadata.Value }
            };

        // Add NFT Type to external info.
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
        return tokenExternalInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L56-65)
```csharp
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L28-31)
```csharp

```
