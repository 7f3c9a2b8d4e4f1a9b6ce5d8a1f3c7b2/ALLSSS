# Audit Report

## Title
Predictable NFT Symbol Generation Allows Miner Manipulation via Known Block Height Random Seed

## Summary
The NFT contract's `GenerateSymbolNumber()` function uses a random seed from the previous block (H-1) that is already publicly stored on-chain when miners are building block H. This allows miners to predict the exact NFT symbol that will be generated for any pending transaction and selectively censor, delay, or front-run transactions to monopolize valuable NFT symbols.

## Finding Description

The vulnerability exists in the NFT symbol generation mechanism where the random seed is deterministic and known before transaction inclusion decisions are made.

When the `Create` method is called to create a new NFT protocol, it invokes `GetSymbol`, which calls `GenerateSymbolNumber()`. [1](#0-0)  This function retrieves random bytes using the block height from the previous block: [2](#0-1) 

The random hash for height H-1 is generated and stored during the consensus transaction execution of block H-1, using EC-VRF verification: [3](#0-2) 

The random hash is stored in `State.RandomHashes`, which is a public mapping accessible through the `GetRandomHash` view method: [4](#0-3) [5](#0-4) 

The block execution order confirms that system transactions (including consensus transactions that store random hashes) execute before user transactions: [6](#0-5) 

**Root Cause**: When a miner is building block H, the random hash for H-1 has already been finalized and stored on-chain during H-1's execution. The symbol generation deterministically combines this known random hash with the known sender address: [7](#0-6) 

The conversion to a numeric symbol is also deterministic: [8](#0-7) 

This makes the outcome 100% predictable to miners before they commit to including the transaction.

**Attack Scenario**:
1. User Alice submits an NFT Create transaction to the mempool
2. Miner Bob is building block H
3. Bob reads `State.RandomHashes[H-1]` from chain state (publicly available)
4. Bob simulates Alice's transaction: `symbol = Hash(Alice.Address, RandomHash[H-1])`
5. If the symbol is valuable (e.g., "AR0001"), Bob can:
   - Exclude Alice's transaction from block H
   - Submit his own transaction to claim that symbol
   - Front-run by submitting a competing transaction

## Impact Explanation

**Direct Impact**:
- **Unfair Symbol Allocation**: Certain NFT symbols have inherently higher value (e.g., lower numbers like "AR0001" vs "AR9999", patterns, memorable sequences). Miners can monopolize these valuable symbols for themselves or allies.
- **Censorship Attack**: Miners can indefinitely delay transactions that would generate desirable symbols, preventing legitimate users from obtaining them.
- **Front-Running**: Miners can observe pending NFT creation transactions, identify which would generate valuable symbols, and submit their own transactions to claim those symbols first.

**Who Is Affected**:
- All users attempting to create NFT protocols via the `Create` method
- The NFT protocol's fairness and market integrity
- Users lose the ability to fairly compete for desirable symbols

**Severity Justification**: HIGH severity because:
1. Miners have complete predictability and control over symbol assignment
2. Attack is passive (requires only transaction simulation)
3. Strong economic incentive exists when certain symbols have higher market value
4. Users cannot defend against this manipulation
5. No on-chain detection mechanism exists

## Likelihood Explanation

**Attacker Capabilities**: 
- Only requires being a block producer (miner) in the AEDPoS consensus
- No special privileges beyond normal mining capabilities
- Attack is passive observation and transaction selection

**Attack Complexity**: LOW
- Miners can trivially simulate NFT creation transactions before including them
- Random hash for H-1 is publicly readable via `GetRandomHash` view method
- No complex cryptographic attacks or state manipulation required
- Simple calculation: `symbol = ConvertHashToInt64(Hash(Sender, RandomBytes[H-1]))`

**Feasibility Conditions**:
- Happens naturally during normal block production
- No additional setup or preconditions needed
- Works on every block where NFT creation transactions are present
- Economic incentive aligns with rational miner behavior

**Detection/Operational Constraints**:
- Censorship appears as normal transaction pool dynamics
- Front-running is observable but not provably malicious
- No on-chain evidence of manipulation
- Victims cannot distinguish between network congestion and intentional censorship

**Probability**: HIGH - Any rational profit-seeking miner will exploit this when valuable symbols are available, especially for patterns that command premium market prices.

## Recommendation

Implement a commit-reveal scheme for NFT symbol generation to prevent miners from predicting symbols before transaction inclusion:

**Solution 1: Commit-Reveal Scheme**
1. User first submits a commit transaction with `Hash(nonce, input)` 
2. After commit is included (e.g., 5 blocks later), user submits reveal transaction with actual `nonce` and `input`
3. Symbol is generated using: `Hash(Sender, RandomHash[reveal_block_height - 1], nonce)`

**Solution 2: Use Future Block Hash**
Instead of using H-1, use a future block hash (e.g., H+N where N > 0):
1. Store creation request at block H with inputs
2. Finalize symbol generation at block H+N using `RandomHash[H+N-1]`
3. This ensures miners cannot predict the symbol when deciding to include the initial request

**Solution 3: Combine Multiple Block Hashes**
Use multiple recent block hashes to increase unpredictability:
```csharp
var randomHash = HashHelper.ConcatAndCompute(
    State.RandomNumberProviderContract.GetRandomBytes(Context.CurrentHeight.Sub(1)),
    State.RandomNumberProviderContract.GetRandomBytes(Context.CurrentHeight.Sub(2)),
    HashHelper.ComputeFrom(Context.TransactionId) // Add transaction ID for uniqueness
);
```

## Proof of Concept

```csharp
// Miner's simulation code to predict NFT symbol before including transaction
public string PredictNFTSymbol(Address sender, long currentHeight)
{
    // 1. Read publicly available random hash for H-1
    var randomBytes = consensusContract.GetRandomBytes(currentHeight - 1);
    
    // 2. Calculate deterministic symbol (same logic as GenerateSymbolNumber)
    var randomHash = HashHelper.ConcatAndCompute(
        HashHelper.ComputeFrom(sender),
        HashHelper.ComputeFrom(randomBytes)
    );
    
    var length = 4; // Assume current length is 4
    var from = 1000L;
    var to = 10000L;
    
    var symbolNumber = ConvertHashToInt64(randomHash, from, to);
    
    // 3. Determine if symbol is valuable
    return $"AR{symbolNumber}"; // e.g., "AR0001" is valuable
}

// Miner's transaction selection logic
public List<Transaction> SelectTransactionsForBlock(List<Transaction> pendingTxs)
{
    var selectedTxs = new List<Transaction>();
    
    foreach (var tx in pendingTxs)
    {
        if (tx.MethodName == "Create" && tx.To == NFTContractAddress)
        {
            var sender = tx.From;
            var predictedSymbol = PredictNFTSymbol(sender, Context.CurrentHeight);
            
            // Censor transactions that would generate valuable symbols
            if (IsValuableSymbol(predictedSymbol))
            {
                // Don't include this transaction - claim the symbol ourselves later
                continue;
            }
        }
        
        selectedTxs.Add(tx);
    }
    
    return selectedTxs;
}
```

## Notes

This vulnerability fundamentally breaks the fairness assumption of NFT symbol allocation. While the collision check ensures uniqueness, it does nothing to prevent miners from gaming the system. The predictability window exists because the random seed (block H-1's hash) is finalized and publicly readable before miners make transaction inclusion decisions for block H.

Additionally, there is a secondary bug in the collision handling loop that would cause an infinite loop if a collision occurs, since the same `randomHash` is used repeatedly without modification. [9](#0-8)

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L20-20)
```csharp
        var symbol = GetSymbol(input.NftType);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L71-74)
```csharp
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L75-77)
```csharp
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L79-82)
```csharp
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L53-53)
```csharp
    public MappedState<long, Hash> RandomHashes { get; set; }
```

**File:** src/AElf.Kernel/Miner/Application/MiningService.cs (L65-78)
```csharp
            var systemTransactions = await GenerateSystemTransactions(requestMiningDto.PreviousBlockHash, requestMiningDto.PreviousBlockHeight);
            
            _systemTransactionExtraDataProvider.SetSystemTransactionCount(systemTransactions.Count,
                block.Header);
            
            var txTotalCount = transactions.Count + systemTransactions.Count;

            var pending = txTotalCount > requestMiningDto.TransactionCountLimit
                ? transactions
                    .Take(requestMiningDto.TransactionCountLimit - systemTransactions.Count)
                    .ToList()
                : transactions;
            var blockExecutedSet = await _blockExecutingService.ExecuteBlockAsync(block.Header,
                systemTransactions, pending, cts.Token);
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-177)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
```
