### Title
Sandwich Attack Vulnerability in Treasury Donation Token Conversion Due to Missing Slippage Protection

### Summary
The Treasury contract's `Donate()` function converts non-native tokens to native tokens without slippage protection, allowing attackers to perform sandwich attacks through price manipulation on the Bancor-based TokenConverter. This results in the Treasury receiving fewer native tokens than expected, directly reducing funds available for protocol rewards and distributions.

### Finding Description

The vulnerability exists in the token conversion flow when users donate non-native tokens to the Treasury: [1](#0-0) 

When a non-native token that can be exchanged is donated, the contract calls `ConvertToNativeToken()`: [2](#0-1) 

The `ConvertToNativeToken()` function calls `TokenConverterContract.Sell()` with only the `Symbol` and `Amount` parameters, crucially omitting the `ReceiveLimit` parameter that provides slippage protection: [3](#0-2) 

The TokenConverter's `Sell` function accepts a `ReceiveLimit` parameter for slippage protection: [4](#0-3) 

The slippage check in the Sell implementation only enforces protection when `ReceiveLimit` is non-zero: [5](#0-4) 

When `ReceiveLimit` is not set (defaults to 0 in protobuf3), the check `input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit` always passes, providing no slippage protection.

The TokenConverter uses Bancor pricing where prices change based on connector balances: [6](#0-5) 

Additionally, the Treasury contract is exempt from converter fees, while attackers pay the standard fee: [7](#0-6) 

### Impact Explanation

**Direct Financial Loss to Protocol:**
- The Treasury receives fewer native tokens than the fair market rate during donation conversions
- Lost funds reduce the total amount available for distribution to miners, voters, and citizens through the profit schemes
- The impact scales with donation size - larger donations suffer greater absolute losses

**Affected Parties:**
- Treasury profit schemes: reduced funding for MinerReward, Subsidy, and Welfare distributions
- Miners: reduced basic rewards, welcome rewards, and flexible rewards
- Voters/Citizens: reduced welfare distributions
- Protocol sustainability: long-term reduction in incentive mechanisms

**Severity Justification:**
The vulnerability enables direct value extraction from protocol funds without requiring any privileged access. Test cases confirm that donating non-native tokens is an intended feature: [8](#0-7) 

### Likelihood Explanation

**Reachable Entry Point:**
The `Donate()` function is public and can be called by any address. The vulnerability triggers whenever a non-native token that can be exchanged is donated.

**Attacker Capabilities:**
- Attacker needs sufficient capital to manipulate the Bancor connector price (achievable for resource tokens with moderate liquidity)
- Attacker needs ability to order transactions (standard capability in blockchain systems)
- No special privileges or insider access required

**Economic Viability:**
- Attacker pays 1% total fees (0.5% on sell + 0.5% on buy)
- If the donation size creates price impact > 1%, the attack is profitable
- For donations of significant size (e.g., 100+ tokens), the price impact on Bancor curves typically exceeds this threshold

**Execution Practicality:**
AElf uses scheduled block production where the current block producer can order transactions within their block. This creates standard MEV (Miner Extractable Value) opportunities for sandwich attacks. No special AElf-specific constraints prevent this attack pattern.

**Detection Difficulty:**
The attack appears as normal trading activity around donation transactions, making it difficult to distinguish from legitimate market activity.

### Recommendation

**Primary Fix - Add Slippage Protection:**

Modify `ConvertToNativeToken()` to calculate and enforce a minimum acceptable output:

1. Before calling Sell, query the current price to estimate expected output
2. Apply a configurable slippage tolerance (e.g., 1-5%)
3. Pass the calculated minimum as `ReceiveLimit` in the SellInput

```csharp
private void ConvertToNativeToken(string symbol, long amount)
{
    // Get expected output amount from connector
    var pairConnector = State.TokenConverterContract.GetPairConnector.Call(
        new TokenSymbol { Symbol = symbol });
    
    var expectedOutput = BancorHelper.GetReturnFromPaid(
        GetConnectorBalance(pairConnector.ResourceConnector),
        GetWeight(pairConnector.ResourceConnector),
        GetConnectorBalance(pairConnector.DepositConnector),
        GetWeight(pairConnector.DepositConnector),
        amount
    );
    
    // Apply slippage tolerance (e.g., 2%)
    var minOutput = expectedOutput * 98 / 100;
    
    State.TokenContract.Approve.Send(new ApproveInput
    {
        Spender = State.TokenConverterContract.Value,
        Symbol = symbol,
        Amount = amount
    });

    State.TokenConverterContract.Sell.Send(new SellInput
    {
        Symbol = symbol,
        Amount = amount,
        ReceiveLimit = minOutput  // Add slippage protection
    });

    Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
    {
        Symbol = Context.Variables.NativeSymbol
    });
}
```

**Additional Recommendations:**
- Add a configurable slippage tolerance parameter that can be adjusted by governance
- Emit events that include expected vs actual conversion rates for monitoring
- Add integration tests that verify slippage protection rejects unfavorable conversions

### Proof of Concept

**Initial State:**
- TokenConverter has connector pair: TOKEN_X â†” ELF
- Connector balances: 10,000 TOKEN_X and 10,000 ELF (for simplicity)
- User holds 1,000 TOKEN_X and wants to donate to Treasury

**Attack Sequence:**

1. **User Transaction Submitted:**
   - User calls `Donate(symbol: "TOKEN_X", amount: 1000)`
   - Transaction visible in mempool

2. **Attacker Front-Run:**
   - Attacker calls `TokenConverter.Sell(symbol: "TOKEN_X", amount: 5000)`
   - Connector state becomes: 15,000 TOKEN_X, ~6,667 ELF
   - Price per TOKEN_X drops significantly

3. **Treasury Donation Executes:**
   - Treasury calls `ConvertToNativeToken("TOKEN_X", 1000)` 
   - Sells at manipulated price with no ReceiveLimit check
   - Receives ~400 ELF instead of expected ~500 ELF (20% loss)
   - Treasury loses 100 ELF in value

4. **Attacker Back-Run:**
   - Attacker calls `TokenConverter.Buy(symbol: "TOKEN_X", amount: 5000)`
   - Restores connector state (minus 1% fees)
   - Attacker profits: 100 ELF loss to Treasury - 50 ELF in fees = 50 ELF profit

**Expected Result:** Treasury receives ~500 ELF (fair market rate)

**Actual Result:** Treasury receives ~400 ELF (manipulated rate), losing 100 ELF to sandwich attack

**Success Condition:** Attacker's profit (Treasury's loss minus fees) > 0, which holds for sufficiently large donations relative to connector liquidity.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L204-208)
```csharp
        var needToConvert = !isNativeSymbol && canExchangeWithNativeSymbol;
        if (needToConvert)
        {
            ConvertToNativeToken(input.Symbol, input.Amount);
        }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L667-686)
```csharp
    private void ConvertToNativeToken(string symbol, long amount)
    {
        State.TokenContract.Approve.Send(new ApproveInput
        {
            Spender = State.TokenConverterContract.Value,
            Symbol = symbol,
            Amount = amount
        });

        State.TokenConverterContract.Sell.Send(new SellInput
        {
            Symbol = symbol,
            Amount = amount
        });

        Context.SendInline(Context.Self, nameof(DonateAll), new DonateAllInput
        {
            Symbol = Context.Variables.NativeSymbol
        });
    }
```

**File:** protobuf/token_converter_contract.proto (L135-143)
```text
message SellInput {
    // The token symbol you want to sell.
    string symbol = 1;
    // The amount you want to sell.
    int64 amount = 2;
    // Limits on tokens obtained by selling. If the token obtained is less than this value, the sale will be abandoned.
    // And 0 is no limit.
    int64 receive_limit = 3;
}
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L161-183)
```csharp
    public override Empty Sell(SellInput input)
    {
        var fromConnector = State.Connectors[input.Symbol];
        Assert(fromConnector != null, "[Sell]Can't find from connector.");
        Assert(fromConnector.IsPurchaseEnabled, "can't purchase");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[Sell]Can't find to connector.");
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );

        var fee = Convert.ToInt64(amountToReceive * GetFeeRate());

        if (Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName)) fee = 0;

        var amountToReceiveLessFee = amountToReceive.Sub(fee);
        Assert(input.ReceiveLimit == 0 || amountToReceiveLessFee >= input.ReceiveLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L23-54)
```csharp
    /// <summary>
    ///     Get token return:
    ///     Return = (1 - (fromConnectorBalance / (fromConnectorBalance + paidAmount))
    ///     ^(fromConnectorWeight/toConnectorWeight))*toConnectorBalance
    /// </summary>
    /// <param name="fromConnectorBalance"></param>
    /// <param name="fromConnectorWeight"></param>
    /// <param name="toConnectorBalance"></param>
    /// <param name="toConnectorWeight"></param>
    /// <param name="paidAmount"></param>
    /// <returns></returns>
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** test/AElf.Contracts.EconomicSystem.Tests/BVT/DonateTests.cs (L89-108)
```csharp
    public async Task Donate_FewOtherToken_Success_Test()
    {
        await InitialBuildConnector(EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol);
        var keyPair = CoreDataCenterKeyPairs[0];
        await TransferToken(keyPair, EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol, 100);
        var stub = GetTreasuryContractTester(keyPair);
        var donateResult = await stub.Donate.SendAsync(new DonateInput
        {
            Symbol = EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol,
            Amount = 50
        });
        donateResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var userBalance = (await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Address.FromPublicKey(keyPair.PublicKey),
            Symbol = EconomicSystemTestConstants.TransactionFeeChargingContractTokenSymbol
        })).Balance;
        userBalance.ShouldBe(50);
    }
```
