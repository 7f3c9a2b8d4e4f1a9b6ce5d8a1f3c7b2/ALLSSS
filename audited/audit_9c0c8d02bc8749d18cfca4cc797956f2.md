### Title
NFT Contract ACS1 Implementation Completely Non-Functional - Governance Cannot Adjust Method Fees

### Summary
The NFT contract's `SetMethodFee()` and `ChangeMethodFeeController()` methods are stub implementations that perform no operations and store no state. [1](#0-0)  This creates permanent state divergence where governance proposals to adjust fees appear to succeed but have zero effect, while `GetMethodFee()` returns hardcoded values instead of stored state. [2](#0-1)  Parliament governance is completely blocked from adjusting NFT contract method fees despite the ACS1 standard interface suggesting this capability.

### Finding Description

**Location:** `contract/AElf.Contracts.NFT/NFTContract_ACS1.cs`

**Root Cause:** The NFT contract lacks the required state storage properties for ACS1 implementation. Examining the state definition reveals no `TransactionFees` or `MethodFeeController` state properties. [3](#0-2) 

**Comparison with Proper Implementation:** All other system contracts implement ACS1 correctly with authorization checks, token validation, and state storage. For example, the Association contract properly validates inputs, checks sender authority, and stores fees in state. [4](#0-3)  It also retrieves fees from stored state rather than hardcoded values. [5](#0-4) 

**Why Protections Fail:** The NFT contract provides no authorization checks, performs no state mutations, and lacks the state infrastructure to store fee configuration. When Parliament attempts to adjust fees through governance proposals, the transaction succeeds but the internal state remains unchanged.

**Execution Path:** When transaction fees are charged, the Token contract queries `GetMethodFee()` on the target contract. [6](#0-5)  For the NFT contract, this returns hardcoded 100 ELF for the Create method regardless of any SetMethodFee calls.

### Impact Explanation

**Governance Authority Violation:** Parliament's default organization cannot exercise its expected authority to manage method fees for the NFT contract, violating the "Authorization & Governance - method-fee provider authority" invariant. This breaks the uniform governance model across all AElf system contracts.

**Economic Rigidity:** The Create method is permanently fixed at 100 ELF (100,000,000,000 smallest units). [7](#0-6)  If ELF price appreciates significantly (e.g., 10x-100x), the fee becomes prohibitively expensive with no governance mechanism to reduce it, effectively DoS'ing NFT protocol creation.

**State Divergence:** External observers (including auditors, governance participants, and monitoring tools) see successful `SetMethodFee` transactions but the contract's actual behavior never changes. This creates a false sense of governance control and makes the system unpredictable.

**Protocol Evolution Blocked:** New economic models, fee reductions for specific NFT types, or zero-fee periods for ecosystem growth cannot be implemented through governance, requiring contract upgrades for what should be routine parameter adjustments.

### Likelihood Explanation

**Certainty of Occurrence:** This is not a probabilistic vulnerability - the governance denial occurs with 100% certainty on every `SetMethodFee` attempt. The methods are publicly callable and any governance proposal will execute successfully while achieving nothing.

**No Attack Complexity:** Any address can call `SetMethodFee` directly (no authorization check exists anyway), demonstrating the broken state. Governance proposals follow standard Parliament procedures but have zero effect.

**Economic Conditions:** As ELF's value fluctuates in external markets, the fixed 100 ELF fee will inevitably become either too expensive (suppressing NFT creation) or too cheap (during bear markets). The protocol has no mechanism to adapt.

**Detection:** The issue is immediately visible by comparing the NFT contract's implementation against all other system contracts' ACS1 implementations, or by attempting any fee adjustment through governance.

### Recommendation

**1. Add Required State Properties:**
```csharp
// In NFTContractState.cs, add:
public MappedState<string, MethodFees> TransactionFees { get; set; }
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**2. Implement SetMethodFee Properly:**
Follow the standard pattern used by all other system contracts - validate tokens, check authorization against MethodFeeController, and store fees in TransactionFees state. Reference the Association contract implementation as the template. [4](#0-3) 

**3. Implement GetMethodFee from State:**
Return stored state rather than hardcoded values, with the current 100 ELF as the default initialization value. [5](#0-4) 

**4. Implement ChangeMethodFeeController:**
Add proper authorization checks and organization validation. [8](#0-7) 

**5. Add Test Coverage:**
Create comprehensive tests for SetMethodFee authorization, fee storage/retrieval, and controller changes, following patterns from Parliament and Association contract tests.

### Proof of Concept

**Initial State:**
- NFT contract deployed with hardcoded 100 ELF fee for Create method
- Parliament default organization is the expected fee controller

**Exploitation Steps:**

1. **Query Current Fee:**
   ```
   GetMethodFee("Create") → Returns 100 ELF (hardcoded)
   ```

2. **Attempt Governance Fee Change via Parliament Proposal:**
   - Create proposal to call SetMethodFee with new fee of 10 ELF
   - Get miner approvals
   - Release proposal
   - Execute SetMethodFee(MethodFees { MethodName: "Create", Fees: [{ Symbol: "ELF", BasicFee: 1000000000 }]})
   - Transaction succeeds with Empty return

3. **Verify State Divergence:**
   ```
   GetMethodFee("Create") → Still returns 100 ELF (unchanged)
   ```

4. **Verify Fee Charging:**
   - Call Create() method for NFT protocol
   - Fee charged is still 100 ELF, confirming governance had no effect

**Expected vs Actual:**
- **Expected:** After step 2, GetMethodFee returns 10 ELF and subsequent Create calls charge 10 ELF
- **Actual:** GetMethodFee still returns 100 ELF and Create charges 100 ELF - governance proposal was ineffective

**Success Condition:** The fee remains at 100 ELF despite successful governance proposal execution, proving governance authority is denied.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
﻿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L34-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        return State.TransactionFees[input.Value];
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-39)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
```
