# Audit Report

## Title
Zero Virtual Balance in AddPairConnector Causes Permanent Connector Failure

## Summary
The `AddPairConnector()` function does not validate that `NativeVirtualBalance` is greater than zero, allowing creation of deposit connectors with zero virtual balance. When combined with tokens having low circulation, `EnableConnector()` can succeed with zero deposit, resulting in a connector with both zero virtual and deposit balances. This causes all subsequent `Buy()` and `Sell()` operations to fail permanently, as `UpdateConnector()` cannot fix enabled connectors.

## Finding Description

The TokenConverter contract implements a Bancor-based token exchange mechanism where each trading pair consists of a resource connector and a deposit connector. The vulnerability stems from insufficient validation in the connector creation and enabling flow.

**Step 1: Unvalidated Connector Creation**

The `AddPairConnector()` method creates a deposit connector without validating the `NativeVirtualBalance` parameter: [1](#0-0) 

The method sets `VirtualBalance = input.NativeVirtualBalance` without checking if it's positive. Only the weight parameter is validated through `AssertValidConnectorWeight()` which checks if weight is between 0 and 1. [2](#0-1) 

**Step 2: Zero Deposit Enablement**

When `EnableConnector()` is invoked, it calculates the required deposit via `GetNeededDeposit()`: [3](#0-2) 

If `amountOutOfTokenConvert <= 0` (meaning all tokens are already in the contract or being converted), the BancorHelper calculation is skipped and `needDeposit` remains zero. This allows `EnableConnector()` to succeed with zero deposit: [4](#0-3) 

The deposit balance is set to zero and both connectors are marked as enabled.

**Step 3: Permanent Buy/Sell Failure**

When `Buy()` or `Sell()` operations are invoked, they call `GetSelfBalance()` for both connectors: [5](#0-4) 

For a deposit connector with `VirtualBalance = 0` and `DepositBalance = 0`, this returns `0 + 0 = 0`. This zero balance is then passed to BancorHelper methods, which explicitly validate against zero balances: [6](#0-5) [7](#0-6) 

Both methods throw an `InvalidValueException` with the message "Connector balance needs to be a positive number."

**Step 4: No Recovery Mechanism**

The `UpdateConnector()` method explicitly prevents updating activated connectors: [8](#0-7) 

Once a connector is enabled (`IsPurchaseEnabled = true`), it cannot be updated or disabled through any available contract methods, leaving the connector permanently broken.

## Impact Explanation

This vulnerability causes **critical denial of service** with the following impacts:

1. **Permanent Operational Failure**: All `Buy()` and `Sell()` operations for the affected connector pair permanently fail with "Connector balance needs to be a positive number". Users cannot convert between the resource token and base token.

2. **No Recovery Path**: The connector cannot be disabled or updated after activation. The only recovery mechanism is a full contract upgrade, which is a complex governance operation requiring significant time and coordination.

3. **Liquidity Lockup**: Any tokens already held by the converter contract for this pair become effectively locked, as trading cannot occur. This impacts protocol liquidity and user funds.

4. **Protocol Integrity Violation**: The connector becomes dead code that cannot fulfill its intended Bancor pricing mechanism, violating the core invariant that enabled connectors should support trading.

The severity is **CRITICAL** because:
- The failure is permanent and irreversible without contract upgrade
- It affects core protocol functionality (token conversion)
- It can occur through honest admin configuration error
- No emergency recovery mechanism exists in the contract

## Likelihood Explanation

The vulnerability has **HIGH likelihood** of occurrence:

1. **Reachable Entry Point**: `AddPairConnector()` is accessible to the connector controller (governance/Parliament by default), making it a legitimate administrative operation.

2. **Feasible Preconditions**:
   - Admin mistakenly sets `NativeVirtualBalance = 0` during connector creation
   - Token has low or zero circulation outside the converter contract
   - `EnableConnector()` is called with sufficient `AmountToTokenConvert`

3. **Lack of Safeguards**:
   - No validation warnings or checks during connector creation
   - The test suite uses a default value of 100 million and does not cover the zero case: [9](#0-8) 

4. **Detection Difficulty**: The issue only manifests after enabling, not during creation. An administrator could successfully create and enable the connector, only discovering the problem when users attempt to trade.

5. **Realistic Scenario**: This represents a genuine configuration error scenario that could occur during routine administrative operations, rather than requiring malicious intent.

## Recommendation

Add validation to ensure `NativeVirtualBalance` is greater than zero in the `AddPairConnector()` method:

```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    AssertPerformedByConnectorController();
    Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
        "resource token symbol should not be empty");
    Assert(input.NativeVirtualBalance > 0, 
        "Native virtual balance must be greater than zero");
    // ... rest of the method
}
```

Additionally, consider adding a validation in `EnableConnector()` to prevent enabling connectors that would result in zero total balance:

```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    // ... existing code ...
    var needDeposit = GetNeededDeposit(input);
    Assert(toConnector.VirtualBalance + needDeposit.NeedAmount > 0,
        "Total connector balance must be positive before enabling");
    // ... rest of the method
}
```

Finally, implement a mechanism to disable or recover broken connectors, even after they have been enabled, for emergency situations.

## Proof of Concept

```csharp
[Fact]
public async Task ZeroVirtualBalance_Causes_Permanent_Connector_Failure()
{
    // Step 1: Create token with minimal supply
    var tokenSymbol = "ZERO";
    await CreateTokenAsync(tokenSymbol, totalSupply: 1000);
    
    // Step 2: Add connector pair with zero native virtual balance
    var pairConnector = new PairConnectorParam
    {
        ResourceConnectorSymbol = tokenSymbol,
        ResourceWeight = "0.5",
        NativeWeight = "0.5",
        NativeVirtualBalance = 0  // Zero virtual balance - no validation!
    };
    
    await ExecuteProposalForParliamentTransaction(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.AddPairConnector),
        pairConnector);
    
    // Step 3: Transfer all tokens to converter and enable
    await TokenContractStub.Approve.SendAsync(new ApproveInput
    {
        Symbol = tokenSymbol,
        Spender = TokenConverterContractAddress,
        Amount = 1000
    });
    
    await DefaultStub.EnableConnector.SendAsync(new ToBeConnectedTokenInfo
    {
        TokenSymbol = tokenSymbol,
        AmountToTokenConvert = 1000  // All tokens deposited
    });
    
    // Verify connector is enabled
    var connector = await DefaultStub.GetPairConnector.CallAsync(new TokenSymbol { Symbol = tokenSymbol });
    connector.DepositConnector.IsPurchaseEnabled.ShouldBe(true);
    connector.ResourceConnector.IsPurchaseEnabled.ShouldBe(true);
    
    // Step 4: Attempt to buy - should fail permanently
    var buyResult = await DefaultStub.Buy.SendWithExceptionAsync(new BuyInput
    {
        Symbol = tokenSymbol,
        Amount = 100
    });
    
    buyResult.TransactionResult.Error.ShouldContain("Connector balance needs to be a positive number");
    
    // Step 5: Verify UpdateConnector cannot fix the issue
    var updateResult = await ExecuteProposalForParliamentTransactionWithException(
        TokenConverterContractAddress,
        nameof(TokenConverterContractImplContainer.TokenConverterContractImplStub.UpdateConnector),
        new Connector
        {
            Symbol = connector.DepositConnector.Symbol,
            VirtualBalance = 1000000
        });
    
    updateResult.Error.ShouldContain("connector can not be updated because it has been activated");
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L64-64)
```csharp
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L96-109)
```csharp
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-300)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L37-38)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L70-71)
```csharp
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");
```

**File:** test/AElf.Contracts.TokenConverter.Tests/TokenConvertConnectorTest.cs (L493-502)
```csharp
    private PairConnectorParam GetLegalPairConnectorParam(string tokenSymbol, long nativeBalance = 1_0000_0000,
        string resourceWeight = "0.05", string nativeWeight = "0.05")
    {
        return new PairConnectorParam
        {
            ResourceConnectorSymbol = tokenSymbol,
            ResourceWeight = resourceWeight,
            NativeWeight = nativeWeight,
            NativeVirtualBalance = nativeBalance
        };
```
