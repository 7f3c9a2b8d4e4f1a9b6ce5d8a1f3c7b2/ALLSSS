# Audit Report

## Title
Invalid Profit Detail Creation When EndPeriod Equals CurrentPeriod with Delayed Distribution

## Summary
The `AddBeneficiary` function in the Profit contract fails to validate that `EndPeriod` is sufficient when `DelayDistributePeriodCount > 0`. When a manager adds a beneficiary with `EndPeriod = CurrentPeriod`, the calculated `StartPeriod` exceeds `EndPeriod`, creating an invalid profit detail. The beneficiary's shares are permanently added to `TotalShares` but can never be claimed, causing permanent dilution of all future profit distributions for legitimate beneficiaries.

## Finding Description

The vulnerability exists in the `AddBeneficiary` method where insufficient validation allows creation of invalid profit details: [1](#0-0) 

This check validates `EndPeriod >= CurrentPeriod` but does not account for the scheme's `DelayDistributePeriodCount`. The `StartPeriod` calculation adds this delay: [2](#0-1) 

When `EndPeriod = CurrentPeriod` and `DelayDistributePeriodCount > 0`, this creates `StartPeriod > EndPeriod`. The shares are immediately added to the scheme's total: [3](#0-2) 

During profit claiming, invalid details are filtered out by this condition: [4](#0-3) 

For a detail with `LastProfitPeriod = 0`, the check `d.EndPeriod >= d.StartPeriod` fails when `StartPeriod > EndPeriod`, preventing any claims.

The cleanup mechanism fails to remove these details: [5](#0-4) 

This only removes details where `LastProfitPeriod >= EndPeriod`, which never occurs for unclaimed invalid details since `LastProfitPeriod` remains 0.

This vulnerability affects production systems. The Treasury Welfare scheme uses `DelayDistributePeriodCount = 1`: [6](#0-5) 

## Impact Explanation

**Permanent Profit Dilution:** When an invalid beneficiary with shares S is added to a scheme with existing shares T, all future distributions calculate shares as S/(T+S) going to an unclaimable address. Legitimate beneficiaries receive (their_shares)/(T+S) instead of (their_shares)/T, a permanent reduction.

**Fund Locking:** The portion allocated to invalid beneficiaries (S/(T+S) of each distribution) remains locked in period virtual addresses indefinitely with no recovery mechanism.

**Production Impact:** The Treasury Welfare scheme in production has `DelayDistributePeriodCount = 1`, making it vulnerable. Any manager mistake or malicious action creating invalid beneficiaries permanently damages all future welfare distributions to voters.

**Scale:** If invalid shares equal 20% of total shares, legitimate beneficiaries permanently lose 20% of all future distributions. Over hundreds of periods, this compounds to significant loss.

## Likelihood Explanation

**Reachable Entry Point:** `AddBeneficiary` is callable by scheme managers: [7](#0-6) 

**Realistic Preconditions:**
- Schemes with `DelayDistributePeriodCount > 0` exist in production (Treasury Welfare)
- Manager calls `AddBeneficiary` with `EndPeriod = CurrentPeriod`
- This could happen accidentally (user not understanding delay semantics) or maliciously (manager intentionally locking funds)

**Execution Simplicity:** Single transaction with standard parameters - no complex state manipulation required.

**Probability:** Medium - requires privileged manager action, but represents a straightforward mistake during scheme management operations like beneficiary migration or period-limited reward grants.

## Recommendation

Add validation to ensure `EndPeriod` is sufficient given the delay settings:

```csharp
Assert(input.EndPeriod >= scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
    $"Invalid end period. End Period must be at least {scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount)} when DelayDistributePeriodCount is {scheme.DelayDistributePeriodCount}");
```

This should be added immediately after the existing validation at line 179-180 in `ProfitContract.cs`.

Additionally, implement a cleanup mechanism to remove invalid details where `StartPeriod > EndPeriod` and refund their shares from `TotalShares`.

## Proof of Concept

```csharp
[Fact]
public async Task Invalid_Profit_Detail_With_Delay_Distribution_Test()
{
    // Create scheme with DelayDistributePeriodCount = 1
    var creator = Creators[0];
    var schemeId = await creator.CreateScheme.SendAsync(new CreateSchemeInput
    {
        DelayDistributePeriodCount = 1
    });
    
    var scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    var currentPeriod = scheme.CurrentPeriod; // Should be 1
    
    // Add beneficiary with EndPeriod = CurrentPeriod
    var beneficiary = Normal[0];
    await creator.AddBeneficiary.SendAsync(new AddBeneficiaryInput
    {
        SchemeId = schemeId.Output,
        BeneficiaryShare = new BeneficiaryShare 
        { 
            Beneficiary = beneficiary.GetAddress(), 
            Shares = 100 
        },
        EndPeriod = currentPeriod // EndPeriod = CurrentPeriod = 1
    });
    
    // Verify shares added to TotalShares
    scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.TotalShares.ShouldBe(100); // Shares are added
    
    // Get profit details - StartPeriod should be 2 (CurrentPeriod + Delay)
    var details = await creator.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId.Output,
        Beneficiary = beneficiary.GetAddress()
    });
    
    var detail = details.Details[0];
    detail.StartPeriod.ShouldBe(2); // CurrentPeriod(1) + DelayDistributePeriodCount(1)
    detail.EndPeriod.ShouldBe(1);
    
    // StartPeriod > EndPeriod - invalid detail created!
    Assert.True(detail.StartPeriod > detail.EndPeriod);
    
    // Distribute profits for period 1
    await creator.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Amount = 1000,
        Symbol = "ELF"
    });
    
    await creator.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeId = schemeId.Output,
        Period = 1,
        AmountsMap = { { "ELF", 1000 } }
    });
    
    // Try to claim - should fail or claim 0 due to invalid detail
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiary.GetAddress(),
        Symbol = "ELF"
    });
    
    await beneficiary.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeId = schemeId.Output
    });
    
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = beneficiary.GetAddress(),
        Symbol = "ELF"
    });
    
    // No profits claimed despite having 100 shares in TotalShares
    balanceAfter.Balance.ShouldBe(balanceBefore.Balance); // No change
    
    // But TotalShares still includes these 100 shares, diluting future distributions
    scheme = await creator.GetScheme.CallAsync(schemeId.Output);
    scheme.TotalShares.ShouldBe(100); // Shares remain, causing permanent dilution
}
```

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L765-766)
```csharp
        var availableDetails = profitDetails.Details.Where(d =>
            d.LastProfitPeriod == 0 ? d.EndPeriod >= d.StartPeriod : d.EndPeriod >= d.LastProfitPeriod).ToList();
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L64-64)
```csharp
                DelayDistributePeriodCount = i == 3 ? 1 : 0,
```
