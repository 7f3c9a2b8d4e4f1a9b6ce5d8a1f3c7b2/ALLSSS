# Audit Report

## Title
Stale Vote References Persist After Candidate Quit/Rejoin Cycle Allowing Vote Inflation

## Summary
The Election contract fails to clear accumulated vote data when a candidate quits election. When the candidate rejoins, new votes are added to the stale pre-quit vote amounts, artificially inflating their vote count. This inflated amount directly determines miner selection through the `GetVictories` method, compromising consensus integrity.

## Finding Description

The vulnerability manifests through a state management flaw across three contract methods:

**QuitElection Fails to Clear Vote State:**
When a candidate quits, the `QuitElection` method only updates status flags but leaves `State.CandidateVotes[pubkey]` completely untouched. [1](#0-0)  The candidate information is updated to set `IsCurrentCandidate = false`, but the accumulated vote data including `ObtainedActiveVotingRecordIds` and `ObtainedActiveVotedVotesAmount` persists in state.

**AnnounceElection Does Not Reset Votes on Rejoin:**
When a candidate who previously quit announces election again, if their `CandidateInformation` already exists, the code only flips the `IsCurrentCandidate` flag back to true without clearing any vote data. [2](#0-1)  The stale `State.CandidateVotes[pubkey]` from the previous candidacy period remains intact.

**Vote Accumulation Adds to Stale Data:**
When new votes are cast for a rejoined candidate, the `UpdateCandidateInformation` method detects that `State.CandidateVotes[candidatePublicKey]` already exists and proceeds to ADD new vote IDs and amounts to the existing collections. [3](#0-2)  This creates an inflated total where `ObtainedActiveVotedVotesAmount = old_votes + new_votes`.

**Inflated Votes Drive Miner Selection:**
The `GetVictories` method, which determines election results, ranks candidates by sorting them based on `ObtainedActiveVotedVotesAmount`. [4](#0-3)  The top N candidates become miners, meaning inflated vote counts directly manipulate who gets selected.

**Attack Execution Path:**
1. Candidate announces election and accumulates votes (amount X)
2. Candidate calls `QuitElection` - deposit returned, but vote state with amount X persists
3. Candidate calls `AnnounceElection` again - vote state still shows amount X  
4. New voters cast votes (amount Y) - system adds to existing: X + Y
5. `GetVictories` ranks candidate using inflated amount (X + Y) instead of just Y
6. Candidate gains unfair advantage in miner selection

## Impact Explanation

This vulnerability has **HIGH** severity impact because:

**Consensus Manipulation:** Miner selection is corrupted through vote inflation, allowing candidates to gain mining privileges they don't legitimately deserve. This directly affects which nodes produce blocks and participate in consensus.

**Economic Incentive Compromise:** Selected miners receive block production rewards and mining subsidies. When selection is based on inflated votes, rewards are misdirected to candidates who haven't earned sufficient genuine community support.

**Data Center Ranking Corruption:** The inflated vote amounts also affect the data center ranking list, which determines backup subsidy distribution from the profit scheme. [5](#0-4) 

**Democratic Process Integrity:** The election system's fundamental guarantee—that candidates with the most genuine voter support become miners—is violated. This undermines trust in the governance mechanism.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** because:

**No Privileges Required:** Any candidate can execute this attack using only public contract methods (`AnnounceElection`, `QuitElection`). No special permissions or collusion needed.

**Low Cost:** The election deposit (100,000 ELF) is returned when quitting, so the only cost is transaction fees. [6](#0-5) 

**Simple Execution:** The attack requires only a 3-step sequence: announce → accumulate votes → quit → rejoin. No complex timing or coordination needed.

**Strong Economic Incentive:** Becoming a miner provides substantial block rewards and subsidies, making even small vote count advantages valuable. Candidates with borderline vote counts have strong motivation to exploit this.

**Existing Test Gap:** The test suite validates quit/rejoin token handling but does not test vote data persistence across the cycle. [7](#0-6)  This suggests the issue was not anticipated during development.

## Recommendation

Clear the candidate's vote data when they quit election by adding cleanup logic to the `QuitElection` method:

```csharp
// In QuitElection method, after line 254:
State.CandidateVotes.Remove(pubkey);
```

Alternatively, add a defensive check in `UpdateCandidateInformation` to verify the candidate is currently active:

```csharp
// In UpdateCandidateInformation, before line 548:
var candidateInfo = State.CandidateInformationMap[candidatePublicKey];
Assert(candidateInfo != null && candidateInfo.IsCurrentCandidate, 
    "Can only vote for current candidates.");
```

The first approach (clearing on quit) is cleaner as it removes stale data immediately. The second approach (checking on vote) provides defense-in-depth but leaves stale data in state.

## Proof of Concept

```csharp
[Fact]
public async Task VoteInflation_QuitAndRejoin_Test()
{
    // Setup: Announce election for a candidate
    var candidate = ValidationDataCenterKeyPairs.First();
    await AnnounceElectionAsync(candidate);
    
    // Phase 1: Get initial votes (e.g., 1000 tokens)
    var voter1 = VoterKeyPairs[0];
    await VoteMinerAsync(voter1, candidate.PublicKey.ToHex(), 100 days, 1000);
    var votesBeforeQuit = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidate.PublicKey.ToHex() });
    votesBeforeQuit.ObtainedActiveVotedVotesAmount.ShouldBe(1000);
    
    // Phase 2: Quit election
    await QuitElectionAsync(candidate);
    
    // Phase 3: Rejoin election
    await AnnounceElectionAsync(candidate);
    
    // Phase 4: New voter votes (e.g., 500 tokens)
    var voter2 = VoterKeyPairs[1];
    await VoteMinerAsync(voter2, candidate.PublicKey.ToHex(), 100 days, 500);
    
    // Vulnerability: Vote amount should be 500, but is actually 1500 (1000 + 500)
    var votesAfterRejoin = await ElectionContractStub.GetCandidateVote.CallAsync(
        new StringValue { Value = candidate.PublicKey.ToHex() });
    
    // This assertion FAILS, proving the vulnerability:
    // Expected: 500 (only new votes)
    // Actual: 1500 (old votes + new votes)
    votesAfterRejoin.ObtainedActiveVotedVotesAmount.ShouldBe(500); 
}
```

This test demonstrates that vote amounts accumulate across quit/rejoin cycles instead of resetting, allowing artificial vote inflation that affects miner selection outcomes.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L152-162)
```csharp
        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L252-254)
```csharp
        candidateInformation.IsCurrentCandidate = false;
        candidateInformation.AnnouncementTransactionId = Hash.Empty;
        State.CandidateInformationMap[pubkey] = candidateInformation;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L445-464)
```csharp
        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L559-566)
```csharp
        else
        {
            candidateVotes.ObtainedActiveVotingRecordIds.Add(voteId);
            candidateVotes.ObtainedActiveVotedVotesAmount =
                candidateVotes.ObtainedActiveVotedVotesAmount.Add(amount);
            candidateVotes.AllObtainedVotedVotesAmount =
                candidateVotes.AllObtainedVotedVotesAmount.Add(amount);
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-81)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
```

**File:** test/AElf.Contracts.Election.Tests/BVT/ElectionTests.cs (L104-119)
```csharp
    public async Task ElectionContract_AnnounceElectionAgain_Test()
    {
        await ElectionContract_QuiteElection_Test();

        var candidatesKeyPair = ValidationDataCenterKeyPairs.First();

        var balanceBeforeAnnouncing = await GetNativeTokenBalance(candidatesKeyPair.PublicKey);
        balanceBeforeAnnouncing.ShouldBe(ElectionContractConstants.UserInitializeTokenAmount);

        await AnnounceElectionAsync(candidatesKeyPair);

        var balanceAfterAnnouncing = await GetNativeTokenBalance(candidatesKeyPair.PublicKey);

        // Check balance after announcing election.
        balanceBeforeAnnouncing.ShouldBe(balanceAfterAnnouncing + ElectionContractConstants.LockTokenForElection);
    }
```
