### Title
Mining Order Manipulation via Unvalidated Signature in UpdateValue Consensus

### Summary
The `NewConsensusInformationFilled` function only validates that consensus signature and OutValue fields are non-empty, without verifying their cryptographic correctness. [1](#0-0)  Since the signature directly determines mining order for the next round via modulo arithmetic, [2](#0-1)  malicious miners can submit arbitrary signature values to manipulate their position in the mining schedule.

### Finding Description

The vulnerability exists in the consensus validation flow where block producers submit UpdateValue transactions. The validation provider only checks that the signature is not null or empty: [3](#0-2) 

The signature should be calculated using `previousRound.CalculateSignature(previousInValue)`, which XORs the inValue with all previous miners' signatures. [4](#0-3)  However, no validation exists to verify this calculation was performed correctly.

After passing validation, the signature is directly stored in the round information [5](#0-4)  and subsequently used to determine the miner's order in the next round by converting it to Int64 and applying modulo arithmetic. [6](#0-5) 

The only other validation, `ValidatePreviousInValue`, checks that the hash of previousInValue matches the previous OutValue [7](#0-6)  but does NOT validate the signature.

The `ValidateConsensusAfterExecution` compares round hashes [8](#0-7)  but both the header and state contain the same manipulated signature value, so they match.

### Impact Explanation

**Consensus Integrity Violation**: A malicious miner can determine their exact position (1 through N) in the next round's mining schedule by crafting a signature where `signature.ToInt64() % minersCount` equals their desired order minus 1. This breaks the fundamental randomness and fairness of the AEDPoS consensus mechanism.

**Strategic Advantage**: Order 1 miners mine first in each round, potentially gaining advantages in transaction ordering, MEV extraction, block reward timing, and influence over round progression decisions. The manipulated signature also affects subsequent signature calculations for other miners since `CalculateSignature` XORs all signatures together, [9](#0-8)  cascading the manipulation across the round.

**Affected Parties**: All honest miners suffer from unfair mining schedule allocation, and the blockchain's consensus guarantees are fundamentally compromised.

**Severity Justification**: HIGH - This violates the core consensus invariant of "miner schedule integrity" and allows any miner to manipulate a critical consensus parameter without detection.

### Likelihood Explanation

**Attacker Capabilities**: Any authorized block producer (miner) can exploit this vulnerability. No special permissions beyond normal mining rights are required.

**Attack Complexity**: LOW - The attacker simply needs to construct a Hash value where the first 8 bytes (when converted via ToInt64) produce the desired modulo result. For example, to achieve order 1 in a 17-miner round, they need bytes that yield 0 when mod 17.

**Feasibility Conditions**: The attack is immediately executable during any UpdateValue transaction. The miner has complete control over the signature field they submit.

**Detection Constraints**: The manipulated signature passes all existing validations. [10](#0-9)  No monitoring exists to detect signature calculation deviations.

**Economic Rationality**: The cost is zero (just submitting different bytes), while the benefit is guaranteed favorable mining position in subsequent rounds.

### Recommendation

**Immediate Fix**: Add cryptographic validation in `UpdateValueValidationProvider` to verify the signature was calculated correctly:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    var previousInValue = minerInRound.PreviousInValue;
    
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true; // First round or no previous value
        
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
        return true;
        
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    return minerInRound.Signature == expectedSignature;
}
```

Add this check to the `ValidateHeaderInformation` method: [11](#0-10) 

**Invariant to Enforce**: `signature == previousRound.CalculateSignature(previousInValue)` for all UpdateValue transactions where previousInValue is available.

**Test Cases**: 
1. Submit UpdateValue with manipulated signature → should fail validation
2. Submit UpdateValue with correctly calculated signature → should pass
3. Verify order assignment uses validated signatures only

### Proof of Concept

**Initial State**: 
- Blockchain running with 17 miners in current round
- Attacker is an authorized miner scheduled for order 10
- Attacker wants order 1 in next round (to mine first)

**Attack Steps**:
1. Attacker prepares UpdateValue transaction
2. Instead of calculating signature via `previousRound.CalculateSignature(previousInValue)`, attacker crafts a Hash where first 8 bytes convert to Int64 value `x` such that `x % 17 == 0`
3. Submit UpdateValue with: valid OutValue, valid PreviousInValue, but manipulated Signature
4. Validation checks pass: [3](#0-2) 
5. Signature stored: [12](#0-11) 
6. Order calculated: `GetAbsModulus(manipulatedSignature.ToInt64(), 17) + 1 == 1` [13](#0-12) 

**Expected Result**: Signature validation fails, transaction rejected

**Actual Result**: Transaction succeeds, attacker assigned order 1 for next round, attacker mines first in subsequent round giving them strategic advantage

**Success Condition**: Attacker's `FinalOrderOfNextRound` field is set to 1 instead of the randomized value that would result from correct signature calculation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-245)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```
