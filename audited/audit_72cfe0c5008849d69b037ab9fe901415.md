### Title
Missing Cryptographic Validation in Secret Sharing Revelation Allows Consensus Manipulation

### Summary
The `UpdateLatestSecretPieces()` function accepts revealed InValues from miners via secret sharing without validating that they hash to the previously committed OutValues. This breaks the VRF commit-reveal scheme, allowing any miner to inject arbitrary values as another miner's PreviousInValue, compromising consensus randomness and mining order integrity.

### Finding Description

**Vulnerable Code Location:** [1](#0-0) 

The `UpdateLatestSecretPieces()` function directly sets revealed InValues as PreviousInValue without any hash validation.

**Root Cause:**

In AEDPoS consensus, miners commit to an OutValue (OutValue = Hash(InValue)) in round N, then reveal the InValue in round N+1. The system must cryptographically verify Hash(revealed InValue) == committed OutValue.

However, when processing `RevealedInValues` from the trigger information, the function only checks if the target miner's PreviousInValue is empty, then blindly accepts the provided value.

**Why Existing Protections Fail:**

The validation system validates only the block producer's own PreviousInValue: [2](#0-1) 

This validation explicitly retrieves `validationContext.SenderPubkey` and validates only that miner's PreviousInValue against their own OutValue. It does NOT validate revealed InValues for other miners.

**Additional Vulnerable Path:**

A similar vulnerability exists in consensus transaction processing: [3](#0-2) 

The `PerformSecretSharing()` function also sets PreviousInValues from input without validation.

**Data Flow:**

The revealed InValues originate from off-chain secret sharing service: [4](#0-3) 

While the service computes Hash(DecodeSecret(shares)), it never validates this hash against the target miner's committed OutValue before storing it.

These unvalidated revealed InValues are then included in trigger information: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Compromise:**

- An attacker can provide arbitrary hash values as revealed InValues for target miners
- Since signature calculation uses PreviousInValue, manipulated values affect random number generation
- Mining order for next round depends on these signatures, enabling mining order manipulation
- Attackers can bias consensus to favor specific miners or timing attacks

**Affected Parties:**

- All network participants relying on consensus randomness
- Miners whose InValues are maliciously revealed with fake values
- Smart contracts depending on deterministic block production order

**Severity Justification:**

CRITICAL - This breaks a fundamental cryptographic invariant of the VRF-based consensus mechanism. The commit-reveal scheme is designed to prevent manipulation of random values, but without validation, the reveal phase is meaningless.

### Likelihood Explanation

**Attacker Capabilities:**

Any miner in the current round can execute this attack when producing blocks. The attacker only needs:
- Valid miner credentials (normal consensus participant)
- Ability to produce blocks in their assigned time slot
- Control over the `RevealedInValues` map in their trigger information

**Attack Complexity:**

LOW - The attack is straightforward:
1. Wait for assigned mining time slot
2. Modify the secret sharing service or trigger information provider to inject fake revealed InValues
3. Produce block normally - the fake values pass validation

**Feasibility Conditions:**

- Secret sharing must be enabled (configurable feature)
- Target miner must not have already revealed their own PreviousInValue (checked at line 150-151)
- These are normal operational conditions

**Detection Constraints:**

The attack is difficult to detect because:
- Malicious revealed InValues look identical to legitimate ones
- No on-chain validation failure occurs
- Only off-chain verification against previously committed OutValues would detect the manipulation

**Economic Rationality:**

Highly rational - Attackers gain:
- Ability to influence mining order for strategic advantage
- Potential to coordinate with specific miners for MEV opportunities
- Cost is zero beyond normal block production costs

### Recommendation

**Immediate Fix:**

Add hash validation in `UpdateLatestSecretPieces()`:

```csharp
foreach (var revealedInValue in triggerInformation.RevealedInValues)
{
    if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
        (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
         updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
    {
        // NEW: Validate revealed InValue against committed OutValue
        if (TryToGetPreviousRoundInformation(out var previousRound) &&
            previousRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key))
        {
            var expectedOutValue = previousRound.RealTimeMinersInformation[revealedInValue.Key].OutValue;
            var actualHash = HashHelper.ComputeFrom(revealedInValue.Value);
            
            // Only accept if hash matches commitment
            if (actualHash == expectedOutValue)
            {
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
            }
            else
            {
                Context.LogDebug(() => $"Rejected invalid revealed InValue for {revealedInValue.Key}");
            }
        }
    }
}
```

**Apply Same Fix to PerformSecretSharing:**

Add identical validation at: [6](#0-5) 

**Test Cases to Add:**

1. Test that valid revealed InValues (Hash matches OutValue) are accepted
2. Test that invalid revealed InValues (Hash mismatch) are rejected
3. Test that rejected revelations don't affect consensus state
4. Test edge case where OutValue doesn't exist in previous round
5. Integration test verifying end-to-end secret sharing with validation

### Proof of Concept

**Initial State:**
- Secret sharing enabled via Configuration contract
- Round N: Miner A produces block with InValue_A, commits OutValue_A = Hash(InValue_A)
- Miner A shares encrypted pieces of InValue_A with other miners
- Round N advances to Round N+1

**Attack Steps:**

1. **Attacker (Miner B) prepares malicious block:**
   - Miner B's time slot arrives in Round N+1
   - Miner B generates trigger information with normal consensus data
   
2. **Inject fake revealed InValue:**
   - Instead of using legitimate revealed InValue for Miner A from secret sharing
   - Set `triggerInformation.RevealedInValues["Miner_A_Pubkey"] = AttackerChosenHash`
   - Where `Hash(AttackerChosenHash) != OutValue_A`

3. **Block production succeeds:**
   - `GetConsensusExtraDataToPublishOutValue()` calls `UpdateLatestSecretPieces()`
   - Fake revealed InValue is set as Miner A's PreviousInValue without validation
   - `ValidateBeforeExecution()` only validates Miner B's own PreviousInValue
   - Block is accepted and finalized

**Expected Result:**
System should reject the block due to invalid revealed InValue hash mismatch.

**Actual Result:**
Block is accepted. Miner A's PreviousInValue is now set to attacker-controlled value, breaking the commit-reveal guarantee and allowing signature/random number manipulation.

**Success Condition:**
After attack, verify that `State.Rounds[N+1].RealTimeMinersInformation["Miner_A_Pubkey"].PreviousInValue == AttackerChosenHash`, and this value was accepted despite `Hash(AttackerChosenHash) != State.Rounds[N].RealTimeMinersInformation["Miner_A_Pubkey"].OutValue`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L175-180)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L112-114)
```csharp
            var revealedInValues = _secretSharingService.GetRevealedInValues(hint.RoundId);
            foreach (var revealedInValue in revealedInValues)
                trigger.RevealedInValues.Add(revealedInValue.Key, revealedInValue.Value);
```
