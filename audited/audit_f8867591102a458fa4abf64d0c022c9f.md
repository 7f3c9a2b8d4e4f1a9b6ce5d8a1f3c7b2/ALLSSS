### Title
Zero Threshold Values Enable Permanent Governance Deadlock in Referendum Contract

### Summary
The `Validate` function in the Referendum contract allows `MaximalAbstentionThreshold` and `MaximalRejectionThreshold` to be set to 0, creating an unbalanced voting mechanism that requires unanimous approval for all proposals. Once configured with zero thresholds, the organization becomes permanently locked in this state with no recovery mechanism, as changing thresholds also requires unanimous approval.

### Finding Description

The vulnerability exists in the threshold validation logic: [1](#0-0) 

The validation explicitly allows `MaximalAbstentionThreshold >= 0` and `MaximalRejectionThreshold >= 0`, permitting zero values. However, the proposal release logic uses strict greater-than comparison: [2](#0-1) 

When either threshold is 0:
- Any `RejectionCount > 0` blocks the proposal
- Any `AbstentionCount > 0` blocks the proposal

This creates a unanimous approval requirement where a single abstention or rejection vote vetoes any proposal.

The critical issue is that threshold changes can only be executed by the organization itself through a proposal: [3](#0-2) 

The `ChangeOrganizationThreshold` function checks `State.Organizations[Context.Sender]`, meaning only the organization address (via a passed proposal) can modify thresholds. If thresholds are already set to 0, the change proposal itself requires unanimous approval, creating a permanent deadlock if any voter is uncooperative or malicious.

### Impact Explanation

**Permanent Governance DoS:**
- Any organization configured with zero maximal thresholds becomes permanently dysfunctional
- All proposals require 100% approval with zero abstentions or rejections
- A single uncooperative or offline voter can permanently block all governance
- No recovery mechanism exists to restore functionality

**Attack Surface:**
1. Initial misconfiguration by organization creator (user error scenario)
2. Malicious threshold change via deceptive proposal (active attack scenario)

For attack scenario 2, a malicious proposer in the whitelist could create a proposal framed as "requiring maximum consensus for security" and social engineer voters to approve it, permanently locking the organization.

**Affected Parties:**
- All referendum organizations using this contract
- Token holders who rely on governance decisions
- Protocols depending on these organizations for configuration changes

The severity is Medium because while the impact is severe and permanent, exploitation requires either initial misconfiguration or successfully passing a malicious proposal under current thresholds.

### Likelihood Explanation

**Reachable Entry Points:**
- `CreateOrganization` - allows direct creation with zero thresholds [4](#0-3) 

- `ChangeOrganizationThreshold` - allows changing existing organization to zero thresholds

**Attack Complexity:**
For the active attack scenario:
1. Attacker must be in the proposer whitelist
2. Create a proposal targeting `ChangeOrganizationThreshold` with zero values
3. Social engineer voters to approve (e.g., claiming "unanimous consent requirement")
4. Once approved and released, organization is permanently locked [5](#0-4) 

**Likelihood Factors:**
- Proposer whitelist membership is a prerequisite but may not be difficult to obtain
- Voters may lack technical understanding of threshold implications
- No warnings or safeguards exist in the validation logic
- The permanent and irreversible nature makes even low-probability events catastrophic

**Detection Challenges:**
- The validation explicitly allows these values, so no error is raised
- Users may view unanimous consent as a "secure" option without understanding the deadlock risk

### Recommendation

**Immediate Fix:**
Modify the validation function to enforce minimum reasonable thresholds:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Require maximal thresholds to be at least 1 to prevent deadlock
    // OR require them to be greater than minimal approval threshold
    return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold > 0 && // Changed from >= 0
           proposalReleaseThreshold.MaximalRejectionThreshold > 0;   // Changed from >= 0
}
```

**Alternative Fix:**
If zero thresholds are intentionally supported for specific use cases, add explicit checks:
- Warn when creating organizations with zero thresholds
- Implement an emergency recovery mechanism (e.g., time-locked threshold reset)
- Require maximal thresholds to be greater than a percentage of minimal vote threshold

**Invariant Checks:**
- `MaximalAbstentionThreshold > 0`
- `MaximalRejectionThreshold > 0`
- Or: `MaximalAbstentionThreshold >= MinimalApprovalThreshold / 10` (allowing some opposition)

**Test Cases:**
1. Attempt to create organization with zero maximal thresholds - should fail
2. Attempt to change thresholds to zero via proposal - should fail
3. Verify that organizations with low (but non-zero) thresholds can still function

### Proof of Concept

**Initial State:**
- Referendum contract deployed
- Token contract available with "ELF" symbol
- Multiple voter addresses with token balances and allowances

**Attack Sequence:**

1. **Create organization with zero thresholds:**
```
CreateOrganization({
    token_symbol: "ELF",
    proposal_release_threshold: {
        minimal_approval_threshold: 1000,
        minimal_vote_threshold: 1000,
        maximal_abstention_threshold: 0,
        maximal_rejection_threshold: 0
    },
    proposer_white_list: [proposer1, proposer2],
    creation_token: hash
})
```

2. **Create and approve a normal proposal:**
```
    - proposer1 creates proposal
    - voter1 approves with 1001 tokens
    - voter2 approves with 1001 tokens
    - Proposal ToBeReleased = true (all approvals)
```

3. **Demonstrate single-voter veto:**
```
    - proposer1 creates second proposal
    - voter1 approves with 1001 tokens
    - voter2 abstains with 1 token
    - Proposal ToBeReleased = false (blocked by single abstention)
```

4. **Demonstrate permanent lock:**
```
    - proposer1 creates proposal to call ChangeOrganizationThreshold
  with reasonable values (e.g., maximal thresholds = 5000)
    - voter1 approves
    - voter2 abstains or is offline
    - Threshold change proposal fails
    - Organization remains locked with zero thresholds forever
```

**Expected Result:**
Organization accepts zero threshold configuration and becomes permanently locked in unanimous-approval-only mode.

**Actual Result:**
The validation passes and organization functions with extreme imbalance, giving any single voter veto power and preventing recovery through threshold changes.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-29)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;

        var isRejected = proposal.RejectionCount > proposalReleaseThreshold.MaximalRejectionThreshold;
        if (isRejected)
            return false;

        var isAbstained = proposal.AbstentionCount > proposalReleaseThreshold.MaximalAbstentionThreshold;
        if (isAbstained)
            return false;

        return proposal.ApprovalCount >= proposalReleaseThreshold.MinimalApprovalThreshold;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L12-40)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            TokenSymbol = input.TokenSymbol,
            OrganizationHash = organizationHash,
            ProposerWhiteList = input.ProposerWhiteList,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization data.");

        if (State.Organizations[organizationAddress] != null)
            return organizationAddress;

        State.Organizations[organizationAddress] = organization;
        Context.Fire(new OrganizationCreated
        {
            OrganizationAddress = organizationAddress
        });

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-137)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```
