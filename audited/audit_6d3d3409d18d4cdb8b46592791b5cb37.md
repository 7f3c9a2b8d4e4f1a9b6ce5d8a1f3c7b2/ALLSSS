### Title
NextTerm Round Validation Bypass via RoundIdForValidation Manipulation Leading to Consensus DoS

### Summary
The `NextTermInput.Create()` method copies the mutable `RoundIdForValidation` field instead of using the computed `RoundId` property, allowing a malicious miner to craft a NextTerm transaction with a manipulated round that bypasses critical time-slot validation. This enables storing a malformed consensus round to state, causing a denial of service on the entire consensus mechanism.

### Finding Description

The vulnerability exists in how NextTermInput is created and validated during term transitions.

**Root Cause:** [1](#0-0) 

The `Create()` method copies `round.RoundIdForValidation` (a mutable field) directly without validation, rather than using the computed `round.RoundId` property.

**Round.RoundId Property Fallback Logic:** [2](#0-1) 

The `RoundId` property returns the sum of all miners' `ExpectedMiningTime.Seconds` if available, otherwise falls back to `RoundIdForValidation`. This fallback mechanism is exploitable.

**Validation Bypass:** [3](#0-2) 

Critical time-slot validation via `CheckRoundTimeSlots()` is only executed when `ProvidedRound.RoundId != BaseRound.RoundId`. An attacker can make these equal by:
1. Crafting a Round with no `ExpectedMiningTime` set (causing RoundId to fall back to RoundIdForValidation)
2. Setting `RoundIdForValidation` to match the current round's RoundId
3. This makes the validation treat it as the same round, skipping `CheckRoundTimeSlots()`

**Missing Validation:** [4](#0-3) 

The NextTerm validation only checks round/term number incrementing and InValue nullability. It does NOT validate that `ExpectedMiningTime` is properly set for all miners.

**Legitimate Round Generation:** [5](#0-4) 

Legitimate rounds from `GenerateFirstRoundOfNewTerm()` always set `ExpectedMiningTime` (line 32-33) but leave `RoundIdForValidation` unset (defaults to 0), making them distinguishable from current rounds.

### Impact Explanation

**Consensus Denial of Service:**
Once the malformed round (without valid `ExpectedMiningTime`) is stored to state via `ProcessNextTerm`: [6](#0-5) 

The consensus mechanism becomes permanently broken because:

1. **Mining Interval Calculation Fails:** [7](#0-6) 

`GetMiningInterval()` requires `ExpectedMiningTime` for the first two miners. With null values, this throws exceptions or returns invalid intervals.

2. **Time Slot Checks Fail:** [8](#0-7) 

`CheckRoundTimeSlots()` explicitly checks for null `ExpectedMiningTime` and fails, preventing any subsequent legitimate round transitions.

**Severity:** HIGH - Complete consensus halt affecting all block production, requiring manual chain intervention to restore functionality. The entire blockchain network becomes non-operational.

### Likelihood Explanation

**Attacker Capabilities Required:** [9](#0-8) 

Attacker must be a current or previous miner (checked in `PreCheck()`). This is a realistic constraint as malicious miners are a known threat model in consensus systems.

**Attack Complexity:** LOW
- Attacker crafts a malicious `NextTermInput` protobuf message with:
  - `RoundNumber` = current + 1
  - `TermNumber` = current + 1  
  - `RealTimeMinersInformation` with miners but no `ExpectedMiningTime`
  - `RoundIdForValidation` = current round's `RoundId` value
- Submits via `NextTerm()` transaction

**No Economic Barriers:** The attack requires only one malicious transaction from a miner during their valid time slot. No staking loss or financial cost.

**Detection Difficulty:** The malformed round passes all validation checks before execution, making it difficult to detect until consensus breaks.

### Recommendation

**Immediate Fix - Store Computed RoundId:**
Modify `NextTermInput.Create()` to store the computed `RoundId` instead of the mutable field:

```csharp
public static NextTermInput Create(Round round, ByteString randomNumber)
{
    return new NextTermInput
    {
        // ... other fields ...
        RoundIdForValidation = round.RoundId,  // Use computed property, not field
        // ... remaining fields ...
    };
}
```

**Defense-in-Depth Validation:**
Add explicit validation in `RoundTerminateValidationProvider.ValidationForNextTerm()`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // ADD: Ensure all miners have valid ExpectedMiningTime
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = "All miners must have valid ExpectedMiningTime for NextTerm." };
        
    return new ValidationResult { Success = true };
}
```

**Test Case:**
Add regression test that attempts NextTerm with null `ExpectedMiningTime` and verifies it's rejected during validation.

### Proof of Concept

**Initial State:**
- Current round: RoundNumber=10, TermNumber=2, RoundId=X (computed from miners' ExpectedMiningTime)
- Malicious miner is in current miner list

**Attack Steps:**

1. Malicious miner queries current round to get RoundId value X
2. Constructs malicious NextTermInput:
   ```
   RoundNumber: 11
   TermNumber: 3
   RealTimeMinersInformation: { miner1: {Order:1, ...}, miner2: {Order:2, ...}, ... }
     (Note: NO ExpectedMiningTime fields set)
   RoundIdForValidation: X (copied from current round)
   InValue: null for all miners
   ```
3. Submits `NextTerm(maliciousInput)` transaction during valid time slot
4. Validation executes:
   - `RoundTerminateValidationProvider`: ✓ Passes (RoundNumber=11, TermNumber=3, InValue=null)
   - `TimeSlotValidationProvider`: ProvidedRound.RoundId = X (falls back to RoundIdForValidation), BaseRound.RoundId = X → Equal, so CheckRoundTimeSlots() skipped ✓
   - Other validators: ✓ Pass
5. Transaction executes successfully, malformed round stored to state
6. Next miner attempts block production → `GetMiningInterval()` fails → Consensus halted

**Expected vs Actual:**
- **Expected:** Validation rejects round without valid ExpectedMiningTime
- **Actual:** Validation passes, consensus breaks permanently

**Success Condition:** Blockchain stops producing blocks after malicious NextTerm transaction, requiring manual intervention to restore consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L19-19)
```csharp
            RoundIdForValidation = round.RoundIdForValidation,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-42)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-19)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-44)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }

        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;

        return round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
