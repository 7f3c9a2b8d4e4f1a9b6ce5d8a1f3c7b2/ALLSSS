### Title
Integer Overflow in Method Fee Aggregation Causes Denial of Service

### Summary
The `AssertValidToken()` function validates individual fee amounts but fails to prevent overflow when multiple fees with the same token symbol are aggregated. When `SetMethodFee` is called with duplicate symbols whose `BasicFee` values sum beyond `long.MaxValue`, subsequent transaction fee charging operations will trigger an overflow exception, permanently disabling the affected method.

### Finding Description

The vulnerability exists across multiple system contracts implementing ACS1 (Transaction Fee Standard). In the Referendum contract, the `SetMethodFee` function validates each fee individually through `AssertValidToken()`: [1](#0-0) 

The `AssertValidToken()` function only checks that the amount is non-negative: [2](#0-1) 

This validation is insufficient because:

1. **No duplicate symbol check**: The protobuf definition allows repeated `MethodFee` entries, and tests confirm duplicate symbols are permitted and summed: [3](#0-2) 

2. **No aggregate validation**: When fees are later retrieved and aggregated, the `GetBaseFeeDictionary()` function groups fees by symbol and sums them without overflow checking: [4](#0-3) 

3. **Checked arithmetic enforcement**: AElf contracts are compiled with `CheckForOverflowUnderflow=true`: [5](#0-4) 

When the `.Sum()` operation exceeds `long.MaxValue`, it throws an `OverflowException`, causing the transaction to fail. This affects all system contracts using the same pattern (Parliament, Association, Referendum, Treasury, TokenHolder, etc.), except Profit which has a count limit: [6](#0-5) 

### Impact Explanation

**Operational Impact - Denial of Service:**
- Any method with fees configured to sum beyond `long.MaxValue` becomes permanently unusable
- Transactions calling the affected method will always fail during the fee charging pre-execution phase
- The DoS persists until governance can pass another proposal to fix the fees
- Affects critical system contract operations including governance proposals, token transfers, consensus operations, and cross-chain communications

**Severity Justification:**
- **Medium-High Impact**: Complete DoS of affected methods until corrected through governance
- **Scope**: Affects 16+ system contracts implementing ACS1 (all except Profit)
- **Recovery**: Requires governance proposal and approval to reset fees, which may be difficult if governance methods themselves are affected

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control over the Method Fee Controller address (default: Parliament default organization)
- Ability to create and pass a governance proposal through standard voting mechanisms

**Attack Complexity:**
- **Moderate**: Requires governance control but does not need technical sophistication
- The attack can occur accidentally through configuration error (e.g., setting two fees of 9×10^18 each)
- Realistic scenario: Compromised governance multisig or malicious proposal that passes voting

**Feasibility Conditions:**
- Governance must approve the malicious `SetMethodFee` transaction
- For Parliament/Association/Referendum contracts, this requires meeting quorum and approval thresholds
- No detection mechanisms exist to prevent overflow during `SetMethodFee` execution

**Likelihood Assessment: Medium**
- Requires trusted role compromise (governance) or significant configuration error
- However, once fees are set, the DoS is immediate and persistent
- Risk increases with number of governance participants and complexity of fee configurations

### Recommendation

**Immediate Mitigations:**

1. **Add aggregate validation in SetMethodFee** - Implement validation similar to Profit contract but also check the sum:

```csharp
public override Empty SetMethodFee(MethodFees input)
{
    foreach (var methodFee in input.Fees) 
        AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
    
    // Add this validation
    var symbolToSum = new Dictionary<string, long>();
    foreach (var fee in input.Fees)
    {
        if (symbolToSum.ContainsKey(fee.Symbol))
            symbolToSum[fee.Symbol] = symbolToSum[fee.Symbol].Add(fee.BasicFee); // Uses checked Add
        else
            symbolToSum[fee.Symbol] = fee.BasicFee;
    }
    
    RequiredMethodFeeControllerSet();
    Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, 
        "Unauthorized to set method fee.");
    State.TransactionFees[input.MethodName] = input;
    return new Empty();
}
```

2. **Add maximum count limit** - Apply the same limit used in Profit contract: [7](#0-6) 

3. **Prevent duplicate symbols** - Add validation to reject duplicate symbols entirely, or normalize them before storage.

**Invariant Checks:**
- Sum of all `BasicFee` values for each unique symbol must not exceed `long.MaxValue`
- Total count of fee entries should be bounded (e.g., ≤ 5 as in Profit contract)

**Test Cases:**
- Test setting fees with duplicate symbols that sum to near `long.MaxValue`
- Verify `OverflowException` is caught during `SetMethodFee`, not during `ChargeTransactionFees`
- Test edge cases: exactly `long.MaxValue`, `long.MaxValue - 1`, two entries of `long.MaxValue / 2 + 1`

### Proof of Concept

**Initial State:**
- Referendum contract deployed with Parliament as Method Fee Controller
- Parliament governance organization has necessary approvals to pass proposals

**Attack Sequence:**

1. **Create malicious proposal** to call `Referendum.SetMethodFee` with:
```
MethodName: "CreateProposal"
Fees: [
  { Symbol: "ELF", BasicFee: 9_223_372_036_854_775_000 },  // Near long.MaxValue
  { Symbol: "ELF", BasicFee: 9_223_372_036_854_775_000 }   // Duplicate symbol
]
```

2. **Pass proposal** through Parliament governance (requires quorum + approval threshold)

3. **Execute proposal** - `SetMethodFee` succeeds because:
   - Each individual fee passes `AssertValidToken()` (both are positive and < long.MaxValue)
   - No aggregate validation exists
   - Fees are stored in state

4. **Attempt to call CreateProposal** - Transaction fails:
   - Pre-execution plugin calls `ChargeTransactionFees`
   - `ChargeTransactionFees` retrieves fees via `GetMethodFee`
   - `GetBaseFeeDictionary()` calls `.Sum()` on the two BasicFee values
   - Sum = 18_446_744_073_709_550_000 > 9_223_372_036_854_775_807 (long.MaxValue)
   - `OverflowException` thrown due to checked arithmetic
   - Transaction reverts with overflow error

**Expected Result:** Transaction succeeds or is rejected during SetMethodFee

**Actual Result:** SetMethodFee succeeds but all subsequent calls to CreateProposal fail permanently with overflow exception

**Success Condition:** Method becomes unusable until governance resets the fees with valid values

### Citations

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L12-12)
```csharp
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L76-85)
```csharp
    private void AssertValidToken(string symbol, long amount)
    {
        Assert(amount >= 0, "Invalid amount.");
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        Assert(State.TokenContract.IsTokenAvailableForMethodFee.Call(new StringValue { Value = symbol }).Value,
            $"Token {symbol} cannot set as method fee.");
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutePluginTransactionDirectlyTest.cs (L73-89)
```csharp
        var methodFee = new MethodFees
        {
            MethodName = methodName,
            Fees =
            {
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                },
                new MethodFee
                {
                    Symbol = NativeTokenSymbol,
                    BasicFee = basicMethodFee
                }
            }
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.Referendum/AElf.Contracts.Referendum.csproj (L13-19)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>

    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L14-14)
```csharp
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```
