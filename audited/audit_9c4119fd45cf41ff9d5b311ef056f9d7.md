### Title
Consensus Takeover via Unauthorized Miner Injection During NextTerm Transition

### Summary
The `NextTerm` method in the AEDPoS consensus contract fails to validate that the miner list in `NextTermInput.RealTimeMinersInformation` matches the Election contract's `GetVictories` result. A malicious current miner can bypass the election mechanism by constructing a custom `NextTermInput` with arbitrary unauthorized miners, completely taking over the consensus and excluding legitimate elected miners.

### Finding Description

The vulnerability exists in the term transition flow where miner list validation is completely absent.

**Root Cause:**

The `NextTermInput.Create()` method simply copies the `RealTimeMinersInformation` from a provided `Round` object without any validation: [1](#0-0) 

**Failed Validation Chain:**

1. **Before Execution Validation** - Only validates round/term number increments, NOT the miner list: [2](#0-1) [3](#0-2) 

2. **Execution Path** - `ProcessNextTerm` blindly accepts the input's miner list and updates state: [4](#0-3) 

3. **After Execution Validation** - Compares state with header, but state was already updated with malicious data: [5](#0-4) 

**Why Protections Fail:**

The Election contract's `GetVictories` method is only called during honest consensus extra data generation: [6](#0-5) [7](#0-6) 

However, the `NextTerm` method is publicly accessible and only requires the sender to be a current miner: [8](#0-7) [9](#0-8) 

A malicious miner can bypass the standard `GenerateConsensusTransactions` flow and construct their own `NextTermInput` with arbitrary miners.

### Impact Explanation

**Consensus/Cross-Chain Integrity**: Complete consensus takeover and permanent control of the blockchain.

**Concrete Harm:**
- **Consensus Control**: Attacker injects themselves and accomplices as miners for the new term, excluding all legitimately elected miners
- **Perpetual Attack**: Once in control, malicious miners can repeat the attack in subsequent terms, maintaining permanent control
- **Election Bypass**: The entire election mechanism becomes meaningless as voting results are ignored
- **Block Production Monopoly**: Only attacker-controlled miners produce blocks, enabling censorship, double-spending, and chain reorganization
- **Economic Impact**: Legitimate miners lose all mining rewards; attackers capture 100% of block rewards and transaction fees
- **Treasury Control**: Malicious miners control treasury release and profit distribution

**Affected Parties:**
- All legitimate elected miners (excluded from consensus)
- All token holders (their votes are meaningless)
- All network users (subject to censorship and potential fund theft)
- The entire blockchain's integrity and trustworthiness

**Severity Justification**: This is a **CRITICAL** vulnerability that completely breaks the core consensus mechanism and election-based governance model of the blockchain.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a current miner (required to pass `PreCheck` authorization)
- Must have block production privileges during their time slot
- No special permissions beyond being a current miner required

**Attack Complexity:** Low
1. Construct a `Round` object with malicious miner list
2. Create `NextTermInput` using `NextTermInput.Create(maliciousRound, randomNumber)`
3. Ensure term number and round number are properly incremented
4. Create and sign transaction calling `NextTerm` method
5. Include transaction in their block with matching consensus extra data

**Feasibility Conditions:**
- Blockchain must be at a term transition point (predictable - happens every `PeriodSeconds`)
- Attacker must be scheduled to produce the term transition block (1 in N chance where N = current miner count)
- Can be attempted multiple times across different term transitions

**Detection/Operational Constraints:**
- Attack succeeds immediately upon block acceptance
- No automated detection mechanism exists
- Other nodes will accept the block if it passes validation (which it will, as shown)
- Recovery requires manual intervention and potentially hard fork

**Probability Reasoning:**
- **High probability** for determined attacker who is already a miner
- Can wait for their scheduled term transition block slot
- Success rate: 100% when conditions are met (correct time slot + proper round/term number construction)

### Recommendation

**Immediate Fix:**

Add validation in `ProcessNextTerm` to verify the miner list matches the Election contract's result:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    // NEW VALIDATION: Verify miner list matches election results
    if (State.IsMainChain.Value && State.ElectionContract.Value != null)
    {
        var victories = State.ElectionContract.GetVictories.Call(new Empty());
        var expectedMiners = victories.Pubkeys.Select(p => p.ToHex()).OrderBy(x => x).ToList();
        var inputMiners = nextRound.RealTimeMinersInformation.Keys.OrderBy(x => x).ToList();
        
        Assert(expectedMiners.Count == inputMiners.Count, "Miner count mismatch with election results");
        Assert(expectedMiners.SequenceEqual(inputMiners), "Miner list does not match election results");
    }
    
    // Continue with existing logic...
}
```

**Alternative Validation Location:**

Add an election-specific validation provider for NextTerm behavior:

```csharp
// In AEDPoSContract_Validation.cs, case AElfConsensusBehaviour.NextTerm:
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new NextTermMinerListValidationProvider()); // NEW
    break;
```

**Invariant to Enforce:**
- For every NextTerm transition on MainChain, `NextTermInput.RealTimeMinersInformation.Keys` MUST exactly match `ElectionContract.GetVictories().Pubkeys`

**Test Cases:**
1. Test that NextTerm rejects input with extra unauthorized miners
2. Test that NextTerm rejects input missing elected miners
3. Test that NextTerm rejects input with completely different miner list
4. Test that valid NextTerm with correct election results succeeds

### Proof of Concept

**Initial State:**
- Current term: 1, miner list: [Alice, Bob, Charlie]
- Election results for term 2: [David, Eve, Frank] (legitimately elected)
- Attacker: Alice (current miner with block production slot for term transition)

**Attack Sequence:**

1. **Attacker constructs malicious Round:**
```
maliciousRound = new Round {
    TermNumber = 2,  // Correct increment
    RoundNumber = currentRound.RoundNumber + 1,  // Correct increment
    RealTimeMinersInformation = {
        ["Alice"] = { ... },  // Attacker keeps themselves
        ["Mallory"] = { ... },  // Unauthorized miner 1
        ["Eve"] = { ... }  // One legitimate miner for camouflage
        // David and Frank excluded!
    }
}
```

2. **Attacker creates NextTermInput:**
```
maliciousInput = NextTermInput.Create(maliciousRound, validRandomNumber)
```

3. **Attacker creates transaction:**
```
tx = CreateTransaction(
    method: "NextTerm",
    input: maliciousInput,
    sender: Alice
)
```

4. **Attacker produces block with malicious transaction:**
    - Block includes tx and consensus extra data with malicious round
    - Block passes validation (round/term numbers are correct)

**Expected Result:**
Transaction should be REJECTED due to miner list mismatch with election results.

**Actual Result:**
Transaction SUCCEEDS. State is updated with malicious miner list [Alice, Mallory, Eve]. David and Frank (legitimately elected) are excluded. Alice and Mallory now control consensus for term 2 and can repeat attack indefinitely.

**Success Condition:**
Query `GetCurrentMinerList()` returns [Alice, Mallory, Eve] instead of [David, Eve, Frank], confirming unauthorized miners have been injected and legitimate miners excluded.

### Notes

This vulnerability represents a complete failure of the election-based consensus mechanism. The absence of miner list validation during term transitions allows any current miner to arbitrarily rewrite the miner list, bypassing the entire voting and election process. The fix must validate against the Election contract's `GetVictories` result before accepting any term transition.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L83-128)
```csharp
    public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
    {
        var headerInformation = new AElfConsensusHeaderInformation();
        headerInformation.MergeFrom(input.Value);
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
            {
                var headerMiners = headerInformation.Round.RealTimeMinersInformation.Keys;
                var stateMiners = currentRound.RealTimeMinersInformation.Keys;
                var replacedMiners = headerMiners.Except(stateMiners).ToList();
                if (!replacedMiners.Any())
                    return new ValidationResult
                    {
                        Success = false, Message =
                            "Current round information is different with consensus extra data.\n" +
                            $"New block header consensus information:\n{headerInformation.Round}" +
                            $"Stated block header consensus information:\n{currentRound}"
                    };

                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
            }
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
