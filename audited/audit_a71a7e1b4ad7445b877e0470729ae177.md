### Title
Missing Extra Block Producer Validation Causes Denial of Service in Consensus and Cross-Chain Operations

### Summary
The `GetNextMinerPubkey()` function uses `.First()` without validation that an extra block producer exists in the round, which can throw `InvalidOperationException` when invoked. A malicious miner can submit a `NextRoundInput` with no extra block producer set, bypassing validation and causing permanent denial of service for critical consensus operations including cross-chain indexing and transaction fee claiming.

### Finding Description

**Root Cause:**
The `GetNextMinerPubkey()` method at line 91-102 contains a fallback that calls `.First(m => m.IsExtraBlockProducer)` without ensuring an extra block producer exists: [1](#0-0) 

When `FirstOrDefault` on line 97 returns null (no miners with future expected mining time), the null-coalescing operator `??` evaluates line 98, which calls `.First(m => m.IsExtraBlockProducer).Pubkey`. If no miner has `IsExtraBlockProducer = true`, this throws `InvalidOperationException`.

Additionally, the `IsCurrentMiner()` method at line 170 uses `.Single(m => m.Value.IsExtraBlockProducer)`, which throws if there are 0 or multiple extra block producers: [2](#0-1) 

**Validation Gap:**
The `RoundTerminateValidationProvider` only validates round number and that InValues are null, but never checks the extra block producer invariant: [3](#0-2) 

**Attack Path:**
1. A malicious miner generates a `NextRoundInput` via `ToRound()` conversion with no miner having `IsExtraBlockProducer = true`
2. Submits this via the `NextRound` transaction during their mining slot
3. The malformed round passes validation and gets stored via `AddRoundInformation()` [4](#0-3) 

4. All subsequent calls to `IsCurrentMiner()` or `GetNextMinerPubkey()` throw exceptions

### Impact Explanation

**Critical Operations Affected:**

1. **Cross-Chain Indexing DoS**: `ProposeCrossChainIndexing` and `ReleaseCrossChainIndexingProposal` call `AssertAddressIsCurrentMiner()`, which invokes `CheckCrossChainIndexingPermission`: [5](#0-4) [6](#0-5) 

All cross-chain indexing operations become permanently unavailable, halting parent-sidechain synchronization.

2. **Transaction Fee Claiming DoS**: `ClaimTransactionFees` and `DonateResourceToken` in the MultiToken contract call `AssertSenderIsCurrentMiner()`: [7](#0-6) 

Miners cannot claim accumulated transaction fees, causing economic disruption and potential miner departure.

3. **View Method Failures**: External systems calling `GetNextMinerPubkey()` receive unhandled exceptions, breaking consensus monitoring and block production coordination.

**Severity Justification:**
This is a **High severity** vulnerability causing:
- Permanent DoS of cross-chain operations (critical for multi-chain ecosystem)
- Complete halt of fee distribution mechanism
- Disruption of consensus monitoring infrastructure
- Requires only single malicious transaction from any miner

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an active miner in the current miner list
- During their assigned time slot, they can generate and submit round information
- Normal consensus privilege, not requiring special authorization

**Attack Complexity:**
- **Low**: Attacker modifies the round generation logic to set all miners' `IsExtraBlockProducer = false` (or set multiple to true)
- Submits via standard `NextRound` transaction
- Single transaction execution sufficient

**Feasibility Conditions:**
- Attacker is scheduled miner (â‰ˆ1/N probability per round where N = miner count, typically 17+)
- No runtime validation prevents malformed round submission
- Round generation is client-side, allowing arbitrary manipulation before submission

**Detection Constraints:**
- Attack succeeds silently; validation passes
- Impact only manifests when subsequent operations attempt to use the round
- No immediate detection mechanism exists

**Economic Rationality:**
- Cost: standard transaction fee only (negligible)
- Benefit: disrupts competitor operations, can force governance intervention
- No penalty mechanism for submitting malformed round data

**Probability Assessment:** High likelihood given minimal cost, guaranteed miner access every epoch, and absence of validation.

### Recommendation

**Immediate Mitigation:**
Add validation in `RoundTerminateValidationProvider` to enforce the extra block producer invariant:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information." };
    
    // Add validation for exactly one extra block producer
    var extraBlockProducerCount = extraData.Round.RealTimeMinersInformation.Values
        .Count(m => m.IsExtraBlockProducer);
    if (extraBlockProducerCount != 1)
        return new ValidationResult { Message = "Exactly one extra block producer required." };

    return new ValidationResult { Success = true };
}
```

**Defensive Coding:**
Replace unsafe operations with safe alternatives:

In `GetNextMinerPubkey()`:
```csharp
Value = round.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
    round.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.IsExtraBlockProducer)?.Pubkey ??
    string.Empty
```

In `IsCurrentMiner()`:
```csharp
var supposedExtraBlockProducer = currentRound.RealTimeMinersInformation
    .FirstOrDefault(m => m.Value.IsExtraBlockProducer);
if (supposedExtraBlockProducer.Value == null) return false;
```

**Test Cases:**
1. Test `NextRound` submission with zero extra block producers (should fail validation)
2. Test `NextRound` submission with multiple extra block producers (should fail validation)
3. Test `GetNextMinerPubkey()` with empty miner list (should return empty string)
4. Test `IsCurrentMiner()` with malformed round (should return false, not throw)

### Proof of Concept

**Initial State:**
- Blockchain running with current round N
- Attacker is miner with upcoming time slot
- Normal round generation produces rounds with exactly one extra block producer per: [8](#0-7) 

**Attack Steps:**

1. **Miner generates malicious NextRoundInput:**
   - Create `NextRoundInput` for round N+1 via custom logic
   - Set all miners' `IsExtraBlockProducer = false` (or multiple to true)
   - Calculate valid round number, signatures, and other fields normally

2. **Miner submits NextRound transaction:**
   - During their time slot, call `NextRound(maliciousInput)`
   - Transaction passes validation (no extra block producer check)
   - Malformed round stored via `AddRoundInformation()` [9](#0-8) 

3. **DoS manifests on subsequent operations:**
   - Any miner calling `ProposeCrossChainIndexing()` receives `InvalidOperationException`
   - Any miner calling `ClaimTransactionFees()` receives `InvalidOperationException`  
   - Any external call to `GetNextMinerPubkey()` receives `InvalidOperationException`

**Expected Result:**
Validation should reject the malformed round, returning error message.

**Actual Result:**
Malformed round is accepted and stored, causing permanent DoS until chain governance intervention or hard fork to correct the round data.

**Success Condition:**
After attack, all calls to `IsCurrentMiner()` and `GetNextMinerPubkey()` throw exceptions, observable via transaction failures with "System.InvalidOperationException: Sequence contains no matching element" or "Sequence contains more than one matching element."

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L91-102)
```csharp
    public override StringValue GetNextMinerPubkey(Empty input)
    {
        if (TryToGetCurrentRoundInformation(out var round))
            return new StringValue
            {
                Value = round.RealTimeMinersInformation.Values
                            .FirstOrDefault(m => m.ExpectedMiningTime > Context.CurrentBlockTime)?.Pubkey ??
                        round.RealTimeMinersInformation.Values.First(m => m.IsExtraBlockProducer).Pubkey
            };

        return new StringValue();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-170)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L288-295)
```csharp
    private void AssertAddressIsCurrentMiner(Address address)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        var isCurrentMiner = State.CrossChainInteractionContract.CheckCrossChainIndexingPermission.Call(address)
            .Value;
        Assert(isCurrentMiner, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L25-28)
```csharp
    public override BoolValue CheckCrossChainIndexingPermission(Address input)
    {
        return IsCurrentMiner(input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L867-906)
```csharp
    public override Empty ClaimTransactionFees(TotalTransactionFeesMap input)
    {
        AssertSenderIsCurrentMiner();
        var claimTransactionExecuteHeight = State.ClaimTransactionFeeExecuteHeight.Value;

        Assert(claimTransactionExecuteHeight < Context.CurrentHeight,
            $"This method already executed in height {State.ClaimTransactionFeeExecuteHeight.Value}");
        State.ClaimTransactionFeeExecuteHeight.Value = Context.CurrentHeight;
        Context.LogDebug(() => $"Claim transaction fee. {input}");
        State.LatestTotalTransactionFeesMapHash.Value = HashHelper.ComputeFrom(input);
        foreach (var bill in input.Value)
        {
            var symbol = bill.Key;
            var amount = bill.Value;
            ModifyBalance(Context.Self, symbol, amount);
            Context.Fire(new TransactionFeeClaimed
            {
                Symbol = symbol,
                Amount = amount,
                Receiver = Context.Self
            });
            
            TransferTransactionFeesToFeeReceiver(symbol, amount);
        }

        Context.LogDebug(() => "Finish claim transaction fee.");

        return new Empty();
    }

    private void AssertSenderIsCurrentMiner()
    {
        if (State.ConsensusContract.Value == null)
        {
            State.ConsensusContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);
        }

        Assert(State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-66)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-124)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);

        if (round.RoundNumber > 1 && !round.IsMinerListJustChanged)
            // No need to share secret pieces if miner list just changed.

            Context.Fire(new SecretSharingInformation
            {
                CurrentRoundId = round.RoundId,
                PreviousRound = State.Rounds[round.RoundNumber.Sub(1)],
                PreviousRoundId = State.Rounds[round.RoundNumber.Sub(1)].RoundId
            });

        // Only clear old round information when the mining status is Normal.
        var roundNumberToRemove = round.RoundNumber.Sub(AEDPoSContractConstants.KeepRounds);
        if (
            roundNumberToRemove >
            1 && // Which means we won't remove the information of the first round of first term.
            GetMaximumBlocksCount() == AEDPoSContractConstants.MaximumTinyBlocksCount)
            State.Rounds.Remove(roundNumberToRemove);
    }
```
