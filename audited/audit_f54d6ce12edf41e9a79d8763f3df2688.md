### Title
Delegation Fallback Failure: Empty Method-Specific Delegate Entries Permanently Block General Delegate Usage

### Summary
The fallback logic in `GetDelegateeList()` and related fee-charging functions fails to properly handle empty method-specific delegate entries. When all method-specific delegatees are removed for a particular contract method, an empty `TransactionFeeDelegatees` object remains in state, which prevents fallback to general delegates. This permanently disables delegation for affected methods, causing a denial-of-service of the fee delegation feature.

### Finding Description
The vulnerability exists in the delegation fallback mechanism across multiple locations in the codebase. The core issue is in how the null-coalescing operator (`??`) is used without checking for empty delegate collections. [1](#0-0) 

In `GetDelegateeList()`, the code checks if `TransactionFeeDelegateInfoMap[delegator][to][methodName]` is null and falls back to `TransactionFeeDelegateesMap[delegator]` if so. However, it doesn't account for the case where the first map returns a non-null `TransactionFeeDelegatees` object with an empty `Delegatees` dictionary.

The same flawed pattern appears in the fee-charging logic: [2](#0-1) [3](#0-2) [4](#0-3) 

The root cause is in the delegate removal logic, which removes delegatees from the `Delegatees` dictionary but always saves the (potentially empty) parent object back to state: [5](#0-4) 

When the last delegatee is removed, `existDelegateeInfoList.Delegatees` becomes empty, but the code still executes line 244-245, saving the empty object to state. There is no cleanup logic to delete the entire entry or set it to null when `Delegatees.Count == 0`. [6](#0-5) 

Similarly, `RemoveTransactionFeeDelegateInfo()` removes delegatees but saves the modified object back without checking if it's now empty.

The delegation system design allows delegatees to unilaterally add themselves to pay fees for any delegator: [7](#0-6) 

This means any party can create method-specific delegate entries for any user, then remove themselves, leaving an empty entry that permanently blocks that user's general delegates for those methods.

### Impact Explanation
**Operational Impact - Denial of Service:**
- Users permanently lose the ability to use their general delegates for specific contract methods once method-specific delegates have been set and then fully removed
- This affects transaction fee payment functionality, potentially causing legitimate transactions to fail if users rely on delegation
- No recovery mechanism exists - users cannot restore general delegate usage without re-adding method-specific delegates (which requires delegatee cooperation)

**Affected Parties:**
- Any user who has both general delegates configured and has experienced method-specific delegates being added then removed
- Can affect critical operations like token transfers, cross-chain transactions, or any contract method calls that rely on delegation

**Attack Amplification:**
- Malicious delegatees can create permanent damage with minimal cost
- They only need to provide initial delegation amounts (e.g., 1000 ELF) to add themselves
- After paying for one transaction (or zero if delegations are set but never used), they remove themselves
- The cost to the attacker is small and temporary, while the impact on the victim is permanent

### Likelihood Explanation
**Likelihood: Medium to High**

**Reachable Entry Points:**
- `SetTransactionFeeDelegateInfos()` - publicly callable, allows anyone to add themselves as method-specific delegate for any delegator
- `RemoveTransactionFeeDelegatorInfos()` - allows delegatees to remove themselves
- `RemoveTransactionFeeDelegateeInfos()` - allows delegators to remove specific delegatees

**Feasible Preconditions:**
- No authorization check prevents arbitrary parties from adding themselves as method-specific delegates
- Only requires attacker to provide delegation amounts upfront (economic barrier exists but is low)
- Victim must have general delegates configured for the attack to have meaningful impact

**Execution Practicality:**
1. Attacker calls `SetTransactionFeeDelegateInfos(DelegatorAddress=Victim, DelegateInfoList=[{Contract, Method, Delegations}])`
2. Attacker calls `RemoveTransactionFeeDelegatorInfos()` to remove themselves
3. Victim's method-specific delegate entry is now empty but non-null
4. Victim can no longer use general delegates for that method

**Natural Occurrence:**
- Even without malicious intent, legitimate delegatees removing themselves (via `RemoveTransactionFeeDelegatorInfos`) causes this issue
- Common scenario: delegatee temporarily helps user, then opts out
- This creates a "footgun" where well-intentioned actions cause permanent damage

**Economic Rationality:**
- Low attack cost: only requires providing initial delegation amount
- High impact: permanent disabling of delegation for specific methods
- Asymmetric damage: temporary cost vs. permanent effect

### Recommendation
**Primary Fix - Add Empty Collection Check:**
Modify the fallback logic to check for both null and empty delegate collections:

In `GetDelegateeList()` and all fee-charging locations, change the pattern from:
```csharp
var allDelegatees = State.TransactionFeeDelegateInfoMap[delegator][to][methodName] 
                    ?? State.TransactionFeeDelegateesMap[delegator];
```

To:
```csharp
var methodSpecific = State.TransactionFeeDelegateInfoMap[delegator][to][methodName];
var allDelegatees = (methodSpecific != null && methodSpecific.Delegatees.Count > 0)
    ? methodSpecific
    : State.TransactionFeeDelegateesMap[delegator];
```

**Alternative Fix - Cleanup Empty Entries:**
In `SetTransactionFeeDelegateInfos()` (line 244-245), add cleanup logic:
```csharp
if (existDelegateeInfoList.Delegatees.Count == 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = null; // Delete empty entry
}
else
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = existDelegateeInfoList;
}
```

Apply the same pattern in `RemoveTransactionFeeDelegateInfo()`.

**Invariant to Enforce:**
- Method-specific delegate entries should only exist in state if they contain at least one delegatee
- Empty delegate collections should trigger fallback to general delegates

**Test Cases:**
1. Set general delegates, add then remove all method-specific delegates, verify general delegates still work
2. Add method-specific delegate, remove via `RemoveTransactionFeeDelegatorInfos`, verify fallback occurs
3. Multiple delegatees: remove all but one, verify method-specific still used; remove last one, verify fallback
4. Edge case: Set IsUnlimitedDelegate=true then remove, verify proper cleanup

### Proof of Concept
**Initial State:**
- Alice has general delegate Bob configured via `SetTransactionFeeDelegations`
- Bob has sufficient balance to pay Alice's transaction fees

**Attack Sequence:**
1. Mallory calls `SetTransactionFeeDelegateInfos(DelegatorAddress=Alice, DelegateInfoList=[{ContractAddress=TokenContract, MethodName="Transfer", Delegations={ELF: 1000}}])`
   - Mallory adds herself as method-specific delegate for Alice's Transfer calls
   - Mallory commits to paying up to 1000 ELF

2. Mallory calls `RemoveTransactionFeeDelegatorInfos(DelegatorAddress=Alice, DelegateTransactionList=[{ContractAddress=TokenContract, MethodName="Transfer"}])`
   - Mallory removes herself from Alice's Transfer method-specific delegates
   - `TransactionFeeDelegateInfoMap[Alice][TokenContract]["Transfer"]` now contains `TransactionFeeDelegatees{ Delegatees: {} }`

3. Alice attempts to call `Transfer()` with insufficient balance, relying on Bob (general delegate) to pay fees

**Expected Result:**
- System checks method-specific delegates, finds none, falls back to general delegate Bob
- Bob pays Alice's transaction fees
- Transfer succeeds

**Actual Result:**
- System checks `TransactionFeeDelegateInfoMap[Alice][TokenContract]["Transfer"]`
- Finds non-null object (with empty Delegatees)
- Does NOT fall back to general delegate Bob
- No delegatee available to pay fees
- Transfer fails with "Transaction fee not enough" error

**Success Condition for Exploit:**
- Alice's Transfer transactions permanently fail when relying on delegation
- Bob (general delegate) is never consulted despite being configured
- Alice cannot recover without Mallory or another delegatee re-adding method-specific delegates

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L134-146)
```csharp
    private List<string> GetDelegateeList(Address delegator, Address to, string methodName)
    {
        var delegateeList = new List<string>();
        var allDelegatees = State.TransactionFeeDelegateInfoMap[delegator][to][methodName] 
                            ?? State.TransactionFeeDelegateesMap[delegator];
            
        if (allDelegatees != null)
        {
            delegateeList.AddRange(allDelegatees.Delegatees.Keys.ToList());
        } 

        return delegateeList;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-102)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L174-176)
```csharp
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L218-220)
```csharp
            var delegateInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][contractAddress][methodName] ??
                State.TransactionFeeDelegateesMap[delegatorAddress];
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L198-217)
```csharp
    public override Empty SetTransactionFeeDelegateInfos(SetTransactionFeeDelegateInfosInput input)
    {
        Assert(input.DelegatorAddress != null && input.DelegateInfoList.Count > 0,
            "Delegator address and delegate info cannot be null.");
        var toAddTransactionList = new DelegateTransactionList();
        var toUpdateTransactionList = new DelegateTransactionList();
        var toCancelTransactionList = new DelegateTransactionList();
        var delegatorAddress = input.DelegatorAddress;
        foreach (var delegateInfo in input.DelegateInfoList)
        {
            //If isUnlimitedDelegate is false,delegate info list should > 0.
            Assert(delegateInfo.IsUnlimitedDelegate || delegateInfo.Delegations.Count > 0,
                "Delegation cannot be null.");
            Assert(delegateInfo.ContractAddress != null && !string.IsNullOrEmpty(delegateInfo.MethodName),
                "Invalid contract address and method name.");

            var existDelegateeInfoList =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                    [delegateInfo.MethodName] ?? new TransactionFeeDelegatees();
            var delegateeAddress = Context.Sender.ToBase58();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L233-246)
```csharp
            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L379-386)
```csharp
            var delegateeInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                    delegateTransaction.MethodName];
            if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
            delegateeInfo.Delegatees.Remove(delegateeAddress);
            toCancelTransactionList.Value.Add(delegateTransaction);
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                delegateTransaction.MethodName] = delegateeInfo;
```
