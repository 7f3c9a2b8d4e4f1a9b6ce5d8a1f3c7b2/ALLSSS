### Title
Parliament Governance Deadlock via Approval-Rejection Threshold Gap

### Summary
The Parliament contract's default thresholds create a mathematical deadlock zone where proposals can become permanently stuck in pending state. With 66.67% approval required but only >20% rejection needed to block, a minority of 13.33%-20% miners can force deadlock by rejecting while remaining miners split between approval and abstention, preventing critical governance actions from being executed or definitively rejected.

### Finding Description

The Parliament contract defines threshold constants that create an exploitable gap: [1](#0-0) 

The proposal release logic uses strict inequality for rejection blocking but inclusive inequality for approval passing: [2](#0-1) [3](#0-2) 

**Root Cause:** The validation logic enforces `MaximalRejectionThreshold + MinimalApprovalThreshold <= AbstractVoteTotal` (2000 + 6667 = 8667 ≤ 10000), which is mathematically valid but creates a 13.33% gap: [4](#0-3) 

**Why Protections Fail:** 
- To block: rejections must EXCEED 20% (strict `>` at line 68-69)
- To pass: approvals must be AT LEAST 66.67% (inclusive `>=` at line 84-86)
- With 100 miners: 20 rejections (200000 > 200000 = FALSE), 66 approvals (660000 >= 666700 = FALSE)
- Proposal stays pending indefinitely until expiration

The release check confirms proposals can only be released when thresholds are met: [5](#0-4) 

### Impact Explanation

**Critical Governance DoS:**
- Important protocol upgrades, parameter changes, or emergency responses can be deadlocked
- No resolution mechanism exists except waiting for proposal expiration
- Affects all Parliament-governed actions including cross-chain operations, economic parameters, and contract upgrades

**Attack Surface:**
- Default organization (main governance) uses these thresholds
- Emergency response organization has tighter thresholds (90% approval, 10% rejection) but custom organizations may use defaults [6](#0-5) 

**Severity:** High - While not directly stealing funds, this enables minority censorship of critical governance actions, potentially preventing security fixes or necessary protocol adaptations.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control or coordination of 13.33%-20% of current miners (13-20 out of 100)
- Ability to vote (Reject) on proposals via standard Parliament methods

**Attack Complexity:** Low
- No special permissions needed beyond being elected miners
- Natural occurrence possible in contentious governance debates
- Can be executed through normal voting mechanisms

**Feasibility Conditions:**
- Parliament members (miners) are elected positions
- Coordination among 13-20 miners is realistic for organized groups
- In controversial proposals, natural vote splits could trigger deadlock accidentally

**Detection:** Difficult to distinguish from legitimate disagreement until proposal expires without resolution.

### Recommendation

**Short-term Fix:** Adjust default thresholds to eliminate the gap:
```
Option 1 (Stricter approval): MinimalApprovalThreshold = 8000 (80%), MaximalRejectionThreshold = 2000 (20%)
Option 2 (Looser rejection): MinimalApprovalThreshold = 6667 (66.67%), MaximalRejectionThreshold = 3333 (33.33%)
```

**Validation Enhancement:** Add explicit check in validation logic:
```csharp
// Ensure no deadlock zone exists
Assert(
    proposalReleaseThreshold.MaximalRejectionThreshold + 
    proposalReleaseThreshold.MinimalApprovalThreshold >= AbstractVoteTotal,
    "Threshold configuration creates deadlock zone"
);
```

**Test Cases:** Add regression tests for boundary conditions:
- Exactly 20% rejections, 66% approvals (should resolve one way or other)
- Verify all vote distributions result in released, rejected, or abstained (no permanent pending)

### Proof of Concept

**Initial State:**
- Parliament organization with default thresholds (MinimalApproval=6667, MaximalRejection=2000)
- 100 active miners in current miner list
- Proposal created for critical governance action

**Attack Sequence:**
1. Attacker coordinates 20 miners (20% of parliament)
2. These 20 miners call `Reject(proposalId)`
3. 66 honest miners call `Approve(proposalId)` 
4. 14 miners call `Abstain(proposalId)` or don't vote

**Expected Result:** Proposal should either pass or be definitively rejected

**Actual Result:**
- `IsProposalRejected`: 20 * 10000 = 200000 NOT > 200000 → Returns FALSE (not blocked)
- `CheckEnoughVoteAndApprovals`: 66 * 10000 = 660000 NOT >= 666700 → Returns FALSE (not approved)
- `IsReleaseThresholdReached` returns FALSE
- Proposal remains in pending state indefinitely
- `Release(proposalId)` transaction fails with "Not approved"
- Critical governance action cannot be executed until proposal expires

**Success Condition:** Proposal with 20% rejections and 66% approvals cannot be released, demonstrating deadlock.

### Citations

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L5-9)
```csharp
    private const int DefaultOrganizationMinimalApprovalThreshold = 6667;
    private const int DefaultOrganizationMaximalAbstentionThreshold = 2000;
    private const int DefaultOrganizationMaximalRejectionThreshold = 2000;
    private const int DefaultOrganizationMinimalVoteThresholdThreshold = 7500;
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L64-70)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var rejectionMemberCount = proposal.Rejections.Count(parliamentMembers.Contains);
        return rejectionMemberCount * AbstractVoteTotal >
               organization.ProposalReleaseThreshold.MaximalRejectionThreshold * parliamentMembers.Count;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L80-92)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization,
        ICollection<Address> parliamentMembers)
    {
        var approvedMemberCount = proposal.Approvals.Count(parliamentMembers.Contains);
        var isApprovalEnough = approvedMemberCount * AbstractVoteTotal >=
                               organization.ProposalReleaseThreshold.MinimalApprovalThreshold *
                               parliamentMembers.Count;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached = IsVoteThresholdReached(proposal, organization, parliamentMembers);
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L22-36)
```csharp
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
