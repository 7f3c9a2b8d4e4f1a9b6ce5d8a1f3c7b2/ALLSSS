### Title
BaseTokenSymbol Collision with Non-Deposit Connector Causes Reserve Accounting Discrepancy and Bancor Pricing Manipulation

### Summary
The TokenConverter contract allows connectors to be created with symbols matching `BaseTokenSymbol.Value`, causing `GetSelfBalance()` to return the contract's total base token balance instead of the connector's specific reserve. This leads to inflated Bancor pricing calculations and enables draining reserves intended for other connector pairs, breaking the fundamental reserve isolation invariant.

### Finding Description

The vulnerability exists in the interaction between connector creation and balance querying logic.

**Root Cause:**

The contract stores `BaseTokenSymbol` (typically "ELF") and allows connectors with any symbol to be created without validation: [1](#0-0) 

Both `Initialize` and `AddPairConnector` lack validation preventing connector symbols from matching `BaseTokenSymbol.Value`: [2](#0-1) [3](#0-2) 

**Balance Accounting Discrepancy:**

When `GetSelfBalance()` is called for a connector, it chooses the balance source based on `IsDepositAccount`: [4](#0-3) 

For non-deposit connectors (`IsDepositAccount = false`), it queries the contract's total token balance. If the connector's symbol equals `BaseTokenSymbol.Value` (e.g., "ELF"), this returns the **aggregate ELF balance** including all reserves tracked separately in `DepositBalance["(NT)XXX"]` for other connector pairs.

**Exploitation Path:**

1. Via `AddPairConnector` with `ResourceConnectorSymbol = BaseTokenSymbol.Value` (e.g., "ELF"):
   - Creates resource connector: `symbol = "ELF"`, `RelatedSymbol = "(NT)ELF"`, `IsDepositAccount = false`
   - Creates deposit connector: `symbol = "(NT)ELF"`, `RelatedSymbol = "ELF"`, `IsDepositAccount = true`

2. Existing legitimate pairs hold ELF reserves (e.g., WRITE/(NT)WRITE pair has 1000 ELF in `DepositBalance["(NT)WRITE"]`)

3. When `Buy("ELF")` is called on the malicious pair:
   - `GetSelfBalance(toConnector)` for connector["ELF"] returns total contract ELF balance (1000 ELF)
   - Bancor calculates price assuming 1000 ELF available for this connector
   - But this ELF is actually reserved for the WRITE pair, tracked separately

4. The inflated balance allows purchasing the malicious token at artificially low prices and draining ELF reserves that belong to other pairs [5](#0-4) 

### Impact Explanation

**Direct Fund Impact:**
- **Reserve Drainage**: ELF tokens reserved for legitimate connector pairs (stored in `DepositBalance["(NT)XXX"]`) can be transferred out through the malicious connector, as the actual transfer uses the contract's total balance
- **Bancor Pricing Manipulation**: The inflated connector balance causes incorrect price calculations, allowing tokens to be bought/sold at prices that don't reflect actual reserves
- **Breaking Reserve Isolation**: The fundamental Bancor invariant that each connector pair has isolated reserves is violated

**Quantified Damage:**
If legitimate pairs have combined reserves of N ELF in various `DepositBalance` entries, the malicious connector would report having access to all N ELF for pricing, when it should have 0 or only its own reserve.

**Affected Parties:**
- Liquidity providers for legitimate connector pairs whose reserves get drained
- Users trading on legitimate pairs who face incorrect pricing after reserves are depleted
- Protocol integrity as the Bancor reserve model breaks down

**Severity Justification:**
Medium severity because:
- Requires privileged configuration (Initialize or governance-approved AddPairConnector)
- Results in concrete financial loss and protocol dysfunction
- Violates critical pricing and reserve isolation invariants
- Not directly exploitable by untrusted users but preventable through input validation

### Likelihood Explanation

**Configuration Requirements:**

This vulnerability requires connector misconfiguration through one of two paths:

1. **Initialize** (one-time deployment): Deployer adds connectors with symbol matching BaseTokenSymbol [6](#0-5) 

2. **AddPairConnector** (post-deployment): Connector controller calls with `ResourceConnectorSymbol = BaseTokenSymbol` [7](#0-6) 

**Authority Requirements:**

Connector controller defaults to Parliament governance: [8](#0-7) 

**Feasibility:**
- Not an active attack by untrusted users
- Represents a **configuration mistake** that trusted administrators could make
- The contract lacks defensive validation to prevent such errors
- Production code shows similar patterns (ELF connector without RelatedSymbol), indicating this configuration space is actively used

**Probability:**
Medium likelihood because:
- Requires privileged access but represents an easy-to-make configuration mistake
- No validation exists to catch this during setup
- Once configured, automatically affects all subsequent Buy/Sell operations
- Mistake could occur during legitimate attempts to create complex connector topologies

### Recommendation

**Add Symbol Collision Validation:**

In `Initialize`, add validation after setting BaseTokenSymbol:
```csharp
foreach (var connector in input.Connectors)
{
    Assert(connector.IsDepositAccount || connector.Symbol != State.BaseTokenSymbol.Value,
        "Non-deposit connector symbol cannot match base token symbol.");
    // ... existing validation
}
```

In `AddPairConnector`, add check before creating resource connector:
```csharp
Assert(input.ResourceConnectorSymbol != State.BaseTokenSymbol.Value,
    "Resource connector symbol cannot match base token symbol.");
```

**Invariant to Enforce:**
- Non-deposit connectors (IsDepositAccount = false) MUST NOT have symbols matching BaseTokenSymbol.Value
- This ensures GetSelfBalance for such connectors queries the correct isolated balance, not the aggregate contract balance

**Test Cases:**
1. Test Initialize rejecting connectors where symbol = BaseTokenSymbol and IsDepositAccount = false
2. Test AddPairConnector rejecting ResourceConnectorSymbol = BaseTokenSymbol
3. Test that deposit connectors (IsDepositAccount = true) CAN have symbols matching BaseTokenSymbol if needed (though unusual)
4. Integration test verifying isolated reserve accounting across multiple connector pairs

### Proof of Concept

**Required Initial State:**
- BaseTokenSymbol = "ELF"
- Legitimate pair: WRITE/(NT)WRITE with 1000 ELF in DepositBalance["(NT)WRITE"]

**Transaction Sequence:**

1. **Setup malicious connector pair** (via governance-approved AddPairConnector):
   ```
   AddPairConnector({
       ResourceConnectorSymbol: "ELF",
       ResourceWeight: "0.5",
       NativeVirtualBalance: 100,
       NativeWeight: "0.5"
   })
   ```
   Creates: Connector["ELF"] with IsDepositAccount=false, RelatedSymbol="(NT)ELF"

2. **Enable the malicious connector:**
   ```
   EnableConnector({
       TokenSymbol: "ELF",
       AmountToTokenConvert: 100
   })
   ```

3. **Exploit via Buy:**
   ```
   Buy({
       Symbol: "ELF",
       Amount: 50
   })
   ```

**Expected vs Actual:**

**Expected:** GetSelfBalance for Connector["ELF"] should return only the ELF balance specifically allocated to this connector (e.g., 0 or small amount).

**Actual:** GetSelfBalance queries `TokenContract.GetBalance(contract, "ELF")` which returns 1000 ELF (includes DepositBalance["(NT)WRITE"] from legitimate pair). Bancor pricing calculates based on this inflated 1000 ELF reserve, allowing the purchase to proceed with incorrect pricing and potentially draining reserves meant for the WRITE pair.

**Success Condition:** 
After Buy("ELF"), verify:
- Contract's actual ELF balance decreased (transferred to buyer)
- DepositBalance["(NT)WRITE"] unchanged in state but effectively depleted from contract's actual balance
- Subsequent Sell("WRITE") operations fail or get incorrect pricing due to missing reserves

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContractState.cs (L15-17)
```csharp
    public StringState BaseTokenSymbol { get; set; }
    public StringState FeeRate { get; set; }
    public MappedState<string, Connector> Connectors { get; set; }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L27-56)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(IsValidBaseSymbol(input.BaseTokenSymbol), $"Base token symbol is invalid. {input.BaseTokenSymbol}");
        Assert(State.TokenContract.Value == null, "Already initialized.");
        State.TokenContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
        State.BaseTokenSymbol.Value = !string.IsNullOrEmpty(input.BaseTokenSymbol)
            ? input.BaseTokenSymbol
            : Context.Variables.NativeSymbol;
        var feeRate = AssertedDecimal(input.FeeRate);
        Assert(IsBetweenZeroAndOne(feeRate), "Fee rate has to be a decimal between 0 and 1.");
        State.FeeRate.Value = feeRate.ToString(CultureInfo.InvariantCulture);
        foreach (var connector in input.Connectors)
        {
            if (connector.IsDepositAccount)
            {
                Assert(!string.IsNullOrEmpty(connector.Symbol), "Invalid connector symbol.");
                AssertValidConnectorWeight(connector);
            }
            else
            {
                Assert(IsValidSymbol(connector.Symbol), "Invalid symbol.");
                AssertValidConnectorWeight(connector);
            }

            State.Connectors[connector.Symbol] = connector;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-159)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
        var fee = Convert.ToInt64(amountToPay * GetFeeRate());

        var amountToPayPlusFee = amountToPay.Add(fee);
        Assert(input.PayLimit == 0 || amountToPayPlusFee <= input.PayLimit, "Price not good.");

        // Pay fee
        if (fee > 0) HandleFee(fee);

        // Transfer base token
        State.TokenContract.TransferFrom.Send(
            new TransferFromInput
            {
                Symbol = State.BaseTokenSymbol.Value,
                From = Context.Sender,
                To = Context.Self,
                Amount = amountToPay
            });
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
        // Transfer bought token
        State.TokenContract.Transfer.Send(
            new TransferInput
            {
                Symbol = input.Symbol,
                To = Context.Sender,
                Amount = input.Amount
            });

        Context.Fire(new TokenBought
        {
            Symbol = input.Symbol,
            BoughtAmount = input.Amount,
            BaseAmount = amountToPay,
            FeeAmount = fee
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-416)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }

    private AuthorityInfo GetDefaultConnectorController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```
