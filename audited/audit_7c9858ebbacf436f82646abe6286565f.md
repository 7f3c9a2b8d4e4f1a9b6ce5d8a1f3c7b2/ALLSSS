### Title
TokenHolder Scheme Symbol Overwrite Causes Permanent Fund Lock

### Summary
The `CreateScheme` method in TokenHolderContract lacks validation to prevent overwriting existing schemes. A scheme manager can call `CreateScheme` multiple times with different symbols, causing a mismatch between the symbol used during token locking and the symbol used during withdrawal. This results in users' locked tokens becoming permanently inaccessible as the `Withdraw` function attempts to unlock tokens using the wrong symbol.

### Finding Description

**Root Cause:**
The `CreateScheme` method directly overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without checking if a scheme already exists for that manager. [1](#0-0) 

**Execution Path:**

1. **Initial Lock:** When users call `RegisterForProfits`, tokens are locked using `scheme.Symbol` from the current scheme: [2](#0-1) 

The tokens are transferred to a virtual address computed from `Context.Sender + input.Address + input.LockId` (note: symbol is NOT part of the virtual address): [3](#0-2) 

2. **Scheme Overwrite:** Manager calls `CreateScheme` again with a different symbol, completely replacing the stored scheme.

3. **Failed Unlock:** When users call `Withdraw`, it retrieves the NEW scheme with the changed symbol: [4](#0-3) 

The `GetLockedAmount` call queries the balance at the virtual address for the NEW symbol, returning zero because the virtual address only contains tokens of the ORIGINAL symbol: [5](#0-4) 

The subsequent `Unlock` call attempts to unlock zero tokens of the wrong symbol, leaving the original tokens permanently locked.

**Why Protections Fail:**
- No assertion validates scheme existence before overwrite
- No test coverage for repeated `CreateScheme` calls
- The virtual address computation is symbol-agnostic, creating an implicit dependency that symbol must remain constant

### Impact Explanation

**Direct Fund Impact:**
- **Permanent Fund Loss:** All users who registered for profits under the original scheme lose access to their locked tokens
- **Quantified Damage:** If N users locked amount A tokens each, total locked value = N × A becomes permanently inaccessible
- **Irreversible:** The virtual address holding the original tokens becomes inaccessible as the lockId remains the same but symbol changes
- **Who is Affected:** All beneficiaries who called `RegisterForProfits` before the scheme symbol change

**Severity Justification:**
This is a **CRITICAL** vulnerability because:
1. Results in permanent, irreversible fund loss
2. Affects all users of the scheme
3. Funds cannot be recovered through any contract mechanism
4. Violates the critical invariant: "lock/unlock correctness"

### Likelihood Explanation

**Attacker Capabilities:**
- The scheme manager (who calls `CreateScheme`) is typically a trusted role, BUT this vulnerability can occur through:
  - **Accidental misuse:** Manager inadvertently calls `CreateScheme` twice during contract setup
  - **Malicious intent:** Compromised or rogue manager intentionally locks user funds
  - **Contract upgrade scenarios:** Management changes leading to scheme reinitialization attempts

**Attack Complexity:**
- **LOW:** Single function call to `CreateScheme` with different symbol
- **No preconditions:** Only requires being the scheme manager (Context.Sender)
- **No cost barriers:** Standard transaction fee only

**Feasibility:**
- Entry point is public: [6](#0-5) 
- All steps executable under AElf contract semantics
- No special permissions beyond being scheme manager

**Detection/Prevention:**
- No events fired indicating scheme overwrite
- No monitoring mechanism to detect symbol changes
- Silent failure mode makes detection post-incident difficult

**Probability Assessment:** MEDIUM-HIGH
Even if the manager role is trusted, the lack of validation creates operational risk through human error or system misuse.

### Recommendation

**Code-Level Mitigation:**
Add an assertion in `CreateScheme` to prevent overwriting existing schemes:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    // Add validation
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, 
        "Scheme already exists for this manager.");
    
    if (State.ProfitContract.Value == null)
        State.ProfitContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
    // ... rest of implementation
}
```

**Invariant Checks:**
1. Enforce one-time scheme creation per manager address
2. Add validation that scheme symbol matches locked tokens before unlock
3. Consider adding scheme update functionality with proper migration logic if symbol changes are legitimately needed

**Test Cases:**
Add test coverage for:
1. Repeated `CreateScheme` calls should fail with clear error message
2. Withdraw should fail gracefully if symbol mismatch detected
3. Integration test: lock with symbol A, attempt CreateScheme with symbol B, verify rejection

### Proof of Concept

**Initial State:**
- Manager (address M) has no existing scheme
- User (address U) has 1000 ELF tokens, approved TokenHolder contract

**Transaction Sequence:**

1. **Manager creates scheme with ELF:**
   - Call: `TokenHolderContract.CreateScheme({Symbol: "ELF", MinimumLockMinutes: 1})`
   - Sender: M
   - Result: `State.TokenHolderProfitSchemes[M].Symbol = "ELF"`

2. **User registers and locks tokens:**
   - Call: `TokenHolderContract.RegisterForProfits({SchemeManager: M, Amount: 1000})`
   - Sender: U
   - Result: 1000 ELF locked at virtual address V = Hash(TokenHolderContract + U + lockId)
   - State: `State.LockIds[M][U] = lockId`

3. **Manager overwrites scheme with USDT:**
   - Call: `TokenHolderContract.CreateScheme({Symbol: "USDT", MinimumLockMinutes: 1})`
   - Sender: M
   - Result: `State.TokenHolderProfitSchemes[M].Symbol = "USDT"` (overwrites!)

4. **User attempts withdrawal:**
   - Wait: MinimumLockMinutes passes
   - Call: `TokenHolderContract.Withdraw(M)`
   - Sender: U
   - Execution:
     - Retrieves scheme: `symbol = "USDT"`
     - Calls `GetLockedAmount(U, lockId, "USDT")` → returns 0 (V has ELF not USDT)
     - Calls `Unlock(U, lockId, 0, "USDT")` → unlocks 0 tokens
   - Result: SUCCESS but unlocks 0 tokens

**Expected vs Actual Result:**
- **Expected:** User withdraws 1000 ELF tokens
- **Actual:** User withdraws 0 tokens; 1000 ELF remains locked at virtual address V forever

**Success Condition for Exploit:**
User's locked ELF tokens become permanently inaccessible while `Withdraw` transaction completes without reverting.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-236)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L208-212)
```csharp
        var fromVirtualAddress = HashHelper.ComputeFrom(Context.Sender.Value.Concat(input.Address.Value)
            .Concat(input.LockId.Value).ToArray());
        var virtualAddress = Context.ConvertVirtualAddressToContractAddress(fromVirtualAddress);
        // Transfer token to virtual address.
        DoTransfer(input.Address, virtualAddress, input.Symbol, input.Amount, input.Usage);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-116)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
    }
```
