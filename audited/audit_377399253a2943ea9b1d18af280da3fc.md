# Audit Report

## Title
Cross-Snapshot Withdrawal Leaves Stale Vote Counts in Subsequent Snapshots

## Summary
The Vote contract's `Withdraw()` function only updates the snapshot where the vote was originally cast, but fails to update subsequent snapshots that have inherited cumulative vote counts. This creates a state inconsistency where withdrawn votes persist in later snapshots' aggregate metrics, leading to inflated `VotesAmount` and `VotersCount` values that can affect governance decisions.

## Finding Description

The vulnerability stems from the interaction between two mechanisms in the Vote contract:

**Snapshot Inheritance Mechanism:**
When `TakeSnapshot()` is called, it creates a new snapshot that inherits `VotersCount` and `VotesAmount` from the previous snapshot as carried-over cumulative metrics. [1](#0-0) 

**Withdrawal Update Mechanism:**
When a voter withdraws their vote via `Withdraw()`, the function retrieves the voting result hash using only the snapshot number stored in the original voting record. [2](#0-1) 

The withdrawal then updates only that specific snapshot's `VotingResult` by subtracting the vote amount and decrementing the voter count. [3](#0-2) 

**Root Cause:**
The withdrawal logic does not iterate through or update any subsequent snapshots that have already inherited the vote counts from the original snapshot. Once `TakeSnapshot()` copies the cumulative counts forward, those copies remain immutable with respect to withdrawals from earlier snapshots.

**Attack Scenario:**
1. Attacker votes with amount X in Snapshot 1
   - Snapshot 1: `VotesAmount = X`, `VotersCount = 1`
2. Sponsor calls `TakeSnapshot()` to create Snapshot 2
   - Snapshot 2 inherits: `VotesAmount = X`, `VotersCount = 1`
3. Attacker withdraws the vote
   - Snapshot 1 updated: `VotesAmount = 0`, `VotersCount = 0`
   - Snapshot 2 remains unchanged: `VotesAmount = X`, `VotersCount = 1` (stale data)

## Impact Explanation

**Inflated Governance Metrics:**
The Election contract exposes `GetVotersCount()` and `GetVotesAmount()` methods that query the Vote contract's voting results. [4](#0-3) 

These methods will return inflated values for any snapshot queried after withdrawals from earlier snapshots have occurred.

**Governance Manipulation:**
For each withdrawn vote of amount X from snapshot N, all subsequent snapshots N+1, N+2, etc. retain X in their `VotesAmount` and potentially +1 in their `VotersCount`. This creates a multiplier effect where:
- The same tokens can be counted multiple times in aggregate statistics
- Voter participation appears artificially higher than reality
- Quorum calculations and governance decisions based on these metrics become unreliable

**Affected Parties:**
Any external contract, dApp, or governance mechanism that queries voting statistics to make decisions based on voter participation or total vote amounts will receive incorrect data.

## Likelihood Explanation

**Attacker Capabilities:**
Any voter can execute this issue with standard voter operations - no special permissions required beyond the ability to vote and withdraw.

**Attack Complexity:**
Very low complexity:
1. Vote in snapshot N with any amount
2. Wait for sponsor to call `TakeSnapshot()` 
3. Call `Withdraw()` with the vote ID
4. Subsequent snapshots now have inflated counts

**Feasibility:**
The issue is always feasible when a voting item has multiple snapshots (`TotalSnapshotNumber > 1`) and withdrawals are allowed (either token locking enabled for voter withdrawal, or disabled for sponsor withdrawal).

**Probability:**
HIGH - This is a systematic flaw that occurs whenever withdrawals happen after snapshot transitions, not an edge case. The existing test suite demonstrates this scenario but only verifies the original snapshot's state after withdrawal, not subsequent snapshots. [5](#0-4) 

## Recommendation

The `Withdraw()` function should be modified to propagate withdrawal updates to all subsequent snapshots that have inherited the vote counts. One approach:

1. Track which snapshots exist for each voting item
2. When withdrawing, iterate through all snapshots with `SnapshotNumber > votingRecord.SnapshotNumber`
3. Update each subsequent snapshot's `VotesAmount`, `Results`, and potentially `VotersCount`

Alternative approach: Instead of copying cumulative counts forward, each snapshot could maintain only delta changes, and view methods would aggregate across all snapshots up to the requested one.

## Proof of Concept

```csharp
[Fact]
public async Task VoteContract_Withdraw_InflatesSubsequentSnapshot_Test()
{
    // Register voting item with 3 snapshots
    var votingItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 3);
    var voteUser = Accounts[1].KeyPair;
    var voteAmount = 10000;
    
    // Vote in Snapshot 1
    await Vote(voteUser, votingItem.VotingItemId, votingItem.Options[0], voteAmount);
    var voteIds = await GetVoteIds(voteUser, votingItem.VotingItemId);
    var voteId = voteIds.ActiveVotes.First();
    
    // Verify Snapshot 1 has the vote
    var snapshot1Before = await GetVotingResult(votingItem.VotingItemId, 1);
    snapshot1Before.VotesAmount.ShouldBe(voteAmount);
    snapshot1Before.VotersCount.ShouldBe(1);
    
    // Take snapshot to create Snapshot 2 (inherits counts)
    await TakeSnapshot(votingItem.VotingItemId, 1);
    
    // Verify Snapshot 2 inherited the counts
    var snapshot2Before = await GetVotingResult(votingItem.VotingItemId, 2);
    snapshot2Before.VotesAmount.ShouldBe(voteAmount); // Inherited
    snapshot2Before.VotersCount.ShouldBe(1); // Inherited
    
    // Withdraw the vote
    await Withdraw(voteUser, voteId);
    
    // Verify Snapshot 1 was updated correctly
    var snapshot1After = await GetVotingResult(votingItem.VotingItemId, 1);
    snapshot1After.VotesAmount.ShouldBe(0);
    snapshot1After.VotersCount.ShouldBe(0);
    
    // BUG: Snapshot 2 still has inflated counts
    var snapshot2After = await GetVotingResult(votingItem.VotingItemId, 2);
    snapshot2After.VotesAmount.ShouldBe(voteAmount); // STALE - should be 0
    snapshot2After.VotersCount.ShouldBe(1); // STALE - should be 0
}
```

This test demonstrates that after withdrawal, Snapshot 2 retains the vote amount and voter count even though the vote was withdrawn, creating inconsistent state across snapshots.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-207)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-222)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-238)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }

    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L259-280)
```csharp
        await TakeSnapshot(voteItemId, 1);


        var beforeBalance = GetUserBalance(voteAddress);
        var transactionResult = await Withdraw(voteUser, currentVoteId);
        transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(0);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(1);
        var voteRecordAfterWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordAfterWithdraw.IsWithdrawn.ShouldBe(true);
        var voteResultAfterWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        voteResultBeforeWithdraw.VotesAmount.Sub(voteResultAfterWithdraw.VotesAmount).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.Results[registerItem.Options[1]]
            .Sub(voteResultAfterWithdraw.Results[registerItem.Options[1]]).ShouldBe(voteAmount);
        voteResultBeforeWithdraw.VotersCount.Sub(1).ShouldBe(voteResultAfterWithdraw.VotersCount);
        var afterBalance = GetUserBalance(voteAddress);
        beforeBalance.ShouldBe(afterBalance - 100);
```
