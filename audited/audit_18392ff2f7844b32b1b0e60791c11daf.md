### Title
Term Change Bypass via Premature UpdateValue Behavior Selection

### Summary
The `HandleMinerInNewRound()` method returns `UpdateValue` behavior for miners who haven't mined in the current round without checking if a term change is needed, causing `NormalBlockCommandStrategy` to be invoked inappropriately. This bypasses critical term transition logic, preventing election results from being applied, treasury releases, and miner list updates, leading to consensus state inconsistency.

### Finding Description

**Root Cause:**
The vulnerability exists in the consensus behavior determination logic. When a miner who hasn't mined in the current round (OutValue is null) requests a consensus command, the system calls `HandleMinerInNewRound()` to determine the appropriate behavior. [1](#0-0) 

The `HandleMinerInNewRound()` method returns `UpdateValue` if the miner's time slot hasn't passed, without checking if a term change is needed: [2](#0-1) 

This bypasses the term change detection that only occurs in `GetConsensusBehaviourToTerminateCurrentRound()`: [3](#0-2) 

**Why Protections Fail:**

1. The first round guard only protects round 1, not term changes: [4](#0-3) 

2. When `UpdateValue` is returned, `NormalBlockCommandStrategy` is instantiated with hardcoded `UpdateValue` behavior: [5](#0-4) 

3. The validation provider only checks OutValue/Signature presence, not term change requirements: [6](#0-5) 

**Term Change Detection Logic:**
Term changes are detected in `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()` using `NeedToChangeTerm()`: [7](#0-6) [8](#0-7) 

However, this logic is never reached when `HandleMinerInNewRound()` returns early with `UpdateValue`.

### Impact Explanation

**Consensus Integrity Violation:**
When `ProcessUpdateValue` executes instead of `ProcessNextTerm`, critical term transition tasks are skipped: [9](#0-8) 

The `ProcessNextTerm` method performs essential operations that don't occur: [10](#0-9) 

**Specific Harms:**
- **Election Results Not Applied**: New miners elected in governance are not added to the miner list (lines 188-190)
- **Treasury Funds Not Released**: Scheduled treasury releases for the term don't occur (lines 203-211)
- **Reward Misallocation**: Mining rewards and dividends are not properly distributed
- **Election Snapshot Missing**: Vote snapshots for the term are not taken (lines 213-218)
- **Term Number Stale**: The consensus remains stuck in the old term (line 173)
- **Miner Statistics Not Reset**: ProducedBlocks and MissedTimeSlots counters remain from previous term (lines 179-183)

**Affected Parties:**
- All network participants experience consensus state inconsistency
- Newly elected miners cannot participate despite winning election
- Token holders don't receive expected treasury distributions
- Voters' election participation becomes ineffective

**Severity Justification:**
HIGH - This breaks a critical consensus invariant (correct term transitions), preventing governance election results from taking effect and disrupting the entire economic reward distribution mechanism.

### Likelihood Explanation

**Reachable Entry Point:**
The vulnerability is triggered through the normal consensus flow via `GetConsensusCommand()`: [11](#0-10) 

**Feasible Preconditions:**
1. Current term has exceeded its period duration (term change needed)
2. A miner in the current miner list hasn't mined in the current round yet (OutValue == null)
3. The miner requests a consensus command during their assigned time slot
4. The miner is not the extra block producer from previous round

**Execution Practicality:**
These conditions occur naturally during normal consensus operation:
- Term changes happen periodically based on `periodSeconds` configuration
- Miners frequently request commands at the start of their time slots before mining
- The OutValue is only set after a miner mines their first block in a round
- No special privileges or manipulation required beyond being in the miner list

**Attack Complexity:**
LOW - This is not an attack but a protocol flaw that occurs during normal operation. Any miner can inadvertently trigger this by requesting a command at the right time when a term change is due.

**Detection/Operational Constraints:**
The issue may go undetected initially as the blockchain continues operating, but the consensus state becomes increasingly divergent from expected governance outcomes over time.

**Probability Reasoning:**
HIGH - Given the frequency of consensus commands and the periodic nature of term changes, this condition will inevitably occur in production.

### Recommendation

**Code-Level Mitigation:**

Modify `HandleMinerInNewRound()` in `ConsensusBehaviourProviderBase.cs` to check for term changes before returning `UpdateValue`:

```csharp
private AElfConsensusBehaviour HandleMinerInNewRound()
{
    if (
        CurrentRound.RoundNumber == 1 &&
        _minerInRound.Order != 1 &&
        CurrentRound.FirstMiner().OutValue == null
    )
        return AElfConsensusBehaviour.NextRound;

    if (
        CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
        _currentBlockTime < CurrentRound.GetRoundStartTime() &&
        _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
    )
        return AElfConsensusBehaviour.TinyBlock;

    // ADD THIS CHECK: Delegate to term change detection if OutValue is null
    // but we're not in a valid time slot for UpdateValue
    if (!_isTimeSlotPassed)
        return AElfConsensusBehaviour.UpdateValue;
    
    // If time slot passed with null OutValue, check for term/round termination
    return GetConsensusBehaviourToTerminateCurrentRound();
}
```

**Alternative Fix:**
Add term change validation to `UpdateValueValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };

    // ADD: Check if term change should have occurred
    if (ShouldHaveChangedTerm(validationContext))
        return new ValidationResult { Message = "Term change required but UpdateValue provided." };

    return new ValidationResult { Success = true };
}
```

**Invariant Checks:**
- Before returning `UpdateValue` from `HandleMinerInNewRound()`, verify that `GetConsensusBehaviourToTerminateCurrentRound()` would not return `NextTerm`
- Add assertion in `ProcessUpdateValue` to verify term change is not needed
- Add monitoring/alerting for term number lag compared to expected based on blockchain start time

**Test Cases:**
1. Test term change scenario where multiple miners haven't mined in current round
2. Test that term change takes priority over UpdateValue when both conditions exist
3. Test round boundary conditions where OutValue is null and term change is due
4. Verify election results are applied when term changes occur correctly

### Proof of Concept

**Required Initial State:**
1. Main chain with configured `periodSeconds = 604800` (7 days)
2. Current term number = 2, current round number = 10
3. Blockchain start timestamp + (2 * 604800) seconds has passed (term 3 should begin)
4. Miner "MinerA" is in current miner list
5. Current round: MinerA.OutValue == null (hasn't mined this round yet)
6. Current time is within MinerA's assigned time slot

**Transaction Steps:**

1. **MinerA requests consensus command:**
   - Call: `GetConsensusCommand(BytesValue(MinerA.Pubkey))`
   - Expected: Should return command with `NextTerm` behavior
   - Actual: Returns command with `UpdateValue` behavior

2. **Execution Flow:**
   ```
   GetConsensusCommand()
   → MainChainConsensusBehaviourProvider.GetConsensusBehaviour()
   → ConsensusBehaviourProviderBase.GetConsensusBehaviour()
   → HandleMinerInNewRound() [OutValue == null]
   → Returns UpdateValue [time slot not passed]
   → NormalBlockCommandStrategy instantiated
   → Command with UpdateValue behavior returned
   ```

3. **MinerA mines block with UpdateValue:**
   - Transaction: `UpdateValue(UpdateValueInput)`
   - Expected: Should trigger term transition
   - Actual: Executes `ProcessUpdateValue()` instead of `ProcessNextTerm()`

4. **Verify State Inconsistency:**
   - Check `State.TermNumber.Value`: Still 2 (should be 3)
   - Check miner list: Old miners still active (new election results not applied)
   - Check `State.FirstRoundNumberOfEachTerm[3]`: Not set
   - Check Election contract: Snapshot for term 2 not taken
   - Check Treasury: No release executed for term 2

**Success Condition:**
Term change is bypassed, consensus continues in old term despite exceeding term duration, and all term transition side effects (miner list update, treasury release, election snapshot) are skipped.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L114-114)
```csharp
            return !_isTimeSlotPassed ? AElfConsensusBehaviour.UpdateValue : AElfConsensusBehaviour.Nothing;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L28-30)
```csharp
        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/NormalBlockCommandStrategy.cs (L28-40)
```csharp
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                {
                    Behaviour = AElfConsensusBehaviour.UpdateValue,
                    RoundId = CurrentRound.RoundId,
                    PreviousRoundId = _previousRoundId
                }.ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                // Cancel mining after time slot of current miner because of the task queue.
                MiningDueTime = CurrentRound.GetExpectedMiningTime(Pubkey).AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock = DefaultBlockMiningLimit
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```
