### Title
Changing Method Fee Controller Invalidates Pending Proposals Without Notification

### Summary
The `ChangeMethodFeeController()` function updates `State.MethodFeeController.Value` without any callbacks or notifications to dependent systems. This breaks ongoing governance proposals that were created under the old controller organization, as they will fail authorization checks when released after the controller change.

### Finding Description

In `BasicContractZeroContract_ACS1_TransactionFeeProvider.cs`, the `ChangeMethodFeeController()` function directly updates the controller state: [1](#0-0) 

**Root Cause**: When a governance proposal to call `SetMethodFee` is created, it stores the organization address of the current controller. When that proposal is later released, the governance contract (Parliament/Association/Referendum) uses `SendVirtualInlineBySystemContract` to execute the target method: [2](#0-1) 

The inline transaction's `From` address is derived from the organization that created the proposal, which becomes `Context.Sender` in the called contract: [3](#0-2) 

However, `SetMethodFee` validates authorization by checking if `Context.Sender` equals the current controller's owner address: [4](#0-3) 

**Why Protections Fail**: If the controller changes between proposal creation and release, `Context.Sender` (old organization address) will not match `State.MethodFeeController.Value.OwnerAddress` (new organization address), causing the assertion to fail with "Unauthorized to set method fee."

### Impact Explanation

**Governance Disruption**: Approved proposals that were legitimately created and voted on under the old controller become permanently unusable after a controller change. The governance process is broken for these proposals - they passed all approval thresholds but cannot execute their intended actions.

**Resource Waste**: Time, effort, and voting power spent by governance participants on proposals that ultimately fail to execute are wasted. In Parliament governance, this involves miner coordination and approval.

**Denial of Service**: This can be exploited to intentionally block specific method fee changes. An adversary could:
1. Observe an approved proposal for unwanted fee changes
2. Rush through a controller change proposal before the fee change is released
3. Effectively veto the fee change without needing rejection votes

**System Configuration Stalls**: Critical method fee updates required for system operation or economic adjustments cannot be applied if the controller changes before release, potentially affecting transaction costs across the entire system.

### Likelihood Explanation

**Attacker Capabilities**: Any party with normal proposal creation privileges can trigger this issue. No special administrative access is required.

**Attack Complexity**: Medium complexity:
- Requires creating and approving a controller change proposal
- Timing must be such that the controller change releases before pending SetMethodFee proposals
- More likely in active governance environments with multiple concurrent proposals

**Feasibility Conditions**: 
- Active governance with multiple proposals in flight is common
- Natural occurrence: Administrators may legitimately change controllers without realizing pending proposals exist
- Intentional exploitation: Adversaries can monitor pending proposals and time controller changes strategically

**Probability**: Medium to High in active governance scenarios. The test suite shows controller changes are a regular governance operation: [5](#0-4) 

However, no tests verify the behavior of pending proposals during controller transitions, indicating this edge case was not considered.

### Recommendation

**Immediate Fix**: Implement a grace period or proposal migration mechanism:

1. Add a mapping to track pending proposals by their organization addresses:
```csharp
// In state definition
public MappedState<Address, BoolState> PendingProposalOrganizations { get; set; }
```

2. Modify `ChangeMethodFeeController()` to check for pending proposals:
```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    // Check for pending proposals under old controller
    var oldController = State.MethodFeeController.Value;
    Assert(!HasPendingProposals(oldController.OwnerAddress), 
        "Cannot change controller while proposals are pending. Release or clear pending proposals first.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

3. Alternatively, modify `SetMethodFee` to accept both current and previous controller:
```csharp
Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress || 
       Context.Sender == State.PreviousMethodFeeController.Value?.OwnerAddress, 
       "Unauthorized to set method fee.");
```

**Test Cases**: Add regression tests verifying:
- Controller change fails if proposals are pending
- Or pending proposals under old controller can still execute after controller change
- Controller change with no pending proposals succeeds

### Proof of Concept

**Initial State**:
- Parliament default organization O1 controls method fees
- `State.MethodFeeController.Value.OwnerAddress = O1`

**Attack Sequence**:

1. Create proposal P1 under organization O1 to call `SetMethodFee` with new fees:
   - Proposer creates proposal targeting BasicContractZero.SetMethodFee
   - Proposal stores `OrganizationAddress = O1`

2. P1 gets approved by parliament miners but not yet released

3. Create new parliament organization O2 with different thresholds

4. Create proposal P2 under organization O1 to call `ChangeMethodFeeController(O2)`

5. P2 gets approved and released successfully:
   - Executes `ChangeMethodFeeController`
   - `State.MethodFeeController.Value.OwnerAddress = O2`

6. Attempt to release P1:
   - Parliament.Release calls `SendVirtualInlineBySystemContract` with O1's virtual hash
   - Inline transaction has `From = O1` (virtual address derived from O1)
   - SetMethodFee executes with `Context.Sender = O1`
   - Check: `Context.Sender (O1) == State.MethodFeeController.Value.OwnerAddress (O2)` â†’ **FAILS**
   - Transaction reverts with error: "Unauthorized to set method fee."

**Expected Result**: P1 should execute successfully as it was approved under the legitimate controller

**Actual Result**: P1 fails authorization check and cannot be executed, despite having passed all approval thresholds

**Success Condition**: The vulnerability is confirmed when a legitimately approved SetMethodFee proposal fails to execute after a controller change, with no mechanism to migrate or honor pre-existing approvals.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L266-276)
```csharp
    public void SendVirtualInlineBySystemContract(Hash fromVirtualAddress, Address toAddress, string methodName,
        ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = ConvertVirtualAddressToContractAddressWithContractHashName(fromVirtualAddress, Self),
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L1208-1239)
```csharp
    public async Task ChangeMethodFeeController_Test()
    {
        var createOrganizationResult = await Tester.ExecuteContractWithMiningAsync(ParliamentAddress,
            nameof(ParliamentContractImplContainer.ParliamentContractImplStub.CreateOrganization),
            new CreateOrganizationInput
            {
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = 1000,
                    MinimalVoteThreshold = 1000
                }
            });

        var organizationAddress = Address.Parser.ParseFrom(createOrganizationResult.ReturnValue);

        var methodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        const string proposalCreationMethodName =
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.ChangeMethodFeeController);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new AuthorityInfo
            {
                OwnerAddress = organizationAddress,
                ContractAddress = ParliamentAddress
            });
        await ApproveWithMinersAsync(Tester, ParliamentAddress, proposalId);
        var txResult2 = await ReleaseProposalAsync(Tester, ParliamentAddress, proposalId);
        txResult2.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMethodFeeController = await GetMethodFeeController(Tester, BasicContractZeroAddress);
        Assert.True(newMethodFeeController.OwnerAddress == organizationAddress);
    }
```
