### Title
Miner Time Manipulation via Unvalidated ActualMiningTime in Consensus Extra Data

### Summary
Miners can manipulate their `ActualMiningTimes` by crafting consensus extra data with false timestamps that differ from `Context.CurrentBlockTime`. The consensus validation logic fails to verify that the reported `ActualMiningTime` matches the actual block time, allowing miners to distort term transitions, time slot calculations, and consensus timing mechanisms.

### Finding Description

The vulnerability exists in how `ActualMiningTime` values are validated when miners produce blocks.

**Entry Point:** [1](#0-0) 

When generating consensus transactions, `ExtractInformationToUpdateConsensus` extracts the last `ActualMiningTime` from a miner's record and includes it in the `UpdateValueInput`.

**Expected Behavior:** [2](#0-1) 

The legitimate flow adds `Context.CurrentBlockTime` to `ActualMiningTimes` when generating consensus extra data.

**Root Cause - Missing Validation:**

When consensus extra data is validated, the system performs hash comparisons but explicitly excludes `ActualMiningTimes`: [3](#0-2) 

The `GetCheckableRound` method clears all `ActualMiningTimes` before computing the hash (line 193), meaning the hash comparison cannot detect manipulated timestamps.

**Time Slot Validation Failure:** [4](#0-3) 

The `TimeSlotValidationProvider` only validates the PREVIOUS `ActualMiningTime` from stored state (line 40-41), not the NEW timestamp being added in the current block's consensus extra data.

**State Update Without Validation:** [5](#0-4) 

The manipulated `ActualMiningTime` from the consensus extra data is directly added to state without any validation that it matches `Context.CurrentBlockTime`.

**Consensus Extra Data Recovery:** [6](#0-5) 

During validation, `RecoverFromUpdateValue` copies the entire `ActualMiningTimes` collection from the provided round to the base round without validating individual timestamps.

### Impact Explanation

**1. Term Transition Manipulation:** [7](#0-6) 

The `NeedToChangeTerm` function uses `ActualMiningTimes.Last()` from each miner to determine when to change consensus terms. If two-thirds of miners report manipulated timestamps, they can:
- Delay term changes by reporting earlier times (avoiding term change threshold)
- Accelerate term changes by reporting later times (prematurely triggering term transitions)

This directly violates the "Correct round transitions and time-slot validation" critical invariant.

**2. Round 1 Time Slot Distortion:** [8](#0-7) 

In the first round, `IsTimeSlotPassed` uses `FirstMiner().ActualMiningTimes.First()` as the reference time. If the first miner manipulates this timestamp, all subsequent miners' time slot calculations are affected, potentially allowing or denying mining opportunities incorrectly.

**3. Consensus Behavior Manipulation:** [9](#0-8) 

Time-based decisions for `TinyBlock` behavior use `ActualMiningTimes` for calculations. Manipulated timestamps affect whether miners can continue producing tiny blocks or must terminate rounds.

**Severity:** HIGH - Direct compromise of consensus integrity, miner schedule fairness, and term transition timing without requiring collusion (single miner can exploit) or complex attack setup.

### Likelihood Explanation

**Attacker Profile:**
Any scheduled miner in the AEDPoS consensus system can execute this attack during their allocated block production time slot.

**Attack Complexity:** LOW
1. Attacker waits for their scheduled mining turn
2. Instead of using legitimate consensus extra data generation, crafts custom `AElfConsensusHeaderInformation` with manipulated `ActualMiningTimes`
3. Sets `ActualMiningTime` to desired false timestamp (e.g., 10 seconds earlier/later than `Context.CurrentBlockTime`)
4. Broadcasts block with manipulated consensus extra data
5. Block passes all validations due to missing timestamp verification

**Preconditions:**
- Attacker must be in the current miner list (normal operational requirement)
- No special permissions or governance control needed

**Detection Difficulty:** HIGH
The manipulated timestamps are stored in state and used in future calculations. Without external timestamp monitoring, the manipulation appears as legitimate mining activity in the contract state.

**Economic Rationality:**
Attack cost is negligible (normal block production cost). Potential gains include:
- Extended mining windows through time slot manipulation
- Strategic term transition control
- Competitive advantage over honest miners in subsequent rounds

### Recommendation

**1. Add Explicit Timestamp Validation:**

In `ProcessUpdateValue`, add validation immediately after line 243: [10](#0-9) 

```csharp
// After line 243:
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime, 
    "ActualMiningTime must match current block time");
```

**2. Add Similar Validation for TinyBlock:** [11](#0-10) 

Add timestamp validation after line 304 in `ProcessTinyBlock`.

**3. Enhance Hash Validation:**

Consider modifying `GetCheckableRound` to include `ActualMiningTimes` in hash computation for the current block's miner: [12](#0-11) 

Or create separate validation that explicitly checks the latest `ActualMiningTime` entry matches `Context.CurrentBlockTime`.

**4. Add Validation Provider:**

Create `ActualMiningTimeValidationProvider` that validates the NEW `ActualMiningTime` being added (not just previous ones) matches the current block timestamp.

### Proof of Concept

**Initial State:**
- Blockchain is running with multiple miners in rotation
- Attacker is miner "MinerA" scheduled to produce block at height 1000
- Current time: 2024-01-01 12:00:00

**Attack Steps:**

1. **MinerA's Turn Arrives:**
   - Legitimate `Context.CurrentBlockTime` would be 2024-01-01 12:00:00

2. **MinerA Crafts Malicious Consensus Extra Data:**
   - Instead of calling `GetConsensusBlockExtraData` normally
   - Creates custom `AElfConsensusHeaderInformation`
   - Sets `ActualMiningTime` in the round data to 2024-01-01 11:59:50 (10 seconds earlier)

3. **Block Validation Occurs:** [13](#0-12) 
   
   - `TimeSlotValidationProvider` checks PREVIOUS `ActualMiningTime` from state (line 40-41), not the new one → PASSES
   - Hash comparison in `ValidateConsensusAfterExecution` ignores `ActualMiningTimes` (cleared in GetCheckableRound) → PASSES
   - No validation checks `ActualMiningTime == Context.CurrentBlockTime` → NO CHECK EXISTS

4. **Block Executes Successfully:** [14](#0-13) 
   
   - False timestamp (11:59:50) added to MinerA's `ActualMiningTimes` in contract state

5. **Impact Manifests:** [7](#0-6) 
   
   - Future term change calculations use manipulated timestamp
   - If this was the first miner in round 1, all other miners' time slots are calculated from the false baseline
   - MinerA's future time slot validations use the manipulated time as reference

**Expected Result:** Block rejected due to ActualMiningTime validation failure

**Actual Result:** Block accepted, false timestamp stored in state, consensus integrity compromised

**Success Condition:** Query contract state shows MinerA's `ActualMiningTimes` contains 11:59:50 instead of 12:00:00, proving timestamp manipulation succeeded without detection.

### Notes

This vulnerability represents a fundamental weakness in the consensus timestamp validation architecture. The issue is compounded by the design decision to exclude `ActualMiningTimes` from hash-based integrity checks, likely done to allow flexibility in block timing but inadvertently creating an attack vector.

The impact is particularly severe in round 1 scenarios where the first miner's `ActualMiningTime` becomes the reference point for all subsequent time slot calculations. A single malicious first miner can distort the entire round's timing without needing to collude with other miners.

While term transition manipulation requires two-thirds of miners to coordinate (per the `MinersCountOfConsent` threshold), individual time slot advantages can be gained by any single miner, making this a practical attack vector in production environments.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L92-98)
```csharp
        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-194)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L218-223)
```csharp
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L40-42)
```csharp
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-244)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-304)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L14-20)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L60-65)
```csharp
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L16-104)
```csharp
    private ValidationResult ValidateBeforeExecution(AElfConsensusHeaderInformation extraData)
    {
        // According to current round information:
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };

        // Skip the certain initial miner during first several rounds. (When other nodes haven't produce blocks yet.)
        if (baseRound.RealTimeMinersInformation.Count != 1 &&
            Context.CurrentHeight < AEDPoSContractConstants.MaximumTinyBlocksCount.Mul(3))
        {
            string producedMiner = null;
            var result = true;
            for (var i = baseRound.RoundNumber; i > 0; i--)
            {
                var producedMiners = State.Rounds[i].RealTimeMinersInformation.Values
                    .Where(m => m.ActualMiningTimes.Any()).ToList();
                if (producedMiners.Count != 1)
                {
                    result = false;
                    break;
                }

                if (producedMiner == null)
                    producedMiner = producedMiners.Single().Pubkey;
                else if (producedMiner != producedMiners.Single().Pubkey) result = false;
            }

            if (result) return new ValidationResult { Success = true };
        }

        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());

        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };

        /* Ask several questions: */

        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }

        var service = new HeaderInformationValidationService(validationProviders);

        Context.LogDebug(() => $"Validating behaviour: {extraData.Behaviour.ToString()}");

        var validationResult = service.ValidateInformation(validationContext);

        if (validationResult.Success == false)
            Context.LogDebug(() => $"Consensus Validation before execution failed : {validationResult.Message}");

        return validationResult;
    }
```
