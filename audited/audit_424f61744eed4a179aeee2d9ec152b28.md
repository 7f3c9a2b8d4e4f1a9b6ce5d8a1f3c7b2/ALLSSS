# Audit Report

## Title
Retroactive Threshold Changes Enable Governance Denial-of-Service Attack

## Summary
The `ChangeOrganizationThreshold()` function in Association, Parliament, and Referendum contracts allows modification of voting thresholds that retroactively affect all existing active proposals. An attacker with proposer privileges can exploit this by creating a proposal to raise thresholds significantly, causing all pending legitimate proposals that had already gathered sufficient votes under the old threshold to become permanently unreleasable, resulting in governance denial-of-service.

## Finding Description

**Root Cause:**

The vulnerability exists because proposal release thresholds are not stored with proposals at creation time. The `ProposalInfo` structure does not include any threshold fields - it only stores metadata like proposal_id, contract_method_name, to_address, params, expired_time, proposer, organization_address, and vote counts/lists. [1](#0-0) 

When `Release()` is called, it dynamically fetches the current organization state and checks thresholds at release time, not at proposal creation time. [2](#0-1) 

The `IsReleaseThresholdReached()` function reads the current threshold values from the organization state, making the check dependent on the organization's current configuration rather than the configuration that existed when the proposal was created. [3](#0-2) 

**Why Protections Fail:**

The `ChangeOrganizationThreshold()` function modifies the threshold in-place by directly updating the organization state without any checks on how this affects existing proposals. [4](#0-3) 

The validation function only verifies structural correctness of the new threshold values (positive numbers, proper mathematical relationships) but does not assess impact on pending proposals. [5](#0-4) 

The same vulnerable pattern exists in Parliament and Referendum contracts. [6](#0-5) [7](#0-6) 

**Execution Path:**

1. Organization has threshold (e.g., MinimalApprovalThreshold = 10,000, MinimalVoteThreshold = 15,000)
2. Legitimate Proposal A is created and gathers 10,500 approvals (meets threshold, ToBeReleased = true)
3. Attacker (in proposer whitelist) creates Proposal B calling `ChangeOrganizationThreshold` with MinimalApprovalThreshold = 1,000,000
4. Proposal B gets approved under current threshold and is released
5. When Proposal B releases, it executes as the organization (via virtual inline call), raising the threshold
6. Proposal A can no longer be released despite having gathered sufficient votes under the original threshold

This behavior is confirmed by the existing test case which explicitly demonstrates that after threshold changes, previously qualifying proposals become unreleasable. [8](#0-7) 

## Impact Explanation

This vulnerability enables a governance denial-of-service attack with HIGH severity impact:

**Direct Harms:**
- **Governance DoS**: Legitimate proposals that met original requirements become permanently blocked
- **Critical Operations Prevention**: Time-sensitive actions like security upgrades, emergency fund releases, or parameter adjustments cannot be executed
- **Trust Violation**: Breaks the fundamental governance guarantee that proposals meeting threshold requirements should be releasable

**Affected Parties:**
- Organization members whose approved proposals are blocked
- Token holders who voted on now-invalidated proposals
- The entire protocol if critical governance decisions are prevented

**Severity Justification:**
This is HIGH severity because it directly compromises governance system availability, a critical protocol function. The attack has concrete, demonstrable impact and affects all three governance contract types (Association, Parliament, Referendum).

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Membership in the organization's proposer whitelist (standard for organization members)
2. Sufficient voting power to pass ONE malicious proposal under current threshold
3. Knowledge of standard proposal creation/approval process

**Attack Complexity: LOW**
- Uses only standard proposal mechanisms
- No advanced technical knowledge required
- Single malicious proposal execution sufficient

**Feasibility:**
- Token accumulation: Attacker can gradually acquire voting power or collude with members
- Low participation exploitation: Easier to pass proposals during low voter participation
- Economic viability: Cost of one proposal approval may be justified by benefits of blocking competing proposals

**Detection Difficulty:**
- Malicious threshold changes are indistinguishable from legitimate governance parameter adjustments
- Damage is immediate and irreversible once executed
- No time-lock or warning period for threshold modifications

**Overall Probability: MEDIUM to HIGH**
Given that organization members naturally have proposer rights and threshold changes are legitimate governance functions, this attack is practically feasible.

## Recommendation

**Solution: Store threshold snapshot with each proposal**

Modify the `ProposalInfo` structure to include the threshold that was active at proposal creation time:

```protobuf
message ProposalInfo {
    // ... existing fields ...
    acs3.ProposalReleaseThreshold creation_threshold = 14;  // Add this field
}
```

Update `CreateNewProposal()` to capture the threshold:

```csharp
var proposal = new ProposalInfo
{
    // ... existing fields ...
    CreationThreshold = organization.ProposalReleaseThreshold
};
```

Modify `Release()` to use the stored threshold instead of current threshold:

```csharp
Assert(IsReleaseThresholdReached(proposalInfo, proposalInfo.CreationThreshold, organization), 
    "Not approved.");
```

This ensures proposals are evaluated against the threshold that was active when they were created, preventing retroactive invalidation.

## Proof of Concept

The existing test case at lines 740-787 in `AssociationContractTests.cs` already demonstrates this vulnerability:

1. Create organization with MinimalVoteThreshold = 1
2. Create and approve Proposal A (ToBeReleased = true)
3. Create Proposal B to change MinimalVoteThreshold to 2
4. Release Proposal B (threshold change executes)
5. Query Proposal A: ToBeReleased = false (retroactively invalidated)

This test explicitly verifies the retroactive behavior exists and works as described in the attack scenario. The test passes because the code implements this behavior, confirming the vulnerability is present in the production contracts.

## Notes

This vulnerability affects all three governance contract implementations (Association, Parliament, Referendum) identically, as they share the same architectural pattern of dynamic threshold evaluation. The issue is particularly severe because:

1. It's a design flaw rather than an implementation bug
2. Existing tests confirm the behavior, suggesting it may have been overlooked as a security issue
3. No protective mechanisms exist in the current codebase
4. The attack uses legitimate governance mechanisms, making it hard to detect or prevent without code changes

### Citations

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-59)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }

    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-160)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }

    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-177)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }

    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }

    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }

    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L740-787)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
        var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, proposalId);
        var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();


        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await associationContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
    }
```
