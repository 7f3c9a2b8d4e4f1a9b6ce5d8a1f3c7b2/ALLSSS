### Title
Governance Proposal Spam via Unrestricted User Contract Deployment on Main Chain

### Summary
The `DeployUserSmartContract()` function lacks access control on the main chain and public side chains, allowing any user to repeatedly create governance proposals by submitting user contracts with slightly different code. This enables an attacker to spam the Parliament governance system with minimal cost, causing state bloat and governance disruption.

### Finding Description

**Entry Point and Access Control Failure:**

The `DeployUserSmartContract()` function at [1](#0-0)  is the entry point that calls permission checks. However, the `AssertUserDeployContract()` function at [2](#0-1)  contains a critical flaw: on main chain or public side chains (where the native symbol matches the primary token symbol), it returns immediately without any permission checks [3](#0-2) , allowing anyone to call this function.

**Insufficient Duplicate Prevention:**

At line 425, the function calls `SendUserContractProposal()` which creates a Parliament proposal. The `SendUserContractProposal()` function at [4](#0-3)  only checks if a proposal with the **exact same hash** already exists [5](#0-4) . This check does not prevent an attacker from creating multiple proposals by slightly varying the input (e.g., changing one byte of code, using different salts, or modifying the category).

**Proposal Creation:**

The input hash is computed from the entire input at [6](#0-5) , meaning any variation in code, category, or salt produces a different hash. Each unique hash creates:
1. A new entry in `State.ContractProposingInputMap` at [7](#0-6) 
2. A new Parliament proposal via `CreateProposalBySystemContract` at [8](#0-7) 

**No Rate Limiting:**

The Parliament contract's `CreateProposalBySystemContract()` function at [9](#0-8)  and the underlying `CreateNewProposal()` at [10](#0-9)  do not implement any rate limiting or maximum proposal count restrictions.

### Impact Explanation

**State Bloat:**
Each spam proposal creates permanent entries in both BasicContractZero's `ContractProposingInputMap` and Parliament's `Proposals` state until they expire. With a default expiration period of 900 seconds (15 minutes) for code check proposals [11](#0-10) , an attacker could maintain hundreds of active proposals simultaneously.

**Governance System DoS:**
Block producers must either:
- Review and vote on spam proposals, wasting governance bandwidth
- Wait 15 minutes for each proposal to expire before manual cleanup via `ClearProposal()` [12](#0-11) 
- Bear the gas cost of individually clearing expired proposals

**Operational Impact:**
The governance system could become overwhelmed if legitimate proposals are buried under spam, delaying critical protocol updates. Each cleanup transaction also costs gas, imposing economic costs on the chain.

**Severity Justification:**
Medium severity due to:
- Direct operational impact on governance (DoS)
- State bloat affecting chain performance
- No direct fund theft but creates cleanup costs
- Limited to main chain/public side chains (not all chains affected)

### Likelihood Explanation

**High Likelihood on Main Chain:**
- **Zero Access Control**: On main chain, `AssertUserDeployContract()` performs no checks and returns immediately
- **Low Cost**: Attacker only pays standard transaction fees (configurable but typically low)
- **Trivial Execution**: Attacker simply calls `DeployUserSmartContract()` repeatedly with code variations (e.g., append different bytes each time)
- **No Technical Barriers**: No special permissions, tokens, or setup required

**Attack Complexity:**
Extremely low - attacker can write a simple script to:
1. Take a base contract code
2. Append sequential numbers or random bytes
3. Call `DeployUserSmartContract()` with each variation
4. Repeat until desired proposal spam level achieved

**Economic Rationality:**
If transaction fees are low enough (as they often are to encourage usage), an attacker could create dozens or hundreds of proposals for minimal cost, making this attack economically viable for disruption purposes.

### Recommendation

**Immediate Mitigations:**

1. **Add Rate Limiting per Address:**
```
// In BasicContractZero_Helper.cs, add:
private void AssertProposalRateLimit(Address proposer) {
    var recentProposalCount = State.ProposalCountMap[proposer] ?? 0;
    var lastProposalTime = State.LastProposalTimeMap[proposer] ?? Timestamp.MinValue;
    
    if (Context.CurrentBlockTime.Seconds - lastProposalTime.Seconds < 3600) {
        Assert(recentProposalCount < 5, "Proposal rate limit exceeded.");
    } else {
        State.ProposalCountMap[proposer] = 0;
    }
    
    State.ProposalCountMap[proposer] = recentProposalCount + 1;
    State.LastProposalTimeMap[proposer] = Context.CurrentBlockTime;
}
```

2. **Require Whitelist Even on Main Chain:**
Modify [2](#0-1)  to always check Parliament proposer whitelist, removing the early return for main chain.

3. **Implement Proposal Deposit:**
Require a refundable deposit (e.g., 100 ELF) that is:
    - Returned when proposal is approved and executed
    - Returned when proposal is rejected
    - Slashed if proposal expires without action

4. **Add Organization-Level Proposal Limit:**
In Parliament contract, track active proposal count per organization and enforce a maximum (e.g., 100 active proposals).

**Test Cases:**
- Test that repeated calls with same input fail
- Test that repeated calls with varied input (within rate limit window) fail
- Test that whitelist check is enforced on main chain
- Test that proposal deposit is correctly charged and refunded/slashed

### Proof of Concept

**Initial State:**
- Main chain deployed with default configuration
- Attacker address: `AttackerAddress` with sufficient balance for transaction fees

**Attack Steps:**

1. **First Proposal Creation:**
```
Transaction: DeployUserSmartContract({
    Code: ByteString.CopyFrom(new byte[] {0x00, 0x01}),
    Category: 0,
    Salt: null
})
Sender: AttackerAddress
```
Result: Proposal 1 created in Parliament, hash H1 stored in BasicContractZero

2. **Second Proposal Creation (1 byte difference):**
```
Transaction: DeployUserSmartContract({
    Code: ByteString.CopyFrom(new byte[] {0x00, 0x02}),  // Changed last byte
    Category: 0,
    Salt: null
})
Sender: AttackerAddress
```
Result: Proposal 2 created (different hash H2), both proposals now active

3. **Repeat 100 times:**
Attacker continues calling with `Code: new byte[] {0x00, N}` where N = 3, 4, 5, ..., 100

**Expected (Vulnerable) Result:**
- 100 active proposals created in Parliament
- 100 entries in BasicContractZero's state
- Block producers see 100 proposals requiring attention
- State bloat until 15-minute expiration per proposal
- No failure or rejection occurs

**Success Condition:**
The attack succeeds if:
- All 100 calls succeed without permission errors
- Each creates a distinct Parliament proposal
- Total cost to attacker is only 100 Ã— (transaction fee)
- Governance system is spammed with 100 proposals

**Notes**

This vulnerability is **specific to main chain and public side chains** where `Context.Variables.NativeSymbol == primaryTokenSymbol` evaluates to true [3](#0-2) . On other side chains, the whitelist check at [13](#0-12)  provides protection. The vulnerability's impact is amplified by the lack of any cleanup mechanism other than manual per-proposal clearing after expiration.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L68-76)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);

        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L179-186)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L225-253)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId, 
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```
