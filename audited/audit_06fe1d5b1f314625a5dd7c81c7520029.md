### Title
Race Condition in Round Termination Behavior Causes Consensus Fork Between NextRound and NextTerm

### Summary
Multiple miners calling `GetConsensusCommand` simultaneously at round termination can receive different consensus behaviors (NextRound vs NextTerm) due to state changes in the underlying Round data between queries. This race condition allows competing valid blocks at the same height with incompatible consensus states, creating a network fork that cannot be reconciled.

### Finding Description

The vulnerability exists in the consensus command generation flow where miners independently query their next action: [1](#0-0) 

The method returns NextRound or NextTerm based on `NeedToChangeTerm()` evaluation: [2](#0-1) 

The critical issue is that `NeedToChangeTerm()` depends on `ActualMiningTimes` of miners, which are continuously updated as miners produce blocks: [3](#0-2) 

When miners call `GetConsensusCommand` (a view method), they read the current state: [4](#0-3) 

The state reading occurs here: [5](#0-4) 

Both NextRound and NextTerm generate round data using the current round number + 1: [6](#0-5) 

The validation only checks round number increment, allowing both behaviors to pass when validated against the same base state: [7](#0-6) 

There is no mechanism preventing multiple miners from receiving different behaviors or validating that only one specific miner can terminate the round.

### Impact Explanation

**Consensus Fork with Incompatible States:**
- When miners A and C both produce valid blocks at height H with different behaviors, the network splits into Fork A (NextRound: Round R+1, Term T) and Fork B (NextTerm: Round R+1, Term T+1)
- These forks are fundamentally incompatible because NextTerm fetches a new miner list from the Election contract and increments the term number
- The chains cannot merge as they have different term numbers and potentially different miner sets

**Network Integrity Compromise:**
- Block finality is delayed as the network must resolve the fork through longest-chain selection
- Different nodes may follow different forks, creating a network partition
- During the fork period, transactions may be processed on one fork but not the other, enabling potential double-spending
- The resolution is arbitrary (based on which fork propagates faster), not deterministic

**Operational Disruption:**
- Consensus becomes unstable during borderline threshold conditions
- Miners waste resources producing blocks on losing forks
- Recovery requires manual intervention or waiting for natural convergence

The vulnerability affects the entire network and compromises the core consensus invariant of deterministic round transitions.

### Likelihood Explanation

**Natural Occurrence (High Probability):**
- Happens whenever the term change threshold (2/3+1 miners) is crossed while multiple miners are preparing their termination blocks
- During normal operation, miners continuously update `ActualMiningTimes` via UpdateValue transactions
- When exactly 7 out of 10 miners meet the threshold, the next UpdateValue can flip `NeedToChangeTerm` from false to true
- Miners querying before and after this flip receive different behaviors

**Intentional Exploitation (Feasible):**
- A malicious miner can precisely time their UpdateValue transaction to cause the threshold crossing at a strategic moment
- By monitoring the network, they can identify when 6/10 miners meet the threshold
- They execute UpdateValue to become the 7th, ensuring other miners see different states
- Attack requires no special privileges, only normal miner capabilities
- Cost is minimal (standard transaction fee)

**Preconditions:**
- Multiple miners must be ready to terminate the round simultaneously (common during normal consensus operation)
- The system must be near the 2/3 threshold for term change (occurs naturally once per term period)
- Network latency must allow different miners to query at different times (always true in distributed networks)

The attack is practical, requires minimal resources, and can occur both naturally and maliciously with reasonable frequency.

### Recommendation

**Immediate Fix - Deterministic Termination:**

1. Add validation that only the designated extra block producer can execute NextRound/NextTerm:

```csharp
// In RoundTerminateValidationProvider
if (validationContext.BaseRound.GetExtraBlockProducerInformation().Pubkey != validationContext.SenderPubkey)
{
    return new ValidationResult { Message = "Only extra block producer can terminate round." };
}
```

2. Add atomic term change decision at round creation time, not at query time. Store the decision in Round state:

```csharp
// In Round
public bool IsTermChangePlanned { get; set; }
```

Calculate this when the previous round is finalized, ensuring all miners see the same decision.

3. Add validation that prevents NextRound if `IsTermChangePlanned` is true and vice versa:

```csharp
// In RoundTerminateValidationProvider
if (validationContext.BaseRound.IsTermChangePlanned && extraData.Behaviour == AElfConsensusBehaviour.NextRound)
{
    return new ValidationResult { Message = "Term change required, NextRound not allowed." };
}
```

**Long-term Fix - State Commitment:**

Implement a two-phase commit for round termination where miners first vote on the termination behavior in the current round, and the decision is executed by the extra block producer.

**Test Cases:**

1. Test concurrent GetConsensusCommand calls with state changes between them
2. Test that only extra block producer can execute termination transactions
3. Test that all miners receive consistent behavior when threshold is at boundary
4. Simulate network partition scenarios to verify fork prevention

### Proof of Concept

**Initial State:**
- Round R=100, Term T=10
- 10 miners total, 6 have ActualMiningTimes meeting term change threshold
- MinersCountOfConsent = (10*2/3)+1 = 7 (rounded)
- Block height H

**Exploitation Steps:**

1. **Block H:** Miner A calls `GetConsensusCommand`
   - Reads Round 100 state: 6/10 meet threshold
   - `NeedToChangeTerm` returns false (6 < 7)
   - Receives behavior: NextRound
   - Prepares transaction with Round 101, Term 10

2. **Block H+1:** Miner B produces block with UpdateValue
   - Updates their `ActualMiningTimes` to meet threshold
   - State now: 7/10 miners meet threshold

3. **Block H+1:** Miner C calls `GetConsensusCommand`
   - Reads Round 100 state: 7/10 meet threshold  
   - `NeedToChangeTerm` returns true (7 >= 7)
   - Receives behavior: NextTerm
   - Prepares transaction with Round 101, Term 11

4. **Block H+2:** Both miners attempt block production
   - **Miner A's block:** NextRound (Round 101, Term 10)
     - Validation reads BaseRound = Round 100
     - Check: 100+1 == 101 ✓ **PASSES**
   - **Miner C's block:** NextTerm (Round 101, Term 11)
     - Validation reads BaseRound = Round 100
     - Check: 100+1 == 101 ✓, 10+1 == 11 ✓ **PASSES**

**Expected Result:**
Only one behavior should be valid; consensus should be deterministic.

**Actual Result:**
Both blocks pass validation and create competing forks:
- Fork A: Round 101, Term 10 (original miner list)
- Fork B: Round 101, Term 11 (new miner list from Election contract)

Network splits into incompatible chains requiring manual resolution.

### Notes

The vulnerability stems from the design decision to determine consensus behavior at query time (GetConsensusCommand) rather than committing to the decision in the blockchain state. The `NeedToChangeTerm` check depends on mutable state that changes as miners produce blocks, creating a time-of-check-to-time-of-use race condition. While AEDPoS includes mechanisms for extra block producer designation and time slot validation, there is no enforcement that only one miner can receive the termination behavior or that all miners must agree on whether to change terms. The `EnsureTransactionOnlyExecutedOnceInOneBlock` protection prevents multiple consensus transactions within a single block but does not prevent different miners from producing competing blocks at the same height with incompatible behaviors.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-243)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-46)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L48-54)
```csharp
    private bool TryToGetCurrentRoundInformation(out Round round)
    {
        round = null;
        if (!TryToGetRoundNumber(out var roundNumber)) return false;
        round = State.Rounds[roundNumber];
        return !round.IsEmpty;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```
