### Title
Race Condition in Mining Order Assignment Causes Duplicate Orders and Block Production Conflicts

### Summary
The AEDPoS consensus mechanism contains a race condition in the distributed conflict resolution for `FinalOrderOfNextRound` values. When multiple miners generate consensus commands based on the same round state before any have produced blocks, they can independently calculate the same supposed order without detecting conflicts. This results in multiple miners being assigned identical `Order` values in subsequent rounds, which causes them to receive identical timestamps from `ArrangeAbnormalMiningTime()`, leading to scheduling conflicts and potential blockchain forks during round termination.

### Finding Description

The vulnerability exists in the interaction between local conflict resolution and on-chain state updates across three key components:

**1. Local Conflict Resolution (Executed Before Block Production)**

The conflict resolution logic in `ApplyNormalConsensusData` checks for existing miners with the same `FinalOrderOfNextRound` and moves them to different orders before assigning the current miner's order. [1](#0-0) 

However, this resolution happens locally during consensus command generation, not during on-chain block execution. The results are passed via `TuneOrderInformation` dictionary.

**2. On-Chain State Update (No Conflict Re-Validation)**

When blocks are executed, `ProcessUpdateValue` directly sets each miner's `FinalOrderOfNextRound` to their `SupposedOrderOfNextRound` and then applies the pre-calculated `TuneOrderInformation`. [2](#0-1) 

There is NO re-validation of conflicts during execution. If the `TuneOrderInformation` was calculated based on stale state, conflicts persist on-chain.

**3. Race Condition Scenario**

When miners A and B both call `GetConsensusCommand` before either has produced a block:
- Both fetch the same on-chain round state (e.g., all `FinalOrderOfNextRound = 0`) [3](#0-2) 

- Both calculate the same `SupposedOrderOfNextRound` (e.g., 2) via hash modulo [4](#0-3) 

- Both see no conflicts locally (all others are 0), so both set `TuneOrderInformation = {}`
- When their blocks are executed sequentially at different heights, both end up with `FinalOrderOfNextRound = 2`
- No miner has unique ordering information

**4. Propagation to Next Round**

When the next round is generated, miners with duplicate `FinalOrderOfNextRound` values are both assigned the same `Order` in the new round. [5](#0-4) 

The `OrderBy` sorts by `FinalOrderOfNextRound`, but when multiple miners have the same value, they all get assigned that same value as their `Order`. They are stored in separate dictionary entries (different pubkeys) but share the identical `Order` field value.

**5. Identical Timestamps in ArrangeAbnormalMiningTime**

When miners with duplicate `Order` values call `ArrangeAbnormalMiningTime()` (used for extra block production during round termination via `TerminateRoundCommandStrategy`), they calculate identical timestamps. [6](#0-5) 

The timestamp formula uses `minerInRound.Order`, so miners with the same `Order` and calling at similar times (same `futureRoundStartTime`) receive identical `ArrangedMiningTime` values. [7](#0-6) 

### Impact Explanation

**Consensus Integrity Impact:**
- Multiple miners receive identical mining timestamps for round termination
- Both attempt to produce extra blocks at the exact same time
- Causes blockchain forks where competing blocks exist at the same height
- Network splits temporarily until consensus mechanism resolves the fork
- Reduces consensus efficiency and increases orphaned blocks

**Operational Impact:**
- Degraded network performance during round transitions
- Wasted computational resources on orphaned blocks
- Potential for extended fork resolution times if multiple pairs of miners have conflicts
- Confusion in block explorer and monitoring tools

**Severity Justification:**
This violates the critical invariant for "Correct round transitions and time-slot validation, miner schedule integrity" under Consensus requirements. While it doesn't directly lead to fund theft, it significantly degrades consensus quality and can cause operational disruptions during every affected round transition.

### Likelihood Explanation

**Attack Complexity: LOW**
- No malicious intent required - this is a natural race condition
- Occurs probabilistically during normal operations

**Feasibility Conditions:**
1. **Hash Collision Probability:** With `minersCount = N` miners, the probability of two miners calculating the same `SupposedOrderOfNextRound` is approximately `1/N` per pair. For 21 miners, this is ~4.7% per pair, meaning conflicts are expected regularly.

2. **Timing Window:** Miners naturally generate consensus commands within the same round before blocks are propagated. Network latency (100-500ms typical) provides a realistic window where multiple miners fetch the same round state.

3. **Sequential Block Execution:** Both blocks can be in the canonical chain at different heights (e.g., height H and H+1), which is the normal case - they don't need to be competing forks at the same height.

4. **Entry Point:** The vulnerability is triggered through the public `GetConsensusCommand` method, which every miner calls regularly to determine their next mining action. [8](#0-7) 

**Detection Constraints:**
- Difficult to detect in advance as it depends on timing and hash distribution
- Manifests as observable forks during round termination
- May appear as "normal" temporary forks to observers

**Probability Assessment: MEDIUM-HIGH**
Given the hash collision probability and typical network conditions, duplicate orders are expected to occur periodically, making scheduling conflicts a recurring operational issue rather than a rare event.

### Recommendation

**1. Add On-Chain Conflict Validation**

Implement conflict detection and resolution in `ProcessUpdateValue` to re-validate `FinalOrderOfNextRound` uniqueness during block execution:

```csharp
// In ProcessUpdateValue, after setting FinalOrderOfNextRound
var conflictingMiners = currentRound.RealTimeMinersInformation.Values
    .Where(m => m.Pubkey != _processingBlockMinerPubkey && 
                m.FinalOrderOfNextRound == updateValueInput.SupposedOrderOfNextRound)
    .ToList();

if (conflictingMiners.Any())
{
    // Find available order for conflicting miner
    var occupiedOrders = currentRound.RealTimeMinersInformation.Values
        .Select(m => m.FinalOrderOfNextRound)
        .Where(o => o != 0)
        .ToList();
    
    var availableOrder = Enumerable.Range(1, minersCount)
        .FirstOrDefault(o => !occupiedOrders.Contains(o));
    
    Assert(availableOrder > 0, "No available order found");
    
    // Move conflicting miner to available order
    conflictingMiners[0].FinalOrderOfNextRound = availableOrder;
}
``` [9](#0-8) 

**2. Add Invariant Check in Round Generation**

Add validation in `GenerateNextRoundInformation` to detect and reject duplicate orders:

```csharp
// After assigning orders, verify uniqueness
var orderCounts = nextRound.RealTimeMinersInformation.Values
    .GroupBy(m => m.Order)
    .Where(g => g.Count() > 1);
Assert(!orderCounts.Any(), "Duplicate orders detected in round generation");
``` [5](#0-4) 

**3. Add Test Cases**

Create regression tests that:
- Simulate concurrent consensus command generation by multiple miners
- Verify that duplicate `FinalOrderOfNextRound` values are prevented
- Validate that `ArrangeAbnormalMiningTime` produces unique timestamps for all miners
- Test hash collision scenarios where multiple miners calculate the same supposed order

### Proof of Concept

**Initial State:**
- Round R with 5 miners: A, B, C, D, E
- All miners have `FinalOrderOfNextRound = 0` (default/unset)
- Mining interval = 4000ms

**Exploitation Steps:**

1. **Concurrent Command Generation (Time T0):**
   - Miner A calls `GetConsensusCommand`
   - Miner A fetches round state: all `FinalOrderOfNextRound = 0`
   - Miner A's signature hash modulo 5 = 2, so `SupposedOrderOfNextRound = 2`
   - Local conflict check: no conflicts (all are 0)
   - Miner A sets local `FinalOrderOfNextRound = 2`, `TuneOrderInformation = {}`

2. **Concurrent Command Generation (Time T0 + 100ms):**
   - Miner B calls `GetConsensusCommand` before A's block is executed
   - Miner B fetches round state: still all `FinalOrderOfNextRound = 0` (A's block not yet on chain)
   - Miner B's signature hash modulo 5 = 2, so `SupposedOrderOfNextRound = 2`
   - Local conflict check: no conflicts (A is still 0 on-chain)
   - Miner B sets local `FinalOrderOfNextRound = 2`, `TuneOrderInformation = {}`

3. **Sequential Block Execution:**
   - Block A executed at height H: A's `FinalOrderOfNextRound = 2`, applies `TuneOrderInformation = {}` → On-chain: A=2
   - Block B executed at height H+1: B's `FinalOrderOfNextRound = 2`, applies `TuneOrderInformation = {}` → On-chain: A=2, B=2

4. **Next Round Generation (Round R+1):**
   - `GenerateNextRoundInformation` called
   - Processes miners A and B: both have `FinalOrderOfNextRound = 2`
   - Both assigned `Order = 2` in Round R+1

5. **Round Termination Conflict:**
   - Miners A and B both need to terminate Round R+1
   - Both call `ArrangeAbnormalMiningTime` at approximately the same time T1
   - Both calculate: `futureRoundStartTime.AddMilliseconds(2 * 4000) = T1 + 8000ms`
   - Both receive `ArrangedMiningTime = T1 + 8000ms`
   - Both attempt to produce extra block at the same timestamp

**Expected Result:**
Only one miner should be able to produce the termination block at any given time.

**Actual Result:**
Both miners receive identical timestamps and attempt to produce blocks simultaneously, causing a fork.

**Success Condition:**
Verify on-chain that after steps 1-3, miners A and B both have `FinalOrderOfNextRound = 2` in Round R, and both have `Order = 2` in Round R+1. Query their consensus commands and observe identical `ArrangedMiningTime` values for round termination.

---

**Notes:**

The vulnerability is confirmed through code analysis of the consensus command generation flow. The race condition is inherent in the distributed conflict resolution design where local validation occurs before on-chain state updates. The comment at line 29 of `Round_ApplyNormalConsensusData.cs` acknowledges "Multiple conflicts is unlikely" but the code does not prevent them, only makes them less probable. [10](#0-9)

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-44)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-27)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L33-36)
```csharp
        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L25-26)
```csharp
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
```
