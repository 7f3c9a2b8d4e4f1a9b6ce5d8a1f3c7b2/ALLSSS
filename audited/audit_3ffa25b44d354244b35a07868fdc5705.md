### Title
Integer Overflow in AddBeneficiary Cleanup Logic Causes Permanent DoS and Unbounded State Growth

### Summary
The `AddBeneficiary` function's cleanup logic at lines 204-207 performs checked arithmetic that can overflow when `EndPeriod` is close to `long.MaxValue`. When a beneficiary is added with a large `EndPeriod` value (e.g., `long.MaxValue - 500`), subsequent calls to `AddBeneficiary` for that same beneficiary will permanently fail due to `OverflowException`, preventing new profit details from being added and causing old details to accumulate indefinitely in contract state.

### Finding Description

The vulnerability exists in the `AddBeneficiary` function's automatic cleanup mechanism: [1](#0-0) 

The cleanup logic filters old profit details using the condition:
`d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod`

The `Add` extension method uses checked arithmetic that throws `OverflowException` on overflow: [2](#0-1) 

The root cause is insufficient validation of `input.EndPeriod` in `AddBeneficiary`. The only validation is: [3](#0-2) 

There is no upper bound check preventing `EndPeriod` from being set to values close to `long.MaxValue`. Given that `ProfitReceivingDuePeriodCount` can be up to 1024: [4](#0-3) 

When `EndPeriod + ProfitReceivingDuePeriodCount` exceeds `long.MaxValue` (9,223,372,036,854,775,807), the checked addition throws an exception, causing the entire transaction to fail.

Alternative cleanup mechanisms cannot resolve this:
- `ClaimProfits` only removes details where `LastProfitPeriod > EndPeriod`, which will never occur since `CurrentPeriod` increments linearly and cannot reach extremely large `EndPeriod` values [5](#0-4) 
- `RemoveBeneficiary` can only remove the detail if `CanRemoveBeneficiaryDirectly` is true, requiring manual manager intervention [6](#0-5) 

### Impact Explanation

**Operational Impact - DoS:**
Once a beneficiary has a profit detail with `EndPeriod` close to `long.MaxValue`, all subsequent `AddBeneficiary` calls for that beneficiary address will permanently fail. This prevents:
- Adding new profit allocation periods for the affected beneficiary
- Automatic cleanup of accumulated old profit details
- Normal profit scheme management operations

**State Growth Impact:**
Old profit details for the affected beneficiary cannot be automatically cleaned up via `AddBeneficiary`, causing unbounded accumulation of `ProfitDetail` entries in the `ProfitDetailsMap` state storage.

**Scope:**
The impact is per-beneficiary within a scheme. Each beneficiary with a problematic `EndPeriod` creates an isolated DoS condition for that specific address, while other beneficiaries in the same scheme remain unaffected.

**Severity Justification:**
Medium severity because while the impact is significant (permanent DoS + state bloat), it requires a trusted role (scheme manager or TokenHolder contract) to create the condition, though this could occur accidentally through typos or calculation errors.

### Likelihood Explanation

**Entry Point:**
The vulnerability is triggered through the public `AddBeneficiary` function, which is callable by scheme managers and the TokenHolder contract: [7](#0-6) 

**Attack Vector:**
A scheme manager (or TokenHolder contract) adds a beneficiary with `input.EndPeriod` set to a value like `long.MaxValue - 500` instead of the intended `long.MaxValue` for permanent beneficiaries. This could occur through:
1. **Accidental:** Typo, off-by-one error, or miscalculation during beneficiary registration
2. **Malicious manager:** Intentionally setting problematic values to DoS future operations
3. **Compromised keys:** Attacker with manager access sabotaging the scheme

**Execution Path:**
1. Initial `AddBeneficiary` call with large `EndPeriod` succeeds and creates the problematic detail
2. Any subsequent `AddBeneficiary` call for the same beneficiary triggers cleanup logic
3. Cleanup evaluates `(long.MaxValue - 500).Add(1024)` causing overflow
4. Transaction reverts with `OverflowException`
5. Condition persists permanently

**Probability:**
Moderate - requires trusted role action but realistic through operational errors or compromised credentials.

### Recommendation

**Primary Fix:**
Add upper bound validation in `AddBeneficiary` to prevent overflow during cleanup:

```csharp
Assert(input.EndPeriod == long.MaxValue || 
       input.EndPeriod <= long.MaxValue - scheme.ProfitReceivingDuePeriodCount,
    "End period too large, may cause overflow during cleanup.");
```

Insert this check after line 180 in `AddBeneficiary`.

**Alternative Fix:**
Modify the cleanup logic to safely handle potential overflow:

```csharp
var oldProfitDetails = currentProfitDetails.Details.Where(
    d => d.EndPeriod != long.MaxValue && 
         d.LastProfitPeriod >= d.EndPeriod &&
         d.EndPeriod < long.MaxValue - scheme.ProfitReceivingDuePeriodCount &&
         d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
```

This adds a pre-check before the overflow-prone addition.

**Test Cases:**
1. Attempt to add beneficiary with `EndPeriod = long.MaxValue - 100` - should fail validation
2. Attempt to add beneficiary with `EndPeriod = long.MaxValue - ProfitReceivingDuePeriodCount - 1` - should fail validation  
3. Verify `EndPeriod = long.MaxValue` (permanent beneficiary) is still allowed
4. Verify `EndPeriod = long.MaxValue - ProfitReceivingDuePeriodCount` is allowed as the maximum non-permanent value

### Proof of Concept

**Initial State:**
- Profit scheme created with `ProfitReceivingDuePeriodCount = 1024` (max allowed)
- `CurrentPeriod = 1`

**Transaction Sequence:**

1. **Manager calls `AddBeneficiary`:**
   - `input.SchemeId = [scheme_id]`
   - `input.BeneficiaryShare.Beneficiary = [beneficiary_address]`
   - `input.BeneficiaryShare.Shares = 100`
   - `input.EndPeriod = 9223372036854775307` (long.MaxValue - 500)
   - **Result:** SUCCESS - Detail created with EndPeriod = 9223372036854775307

2. **Later, manager calls `AddBeneficiary` again for same beneficiary:**
   - `input.SchemeId = [scheme_id]`
   - `input.BeneficiaryShare.Beneficiary = [beneficiary_address]` (SAME)
   - `input.BeneficiaryShare.Shares = 50`
   - `input.EndPeriod = [any_value]`
   - **Expected:** New detail added, old detail potentially cleaned up
   - **Actual:** Transaction FAILS with `OverflowException` at line 206
   - **Reason:** `(9223372036854775307).Add(1024)` overflows long.MaxValue

3. **All subsequent `AddBeneficiary` calls for this beneficiary fail permanently**

**Success Condition:**
The vulnerability is confirmed if step 2 consistently fails with `OverflowException` and the problematic detail remains in `State.ProfitDetailsMap[scheme_id][beneficiary_address]` indefinitely.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L179-180)
```csharp
        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L321-324)
```csharp
        var detailsCanBeRemoved = scheme.CanRemoveBeneficiaryDirectly
            ? profitDetails.Details.Where(d => !d.IsWeightRemoved).ToList()
            : profitDetails.Details
                .Where(d => d.EndPeriod < scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L7-7)
```csharp
    public const int MaximumProfitReceivingDuePeriodCount = 1024;
```
