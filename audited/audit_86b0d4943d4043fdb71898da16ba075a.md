### Title
Missing Mining Interval Validation During Genesis Initialization Allows Consensus DoS

### Summary
The `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` method does not explicitly validate that `MiningDueTime > ArrangedMiningTime`, relying instead on `MiningInterval > 0`. While normal round creation validates this constraint via `CheckRoundTimeSlots()`, the genesis `FirstRound()` initialization bypasses this validation, allowing a misconfigured chain to start with `MiningInterval <= 0`, which would cause immediate consensus failure and denial of service.

### Finding Description

**Root Cause:** The `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` method calculates `MiningDueTime` as `ArrangedMiningTime + MiningInterval` without validating that the result satisfies `MiningDueTime > ArrangedMiningTime`. [1](#0-0) 

The relationship depends entirely on `MiningInterval` being positive, which is obtained from the current round: [2](#0-1) 

The `Round.GetMiningInterval()` method returns `Math.Abs()` of the time difference for multiple miners, or 4000ms for single miner, which could theoretically be zero if two miners have identical `ExpectedMiningTime`: [3](#0-2) 

**Validation During Normal Operation:** The `CheckRoundTimeSlots()` method validates that `miningInterval > 0` (strictly greater than zero): [4](#0-3) 

This validation is enforced through `TimeSlotValidationProvider` during consensus validation for new rounds: [5](#0-4) 

**Missing Validation During Initialization:** However, the `FirstRound()` initialization method adds the genesis round to state without any validation: [6](#0-5) 

The `MinerList.GenerateFirstRoundOfNewTerm()` method accepts `miningInterval` as a parameter and uses it directly without validation: [7](#0-6) 

The initialization provider supplies this value from chain configuration without validation: [8](#0-7) 

### Impact Explanation

**Operational DoS of Consensus:** If `MiningInterval = 0` is provided during genesis initialization:
- `MiningDueTime` would equal `ArrangedMiningTime`
- The mining validation in `MiningRequestService.ValidateBlockMiningTime()` checks if `miningDueTime - 250ms < blockTime + blockExecutionDuration`: [9](#0-8) 

- With `MiningDueTime = ArrangedMiningTime`, the effective mining window would be only 250ms, causing immediate mining cancellation
- If `MiningInterval < 0`, all mining attempts would fail, rendering the blockchain non-operational

**Affected Parties:** All network participants would be unable to produce blocks, resulting in complete chain halt from genesis.

**Severity:** Medium - while the impact is severe (complete DoS), it requires misconfiguration at the trusted genesis initialization stage rather than runtime exploitation.

### Likelihood Explanation

**Attack Vector:** This is not a runtime exploitable vulnerability but a configuration validation gap. An attacker would need to:
1. Control or compromise the chain initialization configuration
2. Set `MiningInterval <= 0` in the genesis parameters
3. Deploy the chain with this misconfiguration

**Feasibility:** Low likelihood because:
- Requires control over genesis configuration (trusted setup phase)
- Standard/default mining interval is 4000ms (positive)
- Once a chain starts with valid configuration, subsequent rounds validate correctly
- Would be immediately detected during chain initialization testing

**Complexity:** Low - no complex exploitation sequence required, just misconfiguration during deployment.

### Recommendation

**1. Add Validation in FirstRound Method:**

Add explicit validation before storing the genesis round:
```csharp
public override Empty FirstRound(Round input)
{
    Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");
    
    // Add validation
    var miningInterval = input.GetMiningInterval();
    Assert(miningInterval > 0, "Mining interval must be greater than 0.");
    
    var validationResult = input.CheckRoundTimeSlots();
    Assert(validationResult.Success, validationResult.Message);
    
    /* Rest of initialization... */
}
```

**2. Add Validation in ConsensusCommand Creation:**

Add defensive validation in command strategies:
```csharp
public override ConsensusCommand GetAEDPoSConsensusCommand()
{
    var arrangedMiningTime = MiningTimeArrangingService.ArrangeExtraBlockMiningTime(...);
    var miningInterval = MiningInterval;
    
    Assert(miningInterval > 0, "Invalid mining interval for consensus command generation.");
    
    return new ConsensusCommand
    {
        ArrangedMiningTime = arrangedMiningTime,
        MiningDueTime = arrangedMiningTime.AddMilliseconds(miningInterval),
        ...
    };
}
```

**3. Add Configuration Validation:**

Validate initialization parameters before contract deployment:
```csharp
public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
{
    var initializationData = _aedPoSContractInitializationDataProvider.GetContractInitializationData();
    
    // Validate mining interval
    if (initializationData.MiningInterval <= 0)
        throw new InvalidOperationException("Mining interval must be positive.");
    
    // Generate initialization calls...
}
```

**4. Add Test Cases:**

Create unit tests that verify:
- `FirstRound` rejects rounds with `MiningInterval <= 0`
- `GetAEDPoSConsensusCommand` asserts `MiningInterval > 0`
- Configuration provider validates mining interval bounds
- ConsensusCommand always satisfies `MiningDueTime > ArrangedMiningTime`

### Proof of Concept

**Initial State:**
- Chain genesis configuration with `MiningInterval = 0` (or negative)
- Standard miner list with multiple nodes

**Exploitation Steps:**

1. **Genesis Block Creation:**
   - Chain initialization calls `InitialAElfConsensusContract` with valid parameters
   - Then calls `FirstRound` with a Round generated from `MinerList.GenerateFirstRoundOfNewTerm(miningInterval: 0, ...)`
   - Round is stored in state without validation (bypasses `CheckRoundTimeSlots`)

2. **First Mining Attempt:**
   - Miner calls `GetConsensusCommand` to get mining instructions
   - `TerminateRoundCommandStrategy.GetAEDPoSConsensusCommand()` executes:
     - `ArrangedMiningTime = T`
     - `MiningInterval = 0` (from stored round)
     - `MiningDueTime = T + 0 = T`

3. **Mining Validation Failure:**
   - `ConsensusService.TriggerConsensusAsync` schedules mining event
   - `MiningRequestService.ValidateBlockMiningTime` checks:
     - `miningDueTime (T) - 250ms < blockTime (T) + blockExecutionDuration (X)`
     - Simplifies to: `T - 250ms < T + X`
     - This fails immediately since `X > 0` (blocks take time to execute)
   - Mining is cancelled with "mining time slot expired" message

4. **Result:**
   - No blocks can be produced
   - Chain is halted from genesis
   - Complete denial of service

**Expected vs Actual:**
- Expected: Genesis initialization should reject invalid mining intervals
- Actual: Invalid mining interval is accepted, causing consensus failure

**Success Condition:** Chain initialization completes but first mining attempt fails validation, proving `MiningDueTime` is not properly validated against `ArrangedMiningTime`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/CommandStrategyBase.cs (L37-37)
```csharp
        protected int MiningInterval => CurrentRound.GetMiningInterval();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L43-47)
```csharp
        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L14-18)
```csharp
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L74-86)
```csharp
    public override Empty FirstRound(Round input)
    {
        /* Basic checks. */
        Assert(State.CurrentRoundNumber.Value == 0, "Already initialized.");

        /* Initial settings. */
        State.CurrentTermNumber.Value = 1;
        State.CurrentRoundNumber.Value = 1;
        State.FirstRoundNumberOfEachTerm[1] = 1;
        State.MiningInterval.Value = input.GetMiningInterval();
        SetMinerList(input.GetMinerList(), 1);

        AddRoundInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L12-33)
```csharp
    internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
        Timestamp currentBlockTime, long currentRoundNumber = 0, long currentTermNumber = 0)
    {
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();

        var round = new Round();

        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/AEDPoSContractInitializationProvider.cs (L40-51)
```csharp
            new()
            {
                MethodName = nameof(AEDPoSContractContainer.AEDPoSContractStub.FirstRound),
                Params = new MinerList
                {
                    Pubkeys =
                    {
                        initializationData.InitialMinerList.Select(ByteStringHelper.FromHexString)
                    }
                }.GenerateFirstRoundOfNewTerm(initializationData.MiningInterval,
                    initializationData.StartTimestamp.ToDateTime()).ToByteString()
            }
```

**File:** src/AElf.Kernel/Miner/Application/IMiningRequestService.cs (L47-57)
```csharp
    private bool ValidateBlockMiningTime(Timestamp blockTime, Timestamp miningDueTime,
        Duration blockExecutionDuration)
    {
        if (miningDueTime - Duration.FromTimeSpan(TimeSpan.FromMilliseconds(250)) <
            blockTime + blockExecutionDuration)
        {
            Logger.LogDebug(
                "Mining canceled because mining time slot expired. MiningDueTime: {MiningDueTime}, BlockTime: {BlockTime}, Duration: {BlockExecutionDuration}",
                miningDueTime, blockTime, blockExecutionDuration);
            return false;
        }
```
