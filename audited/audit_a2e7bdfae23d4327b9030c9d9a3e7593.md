### Title
Broken After-Execution Validation Enables Consensus State Poisoning via Same-Object Hash Comparison

### Summary
The `ValidateConsensusAfterExecution` method contains a critical bug where the hash comparison always passes because both sides reference the same object after recovery. The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods modify `currentRound` in-place and return it, which is then assigned to `headerInformation.Round`, causing the subsequent hash comparison to compare an object's hash with itself. This broken validation allows malicious miners to write corrupted consensus data to StateDb, poisoning future block validations.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The critical flaw exists in the recovery and comparison logic. The `RecoverFromUpdateValue` method modifies the caller (`this` / `currentRound`) in-place: [2](#0-1) 

The recovery method modifies `RealTimeMinersInformation` entries directly on the base round object and returns `this`, making the assignment at lines 90-92 set `headerInformation.Round` to point to the same `currentRound` object that was just modified.

**Why Protections Fail:**

The validation flow is:
1. Load `currentRound` from StateDb (post-execution state)
2. Call `currentRound.RecoverFromUpdateValue(headerInformation.Round, pubkey)` which modifies `currentRound` in-place and returns it
3. Assign the return value to `headerInformation.Round`
4. Compare `headerInformation.Round.GetHash()` vs `currentRound.GetHash()`

After step 3, both `headerInformation.Round` and `currentRound` reference the **same object**, making the hash comparison at lines 100-101 always succeed (comparing an object's hash with itself). The original header round data is lost and never validated.

**Inconsistent Usage:**

The before-execution validation uses recovery differently - it calls recovery for side effects only without assignment: [3](#0-2) 

This inconsistency confirms the bug: the after-execution validation incorrectly overwrites `headerInformation.Round` with `currentRound`, breaking the comparison.

**State Update Path:**

State is modified during consensus processing: [4](#0-3) 

Fields like `ProducedBlocks` and `ProducedTinyBlocks` are incremented during processing but these changes are not validated against the header because the hash comparison is broken.

**Block Processing Pipeline:**

The after-execution validation is mandatory in the block processing pipeline: [5](#0-4) 

When this validation is broken, corrupted consensus data gets committed to the blockchain state.

### Impact Explanation

**Consensus Integrity Compromise:**
Malicious miners can write arbitrary consensus data to StateDb that differs from what they declared in block headers. This corrupted state becomes the `BaseRound` and `PreviousRound` for validating future blocks.

**Concrete Attack Scenarios:**

1. **Field Manipulation:** A miner can provide incorrect values for fields included in the simplified round (e.g., via `GetUpdateValueRound`): [6](#0-5) 

Fields like `ProducedBlocks`, `ProducedTinyBlocks`, `Signature`, `OutValue`, `ImpliedIrreversibleBlockHeight`, and miner ordering fields can be manipulated.

2. **Round Transition Corruption:** For `NextRound` behavior, entire round structures can be corrupted since the hash validation is broken for all consensus behaviors (UpdateValue, TinyBlock).

3. **Cascading Validation Failures:** Future blocks load corrupted `BaseRound` from StateDb for validation: [7](#0-6) 

Validation providers that depend on this data will malfunction:
- Mining permission checks may incorrectly accept/reject miners [8](#0-7) 

- Time slot validation may use corrupted timing data [9](#0-8) 

**Severity: CRITICAL** - This breaks the fundamental consensus integrity invariant. Corrupted consensus state can lead to:
- Denial of service (legitimate blocks rejected)
- Consensus manipulation (malicious blocks accepted)
- Chain instability from invalid round transitions
- Loss of trust in the consensus mechanism

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must be an active miner in the current or previous round's miner list, as verified by `PreCheck()`: [10](#0-9) 

**Attack Complexity: LOW**
1. Miner generates a block with UpdateValue/TinyBlock/NextRound behavior
2. Provides crafted consensus data in the block header that differs from the correct values
3. Before-execution validation may pass if the manipulation is subtle (e.g., incrementing counters)
4. Block execution writes the manipulated data to StateDb
5. After-execution validation passes due to the same-object bug
6. Corrupted state is committed to the blockchain

**Feasibility: HIGH**
- No additional permissions required beyond being a miner
- The bug is deterministic and always present
- Attack can be executed in a single block
- No economic cost beyond normal block production

**Detection: DIFFICULT**
The broken validation passes silently. Corruption may only be detected when:
- Future blocks fail validation unexpectedly
- Off-chain monitoring detects consensus anomalies
- Chain analysis reveals inconsistent round data

**Probability: HIGH**
Any malicious miner can exploit this at any time during their mining slot. Given that miners rotate regularly, the attack surface is continuously available.

### Recommendation

**Immediate Fix:**
Clone the `currentRound` before recovery to ensure independent objects for comparison:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Clone currentRound before recovery to preserve original state
        var recoveredRound = currentRound.Clone();
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            recoveredRound.RecoverFromUpdateValue(headerInformation.Round, 
                headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            recoveredRound.RecoverFromTinyBlock(headerInformation.Round,
                headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        // Now comparing different objects
        if (recoveredRound.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // existing miner replacement logic...
        }
    }
    return new ValidationResult { Success = true };
}
```

**Alternative Fix:**
Modify recovery methods to return a new object instead of modifying `this`:

```csharp
public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
{
    var recovered = this.Clone(); // Create a copy
    // Apply modifications to the copy
    var minerInRound = recovered.RealTimeMinersInformation[pubkey];
    // ... rest of logic
    return recovered; // Return the copy, not this
}
```

**Invariant Checks to Add:**
1. Add unit tests verifying hash comparison fails when consensus data mismatches
2. Add integration tests simulating state poisoning attempts
3. Add runtime assertions that `headerInformation.Round` and `currentRound` are different objects before comparison
4. Add monitoring/logging when hash mismatches occur to detect attempts

**Test Cases:**
1. Test that modified `ProducedBlocks` in header is detected and rejected
2. Test that corrupted miner ordering in `NextRound` is caught
3. Test that recovery creates independent objects for comparison
4. Test that legitimate blocks with correct data still pass validation

### Proof of Concept

**Initial State:**
- Chain is running normally with multiple miners
- Attacker is an active miner in current round
- Current round has attacker with `ProducedBlocks = 10`

**Attack Steps:**

1. **Block Generation:** Attacker generates a block with UpdateValue behavior
   - Load current round from state (`ProducedBlocks = 10`)
   - Call `GetUpdateValueRound()` to create simplified round for header
   - **Manipulate** the simplified round: Set `ProducedBlocks = 100` (incorrect)
   - Include this manipulated round in block header

2. **Before-Execution Validation:**
   - `ValidateBeforeExecution` loads `BaseRound` from StateDb
   - Recovers in-place with header data
   - Validation providers check miner list, time slot, continuous blocks
   - **Passes** because these specific validators don't check `ProducedBlocks`

3. **Block Execution:**
   - `ProcessUpdateValue` is called
   - Loads `currentRound` from StateDb (`ProducedBlocks = 10`)
   - Increments: `ProducedBlocks = 11`
   - Writes back to StateDb
   - **State now has `ProducedBlocks = 11`** (should be rejected)

4. **After-Execution Validation:**
   - Loads `currentRound` from StateDb (`ProducedBlocks = 11`)
   - Calls `currentRound.RecoverFromUpdateValue(headerInformation.Round, pubkey)`
   - This modifies `currentRound` and returns it
   - Assigns to `headerInformation.Round`
   - **Both variables now point to same object with `ProducedBlocks = 11`**
   - Hash comparison: same object → hashes equal → **validation passes**

5. **Result:**
   - Block is accepted and committed
   - StateDb contains `ProducedBlocks = 11` (should have been detected as incorrect)
   - Original header claim of `ProducedBlocks = 100` was never validated
   - Future blocks will load this potentially corrupted state

**Expected vs Actual:**
- **Expected:** After-execution validation should detect that header claimed `ProducedBlocks = 100` but state has `ProducedBlocks = 11`, reject the block
- **Actual:** Validation passes because hash comparison uses same object, corrupted state is committed

**Success Condition:**
Query `GetRoundInformation` after the attack block and observe state contains manipulated values that were never properly validated against the block header's declared values.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L89-101)
```csharp
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-50)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());

        if (extraData.Behaviour == AElfConsensusBehaviour.TinyBlock)
            baseRound.RecoverFromTinyBlock(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockchainExecutingService.cs (L146-150)
```csharp
        if (!await _blockValidationService.ValidateBlockAfterExecuteAsync(block))
        {
            Logger.LogDebug($"Block validate fails after execution. block hash : {blockHash}");
            return null;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L19-22)
```csharp
    /// <summary>
    ///     Round information fetch from StateDb.
    /// </summary>
    public Round BaseRound { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-51)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
    }
```
