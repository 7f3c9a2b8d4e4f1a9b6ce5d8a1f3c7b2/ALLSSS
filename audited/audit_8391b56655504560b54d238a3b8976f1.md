### Title
Missing Dictionary Key Validation in CrossChainCreate Causes KeyNotFoundException

### Summary
The `CrossChainCreate()` function in the NFT contract directly accesses `tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey]` and `tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]` without verifying these keys exist in the dictionary. This causes a `KeyNotFoundException` when the function is called with tokens that lack NFT-specific metadata, resulting in transaction failure and poor error handling.

### Finding Description
The vulnerability exists in the `CrossChainCreate()` method at lines 87-88: [1](#0-0) 

The function retrieves token information from the MultiToken contract and immediately accesses dictionary keys without validation: [2](#0-1) 

The only validation performed is checking if the token symbol is non-empty: [3](#0-2) 

However, regular fungible tokens created through the MultiToken contract's `Create()` method will have an `ExternalInfo` object but won't contain the NFT-specific metadata keys: [4](#0-3) 

The NFT-specific keys are only added when creating tokens through the NFT contract's `GetTokenExternalInfo()` method: [5](#0-4) 

The codebase establishes a safe pattern for accessing `ExternalInfo` dictionaries using null checks and `ContainsKey()` or `TryGetValue()`: [6](#0-5) [7](#0-6) 

The `CrossChainCreate()` function violates this established pattern, making it vulnerable to dictionary key access exceptions.

### Impact Explanation
**Operational Impact - Function Failure:**
- Any attempt to call `CrossChainCreate()` with a non-NFT token symbol results in a `KeyNotFoundException` and transaction failure
- This provides confusing error messages instead of clear validation errors (e.g., "Token is not an NFT protocol")
- While this doesn't corrupt state (the exception occurs before line 108 where state is written), it prevents the function from gracefully handling invalid input
- Potential for griefing attacks where malicious actors repeatedly call the function with invalid symbols to waste gas and create noise in logs

**Affected Users:**
- Users attempting to sync NFT protocols who accidentally use wrong symbols receive cryptic errors
- Contract administrators may have difficulty debugging failed transactions
- Side chain operators attempting to sync protocols face operational friction

**Severity Justification:**
This is a **Medium severity** operational issue. While it doesn't directly steal funds or corrupt state, it violates defensive programming practices and creates operational problems. The impact is limited because legitimate NFT protocols (created through the NFT contract) will have the required keys and function correctly.

### Likelihood Explanation
**High Likelihood of Occurrence:**

**Attacker Capabilities:**
- `CrossChainCreate()` is a public method with no access control restrictions: [8](#0-7) 

- Any user can call this function with any symbol string

**Attack Complexity:**
- Trivially simple - single function call: `NFTContract.CrossChainCreate(new CrossChainCreateInput { Symbol = "REGULARTOKEN" })`
- No special permissions or complex setup required

**Feasibility Conditions:**
- Only requires that a non-NFT token exists in the MultiToken contract (which is the normal state for any fungible token)
- All regular tokens created through MultiToken contract satisfy this condition

**Economic Rationality:**
- Very low cost - only gas fees for the transaction
- Could be used for griefing or to test/probe the contract
- Accidental triggering is also likely during normal operations if users misunderstand which tokens can be synced

### Recommendation
**Immediate Fix:**
Add key existence validation before accessing the dictionary. Replace lines 87-88 with:

```csharp
Assert(tokenInfo.ExternalInfo != null && 
       tokenInfo.ExternalInfo.Value.ContainsKey(NftBaseUriMetadataKey),
       $"Token {input.Symbol} is missing required NFT metadata key: {NftBaseUriMetadataKey}");
Assert(tokenInfo.ExternalInfo.Value.ContainsKey(NftTokenIdReuseMetadataKey),
       $"Token {input.Symbol} is missing required NFT metadata key: {NftTokenIdReuseMetadataKey}");

var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**Alternative Safe Pattern:**
Use `TryGetValue()` for safer access:

```csharp
Assert(tokenInfo.ExternalInfo != null, "Token external info is null");
Assert(tokenInfo.ExternalInfo.Value.TryGetValue(NftBaseUriMetadataKey, out var baseUri),
       $"Token {input.Symbol} is not an NFT protocol - missing base URI metadata");
Assert(tokenInfo.ExternalInfo.Value.TryGetValue(NftTokenIdReuseMetadataKey, out var tokenIdReuseStr),
       $"Token {input.Symbol} is not an NFT protocol - missing token ID reuse metadata");
var isTokenIdReuse = bool.Parse(tokenIdReuseStr);
```

**Additional Validation:**
Consider adding validation that the NFT type exists in the metadata as well: [9](#0-8) 

**Test Cases:**
Add test cases covering:
1. Calling `CrossChainCreate()` with a regular fungible token symbol (should fail with clear error)
2. Calling with a token that has empty `ExternalInfo` 
3. Calling with a token that has `ExternalInfo` but missing specific NFT keys
4. Successful case with proper NFT protocol that has all required metadata

### Proof of Concept

**Required Initial State:**
1. Deploy MultiToken contract and NFT contract on a side chain
2. Create a regular fungible token on the main chain through MultiToken contract (not NFT contract):
   - Symbol: "TESTFT"
   - No NFT-specific metadata keys in ExternalInfo

**Transaction Steps:**
1. Ensure "TESTFT" token info exists in the side chain's MultiToken contract via cross-chain synchronization
2. Call `NFTContract.CrossChainCreate(new CrossChainCreateInput { Symbol = "TESTFT" })`

**Expected vs Actual Result:**
- **Expected**: Clear assertion failure with message like "Token TESTFT is not an NFT protocol" or "Missing required NFT metadata"
- **Actual**: Transaction fails with `System.Collections.Generic.KeyNotFoundException: The given key 'aelf_nft_base_uri' was not present in the dictionary`

**Success Condition:**
The exploit is successful when the function throws `KeyNotFoundException` instead of a controlled assertion failure, demonstrating the missing input validation.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L80-88)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L196-199)
```csharp
        tokenExternalInfo.Value[NftTypeMetadataKey] = input.NftType;
        // Add Uri to external info.
        tokenExternalInfo.Value[NftBaseUriMetadataKey] = input.BaseUri;
        tokenExternalInfo.Value[NftTokenIdReuseMetadataKey] = input.IsTokenIdReuse.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L705-712)
```csharp
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-332)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-7)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
```
