### Title
Lack of Aggregate Evil Miner Detection Allows Coordinated Network Degradation Below Individual Thresholds

### Summary
The `TryToDetectEvilMiners` method only checks individual miners against the threshold, allowing an attacker controlling multiple miners to keep each one just below the detection limit while collectively causing significant network degradation. With 3 malicious miners out of 17 each missing 42.8% of blocks, the network suffers approximately 7.5% total block production loss without triggering any detection.

### Finding Description
The evil miner detection mechanism in `TryToDetectEvilMiners` checks only individual miners against the threshold: [1](#0-0) 

The threshold is set to 4,320 missed time slots (3 days): [2](#0-1) 

With a typical 7-day term consisting of approximately 10,080 time slots (60 minutes/hour × 24 hours/day × 7 days), each miner can miss up to 4,319 slots (42.8%) without detection. The `MissedTimeSlots` counter is incremented each round for miners who don't produce blocks: [3](#0-2) 

When `ProcessNextRound` is called, it checks for evil miners and marks them: [4](#0-3) 

**Root Cause:** The detection logic lacks aggregate monitoring across multiple miners. There is no check for collective network degradation, only per-miner thresholds. An attacker controlling multiple miners can coordinate to stay below individual limits while collectively impacting network performance.

Miner selection is purely vote-based with no performance considerations: [5](#0-4) 

### Impact Explanation
**Concrete Network Degradation:**
- With 17 total miners, each should produce ~593 blocks per 7-day term
- If attacker controls 3 miners, each missing 4,319 time slots:
  - Expected blocks from 3 miners: 1,779
  - Actual blocks produced: ~1,016 
  - Network loss: ~763 blocks = **7.5% reduction in total block production**

**Affected Parties:**
- All network users experience increased transaction confirmation times
- dApp performance degrades due to reduced throughput
- Network reputation and reliability suffer

**Severity Justification:**
Medium severity due to measurable operational impact without catastrophic consensus failure. The attack causes sustained performance degradation that evades detection mechanisms.

### Likelihood Explanation
**Attacker Capabilities Required:**
- Must control multiple miner nodes (requires significant stake/votes to be elected)
- Ability to coordinate behavior across nodes

**Attack Complexity:**
Very low - simply configure miners to selectively not produce blocks while staying below 4,319 missed slots per term.

**Feasibility Conditions:**
- Controlling 3 of 17 miners requires ~17.6% of voting power
- Execution is trivial once miner status is achieved
- MissedTimeSlots reset every term, allowing indefinite attack duration: [6](#0-5) 

**Economic Constraints:**
Attackers lose mining rewards proportional to missed blocks. However, scenarios include:
- Competitor attacking network reputation
- Economic warfare (short positions on ELF token)
- State-level disruption attempts
- Establishing poor performance baseline for follow-on attacks

**Detection Difficulty:**
No automatic detection exists. Manual monitoring would be required to identify the coordinated pattern.

### Recommendation
**1. Implement Aggregate Network Health Monitoring:**

Add a check in `ProcessNextRound` that calculates total network missed blocks percentage and triggers alerts/actions if threshold exceeded:

```csharp
// In ProcessNextRound after line 154
var totalMissedSlots = currentRound.RealTimeMinersInformation.Values
    .Sum(m => m.MissedTimeSlots);
var totalPossibleSlots = currentRound.RealTimeMinersInformation.Count * 
    (currentRound.RoundNumber - /* first round of term */);
if (totalPossibleSlots > 0 && 
    totalMissedSlots * 100 / totalPossibleSlots > AggregateThresholdPercent)
{
    // Log warning or trigger emergency governance review
    Context.LogDebug(() => 
        $"Aggregate network performance degradation detected: {totalMissedSlots}/{totalPossibleSlots}");
}
```

**2. Add Performance Weighting to Miner Selection:**

Modify `GetVictories` in the Election contract to factor in `MissedTimeSlots` from `CandidateInformation`, reducing votes for poor performers.

**3. Lower Individual Threshold:**

Consider reducing `TolerableMissedTimeSlotsCount` from 4,320 to a value representing less than 25% of a term's slots (e.g., 2,500) to detect individual underperformance more quickly.

**4. Test Cases:**

Add integration tests simulating multiple miners coordinating to miss blocks below individual thresholds while measuring aggregate network impact.

### Proof of Concept
**Initial State:**
- 17 active miners in current term
- Attacker controls miners A, B, and C

**Attack Steps:**
1. Configure Miner A to miss blocks until `MissedTimeSlots = 4,319`
2. Configure Miner B to miss blocks until `MissedTimeSlots = 4,319`
3. Configure Miner C to miss blocks until `MissedTimeSlots = 4,319`
4. When approaching threshold, produce minimum blocks to reset suspicion
5. Repeat pattern across term boundaries (counter resets at term change)

**Expected Result:**
- Each individual miner: `MissedTimeSlots < 4,320` → No evil miner detection
- `TryToDetectEvilMiners` returns empty list
- Miners remain in good standing

**Actual Result:**
- Network produces ~7.5% fewer blocks than expected
- Transaction throughput reduced proportionally
- No automatic detection or remediation triggered
- Attack persists indefinitely across multiple terms

**Success Condition:**
Monitor network block production rate over 7-day term. If consistent 7-8% degradation occurs with no evil miner alerts, vulnerability is confirmed.

### Notes
The vulnerability represents a defense-in-depth gap rather than a critical consensus failure. While economic disincentives (lost mining rewards) exist, sophisticated adversaries with non-economic motivations (reputation attacks, competitive disruption, or preparing infrastructure for more severe attacks) could exploit this detection blind spot. The lack of aggregate monitoring means coordinated malicious behavior below per-entity thresholds goes unnoticed, which violates defense-in-depth principles for critical infrastructure.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L46-56)
```csharp
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L179-183)
```csharp
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-84)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
    }
```
