### Title
Authority Downgrade Vulnerability in ChangeMethodFeeController Allows Governance Bypass

### Summary
The `ChangeMethodFeeController` function fails to validate that the `input.ContractAddress` is a legitimate governance contract (Parliament, Association, or Referendum). An attacker who can execute this function through governance can substitute a malicious contract that always validates organizations as existing, then set a regular address as the controller. This permanently downgrades the authorization model from governance-controlled to single-address controlled, allowing future method fee changes without governance approval.

### Finding Description
The vulnerability exists in the `ChangeMethodFeeController` function where the validation logic only verifies that the `input.OwnerAddress` exists as an organization within the contract specified by `input.ContractAddress`, but never validates that `input.ContractAddress` itself is a whitelisted governance contract. [1](#0-0) 

The `CheckOrganizationExist` helper method performs a cross-contract call to the provided `ContractAddress` without any prior validation: [2](#0-1) 

This allows an attacker to deploy a malicious contract implementing a `ValidateOrganizationExist` method that always returns `true`, regardless of the organization address provided. The legitimate governance contracts only return `true` when the organization actually exists in their state: [3](#0-2) 

Once the malicious controller is set, the `SetMethodFee` function only validates that the sender matches the stored `OwnerAddress`, with no additional governance checks: [4](#0-3) 

The same vulnerability pattern exists across ALL contracts implementing ACS1, including MultiToken, Parliament, Treasury, and other system contracts. [5](#0-4) 

### Impact Explanation
**Governance Bypass**: Once exploited, all future method fee changes can be made by a single address without requiring proposal creation, approval voting, or release through the governance system. This violates the fundamental governance invariant.

**System-Wide Impact**: This vulnerability affects every contract implementing ACS1 (method fee standard), including critical system contracts like Token, Parliament, Treasury, Profit, Consensus, CrossChain, and others.

**Permanent Authorization Downgrade**: The attack converts a decentralized governance-controlled permission into a centralized single-address permission. The change persists until reversed through another governance action.

**Economic Impact**: Arbitrary method fee manipulation can enable DoS attacks (setting prohibitively high fees) or economic exploits (setting zero fees to spam the network). Method fees are critical for system economic security and spam protection.

**Severity: HIGH** - The vulnerability compromises the core authorization and governance model of the entire system.

### Likelihood Explanation
**Reachable Entry Point**: The `ChangeMethodFeeController` function is a public method callable through standard governance proposal mechanisms.

**Attack Prerequisites**: The attacker must either:
1. Control the current `MethodFeeController.OwnerAddress` (which in default configurations is a Parliament organization virtual address), OR
2. Successfully create, approve, and release a malicious governance proposal

**Execution Complexity**: MEDIUM
- Requires deploying a malicious contract (trivial)
- Requires gaining governance approval for the controller change (social engineering or governance compromise)
- Once approved, execution is straightforward

**Detection Difficulty**: The malicious proposal would be observable on-chain, but distinguishing between legitimate governance contract changes and this attack requires detailed inspection of the target contract's code.

**Economic Feasibility**: Contract deployment costs are minimal. The main barrier is obtaining governance approval for the proposal.

**Likelihood Assessment: MEDIUM to HIGH** - While initial access requires governance participation, many governance systems have been compromised through social engineering, insider threats, or proposal obfuscation. Once exploited, the damage is permanent and system-wide.

### Recommendation
Implement a whitelist validation that ensures `input.ContractAddress` is one of the authorized governance contracts before accepting the controller change:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // NEW: Validate ContractAddress is a known governance contract
    var validGovernanceContracts = new[] {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    Assert(validGovernanceContracts.Contains(input.ContractAddress), 
           "Invalid governance contract address.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Apply this fix to ALL contracts implementing ACS1**, including:
- ProfitContract
- TokenContract
- ParliamentContract
- TreasuryContract
- GenesisContract (BasicContractZero)
- And all other system contracts

**Test Cases**: Add regression tests that verify:
1. Controller changes with invalid contract addresses are rejected
2. Controller changes with malicious contracts are rejected
3. Only Parliament, Association, and Referendum contract addresses are accepted
4. Valid governance contract changes continue to work correctly

### Proof of Concept

**Initial State**:
- MethodFeeController = {OwnerAddress: ParliamentDefaultOrg, ContractAddress: ParliamentContract}
- Default governance requires proposal approval by Parliament

**Attack Steps**:

1. **Deploy Malicious Contract**:
```csharp
public class MaliciousGovernance : MaliciousGovernanceBase {
    public override BoolValue ValidateOrganizationExist(Address input) {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Governance Proposal** to call `ChangeMethodFeeController` with:
   - `input.ContractAddress` = MaliciousGovernanceAddress
   - `input.OwnerAddress` = AttackerAddress

3. **Approve and Release Proposal** through normal governance (requires social engineering or compromise)

4. **Result**: 
   - Expected: Proposal should fail due to invalid governance contract
   - Actual: Proposal succeeds, MethodFeeController now set to {OwnerAddress: AttackerAddress, ContractAddress: MaliciousGovernance}

5. **Exploitation**:
   - Attacker directly calls `SetMethodFee` with arbitrary fee values
   - Transaction succeeds because `Context.Sender == MethodFeeController.OwnerAddress` (AttackerAddress)
   - No governance approval needed for future changes
   - Governance has been permanently bypassed

**Success Condition**: Attacker can unilaterally modify method fees without creating proposals or obtaining governance approval, violating the critical governance invariant.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L22-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L90-95)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L24-33)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```
