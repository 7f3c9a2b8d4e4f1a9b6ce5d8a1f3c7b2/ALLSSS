### Title
Predictable Miner Ordering in First Round of New Terms Enables Targeted Attacks

### Summary
The `GenerateFirstRoundOfNewTerm()` method sorts miners deterministically by the first byte of their public keys in descending order, allowing any party to calculate exact mining orders and time slots before a term starts. This creates a predictable attack window at every term transition (every 7 days) where miners can be targeted for DoS attacks or MEV extraction.

### Finding Description

The vulnerable sorting logic in `GenerateFirstRoundOfNewTerm()` extracts only the first byte of each public key and sorts in descending order: [1](#0-0) 

This is combined with deterministic time slot calculation: [2](#0-1) 

The miner list for new terms comes from the Election contract's `GetVictories()` method, which is publicly queryable: [3](#0-2) 

**Root Cause:** Although the AEDPoS system includes VRF-based randomness in `NextTermInput`, this random value is only used for verification and storage: [4](#0-3) 

The random number is **not** used to shuffle the initial miner order when generating the first round of new terms: [5](#0-4) 

While subsequent rounds within a term use signature-based shuffling: [6](#0-5) [7](#0-6) 

The first round of each new term remains completely predictable due to the trivial first-byte sorting.

### Impact Explanation

**Concrete Harms:**

1. **Targeted Network-Level DoS**: Adversarial actors can pre-calculate which miners will produce the first blocks of a new term and launch DDoS attacks at their exact expected mining times, causing them to miss blocks. Impact: Loss of block rewards (initially 12.5 ELF per block based on system constants).

2. **Extra Block Producer Manipulation**: The first miner in sorted order becomes the extra block producer with special privileges: [8](#0-7) 

A miner could generate vanity public keys with low first bytes (e.g., `0x00`, `0x01`) to systematically gain this privileged role.

3. **MEV/Front-running Preparation**: Knowing exact mining times enables miners to prepare profitable transaction orderings and coordinate MEV extraction strategies in advance.

4. **Unfair Consensus Participation**: Violates fairness assumptions - miners with unfavorable first-byte values consistently mine early in new terms and face systematic targeting.

**Affected Parties**: All miners in the network, particularly those with high/low first-byte public key values who occupy predictable positions.

**Severity Justification**: Medium - Creates a recurring 7-day cycle vulnerability window enabling DoS and MEV attacks, but requires external resources and doesn't directly steal funds or permanently break consensus.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Basic: Query Election contract for next term's miner list (publicly available)
- Basic: Perform sorting calculation (trivial computation using first byte)
- Moderate: Network infrastructure for DDoS attacks OR
- Low: Smart contract deployment for MEV extraction

**Attack Complexity:** Low - The calculation is trivial: extract first byte from each public key, sort descending, calculate time slots at 4000ms intervals.

**Feasibility Conditions:**
- Occurs at every term transition (every 7 days with default 604800 second period)
- No special permissions required
- Miner list is publicly available before term starts
- Attack surface exists from election announcement until first round completes

**Detection/Operational Constraints:** 
- Network-level DDoS is difficult to attribute to specific miners
- MEV extraction appears as normal transaction ordering
- Low probability of detection makes attack cost-effective
- No on-chain traces of reconnaissance phase

**Probability Reasoning:** High probability of exploitation given:
- Predictable recurring opportunity every 7 days
- Economic incentives (block rewards of 12.5+ ELF per block)
- Low technical barrier to identify targets
- Existing VRF infrastructure available but unused for this purpose

### Recommendation

**Code-Level Mitigation:**

Modify `GenerateFirstRoundOfNewTerm()` to accept and utilize a cryptographic random seed for miner ordering. Use the existing VRF `randomNumber` from `NextTermInput` to deterministically shuffle miners instead of sorting by first byte:

```csharp
internal Round GenerateFirstRoundOfNewTerm(int miningInterval,
    Timestamp currentBlockTime, Hash randomSeed, long currentRoundNumber = 0, long currentTermNumber = 0)
{
    var sortedMiners = ShuffleMinersByRandomness(Pubkeys, randomSeed);
    // ... rest of implementation
}

private List<string> ShuffleMinersByRandomness(RepeatedField<ByteString> pubkeys, Hash randomSeed)
{
    return pubkeys
        .Select((pk, idx) => new {
            Pubkey = pk.ToHex(),
            Score = HashHelper.ComputeFrom(HashHelper.ConcatAndCompute(randomSeed, pk)).ToInt64()
        })
        .OrderBy(x => x.Score)
        .Select(x => x.Pubkey)
        .ToList();
}
```

Pass the VRF `randomNumber` from the consensus transaction through to the round generation process in: [9](#0-8) 

**Invariant Checks:**
- Assert that miner ordering uses cryptographically strong randomness source
- Verify no two consecutive first rounds use identical ordering for same miner set
- Ensure VRF random number is incorporated into ordering calculation

**Test Cases:**
```csharp
[Fact]
public void FirstRound_DifferentRandomSeeds_ProduceDifferentOrders()
{
    var minerList = GetTestMinerList();
    var seed1 = HashHelper.ComputeFrom("seed1");
    var seed2 = HashHelper.ComputeFrom("seed2");
    
    var round1 = minerList.GenerateFirstRoundOfNewTerm(4000, timestamp, seed1);
    var round2 = minerList.GenerateFirstRoundOfNewTerm(4000, timestamp, seed2);
    
    Assert.NotEqual(
        round1.RealTimeMinersInformation.First().Key,
        round2.RealTimeMinersInformation.First().Key
    );
}

[Fact]
public void FirstRound_SameRandomSeed_ProducesConsistentOrder()
{
    var minerList = GetTestMinerList();
    var seed = HashHelper.ComputeFrom("seed");
    
    var round1 = minerList.GenerateFirstRoundOfNewTerm(4000, timestamp, seed);
    var round2 = minerList.GenerateFirstRoundOfNewTerm(4000, timestamp, seed);
    
    Assert.Equal(
        round1.RealTimeMinersInformation.Keys.ToList(),
        round2.RealTimeMinersInformation.Keys.ToList()
    );
}
```

### Proof of Concept

**Initial State:**
- Current term: 5
- Term period: 604800 seconds (7 days)
- Current block time: T
- Next term starts at: T + remaining_seconds
- Mining interval: 4000ms

**Attack Sequence:**

1. **Reconnaissance (before term transition):**
   - Call `GetVictories()` to obtain next term's miner list
   - For each public key, extract first byte: `pubkey[0]`
   - Sort miners by first byte in descending order
   - Calculate exact mining times: `termStartTime + (order * 4000ms)`

2. **Preparation:**
   - Identify miners at positions 1-3 (first 12 seconds of new term)
   - Set up DDoS infrastructure targeting these miners' network endpoints
   - Or prepare MEV extraction contracts if attacker is a miner

3. **Execution (at term transition):**
   - At `termStartTime + 3500ms`: Launch DDoS against first miner
   - At `termStartTime + 7500ms`: Launch DDoS against second miner
   - Result: Target miners miss their time slots
   - Attacker gains relative advantage through increased block production ratio

4. **Success Condition:**
   - Prediction: Calculate mining schedule before term starts using first-byte sorting
   - Verification: Compare predicted order with actual mining order after term transition
   - Result: 100% match confirms complete predictability

**Verification Query:**
```javascript
// Before term transition
nextMiners = ElectionContract.GetVictories()
predictedOrder = nextMiners
    .map(pk => ({ pk, firstByte: pk[0] }))
    .sort((a,b) => b.firstByte - a.firstByte)
    .map((m, i) => ({ 
        miner: m.pk,
        order: i + 1,
        miningTime: termStartTime + (i + 1) * 4000
    }))

// After term transition
actualOrder = AEDPoSContract.GetCurrentRoundInformation()
    .RealTimeMinersInformation
    .OrderBy(m => m.Order)

// Verify: predictedOrder == actualOrder (100% match)
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L27-28)
```csharp
            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L31-33)
```csharp
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L41-50)
```csharp
    public override PubkeyList GetVictories(Empty input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        var currentMiners = State.AEDPoSContract.GetCurrentMinerList.Call(new Empty()).Pubkeys
            .Select(k => k.ToHex()).ToList();
        return new PubkeyList { Value = { GetVictories(currentMiners) } };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-44)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```
