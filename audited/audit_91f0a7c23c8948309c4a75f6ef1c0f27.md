### Title
ProposerWhiteList Desynchronization in ChangeMember() Breaking Proposal Authorization

### Summary
The `ChangeMember()` function in the Association contract updates the organization member list but does not synchronize the ProposerWhiteList, creating an inconsistent authorization state. When an OldMember in the ProposerWhiteList is replaced with a NewMember who is not in the whitelist, the OldMember retains proposal creation rights without voting rights, while the NewMember gains voting rights without proposal creation rights, breaking the intended authorization model.

### Finding Description

The vulnerability exists in the `ChangeMember()` function [1](#0-0)  which only modifies the `OrganizationMemberList` without updating the `ProposerWhiteList`.

An Association organization maintains two critical authorization lists:
- `OrganizationMemberList`: members who can vote on proposals (approve/reject/abstain)
- `ProposerWhiteList`: addresses authorized to create proposals

When `ChangeMember()` is called, it removes OldMember from OrganizationMemberList and adds NewMember to OrganizationMemberList, but the ProposerWhiteList remains unchanged.

Proposal creation authorization is enforced by `AssertIsAuthorizedProposer()` [2](#0-1)  which only checks ProposerWhiteList membership. Voting authorization is enforced by `AssertIsAuthorizedOrganizationMember()` [3](#0-2)  which only checks OrganizationMemberList membership.

The `Validate()` function [4](#0-3)  does not enforce consistency between ProposerWhiteList and OrganizationMemberList - it only checks that neither list is empty, has no duplicates, and threshold constraints are met, but does not verify that ProposerWhiteList members are also in OrganizationMemberList.

Proposal creation checks in `CreateProposal()` [5](#0-4)  and `CreateProposalBySystemContract()` [6](#0-5)  only verify ProposerWhiteList membership, not OrganizationMemberList membership.

### Impact Explanation

This vulnerability breaks the authorization invariant of the Association governance system:

1. **Authorization Bypass**: OldMember who is removed from the organization retains proposal creation rights, allowing a replaced/untrusted member to continue influencing governance decisions by creating proposals they should no longer be able to create.

2. **Incomplete Privilege Transfer**: NewMember who replaces OldMember gains voting rights but not proposal creation rights, preventing them from exercising the full governance authority that the replacement was intended to grant.

3. **Operational Complexity**: Organizations must perform two separate governance actions (ChangeMember + ChangeOrganizationProposerWhiteList) to properly replace a proposer, increasing complexity and risk of incomplete transitions.

4. **Potential for Malicious Proposals**: If OldMember's address is compromised or becomes untrusted (the reason for replacement), they can still create malicious proposals that NewMember cannot, violating the security model.

The severity is Medium because while it breaks authorization invariants and can lead to unauthorized proposal creation, it:
- Requires governance action to trigger (organization must call ChangeMember)
- Does not directly steal funds
- Can be mitigated by separately calling ChangeOrganizationProposerWhiteList [7](#0-6) 
- Proposals still require approval thresholds to execute

### Likelihood Explanation

This vulnerability has high likelihood of occurrence:

1. **Common Scenario**: Organizations frequently need to replace members who leave, become inactive, or are removed for trust reasons. Having the departing member in ProposerWhiteList is a common governance configuration.

2. **Entry Point Accessibility**: `ChangeMember()` is callable by the organization itself (Context.Sender must equal the organization address), which is the standard way organizations modify their membership through governance proposals.

3. **Non-Obvious Requirement**: The need to separately update ProposerWhiteList is not enforced by the contract and is not documented in the function signature or validation logic, making it easy for organizations to overlook.

4. **Operational Friction**: The two-step process (ChangeMember + ChangeOrganizationProposerWhiteList) requires two separate governance proposals and votes, increasing the likelihood that only the first step is completed.

5. **No Automated Detection**: The contract does not emit warnings or fail validation when ProposerWhiteList becomes inconsistent with OrganizationMemberList, allowing the vulnerable state to persist undetected.

### Recommendation

**Immediate Fix**: Modify `ChangeMember()` to automatically update ProposerWhiteList when OldMember is in it:

```csharp
public override Empty ChangeMember(ChangeMemberInput input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
    Assert(removeResult, "Remove member failed.");
    organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
    
    // Automatically transfer ProposerWhiteList membership
    if (organization.ProposerWhiteList.Proposers.Contains(input.OldMember))
    {
        organization.ProposerWhiteList.Proposers.Remove(input.OldMember);
        organization.ProposerWhiteList.Proposers.Add(input.NewMember);
    }
    
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new MemberChanged
    {
        OrganizationAddress = Context.Sender,
        OldMember = input.OldMember,
        NewMember = input.NewMember
    });
    return new Empty();
}
```

**Additional Validation**: Add invariant check in `Validate()` function to ensure ProposerWhiteList members are also in OrganizationMemberList:

```csharp
// Add to Validate() function
foreach (var proposer in organization.ProposerWhiteList.Proposers)
{
    if (!organization.OrganizationMemberList.OrganizationMembers.Contains(proposer))
        return false;
}
```

**Test Cases**: Add regression tests covering:
1. ChangeMember with OldMember in ProposerWhiteList transfers whitelist membership to NewMember
2. ChangeMember with OldMember not in ProposerWhiteList leaves whitelist unchanged
3. Organization validation fails if ProposerWhiteList contains non-members

### Proof of Concept

**Initial State**:
- Organization has members: [Reviewer1, Reviewer2, Reviewer3]
- ProposerWhiteList: [Reviewer1]
- Reviewer1 can create proposals and vote

**Attack Sequence**:

1. Organization calls `ChangeMember(OldMember=Reviewer1, NewMember=Reviewer4)` through governance proposal
   - Result: OrganizationMemberList becomes [Reviewer4, Reviewer2, Reviewer3]
   - Result: ProposerWhiteList remains [Reviewer1]

2. Reviewer1 calls `CreateProposal()`
   - `AssertIsAuthorizedProposer()` checks ProposerWhiteList: Reviewer1 is in list ✓
   - Proposal is created successfully
   - Expected: Should fail because Reviewer1 is no longer a member
   - Actual: Succeeds - **AUTHORIZATION BYPASS**

3. Reviewer1 attempts to vote on their own proposal by calling `Approve()`
   - `AssertIsAuthorizedOrganizationMember()` checks OrganizationMemberList: Reviewer1 not in list ✗
   - Fails with "Unauthorized member"
   - Result: Reviewer1 can create proposals but cannot vote

4. Reviewer4 attempts to call `CreateProposal()`
   - `AssertIsAuthorizedProposer()` checks ProposerWhiteList: Reviewer4 not in list ✗
   - Fails with "Unauthorized to propose"
   - Expected: Should succeed because Reviewer4 is now a member replacing Reviewer1
   - Actual: Fails - **INCOMPLETE PRIVILEGE TRANSFER**

**Success Condition**: The vulnerability is confirmed when:
- OldMember (Reviewer1) retains proposal creation rights without voting rights
- NewMember (Reviewer4) has voting rights without proposal creation rights
- This violates the authorization invariant that member replacement should transfer all governance privileges

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L114-121)
```csharp
    public override Hash CreateProposalBySystemContract(CreateProposalBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Not authorized to propose.");
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
        var proposalId = CreateNewProposal(input.ProposalInput);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L218-231)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L248-264)
```csharp
    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```
