### Title
Scheme Manager Can Dilute User Profits by Adding Phantom Shares Without Token Locking

### Summary
The TokenHolder contract's `AddBeneficiary` function allows the scheme manager to add beneficiaries with arbitrary shares without requiring any token locking, while regular users must lock tokens via `RegisterForProfits` to receive shares. This asymmetry enables the scheme manager to front-run profit distribution by adding themselves with massive phantom shares, diluting legitimate users' profit entitlements proportionally.

### Finding Description

The vulnerability exists in the TokenHolder contract's profit share allocation mechanism. The contract provides two paths for becoming a beneficiary:

**Path 1 - Regular Users (RegisterForProfits):**
Users must lock tokens to receive shares. The function locks the specified token amount and adds the user as a beneficiary with shares equal to the locked amount. [1](#0-0) 

**Path 2 - Scheme Manager (AddBeneficiary):**
The scheme manager can directly add any beneficiary with arbitrary shares without any token locking requirement. The only authorization check is that the caller must be the scheme manager. [2](#0-1) 

The authorization check in the underlying Profit contract only verifies that the caller is either the scheme manager or the TokenHolder contract, but does not enforce any economic backing for the shares: [3](#0-2) 

When profits are distributed, the calculation uses proportional share allocation without distinguishing between shares backed by locked tokens and phantom shares: [4](#0-3) 

The profit claim mechanism calculates each beneficiary's share as `(beneficiary_shares / total_shares) * total_amount`, treating all shares equally regardless of their origin: [5](#0-4) 

### Impact Explanation

**Direct Fund Theft:** Users who legitimately lock tokens to participate in profit distribution will receive proportionally reduced profits when the scheme manager adds phantom shares. For example:
- User A locks 1,000 tokens → receives 1,000 shares
- Profit contribution: 10,000 tokens
- Manager adds themselves with 9,000 phantom shares (no locking)
- Total shares: 10,000
- User A receives: (1,000/10,000) × 10,000 = 1,000 tokens (10% instead of 100%)
- Manager receives: (9,000/10,000) × 10,000 = 9,000 tokens (90% with zero economic contribution)

**Who is Affected:** All users who lock tokens via `RegisterForProfits` in schemes where the manager acts maliciously. The economic damage scales with the amount of profit being distributed and the ratio of phantom shares to legitimate shares.

**Severity Justification:** HIGH severity because it enables direct theft of user funds through profit dilution, with the manager capturing value without providing any economic backing (locked tokens).

### Likelihood Explanation

**Attacker Capabilities:** The attacker must be the scheme manager, which is the address that created the TokenHolder profit scheme. This is not a privileged admin role requiring governance approval - any user can create a scheme and become its manager. [6](#0-5) 

**Attack Complexity:** LOW - The attack requires only a single transaction calling `AddBeneficiary` with the manager's own address and desired share amount. No complex state manipulation or timing requirements exist beyond ensuring execution before `DistributeProfits`.

**Feasibility Conditions:** The manager has full control over when to call `DistributeProfits`, enabling them to add phantom shares immediately before distribution without any front-running risk: [7](#0-6) 

**Detection Constraints:** The attack is difficult to detect pre-execution because `AddBeneficiary` is a legitimate function. Users have no visibility into when the manager will add beneficiaries or distribute profits. Post-execution, users can observe the dilution but cannot prevent or reverse it.

**Probability Reasoning:** HIGH probability in any scheme where the manager has financial incentive to maximize their profit share at users' expense. The zero cost and guaranteed success make this an economically rational attack for malicious managers.

### Recommendation

**Code-Level Mitigation:**
1. Require token locking in `AddBeneficiary` similar to `RegisterForProfits`, or restrict `AddBeneficiary` to only adding beneficiaries with zero initial shares (to be accumulated through separate token locking operations)
2. Add a time lock or delay period between calling `AddBeneficiary` and the shares becoming effective for profit distribution
3. Implement a cap on the ratio of manager-added shares to user-locked shares

**Example Fix for TokenHolderContract.AddBeneficiary:**
```csharp
public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
{
    var scheme = GetValidScheme(Context.Sender);
    
    // NEW: Require token locking for shares
    var lockId = Context.GenerateId(Context.Self,
        ByteArrayHelper.ConcatArrays(Context.Sender.ToByteArray(), input.Beneficiary.ToByteArray()));
    State.TokenContract.Lock.Send(new LockInput
    {
        LockId = lockId,
        Symbol = scheme.Symbol,
        Address = input.Beneficiary,
        Amount = input.Shares
    });
    
    // Rest of existing logic...
}
```

**Invariant Checks:**
- Assert that total shares never exceed total locked tokens in the scheme
- Verify that each beneficiary's shares correspond to an equivalent locked token amount
- Add events logging all `AddBeneficiary` calls with timestamp to enable transparency

**Test Cases:**
1. Test that `AddBeneficiary` reverts when attempting to add shares without locking tokens
2. Test that profit distribution remains proportional to actual locked amounts
3. Test that manager cannot dilute user profits through phantom shares
4. Test the time lock delay mechanism if implemented

### Proof of Concept

**Initial State:**
- Scheme manager creates a TokenHolder profit scheme for "ELF" token
- User A calls `RegisterForProfits` locking 1,000 ELF → receives 1,000 shares
- Total shares in scheme: 1,000
- Scheme virtual address receives 10,000 ELF as profit contribution

**Attack Sequence:**
1. Manager observes pending profit distribution of 10,000 ELF
2. Manager calls `AddBeneficiary(manager_address, 9,000)` → adds 9,000 phantom shares
3. Total shares updated to: 10,000 (1,000 user + 9,000 manager)
4. Manager calls `DistributeProfits`
5. Profit distribution executed:
   - User A's claimable profit: (1,000 / 10,000) × 10,000 = 1,000 ELF
   - Manager's claimable profit: (9,000 / 10,000) × 10,000 = 9,000 ELF
6. Manager calls `ClaimProfits` and receives 9,000 ELF
7. Manager optionally calls `RemoveBeneficiary` to remove their phantom shares

**Expected vs Actual Result:**
- **Expected:** User A should receive 10,000 ELF (or proportional share based on other legitimate locked token holders)
- **Actual:** User A receives only 1,000 ELF, with 9,000 ELF stolen by manager who locked zero tokens

**Success Condition:** Manager successfully claims 9,000 ELF profit without locking any tokens, while User A who locked 1,000 ELF only receives 1,000 ELF profit, demonstrating the profit dilution attack.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L20-25)
```csharp
        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-136)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
        var distributeProfitsInput = new Profit.DistributeProfitsInput
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
