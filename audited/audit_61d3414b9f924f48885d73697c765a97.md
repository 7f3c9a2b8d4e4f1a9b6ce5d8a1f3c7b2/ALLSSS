# Audit Report

## Title
Missing Authorization Check for Extra Block Producer in Round Termination

## Summary
The AEDPoS consensus validation does not verify that the sender of a `NextRound` or `NextTerm` block is the designated extra block producer (`IsExtraBlockProducer = true`). Any miner whose time slot has passed can produce a round-terminating block and gain the associated block production credit and `ExtraBlockProducerOfPreviousRound` status, bypassing the intended consensus role assignment and undermining fair reward distribution.

## Finding Description

In AEDPoS consensus, each round concludes with a designated "extra block producer" who should produce the final block to terminate the round. This role is assigned via the `IsExtraBlockProducer` flag and is meant to be fairly distributed across miners. [1](#0-0) 

However, the consensus validation fails to enforce this role assignment:

**1. Automatic Behavior Assignment Without Authorization Check**

When any miner's time slot passes, `GetConsensusBehaviour()` automatically returns `NextRound` or `NextTerm` behavior without checking if that miner is the designated extra block producer: [2](#0-1) 

**2. Missing Validation in ValidateBeforeExecution**

When a `NextRound` or `NextTerm` block is validated, the system applies several validators, but NONE check if the sender is the designated extra block producer: [3](#0-2) 

Specifically:
- `MiningPermissionValidationProvider` only checks miner list membership: [4](#0-3) 

- `TimeSlotValidationProvider` only validates time slot consistency of the new round structure, not who produced it: [5](#0-4) 

- `RoundTerminateValidationProvider` only validates round/term number correctness: [6](#0-5) 

**3. PreCheck Insufficient**

The `PreCheck` method in `ProcessConsensusInformation` only verifies miner list membership, not extra block producer authorization: [7](#0-6) 

**4. IsCurrentMiner Method Exists But Unused**

The codebase contains an `IsCurrentMiner()` method that DOES check if a miner is the extra block producer at the appropriate time: [8](#0-7) 

However, this method is never called during consensus validation, rendering the check ineffective.

**5. Exploitable Consequences**

When a non-designated miner successfully produces a `NextRound` block, they gain:

- Incremented `ProducedBlocks` count used for reward calculation: [9](#0-8) 

- Status as `ExtraBlockProducerOfPreviousRound` for the next round: [10](#0-9) 

This status grants extended mining privileges in the subsequent round: [11](#0-10) 

## Impact Explanation

**Consensus Invariant Violation**: The protocol design intends that only the designated extra block producer (identified by `IsExtraBlockProducer = true`) should terminate each round. The validation failure breaks this invariant, allowing any miner to usurp this role.

**Reward Misallocation**: Miners who produce round-terminating blocks receive an additional `ProducedBlocks` increment, which directly affects mining reward distribution. An unauthorized miner gains rewards meant for the designated producer.

**Fairness Breach**: The extra block producer role is pseudo-randomly assigned to distribute opportunities fairly across all miners. Allowing miners to bypass this assignment undermines the fairness mechanism and creates opportunities for strategic manipulation.

**Quantified Impact**: Each improperly produced extra block represents one additional block credit for the exploiting miner and the loss of that credit for the designated producer. With mining rewards per block currently set by the Treasury contract, this represents a direct financial impact proportional to the per-block reward value.

## Likelihood Explanation

**Attacker Capability**: Any active miner in the current round can execute this attack with no special privileges required.

**Technical Feasibility**: HIGH
1. Attacker waits for their normal time slot to pass
2. Requests consensus command from their node
3. Receives `NextRound`/`NextTerm` behavior automatically
4. Produces and broadcasts the block
5. Block passes all validation checks despite attacker not being the designated extra block producer

**Preconditions**: 
- Attacker must be an active miner in the current round (standard consensus participant)
- Attacker's normal time slot must have elapsed
- No additional authorization or privilege required

**Detection Difficulty**: The blockchain validation logic accepts these blocks as valid, making detection difficult without off-chain monitoring of intended vs. actual extra block producers.

**Probability**: HIGH - Every miner can potentially exploit this after their time slot passes in every round.

## Recommendation

Add a validation check in `ValidateBeforeExecution` for `NextRound` and `NextTerm` behaviors that verifies the sender is the designated extra block producer. This can be implemented by:

1. Adding a new validation provider `ExtraBlockProducerValidationProvider` that checks:
   - For NextRound/NextTerm behaviors
   - Current time >= extra block mining time (`currentRound.GetExtraBlockMiningTime()`)
   - Sender pubkey == designated extra block producer (`currentRound.GetExtraBlockProducerInformation().Pubkey`)

2. Alternatively, incorporate the existing `IsCurrentMiner()` logic into the validation flow, as it already implements the correct authorization check.

3. Apply this validator before allowing NextRound/NextTerm blocks to be processed.

The fix should mirror the logic already present in `IsCurrentMiner()` at lines 169-178 of `AEDPoSContract_ViewMethods.cs`, ensuring that only the designated extra block producer can terminate rounds at the appropriate time.

## Proof of Concept

Due to the complexity of setting up a full consensus test environment, I'll describe the exploit scenario:

**Scenario**:
- Round has miners A, B, C, D, E
- Miner C is designated as extra block producer (IsExtraBlockProducer = true)
- Miner B's normal time slot passes (B is NOT the extra block producer)

**Exploit Steps**:
1. Miner B calls `GetConsensusCommand()` - receives NextRound behavior
2. Miner B produces NextRound block with next round information
3. Block is broadcast to network
4. Validation runs:
   - `MiningPermissionValidationProvider`: ✓ Pass (B is in miner list)
   - `TimeSlotValidationProvider`: ✓ Pass (only checks time slot consistency)
   - `NextRoundMiningOrderValidationProvider`: ✓ Pass (checks mining order correctness)
   - `RoundTerminateValidationProvider`: ✓ Pass (validates round numbers)
   - **Missing check**: Is sender the designated extra block producer? ✗ NOT CHECKED
5. Block is accepted
6. Miner B's `ProducedBlocks` is incremented
7. Miner B becomes `ExtraBlockProducerOfPreviousRound` in next round
8. Designated producer C loses the opportunity

**Result**: Miner B successfully produced a round-terminating block despite not being the designated extra block producer, gaining rewards and privileges that should have belonged to Miner C.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L64-92)
```csharp
        // Add basic providers at first.
        var validationProviders = new List<IHeaderInformationValidationProvider>
        {
            // Is sender in miner list (of base round)?
            new MiningPermissionValidationProvider(),

            // Is this block produced in proper time?
            new TimeSlotValidationProvider(),

            // Is sender produced too many blocks at one time?
            new ContinuousBlocksValidationProvider()
        };

        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L9-47)
```csharp
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var extraData = validationContext.ExtraData;
        if (extraData.Behaviour == AElfConsensusBehaviour.NextRound) return ValidationForNextRound(validationContext);

        if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm) return ValidationForNextTerm(validationContext);

        validationResult.Success = true;
        return validationResult;
    }

    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L169-178)
```csharp
        var supposedExtraBlockProducer =
            currentRound.RealTimeMinersInformation.Single(m => m.Value.IsExtraBlockProducer).Key;

        // Check extra block time slot.
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L178-178)
```csharp
        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L191-192)
```csharp
        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
```
