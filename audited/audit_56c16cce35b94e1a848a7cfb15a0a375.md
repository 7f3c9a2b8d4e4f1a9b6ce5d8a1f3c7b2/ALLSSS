### Title
NFT Contract ChangeMethodFeeController Silently Ignores Controller Changes Due to Missing State Persistence

### Summary
The `ChangeMethodFeeController()` method in the NFT contract accepts input but fails to persist the new controller to state, causing all controller change attempts to be silently ignored. [1](#0-0)  This violates the ACS1 standard that the contract declares to implement [2](#0-1)  and prevents governance from controlling method fees.

### Finding Description

**Root Cause:** The NFT contract's `ChangeMethodFeeController()` implementation is a stub that simply returns `new Empty()` without any state persistence logic. [1](#0-0) 

**Missing State Variable:** The NFT contract state does not define the required `State.MethodFeeController` property that should store the controller information. [3](#0-2)  This differs from proper implementations which define it as `SingletonState<AuthorityInfo>`. [4](#0-3) 

**Standard Violation:** The NFT contract declares ACS1 implementation as its base [2](#0-1)  but fails to implement the standard correctly. The ACS1 standard requires `ChangeMethodFeeController` to persist the new `AuthorityInfo` input containing `contract_address` and `owner_address` fields. [5](#0-4) 

**Proper Implementation Pattern:** Other system contracts demonstrate the correct implementation by: (1) validating sender authorization, (2) checking organization existence, and (3) persisting with `State.MethodFeeController.Value = input;`. [6](#0-5) 

**Compounding Issue:** The `GetMethodFeeController()` method returns an empty `AuthorityInfo` object [7](#0-6)  and `SetMethodFee()` is also a non-functional stub. [8](#0-7)  This means the entire method fee control system is non-operational, leaving fees hardcoded at 100 ELF for the Create method. [9](#0-8) 

### Impact Explanation

**Governance Control Loss:** Governance bodies cannot establish proper authority over NFT contract method fees. Any governance proposal to change the method fee controller will appear to execute successfully but have no effect, wasting governance resources and creating confusion about system control.

**Inflexible Fee Structure:** The hardcoded 100 ELF fee for NFT creation [10](#0-9)  cannot be adjusted through governance. If market conditions change (ELF price fluctuation, desired accessibility changes), the fee remains static, potentially making NFT creation prohibitively expensive or too cheap.

**Protocol Integrity:** The silent failure violates the principle of least surprise and creates a security anti-pattern where transactions succeed without performing their intended action. This undermines trust in the governance system and contract standard compliance.

**Affected Parties:** 
- Governance participants who invest time/resources in proposals that silently fail
- NFT creators who cannot benefit from fee adjustments
- Protocol administrators who lose visibility into controller state

**Severity Justification:** High severity due to complete loss of governance control over a key contract parameter, violation of declared standards, and potential economic impact from inflexible fees.

### Likelihood Explanation

**Reachability:** The `ChangeMethodFeeController()` method is a public function accessible to any caller. [11](#0-10) 

**Execution Simplicity:** Demonstrating this vulnerability requires only:
1. Call `GetMethodFeeController()` → returns empty AuthorityInfo
2. Call `ChangeMethodFeeController()` with new AuthorityInfo → succeeds
3. Call `GetMethodFeeController()` again → still returns empty AuthorityInfo

**No Barriers:** The stub implementation has no authorization checks, validation logic, or state persistence. Any call will demonstrate the silent failure immediately.

**Detection Difficulty:** The vulnerability is discoverable through basic functional testing or governance proposal execution. Once discovered, it's trivial to reproduce.

**Probability:** High - This is a deterministic failure that occurs on every invocation. The issue will manifest whenever governance attempts to manage NFT method fees.

### Recommendation

**1. Define State Variable:** Add to `NFTContractState.cs`:
```csharp
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**2. Implement ChangeMethodFeeController:** Replace the stub implementation with proper logic:
- Add authorization check against current `State.MethodFeeController.Value.OwnerAddress`
- Validate the new authority organization exists via cross-contract call
- Persist with `State.MethodFeeController.Value = input;`
- Initialize default controller (Parliament default organization) if not set

**3. Implement GetMethodFeeController:** Return `State.MethodFeeController.Value` after ensuring initialization, following the pattern in [12](#0-11) 

**4. Implement SetMethodFee:** Add logic to:
- Validate sender is `State.MethodFeeController.Value.OwnerAddress`
- Validate token symbols are available for method fees
- Persist fees to state map

**5. Add Test Coverage:** Create tests verifying:
- Controller initialization to Parliament default
- Successful controller change through governance proposal
- Unauthorized change attempts are rejected
- Method fee updates work after controller is set
- GetMethodFeeController returns persisted values

### Proof of Concept

**Initial State:**
- NFT contract deployed and initialized
- No method fee controller configured

**Exploitation Steps:**

1. **Query Initial Controller:**
   - Call: `NFTContract.GetMethodFeeController(Empty)`
   - Expected: Returns current controller AuthorityInfo
   - Actual: Returns empty AuthorityInfo [7](#0-6) 

2. **Attempt Controller Change:**
   - Create new AuthorityInfo with custom owner_address and contract_address
   - Call: `NFTContract.ChangeMethodFeeController(newAuthorityInfo)`
   - Expected: Should validate authorization and persist new controller
   - Actual: Returns Empty successfully without persisting anything [1](#0-0) 

3. **Verify Controller State:**
   - Call: `NFTContract.GetMethodFeeController(Empty)` again
   - Expected: Should return the newAuthorityInfo from step 2
   - Actual: Still returns empty AuthorityInfo (change was silently ignored)

4. **Governance Impact:**
   - Create Parliament proposal to change NFT method fee controller
   - Get proposal approved and released
   - Execute proposal → succeeds without error
   - Check controller state → unchanged (governance action wasted)

**Success Condition:** The vulnerability is confirmed when `ChangeMethodFeeController()` returns success but subsequent `GetMethodFeeController()` calls show no state change, and the state variable does not exist in the contract state definition. [3](#0-2)

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** protobuf/nft_contract.proto (L20-20)
```text
    option (aelf.base) = "acs1.proto";
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L6-46)
```csharp
public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationState.cs (L10-10)
```csharp
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** protobuf/authority_info.proto (L5-10)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L23-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L41-45)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        RequiredMethodFeeControllerSet();
        return State.MethodFeeController.Value;
    }
```
