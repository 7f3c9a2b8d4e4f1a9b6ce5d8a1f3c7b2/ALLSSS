### Title
Unbounded Miner Distribution in Cross-Chain Updates Causes ExecutionCallThreshold DoS

### Summary
The `UpdateInformationFromCrossChain()` function unconditionally distributes resource tokens to all main chain miners without validating the miner list size against execution limits. When the main chain has a sufficiently large miner count (approximately 94+ miners with 8 resource tokens), the resulting token transfer operations exceed AElf's ExecutionCallThreshold of 15,000, causing transaction failure and blocking side chain cross-chain consensus synchronization.

### Finding Description

The vulnerability exists in the cross-chain consensus update flow. When a side chain indexes parent chain blocks, it calls `UpdateInformationFromCrossChain()` which unconditionally invokes `DistributeResourceTokensToPreviousMiners()`. [1](#0-0) 

The `DistributeResourceTokensToPreviousMiners()` function performs a nested loop: for each resource token symbol (PayTxFeeSymbolList ∪ PayRentalSymbolList, typically 8 tokens), it iterates through all miners in `State.MainChainCurrentMinerList` and executes a token transfer. [2](#0-1) 

**Root Cause**: No bounds checking exists on the miner list size. The operation count is N_miners × N_tokens × operations_per_transfer. With typical configurations showing 8 resource tokens (4 from PayTxFeeSymbolList + 4 from PayRentalSymbolList), and each transfer involving approximately 15-20 method calls, the threshold is exceeded at roughly 94 miners. [3](#0-2) 

**Why Protections Fail**: 
1. The main chain's MaximumMinersCount defaults to int.MaxValue with no upper bound validation for side chain compatibility. [4](#0-3) 

2. Governance can set arbitrary MaximumMinersCount values without constraints. [5](#0-4) 

3. AElf enforces a hardcoded ExecutionCallThreshold of 15,000 method calls per transaction, throwing RuntimeCallThresholdExceededException when exceeded. [6](#0-5) [7](#0-6) 

**Execution Path**: The cross-chain indexing flow is:
`ReleaseCrossChainIndexingProposal` → `RecordCrossChainData` → `IndexParentChainBlockData` → `UpdateConsensusInformation` → `UpdateInformationFromCrossChain` → `DistributeResourceTokensToPreviousMiners` [8](#0-7) [9](#0-8) [10](#0-9) 

### Impact Explanation

**Critical Operational DoS**: Side chains lose the ability to synchronize consensus information from the parent chain, breaking cross-chain functionality entirely.

**Affected Parties**: All side chains connected to a main chain with elevated miner counts. The side chain miners who attempt to execute `ReleaseCrossChainIndexingProposal` bear the transaction fee cost for failed attempts.

**Quantified Harm**: 
- With 94+ main chain miners and 8 resource tokens: ~750+ token transfers
- Estimated 15,000+ method calls (exceeding threshold)
- Transaction fails with ExecutionStatus.SystemError
- Cross-chain indexing becomes permanently blocked
- Side chain cannot update its miner list from the parent chain

**Severity Justification**: HIGH - This is a complete denial of service of required cross-chain functionality. Side chains depend on parent chain consensus updates for security and proper miner rotation. Without this synchronization, side chain consensus integrity is compromised.

### Likelihood Explanation

**Attacker Capabilities**: Requires main chain governance control to set MaximumMinersCount to high values, OR exploitation of natural growth scenarios where main chain legitimately has many miners.

**Attack Complexity**: LOW
- Single governance action: call SetMaximumMinersCount with value ≥ 94
- Or wait for organic miner growth through auto-increase mechanism
- Side chain cross-chain indexing triggers vulnerability automatically

**Feasibility Conditions**:
1. Main chain governance can modify MaximumMinersCount through parliament proposal (standard operation)
2. No validation exists preventing unreasonably high miner counts for side chain operations
3. Auto-increase mechanism starts at 17 miners and grows by 2 per interval, so organic growth to 94+ is theoretically possible over time [11](#0-10) 

**Detection/Prevention**: No on-chain detection or prevention mechanism exists. The failure occurs during normal cross-chain indexing operations.

**Probability Assessment**: MEDIUM-HIGH
- Malicious scenario: Governance compromise leads to intentional DoS
- Accidental scenario: Misconfiguration or lack of awareness about side chain constraints
- Organic scenario: Natural miner count growth over years could trigger this

### Recommendation

**Immediate Mitigation**: Add miner count validation in `UpdateInformationFromCrossChain()` before calling `DistributeResourceTokensToPreviousMiners()`:

```csharp
// In UpdateInformationFromCrossChain, before line 53
const int MaxSafeMinerCountForDistribution = 50; // Safe threshold considering 8 tokens × 50 miners × 20 calls = 8000 < 15000
var minerCount = State.MainChainCurrentMinerList.Value?.Pubkeys.Count ?? 0;
if (minerCount <= MaxSafeMinerCountForDistribution)
{
    DistributeResourceTokensToPreviousMiners();
}
```

**Long-term Solutions**:
1. Implement batched distribution: distribute to miners in chunks across multiple blocks
2. Implement lazy distribution: track distribution state and allow miners to claim their share
3. Add configuration for MaximumMainChainMinersForSideChain enforced at side chain level
4. Consider alternative distribution mechanisms that don't scale with miner count

**Invariant to Enforce**: 
`minerCount × resourceTokenCount × estimatedCallsPerTransfer < ExecutionCallThreshold * safetyMargin`

**Test Cases**:
1. Test UpdateInformationFromCrossChain with 94+ miners and verify it doesn't exceed threshold
2. Test that distribution is skipped or batched when miner count is too high
3. Test that cross-chain indexing continues to function even when distribution is deferred

### Proof of Concept

**Initial State**:
1. Side chain is initialized and connected to main chain
2. Main chain has standard configuration with 17 initial miners

**Attack Sequence**:
1. Main chain governance creates parliament proposal to call `SetMaximumMinersCount(100)`
2. Parliament approves and releases proposal
3. Main chain holds election and achieves 100 active miners in current round
4. Main chain updates round with 100 miners in RealTimeMinersInformation
5. Side chain miner calls `ProposeCrossChainIndexing` with parent chain block data containing consensus extra data
6. Side chain miner calls `ReleaseCrossChainIndexingProposal` to execute indexing
7. CrossChainContract.RecordCrossChainData → IndexParentChainBlockData executes
8. UpdateConsensusInformation calls UpdateInformationFromCrossChain via SendInline
9. DistributeResourceTokensToPreviousMiners attempts: 100 miners × 8 tokens = 800 transfers
10. Each transfer involves GetBalance + Transfer.Send (internally: balance updates, event emission, ~20 method calls)
11. Total method calls: 800 × 20 = 16,000 calls
12. ExecutionObserver.CallCount() reaches 15,000 and throws RuntimeCallThresholdExceededException
13. Transaction trace shows ExecutionStatus.SystemError with error "Contract call threshold 15000 exceeded"
14. ReleaseCrossChainIndexingProposal transaction fails
15. Side chain cannot update main chain consensus information
16. All subsequent attempts to index parent chain blocks with consensus data fail

**Expected Result**: Transaction succeeds and side chain updates consensus information

**Actual Result**: Transaction fails with "Contract call threshold 15000 exceeded", permanently blocking cross-chain consensus synchronization for side chains

**Success Condition for Exploit**: Side chain cross-chain indexing fails consistently when main chain miner count exceeds threshold (~94 miners), demonstrating complete DoS of cross-chain consensus updates.

---

**Notes**

This vulnerability represents a critical architectural flaw where unbounded iteration over an externally-controlled list (main chain miners) creates a DoS vector against side chain operations. The issue is exacerbated by the lack of communication between the main chain's miner count governance and side chain execution constraints. While current deployments may use low miner counts (5-17 as seen in tests), the system design allows arbitrary scaling that breaks side chain functionality.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L32-64)
```csharp
    public override Empty UpdateInformationFromCrossChain(BytesValue input)
    {
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();

        Context.LogDebug(() =>
            $"Shared miner list of round {consensusInformation.Round.RoundNumber}:" +
            $"{consensusInformation.Round.ToString("M")}");

        DistributeResourceTokensToPreviousMiners();

        State.MainChainRoundNumber.Value = consensusInformation.Round.RoundNumber;

        var minersKeys = consensusInformation.Round.RealTimeMinersInformation.Keys;
        State.MainChainCurrentMinerList.Value = new MinerList
        {
            Pubkeys = { minersKeys.Select(k => ByteStringHelper.FromHexString(k)) }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** test/AElf.Contracts.MultiTokenCrossChainTransfer.Tests/MultiTokenContractCrossChainTestAElfModule.cs (L62-63)
```csharp
            options.ContextVariables["SymbolListToPayTxFee"] = "WRITE,READ,STORAGE,TRAFFIC,";
            options.ContextVariables["SymbolListToPayRental"] = "CPU,RAM,DISK,NET";
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L88-95)
```csharp
    private int GetAutoIncreasedMinersCount()
    {
        if (State.BlockchainStartTimestamp.Value == null) return AEDPoSContractConstants.SupposedMinersCount;

        return AEDPoSContractConstants.SupposedMinersCount.Add(
            (int)(Context.CurrentBlockTime - State.BlockchainStartTimestamp.Value).Seconds
            .Div(State.MinerIncreaseInterval.Value).Mul(2));
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L21-27)
```csharp
    public void CallCount()
    {
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");

        _callCount++;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L293-302)
```csharp
    public override Empty ReleaseCrossChainIndexingProposal(ReleaseCrossChainIndexingProposalInput input)
    {
        Context.LogDebug(() => "Releasing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        Assert(input.ChainIdList.Count > 0, "Empty input not allowed.");
        ReleaseIndexingProposal(input.ChainIdList);
        RecordCrossChainData(input.ChainIdList);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L227-234)
```csharp
    private void UpdateConsensusInformation(ByteString bytes)
    {
        SetContractStateRequired(State.CrossChainInteractionContract,
            SmartContractConstants.ConsensusContractSystemName);
        Context.SendInline(State.CrossChainInteractionContract.Value,
            nameof(State.CrossChainInteractionContract.UpdateInformationFromCrossChain),
            new BytesValue { Value = bytes });
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L783-788)
```csharp
            if (i == parentChainBlockData.Count - 1 &&
                blockInfo.ExtraData.TryGetValue(ConsensusExtraDataName, out var bytes))
            {
                Context.LogDebug(() => "Updating consensus information..");
                UpdateConsensusInformation(bytes);
            }
```
