### Title
Evil Miners Can Continue Operating When Valid Replacement Candidates Exist Due to Incomplete Alternative Candidate Search

### Summary
The `GetMinerReplacementInformation()` function only searches for alternative candidates in the previous term's election snapshot, ignoring currently valid candidates with active votes. When the previous snapshot is null (e.g., during term 1) or has an empty `ElectionResult`, evil miners continue operating even when legitimate voted candidates are available in the current term, violating consensus security.

### Finding Description

The vulnerability exists in the `GetMinerReplacementInformation()` function [1](#0-0) 

**Root Cause:**
The function retrieves the previous term's snapshot [2](#0-1)  and only populates `alternativeCandidates` if that snapshot is non-null and contains election results [3](#0-2) . When this condition fails, the function falls back to initial miners only [4](#0-3) , completely ignoring candidates who have announced election and received votes in the current term.

**Why Protections Fail:**
The function never queries current valid candidates through `State.Candidates` or `State.CandidateVotes`, which track candidates with active votes in the current term [5](#0-4) . The `GetValidCandidates()` helper function exists and correctly retrieves current candidates with active votes, but is never called by `GetMinerReplacementInformation()`.

**Execution Path:**
1. Consensus contract calls `GetMinerReplacementInformation()` during round generation when on main chain and within same term [6](#0-5) 
2. If alternative candidates are found, evil miners are replaced [7](#0-6) 
3. If no alternatives returned (empty list), evil miners remain in the miner list and continue operating

### Impact Explanation

**Consensus Integrity Violation:**
Evil miners who should be replaced continue to participate in block production, potentially:
- Censoring transactions
- Withholding blocks
- Earning block rewards they don't deserve
- Undermining network security and decentralization

**Most Critical Scenarios:**
1. **Term 1 (Chain Bootstrap):** No term 0 snapshot exists [8](#0-7) . If an initial miner becomes evil in term 1 and new candidates have announced and received votes, those candidates are ignored.

2. **After Empty Terms:** Following any term where no candidates participated, the snapshot's `ElectionResult` will be empty [9](#0-8) , causing the same issue.

3. **Insufficient Initial Miner Pool:** If available non-banned initial miners are fewer than evil miners needing replacement, gaps cannot be filled even when voted candidates exist.

**Affected Parties:**
- Network validators and honest miners (security compromised)
- Token holders who voted for candidates (votes ignored, candidates not given deserved positions)
- End users (network reliability and security degraded)

### Likelihood Explanation

**Attacker Capabilities:**
An attacker only needs to:
1. Become a miner (initially legitimate)
2. Commit malicious behavior triggering evil node detection [10](#0-9) 
3. Exploit the timing when previous snapshot is null/empty

**Feasibility Conditions:**
- **Term 1 scenario:** Guaranteed to occur during blockchain bootstrap
- **Post-empty-term scenario:** Can occur naturally if a term has no candidate participation
- **Current valid candidates exist:** Candidates can announce at any time [11](#0-10)  and receive votes during the current term

**Attack Complexity:** 
Low. The vulnerability is triggered by natural consensus operations, requiring no special manipulation beyond becoming evil at an opportune time.

**Detection Constraints:**
The system logs when no alternative miners are found, but doesn't distinguish between "no candidates exist" vs "candidates exist but were ignored due to missing snapshot."

**Probability:**
HIGH for term 1 and early chain lifecycle. MEDIUM for mature chains if terms with no candidates occur. The severity is amplified because the vulnerability is most likely during the vulnerable early stages of the blockchain.

### Recommendation

**Immediate Fix:**
Modify `GetMinerReplacementInformation()` to also check current valid candidates when the previous snapshot is unavailable or empty:

```csharp
// After checking latestSnapshot (line 365-380), add:
if (alternativeCandidates.Count < evilMinersPubKeys.Count)
{
    // Check current valid candidates
    var currentValidCandidates = GetValidCandidates()
        .Where(c => !State.InitialMiners.Value.Value.Contains(
            ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(c))))
        .Where(c => !input.CurrentMinerList.Contains(c))
        .Where(c => !alternativeCandidates.Contains(c))
        .OrderByDescending(c => State.CandidateVotes[c].ObtainedActiveVotedVotesAmount)
        .Take(evilMinersPubKeys.Count - alternativeCandidates.Count);
    
    alternativeCandidates.AddRange(currentValidCandidates);
}
```

**Invariant to Enforce:**
"If valid voted candidates exist (via `GetValidCandidates()`), they must be considered as replacement alternatives before falling back to initial miners only."

**Test Cases:**
1. Test evil miner replacement in term 1 with candidates who announced and received votes
2. Test replacement after a term with empty election results but current term has valid candidates
3. Test that current candidates are prioritized by vote weight
4. Verify candidates are not duplicated between snapshot-based and current-based selections

### Proof of Concept

**Initial State:**
- Blockchain in term 1 (no term 0 snapshot exists)
- Initial miners: [InitMiner1, InitMiner2, InitMiner3]
- Candidate Alice announces election and receives 10,000 votes
- Candidate Bob announces election and receives 8,000 votes

**Attack Sequence:**
1. InitMiner1 commits malicious behavior (e.g., persistent block production failure)
2. Consensus contract detects evil behavior and sets `State.BannedPubkeyMap[InitMiner1] = true` [12](#0-11) 
3. During next round generation, `GetMinerReplacementInformation()` is called [13](#0-12) 
4. Function identifies InitMiner1 as evil [14](#0-13) 
5. `GetPreviousTermSnapshotWithNewestPubkey()` returns null (no term 0) [2](#0-1) 
6. Condition at line 365 fails, `alternativeCandidates` remains empty
7. Function attempts to fill from initial miners, but InitMiner2 and InitMiner3 are already in current miner list [15](#0-14) 
8. Function returns `EvilMinerPubkeys: [InitMiner1], AlternativeCandidatePubkeys: []`
9. Consensus contract sees empty alternatives [16](#0-15) , performs no replacement
10. InitMiner1 continues as miner despite being evil

**Expected Result:**
InitMiner1 should be replaced by Alice (highest votes) or Bob.

**Actual Result:**
InitMiner1 continues operating as evil miner. Alice and Bob, despite having community votes and being eligible, are never considered as replacements.

**Success Condition:**
Evil miner remains in active miner list for subsequent rounds despite valid voted alternatives existing in current term state.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L86-95)
```csharp
    private List<string> GetValidCandidates()
    {
        if (State.Candidates.Value == null) return new List<string>();

        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L132-133)
```csharp
        var termNumber = State.CurrentTermNumber.Value.Sub(1);
        var snapshot = State.Snapshots[termNumber];
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-307)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
        {
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L309-342)
```csharp
            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }

                isMinerListChanged = true;
            }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-112)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
            var rankingList = State.DataCentersRankingList.Value;
            if (rankingList.DataCenters.ContainsKey(input.Pubkey))
            {
                rankingList.DataCenters[input.Pubkey] = 0;
                UpdateDataCenterAfterMemberVoteAmountChanged(rankingList, input.Pubkey, true);
                State.DataCentersRankingList.Value = rankingList;
            }

            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L459-478)
```csharp
    private void SavePreviousTermInformation(TakeElectionSnapshotInput input)
    {
        var snapshot = new TermSnapshot
        {
            MinedBlocks = input.MinedBlocks,
            EndRoundNumber = input.RoundNumber
        };

        if (State.Candidates.Value == null) return;

        foreach (var pubkey in State.Candidates.Value.Value)
        {
            var votes = State.CandidateVotes[pubkey.ToHex()];
            var validObtainedVotesAmount = 0L;
            if (votes != null) validObtainedVotesAmount = votes.ObtainedActiveVotedVotesAmount;

            snapshot.ElectionResult.Add(pubkey.ToHex(), validObtainedVotesAmount);
        }

        State.Snapshots[input.TermNumber] = snapshot;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```
