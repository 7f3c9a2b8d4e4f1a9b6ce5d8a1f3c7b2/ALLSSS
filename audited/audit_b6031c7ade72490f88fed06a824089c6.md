### Title
Missing Miner List Validation in NextTerm Allows Consensus Takeover

### Summary
The `ValidationForNextTerm()` function only validates that term and round numbers increment by 1, but does not verify that the proposed miner list matches the election contract's `GetVictories()` results. A malicious current miner can exploit this by crafting a `NextTerm` transaction with an arbitrary miner list (e.g., only themselves), bypassing democratic election and achieving complete consensus control.

### Finding Description

**Root Cause:**
The validation for `NextTerm` behavior is incomplete. [1](#0-0) 

This validation only checks:
1. Round number increments by 1 (via `ValidationForNextRound`)
2. Term number increments by 1

**Why Protections Fail:**

The validation orchestration for `NextTerm` only adds `RoundTerminateValidationProvider`: [2](#0-1) 

No validator checks the proposed miner list against election contract results.

During execution, `ProcessNextTerm` blindly accepts the miner list from the input: [3](#0-2) 

The `SetMinerList` function has no validation logic—it only checks if the term was previously set: [4](#0-3) 

**Expected Behavior:**
Legitimate term transitions call `GenerateFirstRoundOfNextTerm` which obtains the miner list from the election contract: [5](#0-4) 

The `TryToGetVictories` method queries the election contract: [6](#0-5) 

However, validation never verifies that the miner list in the `NextTerm` transaction matches these election results.

**Exploitation Path:**
The `NextTerm` method is publicly callable and only requires basic permission checks: [7](#0-6) 

The permission check only verifies the sender is in the current or previous miner list, not that the proposed new list is valid: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- **Complete Consensus Takeover**: Attacker gains exclusive control of all future block production by setting themselves as the only miner
- **Governance Bypass**: Democratic election results are completely ignored, violating the core governance invariant
- **Censorship Power**: Attacker can censor any transactions indefinitely
- **Double-Spend Capability**: With exclusive block production, attacker can execute chain reorganizations
- **Chain Halt**: Attacker can stop block production entirely
- **Irreversible Damage**: Once the fraudulent miner list is set for a term, it persists until the next term transition

**Affected Parties:**
- All token holders lose governance rights
- Elected validators are excluded despite winning elections
- All users lose transaction processing guarantees
- Protocol integrity is fundamentally compromised

**Severity Justification:**
This is HIGH severity because it completely breaks the consensus and governance model, allowing a single malicious actor to seize permanent control of the blockchain.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must be in the current miner list (realistic—they were elected in previous term)
- Must control block production during term transition window (realistic—miners produce blocks in their time slots)
- No special privileges or compromised keys needed beyond being a current miner

**Attack Complexity:**
Low complexity. Attacker simply:
1. Monitors blockchain for term transition time
2. Creates malicious `NextTermInput` with:
   - `TermNumber = current + 1`
   - `RoundNumber = current + 1` 
   - `RealTimeMinersInformation` = attacker's chosen list
   - All `InValue` fields = null
3. Submits `NextTerm` transaction during their time slot

**Feasibility Conditions:**
- Term transition occurs periodically (every period duration)
- Attacker only needs one successful block during transition window
- No economic cost beyond normal transaction fees
- Detection may only occur after the fraudulent term is already active

**Probability Assessment:**
HIGH. Any malicious miner can execute this attack during every term transition. The attack is deterministic and requires no coordination or timing luck beyond producing a block in their assigned time slot.

### Recommendation

**Code-Level Mitigation:**

Add miner list validation to `ValidationForNextTerm` in `RoundTerminateValidationProvider.cs`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Verify term number increments by 1
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Verify miner list matches election contract results
    var expectedVictories = State.ElectionContract.GetVictories.Call(new Empty());
    var proposedMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
    var expectedMiners = expectedVictories.Value.Select(p => p.ToHex()).OrderBy(k => k).ToList();
    
    if (proposedMiners.Count != expectedMiners.Count || 
        !proposedMiners.SequenceEqual(expectedMiners))
        return new ValidationResult { Message = "Proposed miner list does not match election results." };

    return new ValidationResult { Success = true };
}
```

**Invariant to Enforce:**
For every `NextTerm` transition, the miner list in `Round.RealTimeMinersInformation` MUST exactly match the result of `ElectionContract.GetVictories()` at the time of validation.

**Test Cases:**
1. Test that `NextTerm` with correct miner list (matching `GetVictories`) passes validation
2. Test that `NextTerm` with modified miner list (one miner added/removed) fails validation
3. Test that `NextTerm` with completely arbitrary miner list fails validation
4. Test that validation rejects attempts to exclude elected miners
5. Test that validation rejects attempts to add non-elected miners

### Proof of Concept

**Initial State:**
- Current term: T
- Current miner list: [Miner_A, Miner_B, Miner_C, Miner_D, Miner_E]
- Election results for next term: [Miner_B, Miner_C, Miner_D, Miner_E, Miner_F] (Miner_A lost, Miner_F won)
- Miner_A is the attacker

**Attack Steps:**

1. **Wait for term transition time**: Monitor blockchain until current term T is about to end

2. **Craft malicious NextTermInput**:
   - `TermNumber = T + 1`
   - `RoundNumber = current_round + 1`
   - `RealTimeMinersInformation = { "Miner_A": {...} }` (only attacker)
   - All `InValue = null`
   - Other fields set appropriately

3. **Submit during attacker's time slot**: Call `NextTerm(maliciousInput)` during Miner_A's assigned time slot

4. **Validation passes**:
   - `RoundTerminateValidationProvider` checks: term T+1 ✓, round increments ✓
   - `MiningPermissionValidationProvider` checks: Miner_A in current list ✓
   - No check for miner list validity ✗

5. **Execution completes**: `ProcessNextTerm` stores fraudulent miner list in state

**Expected vs Actual Result:**
- **Expected**: Term T+1 should have miner list [Miner_B, Miner_C, Miner_D, Miner_E, Miner_F] from election
- **Actual**: Term T+1 has miner list [Miner_A] from attacker's input

**Success Condition:**
Query `GetMinerList({TermNumber: T+1})` returns only Miner_A, confirming the attacker now exclusively controls consensus.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```
