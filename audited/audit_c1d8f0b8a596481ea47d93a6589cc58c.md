# Audit Report

## Title
Missing Timestamp Validation in Round Time Slot Checking Allows Consensus DoS

## Summary
The `CheckRoundTimeSlots` validation method in the AEDPoS consensus contract fails to verify that `ExpectedMiningTime` values are reasonable relative to the current block time. A malicious miner can exploit this by submitting a `NextRound` transaction with distant future timestamps that pass all validation checks, resulting in complete consensus halt as no miner can satisfy the time slot requirements for subsequent block production.

## Finding Description

The vulnerability exists in the round time slot validation logic. The `CheckRoundTimeSlots` method only validates structural properties of timestamps: [1](#0-0) 

This validation checks three conditions:
1. ExpectedMiningTime is not null (line 40-41)
2. Mining interval is greater than zero (line 46-47)
3. Intervals between consecutive miners are roughly equal (lines 49-55)

**Critical Gap:** No validation ensures timestamps are reasonable relative to `Context.CurrentBlockTime`.

An attacker can craft a `NextRoundInput` where all `ExpectedMiningTime` values are set to a distant future (e.g., January 1, 3000) with proper 4000ms intervals. This malicious input passes all existing validation checks but renders the consensus inoperable.

**Attack Flow:**

1. Attacker (who is an elected miner) calls the public `NextRound` method: [2](#0-1) 

2. The `PreCheck` validates only miner list membership: [3](#0-2) 

3. The validation pipeline calls `CheckRoundTimeSlots` via `TimeSlotValidationProvider`: [4](#0-3) 

4. Validation passes because timestamps are not null, intervals are positive and equal. The malicious round is then stored to state: [5](#0-4) 

5. Subsequent mining attempts fail because `IsCurrentMiner` checks if current time falls within the mining time slot: [6](#0-5) 

When `ExpectedMiningTime` is in the distant future (year 3000) and `Context.CurrentBlockTime` is current (year 2024), the condition at lines 162-163 is always false, blocking all miners.

**Input Structure:** The attacker directly controls timestamp values through the protobuf message structure: [7](#0-6) [8](#0-7) 

**Contrast with Legitimate Generation:** Proper round generation calculates timestamps relative to current block time: [9](#0-8) 

However, the `NextRound` method accepts raw `NextRoundInput` which bypasses this legitimate calculation: [10](#0-9) 

## Impact Explanation

**Severity: HIGH - Complete Consensus DoS**

Once the malicious round is stored to state, the blockchain enters an unrecoverable halt:

1. **No Block Production:** All miners fail the `IsCurrentMiner` check because their `ExpectedMiningTime` is in the distant future, while `Context.CurrentBlockTime` remains in the present
2. **Transaction Processing Stops:** No new transactions can be processed
3. **Network-Wide Impact:** All validators and users are affected simultaneously
4. **Recovery Difficulty:** Requires manual intervention, likely a hard fork or chain rollback to a state before the malicious round

This breaks the fundamental consensus guarantee that the network can continue producing blocks as long as Byzantine miners are below the threshold. A single malicious miner can completely halt the chain.

## Likelihood Explanation

**Probability: MEDIUM**

**Preconditions:**
- Attacker must be an elected miner (checked by `PreCheck` - typically 21-100 nodes in a DPoS system)
- This is a realistic threat model - any validator could be compromised or turn malicious

**Attack Complexity:** 
- **Low** - Attacker simply needs to craft a `NextRoundInput` message with modified timestamps while maintaining valid intervals
- No cryptographic operations or complex exploitation required
- Single transaction execution

**Detection:**
- **None** - The attack succeeds silently during validation
- No timestamp bound checks exist in the validation pipeline

The combination of realistic preconditions (compromised validator), trivial execution, and catastrophic impact justifies a MEDIUM likelihood assessment.

## Recommendation

Add timestamp reasonableness validation to `CheckRoundTimeSlots`:

```csharp
public ValidationResult CheckRoundTimeSlots(Timestamp currentBlockTime)
{
    var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
    if (miners.Count == 1)
        return new ValidationResult { Success = true };

    if (miners.Any(m => m.ExpectedMiningTime == null))
        return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

    // NEW: Validate first miner's timestamp is reasonable relative to current time
    var firstMinerTime = miners[0].ExpectedMiningTime;
    var maxFutureOffset = new Duration { Seconds = 300 }; // 5 minutes tolerance
    if (firstMinerTime < currentBlockTime || 
        firstMinerTime > currentBlockTime + maxFutureOffset)
    {
        return new ValidationResult { 
            Message = $"ExpectedMiningTime out of acceptable range relative to current block time.\n{this}" 
        };
    }

    var baseMiningInterval = (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();
    
    if (baseMiningInterval <= 0)
        return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

    for (var i = 1; i < miners.Count - 1; i++)
    {
        var miningInterval = (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
        if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
            return new ValidationResult { Message = "Time slots are so different." };
    }

    return new ValidationResult { Success = true };
}
```

Update the call site in `TimeSlotValidationProvider` to pass `Context.CurrentBlockTime`:

```csharp
validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots(validationContext.CurrentBlockTime);
```

## Proof of Concept

```csharp
[Fact]
public async Task NextRound_WithDistantFutureTimestamps_ShouldCauseConsensusHalt()
{
    // Setup: Bootstrap initial round with normal miners
    var initialMiners = await BootstrapAndGetMiners();
    var currentRound = await GetCurrentRound();
    
    // Attack: Craft NextRoundInput with timestamps set to year 3000
    var distantFuture = Timestamp.FromDateTime(new DateTime(3000, 1, 1, 0, 0, 0, DateTimeKind.Utc));
    var maliciousNextRound = new NextRoundInput
    {
        RoundNumber = currentRound.RoundNumber + 1,
        TermNumber = currentRound.TermNumber,
    };
    
    // Add miners with distant future timestamps but valid 4000ms intervals
    int order = 1;
    foreach (var miner in currentRound.RealTimeMinersInformation.Keys)
    {
        maliciousNextRound.RealTimeMinersInformation.Add(miner, new MinerInRound
        {
            Pubkey = miner,
            Order = order,
            ExpectedMiningTime = distantFuture.AddMilliseconds(4000 * order), // Valid intervals
            IsExtraBlockProducer = order == 1
        });
        order++;
    }
    
    // Execute attack from first miner's account
    var attackerKeyPair = InitialCoreDataCenterKeyPairs[0];
    var result = await AEDPoSContractStub.NextRound.SendWithExceptionAsync(maliciousNextRound);
    
    // Verify attack succeeds (no validation error)
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify consensus is now broken - no miner can produce blocks
    foreach (var minerKeyPair in InitialCoreDataCenterKeyPairs)
    {
        var isCurrentMiner = await GetConsensusContractTester(minerKeyPair)
            .IsCurrentMiner.CallAsync(Address.FromPublicKey(minerKeyPair.PublicKey));
        
        // All miners should fail the time slot check
        isCurrentMiner.Value.ShouldBeFalse();
    }
    
    // Consensus is now halted - no blocks can be produced
}
```

**Notes:**
- The vulnerability exists because timestamp validation only checks structural properties (null, intervals) but not temporal reasonableness
- The attack requires the attacker to be an elected miner, which is within the Byzantine threat model for consensus systems
- Recovery requires manual intervention as the chain cannot self-heal from this state
- The fix should validate timestamps are within a reasonable offset from current block time during round transition validation

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-58)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

        var baseMiningInterval =
            (miners[1].ExpectedMiningTime - miners[0].ExpectedMiningTime).Milliseconds();

        if (baseMiningInterval <= 0)
            return new ValidationResult { Message = $"Mining interval must greater than 0.\n{this}" };

        for (var i = 1; i < miners.Count - 1; i++)
        {
            var miningInterval =
                (miners[i + 1].ExpectedMiningTime - miners[i].ExpectedMiningTime).Milliseconds();
            if (Math.Abs(miningInterval - baseMiningInterval) > baseMiningInterval)
                return new ValidationResult { Message = "Time slots are so different." };
        }

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L136-167)
```csharp
    private bool IsCurrentMiner(string pubkey)
    {
        if (pubkey == null) return false;

        if (!TryToGetCurrentRoundInformation(out var currentRound)) return false;

        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;

        Context.LogDebug(() =>
            $"Extra block producer of previous round: {currentRound.ExtraBlockProducerOfPreviousRound}");

        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }

        var miningInterval = currentRound.GetMiningInterval();
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;

        // Check normal time slot.
        if (timeSlotStartTime <= Context.CurrentBlockTime && Context.CurrentBlockTime <=
            timeSlotStartTime.AddMilliseconds(miningInterval))
        {
            Context.LogDebug(() => "[CURRENT MINER]NORMAL");
            return true;
        }
```

**File:** protobuf/aedpos_contract.proto (L266-301)
```text
message MinerInRound {
    // The order of the miner producing block.
    int32 order = 1;
    // Is extra block producer in the current round.
    bool is_extra_block_producer = 2;
    // Generated by secret sharing and used for validation between miner.
    aelf.Hash in_value = 3;
    // Calculated from current in value.
    aelf.Hash out_value = 4;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 5;
    // The expected mining time.
    google.protobuf.Timestamp expected_mining_time = 6;
    // The amount of produced blocks.
    int64 produced_blocks = 7;
    // The amount of missed time slots.
    int64 missed_time_slots = 8;
    // The public key of this miner.
    string pubkey = 9;
    // The InValue of the previous round.
    aelf.Hash previous_in_value = 10;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 11;
    // The final order of mining for the next round.
    int32 final_order_of_next_round = 12;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    repeated google.protobuf.Timestamp actual_mining_times = 13;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 14;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 15;
    // The amount of produced tiny blocks.
    int64 produced_tiny_blocks = 16;
    // The irreversible block height that current miner recorded.
    int64 implied_irreversible_block_height = 17;
}
```

**File:** protobuf/aedpos_contract.proto (L458-475)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```
