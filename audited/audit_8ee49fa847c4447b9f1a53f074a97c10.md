Based on my thorough code analysis, I have validated this security claim and confirmed it is a **VALID VULNERABILITY**.

---

# Audit Report

## Title
Inconsistent LIB Fields in NextTerm Allow Manipulation of Mining Restrictions

## Summary
The NextTerm consensus transaction flow lacks validation for consistency between `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` fields. An authorized miner can provide inconsistent values during term transitions that pass all validation checks, are stored in consensus state, and subsequently manipulate the mining restriction logic to either bypass safety throttling or trigger unwarranted consensus DoS.

## Finding Description

The vulnerability exists because NextTerm accepts arbitrary LIB field values without validating their consistency, despite these fields being used independently for critical consensus decisions.

**Validation Gap:** The `NextTerm` method is public and accepts `NextTermInput` from authorized miners. [1](#0-0) 

The `NextTermInput.Create()` method directly copies both LIB fields from the input Round without any consistency validation between them: [2](#0-1) 

For NextTerm behavior, only `RoundTerminateValidationProvider` is added to the validation pipeline, which validates term/round number correctness but NOT the LIB fields: [3](#0-2) 

The `RoundTerminateValidationProvider` only checks that term number increments by 1, not LIB field consistency: [4](#0-3) 

The `LibInformationValidationProvider` (which validates LIB fields don't regress) is ONLY added for UpdateValue behavior, not for NextTerm: [5](#0-4) 

Moreover, even `LibInformationValidationProvider` only checks monotonicity (fields don't go backwards), not consistency between the two fields: [6](#0-5) 

**Hash Validation Bypass:** The `GetCheckableRound()` method used for hash calculation excludes LIB fields, only including RoundNumber, TermNumber, RealTimeMinersInformation, and BlockchainAge: [7](#0-6) 

This means inconsistent LIB values will not be detected by the after-execution hash comparison in `ValidateConsensusAfterExecution`.

**Storage Without Validation:** The `ProcessNextTerm` method stores the round information without additional LIB field validation: [8](#0-7) 

## Impact Explanation

The inconsistent LIB values directly affect the `GetMaximumBlocksCount()` method, which uses both fields for different purposes: [9](#0-8) 

The `ConfirmedIrreversibleBlockRoundNumber` determines the mining status (Normal/Abnormal/Severe) via `BlockchainMiningStatusEvaluator`, while `ConfirmedIrreversibleBlockHeight` is used to calculate distance for event firing. These two fields should correspond to the same irreversible block, but no validation enforces this.

**Attack Scenario 1 - Bypass Safety Restrictions:**
- Attacker sets `ConfirmedIrreversibleBlockRoundNumber` high (close to current round)
- Sets `ConfirmedIrreversibleBlockHeight` low (far behind actual LIB)
- Result: Status calculation shows Normal/Abnormal, allowing full mining capacity (8+ blocks per miner)
- Reality: Chain is far behind on irreversible blocks and should be in Severe status (1 block per miner)
- **Impact**: Undermines consensus safety mechanisms designed to throttle the chain when LIB falls behind, allowing excessive block production during unsafe conditions

**Attack Scenario 2 - Artificial Consensus DoS:**
- Attacker sets `ConfirmedIrreversibleBlockRoundNumber` low (many rounds behind)
- Sets `ConfirmedIrreversibleBlockHeight` high (close to current height)
- Result: Status calculation forces Severe status, restricting all miners to 1 block each
- Reality: Chain is healthy and should operate at normal capacity
- **Impact**: Artificially degrades consensus performance and chain throughput by 8x or more, effectively creating a denial of service

The impact fundamentally breaks consensus integrity by decoupling mining restrictions from actual chain finality state.

## Likelihood Explanation

**Attacker Requirements:**
- Must be an authorized miner in the current or next term's miner list (elected position)
- Must be selected to mine the block performing the NextTerm transition (happens at term boundaries)

**Attack Feasibility:**
- Term transitions occur every few days/weeks in AEDPoS
- With N miners, each has approximately 1/N chance per term transition
- Technical barrier is low: simply craft `NextTermInput` with inconsistent LIB values
- Transaction passes all validation checks (term/round number validation only)
- No automatic detection mechanism exists

**Probability Assessment:** Medium-High for a malicious elected miner
- Regular opportunities at predictable term boundaries
- Multiple miners could independently execute this attack
- Low complexity makes it an attractive attack vector for any malicious miner

## Recommendation

Add LIB field consistency validation for NextTerm behavior. The fix should:

1. **Add LibInformationValidationProvider to NextTerm validation:**
   Modify the validation provider list in `ValidateBeforeExecution` to include `LibInformationValidationProvider` for NextTerm behavior, not just UpdateValue.

2. **Implement consistency validation:**
   Create a new validation provider or extend `LibInformationValidationProvider` to verify that `ConfirmedIrreversibleBlockRoundNumber` and `ConfirmedIrreversibleBlockHeight` correspond to the same block. This could check that the height falls within the expected range for that round number based on the average block production rate.

3. **Include LIB fields in hash calculation:**
   Modify `GetCheckableRound()` to include `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` in the checkable round structure so they're validated in the after-execution hash comparison.

The core fix location would be: [10](#0-9) 

Add the LibInformationValidationProvider to the list for NextTerm, similar to how it's currently only added for UpdateValue.

## Proof of Concept

A malicious miner can exploit this vulnerability by:

1. Waiting for term transition eligibility (being selected to mine the term transition block)
2. Crafting a `NextTermInput` with:
   - `ConfirmedIrreversibleBlockRoundNumber` = currentRound - 1 (appears recent)
   - `ConfirmedIrreversibleBlockHeight` = actualLIBHeight - 1000 (far behind)
3. Submitting a `NextTerm` transaction with this malicious input
4. The transaction passes `RoundTerminateValidationProvider` (only checks term/round numbers)
5. The transaction passes after-execution validation (hash excludes LIB fields)
6. The inconsistent values are stored in state
7. Subsequent `GetMaximumBlocksCount()` calls use the manipulated values, keeping the chain in Normal status when it should be in Severe status, allowing excessive block production during an unsafe state

The vulnerability is directly triggerable by any authorized miner at term boundaries with immediate consensus integrity impact.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-17)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-82)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-46)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L199-206)
```csharp
        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L196-196)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L25-26)
```csharp
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
```
