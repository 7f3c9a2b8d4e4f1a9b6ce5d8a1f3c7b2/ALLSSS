### Title
Arithmetic Underflow in Quadratic Voting Withdrawal Due to Vote/Withdraw Amount Mismatch

### Summary
The Vote contract contains a critical arithmetic mismatch between vote addition and withdrawal for quadratic voting items. When a quadratic vote is cast, only `1` is added to `Results[option]`, but during withdrawal, the full `votingRecord.Amount` (which equals `TicketCost * votesCount`) is subtracted. This causes an arithmetic underflow exception, permanently preventing users from withdrawing their locked tokens and creating a denial-of-service condition for all quadratic voting items.

### Finding Description

**Root Cause:**

In the `Vote()` function, when processing quadratic votes, there is an inconsistency in how amounts are recorded versus how they are added to voting results.

For quadratic voting, the amount is calculated as `TicketCost * currentVotesCount` and stored in the voting record [1](#0-0) , but when `UpdateVotingResult()` is called, it passes `1` instead of the actual amount for quadratic votes [2](#0-1) .

The `UpdateVotingResult()` function then adds this value (which is `1` for quadratic voting) to `Results[option]` [3](#0-2) .

However, in the `Withdraw()` function, the full `votingRecord.Amount` is subtracted from `Results[option]` without any special handling for quadratic voting [4](#0-3) .

**Why Protections Fail:**

The `Withdraw()` function retrieves the voting item but never checks the `IsQuadratic` flag to adjust the withdrawal logic accordingly. The `.Sub()` method is a checked arithmetic operation that throws an `OverflowException` when underflow occurs [5](#0-4) .

### Impact Explanation

**Direct Fund Impact:**
- All tokens locked for quadratic voting become permanently locked and unrecoverable
- Users cannot withdraw their funds, resulting in complete loss of access to locked tokens
- If a quadratic voting item has `TicketCost = 100` and a user votes once, they lock 100 tokens but `Results[option]` only contains `1`, making withdrawal impossible

**Operational Impact:**
- Denial of service on the `Withdraw()` function for ALL quadratic voting items
- Voting results become corrupted as `Results[option]` values don't reflect actual token amounts
- The entire quadratic voting feature is non-functional in practice

**Who is Affected:**
- All users who participate in quadratic voting items
- Vote sponsors who create quadratic voting items
- The protocol's voting mechanism integrity

**Severity Justification:**
HIGH severity due to permanent fund loss and complete feature DoS with no workaround available.

### Likelihood Explanation

**Attacker Capabilities:**
No attack required - this is a fundamental logic bug that triggers during normal operation.

**Attack Complexity:**
Trivial - any user participating in quadratic voting will encounter this issue:
1. Sponsor creates a quadratic voting item with any `TicketCost > 1`
2. User votes normally using the `Vote()` function
3. User attempts to withdraw using the `Withdraw()` function
4. Transaction fails with `OverflowException`

**Feasibility Conditions:**
- Quadratic voting feature must be enabled (`IsQuadratic = true`)
- `TicketCost` must be greater than the number of votes (which is always true for reasonable ticket costs)
- No special permissions or state manipulation required

**Probability:**
100% reproducible on every quadratic voting withdrawal attempt where the arithmetic mismatch occurs.

### Recommendation

**Code-Level Mitigation:**

Modify the `Withdraw()` function to check if the voting item is quadratic and adjust the amount subtracted from `Results[option]` accordingly:

```csharp
// In Withdraw() function, replace line 215-216 with:
var amountToSubtract = votingItem.IsQuadratic ? 1 : votingRecord.Amount;
votingResult.Results[votingRecord.Option] =
    votingResult.Results[votingRecord.Option].Sub(amountToSubtract);
```

**Alternative Fix:**

Modify the `Vote()` function to be consistent by always using the full amount:

```csharp
// In Vote() function, replace line 119 with:
UpdateVotingResult(votingItem, input.Option, amount);
```

Note: The second approach would change the semantics of `Results[option]` for quadratic voting from "number of votes" to "total token amount", so the first approach is recommended to maintain backward compatibility.

**Invariant Checks to Add:**
- Add assertion in `Withdraw()`: `Assert(votingItem.IsQuadratic ? votingResult.Results[votingRecord.Option] >= 1 : votingResult.Results[votingRecord.Option] >= votingRecord.Amount)`

**Test Cases:**
- Add test for quadratic voting withdrawal with `TicketCost > 1`
- Add test for multiple quadratic votes and withdrawals
- Add test verifying `Results[option]` values match expected vote counts for quadratic voting

### Proof of Concept

**Required Initial State:**
- Vote contract deployed and initialized
- Token contract with available tokens for locking
- User account with sufficient token balance

**Transaction Steps:**

1. **Register Quadratic Voting Item:**
   - Sponsor calls `Register()` with:
     - `IsQuadratic = true`
     - `TicketCost = 100`
     - `IsLockToken = true`
     - Valid options and timestamps

2. **User Votes:**
   - User calls `Vote()` with:
     - Valid `VotingItemId`
     - `Option = "OptionA"`
     - This locks 100 tokens
   - **State After Vote:**
     - `votingRecord.Amount = 100` (stored in state)
     - `Results["OptionA"] = 1` (only 1 added, not 100)
     - 100 tokens locked in token contract

3. **User Attempts Withdrawal:**
   - User calls `Withdraw()` with the `VoteId`
   - **Expected Result:** Withdrawal succeeds, 100 tokens unlocked
   - **Actual Result:** Transaction fails with `OverflowException` at line 216 because:
     - `Results["OptionA"] = 1`
     - Attempts to compute `1.Sub(100)`
     - Underflow occurs: `1 - 100 = -99`
     - `.Sub()` throws `OverflowException`

**Success Condition for Exploit:**
The bug is successfully demonstrated when the withdrawal transaction reverts with an overflow/underflow exception, preventing the user from recovering their 100 locked tokens.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L98-103)
```csharp
        else
        {
            var currentVotesCount = State.QuadraticVotesCountMap[input.VoteId].Add(1);
            State.QuadraticVotesCountMap[input.VoteId] = currentVotesCount;
            amount = votingItem.TicketCost.Mul(currentVotesCount);
        }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L119-119)
```csharp
        UpdateVotingResult(votingItem, input.Option, votingItem.IsQuadratic ? 1 : amount);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L169-180)
```csharp
    private void UpdateVotingResult(VotingItem votingItem, string option, long amount)
    {
        // Update VotingResult based on this voting behaviour.
        var votingResultHash = GetVotingResultHash(votingItem.VotingItemId, votingItem.CurrentSnapshotNumber);
        var votingResult = State.VotingResults[votingResultHash];
        if (!votingResult.Results.ContainsKey(option)) votingResult.Results.Add(option, 0);

        var currentVotes = votingResult.Results[option];
        votingResult.Results[option] = currentVotes.Add(amount);
        votingResult.VotersCount = votingResult.VotersCount.Add(1);
        votingResult.VotesAmount = votingResult.VotesAmount.Add(amount);
        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L215-216)
```csharp
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
```

**File:** test/AElf.Sdk.CSharp.Tests/SafeMathTests.cs (L60-61)
```csharp
        Should.Throw<OverflowException>(() => { long.MaxValue.Sub(-5); });
        Should.Throw<OverflowException>(() => { ulong.MinValue.Sub(5); });
```
