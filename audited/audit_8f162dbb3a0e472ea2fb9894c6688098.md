### Title
Missing Bounds Validation on Order Values Allows Mining Schedule Disruption via Malicious Consensus Headers

### Summary
The AEDPoS consensus contract lacks bounds validation on `Order`, `SupposedOrderOfNextRound`, and `FinalOrderOfNextRound` values when processing consensus information from block headers. A malicious miner can inject out-of-range Order values (e.g., 0, negative, or exceeding miner count) through block headers, which will be accepted and propagated into the mining schedule, causing consensus failures and preventing proper round progression.

### Finding Description

The vulnerability exists in the consensus information validation and processing flow:

**Entry Point**: The `GetUpdateValueRound()` function copies Order values without validation: [1](#0-0) [2](#0-1) 

**Root Cause**: During block validation, `RecoverFromUpdateValue()` directly copies `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` from the block header's Round object into the current round state without any bounds checking: [3](#0-2) 

**Missing Validation**: The `UpdateValueValidationProvider` only validates OutValue and PreviousInValue fields, completely ignoring Order-related fields: [4](#0-3) 

**Propagation Path**: During execution, `ProcessUpdateValue()` accepts Order values from the input without validation and stores them in state: [5](#0-4) [6](#0-5) 

**Impact Trigger**: When generating the next round, these invalid Order values are used to set mining schedules: [7](#0-6) [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation**: Invalid Order values break critical mining schedule invariants:

1. **Order = 0**: Sets `ExpectedMiningTime = currentBlockTimestamp` (mining interval × 0), causing immediate time slot conflicts. The `BreakContinuousMining()` function will throw exceptions when searching for miners with `Order == 1`: [9](#0-8) 

2. **Order > minersCount**: The extra block producer selection and continuous mining prevention logic fails when attempting to find miners at specific Order positions: [10](#0-9) 

3. **Duplicate Orders**: Multiple miners with identical Order values get the same `ExpectedMiningTime`, creating ambiguous mining schedules and time slot conflicts.

4. **Mining Time Calculation Errors**: Invalid Order values in `IsCurrentMiner()` cause incorrect time slot validations, potentially allowing unauthorized block production or blocking legitimate miners: [11](#0-10) 

**Severity**: This disrupts the entire consensus mechanism, affecting all miners in the network. Round progression may halt, blocks may fail validation, or the chain could enter an inconsistent state requiring manual intervention.

### Likelihood Explanation

**Attacker Requirements**:
- Must be in the active miner list (requires staking/election to become a block producer)
- Must modify their node software to inject malicious consensus data before signing blocks
- Technical capability to understand consensus protocol internals

**Attack Complexity**: Medium
- The attack vector is straightforward once node code is modified
- Block signatures validate successfully (signature covers the malicious data)
- No runtime detection mechanisms exist
- The attack is repeatable in every block the malicious miner produces

**Feasibility**: High
- The validation pipeline has a clear gap - no validator checks Order bounds
- Block headers are signed by miners who control their content before signing
- The `ValidateBeforeExecution()` flow calls validation providers that skip Order validation: [12](#0-11) 

**Economic Rationality**: An attacker already invested in becoming a miner might execute this to:
- Disrupt competitors during critical operations
- Manipulate consensus timing for front-running opportunities
- Force chain halt requiring governance intervention

### Recommendation

**Immediate Fix**: Add bounds validation in multiple layers:

1. **In `RecoverFromUpdateValue()`**: Validate all Order fields before copying:
```csharp
// After line 23, add validation:
foreach (var information in providedRound.RealTimeMinersInformation)
{
    var supposedOrder = information.Value.SupposedOrderOfNextRound;
    var finalOrder = information.Value.FinalOrderOfNextRound;
    
    Assert(supposedOrder >= 1 && supposedOrder <= minersCount, 
           $"SupposedOrderOfNextRound {supposedOrder} out of valid range [1, {minersCount}]");
    Assert(finalOrder >= 0 && finalOrder <= minersCount, 
           $"FinalOrderOfNextRound {finalOrder} out of valid range [0, {minersCount}]");
    
    // Existing copy logic
}
```

2. **In `UpdateValueValidationProvider`**: Add Order validation to the validation provider: [13](#0-12) 

3. **In `ProcessUpdateValue()`**: Add defensive checks before storing: [14](#0-13) 

**Test Cases**:
- Attempt to submit UpdateValue with SupposedOrderOfNextRound = 0
- Attempt to submit UpdateValue with SupposedOrderOfNextRound = minersCount + 1
- Attempt to submit UpdateValue with negative Order values
- Verify that GenerateNextRoundInformation handles edge cases gracefully

### Proof of Concept

**Initial State**:
- Network has 5 active miners
- Attacker is miner #3 with valid block production rights
- Current round is progressing normally

**Attack Steps**:

1. **Malicious Miner Modification**: Attacker modifies their node's `GetConsensusExtraDataToPublishOutValue()` to inject invalid data: [15](#0-14) 

2. **Inject Invalid Order**: Instead of calling `ApplyNormalConsensusData()`, directly construct Round with:
   - Attacker's SupposedOrderOfNextRound = 0
   - Or another miner's FinalOrderOfNextRound = 10 (> minersCount)

3. **Block Production**: Sign and broadcast block with malicious consensus header

4. **Block Validation**: Other nodes execute validation:
   - Signature verification: ✓ Passes (attacker legitimately signed)
   - `RecoverFromUpdateValue()`: ✓ Accepts invalid values (no bounds check)
   - `UpdateValueValidationProvider`: ✓ Passes (only checks OutValue/PreviousInValue)
   - Block accepted into chain

5. **Next Round Generation**: When generating next round: [16](#0-15) 
   - Invalid Order values are used in ExpectedMiningTime calculations
   - `BreakContinuousMining()` throws exception trying to find Order == 1
   - Round generation fails, halting consensus

**Expected Result**: Block should be rejected with "Invalid SupposedOrderOfNextRound value"

**Actual Result**: Block is accepted, invalid Order values propagate, next round generation fails with exception or produces corrupted mining schedule

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L30-30)
```csharp
                    Order = minerInRound.Order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L49-49)
```csharp
                    Order = information.Value.Order,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L24-27)
```csharp
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-260)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-71)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }

        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

        BreakContinuousMining(ref nextRound);

        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-86)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L93-107)
```csharp
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L203-210)
```csharp
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
                if (passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(1).Add(minersCount) ||
                    passedSlotsCount == currentMinerOrder.Sub(latestMinedOrder).Add(minersCount))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
