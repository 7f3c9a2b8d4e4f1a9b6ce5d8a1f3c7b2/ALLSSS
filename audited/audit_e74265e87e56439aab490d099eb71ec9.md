# Audit Report

## Title
Referendum Contract Allows Setting Unbounded MinimalVoteThreshold Leading to Permanent Governance Lockout

## Summary
The Referendum contract lacks upper bound validation for `MinimalVoteThreshold` in its threshold validation logic, allowing organization thresholds to be set to unreachable values like `Int64.MaxValue`. This creates a permanent governance denial-of-service where no proposals can ever be released, with no recovery mechanism available. Parliament and Association contracts implement proper upper bounds, but Referendum does not.

## Finding Description

The vulnerability exists in the Referendum contract's `ChangeOrganizationThreshold` function and its validation logic. When an organization updates its threshold via a governance proposal, the `Validate` method performs only relative checks between threshold parameters without enforcing any upper bound. [1](#0-0) 

The validation only requires:
- `MinimalApprovalThreshold <= MinimalVoteThreshold`
- `MinimalApprovalThreshold > 0`
- `MaximalAbstentionThreshold >= 0`
- `MaximalRejectionThreshold >= 0`

An attacker can set both `MinimalVoteThreshold` and `MinimalApprovalThreshold` to `Int64.MaxValue`, which satisfies all validation conditions.

When proposals attempt to release, the `IsReleaseThresholdReached` method checks whether total votes meet the threshold: [2](#0-1) 

With `MinimalVoteThreshold` set to `Int64.MaxValue`, the condition at line 15-16 can never be satisfied since realistic token supplies cannot reach this value, preventing all future proposals from being released.

**Critical Design Flaw - No Recovery Mechanism:**

The `ChangeOrganizationThreshold` function can only be called by the organization address itself: [3](#0-2) 

This requires executing through a released proposal via the virtual inline call mechanism: [4](#0-3) 

If no proposals can be released due to the unreachable threshold, the organization cannot fix its own thresholds, creating an unrecoverable state with no emergency override mechanism.

**Inconsistency with Other Governance Contracts:**

Parliament contract enforces upper bound using `AbstractVoteTotal`: [5](#0-4) [6](#0-5) 

Association contract enforces upper bound using organization member count: [7](#0-6) 

Referendum is the only governance contract missing this critical protection.

## Impact Explanation

**Severity: HIGH - Permanent Governance Denial-of-Service**

Once exploited, the organization's governance becomes permanently non-functional:

1. **Complete Governance Lockout**: All future proposals can never reach release threshold, preventing any governance actions including upgrades, parameter changes, or fund releases.

2. **Irreversible State**: The attack creates an unrecoverable state. Since `ChangeOrganizationThreshold` can only be called through a released proposal, and proposals cannot be released, there is no path to recovery. No emergency mechanisms exist for Referendum organizations (unlike Parliament which has emergency response organization).

3. **Systemic Impact**: All members of the affected organization lose governance rights permanently. If critical protocol operations are controlled by the affected Referendum organization, the entire protocol's ability to adapt becomes compromised.

4. **Design Vulnerability**: This represents a fundamental design flaw where token-based governance lacks the same safety bounds as member-based governance (Parliament/Association).

## Likelihood Explanation

**Likelihood: MEDIUM - Requires Governance Approval but Feasible**

**Attack Prerequisites:**
- Attacker must be in the organization's proposer whitelist
- Must successfully pass one malicious proposal through current voting thresholds

**Attack Complexity: LOW**
1. Create proposal calling `ChangeOrganizationThreshold` with extreme values
2. Pass proposal through normal voting (one-time requirement)
3. Release proposal
4. Organization is permanently locked

**Feasibility Factors:**
- **Social Engineering**: Attack can be disguised as "strengthening governance security requirements"
- **Insider Threat**: Single malicious whitelisted proposer can initiate
- **Economic Cost**: Only standard gas fees required
- **Detection**: Extreme values may not be immediately noticed until next proposal fails

While requiring proposal approval is a significant barrier (lowering likelihood from HIGH to MEDIUM), the combination of low cost, irreversible impact, and potential for social engineering makes this a realistic threat. The lack of upper bound validation is an objective security weakness compared to Parliament and Association contracts.

## Recommendation

Add upper bound validation to the Referendum contract's `Validate` method, consistent with Parliament and Association implementations:

```csharp
private bool Validate(Organization organization)
{
    if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
        organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
        return false;
    Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    
    // Get total supply as maximum possible votes
    var tokenInfo = GetTokenInfo(organization.TokenSymbol);
    var maxPossibleVotes = tokenInfo.Supply;
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= maxPossibleVotes &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
}
```

Alternatively, implement a fixed upper bound constant (like Parliament's `AbstractVoteTotal`) or ensure reasonable relationship to total token supply.

## Proof of Concept

```csharp
[Fact]
public async Task ReferendumContract_UnboundedThreshold_PermanentLockout_Test()
{
    // Create organization with normal thresholds
    var createOrganizationInput = new CreateOrganizationInput
    {
        TokenSymbol = "ELF",
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = 1000,
            MinimalVoteThreshold = 1000,
            MaximalAbstentionThreshold = 0,
            MaximalRejectionThreshold = 0
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { DefaultSender } }
    };
    
    var organizationAddress = await ReferendumContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    
    // Create malicious proposal to set extreme thresholds
    var maliciousThreshold = new ProposalReleaseThreshold
    {
        MinimalVoteThreshold = long.MaxValue,
        MinimalApprovalThreshold = long.MaxValue,
        MaximalAbstentionThreshold = 0,
        MaximalRejectionThreshold = 0
    };
    
    var proposalId = await CreateProposalAsync(organizationAddress.Output, 
        nameof(ReferendumContractStub.ChangeOrganizationThreshold), maliciousThreshold);
    
    // Approve and release the malicious proposal (passes with current thresholds)
    await ApproveWithTokensAsync(proposalId, 1000);
    await ReferendumContractStub.Release.SendAsync(proposalId);
    
    // Verify organization is now locked - create a normal proposal
    var normalProposalId = await CreateProposalAsync(organizationAddress.Output, 
        nameof(ReferendumContractStub.ChangeOrganizationThreshold), 
        createOrganizationInput.ProposalReleaseThreshold);
    
    // Even with maximum possible votes, proposal cannot be released
    await ApproveWithTokensAsync(normalProposalId, long.MaxValue / 2);
    
    // Release should fail - threshold unreachable
    var releaseResult = await ReferendumContractStub.Release.SendWithExceptionAsync(normalProposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Organization is permanently locked with no recovery
}
```

## Notes

This vulnerability represents a fundamental inconsistency in AElf's governance contract design. While Parliament and Association contracts properly bound their thresholds to realistic maximums (AbstractVoteTotal and member count respectively), Referendum's token-based voting lacks equivalent protection. The absence of upper bound validation combined with no emergency recovery mechanism creates a permanent governance denial-of-service attack vector. The attack requires majority approval to pass the malicious proposal, which provides some protection, but the irreversible and catastrophic impact upon success justifies HIGH severity classification.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L12-18)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var enoughVote = proposal.RejectionCount.Add(proposal.AbstentionCount).Add(proposal.ApprovalCount) >=
                         proposalReleaseThreshold.MinimalVoteThreshold;
        if (!enoughVote)
            return false;
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L90-102)
```csharp
    private bool Validate(Organization organization)
    {
        if (string.IsNullOrEmpty(organization.TokenSymbol) || organization.OrganizationAddress == null ||
            organization.OrganizationHash == null || organization.ProposerWhiteList.Empty())
            return false;
        Assert(!string.IsNullOrEmpty(GetTokenInfo(organization.TokenSymbol).Symbol), "Token not exists.");

        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        return proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L124-130)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-171)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-147)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-73)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
```
