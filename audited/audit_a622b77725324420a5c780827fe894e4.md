### Title
Legitimate Vote Target Changes Blocked by Missing Profit Details Due to Integer Division Rounding

### Summary
When voters attempt to change their voting target with `IsResetVotingTime = true`, the operation can fail for legitimate active votes due to missing profit details. This occurs because profit detail `EndPeriod` is calculated using integer division that rounds down, creating a timing gap where profit details can be removed via `ClaimProfits` before the vote lock expires, causing `ExtendVoterWelfareProfits` to throw an `AssertionException` and blocking the vote change operation.

### Finding Description

**Root Cause - Integer Division Rounding:**

The vulnerability originates in the `GetEndPeriod` calculation where `lockTime` (in seconds) is divided by `TimeEachTerm` (period duration in seconds) using integer division: [1](#0-0) 

When `lockTime` is not perfectly divisible by `TimeEachTerm`, the result rounds down. For example, a 30-day lock with 7-day periods results in `EndPeriod = currentPeriod + 4` (ignoring 2 extra days), while the actual vote lock lasts the full 30 days.

**Profit Detail Removal:**

When `ClaimProfits` is called on the welfare scheme, it processes all claimable periods and updates `LastProfitPeriod`. After claiming up to the `EndPeriod`, the `LastProfitPeriod` is set to `EndPeriod + 1`: [2](#0-1) [3](#0-2) 

Subsequently, the profit detail is identified for removal because `LastProfitPeriod > EndPeriod`: [4](#0-3) 

And is then removed from the beneficiary's profit details list: [5](#0-4) 

**Vote Change Failure:**

When a voter attempts to change their voting target, the function first validates that the vote hasn't expired: [6](#0-5) 

This check passes because the actual lock time (e.g., 30 days) hasn't elapsed yet, even though the profit detail's `EndPeriod` (representing only 28 days due to rounding) has passed.

If `IsResetVotingTime = true`, the function calls `ExtendVoterWelfareProfits`: [7](#0-6) 

This function attempts to locate the profit detail using `GetProfitDetailByElectionVotingRecord`, which tries two lookups - first by ID, then by Shares: [8](#0-7) 

Since the profit detail was completely removed from the list, both lookups fail and the function returns `null`. This causes `ExtendVoterWelfareProfits` to throw an `AssertionException`: [9](#0-8) 

The vote change operation is blocked even though the vote is legitimate and active.

### Impact Explanation

**Harm Occurrence:**
Voters are unable to change their voting targets when `IsResetVotingTime = true`, resulting in denial of service on a core election functionality. Users are forced to either:
1. Change targets without resetting voting time (`IsResetVotingTime = false`), losing the benefit of extended profit participation
2. Wait until the vote fully expires, then withdraw and create a new vote, incurring additional transaction costs and potentially missing voting opportunities

**Who is Affected:**
Any voter whose `lockTime` is not perfectly divisible by `TimeEachTerm` and who (or whose benefits) claims profits after the rounded-down `EndPeriod` passes but before the actual vote lock expires. This affects a significant portion of users since:
- Common lock periods (30, 60, 90, 180 days) often don't align with period durations
- Profit claiming is routine user behavior to realize rewards
- The timing window exists in every such scenario

**Protocol Damage:**
- **Operational Disruption**: Core voting functionality becomes unreliable
- **User Experience Degradation**: Legitimate operations fail with cryptic error messages
- **Reduced Flexibility**: Users cannot dynamically adjust their voting strategies
- **No Direct Fund Loss**: Tokens remain locked and recoverable after expiration

**Severity Justification:**
Medium severity is appropriate because:
- **Impact**: Operational denial of service affecting core functionality but no fund theft or permanent loss
- **Likelihood**: High - fractional periods are common in real-world usage
- **Scope**: Affects significant user population with realistic timing conditions

### Likelihood Explanation

**Attacker Capabilities:**
No attacker needed - this is a logic flaw affecting legitimate users. Any voter or third-party profit claimer can inadvertently trigger the condition through normal protocol usage.

**Attack Complexity:**
Minimal complexity:
1. User votes with non-perfectly-divisible lock time (common)
2. Time elapses past the rounded-down `EndPeriod`
3. Anyone calls `ClaimProfits` on the welfare scheme (routine operation)
4. User attempts to change voting target with reset time
5. Operation fails with `AssertionException`

**Feasibility Conditions:**
Highly feasible and occurs naturally:
- **Fractional Periods**: Lock times like 30 days with 7-day periods create 2-day gaps
- **Profit Claiming**: Regular maintenance operation performed by users or automated systems
- **Timing Window**: Exists from when `EndPeriod` passes until vote expiration (2+ days in typical scenarios)
- **User Intent**: Legitimate users routinely change voting targets to optimize rewards

**Probability Reasoning:**
High probability of occurrence:
- Integer division rounding affects ~85% of lock time choices (assuming uniform distribution of day values)
- Profit claiming happens regularly (weekly, monthly) for reward realization
- Vote changes are common as candidates' performance and rewards vary
- No special privileges or edge conditions required

### Recommendation

**Code-Level Mitigation:**

Modify `ExtendVoterWelfareProfits` to handle missing profit details gracefully by recreating them instead of throwing an exception:

```csharp
private void ExtendVoterWelfareProfits(Hash voteId)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var electionVotingRecord = GetElectionVotingRecordByVoteId(voteId);
    
    var lockTime = State.LockTimeMap[voteId];
    var lockPeriod = lockTime.Div(State.TimeEachTerm.Value);
    if (lockPeriod == 0)
    {
        return;
    }
    
    var endPeriod = lockPeriod.Add(treasury.CurrentPeriod);
    var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
    
    if (extendingDetail != null)
    {
        // Fix existing profit detail
        State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = electionVotingRecord.Voter,
                Shares = electionVotingRecord.Weight
            },
            EndPeriod = endPeriod,
            ProfitDetailId = voteId
        });
    }
    else
    {
        // Recreate missing profit detail
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = electionVotingRecord.Voter,
                Shares = electionVotingRecord.Weight
            },
            EndPeriod = endPeriod,
            ProfitDetailId = voteId
        });
    }
}
```

**Alternative Solution:**

Fix the root cause by calculating `EndPeriod` to round up instead of down:

```csharp
private long GetEndPeriod(long lockTime)
{
    var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
    var timeEachTerm = State.TimeEachTerm.Value;
    var periods = (lockTime + timeEachTerm - 1).Div(timeEachTerm); // Round up
    return periods.Add(treasury.CurrentPeriod);
}
```

**Invariant Checks:**
- Add assertion in `ChangeVotingOption`: verify profit detail exists before calling `ExtendVoterWelfareProfits`
- Add validation in `ClaimProfits`: ensure `EndPeriod` accurately reflects remaining lock time

**Test Cases to Prevent Regression:**
1. Vote with 30-day lock, 7-day periods, claim profits at day 28, change target at day 29
2. Vote with any non-divisible lock time, verify profit detail handling after claim
3. Multiple sequential vote changes with profit claiming between operations
4. Edge case: EndPeriod = CurrentPeriod (just expired) with pending vote change

### Proof of Concept

**Initial State:**
- Treasury scheme at period 100
- `TimeEachTerm = 7 days = 604,800 seconds`
- User votes with `lockTime = 30 days = 2,592,000 seconds`
- `EndPeriod = 2,592,000 / 604,800 + 100 = 4 + 100 = 104` (rounds down from 4.28)
- Profit detail created with `EndPeriod = 104`

**Transaction Steps:**

1. **Day 0 (Period 100)**: User calls `Vote()` with 30-day lock
   - Profit detail created with `Id = voteId`, `EndPeriod = 104`, `LastProfitPeriod = 0`

2. **Day 28 (Period 104)**: Treasury advances to period 104
   - `DistributeProfits` called for period 104

3. **Day 28 (Period 105)**: Treasury advances to period 105  
   - User calls `ClaimProfits` on welfare scheme
   - `LastProfitPeriod` updated to 105 (EndPeriod + 1)
   - Profit detail removed because `LastProfitPeriod (105) > EndPeriod (104)`

4. **Day 29 (Period 105)**: User calls `ChangeVotingOption` with `IsResetVotingTime = true`
   - Vote expiration check passes: `actualLockedSeconds = 29 days < claimedLockingSeconds = 30 days`
   - `ExtendVoterWelfareProfits` called
   - `GetProfitDetailByElectionVotingRecord` returns `null` (detail was removed)
   - **Transaction reverts with**: `AssertionException: "Cannot find profit detail of given vote id {voteId}"`

**Expected vs Actual Result:**

- **Expected**: Vote target change succeeds, profit detail extended to new `EndPeriod`
- **Actual**: Transaction fails with `AssertionException`, vote change blocked despite legitimate active vote

**Success Condition:**
The vulnerability is demonstrated when a legitimate, non-expired vote (passing the expiration check at line 31) fails to change targets due to missing profit details that were removed by normal profit claiming operations.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L29-31)
```csharp
        var actualLockedSeconds = Context.CurrentBlockTime.Seconds.Sub(votingRecord.VoteTimestamp.Seconds);
        var claimedLockingSeconds = State.LockTimeMap[input.VoteId];
        Assert(actualLockedSeconds < claimedLockingSeconds, "This vote already expired.");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L33-38)
```csharp
        if (input.IsResetVotingTime)
        {
            // true for extend EndPeroid of a Profit details, e.g. you vote for 12 months, and on the 6th month, you
            // change the vote, then there will be another 12 months from that time.
            ExtendVoterWelfareProfits(input.VoteId);
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L140-159)
```csharp
        var extendingDetail = GetProfitDetailByElectionVotingRecord(electionVotingRecord);
        if (extendingDetail != null)
        {
            // The endPeriod is updated and startPeriod is 0, others stay still.
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
        else
        {
            throw new AssertionException($"Cannot find profit detail of given vote id {voteId}");
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L168-185)
```csharp
    private ProfitDetail GetProfitDetailByElectionVotingRecord(ElectionVotingRecord electionVotingRecord)
    {
        var profitDetails = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = electionVotingRecord.Voter,
            SchemeId = State.WelfareHash.Value
        });

        // In new rules, profitDetail.Id equals to its vote id.
        ProfitDetail profitDetail = profitDetails.Details.FirstOrDefault(d => d.Id == electionVotingRecord.VoteId);
        // However, in the old world, profitDetail.Id is null, so use Shares.
        if (profitDetail == null)
        {
            profitDetail = profitDetails.Details.LastOrDefault(d => d.Shares == electionVotingRecord.Weight);
        }

        return profitDetail;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L612-616)
```csharp
    private long GetEndPeriod(long lockTime)
    {
        var treasury = State.ProfitContract.GetScheme.Call(State.TreasuryHash.Value);
        return lockTime.Div(State.TimeEachTerm.Value).Add(treasury.CurrentPeriod);
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L787-789)
```csharp
        var profitDetailsToRemove = profitableDetails
            .Where(profitDetail =>
                profitDetail.LastProfitPeriod > profitDetail.EndPeriod && !profitDetail.IsWeightRemoved).ToList();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L801-806)
```csharp
        foreach (var profitDetail in profitDetailsToRemove)
        {
            availableDetails.Remove(profitDetail);
        }

        State.ProfitDetailsMap[input.SchemeId][beneficiary] = new ProfitDetails { Details = { availableDetails } };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```
