### Title
Missing Validation of Revealed InValues in Secret Sharing Allows Consensus Manipulation

### Summary
The `RevealSharedInValues()` function reconstructs miners' InValues from decrypted secret shares without validating that the revealed InValue matches the committed OutValue from the previous round. Malicious miners can submit corrupted decrypted pieces via `UpdateValue`, causing incorrect InValues to be revealed for offline miners. These incorrect values are then used in signature calculations, breaking the commit-reveal scheme's binding property and allowing manipulation of consensus random number generation.

### Finding Description

**Exact Code Locations:**
- Primary vulnerability: [1](#0-0) 
- Decrypted pieces storage without validation: [2](#0-1) 
- Off-chain revelation with same issue: [3](#0-2) 
- Usage of revealed value in signature calculation: [4](#0-3) 

**Root Cause:**
The secret sharing revelation process has two critical flaws:

1. When miners call `UpdateValue`, their `decrypted_pieces` field (a `map<string, bytes>`) is accepted and stored without any format or cryptographic validation: [5](#0-4) 

2. When `RevealSharedInValues` reconstructs a miner's InValue, it calls `ToByteArray()` on these potentially corrupted ByteStrings and passes them to `SecretSharingHelper.DecodeSecret`. The protobuf ByteString `ToByteArray()` method accepts any bytes, and the `BigInteger` constructor in `DecodeSecret` accepts any byte array without throwing exceptions: [6](#0-5) 

3. **Critical missing validation**: After computing the revealed InValue, the system stores it directly without verifying that `Hash(revealedInValue) == OutValue` from the previous round: [7](#0-6) 

**Why Existing Protections Fail:**
- The `UpdateValueValidationProvider` only validates a miner's self-published `PreviousInValue`, not values revealed through secret sharing: [8](#0-7) 
- No validation exists at lines 148-152 where revealed InValues from trigger information are applied to the round: [9](#0-8) 

**Execution Path:**
1. Round N-1: Victim miner V publishes `OutValue_V = Hash(InValue_V)` and encrypted pieces
2. Round N: Attacker miner A calls `UpdateValue` with maliciously corrupted bytes in `input.DecryptedPieces[V]`
3. These corrupted bytes are stored via `PerformSecretSharing`
4. Round N→N+1 transition: Extra block producer calls `GetConsensusExtraDataForNextRound`, which invokes `RevealSharedInValues`
5. The corrupted bytes undergo Lagrange interpolation in `DecodeSecret`, producing `InValue_V_incorrect`
6. This incorrect value is stored as V's `PreviousInValue` without validation
7. If V is offline and doesn't call `UpdateValue` themselves, `SupplyCurrentRoundInformation` uses the incorrect `PreviousInValue` to calculate V's signature: [10](#0-9) 
8. The signature calculation XORs this incorrect InValue with other miners' signatures: [11](#0-10) 

### Impact Explanation

**Consensus Integrity Breach:**
This vulnerability breaks a fundamental security property of the AEDPoS commit-reveal scheme. In proper secret sharing, miners commit to their InValue by publishing `OutValue = Hash(InValue)`. The system should only accept revealed InValues that match this commitment. By accepting unvalidated revealed InValues, the system allows the binding property of the commitment to be violated.

**Random Number Manipulation:**
Miners' signatures are XORed together to generate consensus random numbers used for mining order and consensus behavior. When an attacker can force incorrect InValues (and thus incorrect signatures) into the calculation, they can disrupt this randomness generation. While the attacker cannot precisely control the output (due to the complexity of Lagrange interpolation and XOR operations), they can systematically bias the random number generation against specific miners.

**Targeted Disruption:**
The attack becomes effective when the victim miner is offline or misses their time slot, as online miners can overwrite the incorrect revealed value with their correct self-published PreviousInValue: [12](#0-11) 

This allows selective targeting of non-participating miners, undermining consensus fairness and potentially affecting:
- Mining order determination for subsequent rounds
- Block producer selection fairness
- Consensus decision-making that relies on verifiable randomness

**Protocol-Level Impact:**
The vulnerability affects the entire consensus mechanism's trustworthiness, as the secret sharing mechanism is designed to ensure that even non-cooperative miners' InValues can be correctly recovered. Breaking this guarantee undermines the security assumptions of the AEDPoS protocol.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an active miner (requires staking to join miner set)
- No special privileges beyond normal miner operations required
- Attack performed through standard `UpdateValue` method: [13](#0-12) 

**Attack Complexity:**
- Low technical complexity: Attacker simply provides arbitrary bytes in the `decrypted_pieces` field of `UpdateValueInput`
- No cryptographic breaking required
- The protobuf `map<string, bytes>` field accepts any byte values: [14](#0-13) 

**Feasibility Conditions:**
- Attack is most effective when target miner is offline or misses their time slot
- Attacker can repeatedly attempt the attack across multiple rounds
- Success probability increases with higher offline miner count

**Detection Constraints:**
- Difficult to detect as corrupted decrypted pieces appear as valid byte data
- No on-chain validation mechanism exists to flag incorrect revelations
- Attack appears as normal consensus participation

**Economic Rationality:**
- Attacker cost: Only requires being a miner (existing staking requirement)
- No additional transaction costs beyond normal mining operations
- Potential benefit: Disrupting specific competitors or manipulating mining order

### Recommendation

**Immediate Fix - Add Validation:**

Add validation in `RevealSharedInValues` after line 50 to verify the revealed InValue matches the committed OutValue:

```csharp
var revealedInValue = HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// CRITICAL: Validate revealed value matches commitment from previous round
if (HashHelper.ComputeFrom(revealedInValue) != anotherMinerInPreviousRound.OutValue)
{
    Context.LogDebug(() => $"Invalid revealed InValue for {publicKeyOfAnotherMiner}, skipping.");
    continue; // Skip invalid revelation
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**Apply Same Fix Off-Chain:**

Update `SecretSharingService.RevealPreviousInValues` to add the same validation: [15](#0-14) 

**Additional Validation:**

Add validation when storing decrypted pieces to ensure they are properly formatted secret shares (reasonable byte length, non-zero, etc.).

**Invariant Checks:**
1. `Hash(revealed_PreviousInValue) == OutValue_from_previous_round` must hold for all revealed InValues
2. Decrypted pieces must pass basic sanity checks (length, format)
3. Log and potentially slash miners who consistently provide invalid decrypted pieces

**Test Cases:**
1. Test that corrupted decrypted pieces result in revelation being skipped
2. Test that miners with invalid revealed InValues cannot affect signature calculations
3. Test that the validation correctly identifies mismatched InValue/OutValue pairs
4. Regression test that valid secret sharing still works correctly

### Proof of Concept

**Initial State:**
- Round N-1 active with miners A (attacker) and V (victim)
- V publishes `OutValue_V = Hash(InValue_V)` and encrypted pieces
- Both miners are in the miner set

**Attack Steps:**

1. **Round N - Attacker corrupts decrypted pieces:**
   - Attacker A calls `UpdateValue` with:
     ```
     UpdateValueInput {
       decrypted_pieces: {
         "V_pubkey": <arbitrary_corrupted_bytes>
       }
       // ... other required fields
     }
     ```
   - These corrupted bytes are stored in round N state without validation

2. **Round N→N+1 Transition - Revelation occurs:**
   - Extra block producer calls `GetConsensusExtraDataForNextRound`
   - `RevealSharedInValues` is invoked
   - Uses corrupted decrypted pieces from A to reconstruct V's InValue
   - Results in `InValue_V_corrupted` ≠ `InValue_V`
   - **Expected:** System should validate `Hash(InValue_V_corrupted) == OutValue_V` and reject
   - **Actual:** System accepts and stores `InValue_V_corrupted` without validation

3. **Round N+1 - Victim offline:**
   - V misses their time slot or is offline
   - `SupplyCurrentRoundInformation` is called for V
   - Retrieves `PreviousInValue = InValue_V_corrupted` from round state
   - Calculates `signature_V_incorrect = XOR(InValue_V_corrupted, other_signatures)`
   - Stores incorrect signature for V

4. **Consensus Impact:**
   - Random number generation uses `signature_V_incorrect` in XOR calculation
   - Results in biased random numbers for subsequent rounds
   - Mining order and consensus decisions affected

**Success Condition:**
- Revealed InValue stored in state does not match `Hash(InValue) == OutValue` from previous round
- Incorrect signature calculated for offline miner
- Random number generation produces different result than it should with correct InValue

**Notes**

The vulnerability exists in both on-chain and off-chain revelation paths, indicating a systematic design flaw in the secret sharing validation logic. The issue is particularly concerning because it undermines a core security mechanism (commit-reveal scheme) that the entire consensus protocol relies upon for trustless random number generation. While online miners can protect themselves by publishing their own correct PreviousInValue, the system should not accept invalid revelations for offline miners, as this violates the fundamental security guarantees of Shamir's Secret Sharing combined with commit-reveal schemes.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L46-52)
```csharp
            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L263-264)
```csharp
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L172-180)
```csharp
            var sharedParts = minerInRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            Logger.LogDebug($"Revealed in value of {pubkey} of round {round.RoundNumber}: {revealedInValue}");

            revealedInValues[pubkey] = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-200)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** src/AElf.Cryptography/SecretSharing/SecretSharingHelper.cs (L44-50)
```csharp
        public static byte[] DecodeSecret(List<byte[]> sharedParts, List<int> orders, int threshold)
        {
            var result = BigInteger.Zero;

            for (var i = 0; i < threshold; i++)
            {
                var numerator = new BigInteger(sharedParts[i]);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L148-152)
```csharp
        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** protobuf/aedpos_contract.proto (L194-221)
```text
message UpdateValueInput {
    // Calculated from current in value.
    aelf.Hash out_value = 1;
    // Calculated from current in value and signatures of previous round.
    aelf.Hash signature = 2;
    // To ensure the values to update will be apply to correct round by comparing round id.
    int64 round_id = 3;
    // Publish previous in value for validation previous signature and previous out value.
    aelf.Hash previous_in_value = 4;
    // The actual mining time, miners must fill actual mining time when they do the mining.
    google.protobuf.Timestamp actual_mining_time = 5;
    // The supposed order of mining for the next round.
    int32 supposed_order_of_next_round = 6;
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
    // The encrypted pieces of InValue.
    map<string, bytes> encrypted_pieces = 8;
    // The decrypted pieces of InValue.
    map<string, bytes> decrypted_pieces = 9;
    // The amount of produced blocks.
    int64 produced_blocks = 10;
    // The InValue in the previous round, miner public key -> InValue.
    map<string, aelf.Hash> miners_previous_in_values = 11;
    // The irreversible block height that miner recorded.
    int64 implied_irreversible_block_height = 12;
    // The random number.
    bytes random_number = 13;
}
```
