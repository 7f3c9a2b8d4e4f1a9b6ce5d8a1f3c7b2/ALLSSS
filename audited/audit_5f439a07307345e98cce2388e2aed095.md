# Audit Report

## Title
Contract Ownership Theft via Expired Proposal State Overwrite

## Summary
The `SendUserContractProposal()` function in the Genesis contract allows attackers to overwrite expired proposal metadata while an approved governance proposal is still pending execution. By submitting identical contract deployment inputs after the expiration period, an attacker can replace the legitimate author's address with their own. When miners subsequently release the original approved proposal, the contract deploys with the attacker as owner instead of the legitimate proposer, resulting in complete ownership theft.

## Finding Description

The vulnerability exists in the user contract deployment workflow within the Genesis (BasicContractZero) contract. The core issue is a race condition between proposal expiration and governance execution that allows state overwriting.

**Vulnerable Code Flow:**

The `SendUserContractProposal()` helper method contains a critical flaw in its expiration check. [1](#0-0)  The assertion `Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.")` explicitly permits overwriting the state mapping when the expiration time has passed, without verifying whether an approved governance proposal for that input hash is still pending execution.

When the condition evaluates to true, the function proceeds to completely overwrite the `ContractProposingInputMap` state entry with a new `ContractProposingInput` structure. [2](#0-1)  Most critically, line 321 sets `Author = Context.Sender`, meaning the attacker's address replaces the legitimate user's address.

The state mapping is keyed solely by the input hash, not by proposal ID. [3](#0-2)  This design allows multiple governance proposals (with different IDs) to reference the same state entry, creating the vulnerability.

**Attack Execution Path:**

1. **Initial Deployment:** A legitimate user calls `DeployUserSmartContract()` with specific contract code, category, and salt. [4](#0-3)  This creates a state entry with `Author = UserAddress` and initiates a governance proposal P1 with expiration time T1 (default 15 minutes). [5](#0-4) 

2. **Governance Approval:** Miners vote and approve proposal P1 through the code check controller (Parliament contract).

3. **Expiration Before Release:** Due to operational delays or network congestion, the current block time advances past T1 before miners release the approved proposal.

4. **Attacker Overwrites State:** The attacker submits an identical `UserContractDeploymentInput` (same code, category, salt), generating the identical input hash. Since `Context.CurrentBlockTime >= registered.ExpiredTime`, the expiration check passes and the state is completely overwritten with `Author = AttackerAddress`. A new governance proposal P2 is created, but the attacker does not need it to be approved.

5. **Release of Original Proposal:** A miner releases the **original approved proposal P1** via `ReleaseApprovedUserSmartContract()`. [6](#0-5)  At line 478, it retrieves the state entry by input hash, which now contains the **attacker's address**. The validation checks at lines 480-483 pass because: the status is still `CodeCheckProposed` (set by attacker), and the proposer is `Context.Self` for both proposals (not the user's address).

6. **Contract Deployment with Wrong Owner:** When the code check controller calls back to `PerformDeployUserSmartContract()`, it retrieves the compromised state entry. [7](#0-6)  Lines 502-503 deploy the contract using `contractProposingInput.Author` as both the author and deployer parameters, which is now the attacker's address instead of the legitimate user's address.

**Why Existing Protections Fail:**

The `ReleaseApprovedUserSmartContract()` validation cannot distinguish between the legitimate user's state and the attacker's overwrite because:
- Both proposals set `Proposer = Context.Self` (the Genesis contract address), not the user's address. [8](#0-7) 
- The status check only verifies it's `CodeCheckProposed`, which the attacker's call also sets
- There is no validation linking the proposal ID being released to the state entry's creation

The governance approval system correctly verifies that proposal P1 was approved, but it has no visibility into the fact that the Genesis contract's state mapping was subsequently overwritten.

## Impact Explanation

**Severity: HIGH**

This vulnerability enables complete contract ownership theft with the following concrete impacts:

1. **Unauthorized Contract Control:** The attacker gains full authorship rights to the deployed contract. The `UpdateUserSmartContract()` method validates `Context.Sender == info.Author` before allowing updates. [9](#0-8)  With the attacker registered as author, they can modify the contract's code through subsequent updates while the legitimate user is permanently locked out.

2. **Authorship Transfer:** The attacker can transfer the stolen ownership to other addresses or sell it, making the theft permanent and difficult to trace.

3. **Governance Integrity Violation:** This breaks a fundamental invariant: approved governance proposals must execute with the parameters that were approved. The miners approved deployment with `Author = LegitimateUser`, but the contract deploys with `Author = Attacker`. This undermines trust in the entire governance system.

4. **Financial Loss:** If the legitimate user paid fees for the deployment or invested resources in the contract code, they lose both the deployed contract and all associated value.

The same vulnerability affects `UpdateUserSmartContract()`, allowing attackers to steal update rights for existing contracts. [10](#0-9) 

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The attack is highly feasible under realistic conditions:

**Attacker Capabilities:**
- On main chains and public sidechains, any user can call `DeployUserSmartContract()` without special permissions. [11](#0-10)  The check only restricts deployment on private sidechains where the sender must be in the Parliament whitelist.
- The attacker can monitor blockchain events to detect when contracts are proposed.
- Computing the identical input hash is trivial since the contract code is public.

**Preconditions:**
- The critical precondition is that the time between proposal approval and release exceeds the `CodeCheckProposalExpirationTimePeriod` (default 15 minutes).
- This occurs realistically during:
  - Network congestion when miners are busy processing other transactions
  - Off-peak hours when miner activity is reduced
  - Operational delays in automated proposal release systems
  - Deliberately short expiration periods set by governance

**Attack Complexity: LOW**
1. Monitor for `CodeCheckRequired` events from contract deployments
2. Query `GetCodeCheckProposalExpirationTimePeriod()` to determine expiration time
3. Wait until `current_time > expiration_time`
4. Submit identical deployment input
5. Wait for miners to release the original approved proposal

**Detection Difficulty:**
The attack produces normal-looking on-chain behavior. Both the attacker's submission and the final deployment emit standard events. The `ContractDeployed` event shows the attacker as author, which appears legitimate. Post-mortem analysis would require correlating governance proposal IDs with state changes, which is not straightforward.

The test suite confirms that re-proposal after expiration is intended behavior. [12](#0-11)  However, this feature was not designed to account for approved-but-unreleased governance proposals.

## Recommendation

**Primary Fix:** Add proposal-ID-to-state-entry binding to prevent state overwrite while governance proposals are pending.

**Recommended Solution:**

1. Modify `ContractProposingInput` to include a `ProposalId` field that links the state entry to the specific governance proposal.

2. Update `SendUserContractProposal()` to check if an existing state entry has an associated active proposal in the code check controller before allowing overwrite:

```csharp
private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
{
    var registered = State.ContractProposingInputMap[proposingInputHash];
    
    // NEW: Check if proposal is still active before allowing expiration-based overwrite
    if (registered != null && Context.CurrentBlockTime >= registered.ExpiredTime)
    {
        // Query the code check controller to verify the proposal has been released or rejected
        var proposalStatus = GetProposalStatus(registered.ProposalId);
        Assert(proposalStatus == ProposalStatus.Released || 
               proposalStatus == ProposalStatus.Abstained ||
               proposalStatus == ProposalStatus.Rejected,
               "Cannot overwrite: approved proposal still pending release.");
    }
    else
    {
        Assert(registered == null, "Already proposed.");
    }
    
    var proposedInfo = new ContractProposingInput
    {
        Proposer = Context.Self,
        Status = ContractProposingInputStatus.CodeCheckProposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
        Author = Context.Sender
    };
    State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
    
    // Create governance proposal and store its ID
    var proposalCreationInput = new CreateProposalBySystemContractInput { ... };
    var proposalId = Context.SendInline(...);
    proposedInfo.ProposalId = proposalId; // Link state to proposal
    State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
}
```

3. In `ReleaseApprovedUserSmartContract()`, verify that the proposal ID being released matches the state entry's proposal ID:

```csharp
public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
{
    var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];
    
    Assert(contractProposingInput != null &&
           contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
           contractProposingInput.Proposer == Context.Self &&
           contractProposingInput.ProposalId == input.ProposalId, // NEW: Verify proposal ID match
           "Invalid contract proposing status.");
    
    AssertCurrentMiner();
    
    contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
    State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
    
    var codeCheckController = State.CodeCheckController.Value;
    Context.SendInline(codeCheckController.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
    return new Empty();
}
```

**Alternative Solution:** Use a composite key combining input hash and proposal ID for `ContractProposingInputMap` to ensure each governance proposal has its own state entry that cannot be overwritten.

## Proof of Concept

```csharp
[Fact]
public async Task ContractOwnershipTheft_Via_ExpiredProposalOverwrite()
{
    // Setup: Initialize side chain and whitelist
    StartSideChain("ELF");
    await AddZeroContractToProposerWhiteListAsync();
    
    // Step 1: Legitimate user deploys contract
    var legitimateUser = SampleAddress.AddressList[0];
    var contractCode = Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value;
    var deploymentInput = new UserContractDeploymentInput
    {
        Category = KernelConstants.DefaultRunnerCategory,
        Code = ByteString.CopyFrom(contractCode)
    };
    
    var deployResult = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract),
        deploymentInput);
    deployResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Extract proposal info
    var proposalId = ProposalCreated.Parser
        .ParseFrom(deployResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
        .ProposalId;
    var proposedContractInputHash = CodeCheckRequired.Parser
        .ParseFrom(deployResult.Logs.First(l => l.Name.Contains(nameof(CodeCheckRequired))).NonIndexed)
        .ProposedContractInputHash;
    
    // Step 2: Miners approve the proposal
    await ApproveWithMinersAsync(SideChainTester, SideParliamentAddress, proposalId);
    
    // Step 3: Advance time past expiration (15 minutes default)
    var expirationPeriod = await GetCodeCheckProposalExpirationTimePeriod();
    await AdvanceBlockTimeAsync(expirationPeriod + 1);
    
    // Step 4: Attacker submits identical input to overwrite state
    var attacker = SampleAddress.AddressList[1];
    var attackResult = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.DeployUserSmartContract),
        deploymentInput,
        attacker); // Different sender (attacker)
    attackResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 5: Miner releases the ORIGINAL approved proposal
    var releaseResult = await SideChainTester.ExecuteContractWithMiningAsync(
        SideBasicContractZeroAddress,
        nameof(ACS0Container.ACS0Stub.ReleaseApprovedUserSmartContract),
        new ReleaseContractInput
        {
            ProposalId = proposalId,
            ProposedContractInputHash = proposedContractInputHash
        });
    releaseResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 6: Verify contract was deployed with ATTACKER as author (VULNERABILITY)
    var contractDeployedEvent = ContractDeployed.Parser
        .ParseFrom(releaseResult.Logs.First(l => l.Name.Contains(nameof(ContractDeployed))).NonIndexed);
    
    // BUG: Author should be legitimateUser, but it's attacker!
    contractDeployedEvent.Author.ShouldBe(attacker); // Vulnerability proven
    contractDeployedEvent.Author.ShouldNotBe(legitimateUser); // Legitimate user lost ownership
}
```

**Notes:**
- This vulnerability has been validated through complete code trace analysis of the Genesis contract
- The default expiration period is 900 seconds (15 minutes), making the attack window realistic
- The vulnerability affects both new contract deployment and contract updates
- No special privileges are required beyond normal user contract deployment permissions
- The attack is undetectable through standard event monitoring since all events appear legitimate

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L314-315)
```csharp
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L316-323)
```csharp
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroState.cs (L17-17)
```csharp
    public MappedState<Hash, ContractProposingInput> ContractProposingInputMap { get; set; }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-427)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-474)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
        Assert(info.Deployer == null || info.Deployer == Context.Sender, "No permission to update.");
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Assert(info.CodeHash != codeHash, "Code is not changed.");
        AssertContractNotExists(codeHash);
        AssertContractVersion(info.ContractVersion, input.Code, info.Category);

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformUpdateUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = info.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-493)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-505)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L276-314)
```csharp
    public async Task Propose_MultiTimes()
    {
        var contractDeploymentInput = new ContractDeploymentInput
        {
            Category = KernelConstants.DefaultRunnerCategory, // test the default runner
            Code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TokenConverter")).Value)
        };

        var utcNow = TimestampHelper.GetUtcNow();
        // propose contract code
        var proposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow);
        proposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var proposalId = ProposalCreated.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ProposalCreated))).NonIndexed)
            .ProposalId;
        proposalId.ShouldNotBeNull();
        var proposedContractInputHash = ContractProposed.Parser
            .ParseFrom(proposingTxResult.Logs.First(l => l.Name.Contains(nameof(ContractProposed))).NonIndexed)
            .ProposedContractInputHash;

        var secondProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
        secondProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);

        var thirdProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(86399));
        thirdProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        
        var byteResult = await Tester.CallContractMethodAsync(BasicContractZeroAddress,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplStub.GetContractProposalExpirationTimePeriod),
            new Empty());
        var expirationTimePeriod = Int32Value.Parser.ParseFrom(byteResult);
        
        var forthProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(expirationTimePeriod.Value));
        forthProposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
    }
```
