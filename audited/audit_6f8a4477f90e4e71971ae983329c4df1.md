### Title
Malicious Contract Address in ChangeMethodFeeController Enables Permanent Controller Lockout

### Summary
The `ChangeMethodFeeController()` function in all ACS1-compliant contracts (Association, Parliament, Referendum, Genesis, etc.) lacks validation that `input.ContractAddress` is a trusted system contract. An attacker with temporary governance control can set a malicious contract that always returns true for `ValidateOrganizationExist`, allowing the controller to be locked to an uncontrollable address (including zero address). This creates permanent, irreversible loss of method fee control even after governance is recovered.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController()` implementation across all ACS1 contracts. The Association contract implementation is representative: [1](#0-0) 

The function performs only two validations:
1. Authorization check that sender is current controller's OwnerAddress
2. Organization existence check via `CheckOrganizationExist(input)`

The critical flaw is in the `CheckOrganizationExist` implementation: [2](#0-1) 

This makes a cross-contract call to `input.ContractAddress` without validating it is a trusted governance contract. The codebase has an established pattern for validating system contracts: [3](#0-2) 

However, this validation is NOT applied in `ChangeMethodFeeController`. The same vulnerability exists identically in Parliament, Referendum, Genesis, and all other ACS1 implementations: [4](#0-3) [5](#0-4) 

The `AuthorityInfo` structure allows arbitrary contract and owner addresses: [6](#0-5) 

AElf Address type permits creation of zero addresses (32 bytes of zeros): [7](#0-6) 

### Impact Explanation

**Operational Impact - Permanent DoS:**
- Method fee control for ALL affected contracts becomes permanently locked
- No recovery mechanism exists - the controller state can only be changed by calling `ChangeMethodFeeController`, which requires being the current controller
- Affects critical system contracts: Genesis, Parliament, Association, Referendum, Token, CrossChain, Consensus, Economic, and all others implementing ACS1

**Governance Impact:**
- Even if governance control is recovered (e.g., compromised keys replaced, voting bug fixed), the fee controller cannot be recovered
- Violates the fundamental governance principle of recoverability
- Creates asymmetric damage: temporary compromise causes permanent harm

**Severity Justification:**
This is CRITICAL because:
1. The damage is irreversible - no contract method or admin function can reset the controller
2. It affects all system contracts implementing ACS1
3. Method fees are critical for economic security and spam prevention
4. The vulnerability enables permanent governance damage from temporary compromise

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must control current MethodFeeController (typically Parliament or Association default organization)
- This requires either:
  - Compromised governance keys (temporary access)
  - Exploited voting/approval logic bug
  - Malicious insider with proposal rights
  - Social engineering of governance participants

**Attack Complexity:**
1. Deploy malicious contract with `ValidateOrganizationExist(Address) returns BoolValue { Value = true }`
2. Create governance proposal to call `ChangeMethodFeeController` with:
   - `ContractAddress`: deployed malicious contract address
   - `OwnerAddress`: zero address created via `Address.FromBytes(new byte[32])`
3. Pass proposal through current governance process
4. Release proposal - controller now locked permanently

**Feasibility:**
- Attack is technically simple - requires only basic contract deployment
- On-chain visibility: attack is visible in proposal text, but may not be detected
- Cost: minimal (deployment + governance proposal fees)
- Irreversibility: once executed, cannot be undone

**Probability Assessment:**
While requiring governance control is a high bar, the critical factor is that this creates PERMANENT damage that exceeds the scope of temporary compromise. This violates defense-in-depth principles - governance should be recoverable even after temporary compromise.

### Recommendation

**Primary Fix - Validate System Contract:**
Add validation in `ChangeMethodFeeController` that `input.ContractAddress` is a registered system contract:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // ADD THIS VALIDATION:
    Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(input.ContractAddress),
        "Authority contract address must be a system contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Additional Validation - Non-Zero Owner Address:**
```csharp
Assert(input.OwnerAddress != null && !input.OwnerAddress.Value.IsNullOrEmpty(),
    "Invalid owner address.");
```

**Invariant Checks:**
1. ContractAddress must be in system contract mapping
2. OwnerAddress must be non-null and non-empty
3. Organization must exist in the specified contract

**Test Cases:**
1. Attempt to set non-system contract address - should fail
2. Attempt to set zero address as owner - should fail  
3. Attempt to set null OwnerAddress - should fail
4. Valid change between system contracts - should succeed

Apply this fix to ALL ACS1 implementations: [1](#0-0) [4](#0-3) [8](#0-7) [9](#0-8) 

### Proof of Concept

**Initial State:**
- MethodFeeController is Parliament default organization (standard configuration)
- Attacker gains temporary control of Parliament organization (compromised keys/voting bug)

**Attack Steps:**

1. **Deploy Malicious Contract:**
```csharp
public class MaliciousValidator : Container.ContractBase
{
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Create Zero Address:**
```csharp
var zeroAddress = Address.FromBytes(new byte[32]); // All zeros
```

3. **Submit Governance Proposal:**
Call `CreateProposal` through Parliament with:
    - ToAddress: Association contract address
    - ContractMethodName: "ChangeMethodFeeController"
    - Params: `AuthorityInfo { ContractAddress = maliciousContract, OwnerAddress = zeroAddress }`

4. **Execute Proposal:**
    - Proposal passes with majority votes
    - Call `Release` on the proposal
    - `ChangeMethodFeeController` executes
    - `CheckOrganizationExist` calls malicious contract which returns true
    - Controller is set to uncontrollable zero address

**Expected Result:**
Transaction should fail with "Authority contract address must be a system contract."

**Actual Result:**
Transaction succeeds. MethodFeeController is now:
```
ContractAddress: <malicious contract>
OwnerAddress: 0x0000000000000000000000000000000000000000000000000000000000000000
```

**Success Condition:**
Subsequent calls to `SetMethodFee` or `ChangeMethodFeeController` fail with "Unauthorized behavior" because sender can never equal zero address. Method fee control is permanently lost.

### Citations

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L70-74)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L96-99)
```csharp
    public override Address CreateOrganizationBySystemContract(CreateOrganizationBySystemContractInput input)
    {
        Assert(Context.GetSystemContractNameToAddressMapping().Values.Contains(Context.Sender),
            "Unauthorized to create organization.");
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/authority_info.proto (L5-10)
```text
message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```

**File:** test/AElf.Types.Tests/AddressTest.cs (L23-26)
```csharp
        //Generate from byte
        var bytes = Enumerable.Repeat((byte)0xEF, 32).ToArray();
        var address4 = Address.FromBytes(bytes);
        address4.ShouldNotBe(null);
```

**File:** contract/AElf.Contracts.Referendum/ReferendumContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```
