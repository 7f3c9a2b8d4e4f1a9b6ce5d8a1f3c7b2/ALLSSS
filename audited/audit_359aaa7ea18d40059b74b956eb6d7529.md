### Title
Assembled NFTs Can Be Burned Directly, Causing Permanent Loss of Locked Fungible Tokens

### Summary
The `Burn` method does not check whether an NFT contains assembled assets (locked NFTs/FTs) before destroying it. When a minter directly burns an assembled NFT instead of properly disassembling it, the fungible tokens locked in the contract remain permanently trapped because the `AssembledFtsMap` entry is never removed and the disassembly flow becomes inaccessible. This violates the critical invariant that locked assets must be recoverable.

### Finding Description

The NFT contract implements an assembly mechanism where users can lock fungible tokens (FTs) and other NFTs inside a new assembled NFT. [1](#0-0) 

During assembly, FTs are transferred from the user to the contract itself via `TransferFrom`, and the mapping is stored in `AssembledFtsMap`. [2](#0-1) 

The intended recovery path is through the `Disassemble` method, which burns the assembled NFT, retrieves the locked assets from state, transfers them back to the receiver, and removes the state entries. [3](#0-2) 

However, the `Burn` method can be called directly by any minter who owns the assembled NFT. [4](#0-3) 

**Root Cause:** The `Burn` method lacks any check to determine if the NFT being burned is assembled (i.e., has entries in `AssembledFtsMap` or `AssembledNftsMap`). It only verifies that the protocol is burnable, the caller is a minter, and the caller has sufficient balance. [5](#0-4) 

When an assembled NFT is burned directly:
1. The NFT balance is reduced to zero
2. The supply and quantity are decremented
3. The NFT is marked as burned
4. **The `AssembledFtsMap` entry remains in state but becomes orphaned**
5. **The locked FTs remain in the contract address**

After this occurs, the `Disassemble` method cannot recover the locked assets because it requires calling `Burn`, which requires the caller to have balance ≥ 1. [6](#0-5) 

There is no alternative recovery mechanism to retrieve orphaned assembled assets.

### Impact Explanation

**Direct Asset Loss:** All fungible tokens locked in the assembled NFT are permanently trapped in the NFT contract address with no possibility of recovery. For example, if 1000 ELF tokens were locked during assembly, they become permanently inaccessible.

**Affected Parties:**
- NFT owners who assembled valuable FTs into NFTs
- Any user who subsequently receives such an assembled NFT from the original assembler
- The protocol's economic integrity, as locked assets reduce circulating supply permanently

**Severity Justification:** HIGH severity because:
1. Results in permanent, unrecoverable loss of user funds
2. Can affect any assembled NFT with arbitrary value of locked FTs
3. Requires only normal operational permissions (minter role)
4. No admin recovery mechanism exists
5. Violates the fundamental expectation that assembled assets can be recovered through disassembly

### Likelihood Explanation

**Attacker Capabilities:** The vulnerability can be triggered by any minter who owns an assembled NFT. Minters are common operational roles in the NFT ecosystem - they are explicitly added to mint NFTs and often include the creator/assembler themselves. [7](#0-6) 

**Attack Complexity:** Extremely simple - requires a single transaction calling the public `Burn` method with the symbol and token ID of the assembled NFT.

**Feasibility Conditions:**
1. Protocol must be burnable (set during protocol creation)
2. Attacker must be in the minter list for that protocol
3. Attacker must own the assembled NFT (balance ≥ 1)

These conditions are commonly met in normal operations. Many protocols are burnable by design, and assemblers are often minters themselves.

**Detection:** The vulnerability could occur accidentally (user calls wrong method) or intentionally. Once executed, the locked FTs cannot be recovered through any contract mechanism.

**Probability:** MEDIUM to HIGH - while this may not be a deliberate attack vector, the ease of accidentally calling `Burn` instead of `Disassemble`, combined with no warning or protection mechanism, makes this a realistic scenario.

### Recommendation

**Primary Fix:** Add a check in the `Burn` method to prevent burning assembled NFTs:

```csharp
// In Burn method, after line 88, add:
var assembledFts = State.AssembledFtsMap[tokenHash];
var assembledNfts = State.AssembledNftsMap[tokenHash];
Assert(assembledFts == null && assembledNfts == null, 
    "Cannot burn assembled NFT directly. Use Disassemble method to recover locked assets first.");
```

**Invariant to Enforce:** An NFT with non-null entries in `AssembledFtsMap` or `AssembledNftsMap` MUST NOT be burnable via the `Burn` method. It must only be destroyed through the `Disassemble` flow which properly returns locked assets.

**Alternative/Additional Fix:** If burning assembled NFTs should be allowed, then the `Burn` method must:
1. Check for assembled assets
2. Transfer the locked FTs back to the NFT owner before burning
3. Remove the `AssembledFtsMap` and `AssembledNftsMap` entries

**Test Cases to Add:**
1. Test that `Burn` reverts when called on an assembled NFT with locked FTs
2. Test that `Burn` reverts when called on an assembled NFT with locked NFTs
3. Test that `Disassemble` is the only valid path to destroy assembled NFTs
4. Test edge cases: assembled NFT with only FTs, only NFTs, or both

### Proof of Concept

**Initial State:**
1. Create a burnable NFT protocol with symbol "TEST"
2. Add User A as a minter for "TEST" protocol
3. User A mints NFT "TEST#1" 
4. User A approves the NFT contract to spend 1000 ELF tokens
5. User A calls `Assemble` to create "TEST#2" by locking "TEST#1" and 1000 ELF
   - State: `AssembledFtsMap[hash("TEST#2")] = {"ELF": 1000}`
   - State: Contract holds 1000 ELF tokens
   - State: User A owns "TEST#2"

**Exploit Steps:**
1. User A (or any minter who receives "TEST#2") calls `Burn`:
   ```
   Burn(BurnInput {
       Symbol: "TEST",
       TokenId: 2,
       Amount: 1
   })
   ```

**Actual Result:**
- NFT "TEST#2" is burned (balance = 0, quantity = 0)
- `AssembledFtsMap[hash("TEST#2")]` still contains `{"ELF": 1000}` but is orphaned
- 1000 ELF remains in the NFT contract address
- No method can retrieve these 1000 ELF tokens

**Expected Result:**
- The `Burn` call should revert with: "Cannot burn assembled NFT directly. Use Disassemble method."
- OR the `Burn` method should automatically transfer the 1000 ELF back to the owner before burning

**Success Condition:** After the exploit, attempting to call `Disassemble` on "TEST#2" will fail because User A has zero balance of the burned NFT, permanently locking the 1000 ELF in the contract.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-111)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

        Context.Fire(new Burned
        {
            Burner = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            TokenId = input.TokenId
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L113-189)
```csharp
    public override Hash Assemble(AssembleInput input)
    {
        if (input.Metadata != null && input.Metadata.Value.Any())
            AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);

        var metadata = input.Metadata ?? new Metadata();

        if (input.AssembledNfts.Value.Any())
        {
            metadata.Value[AssembledNftsKey] = input.AssembledNfts.ToString();
            // Check owner.
            foreach (var pair in input.AssembledNfts.Value)
            {
                var nftHash = Hash.LoadFromHex(pair.Key);
                var nftInfo = GetNFTInfoByTokenHash(nftHash);
                Assert(State.BalanceMap[nftHash][Context.Sender] >= pair.Value,
                    $"Insufficient balance of {nftInfo.Symbol}{nftInfo.TokenId}.");
                DoTransfer(nftHash, Context.Sender, Context.Self, pair.Value);
            }
        }

        if (input.AssembledFts.Value.Any())
        {
            metadata.Value[AssembledFtsKey] = input.AssembledFts.ToString();
            // Check balance and allowance.
            foreach (var pair in input.AssembledFts.Value)
            {
                var symbol = pair.Key;
                var amount = pair.Value;
                var balance = State.TokenContract.GetBalance.Call(new MultiToken.GetBalanceInput
                {
                    Owner = Context.Sender,
                    Symbol = symbol
                }).Balance;
                Assert(balance >= amount, $"Insufficient balance of {symbol}");
                var allowance = State.TokenContract.GetAllowance.Call(new MultiToken.GetAllowanceInput
                {
                    Owner = Context.Sender,
                    Spender = Context.Self,
                    Symbol = symbol
                }).Allowance;
                Assert(allowance >= amount, $"Insufficient allowance of {symbol}");
                State.TokenContract.TransferFrom.Send(new MultiToken.TransferFromInput
                {
                    From = Context.Sender,
                    To = Context.Self,
                    Symbol = symbol,
                    Amount = amount
                });
            }
        }

        var mingInput = new MintInput
        {
            Symbol = input.Symbol,
            Alias = input.Alias,
            Owner = input.Owner,
            Uri = input.Uri,
            Metadata = metadata,
            TokenId = input.TokenId
        };

        var nftMinted = PerformMint(mingInput, true);
        if (input.AssembledNfts.Value.Any()) State.AssembledNftsMap[nftMinted.TokenHash] = input.AssembledNfts;

        if (input.AssembledFts.Value.Any()) State.AssembledFtsMap[nftMinted.TokenHash] = input.AssembledFts;

        Context.Fire(new Assembled
        {
            Symbol = input.Symbol,
            TokenId = nftMinted.TokenId,
            AssembledNfts = input.AssembledNfts,
            AssembledFts = input.AssembledFts
        });

        return nftMinted.TokenHash;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L191-236)
```csharp
    public override Empty Disassemble(DisassembleInput input)
    {
        Burn(new BurnInput
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Amount = 1
        });

        var receiver = input.Owner ?? Context.Sender;

        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var assembledNfts = State.AssembledNftsMap[tokenHash].Clone();
        if (assembledNfts != null)
        {
            var nfts = assembledNfts;
            foreach (var pair in nfts.Value) DoTransfer(Hash.LoadFromHex(pair.Key), Context.Self, receiver, pair.Value);

            State.AssembledNftsMap.Remove(tokenHash);
        }

        var assembledFts = State.AssembledFtsMap[tokenHash].Clone();
        if (assembledFts != null)
        {
            var fts = assembledFts;
            foreach (var pair in fts.Value)
                State.TokenContract.Transfer.Send(new MultiToken.TransferInput
                {
                    Symbol = pair.Key,
                    Amount = pair.Value,
                    To = receiver
                });

            State.AssembledFtsMap.Remove(tokenHash);
        }

        Context.Fire(new Disassembled
        {
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            DisassembledNfts = assembledNfts ?? new AssembledNfts(),
            DisassembledFts = assembledFts ?? new AssembledFts()
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```
