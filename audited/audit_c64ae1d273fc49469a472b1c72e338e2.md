### Title
TokenHolder Scheme Configuration Overwrite Allows Lock Term Manipulation

### Summary
The `CreateScheme` function in the TokenHolder contract lacks duplicate prevention checks, allowing a scheme manager to call it multiple times and overwrite the stored scheme configuration (`Symbol` and `MinimumLockMinutes`). This enables the manager to retroactively change lock terms after users have already locked tokens, breaking withdrawal functionality and extending lock periods arbitrarily beyond the original agreement.

### Finding Description

The `CreateScheme` function contains no validation to prevent multiple invocations by the same sender: [1](#0-0) 

The function directly overwrites `State.TokenHolderProfitSchemes[Context.Sender]` without checking if a scheme already exists. Each invocation also creates a new Profit scheme: [2](#0-1) 

The Profit contract allows multiple schemes per manager and stores them in a list: [3](#0-2) 

When users register for profits and lock tokens, they use the current scheme configuration: [4](#0-3) 

However, during withdrawal, the scheme configuration is retrieved fresh from state, which may now contain different values: [5](#0-4) 

The withdrawal process uses the retrieved scheme's `Symbol` for unlocking and `MinimumLockMinutes` for time validation: [6](#0-5) 

**Root Cause**: Missing existence check before scheme creation and no immutability guarantee for lock terms.

**Why Protections Fail**: The contract assumes each manager creates only one scheme (as evidenced by test patterns), but no enforcement mechanism exists. The state mapping design allows arbitrary overwrites.

### Impact Explanation

**Direct Fund Impact**: Users' locked tokens become inaccessible or locked for periods far exceeding their original agreement. If `MinimumLockMinutes` changes from 100 to 1,000,000, users expecting a ~1.6 hour lock face a nearly 2-year lock.

**Symbol Mismatch Impact**: If `Symbol` changes from "ELF" to "APP", the withdrawal's `GetLockedAmount` and `Unlock` operations query the wrong token type, causing transaction failures since the lock ID contains "ELF" tokens, not "APP".

**Affected Parties**: All users who have registered for profits under the scheme before the configuration change. Since TokenHolder schemes typically involve staking for dividends, this could affect numerous participants in DApp profit-sharing.

**Severity Justification**: HIGH - This breaks the fundamental lock/unlock invariant (Critical Invariant #3: "lock/unlock correctness"). Users lose access to funds based on a unilateral change by the scheme manager, with no recovery mechanism. The exploit requires no special privileges beyond the manager's normal role, making it practical for rug-pull scenarios.

### Likelihood Explanation

**Attacker Capabilities**: The scheme manager (who legitimately created the scheme) is the attacker. No additional privileges or vulnerabilities need to be chained.

**Attack Complexity**: Trivial - simply call `CreateScheme` again with different parameters. The function is publicly accessible with no access control beyond standard transaction authentication.

**Feasibility Conditions**: 
- Manager must have created an initial scheme
- Users must have locked tokens via `RegisterForProfits`
- No additional preconditions required

**Detection/Operational Constraints**: No on-chain events distinguish a malicious re-creation from legitimate operations. Users cannot detect the change before attempting withdrawal. No governance or time-lock mechanisms protect configuration changes.

**Probability**: HIGH - The attack is economically rational for malicious managers seeking to extract value or deny user withdrawals. Zero marginal cost to execute (just transaction fees).

### Recommendation

**Code-Level Mitigation**:

Add an existence check at the beginning of `CreateScheme`:

```csharp
public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
{
    Assert(State.TokenHolderProfitSchemes[Context.Sender] == null || 
           State.TokenHolderProfitSchemes[Context.Sender].SchemeId == null, 
           "Scheme already exists for this manager.");
    
    // ... existing implementation
}
```

**Invariant Checks to Add**:
1. Verify scheme configuration immutability after first user registration
2. Add event emission for scheme creation to enable monitoring
3. Consider implementing a scheme update mechanism with governance approval if changes are needed

**Test Cases to Prevent Regression**:
1. Test calling `CreateScheme` twice with same sender - should fail on second call
2. Test that scheme parameters remain unchanged after user locks tokens
3. Test withdrawal fails gracefully if state corruption occurs, with clear error messages

### Proof of Concept

**Required Initial State**:
- Scheme manager address: `ManagerAddr`
- User address: `UserAddr`
- User has 1000 ELF tokens available and approved for TokenHolder contract

**Transaction Steps**:

1. **T1**: `ManagerAddr` calls `CreateScheme(Symbol="ELF", MinimumLockMinutes=100)`
   - Expected: Scheme created with 100-minute lock period

2. **T2**: `UserAddr` calls `RegisterForProfits(SchemeManager=ManagerAddr, Amount=1000)`
   - Expected: 1000 ELF locked, lock timestamp recorded
   - User can withdraw after 100 minutes

3. **T3**: `ManagerAddr` calls `CreateScheme(Symbol="APP", MinimumLockMinutes=1000000)`
   - Expected: Scheme configuration overwritten
   - State now shows Symbol="APP", MinimumLockMinutes=1000000

4. **T4** (101 minutes after T2): `UserAddr` calls `Withdraw(ManagerAddr)`
   - Expected: Withdrawal succeeds after 100 minutes
   - **Actual**: Withdrawal fails because:
     * MinimumLockMinutes check requires 1000000 minutes (line 227-228)
     * GetLockedAmount queries wrong Symbol "APP" instead of "ELF" (line 220-225)
     * Unlock attempts wrong Symbol "APP" (line 230-236)

**Success Condition**: 
The proof demonstrates that after step T3, the withdrawal in T4 fails even though 100+ minutes have elapsed, confirming users cannot access funds due to retroactive configuration changes. The scheme manager successfully modified lock terms after users committed their tokens.

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L159-167)
```csharp
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-236)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L62-71)
```csharp
        var schemeIds = State.ManagingSchemeIds[scheme.Manager];
        if (schemeIds == null)
            schemeIds = new CreatedSchemeIds
            {
                SchemeIds = { schemeId }
            };
        else
            schemeIds.SchemeIds.Add(schemeId);

        State.ManagingSchemeIds[scheme.Manager] = schemeIds;
```
