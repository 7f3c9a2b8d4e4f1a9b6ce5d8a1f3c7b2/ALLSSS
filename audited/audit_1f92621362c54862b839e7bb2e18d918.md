### Title
Secret Sharing Manipulation Allows Consensus Control with > 2/3 Miner Collusion

### Summary
The `RevealSharedInValues()` function reconstructs miners' previous InValues from decrypted secret shares without validating that the revealed InValue matches the previously committed OutValue. When an attacker controls > 2/3 of miners, they can submit colluding fake `DecryptedPieces` to force reconstruction of arbitrary fake InValues for honest miners, manipulating their mining order and corrupting consensus randomness.

### Finding Description

The vulnerability exists in the secret sharing recovery mechanism across multiple contract methods:

**Location 1 - No Validation in RevealSharedInValues:** [1](#0-0) 

The function reconstructs a miner's InValue from all submitted `DecryptedPieces` and directly sets it as `PreviousInValue` without verifying that `Hash(revealedInValue) == OutValue` from the previous round.

**Location 2 - No Validation of DecryptedPieces:** [2](#0-1) 

When miners submit `DecryptedPieces` via `UpdateValueInput`, the contract stores them without cryptographic verification that they are correct decryptions of the `EncryptedPieces` from the previous round.

**Location 3 - Fake PreviousInValue Persists:** [3](#0-2) 

The code only sets `PreviousInValue` if it's empty or null, meaning a fake value set by `RevealSharedInValues` will NOT be overwritten even when the honest miner submits the correct value.

**Location 4 - Fake Value Used for Signature Calculation:** [4](#0-3) 

`SupplyCurrentRoundInformation` reads the `PreviousInValue` from state (potentially the fake value) and uses it to calculate the signature that determines mining order in the next round.

**Root Cause:**
The secret sharing mechanism assumes honest majority participation but lacks cryptographic proofs. With Shamir's Secret Sharing using a 2/3 threshold, an attacker controlling > 2/3 of shares can force reconstruction to ANY predetermined value, regardless of what the honest minority submits.

**Exploitation Path:**
1. Honest miner B publishes `OutValue_B = Hash(InValue_B)` and encrypted shares in Round N-1
2. In Round N, attacker's colluding miners (> 2/3) submit fake `DecryptedPieces` for B's encrypted shares
3. In Round N+1, `RevealSharedInValues` reconstructs using ALL decrypted pieces (requires `minersCount` pieces per line 36)
4. With > 2/3 fake pieces, reconstruction produces `fake_InValue_B` 
5. This fake value is set as B's `PreviousInValue` without validation
6. Even if B submits correct InValue (which passes validation), the fake value persists in state
7. Future calls to `SupplyCurrentRoundInformation` use the fake value to calculate B's signature
8. The fake signature manipulates B's order in subsequent rounds

### Impact Explanation

**Consensus Integrity Violation:**
- Attacker manipulates which miners produce blocks at which times by controlling their signatures
- Signatures directly determine mining order via the formula at: [5](#0-4) 

**Random Number Generation Corruption:**
- Signatures contribute to consensus randomness via: [6](#0-5) 
- Manipulated signatures allow attacker to influence random outcomes

**Block Production Manipulation:**
- Attacker can delay or advance honest miners' time slots
- Affects reward distribution and network fairness
- Enables censorship by consistently pushing honest miners to disadvantageous positions

**Severity: Critical** - Complete subversion of consensus fairness and randomness when precondition is met.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Must control > 2/3 of active miners through Sybil identities
- Each candidate requires 100,000 ELF deposit per: [7](#0-6) 
- Must receive majority votes to become active validators

**Attack Complexity:**
- **HIGH cost** to achieve precondition in well-functioning network (millions of ELF tokens required)
- **LOW complexity** once precondition met - simple submission of fake DecryptedPieces
- **Undetectable** at protocol level - no on-chain mechanism to distinguish fake from real pieces

**Feasibility Conditions:**
- Permissioned/private deployments with insufficient validator diversity
- Compromised election system or coordinated miner collusion
- Network with low voter participation allowing cheap vote manipulation
- Attacker with massive capital willing to lock substantial ELF holdings

**Economic Rationality:**
- Irrational for public mainnet (cost >> potential gain)
- Rational for high-stakes private chains or during governance attacks
- Cost-benefit improves if attacker already controls significant stake

**Likelihood: Medium-Low** - Expensive precondition but technically trivial exploit once achieved. More realistic threat in permissioned deployments or during governance crises.

### Recommendation

**Critical Validation Required:**

1. **Add OutValue Verification in RevealSharedInValues:**
```
After line 50, add:
var expectedOutValue = anotherMinerInPreviousRound.OutValue;
Assert(HashHelper.ComputeFrom(revealedInValue) == expectedOutValue, 
       "Revealed InValue does not match committed OutValue");
```

2. **Implement Cryptographic Proof for DecryptedPieces:**
    - Use verifiable secret sharing schemes (e.g., Feldman VSS, Pedersen VSS)
    - Require zero-knowledge proofs that DecryptedPieces are correct decryptions
    - Validate proofs before accepting DecryptedPieces in PerformSecretSharing

3. **Fix PreviousInValue Override Logic:**
```
In ApplyNormalConsensusData, change lines 14-16 to:
if (previousInValue != null && previousInValue != Hash.Empty)
    RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```
This ensures correct values overwrite any fake values.

4. **Add Invariant Checks:**
    - Before using PreviousInValue in SupplyCurrentRoundInformation, verify:
  `Hash(previousInValue) == previousRound.RealTimeMinersInformation[miner.Pubkey].OutValue`
    - Reject rounds where revealed InValues don't match committed OutValues

5. **Test Cases:**
    - Simulate 5 miners with 4 colluding to submit fake DecryptedPieces
    - Verify reconstruction fails with OutValue mismatch
    - Test that honest miner's correct submission overwrites fake value
    - Ensure signature calculation only uses validated InValues

### Proof of Concept

**Initial State:**
- 5 active miners: Honest (B), Attacker-controlled (A, C, D, E)
- Round N-1 completed with B's OutValue_B = Hash(InValue_B) on-chain
- B's EncryptedPieces distributed to all miners

**Attack Sequence:**

1. **Round N - UpdateValue transactions:**
   - Miner A submits `UpdateValueInput` with `DecryptedPieces["B"] = fake_share_A`
   - Miner C submits `UpdateValueInput` with `DecryptedPieces["B"] = fake_share_C`
   - Miner D submits `UpdateValueInput` with `DecryptedPieces["B"] = fake_share_D`
   - Miner E submits `UpdateValueInput` with `DecryptedPieces["B"] = fake_share_E`
   - Miner B submits `UpdateValueInput` with correct `DecryptedPieces["B"] = correct_share_B`
   - All 5 DecryptedPieces stored on-chain without validation

2. **Round N+1 - NextRound transaction:**
   - Miner A produces NextRound block
   - `RevealSharedInValues` called with currentRound = Round N+1
   - Function checks: B's `DecryptedPieces.Count >= 5` ✓
   - Function reconstructs using Shamir's with threshold=3: `DecodeSecret([fake_share_A, fake_share_C, fake_share_D, fake_share_E, correct_share_B], orders, 3)`
   - Reconstruction produces: `fake_InValue_B` (attacker predetermined this value)
   - Sets: `Round[N+1].RealTimeMinersInformation["B"].PreviousInValue = fake_InValue_B`
   - **No validation** that `Hash(fake_InValue_B) == OutValue_B`

3. **B attempts to correct in Round N+1:**
   - B produces block, submits correct `InValue_B`
   - Validation passes: `Hash(InValue_B) == OutValue_B` ✓
   - But `ApplyNormalConsensusData` skips update: `PreviousInValue` already set
   - Fake value persists in state

4. **Round N+2 - Manipulation takes effect:**
   - If B misses time slot, `SupplyCurrentRoundInformation` called
   - Reads: `previousInValue = Round[N+2].RealTimeMinersInformation["B"].PreviousInValue = fake_InValue_B`
   - Calculates: `signature = Round[N+1].CalculateSignature(fake_InValue_B)`
   - Fake signature determines B's order in Round N+3
   - Attacker controls when B produces blocks

**Expected vs Actual:**
- **Expected:** Revealed InValue validated against OutValue, fake shares rejected
- **Actual:** Fake InValue accepted and persists, manipulating consensus scheduling

**Success Condition:** 
Monitor B's `FinalOrderOfNextRound` across multiple rounds - it will differ from what B's correct InValue would produce, confirming attacker manipulation.

### Notes

The vulnerability is **technically valid** but has a **critical precondition**: achieving > 2/3 miner control requires substantial economic investment in the AElf network. In a healthy public blockchain with distributed token ownership and active governance, this attack is prohibitively expensive. However, the vulnerability represents a **systemic design flaw** in the secret sharing recovery mechanism that should be addressed through cryptographic validation, regardless of economic barriers. The risk is elevated in permissioned deployments, private chains, or scenarios involving miner compromise rather than pure Sybil attacks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L49-52)
```csharp
            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L14-16)
```csharp
        if (RealTimeMinersInformation[pubkey].PreviousInValue == Hash.Empty ||
            RealTimeMinersInformation[pubkey].PreviousInValue == null)
            RealTimeMinersInformation[pubkey].PreviousInValue = previousInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L186-200)
```csharp
            if (previousRound != null && previousRound.RealTimeMinersInformation.ContainsKey(miner.Pubkey))
            {
                // Check this miner's:
                // 1. PreviousInValue in current round; (means previous in value recovered by other miners)
                // 2. InValue in previous round; (means this miner hasn't produce blocks for a while)
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L36-52)
```csharp
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }

        State.CandidateAdmins[pubkey] = input.Admin;

        var pubkeyByteString = ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(pubkey));

        var newAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[input.Admin] ?? new PubkeyList();
        if (!newAdminManagedPubkeys.Value.Contains(pubkeyByteString))
            newAdminManagedPubkeys.Value.Add(pubkeyByteString);
        State.ManagedCandidatePubkeysMap[input.Admin] = newAdminManagedPubkeys;

        var oldAdminManagedPubkeys = State.ManagedCandidatePubkeysMap[Context.Sender] ?? new PubkeyList();
        if (oldAdminManagedPubkeys.Value.Contains(pubkeyByteString))
```
