### Title
LIB Calculation Failure During Miner List Expansion Due to Mismatched Threshold Basis

### Summary
The `LastIrreversibleBlockHeightCalculator.Deconstruct()` method uses the current round's total miner count to calculate the consensus threshold (`MinersCountOfConsent`), but checks implied irreversible block heights from the previous round. When the miner list increases at term change, new miners cannot contribute previous round data, making the threshold mathematically impossible to meet and causing LIB advancement to halt until sufficient old miners participate.

### Finding Description

The vulnerability exists in the LIB calculation logic: [1](#0-0) 

The threshold `MinersCountOfConsent` is calculated as `(current_miner_count * 2 / 3) + 1`: [2](#0-1) 

The root cause is a three-step mismatch:

1. **Threshold Calculation**: `MinersCountOfConsent` is based on `_currentRound.RealTimeMinersInformation.Count`
2. **Data Source**: `impliedIrreversibleHeights` are extracted from `_previousRound` filtered by miners who mined in current round: [3](#0-2) 
3. **Miner Identification**: Only miners from current round who have mined are considered: [4](#0-3) 

When the miner list increases (e.g., from 10 to 13 miners at term change marked by `IsMinerListJustChanged = true`): [5](#0-4) 

The new 3 miners have no entries in the previous round, so maximum possible `impliedIrreversibleHeights.Count` is 10, but `MinersCountOfConsent` requires 9 based on 13 miners. If only 8 of the original miners mine in the current round, the check fails (8 < 9), forcing `libHeight = 0`.

The LIB calculation is invoked during every `UpdateValue` call: [6](#0-5) 

**Why Existing Protections Fail**: The `IsMinerListJustChanged` flag exists but is NOT checked in the `Deconstruct()` method. It is only used for miner validation and extra block producer logic, not for LIB threshold adjustment.

### Impact Explanation

**Operational Impact - DoS of Consensus Finality:**
- LIB (Last Irreversible Block) stops advancing when miner count increases
- Blocks remain unconfirmed as irreversible, degrading network finality guarantees
- Cross-chain operations depending on LIB verification are blocked
- User confidence in transaction finality is undermined

**Quantified Damage:**
- Affects every term change where miner count increases (regular network operations)
- Duration: Multiple rounds until enough original miners participate (potentially dozens of blocks)
- Scope: All network participants relying on finality (users, dApps, cross-chain bridges)

**Affected Parties:**
- All users waiting for transaction finality
- Cross-chain bridge operators requiring LIB confirmation
- dApps depending on `ConfirmedIrreversibleBlockHeight` for critical operations

**Severity Justification**: HIGH - This is not a funds-at-risk vulnerability, but it causes deterministic denial-of-service to a critical consensus invariant (LIB advancement) during normal network operations.

### Likelihood Explanation

**Attacker Capabilities**: None required - this is a logic bug triggered by normal protocol operations.

**Attack Complexity**: Zero - automatically occurs at term changes with miner list expansion.

**Feasibility Conditions**:
- Occurs when `GenerateFirstRoundOfNewTerm` creates a round with more miners than the previous term
- Term changes happen regularly (configured interval, typically yearly)
- Miner list increases are expected as the network grows

**Probability**: HIGH - Guaranteed to occur at every term change that adds miners. The test suite confirms miner count increases over terms but does not validate LIB calculation under these conditions: [7](#0-6) 

**Detection**: LIB stall is observable via `ConfirmedIrreversibleBlockHeight` not advancing, but may be mistaken for network issues rather than a protocol bug.

### Recommendation

**Code-Level Mitigation:**

Modify `LastIrreversibleBlockHeightCalculator.Deconstruct()` to handle miner list changes:

```csharp
public void Deconstruct(out long libHeight)
{
    if (_currentRound.IsEmpty || _previousRound.IsEmpty) 
    {
        libHeight = 0;
        return;
    }

    var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
    var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
    
    // Use the intersection count when miner list changed, otherwise use current count
    var effectiveThreshold = _currentRound.IsMinerListJustChanged 
        ? impliedIrreversibleHeights.Count.Mul(2).Div(3).Add(1)  // Based on available data
        : _currentRound.MinersCountOfConsent;                     // Based on current list
    
    if (impliedIrreversibleHeights.Count < effectiveThreshold)
    {
        libHeight = 0;
        return;
    }

    libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
}
```

**Alternative Approach**: Skip LIB calculation entirely when `IsMinerListJustChanged` is true, carrying forward the previous LIB height.

**Invariant Checks to Add:**
- Assert that when `IsMinerListJustChanged` is true, threshold calculation accounts for data availability
- Validate that `MinersCountOfConsent` never exceeds the maximum possible contributors from previous round

**Test Cases to Prevent Regression:**
1. Test LIB calculation when miner list increases from N to N+K miners
2. Test LIB calculation when miner list decreases from N to N-K miners  
3. Verify LIB continues advancing across term boundaries with miner changes
4. Test edge case where only minority of old miners participate in new term

### Proof of Concept

**Required Initial State:**
- Previous Round N: 10 miners (A-J), all participated and set `ImpliedIrreversibleBlockHeight > 0`
- Term change occurs via `NextTerm` with new miner list
- Current Round N+1: 13 miners (A-J from previous + 3 new miners K-M)
- `IsMinerListJustChanged = true` in Round N+1

**Transaction Steps:**
1. Term N ends with 10 miners having valid implied heights
2. `NextTerm` is called, generating Round N+1 with 13 miners
3. In Round N+1, only 8 of the original 10 miners (e.g., A-H) successfully mine blocks
4. Miner A calls `UpdateValue` with their consensus information
5. `ProcessUpdateValue` invokes `LastIrreversibleBlockHeightCalculator.Deconstruct()`

**Expected Result:**
- `_currentRound.MinersCountOfConsent` = (13 * 2 / 3) + 1 = 9
- `impliedIrreversibleHeights` from previous round = 8 (only A-H from previous round)
- Check: 8 < 9 â†’ FAILS
- `libHeight = 0` (LIB does not advance)

**Actual Result:**
LIB remains at the previous confirmed height despite 8/10 original miners participating (80% consensus achieved among eligible miners).

**Success Condition:**
Monitor `ConfirmedIrreversibleBlockHeight` in Round N+1 - it will not increase despite sufficient old-miner participation, confirming the threshold calculation is incorrectly based on the new miner count rather than the intersection of available data sources.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L40-42)
```csharp
        round.RoundNumber = currentRoundNumber.Add(1);
        round.TermNumber = currentTermNumber.Add(1);
        round.IsMinerListJustChanged = true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L266-282)
```csharp
        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/MinersCountTest.cs (L20-136)
```csharp
    /// <summary>
    ///     test:Change the number of miners when term changed
    /// </summary>
    /// <returns></returns>
    [IgnoreOnCIFact]
    public async Task AEDPoSContract_ChangeMinersCount_Test()
    {
        const int termIntervalMin = 31536000 / 60;

        var maxCount = ValidationDataCenterKeyPairs.Count;
        await InitializeCandidates(maxCount);

        var firstRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());

        var randomHashes = Enumerable.Range(0, EconomicContractsTestConstants.InitialCoreDataCenterCount)
            .Select(_ => HashHelper.ComputeFrom("randomHashes")).ToList();
        var triggers = Enumerable.Range(0, EconomicContractsTestConstants.InitialCoreDataCenterCount).Select(i =>
            new AElfConsensusTriggerInformation
            {
                Pubkey = ByteString.CopyFrom(InitialCoreDataCenterKeyPairs[i].PublicKey),
                InValue = randomHashes[i]
            }).ToDictionary(t => t.Pubkey.ToHex(), t => t);

        var voter = GetElectionContractTester(VoterKeyPairs[0]);
        foreach (var candidateKeyPair in ValidationDataCenterKeyPairs)
        {
            var voteResult = await voter.Vote.SendAsync(new VoteMinerInput
            {
                CandidatePubkey = candidateKeyPair.PublicKey.ToHex(),
                Amount = 10 + new Random().Next(1, 10),
                EndTimestamp = TimestampHelper.GetUtcNow().AddDays(100)
            });
            voteResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
        }

        byte[] randomNumber;
        foreach (var minerInRound in firstRound.RealTimeMinersInformation.Values.OrderBy(m => m.Order))
        {
            var currentKeyPair = InitialCoreDataCenterKeyPairs.First(p => p.PublicKey.ToHex() == minerInRound.Pubkey);

            KeyPairProvider.SetKeyPair(currentKeyPair);

            BlockTimeProvider.SetBlockTime(minerInRound.ExpectedMiningTime);

            var tester = GetAEDPoSContractStub(currentKeyPair);
            var headerInformation =
                (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(triggers[minerInRound.Pubkey]
                    .ToBytesValue())).ToConsensusHeaderInformation();

            randomNumber = await GenerateRandomProofAsync(currentKeyPair);
            // Update consensus information.
            var toUpdate =
                headerInformation.Round.ExtractInformationToUpdateConsensus(minerInRound.Pubkey,
                    ByteString.CopyFrom(randomNumber));
            await tester.UpdateValue.SendAsync(toUpdate);
        }

        var changeTermTime = BlockchainStartTimestamp.ToDateTime();
        BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());

        var nextTermInformation = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextRound,
                Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
            }.ToBytesValue())).ToConsensusHeaderInformation();

        var nextRoundInput = NextRoundInput.Parser.ParseFrom(nextTermInformation.Round.ToByteArray());
        randomNumber = await GenerateRandomProofAsync(BootMinerKeyPair);
        nextRoundInput.RandomNumber = ByteString.CopyFrom(randomNumber);
        await AEDPoSContractStub.NextRound.SendAsync(nextRoundInput);
        changeTermTime = BlockchainStartTimestamp.ToDateTime().AddMinutes(termIntervalMin).AddSeconds(10);
        BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());

        nextTermInformation = (await AEDPoSContractStub.GetConsensusExtraData.CallAsync(
            new AElfConsensusTriggerInformation
            {
                Behaviour = AElfConsensusBehaviour.NextTerm,
                Pubkey = ByteString.CopyFrom(BootMinerKeyPair.PublicKey)
            }.ToBytesValue())).ToConsensusHeaderInformation();

        var nextTermInput = NextTermInput.Parser.ParseFrom(nextTermInformation.Round.ToByteArray());
        randomNumber = await GenerateRandomProofAsync(BootMinerKeyPair);
        nextTermInput.RandomNumber = ByteString.CopyFrom(randomNumber);
        var transactionResult = await AEDPoSContractStub.NextTerm.SendAsync(nextTermInput);
        transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

        var newMinerStub = GetAEDPoSContractStub(ValidationDataCenterKeyPairs[0]);
        var termCount = 0;
        var minerCount = 0;
        while (minerCount < maxCount)
        {
            var currentRound = await newMinerStub.GetCurrentRoundInformation.CallAsync(new Empty());
            var firstPubKey = currentRound.RealTimeMinersInformation.Keys.First();
            var keypair = ValidationDataCenterKeyPairs.First(o => o.PublicKey.ToHex() == firstPubKey);
            newMinerStub = GetAEDPoSContractStub(keypair);

            minerCount = currentRound.RealTimeMinersInformation.Count;
            Assert.Equal(AEDPoSContractTestConstants.SupposedMinersCount.Add(termCount.Mul(2)), minerCount);

            changeTermTime = BlockchainStartTimestamp.ToDateTime()
                .AddMinutes((termCount + 2).Mul(termIntervalMin)).AddSeconds(10);
            BlockTimeProvider.SetBlockTime(changeTermTime.ToTimestamp());
            var nextRoundInformation = (await newMinerStub.GetConsensusExtraData.CallAsync(
                new AElfConsensusTriggerInformation
                {
                    Behaviour = AElfConsensusBehaviour.NextTerm,
                    Pubkey = ByteStringHelper.FromHexString(currentRound.RealTimeMinersInformation.ElementAt(0).Value
                        .Pubkey)
                }.ToBytesValue())).ToConsensusHeaderInformation();
            nextTermInput = NextTermInput.Parser.ParseFrom(nextRoundInformation.Round.ToByteArray());
            randomNumber = await GenerateRandomProofAsync(keypair);
            nextTermInput.RandomNumber = ByteString.CopyFrom(randomNumber);
            await newMinerStub.NextTerm.SendAsync(nextTermInput);
            termCount++;
        }
    }
```
