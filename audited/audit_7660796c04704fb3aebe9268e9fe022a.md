# Audit Report

## Title
Insufficient Validation in ChangeMethodFeeController Allows Governance Bypass via Malicious Contract

## Summary
The `ChangeMethodFeeController` function in the AEDPoS consensus contract lacks validation to ensure that the `ContractAddress` field in the input `AuthorityInfo` points to a legitimate governance contract (Parliament, Association, or Referendum). This allows an attacker who achieves Parliament approval to set an arbitrary contract as the authority validator and their own EOA as the controller address, gaining permanent unilateral control over method fee settings and bypassing the intended governance mechanism.

## Finding Description

The vulnerability exists in the `ChangeMethodFeeController` function which accepts any `AuthorityInfo` input and validates it only by calling `CheckOrganizationExist` on the provided contract address. [1](#0-0) 

The `CheckOrganizationExist` helper method makes a cross-contract call to `ValidateOrganizationExist` on whatever contract address is provided in the `AuthorityInfo` input, without verifying that this contract is one of the legitimate governance system contracts: [2](#0-1) 

**Attack Vector:**

1. Attacker deploys a malicious contract implementing a `ValidateOrganizationExist` method that always returns `true`
2. Attacker creates a Parliament proposal to change the method fee controller with `AuthorityInfo` containing: `{ContractAddress: MaliciousContract, OwnerAddress: AttackerEOA}`
3. If Parliament approves, the controller is updated to the malicious configuration
4. Subsequently, the `SetMethodFee` function only verifies that the caller equals the stored `OwnerAddress`, granting the attacker direct control: [3](#0-2) 

**Why Existing Protections Fail:**

The AElf system provides `Context.GetSystemContractNameToAddressMapping()` to validate legitimate system contracts, which is used in other parts of the codebase to ensure callers are authorized system contracts. However, this validation is not applied in `ChangeMethodFeeController`. The function only validates that the organization "exists" according to the provided contract, not that the contract itself is legitimate.

Legitimate governance contracts like Parliament validate organization existence by checking contract state: [4](#0-3) 

A malicious contract can implement this method to always return `true`, bypassing the intended organizational approval requirement. In proper governance flow, the `OwnerAddress` should be a virtual organization address that can only send transactions through proposal execution mechanisms: [5](#0-4) 

## Impact Explanation

**High Impact - Governance Bypass and Consensus Disruption:**

Once the malicious controller is set, the attacker gains permanent unilateral control over method fee settings for critical consensus operations including `InitialAElfConsensusContract`, `FirstRound`, `UpdateValue`, `UpdateTinyBlockInformation`, `NextRound`, and `NextTerm`. [6](#0-5) 

**Specific Harms:**

1. **Denial of Service**: Setting extremely high fees for consensus methods can halt block production entirely
2. **Economic Manipulation**: Arbitrarily adjusting fees disrupts network economics and can favor specific actors
3. **Permanent Governance Bypass**: Violates the fundamental security invariant that method fee changes require organizational approval, persisting until governance passes another corrective proposal

This affects all network participants, miners, validators, and the integrity of the consensus mechanism itself.

## Likelihood Explanation

**Moderate Likelihood:**

The attack requires two Parliament proposals to be approved:
1. Contract deployment approval (on mainnet where `ContractDeploymentAuthorityRequired = true`)
2. Controller change approval

While this creates significant friction, several factors make the attack realistic:

- **Lack of Technical Safeguards**: The code provides no validation that would prevent this even if governance is careful
- **Proposal Obfuscation**: Technical complexity of AuthorityInfo parameters could obscure malicious intent
- **Irreversibility**: Once executed, the attacker maintains control until another governance proposal reverses it

The vulnerability fundamentally stems from missing technical validation in the code that allows mis-scoped privileges, not from compromised keys or pure social engineering.

## Recommendation

Add validation to ensure `ContractAddress` in `AuthorityInfo` points to a legitimate governance system contract. The implementation should verify the contract address is one of the three authorized governance contracts using the system contract registry:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        authorityInfo.ContractAddress == parliamentAddress ||
        authorityInfo.ContractAddress == associationAddress ||
        authorityInfo.ContractAddress == referendumAddress,
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

Apply this fix consistently across all contracts implementing the ACS1 standard.

## Proof of Concept

```csharp
[Fact]
public async Task ChangeMethodFeeController_MaliciousContract_Bypass_Test()
{
    // Step 1: Deploy malicious contract that always returns true for ValidateOrganizationExist
    var maliciousContractCode = /* Contract code with ValidateOrganizationExist returning true */;
    var maliciousContractAddress = await DeployContractAsync(maliciousContractCode);
    
    // Step 2: Get current controller (should be Parliament default org)
    var currentController = await AEDPoSContractStub.GetMethodFeeController.CallAsync(new Empty());
    var defaultOrg = await ParliamentContractStub.GetDefaultOrganizationAddress.CallAsync(new Empty());
    currentController.OwnerAddress.ShouldBe(defaultOrg);
    
    // Step 3: Create Parliament proposal to change controller to malicious setup
    var attackerAddress = SampleAddress.AddressList[0];
    var proposalId = await CreateProposalAsync(ConsensusContractAddress,
        currentController.OwnerAddress, 
        nameof(AEDPoSContractImplContainer.AEDPoSContractImplStub.ChangeMethodFeeController), 
        new AuthorityInfo
        {
            OwnerAddress = attackerAddress,  // Attacker's EOA
            ContractAddress = maliciousContractAddress  // Malicious contract
        });
    
    // Step 4: Approve and release proposal
    await ApproveWithMinersAsync(proposalId);
    var releaseResult = await ParliamentContractStub.Release.SendAsync(proposalId);
    releaseResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Step 5: Verify controller changed to malicious setup
    var newController = await AEDPoSContractStub.GetMethodFeeController.CallAsync(new Empty());
    newController.OwnerAddress.ShouldBe(attackerAddress);
    newController.ContractAddress.ShouldBe(maliciousContractAddress);
    
    // Step 6: Attacker can now directly set method fees without governance approval
    var attackerStub = GetAEDPoSContractStub(attackerAddress);
    var setFeeResult = await attackerStub.SetMethodFee.SendAsync(new MethodFees
    {
        MethodName = nameof(AEDPoSContractImplContainer.AEDPoSContractImplStub.UpdateValue),
        Fees = { new MethodFee { Symbol = "ELF", BasicFee = 1000000000 } }  // Extremely high fee
    });
    
    // This should succeed, demonstrating complete governance bypass
    setFeeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L13-23)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L40-51)
```csharp
        if (new List<string>
            {
                nameof(InitialAElfConsensusContract), nameof(FirstRound), nameof(UpdateValue),
                nameof(UpdateTinyBlockInformation), nameof(NextRound), nameof(NextTerm)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };

        return State.TransactionFees[input.Value];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
