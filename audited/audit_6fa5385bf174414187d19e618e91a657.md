### Title
DepositBalance Overwrite Vulnerability in EnableConnector Allows Accounting Corruption and Fund Loss

### Summary
The `EnableConnector()` function directly overwrites `State.DepositBalance[toConnector.Symbol]` without checking for existing balances or preventing re-enablement. This allows anyone to corrupt the deposit accounting after trading has occurred, making accumulated funds untracked and breaking the Bancor pricing mechanism, effectively causing fund loss and protocol insolvency.

### Finding Description

The `EnableConnector()` function contains a critical accounting flaw at line 297: [1](#0-0) 

This line directly assigns `needDeposit.NeedAmount` to `DepositBalance` without:
1. Checking if the connector is already enabled
2. Preserving any existing DepositBalance value
3. Requiring authorization (no `AssertPerformedByConnectorController()` call) [2](#0-1) 

Unlike other sensitive functions (`UpdateConnector`, `AddPairConnector`, `SetFeeRate`), `EnableConnector` lacks authorization checks: [3](#0-2) 

The `DepositBalance` accumulates during normal trading operations. In `Buy()`: [4](#0-3) 

And in `Sell()`: [5](#0-4) 

The `GetNeededDeposit()` calculation is designed for initial connector enablement: [6](#0-5) 

When called on an already-enabled connector where tokens are distributed, `amountOutOfTokenConvert` becomes near-zero, resulting in `needDeposit = 0` or a very small value. This overwrites the accumulated DepositBalance.

The corrupted DepositBalance breaks pricing since `GetSelfBalance()` relies on it for deposit accounts: [7](#0-6) 

### Impact Explanation

**Direct Fund Impact:**
- After normal trading accumulates DepositBalance to 100,000 ELF, calling `EnableConnector` again can reset it to 0
- The contract physically holds 100,000 ELF but accounting shows 0 ELF
- These funds become untracked and effectively lost to the protocol
- Users cannot properly sell tokens due to corrupted pricing calculations or underflow errors in `Sell()` operations

**Protocol Impact:**
- Bancor pricing mechanism completely breaks as `GetSelfBalance()` returns incorrect values
- The reserve accounting invariant is violated: physical reserves ≠ tracked reserves
- Protocol becomes insolvent from user perspective
- All subsequent buy/sell operations use corrupted pricing

**Severity Justification:** CRITICAL
- Direct theft/loss of accumulated deposit funds
- Anyone can execute without authorization
- Breaks core protocol functionality permanently
- No recovery mechanism exists

### Likelihood Explanation

**Attacker Capabilities:**
- Any address can call `EnableConnector()` - no authorization required
- Attacker only needs to know a valid enabled token symbol
- No special permissions or privileges needed

**Attack Complexity:**
- Extremely simple: single function call with standard parameters
- Call `EnableConnector(ToBeConnectedTokenInfo { TokenSymbol = "USDT", AmountToTokenConvert = 0 })`
- No complex transaction ordering or timing requirements

**Feasibility Conditions:**
- Works on any connector after initial legitimate enablement
- Most effective after significant trading volume has accumulated DepositBalance
- Attacker cost is minimal (only transaction gas fee)

**Detection Constraints:**
- Attack appears as normal EnableConnector call
- No obvious red flags in transaction data
- Damage only visible in accounting discrepancy

**Probability:** HIGH
- No technical barriers to execution
- Economically rational for griefing or competitor attacks
- Can be executed repeatedly on different connectors

### Recommendation

**Immediate Fix:**

1. Add authorization check at the start of `EnableConnector()`:
```
AssertPerformedByConnectorController();
```

2. Add re-enablement prevention check:
```
Assert(!toConnector.IsPurchaseEnabled && !fromConnector.IsPurchaseEnabled, 
       "Connector already enabled");
```

3. Add DepositBalance preservation check:
```
Assert(State.DepositBalance[toConnector.Symbol] == 0, 
       "DepositBalance must be zero before enabling");
```

4. Or modify line 297 to accumulate instead of overwrite:
```
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

**Invariant Checks:**
- `DepositBalance` should only be modified through Buy/Sell after initial EnableConnector
- EnableConnector should be callable exactly once per connector pair
- Only connector controller should enable connectors

**Test Cases:**
- Test calling EnableConnector twice on same connector (should fail)
- Test calling EnableConnector without authorization (should fail)
- Test that DepositBalance accumulation through Buy/Sell is preserved
- Test calling EnableConnector after Buy operations have accumulated balance

### Proof of Concept

**Initial State:**
1. Connector pair created for "USDT" and "(NT)USDT"
2. EnableConnector called legitimately: `DepositBalance[(NT)USDT] = 10,000 ELF`
3. Multiple users call Buy(), accumulating: `DepositBalance[(NT)USDT] = 100,000 ELF`
4. Contract physically holds 100,000 ELF in deposits

**Attack Execution:**
1. Attacker (any address) calls:
   ```
   EnableConnector({
     TokenSymbol: "USDT",
     AmountToTokenConvert: 0
   })
   ```

2. GetNeededDeposit calculates:
   - Most USDT tokens already in contract from step 2
   - `amountOutOfTokenConvert ≈ 0`
   - Returns `NeedAmount = 0`

3. Line 297 executes: `State.DepositBalance[(NT)USDT] = 0`

**Result:**
- **Expected:** DepositBalance remains 100,000 ELF (preserves accumulated balance)
- **Actual:** DepositBalance overwritten to 0 ELF
- **Verification:** Query `GetDepositConnectorBalance("USDT")` shows VirtualBalance only, missing 100,000 ELF
- **Impact:** Contract holds 100,000 ELF but accounting shows 0; pricing broken; users cannot sell properly

**Success Condition:** 
DepositBalance corrupted from 100,000 to 0 while contract still holds physical 100,000 ELF tokens.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-64)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L141-141)
```csharp
        State.DepositBalance[fromConnector.Symbol] = State.DepositBalance[fromConnector.Symbol].Add(amountToPay);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L193-194)
```csharp
        State.DepositBalance[toConnector.Symbol] =
            State.DepositBalance[toConnector.Symbol].Sub(amountToReceive);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-275)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L297-297)
```csharp
        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-389)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-84)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }
```
