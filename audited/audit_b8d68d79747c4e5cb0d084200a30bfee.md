### Title
LIB Height Deflation Attack via Malicious ImpliedIrreversibleBlockHeight Reporting

### Summary
Malicious miners can arbitrarily report low `ImpliedIrreversibleBlockHeight` values without validation, causing the Last Irreversible Block (LIB) height calculation to select an artificially low value. With approximately one-third of miners colluding, this attack prevents newer blocks from being finalized, disrupts cross-chain operations, and potentially enables long-range reorganization attacks.

### Finding Description

The LIB calculation in `Deconstruct()` selects the irreversible block height at index `(count - 1) / 3` from sorted `ImpliedIrreversibleBlockHeight` values reported by miners in the previous round. [1](#0-0) 

The `ImpliedIrreversibleBlockHeight` values are filtered from the previous round for miners who have mined in the current round, excluding only zero values: [2](#0-1) 

When miners produce blocks, their `ImpliedIrreversibleBlockHeight` is directly assigned from the `UpdateValueInput` without bounds validation: [3](#0-2) 

The only validation enforced is that the value cannot decrease from the miner's previous report: [4](#0-3) 

While honest miners set `ImpliedIrreversibleBlockHeight` to `Context.CurrentHeight`: [5](#0-4) 

There is **no validation** requiring miners to report values close to the current block height or current LIB. A malicious miner can set their value to 1 (or any low positive value) in their first block and maintain this artificially low value indefinitely, as long as it doesn't decrease.

### Impact Explanation

**Consensus Integrity Compromise**: For a network with N miners where all participate, the LIB is selected at index `(N-1)/3`. If approximately N/3 malicious miners report artificially low heights (e.g., 1), the selected LIB value will be one of these low values rather than reflecting the actual irreversible blockchain state.

For example, with 7 miners:
- Selection index: (7-1)/3 = 2 (3rd lowest value)
- If 3 malicious miners report height 1, the LIB becomes 1
- Legitimate blocks at heights 2+ cannot be finalized

**Concrete Harms**:
1. **Finalization Stalling**: Blocks remain unfinalized indefinitely, eliminating finality guarantees for transactions
2. **Cross-Chain Operations Disrupted**: Cross-chain indexing and verification rely on LIB heights, rendering cross-chain bridges inoperable
3. **Reorganization Risk**: An artificially low LIB allows potential reorganization of recent blocks that should be irreversible
4. **Economic Impact**: Users and applications cannot trust transaction finality, undermining the blockchain's utility

**Affected Parties**: All network participants, cross-chain systems, and any application requiring transaction finality guarantees.

### Likelihood Explanation

**Attacker Capabilities**: Requires control of approximately one-third of the active miner set (standard Byzantine fault tolerance assumption). Attackers must be elected miners capable of producing blocks.

**Attack Complexity**: Low - attackers simply modify their consensus nodes to report a constant low value (e.g., 1) for `ImpliedIrreversibleBlockHeight` instead of `Context.CurrentHeight`.

**Feasibility Conditions**:
- Attackers must be part of the elected miner set
- Must actively participate in block production
- No special timing or coordination beyond maintaining mining participation

**Detection and Disincentives**: The system has no detection mechanism for incorrect `ImpliedIrreversibleBlockHeight` reporting. The evil miner detection logic only identifies miners who miss time slots, not those reporting incorrect heights: [6](#0-5) 

There are no economic penalties, reputation costs, or slashing mechanisms for this behavior.

**Probability**: High - the attack is within the standard 1/3 Byzantine actor threat model, requires minimal sophistication, and faces no countermeasures.

### Recommendation

**Immediate Fix**: Add validation in `LibInformationValidationProvider` to enforce that `ImpliedIrreversibleBlockHeight` must be within a reasonable range of the current block height:

```csharp
// In LibInformationValidationProvider.ValidateHeaderInformation()
if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
    providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0)
{
    var providedHeight = providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight;
    var currentHeight = validationContext.CurrentHeight; // Need to add this to context
    var currentLIB = baseRound.ConfirmedIrreversibleBlockHeight;
    
    // Must not decrease
    if (baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight > providedHeight)
    {
        validationResult.Message = "Incorrect implied lib height.";
        return validationResult;
    }
    
    // Must be at least as high as confirmed LIB
    if (providedHeight < currentLIB)
    {
        validationResult.Message = "ImpliedIrreversibleBlockHeight cannot be below confirmed LIB.";
        return validationResult;
    }
    
    // Must be within reasonable range of current height (e.g., current height - tolerance)
    if (providedHeight < currentHeight - MaxAcceptableLibLag)
    {
        validationResult.Message = "ImpliedIrreversibleBlockHeight too far behind current height.";
        return validationResult;
    }
}
```

**Additional Safeguards**:
1. Add outlier detection in LIB calculation to exclude values that deviate significantly from the median
2. Implement slashing or reputation penalties for miners consistently reporting suspiciously low values
3. Add monitoring and alerting for abnormal LIB progression

**Test Cases**:
1. Test that miners cannot set `ImpliedIrreversibleBlockHeight` below confirmed LIB
2. Test that miners cannot set values significantly below current height
3. Test that LIB advances normally even with some miners offline or reporting edge-case values

### Proof of Concept

**Initial State**:
- Network with 7 elected miners (M1-M7)
- Current block height: 1000
- Current confirmed LIB: 950
- 3 miners (M1, M2, M3) are malicious

**Attack Sequence**:

1. **Round N (Height ~1000)**:
   - M1 produces block at height 1000, sets `ImpliedIrreversibleBlockHeight = 1`
   - M2 produces block at height 1001, sets `ImpliedIrreversibleBlockHeight = 1`
   - M3 produces block at height 1002, sets `ImpliedIrreversibleBlockHeight = 1`
   - M4-M7 honestly set `ImpliedIrreversibleBlockHeight = Context.CurrentHeight`

2. **Round N+1 (Height ~1007)**:
   - When any miner calls `UpdateValue`, `LastIrreversibleBlockHeightCalculator.Deconstruct()` executes
   - Retrieves `ImpliedIrreversibleBlockHeight` from Round N for all 7 miners
   - Sorted heights: [1, 1, 1, 1003, 1004, 1005, 1006]
   - Selects index (7-1)/3 = 2: `libHeight = sortedHeights[2] = 1`
   - LIB is set to 1 instead of advancing to ~950+

3. **Continued Rounds**:
   - Malicious miners maintain `ImpliedIrreversibleBlockHeight = 1`
   - LIB remains frozen at 1
   - Blocks 2-1100+ cannot be finalized

**Expected vs Actual**:
- **Expected**: LIB should advance to approximately current_height - rounds_for_consensus (e.g., ~1000)
- **Actual**: LIB remains at 1, preventing all subsequent blocks from finalization

**Success Condition**: Monitor the `IrreversibleBlockFound` event - it will show LIB stuck at 1 while block height continues advancing, proving successful height deflation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-32)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L12-19)
```csharp
    public List<long> GetSortedImpliedIrreversibleBlockHeights(List<string> specificPublicKeys)
    {
        var heights = RealTimeMinersInformation.Values.Where(i => specificPublicKeys.Contains(i.Pubkey))
            .Where(i => i.ImpliedIrreversibleBlockHeight > 0)
            .Select(i => i.ImpliedIrreversibleBlockHeight).ToList();
        heights.Sort();
        return heights;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-248)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L118-118)
```csharp
        updatedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight = Context.CurrentHeight;
```
