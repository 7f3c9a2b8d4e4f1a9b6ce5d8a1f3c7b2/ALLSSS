### Title
Critical Token Theft via Negative Amount in AdvanceResourceToken

### Summary
The `AdvanceResourceToken` function lacks validation that `input.Amount` is positive, allowing attackers to pass negative values. This causes the internal `DoTransfer` logic to reverse direction, enabling direct theft of tokens from contract addresses while corrupting the `AdvancedResourceToken` state to negative values.

### Finding Description

The `AdvanceResourceToken` function accepts an `AdvanceResourceTokenInput` with an `int64 amount` field that can be negative. [1](#0-0) 

The function only validates the contract address and resource token symbol, but never checks if `input.Amount` is positive: [2](#0-1) 

When a negative amount is passed, line 418-420 updates the state by adding the negative value (decreasing the tracked amount, potentially to negative), and line 421 calls `DoTransfer` with the negative amount.

The `DoTransfer` function applies the amount with opposite signs to sender and recipient without validating the amount's sign: [3](#0-2) 

Specifically, line 104 does `ModifyBalance(from, symbol, -amount)` and line 105 does `ModifyBalance(to, symbol, amount)`. When `amount` is negative (e.g., -100), this becomes:
- `ModifyBalance(sender, symbol, 100)` → ADDS tokens to sender
- `ModifyBalance(contractAddress, symbol, -100)` → SUBTRACTS tokens from contract

The `ModifyBalance` function will allow this as long as the contract has sufficient balance: [4](#0-3) 

In contrast, the complementary `TakeResourceTokenBack` function properly validates the amount against the advanced balance: [5](#0-4) 

Other token transfer functions properly validate amounts are positive through `AssertValidSymbolAndAmount`: [6](#0-5) 

### Impact Explanation

**Direct Fund Theft**: An attacker can steal tokens from any contract address that has been targeted for resource token advancement. For example:
1. Attacker advances 100 tokens legitimately (state = 100)
2. Attacker calls `AdvanceResourceToken` with amount = -200
3. Result: Attacker gains 200 tokens, contract loses 200 tokens, state corrupted to -100

**State Corruption**: The `AdvancedResourceToken` state can become negative, breaking the accounting invariant that tracks how much each user has advanced to each contract.

**Scale**: The attack can be repeated to drain contracts as long as they maintain balances. This affects all contracts that rely on the resource token advancement mechanism for transaction fees.

**Severity**: Critical - enables direct token theft with minimal cost, bypassing the intended access controls of `TakeResourceTokenBack`.

### Likelihood Explanation

**Reachable Entry Point**: `AdvanceResourceToken` is a public RPC method accessible to any user. [7](#0-6) 

**Feasible Preconditions**: 
- Attacker needs tokens of a valid resource symbol (CPU, RAM, DISK, NET, TRAFFIC)
- Target contract must have token balance
- Both conditions are commonly met in normal operations

**Execution Practicality**: Single transaction with negative amount parameter. No complex setup or timing requirements.

**Economic Rationality**: Cost is minimal (small gas fee), profit is direct token theft proportional to contract balance.

**Detection**: The reversed `Transferred` event will show unusual direction, but may not trigger immediate alerts in production systems.

### Recommendation

Add amount validation at the start of the `AdvanceResourceToken` function:

```csharp
public override Empty AdvanceResourceToken(AdvanceResourceTokenInput input)
{
    Assert(input.Amount > 0, "Invalid amount.");
    AssertValidInputAddress(input.ContractAddress);
    // ... rest of function
}
```

**Additional safeguards**:
1. Add regression test that verifies negative amounts are rejected
2. Add invariant checks that `AdvancedResourceToken` state cannot be negative
3. Consider adding similar validation to all public token operation methods

### Proof of Concept

**Initial State**:
- Attacker has 1000 TRAFFIC tokens
- Contract address has 500 TRAFFIC tokens
- AdvancedResourceToken[contract][attacker][TRAFFIC] = 0

**Attack Sequence**:

Step 1: Legitimate advance
```
AdvanceResourceToken(contract, "TRAFFIC", 100)
→ State: AdvancedResourceToken = 100
→ Attacker balance: 900
→ Contract balance: 600
```

Step 2: Exploit with negative amount
```
AdvanceResourceToken(contract, "TRAFFIC", -200)
→ State update: 100 + (-200) = -100 (CORRUPTED)
→ DoTransfer(attacker, contract, "TRAFFIC", -200) executes:
  - ModifyBalance(attacker, "TRAFFIC", 200) → Balance becomes 1100
  - ModifyBalance(contract, "TRAFFIC", -200) → Balance becomes 400
```

**Expected Result**: Transaction should fail with "Invalid amount" error

**Actual Result**: Transaction succeeds, attacker steals 200 tokens, state corrupted to -100

**Success Condition**: Attacker's balance increases by 200, contract's balance decreases by 200, while AdvancedResourceToken state shows negative value

### Citations

**File:** protobuf/token_contract_impl.proto (L28-30)
```text
    // Transfer resource tokens to designated contract address.
    rpc AdvanceResourceToken (AdvanceResourceTokenInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/token_contract_impl.proto (L220-227)
```text
message AdvanceResourceTokenInput {
    // The contract address to transfer.
    aelf.Address contract_address = 1;
    // The resource token symbol to transfer.
    string resource_token_symbol = 2;
    // The amount of resource token to transfer.
    int64 amount = 3;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L411-423)
```csharp
    public override Empty AdvanceResourceToken(AdvanceResourceTokenInput input)
    {
        AssertValidInputAddress(input.ContractAddress);
        Assert(
            Context.Variables.GetStringArray(TokenContractConstants.PayTxFeeSymbolListName)
                .Contains(input.ResourceTokenSymbol),
            "Invalid resource token symbol.");
        State.AdvancedResourceToken[input.ContractAddress][Context.Sender][input.ResourceTokenSymbol] =
            State.AdvancedResourceToken[input.ContractAddress][Context.Sender][input.ResourceTokenSymbol]
                .Add(input.Amount);
        DoTransfer(Context.Sender, input.ContractAddress, input.ResourceTokenSymbol, input.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L425-436)
```csharp
    public override Empty TakeResourceTokenBack(TakeResourceTokenBackInput input)
    {
        Assert(!string.IsNullOrWhiteSpace(input.ResourceTokenSymbol), "Invalid input resource token symbol.");
        AssertValidInputAddress(input.ContractAddress);
        var advancedAmount =
            State.AdvancedResourceToken[input.ContractAddress][Context.Sender][input.ResourceTokenSymbol];
        Assert(advancedAmount >= input.Amount, "Can't take back that more.");
        DoTransfer(input.ContractAddress, Context.Sender, input.ResourceTokenSymbol, input.Amount);
        State.AdvancedResourceToken[input.ContractAddress][Context.Sender][input.ResourceTokenSymbol] =
            advancedAmount.Sub(input.Amount);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L81-86)
```csharp
    private void AssertValidSymbolAndAmount(string symbol, long amount)
    {
        Assert(!string.IsNullOrEmpty(symbol) && IsValidSymbol(symbol),
            "Invalid symbol.");
        Assert(amount > 0, "Invalid amount.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L116-125)
```csharp
    private void ModifyBalance(Address address, string symbol, long addAmount)
    {
        var before = GetBalance(address, symbol);
        if (addAmount < 0 && before < -addAmount)
            Assert(false,
                $"{address}. Insufficient balance of {symbol}. Need balance: {-addAmount}; Current balance: {before}");

        var target = before.Add(addAmount);
        State.Balances[address][symbol] = target;
    }
```
