### Title
Non-Extra-Block-Producer Can Usurp Extra Block Privileges Through NextRound Transaction

### Summary
The AEDPoS consensus contract fails to validate that only the designated extra block producer (marked with `IsExtraBlockProducer = true`) can execute NextRound/NextTerm transactions. Any miner can trigger round termination under certain timing conditions, and whoever successfully executes NextRound will be incorrectly recorded as `ExtraBlockProducerOfPreviousRound` in the next round, granting them undeserved extra block production privileges including pre-round mining rights and increased tiny block limits.

### Finding Description

The vulnerability spans multiple files in the consensus command generation and validation flow:

**Root Cause:**

When generating consensus extra data for NextRound, the contract unconditionally sets the sender's pubkey as the `ExtraBlockProducerOfPreviousRound` without verifying they are the actual designated extra block producer: [1](#0-0) 

The designated extra block producer is determined during round generation and marked with `IsExtraBlockProducer = true`: [2](#0-1) 

**Missing Validation:**

The behavior determination logic does not restrict NextRound/NextTerm to only the extra block producer. Any miner can receive this behavior when their time slot passes or other conditions are met: [3](#0-2) 

The validation providers for NextRound fail to check if the sender has `IsExtraBlockProducer = true`: [4](#0-3) [5](#0-4) 

The PreCheck only verifies the miner is in the miner list, not that they are the extra block producer: [6](#0-5) 

**Privilege Abuse Path:**

Once a wrong miner is recorded as `ExtraBlockProducerOfPreviousRound`, they gain special privileges in the next round including the ability to mine before the round officially starts: [7](#0-6) 

And extended tiny block production limits: [8](#0-7) 

### Impact Explanation

**Consensus Integrity Violation:**
- Wrong miners receive extra block producer privileges, violating the consensus protocol's intended round termination mechanism
- The actual designated extra block producer loses their rightful privileges
- Disrupts the deterministic miner rotation schedule that AEDPoS relies on

**Operational Impact:**
- Miners who usurp extra block privileges can produce blocks outside their designated time slots
- Can produce more tiny blocks than allowed for normal miners
- May enable censorship or transaction ordering attacks during the privilege window
- Degrades fairness in block production and associated rewards

**Reward Misallocation:**
- Extra block producers may receive additional mining rewards or fees for their privileged blocks
- The actual designated producer loses potential rewards they should have earned

### Likelihood Explanation

**Attack Feasibility: HIGH**

The attack is highly practical under normal operational conditions:

1. **Reachable Entry Point:** The public `GetConsensusCommand` method is called by any miner requesting their next consensus action: [9](#0-8) 

2. **Realistic Trigger Conditions:**
   - Network delays causing the actual extra block producer to be slow
   - The extra block producer experiencing temporary downtime
   - Round overtime scenarios where multiple miners evaluate behavior simultaneously
   - Any miner whose time slot has passed can receive NextRound behavior

3. **No Special Privileges Required:**
   - Attacker only needs to be in the current miner list
   - No special authorization or governance control needed
   - Can occur accidentally during normal network conditions or be deliberately exploited

4. **Race Condition Window:**
   - When a round exceeds its expected duration, multiple miners may attempt NextRound
   - Timing logic in `ArrangeAbnormalMiningTime` does not guarantee extra block producer priority once the time window passes: [10](#0-9) 

5. **Detection Difficulty:**
   - The wrong assignment appears valid in on-chain state
   - No events or logs distinguish legitimate vs. usurped extra block producer status

### Recommendation

**Primary Fix: Add Extra Block Producer Validation**

Add validation in `RoundTerminateValidationProvider` to verify the sender is the designated extra block producer:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // NEW: Verify sender is the designated extra block producer
    var currentExtraBlockProducer = validationContext.BaseRound.GetExtraBlockProducerInformation();
    if (currentExtraBlockProducer.Pubkey != extraData.SenderPubkey.ToHex())
    {
        return new ValidationResult 
        { 
            Message = $"Only the designated extra block producer can terminate the round. Expected: {currentExtraBlockProducer.Pubkey}, Got: {extraData.SenderPubkey.ToHex()}" 
        };
    }
    
    // Existing validations
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Secondary Fix: Restrict Behavior Assignment**

Modify `GetConsensusBehaviourToTerminateCurrentRound` to only assign NextRound/NextTerm to the designated extra block producer:

```csharp
protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
{
    // Only allow extra block producer to terminate round
    var extraBlockProducer = CurrentRound.GetExtraBlockProducerInformation();
    if (extraBlockProducer.Pubkey != _pubkey)
    {
        return AElfConsensusBehaviour.Nothing; // Or UpdateValue if time slot not passed
    }
    
    // Existing logic for determining NextRound vs NextTerm
    return CurrentRound.RoundNumber == 1 || 
           !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp, CurrentRound.TermNumber, _periodSeconds) ||
           CurrentRound.RealTimeMinersInformation.Keys.Count == 1
        ? AElfConsensusBehaviour.NextRound
        : AElfConsensusBehaviour.NextTerm;
}
```

**Test Cases to Add:**
1. Verify non-extra-block-producer cannot execute NextRound transaction
2. Verify `ExtraBlockProducerOfPreviousRound` is only set by the correct miner
3. Test round timeout scenarios to ensure deterministic behavior
4. Verify privilege assignment only to legitimate extra block producers

### Proof of Concept

**Initial State:**
- Round N in progress with 5 miners
- Miner A has `IsExtraBlockProducer = true` (designated extra block producer)
- Miner B is a regular miner (Order = 2, `IsExtraBlockProducer = false`)
- Current time has exceeded the expected extra block mining time (round delayed)

**Attack Sequence:**

1. **Miner B Requests Consensus Command:**
   - Calls `GetConsensusCommand(BytesValue{Value=MinerB_Pubkey})`
   - Behavior provider evaluates: Miner B's time slot passed â†’ calls `GetConsensusBehaviourToTerminateCurrentRound()`
   - Returns: `AElfConsensusBehaviour.NextRound`

2. **Miner B Produces NextRound Block:**
   - Generates consensus extra data via `GetConsensusExtraDataForNextRound`
   - Line 178 sets: `nextRound.ExtraBlockProducerOfPreviousRound = MinerB_Pubkey` (WRONG!)
   - Transaction passes validation (no check for extra block producer status)
   - Block is accepted, `ProcessNextRound` executes

3. **Round N+1 Begins:**
   - State now shows: `Round(N+1).ExtraBlockProducerOfPreviousRound = MinerB_Pubkey`
   - Should be: `Round(N+1).ExtraBlockProducerOfPreviousRound = MinerA_Pubkey`

**Expected Result:**
- Only Miner A should be able to execute NextRound
- Miner B's NextRound transaction should be rejected with "Not designated extra block producer"

**Actual Result:**
- Miner B's NextRound transaction succeeds
- Miner B is recorded as `ExtraBlockProducerOfPreviousRound` in Round N+1
- Miner B gains privileges to mine before Round N+1 starts and produce extra tiny blocks
- Miner A loses these rightful privileges

**Success Condition:**
Observe in Round N+1 state that `ExtraBlockProducerOfPreviousRound` equals Miner B's pubkey instead of Miner A's pubkey, and Miner B can successfully mine during pre-round window when calling `IsCurrentMiner`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-179)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-66)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L149-155)
```csharp
        // Check confirmed extra block producer of previous round.
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L19-37)
```csharp
    public Timestamp ArrangeAbnormalMiningTime(string pubkey, Timestamp currentBlockTime,
        bool mustExceededCurrentRound = false)
    {
        var miningInterval = GetMiningInterval();

        var minerInRound = RealTimeMinersInformation[pubkey];

        if (GetExtraBlockProducerInformation().Pubkey == pubkey && !mustExceededCurrentRound)
        {
            var distance = (GetExtraBlockMiningTime().AddMilliseconds(miningInterval) - currentBlockTime)
                .Milliseconds();
            if (distance > 0) return GetExtraBlockMiningTime();
        }

        var distanceToRoundStartTime = (currentBlockTime - GetRoundStartTime()).Milliseconds();
        var missedRoundsCount = distanceToRoundStartTime.Div(TotalMilliseconds(miningInterval));
        var futureRoundStartTime = CalculateFutureRoundStartTime(missedRoundsCount, miningInterval);
        return futureRoundStartTime.AddMilliseconds(minerInRound.Order.Mul(miningInterval));
    }
```
