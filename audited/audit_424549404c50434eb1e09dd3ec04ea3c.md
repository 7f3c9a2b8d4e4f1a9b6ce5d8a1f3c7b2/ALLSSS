### Title
Association Contract Allows Unbounded Proposal Expiry Time Leading to State Storage Bloat

### Summary
The Association contract's `Validate(ProposalInfo)` function only validates that `ExpiredTime` is in the future but does not enforce an upper bound on how far in the future it can be set. This allows any authorized proposer to create proposals with effectively infinite expiry times (e.g., year 9999), permanently bloating contract state storage until that distant expiry date, as the cleanup mechanism `ClearProposal` can only remove proposals after they expire.

### Finding Description
The vulnerability exists in the `Validate(ProposalInfo proposal)` method in `Association_Helper.cs`: [1](#0-0) 

The validation only checks two conditions:
1. `ExpiredTime` is not null
2. `ExpiredTime` is greater than current block time (`Context.CurrentBlockTime < proposal.ExpiredTime`)

There is **no upper bound validation** on how far in the future `ExpiredTime` can be set. This validation is called during proposal creation in `CreateNewProposal`: [2](#0-1) 

The attack path is:
1. Any user can create an organization via the public `CreateOrganization` method (subject only to method fees)
2. The creator configures themselves in the `ProposerWhiteList`
3. The proposer then creates proposals with `ExpiredTime` set to year 9999 or any arbitrarily distant future date
4. These proposals are stored in the global `State.Proposals` mapping [3](#0-2) 

While a `ClearProposal` method exists to remove expired proposals: [4](#0-3) 

It can **only** remove proposals where `Context.CurrentBlockTime >= proposal.ExpiredTime`, meaning proposals with year 9999 expiry will remain in state storage until that date is reached.

Each `ProposalInfo` object stores significant data including contract method name, target address, parameters, organization address, proposer, voting lists (approvals/rejections/abstentions which can grow), title, description, and description URL: [5](#0-4) 

The same vulnerability pattern exists in Parliament and Referendum contracts with identical validation logic that lacks upper bound checks. [6](#0-5) [7](#0-6) 

### Impact Explanation
The impact is **state storage bloat** affecting the entire blockchain network:

1. **Unbounded State Growth**: Each proposal with far-future expiry permanently occupies storage until year 9999, effectively forever from a practical standpoint
2. **Node Resource Exhaustion**: All full nodes must store this bloated state, increasing disk space, memory requirements, and sync times for new nodes
3. **Economic Externality**: The attacker pays only the initial transaction fees (if configured), but the storage cost is borne indefinitely by all node operators
4. **No Practical Cleanup**: The `ClearProposal` mechanism is useless for far-future expiries, as no one will call it in year 9999
5. **Amplification Factor**: An attacker can create multiple organizations and spam numerous proposals per organization

The severity is **Medium** because while it doesn't result in direct fund theft, it creates a sustainable DoS vector against blockchain infrastructure through state bloat, increasing operational costs for all network participants.

### Likelihood Explanation
The exploitability is **HIGH** with realistic feasibility:

**Attacker Capabilities Required:**
- Ability to call public `CreateOrganization` method (any user can do this)
- Sufficient funds to pay method fees (if configured via ACS1)
- No trusted role compromise required - attacker uses their own organization

**Attack Complexity:**
- Low - only requires 2-3 straightforward transactions:
  1. `CreateOrganization` with self in proposer whitelist
  2. `CreateProposal` with far-future `ExpiredTime` (repeat multiple times)

**Economic Feasibility:**
- Method fees for `CreateOrganization` and `CreateProposal` are configurable but typically modest compared to permanent state storage costs imposed on all nodes
- Attack scales efficiently: one organization can spawn many proposals

**Detection/Prevention Constraints:**
- No on-chain detection mechanism for "unreasonably far" expiry times
- Validators cannot reject transactions with far-future expiry times as they pass validation
- Post-deployment mitigation requires contract upgrade

The lack of upper bound validation makes this exploit trivial for any motivated attacker to execute.

### Recommendation
Implement a maximum allowed expiry time duration to prevent unbounded state retention:

**Code-Level Mitigation:**

Add a constant defining maximum proposal lifetime (e.g., 30 days, 90 days, or 1 year based on governance needs):

```csharp
private const long MaxProposalLifetimeSeconds = 7776000; // 90 days
```

Modify the `Validate(ProposalInfo proposal)` method to enforce this upper bound:

```csharp
private bool Validate(ProposalInfo proposal)
{
    if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
        !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
        return false;

    if (proposal.ExpiredTime == null || Context.CurrentBlockTime >= proposal.ExpiredTime)
        return false;
    
    // Add upper bound check
    var maxExpiredTime = Context.CurrentBlockTime.AddSeconds(MaxProposalLifetimeSeconds);
    if (proposal.ExpiredTime > maxExpiredTime)
        return false;

    return true;
}
```

**Apply to All Governance Contracts:**
- Association: `contract/AElf.Contracts.Association/Association_Helper.cs`
- Parliament: `contract/AElf.Contracts.Parliament/Parliament_Helper.cs`
- Referendum: `contract/AElf.Contracts.Referendum/Referendum_Helper.cs`

**Test Cases to Add:**
1. Proposal creation with `ExpiredTime` at maximum allowed duration (should succeed)
2. Proposal creation with `ExpiredTime` exceeding maximum (should fail with "Invalid proposal")
3. Proposal creation with extremely far future date like year 9999 (should fail)

**Invariant to Enforce:**
`proposal.ExpiredTime <= Context.CurrentBlockTime + MaxProposalLifetimeSeconds`

### Proof of Concept

**Initial State:**
- Association contract deployed
- Attacker has sufficient tokens to pay method fees (if configured)

**Attack Steps:**

1. **Create Organization:**
   - Call `CreateOrganization` with `CreateOrganizationInput`:
     - `organization_member_list`: [AttackerAddress]
     - `proposer_white_list`: [AttackerAddress]
     - `proposal_release_threshold`: Any valid threshold
   - Receive organization address

2. **Create Far-Future Proposals:**
   - Call `CreateProposal` with `CreateProposalInput`:
     - `organization_address`: Organization from step 1
     - `expired_time`: Timestamp for December 31, 9999 (or any far future date)
     - `to_address`: Any valid contract address
     - `contract_method_name`: Any method name
     - Other required fields
   - Transaction succeeds, proposal stored in `State.Proposals`

3. **Repeat Step 2:**
   - Create hundreds or thousands of proposals with far-future expiry
   - Each proposal permanently occupies state storage

**Expected vs Actual Result:**
- **Expected:** Proposal creation should fail with upper bound validation error
- **Actual:** All proposals are accepted and stored, bloating state indefinitely

**Success Condition:**
Verify state bloat by querying `GetProposal` for created proposal IDs - all return valid proposals with year 9999 expiry times that cannot be cleared until that date.

**Notes**

This vulnerability affects all three ACS3 governance contract implementations (Association, Parliament, Referendum) as they share the same validation pattern. The issue is architectural - the ACS3 standard itself does not mandate upper bound validation on proposal expiry times, leading to consistent implementation of this vulnerability across all governance contracts. While method fees (via ACS1) can increase the cost of exploitation, they do not fundamentally prevent the attack, as the one-time fee paid by the attacker is dwarfed by the perpetual storage costs imposed on all network participants.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L83-90)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        if (proposal.ToAddress == null || string.IsNullOrWhiteSpace(proposal.ContractMethodName) ||
            !ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl))
            return false;

        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/AssociationState.cs (L9-10)
```csharp
    public MappedState<Address, Organization> Organizations { get; set; }
    public MappedState<Hash, ProposalInfo> Proposals { get; set; }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L76-103)
```text
message ProposalInfo {
    // The proposal ID.
    aelf.Hash proposal_id = 1;
    // The method that this proposal will call when being released.
    string contract_method_name = 2;
    // The address of the target contract.
    aelf.Address to_address = 3;
    // The parameters of the release transaction.
    bytes params = 4;
    // The date at which this proposal will expire.
    google.protobuf.Timestamp expired_time = 5;
    // The address of the proposer of this proposal.
    aelf.Address proposer = 6;
    // The address of this proposals organization.
    aelf.Address organization_address = 7;
    // Address list of approved.
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
    // Url is used for proposal describing.
    string proposal_description_url = 11;
    // Title of this proposal.
    string title = 12;
    // Description of this proposal.
    string description = 13;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L177-180)
```csharp
    private bool CheckProposalNotExpired(ProposalInfo proposal)
    {
        return proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L104-113)
```csharp
    private bool Validate(ProposalInfo proposal)
    {
        var validDestinationAddress = proposal.ToAddress != null;
        var validDestinationMethodName = !string.IsNullOrWhiteSpace(proposal.ContractMethodName);
        var validExpiredTime = proposal.ExpiredTime != null && Context.CurrentBlockTime < proposal.ExpiredTime;
        var hasOrganizationAddress = proposal.OrganizationAddress != null;
        var validDescriptionUrl = ValidateDescriptionUrlScheme(proposal.ProposalDescriptionUrl);
        return validDestinationAddress && validDestinationMethodName && validExpiredTime &&
               hasOrganizationAddress && validDescriptionUrl;
    }
```
