### Title
AddOptions() Fails to Validate Duplicate Options Within Same Batch Submission

### Summary
The `AddOptions()` function in VoteContract.cs does not detect duplicate options within a single batch submission. The `AssertOption()` validation at line 318 only checks if each option already exists in the stored state, not whether duplicates exist within the `input.Options` array itself. This allows a voting item sponsor to add duplicate options, violating the uniqueness invariant and enabling option slot exhaustion attacks. [1](#0-0) 

### Finding Description

The vulnerability exists in the `AddOptions()` function's validation logic. The function iterates through `input.Options` and calls `AssertOption()` for each option: [2](#0-1) 

However, `AssertOption()` only validates that the option doesn't exist in the current state (`votingItem.Options`), not against other options in the same batch: [3](#0-2) 

The check `!votingItem.Options.Contains(option)` at line 295 only verifies the option isn't already in storage. After all validations pass, the entire `input.Options` array is added via `AddRange()`, including any duplicates: [4](#0-3) 

**Execution Path:**
1. Sponsor calls `AddOptions()` with `input.Options = ["A", "A"]`
2. First iteration: checks if "A" exists in `votingItem.Options` → passes (not in state)
3. Second iteration: checks if "A" exists in `votingItem.Options` → passes (still not in state)
4. Line 319: both "A" entries are added to `votingItem.Options`
5. Result: `votingItem.Options` contains duplicate "A"

### Impact Explanation

**Primary Impacts:**

1. **Option Slot Exhaustion**: The maximum options count is enforced after addition: [5](#0-4) 

With `MaximumOptionsCount = 64`, a sponsor could add 32 unique options twice, consuming all 64 slots with only 32 distinct choices. This prevents legitimate options from being added and violates the intent of the limit. [6](#0-5) 

2. **Voting Integrity Confusion**: Duplicate options in the options list create voter confusion, potentially leading to:
   - Misunderstanding of available choices
   - Manipulation of perceived voting distributions
   - UI/frontend display issues

3. **Incomplete Option Removal**: The `RemoveOption()` function only removes the first instance: [7](#0-6) 

Calling `Remove()` on a duplicate only eliminates one occurrence, leaving the duplicate in place and requiring multiple calls to fully remove.

4. **Governance Manipulation**: In governance contexts where voting items represent important decisions, malformed option lists with duplicates can be weaponized to:
   - Confuse participants in critical votes
   - Game option availability for competitive voting scenarios
   - Create ambiguity in voting outcomes

**Severity**: Medium - While vote counting remains correct (results use a map structure), the operational impact on voting governance integrity and the ability to bypass option limits constitute a significant flaw.

### Likelihood Explanation

**Exploitability: HIGH**

- **Reachable Entry Point**: `AddOptions()` is a public method accessible to any voting item sponsor
- **Attacker Capabilities**: Only requires being the sponsor of a voting item (legitimate role)
- **Attack Complexity**: Trivial - simply pass an array with duplicate strings
- **Preconditions**: None beyond having sponsor permissions on a voting item
- **Detection**: Difficult to detect proactively; requires inspection of `votingItem.Options` list
- **Economic Cost**: Minimal - only standard transaction fees

**Feasibility**: The exploit requires no special privileges beyond normal sponsor capabilities. Any sponsor, whether malicious or making an honest mistake, can introduce duplicates. There are no existing tests validating this scenario: [8](#0-7) 

The test suite verifies permission checks and successful addition but does not test duplicate detection within a single batch.

### Recommendation

**Immediate Fix**: Add intra-batch duplicate validation in `AddOptions()`:

```csharp
public override Empty AddOptions(AddOptionsInput input)
{
    var votingItem = AssertVotingItem(input.VotingItemId);
    Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
    
    // NEW: Check for duplicates within the input batch
    var uniqueOptions = new HashSet<string>();
    foreach (var option in input.Options)
    {
        Assert(uniqueOptions.Add(option), "Duplicate option in batch.");
        AssertOption(votingItem, option);
    }
    
    votingItem.Options.AddRange(input.Options);
    Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    State.VotingItems[votingItem.VotingItemId] = votingItem;
    return new Empty();
}
```

**Alternative**: Use `Distinct()` to automatically deduplicate, though explicit rejection is clearer:

```csharp
var distinctOptions = input.Options.Distinct().ToList();
Assert(distinctOptions.Count == input.Options.Count, "Duplicate options not allowed.");
```

**Test Coverage**: Add test case validating duplicate rejection:

```csharp
[Fact]
public async Task AddOptions_Should_Reject_Duplicates_In_Batch()
{
    var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
    var result = await VoteContractStub.AddOptions.SendWithExceptionAsync(
        new AddOptionsInput
        {
            VotingItemId = registerItem.VotingItemId,
            Options = { "OptionA", "OptionA" }  // Duplicate
        });
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Duplicate");
}
```

### Proof of Concept

**Initial State:**
- Voting item exists with `Options = ["Option1", "Option2", "Option3"]`
- Sponsor authenticated

**Attack Steps:**

1. Sponsor calls `AddOptions()`:
   ```
   Input: {
     VotingItemId: <voting_item_id>,
     Options: ["NewOption", "NewOption"]
   }
   ```

2. Validation at line 318 executes:
   - First "NewOption": `votingItem.Options.Contains("NewOption")` → false → passes
   - Second "NewOption": `votingItem.Options.Contains("NewOption")` → false → passes

3. Line 319 executes: `votingItem.Options.AddRange(["NewOption", "NewOption"])`

**Expected Result:** Transaction should fail with "Duplicate option in batch" or "Option already exists"

**Actual Result:** Transaction succeeds. `votingItem.Options` now contains:
```
["Option1", "Option2", "Option3", "NewOption", "NewOption"]
```

**Success Condition:** Query `GetVotingItem()` confirms duplicate "NewOption" entries in the options list, demonstrating the vulnerability allows violation of option uniqueness invariant.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L309-309)
```csharp
        votingItem.Options.Remove(input.Option);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-324)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L453-506)
```csharp
    public async Task VoteContract_AddOptions_Test()
    {
        //without permission
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            var otherUser = Accounts[10].KeyPair;
            var transactionResult = (await GetVoteContractTester(otherUser).AddOptions.SendWithExceptionAsync(
                new AddOptionsInput
                {
                    VotingItemId = registerItem.VotingItemId,
                    Options =
                    {
                        Accounts[0].Address.ToBase58(),
                        Accounts[1].Address.ToBase58()
                    }
                })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.Error.Contains("Only sponsor can update options").ShouldBeTrue();
        }
        //voteItem does not exist
        {
            var itemId = HashHelper.ComputeFrom("hash");
            var transactionResult = (await VoteContractStub.AddOptions.SendWithExceptionAsync(new AddOptionsInput
            {
                VotingItemId = itemId,
                Options =
                {
                    Accounts[0].Address.ToBase58()
                }
            })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            transactionResult.Error.Contains("Voting item not found.").ShouldBeTrue();
        }
        //success
        {
            var registerItem = await RegisterVotingItemAsync(100, 3, true, DefaultSender, 1);
            var transactionResult = (await VoteContractStub.AddOptions.SendAsync(new AddOptionsInput
            {
                VotingItemId = registerItem.VotingItemId,
                Options =
                {
                    Accounts[3].Address.ToBase58(),
                    Accounts[4].Address.ToBase58()
                }
            })).TransactionResult;

            transactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            var votingItem = await GetVoteItem(registerItem.VotingItemId);
            votingItem.Options.Count.ShouldBe(5);
        }
    }
```
