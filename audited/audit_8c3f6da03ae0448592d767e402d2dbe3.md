### Title
Insufficient Contract Type Validation in CheckOrganizationExist Allows Permanent Method Fee Controller Takeover

### Summary
The `ChangeMethodFeeController` method in Genesis contract accepts arbitrary contract addresses without validating they are legitimate organization contracts (Parliament/Association/Referendum). An attacker can pass a Parliament proposal once to install a malicious contract that always returns `true` for `ValidateOrganizationExist`, gaining permanent control over Genesis contract method fees without further governance oversight.

### Finding Description

**Vulnerability Location:**

The vulnerability exists in the `ChangeMethodFeeController` method [1](#0-0) 

The method calls `CheckOrganizationExist` to validate the new controller [2](#0-1) 

**Root Cause:**

The `CheckOrganizationExist` implementation performs a cross-contract call to `ValidateOrganizationExist` on whatever contract address is provided in `AuthorityInfo.ContractAddress`, without any validation that this contract is a legitimate organization contract [3](#0-2) 

Legitimate organization contracts (Parliament, Association, Referendum) implement `ValidateOrganizationExist` to check if the organization exists in their internal state [4](#0-3) [5](#0-4) [6](#0-5) 

However, there is **no validation** that:
1. The provided `ContractAddress` is actually one of these three legitimate organization contracts
2. The contract correctly implements organization validation logic
3. The contract is a system contract or has been vetted

**Exploitation Path:**

1. Attacker deploys a malicious user contract implementing a `ValidateOrganizationExist` method that always returns `true` (user contract deployment is permissionless on main/public chains)

2. Attacker creates a Parliament proposal to call `ChangeMethodFeeController` with:
   - `AuthorityInfo.OwnerAddress` = attacker's controlled address
   - `AuthorityInfo.ContractAddress` = malicious contract address

3. When the proposal is approved and released:
   - Sender authorization passes (sender is Parliament organization address) [7](#0-6) 
   - `CheckOrganizationExist` calls malicious contract's `ValidateOrganizationExist` 
   - Malicious contract returns `true`
   - Controller is updated to attacker's setup [8](#0-7) 

4. Post-exploit, attacker directly calls `SetMethodFee` which only checks that sender equals `MethodFeeController.Value.OwnerAddress` [9](#0-8) 

**Why Existing Protections Fail:**

The only protection is the sender check requiring the current controller to authorize the change. However, this is bypassed through legitimate governance proposal execution where the organization contract itself is the sender. Once changed, there is no mechanism to validate the legitimacy of the new controller's contract address.

### Impact Explanation

**Direct Governance Impact:**
- Attacker gains **permanent, unilateral control** over Genesis contract method fees without requiring ongoing Parliament approval
- This is a privilege escalation from "must pass proposals for each change" to "can change fees at will"

**Operational Impact - DoS:**
The attacker can set prohibitively high transaction fees for critical Genesis contract methods including:
- `DeploySmartContract` / `UpdateSmartContract` - blocks all contract deployment/updates
- `ProposeNewContract` / `ProposeUpdateContract` - prevents proposing new contracts
- `ReleaseApprovedContract` / `ReleaseCodeCheckedContract` - prevents releasing approved contracts

This effectively **halts the entire smart contract deployment and upgrade system** for the chain.

**Economic Manipulation:**
- Setting zero fees where non-zero fees are intended bypasses economic controls
- Manipulating fee structures to extract value from specific transaction types
- Discriminatory fee setting to favor/harm specific users or use cases

**Affected Parties:**
- All chain participants who need to deploy or update contracts
- Governance system integrity (Parliament control is bypassed)
- Economic model of the chain (fee structures are corrupted)

**Severity Justification:**
HIGH severity due to:
1. Permanent governance bypass (critical invariant violation)
2. Chain-level DoS capability
3. Economic manipulation potential
4. Requires only ONE successful proposal to achieve lasting damage

### Likelihood Explanation

**Attacker Capabilities Required:**
- Deploy a user contract (permissionless on main/public side chains)
- Pass ONE Parliament proposal (requires 2/3 miner approval)

**Attack Complexity:**
- **LOW** - Straightforward contract deployment and proposal creation
- Malicious contract implementation is trivial (single method always returning true)
- Proposal parameters are complex enough to obscure malicious intent from voters

**Feasibility Conditions:**
- Attacker has sufficient influence/compromise to pass one Parliament proposal, OR
- During a governance compromise/attack when malicious proposals can be pushed through
- Social engineering could frame the proposal as a legitimate governance upgrade

**Detection Difficulty:**
- MEDIUM - The malicious nature isn't obvious from the proposal parameters alone
- Would require voters to:
  1. Inspect the target contract code at `ContractAddress`
  2. Recognize it's not a legitimate organization contract
  3. Understand the privilege escalation implications

**Probability Assessment:**
- Feasible during periods of governance inattention or coordinated attacks
- Higher probability if attacker controls multiple miner nodes
- The one-time nature (only need one successful proposal) increases overall risk

**Economic Rationality:**
- Cost: Minimal contract deployment cost + political capital for one proposal
- Benefit: Permanent control over fee structures = significant economic advantage and/or DoS capability
- Risk-reward ratio strongly favors exploitation

### Recommendation

**Immediate Fix:**

Add validation to ensure the `ContractAddress` is a legitimate, registered organization contract:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate contract address is a known organization contract
    var validContracts = new[] {
        State.ParliamentContract.Value,
        State.AssociationContract.Value, // Add this state variable
        State.ReferendumContract.Value   // Add this state variable
    };
    
    Assert(validContracts.Contains(authorityInfo.ContractAddress), 
           "Invalid organization contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Alternative Approach:**

Retrieve organization contract addresses from system contract name mapping:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    var parliamentAddress = Context.GetContractAddressByName(
        SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(
        SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(
        SmartContractConstants.ReferendumContractSystemName);
    
    Assert(authorityInfo.ContractAddress == parliamentAddress ||
           authorityInfo.ContractAddress == associationAddress ||
           authorityInfo.ContractAddress == referendumAddress,
           "Contract address must be Parliament, Association, or Referendum.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Apply to All Affected Contracts:**

This pattern appears in multiple contracts [10](#0-9)  and requires the same fix across all ACS1 implementations (Configuration, AEDPoS, CrossChain, Election, Parliament, Profit, Referendum, TokenConverter, TokenHolder, Treasury, Vote, Association, Economic contracts).

**Test Cases to Add:**

1. Test that `ChangeMethodFeeController` rejects non-organization contract addresses
2. Test that `ChangeMethodFeeController` rejects user contracts masquerading as organization contracts
3. Test that only Parliament/Association/Referendum contracts are accepted
4. Test that malicious contracts returning `true` are rejected before the call is made

### Proof of Concept

**Initial State:**
- Genesis contract deployed with `MethodFeeController` set to Parliament default organization [11](#0-10) 

**Attack Sequence:**

1. **Deploy Malicious Contract:**
```
Attacker deploys contract with:
public override BoolValue ValidateOrganizationExist(Address input)
{
    return new BoolValue { Value = true };
}
```

2. **Create Parliament Proposal:**
```
CreateProposal({
    to_address: Genesis_Contract_Address,
    contract_method_name: "ChangeMethodFeeController",
    params: {
        owner_address: Attacker_Address,
        contract_address: Malicious_Contract_Address
    },
    organization_address: Parliament_Default_Organization
})
```

3. **Get Proposal Approved:**
    - 2/3 of miners approve the proposal (assuming attacker has influence or during governance compromise)

4. **Release Proposal:**
```
Release(proposal_id)
// Executes ChangeMethodFeeController via Parliament organization
// Context.Sender = Parliament_Organization_Address ✓
// CheckOrganizationExist calls Malicious_Contract.ValidateOrganizationExist ✓
// Returns true ✓
// State.MethodFeeController.Value updated to attacker's AuthorityInfo ✓
```

5. **Exploit Control:**
```
// Attacker directly calls SetMethodFee
SetMethodFee({
    method_name: "DeploySmartContract",
    fees: [{
        symbol: "ELF",
        basic_fee: 1000000000000 // Extremely high fee
    }]
})
// Check: Context.Sender == State.MethodFeeController.Value.OwnerAddress ✓
// Success - DoS achieved, no one can afford to deploy contracts
```

**Expected Result:**
- Proposal should fail with "Invalid organization contract address" error

**Actual Result:**
- Proposal succeeds
- Attacker gains permanent fee control
- Can set arbitrary fees causing DoS or economic manipulation

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L15-15)
```csharp
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L59-71)
```csharp
            IsSystemContract = info.IsSystemContract,
            Version = info.Version,
            ContractAddress = contractAddress,
            IsUserContract = isUserContract
        };

        var contractInfo = Context.DeploySmartContract(contractAddress, reg, name);

        info.ContractVersion = contractInfo.ContractVersion;
        reg.ContractVersion = info.ContractVersion;

        State.ContractInfos[contractAddress] = info;
        State.SmartContractRegistrations[reg.CodeHash] = reg;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L51-54)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L218-221)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L119-119)
```csharp
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
```
