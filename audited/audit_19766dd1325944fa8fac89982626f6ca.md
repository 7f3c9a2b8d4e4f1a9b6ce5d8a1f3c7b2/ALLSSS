### Title
Missing Validation for Empty Miner List in NextTerm Allows Consensus Halt

### Summary
The `ToRound()` method in `NextTermInput` does not validate that `RealTimeMinersInformation` is non-empty, and neither does the subsequent `ProcessNextTerm` execution flow. A malicious miner can submit a crafted `NextTermInput` with empty `RealTimeMinersInformation`, causing the contract to set an empty miner list for the new term and permanently halting consensus.

### Finding Description

The vulnerability exists in the term transition logic of the AEDPoS consensus contract: [1](#0-0) 

The `ToRound()` method simply copies fields from `NextTermInput` to a new `Round` object without validating that `RealTimeMinersInformation` contains at least one miner. While Protobuf map fields cannot be null (they're always initialized as empty collections), they can be empty.

The validation in `RoundTerminateValidationProvider` only checks round and term number increments: [2](#0-1) 

This validation calls `ValidationForNextRound` which checks if any miner has `InValue != null`: [3](#0-2) 

When `RealTimeMinersInformation` is empty, `Values.Any(m => m.InValue != null)` returns `false`, so validation passes with `Success = true`.

The `ProcessNextTerm` method then executes without checking if the Round has miners: [4](#0-3) 

An empty `MinerList` is created and stored, and an empty `Round` is added to state. The only gate is `PreCheck()` which verifies the sender is a current miner but does not validate the input data: [5](#0-4) 

### Impact Explanation

**Consensus Halt**: Setting an empty miner list for a new term means no miners can produce blocks, permanently halting the blockchain until manual intervention or a hard fork.

**Affected Parties**: All network participants lose access to the blockchain. No transactions can be processed, tokens become inaccessible, and all on-chain applications cease functioning.

**Severity**: Critical - This is a complete denial of service attack against the entire blockchain network with potentially unrecoverable state unless emergency governance procedures exist.

### Likelihood Explanation

**Attacker Requirements**: 
- Must be a current miner (to pass `PreCheck()` permission validation)
- Can submit a crafted `NextTerm` transaction with malicious `NextTermInput`

**Attack Complexity**: Low - Simply requires constructing a `NextTermInput` message with empty `RealTimeMinersInformation` and appropriate round/term numbers.

**Feasibility**: The code comment mentions `ConstrainedAEDPoSTransactionValidationProvider` should prevent unauthorized consensus transactions at the pool level, but this provider's implementation and effectiveness cannot be verified in the provided codebase. If this protection is absent or bypassable, the attack is straightforward.

**Detection**: Difficult to detect in advance as the malicious transaction would appear valid until execution completes and the empty miner list is set.

**Overall Likelihood**: Medium - Requires a compromised or malicious miner, but no other complex preconditions.

### Recommendation

Add validation to enforce non-empty miner lists at multiple defense layers:

1. **In `ToRound()` or immediately after**:
```csharp
Assert(RealTimeMinersInformation != null && RealTimeMinersInformation.Count > 0, 
    "RealTimeMinersInformation cannot be empty.");
```

2. **In `RoundTerminateValidationProvider.ValidationForNextTerm()`**:
```csharp
if (extraData.Round.RealTimeMinersInformation.Count == 0)
    return new ValidationResult { Message = "Miner list cannot be empty for term transition." };
```

3. **In `ProcessNextTerm()` before `SetMinerList()`**:
```csharp
Assert(nextRound.RealTimeMinersInformation.Count > 0, 
    "Cannot set empty miner list for new term.");
```

4. **Add integration tests** that attempt to call `NextTerm` with empty or minimal `RealTimeMinersInformation` to verify the fix prevents this attack.

### Proof of Concept

**Initial State**: 
- Blockchain is running with current term N, round R
- Attacker is a valid miner in current term

**Attack Steps**:
1. Attacker crafts a `NextTermInput` with:
   - `RoundNumber = R + 1`
   - `TermNumber = N + 1`
   - `RealTimeMinersInformation = {}` (empty map)
   - Valid `RandomNumber` that passes VRF verification
   
2. Attacker submits transaction: `NextTerm(maliciousInput)`

3. `PreCheck()` passes (attacker is current miner)

4. `ValidateBeforeExecution` passes (round/term numbers increment correctly, empty collection passes InValue check)

5. `ProcessNextTerm` executes:
   - Creates empty `MinerList` at line 188-189
   - Stores empty miner list via `SetMinerList` at line 190
   - Stores empty `Round` via `AddRoundInformation` at line 196

**Expected Result**: Transaction rejected due to empty miner list

**Actual Result**: Transaction succeeds, empty miner list stored, consensus permanently halted as no miners can produce subsequent blocks

**Success Condition**: `State.MinerListMap[N+1].Pubkeys.Count == 0` and no blocks can be produced for round R+1 or higher

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
