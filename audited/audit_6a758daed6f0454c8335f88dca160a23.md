### Title
Missing Range Validation on Mining Orders Allows Consensus DoS via Invalid Order Assignment

### Summary
The `NextRoundMiningOrderValidationProvider` only validates that the count of distinct `FinalOrderOfNextRound` values matches the number of miners who mined, but does not verify that orders are within the valid range (1 to miner count) or that there are no gaps. Miners can exploit this by submitting `UpdateValue` transactions with `tune_order_information` containing out-of-range values (e.g., 100, 101), which breaks subsequent round generation and halts consensus.

### Finding Description

**Root Cause:**

The validation logic in `NextRoundMiningOrderValidationProvider` only performs a count-based check without validating the actual order values: [1](#0-0) 

This validation checks that the number of distinct `FinalOrderOfNextRound` values equals the number of miners who produced blocks, but crucially does NOT verify:
- Orders are within valid range [1, minersCount]
- Orders have no gaps (sequential from 1)

**Attack Vector:**

Miners can inject invalid orders through the `UpdateValue` method, which accepts a `tune_order_information` map allowing arbitrary order assignments: [2](#0-1) 

When `ProcessUpdateValue` executes, it blindly applies these values without validation: [3](#0-2) 

**Why Existing Protections Fail:**

1. `UpdateValueValidationProvider` does not validate `tune_order_information` ranges: [4](#0-3) 

2. `NextRoundMiningOrderValidationProvider` is only invoked for `NextRound` behavior, NOT for `UpdateValue`: [5](#0-4) 

3. During block validation for `UpdateValue`, the invalid orders are copied into state without validation: [6](#0-5) 

**Exploitation Path:**

When `GenerateNextRoundInformation` uses these corrupted `FinalOrderOfNextRound` values, it directly assigns them as `Order` values in the next round: [7](#0-6) 

### Impact Explanation

**Consensus System Failure:**

The invalid order values break critical consensus operations:

1. `BreakContinuousMining` assumes orders 1, 2, minersCount-1, and minersCount exist. With invalid orders, `First()` operations throw exceptions: [8](#0-7) [9](#0-8) 

2. `GetMiningInterval` fails when no miners have Order 1 or 2: [10](#0-9) 

3. `FirstMiner()` returns null when Order 1 doesn't exist: [11](#0-10) 

**Concrete Harm:**
- Blockchain consensus halts - no new blocks can be produced
- All miners affected - entire network stops functioning
- Requires hard fork or manual intervention to recover
- No fund theft, but complete operational DoS of the chain

**Severity Justification:** HIGH - Complete consensus failure affecting entire network operation.

### Likelihood Explanation

**Attacker Capabilities:**
- Any miner in the current mining schedule can execute this attack
- Requires only ability to submit one malicious `UpdateValue` transaction
- No special permissions beyond being an active miner

**Attack Complexity:**
- Low complexity: Single transaction with crafted `tune_order_information` parameter
- Example payload: `tune_order_information = {"minerA": "100", "minerB": "101", "minerC": "1", "minerD": "2"}`

**Feasibility Conditions:**
- `UpdateValue` is a public RPC method accessible to all miners: [12](#0-11) 

- No authorization checks prevent miners from setting arbitrary `tune_order_information` values
- Transaction is validated by `UpdateValueValidationProvider` which doesn't check order ranges

**Detection/Operational Constraints:**
- Attack is immediately visible once the next round fails to generate
- But by then, state is corrupted and requires manual intervention
- Low detection before exploitation - looks like normal UpdateValue transaction

**Probability:** HIGH - Easy to execute, requires only miner access, no economic cost beyond transaction fees.

### Recommendation

**Immediate Fix:**

Add range and continuity validation to `NextRoundMiningOrderValidationProvider`:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var providedRound = validationContext.ProvidedRound;
    var minersCount = providedRound.RealTimeMinersInformation.Count;
    
    // Existing count check
    var distinctCount = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Distinct().Count();
    if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound count.";
        return validationResult;
    }
    
    // NEW: Validate orders are within valid range [1, minersCount]
    var ordersOutOfRange = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Any(m => m.FinalOrderOfNextRound < 1 || m.FinalOrderOfNextRound > minersCount);
    if (ordersOutOfRange)
    {
        validationResult.Message = "FinalOrderOfNextRound values must be between 1 and miner count.";
        return validationResult;
    }
    
    // NEW: Validate no gaps - all orders from 1 to distinctCount exist
    var orderSet = providedRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound)
        .ToHashSet();
    for (int i = 1; i <= distinctCount; i++)
    {
        if (!orderSet.Contains(i))
        {
            validationResult.Message = $"Missing FinalOrderOfNextRound value {i} - orders must be continuous.";
            return validationResult;
        }
    }

    validationResult.Success = true;
    return validationResult;
}
```

**Additional Protection:**

Apply the same validation in `UpdateValueValidationProvider` to catch issues earlier, or add validation in `ProcessUpdateValue` before applying `tune_order_information`.

**Test Cases:**

1. Test `UpdateValue` with out-of-range orders (0, negative, > minersCount)
2. Test `UpdateValue` with gaps in orders (e.g., 1, 2, 5, 6)
3. Test `NextRound` with similar invalid order patterns
4. Verify `BreakContinuousMining` handles all edge cases correctly

### Proof of Concept

**Initial State:**
- Round N with 4 miners (minerA, minerB, minerC, minerD)
- All miners have valid orders 1, 2, 3, 4
- Current consensus operating normally

**Attack Sequence:**

1. **Malicious miner submits UpdateValue transaction:**
```
UpdateValueInput {
    ...normal fields...
    tune_order_information: {
        "minerA": 100,
        "minerB": 101,
        "minerC": 1,
        "minerD": 2
    }
}
```

2. **Transaction validation passes:**
   - `UpdateValueValidationProvider` checks OutValue and Signature only
   - Does NOT validate `tune_order_information` ranges
   - Block is accepted

3. **State corruption:**
   - `ProcessUpdateValue` applies: `FinalOrderOfNextRound[minerA] = 100`, `FinalOrderOfNextRound[minerB] = 101`
   - Round N state now has invalid FinalOrderOfNextRound values

4. **NextRound generation:**
   - `GenerateNextRoundInformation` creates Round N+1
   - Miners in Round N+1 get Order = 100, 101, 1, 2

5. **NextRound validation (incorrectly passes):**
   - `NextRoundMiningOrderValidationProvider` checks distinct count
   - Count of distinct FinalOrderOfNextRound in Round N+1 = 4 (correct count)
   - But does NOT check that Order values 100, 101 are invalid
   - Validation passes incorrectly

6. **Consensus failure:**
   - Round N+1 operations call `BreakContinuousMining`
   - Line 79: `First(i => i.Order == 1)` succeeds (minerC has Order 1)
   - Line 84: `First(i => i.Order == 2)` succeeds (minerD has Order 2)  
   - Line 94: `FirstOrDefault(i => i.Order == 4)` returns null (no miner has Order 4)
   - Line 101: `First(i => i.Order == 3)` throws `InvalidOperationException` - **CONSENSUS HALTS**

**Expected Result:** Transaction should be rejected with "Invalid order range" error

**Actual Result:** Transaction accepted, consensus breaks in next round, chain halts

**Success Condition:** After step 6, blockchain cannot produce new blocks, confirming DoS vulnerability.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** protobuf/aedpos_contract.proto (L29-31)
```text
    // Update consensus information.
    rpc UpdateValue (UpdateValueInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/aedpos_contract.proto (L207-208)
```text
    // The tuning order of mining for the next round, miner public key -> order.
    map<string, int32> tune_order_information = 7;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L79-84)
```csharp
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L94-101)
```csharp
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L76-80)
```csharp
        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```
