### Title
Non-Deterministic Fee Token Selection Enables Economic Unfairness in Multi-Token Fee Configuration

### Summary
The `SetMethodFee()` function allows the controller to set multiple token fees for the same method, but the fee charging logic only deducts ONE token based on non-deterministic dictionary iteration order. This creates unpredictable and unfair fee structures where users holding rare tokens may pay significantly less than users holding only common tokens for the same method call.

### Finding Description

The `SetMethodFee()` method accepts a `MethodFees` input that allows multiple fee tokens through the `repeated MethodFee fees` field in the protobuf definition. [1](#0-0) 

The controller can set multiple fees like `{ELF: 100, TSA: 10000, TSB: 1}` for a single method. [2](#0-1) 

When fees are charged, the `GetBaseFeeDictionary()` method converts the repeated fees into a dictionary grouping by symbol. [3](#0-2) 

The critical flaw occurs in `TryToChargeUserBaseFee()`, which iterates through the dictionary using `foreach (var (symbol, value) in symbolToAmountMap)` and selects the FIRST token that meets priority criteria (sufficient allowance, sufficient balance+allowance, sufficient balance, or any balance). [4](#0-3) 

In C#, Dictionary iteration order is **not guaranteed to be deterministic**. This means the same user with the same balances may be charged different tokens depending on internal dictionary implementation details, runtime version, or environmental factors.

The test suite confirms this behavior with test cases setting multiple fees (ELF, TSA, TSB) and expecting specific tokens to be charged, but the expected token appears to rely on iteration order. [5](#0-4) 

### Impact Explanation

**Economic Unfairness**: Users pay dramatically different amounts for the same method call:
- User A (holds only ELF): Pays 100 ELF
- User B (holds both ELF and TSB): May pay only 1 TSB if dictionary iteration encounters TSB first
- Result: 100x cost difference for identical service

**Unpredictability**: The charged token cannot be reliably predicted by users because dictionary iteration order varies across:
- Different .NET runtime versions
- Different execution contexts
- Hash collision scenarios

**Economic Manipulation Potential**: A controller (even acting in good faith) could inadvertently create exploitable fee structures:
- Set commonly-held token fees high (ELF = 100)
- Set rarely-held token fees low (RARE = 1)
- Users who happen to hold the rare token pay 1% of the intended fee

**Severity**: Medium - Creates significant economic unfairness and unpredictability, but does not enable theft or total fund loss. Requires controller action (governance-controlled) to set multiple fees.

### Likelihood Explanation

**Attacker Capabilities**: The method fee controller (default: Parliament organization) can call `SetMethodFee()` with multiple token fees. No special privileges beyond normal controller authority are required.

**Attack Complexity**: Low - Simply call `SetMethodFee()` with multiple `MethodFee` entries. No complex exploit sequence needed.

**Feasibility**: High - This is normal operation of the system, not an exploit. The vulnerability manifests automatically whenever:
1. Controller sets multiple fees for a method
2. Users call that method with balances in multiple fee tokens

**Detection Constraints**: Difficult to detect because:
- The behavior appears intentional (multiple fees are explicitly allowed)
- Different users experience different charging without obvious pattern
- Test suite validates the behavior without recognizing the non-determinism

**Probability**: Likely to occur if controllers attempt to provide fee payment flexibility by setting multiple token options, not realizing only one is charged non-deterministically.

### Recommendation

**Code-Level Mitigation**:

1. **Enforce Single Token Per Method**: Modify `SetMethodFee()` to validate that only one token is provided per method:
```csharp
Assert(input.Fees.Count <= 1, "Only one token fee allowed per method.");
```

2. **If Multiple Tokens Required**: If the intent is to allow users to choose payment token, implement explicit token selection logic:
   - Add a user preference mechanism
   - Use deterministic ordering (alphabetical by symbol)
   - Document clearly which token will be charged

3. **Add Deterministic Ordering**: If multiple fees must coexist, sort the dictionary keys before iteration:
```csharp
foreach (var (symbol, value) in symbolToAmountMap.OrderBy(x => x.Key))
```

**Invariant Checks**:
- Assert at most one fee token per method in SetMethodFee validation
- If multiple tokens allowed, document and test deterministic selection order

**Test Cases**:
- Test that SetMethodFee rejects multiple token fees
- If multiple fees allowed, test that the same token is always selected for identical balance scenarios
- Test with various token symbol orderings to verify deterministic behavior

### Proof of Concept

**Initial State**:
- Method fee controller sets fees for `DummyMethod`: `{ELF: 100, TSB: 1}`
- User A has: ELF = 1000, TSB = 0
- User B has: ELF = 1000, TSB = 10

**Transaction Steps**:
1. Controller calls `SetMethodFee()`: [2](#0-1) 
   ```
   MethodFees = {
     MethodName: "DummyMethod",
     Fees: [
       {Symbol: "ELF", BasicFee: 100_00000000},
       {Symbol: "TSB", BasicFee: 1_00000000}
     ]
   }
   ```

2. User A calls `DummyMethod()`:
   - ChargeTransactionFees invoked
   - Dictionary contains: `{"ELF": 100, "TSB": 1}`
   - Iteration encounters "ELF" first (or "TSB" first, non-deterministic)
   - If "ELF" first: User A charged 100 ELF
   - Result: 100 ELF deducted

3. User B calls `DummyMethod()`:
   - ChargeTransactionFees invoked
   - Dictionary contains: `{"ELF": 100, "TSB": 1}`
   - Iteration encounters "TSB" first (or "ELF" first, non-deterministic)
   - If "TSB" first and User B has TSB balance: User B charged 1 TSB
   - Result: 1 TSB deducted (instead of 100 ELF)

**Expected vs Actual**:
- Expected: All users pay the same fee amount for the same method
- Actual: User A pays 100 ELF, User B pays 1 TSB - a 100x difference for identical service

**Success Condition**: Different users calling the same method pay dramatically different fee amounts based on which tokens they hold and non-deterministic iteration order.

### Citations

**File:** protobuf/acs1.proto (L40-46)
```text
message MethodFees {
    // The name of the method to be charged.
    string method_name = 1;
    // List of fees to be charged.
    repeated MethodFee fees = 2;
    bool is_size_fee_free = 3;// Optional based on the implementation of SetMethodFee method.
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L13-23)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L747-808)
```csharp
    private bool TryToChargeUserBaseFee(Dictionary<string, long> symbolToAmountMap, Address fromAddress,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap, out long amount,
        out string symbolOfValidBalance, out long existingBalance, out long existingAllowance)
    {
        // priority: enough allowance -> symbolWithEnoughBalancePlusAllowance -> symbolWithEnoughBalance -> symbolWithAnything
        symbolOfValidBalance = null;
        string symbolWithAnything = null;
        string symbolWithEnoughBalance = null;
        string symbolWithEnoughBalancePlusAllowance = null;

        amount = 0;
        existingBalance = 0;
        existingAllowance = 0;
        //For user
        //Find the token that satisfies the balance of the fee,if there is no token that satisfies the balance of the fee, find the token that balance > 0
        foreach (var (symbol, value) in symbolToAmountMap)
        {
            // current token symbol
            amount = value;
            existingBalance = GetBalance(fromAddress, symbol);
            existingAllowance = GetFreeFeeAllowanceAmount(transactionFeeFreeAllowancesMap, symbol);

            var existingBalancePlusAllowance = existingBalance.Add(existingAllowance);

            
            // allowance is enough to cover the base fee
            if (existingAllowance >= amount)
            {
                symbolOfValidBalance = symbol;
                return true;
            }

            if (existingBalancePlusAllowance <= 0) continue;
            
            // find symbol: balance + allowance > 0
            symbolWithAnything ??= symbol;

            if (existingBalancePlusAllowance < amount) continue;

            if (existingAllowance > 0)
            {
                // find symbol: balance plus allowance is enough to cover the base fee and allowance is greater than 0
                symbolWithEnoughBalancePlusAllowance ??= symbol;
            }
            else
            {
                // find symbol: balance is enough to cover the base fee and no allowance 
                symbolWithEnoughBalance ??= symbol;
            }
        }

        if (symbolWithEnoughBalancePlusAllowance == null && symbolWithEnoughBalance == null)
        {
            symbolOfValidBalance = symbolWithAnything;

            return false;
        }

        symbolOfValidBalance = symbolWithEnoughBalancePlusAllowance ?? symbolWithEnoughBalance;

        return true;
    }
```

**File:** test/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee.Tests/ExecutionPluginForMethodFeeTest.cs (L344-424)
```csharp
    [Theory]
    [InlineData(100000000, 0, 3, 10, 1, 2, "ELF", 20260010, true)]
    [InlineData(9, 0, 1, 10, 1, 2, "ELF", 9, false)]
    [InlineData(100000000, 2, 2, 0, 1, 2, "TSA", 1, true)]
    [InlineData(100000000, 2, 2, 0, 13, 2, "TSB", 2, true)]
    [InlineData(100000000, 2, 2, 0, 20, 20, "TSA", 2, false)]
    [InlineData(1, 0, 1, 0, 1, 2, "TSB", 1, false)]
    [InlineData(10, 0, 0, 0, 1, 2, "ELF", 10, false)] // Charge 10 ELFs tx size fee.
    public async Task ChargeFee_Set_Method_Fees_Tests(long balance1, long balance2, long balance3, long fee1, long fee2,
        long fee3, string chargedSymbol, long chargedAmount, bool isChargingSuccessful)
    {
        await DeployTestContractAsync();

        var tokenContractStub = await GetTokenContractStubAsync();
        await SetPrimaryTokenSymbolAsync(tokenContractStub);
        await tokenContractStub.Transfer.SendAsync(new TransferInput
        {
            Symbol = "ELF",
            Amount = balance1,
            To = Accounts[1].Address,
            Memo = "Set for token converter."
        });
        await CreateAndIssueTokenAsync("TSA", balance2, Accounts[1].Address);
        await CreateAndIssueTokenAsync("TSB", balance3, Accounts[1].Address);

        var methodFee = new MethodFees
        {
            MethodName = nameof(_testContractStub.DummyMethod)
        };
        if (fee1 > 0)
            methodFee.Fees.Add(new MethodFee { Symbol = "ELF", BasicFee = fee1 });
        if (fee2 > 0)
            methodFee.Fees.Add(new MethodFee { Symbol = "TSA", BasicFee = fee2 });
        if (fee3 > 0)
            methodFee.Fees.Add(new MethodFee { Symbol = "TSB", BasicFee = fee3 });
        await _testContractStub.SetMethodFee.SendAsync(methodFee);

        var originBalance = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = chargedSymbol ?? "ELF"
        })).Balance;

        Dictionary<Address,Dictionary<string, long>> transactionFeeDic;
        var userTestContractStub =
            GetTester<ContractContainer.ContractStub>(_testContractAddress, Accounts[1].KeyPair);
        if (isChargingSuccessful)
        {
            var dummyResult = await userTestContractStub.DummyMethod.SendAsync(new Empty());
            dummyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
            if (chargedSymbol != null)
            {
                dummyResult.TransactionResult.GetChargedTransactionFees().Keys.ShouldContain(Accounts[1].Address);
                dummyResult.TransactionResult.GetChargedTransactionFees()[Accounts[1].Address].Keys.ShouldContain(chargedSymbol);
                dummyResult.TransactionResult.GetChargedTransactionFees()[Accounts[1].Address].Values.ShouldContain(chargedAmount);
            }

            transactionFeeDic = dummyResult.TransactionResult.GetChargedTransactionFees();
        }
        else
        {
            var dummyResult = await userTestContractStub.DummyMethod.SendWithExceptionAsync(new Empty());
            dummyResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
            dummyResult.TransactionResult.Error.ShouldBe("Pre-Error: Transaction fee not enough.");
            if (chargedSymbol != null)
                dummyResult.TransactionResult.GetChargedTransactionFees()[Accounts[1].Address].Keys.ShouldContain(chargedSymbol);
            transactionFeeDic = dummyResult.TransactionResult.GetChargedTransactionFees();
        }

        await CheckTransactionFeesMapAsync(Accounts[1].Address,transactionFeeDic);
        if (chargedSymbol != null)
            transactionFeeDic[Accounts[1].Address][chargedSymbol].ShouldBe(chargedAmount);

        var finalBalance = (await tokenContractStub.GetBalance.CallAsync(new GetBalanceInput
        {
            Owner = Accounts[1].Address,
            Symbol = chargedSymbol ?? "ELF"
        })).Balance;

        (originBalance - finalBalance).ShouldBe(chargedAmount);
    }
```
