### Title
CachedDelayTotalShares Never Updated During Beneficiary Removal - Causing Permanent Fund Dilution

### Summary
The `RemoveBeneficiary` function modifies `scheme.CachedDelayTotalShares` to reflect removed shares but never persists the updated scheme object back to state, causing all cached totals to remain inflated with phantom shares. This results in permanent fund loss for all remaining beneficiaries across all future delayed distribution periods.

### Finding Description

**Primary Issue - Missing State Persistence**:
The `RemoveBeneficiary` function loads the scheme object, modifies its `CachedDelayTotalShares`, but fails to save the updated scheme back to state: [9](#0-8) [10](#0-9) [11](#0-10) 

At line 260, only `TotalShares` is updated directly on state. The modified `scheme.CachedDelayTotalShares` from lines 253-254 is never persisted because there is no `State.SchemeInfos[input.SchemeId] = scheme;` statement.

**Correct Pattern** (from AddBeneficiary for comparison): [12](#0-11) [13](#0-12) 

AddBeneficiary explicitly saves the scheme object back to state at line 184, which RemoveBeneficiary omits.

**TryAdd Accumulation Logic** (investigated function):
The `TryAdd` method itself correctly accumulates removal amounts using safe checked arithmetic: [14](#0-13) [15](#0-14) 

However, this correct accumulation is rendered meaningless because the state updates are never committed.

**Execution Flow**: [4](#0-3) 

All removed details are accumulated with `CurrentPeriod` as key in `RemoveProfitDetails`, then the accumulated shares should be subtracted from future cached periods, but these subtractions are lost.

### Impact Explanation

**Direct Financial Harm**:
When `DistributeProfits` is called for future periods, it uses the inflated `CachedDelayTotalShares` that still includes removed beneficiaries: [16](#0-15) 

The profit calculation divides by the incorrect (higher) total: [5](#0-4) [17](#0-16) 

**Quantified Loss**:
- If 100 shares removed from 1000 total, remaining beneficiaries lose 10% of expected profits permanently
- For consensus rewards distributing 100,000 tokens: 10,000 tokens locked forever per affected period
- Affects ALL future periods after removal, compounding losses over time

**Affected Systems**:
- AEDPoS consensus miner rewards (with delay distribution)
- Treasury profit distributions
- TokenHolder dividend schemes
- Any profit scheme with `DelayDistributePeriodCount > 0`

**Permanence**:
Funds remain locked in period virtual addresses with no recovery mechanism: [7](#0-6) [6](#0-5) 

Once a period is distributed and `CurrentPeriod` increments, past periods cannot be redistributed.

**Severity**: CRITICAL
- Complete failure of beneficiary removal accounting
- Permanent fund loss with no recovery
- Affects core protocol economic incentives

### Likelihood Explanation

**Attacker Capabilities**: 
Requires scheme manager or TokenHolder contract privileges: [8](#0-7) 

**Attack Complexity**: NONE (Passive Bug)
This is not an active exploit - it's a broken feature. ANY call to `RemoveBeneficiary` on schemes with delayed distribution fails to update cached totals, regardless of caller intent.

**Feasibility**: CERTAIN
- Occurs during normal operations (removing expired beneficiaries, vote withdrawals, etc.)
- No special timing or conditions required
- Schemes with `DelayDistributePeriodCount > 0` are common in production (AEDPoS consensus uses delay=2)

**Detection**: DIFFICULT
- No transaction failure or event indicating the bug
- Beneficiaries only notice reduced profits in future periods
- Attribution requires comparing expected vs actual profit amounts across multiple periods

**Probability**: 100% on every RemoveBeneficiary call with DelayDistributePeriodCount > 0

### Recommendation

**Immediate Fix**:
Add scheme state persistence after updating `CachedDelayTotalShares`:

```csharp
// contract/AElf.Contracts.Profit/ProfitContract.cs
// After line 258, before line 260:

State.SchemeInfos[input.SchemeId] = scheme;  // ADD THIS LINE

State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());
```

Alternatively, update CachedDelayTotalShares directly on state:
```csharp
// Replace lines 251-255 with:
if (State.SchemeInfos[input.SchemeId].CachedDelayTotalShares.ContainsKey(removedPeriod))
{
    State.SchemeInfos[input.SchemeId].CachedDelayTotalShares[removedPeriod] = 
        State.SchemeInfos[input.SchemeId].CachedDelayTotalShares[removedPeriod].Sub(removedShares);
}
```

**Invariant Check**:
After beneficiary removal, verify cached totals match expectations:
```csharp
Assert(scheme.TotalShares == State.SchemeInfos[input.SchemeId].TotalShares,
    "TotalShares mismatch after removal");
// Add checks for CachedDelayTotalShares consistency
```

**Test Cases**:
1. Remove beneficiary with DelayDistributePeriodCount > 0, verify CachedDelayTotalShares persisted
2. Distribute profits after removal, verify correct (reduced) totalShares used
3. Remove multiple beneficiaries in sequence, verify cumulative cache updates
4. Remove then add beneficiaries in same period, verify cache consistency

### Proof of Concept

**Initial State** (Period 15):
```
Scheme: DelayDistributePeriodCount = 5
Beneficiary A: 100 shares (to be removed)
Beneficiary B: 900 shares (remaining)
scheme.TotalShares = 1000
CachedDelayTotalShares = {20: 1000, 21: 1000, 22: 1000}
```

**Step 1** - Call `RemoveBeneficiary` for Beneficiary A in period 15:
- RemoveProfitDetails accumulates: removedDetails = {15: 100}
- Lines 247-256: Loop attempts to subtract 100 from CachedDelayTotalShares[15-19]
- Lines 253-254: Local `scheme.CachedDelayTotalShares[20]` becomes 900 (in memory only)
- Line 260: Only `State.SchemeInfos[...].TotalShares` updated to 900
- **BUG**: Modified `scheme` object with updated CachedDelayTotalShares is never saved
- **Result**: State still has CachedDelayTotalShares[20] = 1000 (phantom 100 shares)

**Step 2** - Period 20 arrives, call `DistributeProfits` with 10,000 tokens:
- Line 469: Uses `CachedDelayTotalShares[20] = 1000` (incorrect - includes removed A)
- Line 579: distributedProfitsInfo.TotalShares = 1000
- Beneficiary B claims: (900 × 10000) / 1000 = 9,000 tokens
- **Expected**: (900 × 10000) / 900 = 10,000 tokens
- **Loss**: 1,000 tokens permanently locked in period 20's virtual address

**Verification**:
- Query `State.SchemeInfos[schemeId].CachedDelayTotalShares[20]` after Step 1
- Expected: 900 (if bug fixed)
- Actual: 1000 (bug confirmed - removal not persisted)

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L166-166)
```csharp
        var scheme = State.SchemeInfos[schemeId];
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-184)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L229-229)
```csharp
        var scheme = State.SchemeInfos[input.SchemeId];
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L247-256)
```csharp
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L260-262)
```csharp
        State.SchemeInfos[input.SchemeId].TotalShares = scheme.TotalShares.Sub(removedDetails.Values.Sum());

        return new Empty();
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L358-358)
```csharp
                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L466-470)
```csharp
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L479-480)
```csharp
        Assert(input.Period == releasingPeriod,
            $"Invalid period. When release scheme {input.SchemeId.ToHex()} of period {input.Period}. Current period is {releasingPeriod}");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-961)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L8-18)
```csharp
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```
