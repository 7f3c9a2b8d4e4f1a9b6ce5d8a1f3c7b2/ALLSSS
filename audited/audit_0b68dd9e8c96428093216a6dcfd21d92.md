# Audit Report

## Title
Decimal Overflow in GetAmountToPayFromReturn Due to Unbounded Connector Weight Ratios

## Summary
The `GetAmountToPayFromReturn` function in BancorHelper can experience decimal overflow when connector weights have extreme ratios, causing the TokenConverter contract to become completely unusable for affected connector pairs. The vulnerability occurs because individual connector weights are validated to be between 0 and 1, but there is no validation on the ratio between paired connector weights, allowing governance to create pairs with extreme ratios (e.g., 0.01:0.99, ratio of 99).

## Finding Description
The vulnerability exists in the Bancor formula calculation where the multiplication `bf * (Exp(y * Ln(x)) - decimal.One)` can exceed C# decimal's maximum value when the weight ratio `y = toConnectorWeight / fromConnectorWeight` is large. [1](#0-0) 

The weight ratio `y` is computed as the division of two connector weights, with no bounds on the magnitude of this ratio. [2](#0-1) 

Connector weights are only validated individually to ensure they are strictly between 0 and 1 (exclusive). [3](#0-2) 

The validation function `IsBetweenZeroAndOne` enforces individual bounds but provides no protection against extreme ratios. [4](#0-3) 

Governance can create connector pairs with arbitrary weight ratios through `AddPairConnector`, where `ResourceWeight` and `NativeWeight` are set independently. [5](#0-4) 

When users call the public `Buy` function, it invokes the vulnerable calculation with potentially extreme weight ratios. [6](#0-5) 

The TokenConverter project has `CheckForOverflowUnderflow` enabled in both Debug and Release configurations, which means decimal overflow operations throw `OverflowException` rather than wrapping silently. [7](#0-6) 

## Impact Explanation
**High Impact - Operational DoS**

When the overflow occurs, the C# runtime throws `OverflowException`, causing the entire transaction to revert. This makes the token converter completely unusable for the affected connector pair, effectively creating a denial-of-service condition.

**Concrete overflow scenario:**
- Connector weights: `fromConnectorWeight = 0.01` (1%), `toConnectorWeight = 0.99` (99%)
- Weight ratio: `y = 99`
- Balances: `fromConnectorBalance = 1,000,000,000,000` (1 trillion tokens)
- Purchase: User wants `amountToReceive = 4,000,000,000` (40% of a 10 billion toConnectorBalance)
- Calculation: `x = 10B / (10B - 4B) = 1.667`
- `Ln(1.667) ≈ 0.511`
- `y * Ln(x) = 99 * 0.511 ≈ 50.6`
- `Exp(50.6) ≈ 4.7 × 10^21`
- `bf * Exp(50.6) ≈ 10^12 * 4.7 × 10^21 ≈ 4.7 × 10^33`
- **Result**: Exceeds `decimal.MaxValue` (≈7.9 × 10^28) → OverflowException thrown

**Affected parties**: 
- All users attempting to buy or sell tokens through the affected connector pair
- Liquidity providers whose funds become locked in the unusable pair
- The protocol's token conversion functionality

## Likelihood Explanation
**Medium-High Likelihood**

1. **Reachable entry point**: The `Buy` function is publicly accessible to all users without special permissions.

2. **Feasible preconditions**: Requires governance to set unbalanced weights via `AddPairConnector` or `UpdateConnector`. [8](#0-7) 

3. **No explicit prevention**: The validation only checks that each weight satisfies `0 < weight < 1`, with no constraints on the ratio between paired connector weights.

4. **Realistic scenarios**:
   - **Intentional asymmetric design**: Governance might deliberately set asymmetric weights for economic reasons (e.g., to control price impact or create specific market dynamics)
   - **Configuration error**: Accidental weight inversion or typo during connector setup
   - **Natural growth**: Even moderate weight imbalances (e.g., 0.05/0.95, ratio of 19) can cause overflow as connector balances grow over time through normal trading activity

5. **Initial setup uses balanced weights**: The Economic contract initialization demonstrates that the system initially uses balanced weights (both 0.005), but this provides no protection against governance later creating pairs with extreme ratios. [9](#0-8) 

## Recommendation
Add validation to prevent extreme weight ratios when creating or updating connector pairs:

```csharp
private void AssertValidConnectorWeightRatio(decimal weight1, decimal weight2)
{
    const decimal MaxRatio = 10m; // Maximum allowed ratio between weights
    var ratio = weight1 > weight2 ? weight1 / weight2 : weight2 / weight1;
    Assert(ratio <= MaxRatio, $"Connector weight ratio {ratio} exceeds maximum allowed ratio of {MaxRatio}");
}
```

Apply this validation in `AddPairConnector`:
```csharp
public override Empty AddPairConnector(PairConnectorParam input)
{
    AssertPerformedByConnectorController();
    // ... existing validation ...
    
    var resourceWeight = AssertedDecimal(input.ResourceWeight);
    var nativeWeight = AssertedDecimal(input.NativeWeight);
    
    // Add ratio validation
    AssertValidConnectorWeightRatio(resourceWeight, nativeWeight);
    
    // ... rest of implementation ...
}
```

Similarly apply in `UpdateConnector` when weight is being modified.

Alternatively, implement overflow protection in `GetAmountToPayFromReturn` by checking intermediate results before final multiplication, though preventing extreme ratios at configuration time is the more robust solution.

## Proof of Concept
```csharp
[Fact]
public void TestDecimalOverflowInGetAmountToPayFromReturn()
{
    // Setup extreme weight ratio: 0.01 to 0.99 = ratio of 99
    decimal fromConnectorWeight = 0.01m;
    decimal toConnectorWeight = 0.99m;
    
    // Large balances that could realistically occur
    long fromConnectorBalance = 1_000_000_000_000L; // 1 trillion
    long toConnectorBalance = 10_000_000_000L;       // 10 billion
    
    // User wants to buy 40% of toConnectorBalance
    long amountToReceive = 4_000_000_000L;
    
    // This should throw OverflowException due to decimal overflow
    Assert.Throws<OverflowException>(() =>
    {
        BancorHelper.GetAmountToPayFromReturn(
            fromConnectorBalance,
            fromConnectorWeight,
            toConnectorBalance,
            toConnectorWeight,
            amountToReceive
        );
    });
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L230-249)
```csharp
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```
