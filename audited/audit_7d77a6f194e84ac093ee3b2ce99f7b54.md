### Title
Vote Weight Overflow Corrupts Profit Share Distribution Due to Missing Parameter Bounds Validation

### Summary
The `SetVoteWeightInterest` function lacks upper bounds validation on Interest and Capital parameters, allowing governance to configure extreme values that cause arithmetic overflow in `GetVotesWeight`. When normal users subsequently call `Vote()`, the overflowed weight value corrupts profit share allocations in the welfare scheme, breaking the economic invariant that profit distribution must accurately reflect vote weights.

### Finding Description

**Root Cause**: [1](#0-0) 

The `SetVoteWeightInterest` function only validates that Interest, Capital, and Day are greater than zero, with no upper bounds checks. This allows governance to set extreme values like Interest=10^10 and Capital=1.

**Overflow Mechanism**: [2](#0-1) 

The `GetVotesWeight` function calculates: `initBase = 1 + Interest/Capital`, then `weight = (long)(Pow(initBase, lockDays) * votesAmount) + proportionAdjustment`. With extreme Interest/Capital ratios, `Pow(initBase, lockDays)` produces astronomical decimal values that overflow when cast to long. The cast operation has undefined behavior in unchecked contexts, potentially wrapping to incorrect positive values rather than throwing exceptions or producing negatives.

**Corruption Path**: [3](#0-2) 

The corrupted weight is passed directly to `AddBeneficiaryToVoter`, which sends it as `Shares` to the Profit contract without additional validation.

**Insufficient Protection**: [4](#0-3) 

The Profit contract's `AssertValidInput` only validates `Shares >= 0`, accepting corrupted positive values. [5](#0-4) 

These corrupted shares are added to `scheme.TotalShares`, permanently distorting the profit distribution ratio for all participants in the welfare scheme.

### Impact Explanation

**Economic Harm**: When vote weight overflows to an incorrect positive value, voters receive wrong profit shares. If overflow wraps to a small positive number, voters get far less than entitled. If it wraps to a large incorrect value, they get excessive shares at others' expense. The scheme's `TotalShares` becomes incorrect, breaking the fundamental invariant: `actual_profit_share = (voter_shares / TotalShares) * distributed_amount`.

**Affected Parties**: All participants in the Election welfare profit scheme are impacted, as the corrupted TotalShares affects everyone's profit distribution calculations. [6](#0-5) 

The profit calculation formula `SafeCalculateProfits(shares, totalAmount, totalShares)` produces incorrect results when TotalShares is corrupted.

**Severity Justification**: This violates the critical Economics & Treasury invariant requiring "Profit/Treasury/TokenHolder share calculations, donation/release logic, dividend distribution and settlement accuracy." Once corrupted, the only recovery is migration to a new scheme, disrupting all stakers.

### Likelihood Explanation

**Preconditions**: Governance must first call `SetVoteWeightInterest` with extreme but technically valid parameters (e.g., Interest=10^10, Capital=1). While this requires governance action, it's NOT a "compromise" scenario but a missing code protection against configuration errors. No adversarial intent is required—governance could make this mistake during legitimate parameter adjustments or testing. [1](#0-0) 

**Attack Surface**: Once misconfigured, ANY normal user calling the public `Vote()` function triggers the overflow. [7](#0-6) 

No special permissions or capabilities are required—the attacker is simply a regular voter. Even with validated `lockSeconds` (checked at line 430), the extreme Interest/Capital ratio causes overflow.

**Detection**: The misconfiguration may go undetected initially. Overflow behavior in decimal-to-long casts is undefined in unchecked contexts, potentially producing varied results across different execution environments. Symptoms only appear when voters notice incorrect profit distributions, by which time corruption has spread across the scheme.

**Probability**: MEDIUM—relies on governance error, but defense-in-depth principles require contracts to validate ALL inputs, even from trusted sources, to prevent operational failures.

### Recommendation

**Add Upper Bounds Validation**: [1](#0-0) 

```
Assert(info.Interest <= MaxInterestRate, "Interest rate exceeds maximum");
Assert(info.Capital >= MinCapitalBase, "Capital base below minimum");
Assert(info.Interest.Div(info.Capital) <= MaxInterestRatio, "Interest/Capital ratio exceeds safe bounds");
```

Define constants: `MaxInterestRate = 1000`, `MinCapitalBase = 100`, `MaxInterestRatio = 10` to ensure `initBase` stays within safe bounds (e.g., <= 11) preventing exponential explosion.

**Add Overflow Protection in GetVotesWeight**: [2](#0-1) 

Before the cast, validate: `Assert(Pow(initBase, lockDays) * votesAmount <= long.MaxValue, "Vote weight calculation overflow")` or use checked arithmetic context.

**Add Test Cases**: Test extreme values (Interest=10^10, lockDays=1080, amount=TotalSupply/10) to verify overflow protection. Test that valid ranges (Interest≤1000, Capital≥100) work correctly.

### Proof of Concept

**Initial State**: 
- Election contract deployed with default VoteWeightInterest settings
- Welfare profit scheme active with existing voters

**Exploitation Steps**:

1. **Misconfiguration** (Governance): Call `SetVoteWeightInterest` with:
   ```
   VoteWeightInterestInfos: [{Day: 365, Interest: 10000000000, Capital: 1}]
   ```
   This passes validation (all values > 0) but creates `initBase = 1 + 10^10 / 1 ≈ 10^10`

2. **Trigger** (Normal User): Call `Vote()` with:
   ```
   Amount: 100000000000000 (10^14, reasonable for 8-decimal token)
   EndTimestamp: CurrentTime + 1080 days (within MaximumLockTime)
   ```

3. **Overflow**: [8](#0-7) 
   - `lockDays = 1080`
   - `Pow(10^10, 1080)` produces astronomical decimal (>> 10^10800)
   - Multiplication by amount produces value vastly exceeding decimal range
   - Cast to long produces undefined/corrupted result

4. **Corruption**: Corrupted weight passed to Profit contract, accepted by `Shares >= 0` check, added to `TotalShares`, breaking all profit calculations.

**Success Condition**: Query `scheme.TotalShares` and voter's profit details—values will be incorrect relative to actual vote amounts, proving share corruption.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L421-467)
```csharp
    public override Hash Vote(VoteMinerInput input)
    {
        // Check candidate information map instead of candidates. 
        var targetInformation = State.CandidateInformationMap[input.CandidatePubkey];
        AssertValidCandidateInformation(targetInformation);

        var electorPubkey = Context.RecoverPublicKey();

        var lockSeconds = (input.EndTimestamp - Context.CurrentBlockTime).Seconds;
        AssertValidLockSeconds(lockSeconds);

        var voteId = GenerateVoteId(input);
        Assert(State.LockTimeMap[voteId] == 0, "Vote already exists.");
        State.LockTimeMap[voteId] = lockSeconds;

        UpdateElectorInformation(electorPubkey, input.Amount, voteId);

        var candidateVotesAmount = UpdateCandidateInformation(input.CandidatePubkey, input.Amount, voteId);

        LockTokensOfVoter(input.Amount, voteId);
        TransferTokensToVoter(input.Amount);
        CallVoteContractVote(input.Amount, input.CandidatePubkey, voteId);
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);

        var rankingList = State.DataCentersRankingList.Value;
        if (rankingList.DataCenters.ContainsKey(input.CandidatePubkey))
        {
            rankingList.DataCenters[input.CandidatePubkey] =
                rankingList.DataCenters[input.CandidatePubkey].Add(input.Amount);
            State.DataCentersRankingList.Value = rankingList;
        }
        else
        {
            if (rankingList.DataCenters.Count < GetValidationDataCenterCount())
            {
                State.DataCentersRankingList.Value.DataCenters.Add(input.CandidatePubkey,
                    candidateVotesAmount);
                AddBeneficiary(input.CandidatePubkey);
            }
            else
            {
                TryToBecomeAValidationDataCenter(input, candidateVotesAmount, rankingList);
            }
        }

        return voteId;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L182-182)
```csharp
        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L217-222)
```csharp
    private void AssertValidInput(AddBeneficiaryInput input)
    {
        Assert(input.SchemeId != null, "Invalid scheme id.");
        Assert(input.BeneficiaryShare?.Beneficiary != null, "Invalid beneficiary address.");
        Assert(input.BeneficiaryShare?.Shares >= 0, "Invalid share.");
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
