# Audit Report

## Title
Manager Can Erase Self-Registered User Shares via AddBeneficiary Due to Uncaptured Return Value

## Summary
The `AddBeneficiary` method in TokenHolderContract contains a critical bug where it fails to capture the return value of the SafeMath `Add()` extension method. This causes existing beneficiary shares to be discarded instead of accumulated, allowing scheme managers to arbitrarily reduce profit entitlements of users who locked tokens via `RegisterForProfits`.

## Finding Description

**Root Cause:**

The bug occurs in the `AddBeneficiary` method when re-adding an existing beneficiary. The method attempts to preserve and accumulate existing shares, but fails due to not capturing the return value of the `Add` extension method. [1](#0-0) 

At line 55, the code calls `shares.Add(detail.Details.Single().Shares)` but does not assign the result back to `shares`. Since `Add` is a SafeMath extension method that returns a new value rather than modifying the original [2](#0-1) , the existing shares are lost.

**Security Guarantee Broken:**

Users who lock tokens through `RegisterForProfits` expect their profit shares to remain proportional to their locked token amount. The system should maintain the invariant: **locked_tokens = profit_shares** until unlock.

**Attack Execution Path:**

1. User calls `RegisterForProfits` and locks 1000 tokens, receiving 1000 profit shares [3](#0-2) 

2. Manager calls `AddBeneficiary(beneficiary=User, shares=100)`:
   - Line 45: `shares` is set to 100 (input value)
   - Line 46-54: Existing beneficiary is detected and removed (losing 1000 shares)
   - Line 55: `shares.Add(1000)` returns 1100 but result is not captured
   - Line 58-66: User re-added with only 100 shares (90% reduction)

3. User's 1000 tokens remain locked [4](#0-3)  but profit entitlement reduced to 10%.

**Why Existing Protections Fail:**

Authorization in `AddBeneficiary` only verifies the caller is the scheme manager [5](#0-4) , with no distinction between manager-added and self-registered beneficiaries. The underlying Profit contract permits both manager and TokenHolder contract to modify beneficiaries [6](#0-5) , creating no separation of concerns.

**Evidence from Test Suite:**

The existing test `AddBeneficiary_Repeatedly_Test` documents this bug as expected behavior, showing that after adding 1 share then 2 shares, total shares equals 2 (not 3), confirming replacement rather than accumulation [7](#0-6) .

## Impact Explanation

**Direct Financial Harm:**
- Users lose profit distribution rights proportional to the share reduction
- A user with 1000 locked tokens receiving only 100 shares loses 90% of entitled profits
- Tokens remain locked for the minimum period while receiving minimal/zero profit returns
- Total scheme shares decrease, causing other beneficiaries to receive proportionally larger dividends funded by the manipulated user's lost entitlement

**Affected Parties:**
- All users who self-register via `RegisterForProfits` are vulnerable
- Malicious or careless managers can execute this attack
- Legitimate users suffer opportunity cost of locked capital with reduced returns

**Severity: HIGH**
- Breaks core economic invariant: profit shares must match locked token amounts
- No on-chain detection or prevention mechanism exists
- Direct misappropriation of profit distributions
- Asymmetric risk: user capital locked, manager share allocation unrestricted

## Likelihood Explanation

**Attacker Requirements:**
- Scheme manager role (obtainable by anyone via `CreateScheme`) [8](#0-7) 
- No special privileges beyond normal user capabilities

**Attack Complexity:**
- Single transaction calling `AddBeneficiary` with arbitrary share values
- No timing constraints, complex preconditions, or multi-step coordination required

**Feasibility:**
- Users registering via `RegisterForProfits` is the intended/normal usage pattern
- Manager calling `AddBeneficiary` appears as legitimate scheme management
- No external dependencies or blockchain state requirements

**Detection Difficulty:**
- Behavior indistinguishable from legitimate manager operations
- No event emissions or alerts for share reductions

**Likelihood: HIGH** - This bug affects core profit-sharing functionality in normal operations, with strong manager incentives to maximize their own profit share at users' expense.

## Recommendation

**Fix:** Capture the return value of the `Add` method:

```csharp
// Line 55 should be changed from:
shares.Add(detail.Details.Single().Shares);

// To:
shares = shares.Add(detail.Details.Single().Shares);
```

**Additional Safeguards:**
1. Implement separate tracking for self-registered vs manager-added beneficiaries
2. Prevent managers from reducing shares of self-registered users
3. Add validation that share updates for locked token holders must maintain the `locked_amount == shares` invariant
4. Emit events when beneficiary shares are modified to enable off-chain monitoring

## Proof of Concept

```csharp
[Fact]
public async Task PoC_Manager_Erases_User_Shares()
{
    // Setup: Create scheme and register user with locked tokens
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = Starter,
        Symbol = "ELF",
        Amount = 1000
    });

    // User registers and locks 1000 tokens, getting 1000 shares
    var userStub = GetTester<TokenHolderContractImplContainer.TokenHolderContractImplStub>(
        TokenHolderContractAddress, UserKeyPairs.First());
    await userStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = Starter,
        Amount = 1000
    });

    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
    var profitScheme = await ProfitContractStub.GetScheme.CallAsync(scheme.SchemeId);
    
    // Verify user has 1000 shares
    profitScheme.TotalShares.ShouldBe(1000);

    // ATTACK: Manager calls AddBeneficiary with only 100 shares
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Shares = 100
    });

    // VULNERABILITY: User's shares reduced to 100 (not 1100 as intended)
    profitScheme = await ProfitContractStub.GetScheme.CallAsync(scheme.SchemeId);
    profitScheme.TotalShares.ShouldBe(100);  // Should be 1100, but bug causes it to be 100
    
    // User's 1000 tokens remain locked but profit entitlement reduced by 90%
    var lockedAmount = await TokenContractStub.GetLockedAmount.CallAsync(new GetLockedAmountInput
    {
        Address = UserAddresses.First(),
        Symbol = "ELF",
        LockId = Context.GenerateId(TokenHolderContractAddress, 
            ByteArrayHelper.ConcatArrays(Starter.ToByteArray(), UserAddresses.First().ToByteArray()))
    });
    lockedAmount.Amount.ShouldBe(1000);  // Tokens still locked
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-176)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L227-228)
```csharp
        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L100-106)
```csharp
    public static long Add(this long a, long b)
    {
        checked
        {
            return a + b;
        }
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L120-135)
```csharp
    public async Task AddBeneficiary_Repeatedly_Test()
    {
        await AddBeneficiaryTest();
        var tokenHolderProfitScheme = await TokenHolderContractStub.GetScheme.CallAsync(Starter);
        var newShare = 2;
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First(),
            Shares = newShare
        });

        {
            var originScheme = await ProfitContractStub.GetScheme.CallAsync(tokenHolderProfitScheme.SchemeId);
            originScheme.TotalShares.ShouldBe(newShare);
        }
    }
```
