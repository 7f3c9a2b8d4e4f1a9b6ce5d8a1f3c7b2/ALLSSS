### Title
Unbounded Loop with Cross-Contract Calls in Cross-Chain Proposal Cleanup Causes DoS

### Summary
The `ClearCrossChainIndexingProposalIfExpired()` helper method iterates through all proposals in `ChainIndexingProposalCollections` and makes a cross-contract call for each one to check expiration status. When many side chains exist with indexing proposals, this unbounded loop can consume excessive gas, preventing miners from proposing new cross-chain indexing and effectively causing a denial of service of critical cross-chain functionality.

### Finding Description
When a miner calls `ProposeCrossChainIndexing`, it immediately invokes `ClearCrossChainIndexingProposalIfExpired()` to clean up expired proposals. [1](#0-0) 

This cleanup method loads all pending proposals and iterates through every entry in `ChainIndexingProposalCollections` without any limit: [2](#0-1) 

For each proposal, the method calls `CheckProposalExpired()`, which makes an expensive cross-contract call via `GetCrossChainProposal()` to the authorization contract: [3](#0-2) 

The cross-contract call uses `Context.Call` which has significant gas overhead: [4](#0-3) 

The collection can contain one proposal per chain (parent chain plus all side chains), and there is no explicit limit on the number of side chains that can be created. [5](#0-4) 

Proposals remain in the collection as PENDING (not yet released) or ACCEPTED (released but not manually cleaned up) status, and they expire after only 120 seconds: [6](#0-5) 

The assertion in `ProposeCrossChainBlockData` ensures only one proposal per chain can exist at a time, but does not limit the total number of chains: [7](#0-6) 

**Why existing protections fail:**
- No gas limit check or early exit in the loop
- No batching or pagination mechanism
- Cleanup happens synchronously on every propose call regardless of collection size
- ACCEPTED proposals are not immediately removed after processing, requiring manual cleanup via `AcceptCrossChainIndexingProposal` [8](#0-7) 

### Impact Explanation
This vulnerability causes denial of service of the cross-chain indexing mechanism, which is critical infrastructure for parent-chain and side-chain communication in the AElf ecosystem.

**Concrete harm:**
- If 50+ side chains exist with proposals (expired or not), the cleanup loop makes 50+ cross-contract calls
- Each `Context.Call` consumes significant gas, and the cumulative cost can exceed transaction or block gas limits
- Miners' `ProposeCrossChainIndexing` transactions will fail due to out-of-gas errors
- New cross-chain indexing cannot be proposed, blocking all cross-chain data synchronization
- Both parent chain block data and side chain block data indexing are affected

**Who is affected:**
- All miners attempting to propose cross-chain indexing
- All side chains waiting for their block data to be indexed on the parent chain
- Parent chain services relying on cross-chain communication
- The entire cross-chain infrastructure becomes inoperable

**Severity justification:**
Medium severity is appropriate because the impact is high (complete DoS of cross-chain functionality) but likelihood is medium (requires accumulation of many side chains with proposals, which can occur naturally but not trivially).

### Likelihood Explanation
**Natural accumulation scenario:**
- Multiple side chains are created legitimately through governance over time (no explicit limit exists)
- Miners propose indexing for various chains as part of normal operations
- Proposals expire after 120 seconds if not approved/released quickly
- Expired proposals accumulate in the collection because cleanup only happens when `ProposeCrossChainIndexing` is called
- Once 50+ chains have proposals, the next miner attempting to propose indexing triggers the expensive cleanup loop

**Attacker capabilities:**
- An attacker cannot directly create many side chains without governance approval and locked tokens
- However, they don't need to - natural accumulation over time is sufficient
- The short 120-second expiration window makes it realistic for proposals to expire during busy periods

**Attack complexity:**
- Low complexity - the vulnerability is triggered simply by calling `ProposeCrossChainIndexing` when many proposals exist
- No special permissions needed beyond being a current miner (which is required anyway for this operation)

**Feasibility conditions:**
- Production deployment with 50+ side chains (realistic for a mature cross-chain ecosystem)
- Proposals exist for multiple chains simultaneously
- Some proposals expired but haven't been cleaned up yet

**Detection/operational constraints:**
- The issue manifests as out-of-gas failures on legitimate miner transactions
- Would appear as operational degradation rather than obvious attack
- Difficult to distinguish from legitimate high gas usage

### Recommendation

**1. Implement batched cleanup with gas limits:**
```
In ClearCrossChainIndexingProposalIfExpired():
- Add a maximum iterations limit (e.g., MAX_CLEANUP_PER_CALL = 10)
- Track last cleaned chain ID in state
- Only clean up to MAX_CLEANUP_PER_CALL proposals per transaction
- Resume from last position on next call
```

**2. Immediate cleanup of ACCEPTED proposals:**
Modify `RecordCrossChainData` to immediately call `ResetChainIndexingProposal` instead of just changing status to ACCEPTED: [9](#0-8) 

**3. Add separate maintenance function:**
Create a dedicated low-priority maintenance function for cleanup that can be called independently, removing the burden from the critical `ProposeCrossChainIndexing` path.

**4. Add invariant checks:**
- Assert that the cleanup loop processes at most MAX_CLEANUP_PER_CALL entries
- Monitor and alert when `ChainIndexingProposalCollections` exceeds a threshold size
- Add gas consumption checks before and during the loop

**5. Test cases to prevent regression:**
- Test with 100+ proposals in the collection and verify gas consumption
- Test that cleanup properly handles batching and doesn't miss proposals
- Test that ACCEPTED proposals are immediately removed after recording

### Proof of Concept

**Initial State:**
1. System has 60 side chains created (legitimate via governance)
2. Each chain has received an indexing proposal from miners
3. All 60 proposals have expired (current block time > expiration time of 120 seconds)
4. Proposals remain in `ChainIndexingProposalCollections` with either PENDING or ACCEPTED status

**Attack Steps:**
1. Current miner calls `ProposeCrossChainIndexing` with valid cross-chain block data
2. Method enters `ClearCrossChainIndexingProposalIfExpired()` at line 287
3. Loop iterates through all 60 proposals (line 568)
4. For each proposal, makes cross-contract call to `GetCrossChainProposal()` (60 calls total)
5. Gas consumption accumulates: 60 cross-contract calls Ã— gas_per_call
6. Transaction exceeds gas limit before completing cleanup
7. Transaction reverts with out-of-gas error

**Expected vs Actual Result:**
- Expected: Miner successfully proposes new cross-chain indexing
- Actual: Transaction fails with out-of-gas, no new indexing can be proposed

**Success Condition:**
The vulnerability is confirmed when:
- `ProposeCrossChainIndexing` transaction fails due to gas exhaustion
- The failure occurs during the cleanup loop before reaching actual proposal logic
- Subsequent attempts by other miners also fail until proposals are manually cleaned up
- Cross-chain indexing functionality is effectively disabled

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L287-287)
```csharp
        ClearCrossChainIndexingProposalIfExpired();
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L327-329)
```csharp
            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L395-395)
```csharp
            Assert(!TryGetIndexingProposal(chainId, out _), "Chain indexing already proposed.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L449-453)
```csharp
    private ProposalOutput GetCrossChainProposal(AuthorityInfo authorityInfo, Hash proposalId)
    {
        return Context.Call<ProposalOutput>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.GetProposal), proposalId);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L559-575)
```csharp
    private void ClearCrossChainIndexingProposalIfExpired()
    {
        var crossChainIndexingProposal = State.IndexingPendingProposal.Value;
        if (crossChainIndexingProposal == null)
        {
            State.IndexingPendingProposal.Value = new ProposedCrossChainIndexing();
            return;
        }

        foreach (var chainId in crossChainIndexingProposal.ChainIndexingProposalCollections.Keys.ToList())
        {
            var indexingProposal = crossChainIndexingProposal.ChainIndexingProposalCollections[chainId];
            var isExpired = CheckProposalExpired(GetCrossChainIndexingController(), indexingProposal.ProposalId);
            if (isExpired)
                ResetChainIndexingProposal(chainId);
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L585-589)
```csharp
    private bool CheckProposalExpired(AuthorityInfo authorityInfo, Hash proposalId)
    {
        var proposalInfo = GetCrossChainProposal(authorityInfo, proposalId);
        return proposalInfo.ExpiredTime <= Context.CurrentBlockTime;
    }
```

**File:** protobuf/cross_chain_contract.proto (L132-135)
```text
message ProposedCrossChainIndexing{
    // The collection of chain indexing proposal, the key is chain id.
    map<int32, ChainIndexingProposal> chain_indexing_proposal_collections = 1;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Constants.cs (L5-5)
```csharp
    private const int CrossChainIndexingProposalExpirationTimePeriod = 120;
```
