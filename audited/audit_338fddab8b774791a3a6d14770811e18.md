### Title
Infinite Loop in NFT Symbol Generation Causes DoS When Number Collision Occurs

### Summary
The `GenerateSymbolNumber()` function in `NFTContract_Helpers.cs` contains a critical flaw where it reuses the same random hash in its collision retry loop, causing it to generate the identical number on every iteration. When a collision occurs, the function loops up to 15,000 times before throwing `RuntimeBranchThresholdExceededException`, causing NFT creation to fail completely. As the number space fills with more NFTs, collision probability increases dramatically, eventually making NFT creation impossible.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` method: [1](#0-0) 

The root cause is in the do-while loop collision retry logic:

1. The `randomHash` is computed **once** before the loop using random bytes and sender hash [2](#0-1) 

2. The loop attempts to find an unused number, but uses the **same** `randomHash` in every iteration [3](#0-2) 

3. Since `ConvertHashToInt64()` is deterministic (computes `hash % range + start`), it returns the **identical** `randomNumber` every time [4](#0-3) 

4. If that `randomNumber` already exists in `State.IsCreatedMap`, the loop condition remains true forever

5. AElf's execution protection eventually terminates the loop after 15,000 branch iterations [5](#0-4) [6](#0-5) 

The function is called from the public `Create()` method that any user can invoke: [7](#0-6) 

**Why existing protections fail:**
- The `IsCreatedMap` tracking is global (not per-type), making the number space shared across all NFT types [8](#0-7) 
- Range expansion in `GetCurrentNumberLength()` doesn't help once inside the collision loop with a fixed range
- ExecutionBranchThreshold only prevents true infinite loops but causes transaction failure after wasting resources

### Impact Explanation

**Operational Impact - DoS of NFT Creation:**

1. **Immediate Harm**: When a collision occurs, NFT creation fails after looping 15,000 times and throwing `RuntimeBranchThresholdExceededException`. The transaction consumes significant resources before failing.

2. **Progressive Degradation**: As more NFTs are created, the collision probability increases:
   - Starting with 9-digit numbers (100,000,000 to 999,999,999), there are 900 million possible values
   - By the birthday paradox, 50% collision probability occurs around √(900M) ≈ 30,000 NFTs
   - As the space fills, success rate drops to near zero
   
3. **Affected Users**: All users attempting to create NFT protocols via the `Create()` method, regardless of NFT type chosen

4. **Protocol-Level Damage**: Eventually renders the NFT creation functionality completely unusable, requiring contract upgrade to restore service

**Severity Justification: HIGH**
- Core functionality permanently degraded
- Affects all users equally
- No graceful degradation or recovery mechanism
- Mathematically certain to occur as NFT count grows

### Likelihood Explanation

**Attack Complexity: LOW** (naturally occurs without deliberate attack)

1. **Reachable Entry Point**: Public `Create()` method callable by any user [9](#0-8) 

2. **Feasible Preconditions**: 
   - No special privileges required
   - Simply requires that the randomly generated number already exists in `IsCreatedMap`
   - Probability increases naturally with each NFT created

3. **Execution Practicality**: 
   - Happens automatically during normal NFT creation
   - Users don't need to take any special action
   - The flaw is triggered by the contract's own logic

4. **Probability Reasoning**:
   - With uniform random distribution and 900M possible 9-digit numbers
   - After creating ~30,000 NFTs: ~50% collision probability per creation attempt
   - After creating ~300,000 NFTs: ~99% collision probability
   - Beyond this point, NFT creation becomes effectively impossible

5. **Detection**: Users will observe transaction failures with branch threshold exceeded errors, but the root cause (deterministic collision retry) is not obvious

**Likelihood: HIGH** (becomes certain as NFT count increases)

### Recommendation

**Immediate Fix**: Regenerate a new random hash inside the collision retry loop:

```csharp
private long GenerateSymbolNumber()
{
    var length = GetCurrentNumberLength();
    var from = 1L;
    for (var i = 1; i < length; i++) from = from.Mul(10);

    long randomNumber;
    var attempts = 0;
    const int maxAttempts = 100; // Add reasonable limit
    
    do
    {
        // Generate NEW random hash in each iteration
        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(
            new Int64Value { Value = Context.CurrentHeight.Sub(1) }.ToBytesValue());
        var randomHash = HashHelper.ConcatAndCompute(
            HashHelper.ComputeFrom(Context.Sender),
            HashHelper.ComputeFrom(randomBytes),
            HashHelper.ComputeFrom(attempts)); // Add attempt counter for uniqueness
            
        randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        attempts++;
        
        // Fail gracefully if too many collisions
        if (attempts >= maxAttempts)
        {
            // Trigger range expansion or return error
            throw new AssertionException(
                "Unable to generate unique symbol number. Number space may be exhausted.");
        }
    } while (State.IsCreatedMap[randomNumber]);

    return randomNumber;
}
```

**Additional Safeguards**:
1. Add explicit collision tracking and logging
2. Implement proactive range expansion when collision rate exceeds threshold
3. Add per-type number tracking to distribute load across type prefixes
4. Monitor `IsCreatedMap` size and warn administrators

**Test Cases**:
1. Test with pre-filled `IsCreatedMap` containing many numbers to simulate high collision rate
2. Verify different numbers generated on successive calls
3. Test graceful failure when range approaches exhaustion
4. Verify range expansion triggers correctly under load

### Proof of Concept

**Required Initial State:**
1. NFT Contract deployed and initialized with type mappings [10](#0-9) 

2. Token contract address set
3. Random number provider contract address set

**Exploitation Steps:**

1. **Setup**: Pre-populate `IsCreatedMap` with a number that will collide
   - Create multiple NFTs until a specific number X is generated and stored

2. **Trigger Collision**: Call `Create()` with parameters that will generate the same number X
   ```
   Create({
       NftType: "Art",
       ProtocolName: "TestNFT",
       // ... other params
   })
   ```

3. **Observe Behavior**:
   - Transaction enters `GenerateSymbolNumber()` → `do-while` loop
   - Loop iterations: 1, 2, 3... all generate identical `randomNumber` = X
   - Each iteration checks `State.IsCreatedMap[X]` = true
   - Loop continues
   - At iteration 15,000: `RuntimeBranchThresholdExceededException` thrown
   - Transaction fails completely

**Expected Result**: Graceful failure with informative error or successful generation of different number

**Actual Result**: Transaction fails after wasting 15,000 loop iterations with `RuntimeBranchThresholdExceededException`

**Success Condition**: The vulnerability is confirmed when:
- Transaction repeatedly generates same number despite collision
- Transaction fails due to branch threshold exceeded
- No alternative number is attempted
- Failure is not graceful and provides no useful feedback

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L27-27)
```csharp
        State.IsCreatedMap[randomNumber] = true;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L39-63)
```csharp
    private NFTTypes InitialNFTTypeNameMap()
    {
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;

        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;

        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }

        return nftTypes;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L29-36)
```csharp
    public void BranchCount()
    {
        if (_branchThreshold != -1 && _branchCount == _branchThreshold)
            throw new RuntimeBranchThresholdExceededException(
                $"Contract branch threshold {_branchThreshold} exceeded.");

        _branchCount++;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-7)
```csharp
    public const int ExecutionCallThreshold = 15000;

    public const int ExecutionBranchThreshold = 15000;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-21)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
```
