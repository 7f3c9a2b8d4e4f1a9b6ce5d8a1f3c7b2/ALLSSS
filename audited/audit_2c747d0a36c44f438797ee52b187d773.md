### Title
Association Organization Can Become Functionally Empty While Count() Reports Non-Zero Members

### Summary
The Association contract fails to validate whether addresses in the organization member list are valid (non-null, non-empty). This allows organizations to contain invalid addresses that contribute to `Count()` but cannot participate in governance, violating the invariant that `Empty()` accurately reflects functional emptiness. An organization can become completely bricked with non-zero member count but no valid members able to vote or create proposals.

### Finding Description

**Root Cause:**

The `AddMember` and `CreateOrganization` methods do not validate that input addresses have non-empty values. [1](#0-0) 

The `Validate` method only checks if the member list itself is empty and has duplicates, but does not validate individual address validity. [2](#0-1) 

In contrast, other contracts like MultiToken properly validate addresses using `AssertValidInputAddress`, which checks `input != null && !input.Value.IsNullOrEmpty()`. [3](#0-2) 

The `ByteString.IsNullOrEmpty()` extension method exists but is not used in Association contract validation. [4](#0-3) 

**Why Existing Protections Fail:**

The `OrganizationMemberList.Empty()` method only checks `Count() == 0`, not whether members are valid. [5](#0-4) 

The protobuf `Address` type allows empty `value` bytes, and an Address with `Value.IsEmpty == true` can be added to the member list without triggering any validation errors. [6](#0-5) 

**Execution Path:**

1. Organization is created with valid members A, B, C
2. Member A creates proposal to add an Address with empty Value field via `AddMember`
3. Members vote and approve (malicious insider or compromised keys)
4. Proposal executes, adding invalid address (Count = 4)
5. Another proposal removes all valid members A, B, C
6. Organization now has Count = 1, but only invalid address remains
7. No one can vote (requires `Contains(Context.Sender)` check) or create proposals [7](#0-6) 

### Impact Explanation

**Governance DoS:** An Association organization can be permanently bricked, making it impossible to:
- Create new proposals (requires authorized member via `AssertIsAuthorizedOrganizationMember`)
- Vote on existing proposals (approval/rejection/abstention all require valid membership)
- Release proposals (threshold checks use `Contains` which would never match invalid addresses)

**Affected Parties:**
- Organizations using Association contract for multi-sig governance
- Protocols relying on Association organizations for critical configuration changes
- Any system where an Association organization controls important protocol parameters

**Severity Justification:** Medium to High
- While requiring insider action (existing member must propose), the damage is permanent
- Organizations managing critical protocol functions could be rendered inoperable
- The attack is irreversible - once all valid members are removed, the organization cannot be recovered
- Violates fundamental invariant that `Empty() == false` implies the organization is functional

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an existing organization member (or control enough members to pass proposals)
- Does not require any special system privileges
- Can be executed by compromised member keys or malicious insiders

**Attack Complexity:** Low
- Simple two-step process: add invalid address, remove valid members
- No complex timing or race conditions required
- No external contract interactions needed

**Feasibility Conditions:**
- Organization must have proposal approval threshold reachable by attacker
- For single attacker: need enough voting power to pass both proposals
- For coordinated attack: multiple compromised members could execute easily

**Detection Constraints:**
- Invalid addresses appear identical to valid addresses in storage (both are Address objects)
- No on-chain mechanism to detect empty Address values in member lists
- Organization appears valid by all current checks until someone tries to use it

**Probability:** Medium to High
- Common scenario: compromised keys in multi-sig setup
- Social engineering could trick members into approving "address updates"
- Organizations with low approval thresholds particularly vulnerable

### Recommendation

**Code-Level Mitigation:**

Add address validation helper method in `Association_Helper.cs`:
```csharp
private void AssertValidAddress(Address address)
{
    Assert(address != null && !address.Value.IsNullOrEmpty(), "Invalid address.");
}
```

Update `AddMember` to validate input:
```csharp
public override Empty AddMember(Address input)
{
    AssertValidAddress(input);  // Add this line
    var organization = State.Organizations[Context.Sender];
    // ... rest of method
}
```

Update `ChangeMember` to validate new member:
```csharp
public override Empty ChangeMember(ChangeMemberInput input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    AssertValidAddress(input.NewMember);  // Add this line
    // ... rest of method
}
```

Update `Validate` method to check all member addresses:
```csharp
private bool Validate(Organization organization)
{
    if (organization.ProposerWhiteList.Empty() ||
        organization.ProposerWhiteList.AnyDuplicate() ||
        organization.OrganizationMemberList.Empty() ||
        organization.OrganizationMemberList.AnyDuplicate())
        return false;
    
    // Add validation for all member addresses
    foreach (var member in organization.OrganizationMemberList.OrganizationMembers)
    {
        if (member == null || member.Value.IsNullOrEmpty())
            return false;
    }
    
    // ... rest of validation
}
```

**Test Cases:**

1. Test creating organization with empty Address - should fail
2. Test adding empty Address to existing organization - should fail  
3. Test changing member to empty Address - should fail
4. Test that valid addresses continue to work normally
5. Test edge case: Address with all-zero bytes (technically valid length but semantically invalid)

### Proof of Concept

**Initial State:**
- Association contract deployed
- User A, B, C with valid addresses and key pairs

**Attack Steps:**

1. Create organization with members A, B, C:
   ```
   CreateOrganization({
     organization_member_list: [A, B, C],
     proposal_release_threshold: {
       minimal_approval_threshold: 2,
       minimal_vote_threshold: 2,
       ...
     }
   })
   ```
   Result: Organization created, Count() = 3

2. Create and approve proposal to add invalid address:
   ```
   CreateProposal(AddMember(new Address())) // Empty Address
   A.Approve(proposalId)
   B.Approve(proposalId)
   Release(proposalId)
   ```
   Result: Count() = 4, members = [A, B, C, empty]

3. Create and approve proposal to remove member A:
   ```
   CreateProposal(RemoveMember(A))
   A.Approve(proposalId) // A votes to remove self
   B.Approve(proposalId)
   Release(proposalId)
   ```
   Result: Count() = 3, members = [B, C, empty]

4. Repeat step 3 for B and C:
   Result: Count() = 1, members = [empty]

**Expected Result:** 
Organization should reject invalid addresses at step 2

**Actual Result:**
- Count() = 1
- Empty() = false (since Count() != 0)
- Organization completely non-functional - no one can vote or create proposals
- `AssertIsAuthorizedOrganizationMember` will always fail since no valid sender can match the empty address
- Organization is permanently bricked

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L233-245)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L18-22)
```csharp
    private void AssertIsAuthorizedOrganizationMember(Organization organization, Address member)
    {
        Assert(organization.OrganizationMemberList.Contains(member),
            "Unauthorized member.");
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-97)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
    }
```

**File:** src/AElf.Types/Extensions/ByteStringExtensions.cs (L34-37)
```csharp
        public static bool IsNullOrEmpty(this ByteString byteString)
        {
            return byteString == null || byteString.IsEmpty;
        }
```

**File:** contract/AElf.Contracts.Association/OrganizationMemberList.cs (L12-15)
```csharp
    public bool Empty()
    {
        return Count() == 0;
    }
```

**File:** protobuf/aelf/core.proto (L135-138)
```text
message Address
{
    bytes value = 1;
}
```
