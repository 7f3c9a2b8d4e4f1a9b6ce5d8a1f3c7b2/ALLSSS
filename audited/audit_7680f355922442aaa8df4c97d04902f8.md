### Title
Insufficient Recharge Validation Allows Side Chain to Immediately Fall Back Into Debt

### Summary
The `Recharge` function contains a flawed assertion that double-counts the recharge amount when validating minimum recharge requirements. This allows side chains to be recharged with insufficient funds (as little as `arrears + indexingPrice/2` instead of `arrears + indexingPrice`), causing the chain to immediately transition back to `IndexingFeeDebt` status upon the next block indexing, wasting the recharger's funds and preventing proper chain reactivation.

### Finding Description

The vulnerability exists in the recharge validation logic in `CrossChainContract.cs`. [1](#0-0) 

**Root Cause:**

The assertion on line 207-208 validates: `input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice`

However, `originBalance` is fetched AFTER arrears have been paid from the chain's virtual address. [2](#0-1) 

The execution flow is:
1. Transfer `input.Amount` (R) from sender to chain → balance becomes `B_initial + R`
2. Pay all arrears (A) from chain balance → balance becomes `B_initial + R - A`
3. Fetch `originBalance = B_initial + R - A`
4. Assert: `R + (B_initial + R - A) >= A + P` where P = IndexingPrice

This simplifies to: `2R + B_initial >= 2A + P`

For a fully drained chain (`B_initial = 0`), the minimum recharge is:
- `2R >= 2A + P`
- `R >= A + P/2`

But the **correct** requirement should be that after paying arrears, enough remains for at least one indexing operation:
- `B_initial + R - A >= P`
- `R >= A - B_initial + P`

For `B_initial = 0`: `R >= A + P` (not `A + P/2`)

**Why Existing Protections Fail:**

When `IndexingPrice >= 2`, the faulty assertion allows recharges with `R = A + P/2`, leaving only `P/2` balance after paying arrears. During subsequent indexing in `IndexSideChainBlockData`: [3](#0-2) 

The chain status is `Active` (set by Recharge), so `lockedToken = GetSideChainIndexingFeeDeposit(chainId) = P/2`. When processing the first block, `lockedToken -= indexingPrice` results in `P/2 - P = -P/2`, which is negative. The chain immediately records new arrears and transitions back to `IndexingFeeDebt` status. [4](#0-3) 

### Impact Explanation

**Direct Financial Impact:**
- Rechargers lose funds without achieving the intended chain reactivation
- With `IndexingPrice = 10` and `arrears = 100`, a user can recharge with 105 tokens (instead of required 110), paying 100 to clear arrears but leaving only 5 tokens in balance
- The next indexing operation requires 10 tokens, immediately creating 10 tokens of new arrears
- The proposer/miner is not compensated for indexing, accumulating more debt

**Operational Impact:**
- Side chains cannot be properly reactivated from debt status
- Continuous recharge cycles waste funds without enabling indexing
- Cross-chain functionality is disrupted as chains remain in `IndexingFeeDebt` status
- Trust in the side chain fee system is undermined

**Affected Parties:**
- Side chain operators who attempt to recharge their chains
- Miners/proposers who index blocks but don't receive payment
- Users relying on cross-chain functionality

**Severity Justification:**
This is a **High** severity issue because it directly causes fund loss through wasted recharges, prevents proper operation of the cross-chain indexing system, and can be triggered whenever `IndexingPrice >= 2` (common in production scenarios).

### Likelihood Explanation

**Attacker Capabilities:**
- Any user can call the public `Recharge` function for any side chain
- No special permissions required beyond token allowance
- The vulnerability triggers automatically when using minimum allowed recharge amounts

**Attack Complexity:**
- Low complexity: simply call `Recharge` with the minimum amount that passes the flawed assertion
- Mathematical: for `arrears = 100`, `indexingPrice = 10`, recharge with 105 tokens
- No race conditions or timing dependencies required

**Feasibility Conditions:**
- Side chain must be in `IndexingFeeDebt` status (common operational state)
- `IndexingPrice >= 2` (typical in production; the test suite uses `indexingPrice = 1` which masks the issue)
- Chain balance must be sufficiently drained (`B_initial ~ 0`)

**Economic Rationality:**
While not profitable for an "attacker," this is a critical bug affecting legitimate operators:
- Side chain operators attempting minimal recharges lose funds
- The issue manifests naturally during normal operations, not just targeted attacks
- Detection is difficult as the transaction succeeds but chain immediately returns to debt

**Probability:**
High probability of occurrence in production environments where side chains run low on funds and operators attempt minimal recharges to reduce costs.

### Recommendation

**Code-Level Mitigation:**

Replace the assertion in `CrossChainContract.cs` lines 207-208 with:

```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

This correctly validates that after paying all arrears, the remaining balance is sufficient for at least one indexing operation.

**Invariant to Enforce:**
After a successful `Recharge` that transitions a chain from `IndexingFeeDebt` to `Active` status:
- `GetSideChainIndexingFeeDeposit(chainId) >= sideChainInfo.IndexingPrice` must hold

**Test Cases to Add:**

1. Test recharge with `indexingPrice = 10`, `arrears = 100`, attempting `rechargeAmount = 105` (should fail)
2. Test recharge with `indexingPrice = 10`, `arrears = 100`, with `rechargeAmount = 110` (should succeed and allow one block indexing)
3. Test that after minimum valid recharge, at least one block can be indexed without falling back into debt
4. Parameterized tests with various `indexingPrice` values (2, 10, 100) to ensure consistent behavior

### Proof of Concept

**Initial State:**
- Side chain exists with `chainId = 123`
- `IndexingPrice = 10`
- Chain status = `IndexingFeeDebt`
- Accumulated arrears = 100 tokens (10 blocks indexed while in debt)
- Chain balance = 0 (fully drained)

**Exploitation Steps:**

1. **Call Recharge with minimum passing amount:**
   ```
   Recharge(chainId: 123, amount: 105)
   ```

2. **Execution trace:**
   - Transfer 105 tokens from sender to chain → balance = 105
   - Pay 100 tokens in arrears to proposers → balance = 5
   - Fetch `originBalance = 5`
   - Assert: `105 + 5 >= 100 + 10` → `110 >= 110` ✓ (passes)
   - Set chain status to `Active`
   - Chain balance = 5

3. **Next indexing operation (one block proposed):**
   - Chain status is `Active`, so `lockedToken = GetSideChainIndexingFeeDeposit(123) = 5`
   - Process block: `lockedToken -= 10` → `lockedToken = -5`
   - Since `lockedToken < 0`: record `arrearsAmount += 10`, set status to `IndexingFeeDebt`
   - Proposer is NOT paid (no `indexingFeeAmount` increment)

**Expected vs Actual Result:**
- **Expected:** After recharge, at least one block should be indexable with proposer payment
- **Actual:** Chain immediately returns to `IndexingFeeDebt`, proposer unpaid, 105 tokens wasted

**Success Condition:**
The vulnerability is confirmed when a recharge with `arrears + indexingPrice/2` passes validation but leaves insufficient balance (`< indexingPrice`), causing immediate return to debt status upon next indexing.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L181-208)
```csharp
        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L828-855)
```csharp
            var lockedToken = sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt
                ? 0
                : GetSideChainIndexingFeeDeposit(chainId);

            foreach (var sideChainBlockData in sideChainBlockDataList)
            {
                var target = currentSideChainHeight != 0
                    ? currentSideChainHeight + 1
                    : AElfConstants.GenesisBlockHeight;
                var sideChainHeight = sideChainBlockData.Height;
                if (target != sideChainHeight)
                    break;

                // indexing fee
                var indexingPrice = sideChainInfo.IndexingPrice;

                lockedToken -= indexingPrice;

                if (lockedToken < 0)
                {
                    // record arrears
                    arrearsAmount += indexingPrice;
                    sideChainInfo.SideChainStatus = SideChainStatus.IndexingFeeDebt;
                }
                else
                {
                    indexingFeeAmount += indexingPrice;
                }
```
