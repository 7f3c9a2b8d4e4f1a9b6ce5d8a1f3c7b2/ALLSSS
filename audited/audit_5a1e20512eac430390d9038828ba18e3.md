### Title
Inactive Miners Inflate MinersCountOfConsent Causing Last Irreversible Block (LIB) Calculation Failure

### Summary
The `MinersCountOfConsent` property uses `RealTimeMinersInformation.Count` which includes all registered miners, including those that have become inactive but have not yet been banned. This creates a mismatch with LIB calculation logic that only counts miners who actually participated, potentially preventing block finalization for extended periods when more than 1/3 of miners are inactive.

### Finding Description

The `MinersCountOfConsent` property calculates the consensus threshold as: [1](#0-0) 

This count includes ALL miners in `RealTimeMinersInformation`, regardless of whether they are actively participating. During round generation, all miners from the previous round are carried forward, including those who did not mine: [2](#0-1) 

The LIB calculation requires that the count of implied irreversible heights from active miners meets the `MinersCountOfConsent` threshold: [3](#0-2) 

However, `impliedIrreversibleHeights` only includes data from miners who actually mined in the current round (determined by `SupposedOrderOfNextRound != 0`): [4](#0-3) 

Inactive miners are only detected and banned after accumulating at least `TolerableMissedTimeSlotsCount` (4320) missed time slots: [5](#0-4) [6](#0-5) 

The evil miner detection and banning only occurs during `ProcessNextRound`: [7](#0-6) 

**Root Cause:** There is no validation ensuring that `RealTimeMinersInformation.Count` represents only active participants. Inactive miners remain counted for up to 4320 rounds (approximately 3 days) before being removed, creating a mismatch between the expected consensus threshold and the actual number of active miners.

### Impact Explanation

**Operational Impact - Consensus Denial of Service:**
- When more than 1/3 of registered miners become inactive but have not yet reached the 4320 missed slots threshold, the LIB calculation fails
- With LIB = 0, no blocks can be confirmed as irreversible
- This affects the entire blockchain's ability to finalize transactions

**Quantified Scenario:**
- Total miners: 21
- `MinersCountOfConsent` = 21 × 2 ÷ 3 + 1 = 15
- If 8 miners become inactive: only 13 miners participate
- `impliedIrreversibleHeights.Count` = 13 (at most)
- Since 13 < 15, LIB calculation returns 0
- Block finalization is blocked until inactive miners are banned (up to 4320 rounds)

**Affected Parties:**
- All blockchain users unable to rely on transaction finality
- Cross-chain operations dependent on LIB heights
- Economic activities requiring settlement guarantees

### Likelihood Explanation

**Feasibility:**
- Multiple miners can go offline simultaneously due to:
  - Network partitions or DDoS attacks
  - Infrastructure failures (cloud provider outages)
  - Software bugs affecting multiple nodes
  - Coordinated malicious behavior

**Attack Complexity:**
- No special privileges required
- Miners simply stop participating (passive attack)
- No transaction costs for the attacker

**Operational Constraints:**
- Requires > 1/3 of total registered miners to be inactive
- Condition persists for duration of downtime or until 4320 rounds elapse
- Detection is visible through monitoring but mitigation takes time

**Probability Assessment:**
- Medium-to-High likelihood in scenarios with:
  - Concentrated infrastructure (many miners on same provider)
  - Network-wide attacks or issues
  - Malicious coordination among miners

The 3-day delay (4320 rounds) provides substantial window for exploitation or occurrence of this condition.

### Recommendation

**Immediate Mitigation:**
Modify `MinersCountOfConsent` calculation to use only active miners:

1. **Option A:** Calculate based on miners who participated in recent rounds
   - Track miners who have successfully produced blocks in last N rounds
   - Use this active count instead of total `RealTimeMinersInformation.Count`

2. **Option B:** Reduce `TolerableMissedTimeSlotsCount` threshold
   - Current value of 4320 (3 days) is too permissive
   - Consider reducing to 100-500 rounds to enable faster removal

3. **Option C:** Adjust LIB calculation logic
   - Use `minedMiners.Count` instead of `MinersCountOfConsent` for the threshold
   - Calculate dynamic threshold: `max(minedMiners.Count * 2/3 + 1, minimum_required)`

**Invariant to Add:**
- Assert that active miner participation rate stays above minimum threshold
- Fire warning event when inactive miner ratio exceeds safety margin (e.g., 25%)

**Test Cases:**
- Scenario with 1/3 + 1 miners going offline simultaneously
- Verify LIB calculation continues functioning
- Test evil miner detection and replacement timing
- Validate term change behavior under reduced active miner count

### Proof of Concept

**Initial State:**
- 21 miners registered in `RealTimeMinersInformation`
- All miners initially active and producing blocks

**Attack Steps:**
1. **Round 1:** 8 miners (38% of total) stop producing blocks
   - These miners' `SupposedOrderOfNextRound` remains 0
   - Their `MissedTimeSlots` increments by 1 each round

2. **Round 2-4319:** Continue with only 13 active miners
   - `MinersCountOfConsent` = 21 × 2 ÷ 3 + 1 = 15
   - `GetMinedMiners()` returns only 13 miners
   - LIB calculation: `impliedIrreversibleHeights.Count` = 13
   - Check fails: 13 < 15
   - LIB = 0 (no blocks can be finalized)

3. **Round 4320:** Inactive miners finally banned
   - `TryToDetectEvilMiners` identifies 8 miners with `MissedTimeSlots >= 4320`
   - These miners marked as evil and added to `BannedPubkeyMap`

4. **Round 4321:** Next round generated with replacement miners
   - `GetMinerReplacementInformation` finds 8 evil miners
   - Alternative candidates replace them
   - `RealTimeMinersInformation.Count` returns to effective count
   - LIB calculation resumes normally

**Expected vs Actual Result:**
- **Expected:** LIB should calculate based on active miners, allowing block finalization
- **Actual:** LIB = 0 for 4320 rounds (3 days), preventing any block finalization

**Success Condition:**
The vulnerability is confirmed when LIB remains at 0 despite having sufficient active miners to reach 2/3 consensus, solely due to inactive miners being counted in the threshold calculation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L16-56)
```csharp
        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L24-30)
```csharp
            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```
