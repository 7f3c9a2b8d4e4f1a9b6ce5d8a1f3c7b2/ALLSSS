### Title
Missing Order Value Validation in NextTerm Allows Consensus DoS via Malformed Round Data

### Summary
The NextTerm consensus behavior lacks validation of miner Order values in RealTimeMinersInformation, allowing a malicious block producer to submit a Round with zero or negative Order values. This bypasses the Order validation that exists for NextRound behavior, causing critical consensus methods to throw exceptions and halting block production.

### Finding Description

**Root Cause:**

The `NextTermInput.Create()` method copies RealTimeMinersInformation from a Round object without validating Order values. [1](#0-0) 

The validation system for NextTerm behavior does not include Order value checks. In `AEDPoSContract_Validation.cs`, the NextTerm case only adds `RoundTerminateValidationProvider`: [2](#0-1) 

In contrast, NextRound behavior includes `NextRoundMiningOrderValidationProvider` which validates `FinalOrderOfNextRound > 0`: [3](#0-2) [4](#0-3) 

The `RoundTerminateValidationProvider` used for NextTerm only validates round number and term number increments, not Order values: [5](#0-4) 

**Why Normal Generation Produces Valid Values:**

Honest execution generates valid Order values through `MinerList.GenerateFirstRoundOfNewTerm`: [6](#0-5) 

However, a malicious miner can bypass this by crafting consensus extra data directly with invalid Order values.

**Exploitation Path:**

When a miner produces a NextTerm block, they generate consensus extra data via `GetConsensusExtraDataForNextTerm`, which calls `GenerateFirstRoundOfNextTerm`: [7](#0-6) 

A malicious miner can modify this process to inject a Round with Order = 0 or negative values, which then gets processed without Order validation and stored via `ProcessNextTerm`: [8](#0-7) 

### Impact Explanation

**Critical Method Failures:**

Multiple consensus-critical methods assume valid Order values and will throw exceptions:

1. **GetMiningInterval()** - Used to calculate time between block production slots. Queries miners with `Order == 1 || Order == 2` and indexes the result without bounds checking: [9](#0-8) 

If no miners have Order 1 or 2, `firstTwoMiners[0]` and `firstTwoMiners[1]` throw `IndexOutOfRangeException`.

2. **BreakContinuousMining()** - Prevents the same miner from producing consecutive blocks. Uses `.First(i => i.Order == 1)` which throws `InvalidOperationException` if no miner has Order 1: [10](#0-9) 

3. **FirstMiner()** - Returns null if no miner has Order 1, causing null reference exceptions in calling code: [11](#0-10) 

**Consensus Halt:**

With corrupted Order values, the blockchain cannot:
- Calculate mining time slots (GetMiningInterval fails)
- Generate subsequent rounds (GenerateNextRoundInformation fails)
- Determine block producer schedule (extra block producer selection fails)
- Validate time slots (TimeSlotValidationProvider depends on Order)

This results in complete consensus failure and chain halt until manual intervention.

**Who Is Affected:**

All network participants lose consensus functionality. The entire blockchain stops producing blocks until the corrupted round state is manually recovered or the chain is reset.

### Likelihood Explanation

**Attacker Capabilities:**

The attacker must be a miner in the current term who is scheduled to produce the NextTerm block. In AEDPoS consensus, miners rotate, so any miner could eventually be in position to trigger NextTerm.

**Attack Complexity:**

Low. The attacker needs to:
1. Modify their node software to craft malicious Round data with Order = 0 for all miners
2. Submit this in the NextTerm transaction when producing the term transition block
3. The malformed data passes validation due to the missing Order checks

**Feasibility:**

The attack is feasible because:
- Miners control the consensus extra data they submit
- No cryptographic or mathematical constraints prevent Order = 0
- The validation gap is straightforward to exploit
- No additional blockchain state manipulation required

**Detection:**

The attack would be immediately detected after execution as consensus methods begin throwing exceptions. However, by then the malformed Round is already stored in state, causing persistent DoS until manual recovery.

**Economic Rationality:**

While attacking one's own chain may seem irrational, scenarios include:
- Compromised miner node
- Malicious miner attempting to halt the chain for competitive advantage
- Attacker willing to sacrifice miner status for ecosystem disruption
- Bug or misconfiguration in miner software

### Recommendation

**Add Order Validation to NextTerm:**

Extend the validation for NextTerm behavior to include Order value checks. In `AEDPoSContract_Validation.cs`, add a new validation provider or modify the existing flow:

```csharp
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new NextTermOrderValidationProvider()); // New validator
    validationProviders.Add(new RoundTerminateValidationProvider());
    break;
```

**Create NextTermOrderValidationProvider:**

Implement a new validator that checks all miners have valid Order values in the range [1, minerCount]:

```csharp
public class NextTermOrderValidationProvider : IHeaderInformationValidationProvider
{
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var round = validationContext.ExtraData.Round;
        var minersCount = round.RealTimeMinersInformation.Count;
        
        foreach (var miner in round.RealTimeMinersInformation.Values)
        {
            if (miner.Order < 1 || miner.Order > minersCount)
            {
                return new ValidationResult 
                { 
                    Message = $"Invalid Order value {miner.Order} for miner {miner.Pubkey}. Must be in range [1, {minersCount}]." 
                };
            }
        }
        
        // Verify no duplicate Order values
        var orders = round.RealTimeMinersInformation.Values.Select(m => m.Order).ToList();
        if (orders.Distinct().Count() != orders.Count)
        {
            return new ValidationResult { Message = "Duplicate Order values detected." };
        }
        
        return new ValidationResult { Success = true };
    }
}
```

**Test Cases:**

Add regression tests that verify:
1. NextTerm transactions with Order = 0 are rejected
2. NextTerm transactions with negative Order values are rejected  
3. NextTerm transactions with duplicate Order values are rejected
4. NextTerm transactions with Order > minerCount are rejected
5. Valid NextTerm transactions with proper Order values [1, N] are accepted

### Proof of Concept

**Initial State:**
- Chain is running with N miners in current term
- One miner (Attacker) is scheduled to produce the NextTerm block

**Attack Steps:**

1. Attacker's turn to produce NextTerm block arrives
2. Instead of calling `GenerateFirstRoundOfNextTerm()` which assigns Order = i + 1, attacker crafts malicious Round:
   ```csharp
   var maliciousRound = new Round
   {
       RoundNumber = currentRound.RoundNumber + 1,
       TermNumber = currentRound.TermNumber + 1,
       RealTimeMinersInformation = {
           { "miner1", new MinerInRound { Pubkey = "miner1", Order = 0 } },
           { "miner2", new MinerInRound { Pubkey = "miner2", Order = 0 } },
           // ... all miners with Order = 0
       }
   };
   var maliciousInput = NextTermInput.Create(maliciousRound, randomNumber);
   ```

3. Submit NextTerm transaction with malicious input
4. Transaction passes `ValidateConsensusBeforeExecution` (only checks round/term numbers)
5. `ProcessNextTerm` stores the malicious Round
6. Next block producer attempts to generate consensus command
7. Consensus methods call `GetMiningInterval()` which executes:
   ```csharp
   var firstTwoMiners = RealTimeMinersInformation.Values
       .Where(m => m.Order == 1 || m.Order == 2).ToList();
   // firstTwoMiners is empty (no miners have Order 1 or 2)
   return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)...);
   // IndexOutOfRangeException thrown
   ```

**Expected Result:** NextTerm transaction is rejected with validation error about invalid Order values

**Actual Result:** NextTerm transaction succeeds, malicious Round is stored, subsequent consensus operations throw exceptions, blockchain halts

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L9-25)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Miners that have determined the order of the next round should be equal to
        // miners that mined blocks during current round.
        var validationResult = new ValidationResult();
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L206-220)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextTerm(string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        var firstRoundOfNextTerm = GenerateFirstRoundOfNextTerm(pubkey, State.MiningInterval.Value);
        Assert(firstRoundOfNextTerm.RoundId != 0, "Failed to generate new round information.");
        if (firstRoundOfNextTerm.RealTimeMinersInformation.ContainsKey(pubkey))
            firstRoundOfNextTerm.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = firstRoundOfNextTerm,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-90)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
```
