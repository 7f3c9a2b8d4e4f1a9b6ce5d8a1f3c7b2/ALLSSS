### Title
Insufficient Fee Coefficient Validation Enables Fee Under-Calculation for High-Volume Transactions

### Summary
The `AssertPieceUpperBoundsIsInOrder()` function only validates ordering and uniqueness of piece upper bounds but fails to ensure complete coverage of the input space. A governance proposal can update the last piece's upper bound from `int.MaxValue` to a smaller value, causing the fee calculation to stop prematurely and under-calculate fees for high-volume transactions.

### Finding Description

The validation function at [1](#0-0)  checks only two conditions: (1) no duplicate upper bounds, and (2) upper bounds are in ascending order. It does not validate that the last piece extends to `int.MaxValue` to ensure all possible input values are covered.

The fee calculation logic at [2](#0-1)  iterates through pieces sequentially, calculating fees for each interval. When the loop completes without processing all units (because `remainCount > 0` but no more pieces exist), the remaining units are silently ignored and no fee is calculated for them.

The `UpdateCoefficients()` method at [3](#0-2)  allows governance to update any existing piece's coefficients, including changing the last piece's upper bound. After updating, it calls the insufficient validation function, which passes even when the last upper bound is reduced below `int.MaxValue`.

All initial coefficients correctly use `int.MaxValue` for their last piece (see [4](#0-3) ), but this invariant can be broken through updates.

### Impact Explanation

**Direct Financial Impact**: Users will pay significantly reduced fees for high-volume transactions. For example, if the last piece's upper bound is changed from `int.MaxValue` to `1000`, a transaction with `totalCount = 2000` will only have fees calculated for 1000 units, with the remaining 1000 units charged zero fees.

**Resource Underpricing**: This affects all resource token types (READ, WRITE, STORAGE, TRAFFIC) and transaction fees (TX), as each uses the same fee calculation mechanism at [5](#0-4) .

**DoS Vector**: Attackers can exploit underpriced fees to spam the network with high-volume transactions at a fraction of the intended cost, potentially causing resource exhaustion and network congestion.

**System-Wide Impact**: All users benefit from reduced fees once the configuration is changed, making this an economic attack on the protocol's sustainability rather than theft from individual users.

### Likelihood Explanation

**Entry Point**: The vulnerability is triggered through `UpdateCoefficientsForContract()` at [6](#0-5) , which is protected by `AssertDeveloperFeeController()` at [7](#0-6) .

**Preconditions**: Requires governance approval through the DeveloperFeeController, which involves a multi-layer governance structure with Parliament and Association controllers as shown in [8](#0-7) .

**Execution Practicality**: While governance-gated, this is not a "trusted role compromise" scenario. The vulnerability exists because the contract accepts invalid configurations that governance could set either maliciously or through honest mistake. The insufficient validation creates a systemic risk that should be prevented at the contract level.

**Detection Difficulty**: The misconfiguration may not be immediately obvious during proposal review, as coefficients are complex mathematical functions and the validation appears to pass all checks.

### Recommendation

Add comprehensive validation to `AssertPieceUpperBoundsIsInOrder()`:

```csharp
private void AssertPieceUpperBoundsIsInOrder(
    IReadOnlyCollection<CalculateFeePieceCoefficients> calculateFeePieceCoefficientsList)
{
    Assert(calculateFeePieceCoefficientsList.Count > 0, "At least one piece is required.");
    
    // No same piece upper bound
    Assert(!calculateFeePieceCoefficientsList.GroupBy(i => i.Value[0]).Any(g => g.Count() > 1),
        "Piece upper bounds contains same elements.");

    var pieceUpperBounds = calculateFeePieceCoefficientsList.Select(l => l.Value[0]).ToList();
    var orderedEnumerable = pieceUpperBounds.OrderBy(i => i).ToList();
    for (var i = 0; i < calculateFeePieceCoefficientsList.Count; i++)
        Assert(pieceUpperBounds[i] == orderedEnumerable[i], "Piece upper bounds not in order.");
    
    // NEW: Ensure the last piece covers all possible inputs
    var lastUpperBound = pieceUpperBounds[pieceUpperBounds.Count - 1];
    Assert(lastUpperBound == int.MaxValue, 
        "Last piece upper bound must be int.MaxValue to cover all inputs.");
}
```

Add test cases that attempt to update the last piece to values less than `int.MaxValue` and verify they are rejected.

### Proof of Concept

**Initial State**: READ fee type has pieces with upper bounds `[10, 100, int.MaxValue]` as initialized in [9](#0-8) .

**Attack Sequence**:
1. Governance creates proposal to update piece 3 (index 2) with new upper bound `1000`
2. Input: `UpdateCoefficientsInput { PieceNumbers: [3], Coefficients: { FeeTokenType: 0, PieceCoefficientsList: [{ Value: [1000, 2, 25, 16, 1, 1, 4] }] } }`
3. Validation at line 64 passes: `10 < 100 < 1000` (ordered), all unique
4. State updated to upper bounds `[10, 100, 1000]`

**Exploitation**:
1. User submits transaction with READ count = `2000`
2. Fee calculation processes:
   - Piece 1: interval `[0, 10]`, calculates 10 units
   - Piece 2: interval `[10, 100]`, calculates 90 units  
   - Piece 3: interval `[100, 1000]`, calculates 900 units
   - Loop ends with `remainCount = 1000` unprocessed
3. **Expected**: Fee for 2000 units
4. **Actual**: Fee for only 1000 units (50% under-calculation)

**Success Condition**: The transaction is charged significantly less than the intended fee amount, enabling resource underpricing and potential DoS attacks.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L16-23)
```csharp
    public override Empty UpdateCoefficientsForContract(UpdateCoefficientsInput input)
    {
        Assert(input.Coefficients != null, "Invalid input coefficients.");
        Assert(input.Coefficients.FeeTokenType != (int)FeeTypeEnum.Tx, "Invalid fee type.");
        AssertDeveloperFeeController();
        UpdateCoefficients(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L34-72)
```csharp
    private void UpdateCoefficients(UpdateCoefficientsInput input)
    {
        var feeType = input.Coefficients.FeeTokenType;
        var currentAllCoefficients = State.AllCalculateFeeCoefficients.Value;

        // Get coefficients for specific fee type.
        var currentCoefficients = currentAllCoefficients.Value.SingleOrDefault(x =>
            x.FeeTokenType == feeType);
        Assert(currentCoefficients != null, "Specific fee type not existed before.");

        var inputPieceCoefficientsList = input.Coefficients.PieceCoefficientsList;
        // ReSharper disable once PossibleNullReferenceException
        var currentPieceCoefficientList = currentCoefficients.PieceCoefficientsList;

        var inputPieceCount = input.PieceNumbers.Count;
        Assert(inputPieceCount == inputPieceCoefficientsList.Count,
            "Piece numbers not match.");

        foreach (var coefficients in inputPieceCoefficientsList)
            AssertCoefficientsValid(coefficients);

        for (var i = 0; i < inputPieceCount; i++)
        {
            Assert(currentPieceCoefficientList.Count >= input.PieceNumbers[i],
                "Piece number exceeded.");
            var pieceIndex = input.PieceNumbers[i].Sub(1);
            var pieceCoefficients = inputPieceCoefficientsList[i];
            currentPieceCoefficientList[pieceIndex] = pieceCoefficients;
        }

        AssertPieceUpperBoundsIsInOrder(currentPieceCoefficientList);

        State.AllCalculateFeeCoefficients.Value = currentAllCoefficients;

        Context.Fire(new CalculateFeeAlgorithmUpdated
        {
            AllTypeFeeCoefficients = currentAllCoefficients
        });
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L90-101)
```csharp
    private void AssertPieceUpperBoundsIsInOrder(
        IReadOnlyCollection<CalculateFeePieceCoefficients> calculateFeePieceCoefficientsList)
    {
        // No same piece upper bound.
        Assert(!calculateFeePieceCoefficientsList.GroupBy(i => i.Value[0]).Any(g => g.Count() > 1),
            "Piece upper bounds contains same elements.");

        var pieceUpperBounds = calculateFeePieceCoefficientsList.Select(l => l.Value[0]).ToList();
        var orderedEnumerable = pieceUpperBounds.OrderBy(i => i).ToList();
        for (var i = 0; i < calculateFeePieceCoefficientsList.Count; i++)
            Assert(pieceUpperBounds[i] == orderedEnumerable[i], "Piece upper bounds not in order.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L132-312)
```csharp
    private CalculateFeeCoefficients GetReadFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Read,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 10]: x/8 + 1 / 100000
                    Value =
                    {
                        10,
                        1, 1, 8,
                        0, 1, 100000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (10, 100]: x/4 
                    Value =
                    {
                        100,
                        1, 1, 4
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (100, +∞): 25 / 16 * x^2 + x / 4
                    Value =
                    {
                        int.MaxValue,
                        2, 25, 16,
                        1, 1, 4
                    }
                }
            }
        };
    }

    private CalculateFeeCoefficients GetStorageFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Storage,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 4 + 1 / 100000
                    Value =
                    {
                        1000000,
                        1, 1, 4,
                        0, 1, 100000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, +∞): x ^ 2 / 20000 + x / 64
                    Value =
                    {
                        int.MaxValue,
                        2, 1, 20000,
                        1, 1, 64
                    }
                }
            }
        };
    }

    private CalculateFeeCoefficients GetWriteFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Write,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 10]: x / 8 + 1 / 10000
                    Value =
                    {
                        10,
                        1, 1, 8,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (10, 100]: x / 4
                    Value =
                    {
                        100,
                        1, 1, 4
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (100, +∞): x / 4 + x^2 * 25 / 16
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 4,
                        2, 25, 16
                    }
                }
            }
        };
    }

    private CalculateFeeCoefficients GetTrafficFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Traffic,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 64 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 64,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, +∞): x / 64 + x^2 / 20000
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 64,
                        2, 1, 20000
                    }
                }
            }
        };
    }

    private CalculateFeeCoefficients GetTxFeeInitialCoefficient()
    {
        return new CalculateFeeCoefficients
        {
            FeeTokenType = (int)FeeTypeEnum.Tx,
            PieceCoefficientsList =
            {
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (1000000, 5000000): x / 80
                    Value =
                    {
                        5000000,
                        1, 1, 80
                    }
                },
                new CalculateFeePieceCoefficients
                {
                    // Interval (5000000, ∞): x / 80 + x^2 / 100000
                    Value =
                    {
                        int.MaxValue,
                        1, 1, 80,
                        2, 1, 100000
                    }
                }
            }
        };
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/CalculateFunction.cs (L34-58)
```csharp
    public long CalculateFee(int totalCount)
    {
        if (CalculateFeeCoefficients.PieceCoefficientsList.Count != _currentCalculateFunctions.Count)
            throw new ArgumentOutOfRangeException(nameof(_currentCalculateFunctions),
                "Coefficients count not match.");

        var remainCount = totalCount;
        var result = 0L;
        var pieceStart = 0;
        for (var i = 0; i < _currentCalculateFunctions.Count; i++)
        {
            var function = _currentCalculateFunctions[i];
            var pieceCoefficient = CalculateFeeCoefficients.PieceCoefficientsList[i].Value;
            var pieceUpperBound = pieceCoefficient[0];
            var interval = pieceUpperBound - pieceStart;
            pieceStart = pieceUpperBound;
            var count = Math.Min(interval, remainCount);
            result += function(count);
            if (pieceUpperBound > totalCount) break;

            remainCount -= interval;
        }

        return result;
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/TokenFeeProviderBase.cs (L24-37)
```csharp
    public Task<long> CalculateFeeAsync(ITransactionContext transactionContext, IChainContext chainContext)
    {
        var functionDictionary = _calculateFunctionProvider.GetCalculateFunctions(chainContext);
        var targetKey = ((FeeTypeEnum)_tokenType).ToString().ToUpper();
        if (!functionDictionary.ContainsKey(targetKey))
        {
            var currentKeys = string.Join(" ", functionDictionary.Keys);
            throw new InvalidOperationException($"Function not found. Current keys: {currentKeys}");
        }

        var function = functionDictionary[targetKey];
        var count = GetCalculateCount(transactionContext);
        return Task.FromResult(function.CalculateFee(count));
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L296-322)
```csharp
    private DeveloperFeeController GetDefaultDeveloperFeeController(AuthorityInfo defaultParliamentController)
    {
        if (State.AssociationContract.Value == null)
            State.AssociationContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);

        var developerFeeController = new DeveloperFeeController
        {
            ParliamentController = new AuthorityInfo(),
            DeveloperController = new AuthorityInfo(),
            RootController = new AuthorityInfo()
        };
        developerFeeController.ParliamentController = defaultParliamentController;
        developerFeeController.DeveloperController.ContractAddress = State.AssociationContract.Value;
        developerFeeController.DeveloperController.OwnerAddress =
            State.AssociationContract.CalculateOrganizationAddress.Call(
                GetDeveloperControllerCreateInput(defaultParliamentController.OwnerAddress)
                    .OrganizationCreationInput);
        developerFeeController.RootController.ContractAddress = State.AssociationContract.Value;
        developerFeeController.RootController.OwnerAddress =
            State.AssociationContract.CalculateOrganizationAddress.Call(
                GetAssociationControllerCreateInputForDeveloperFee(
                        defaultParliamentController.OwnerAddress,
                        developerFeeController.DeveloperController.OwnerAddress)
                    .OrganizationCreationInput);
        return developerFeeController;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L383-389)
```csharp
    private void AssertDeveloperFeeController()
    {
        Assert(State.DeveloperFeeController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");

        Assert(Context.Sender == State.DeveloperFeeController.Value.RootController.OwnerAddress, "no permission");
    }
```
