# Audit Report

## Title
Fixed Candidate Registration Cost Enables Predictable Candidate Pool Monopolization Attack

## Summary
The Election contract uses a fixed deposit of 100,000 ELF combined with the Vote contract's hard limit of 64 voting options, allowing an attacker with 6.4M ELF to monopolize all candidate slots. This creates a denial-of-service condition where no new legitimate candidates can register until the attacker voluntarily quits, undermining the permissionless nature of the consensus mechanism.

## Finding Description

The vulnerability stems from the interaction of three immutable architectural constraints:

**Root Cause 1 - Fixed Lock Amount:**
The candidate registration deposit is hardcoded as a compile-time constant with no governance mechanism to adjust it. [1](#0-0) 

**Root Cause 2 - Hard Candidate Limit:**
The Vote contract enforces a maximum of 64 options per voting item as a hardcoded constant. [2](#0-1) 

**Root Cause 3 - Strict Enforcement:**
The `AddOption` method in the Vote contract strictly enforces this limit by reverting any transaction that would exceed 64 options. [3](#0-2) 

**Execution Path:**

When a user calls `AnnounceElection`, the system locks exactly 100,000 ELF tokens from the sender: [4](#0-3) 

The Election contract then attempts to add the candidate as a voting option by calling the Vote contract: [5](#0-4) 

The code explicitly acknowledges that candidate capacity is limited by voting options: [6](#0-5) 

**Why Existing Protections Fail:**

The only protection is the 100,000 ELF deposit requirement. However, this provides insufficient defense because:
- The cost is fixed and predictable (6.4M ELF total)
- Tokens are fully recoverable via `QuitElection`, which returns the exact deposit amount [7](#0-6) 
- No rate limiting, progressive pricing, or cooldown mechanisms exist
- No governance mechanism can dynamically adjust either the lock amount or the option limit

## Impact Explanation

**Operational Impact - Denial of Service:**
Once all 64 candidate slots are occupied, any attempt to register a new candidate will revert at the Vote contract's strict limit enforcement. This creates a complete DoS of the candidate registration system. Legitimate node operators, regardless of their stake or community support, cannot enter the candidate pool until an existing candidate quits.

**Consensus Decentralization Impact:**
The attacker controls which 64 public keys occupy all available candidate slots. While existing candidates can still receive votes and become miners, no new competition can emerge. This undermines the open and permissionless nature of the AEDPoS consensus mechanism. The attacker can maintain this monopoly indefinitely by immediately re-registering whenever slots open.

**Quantified Damage:**
- Total attack cost: 6,400,000 ELF (64 candidates Ã— 100,000 ELF)
- All tokens are locked but fully recoverable, making the effective cost only the opportunity cost
- Complete blockage of new candidate registrations until attacker releases slots
- Prevents any prospective validator from joining the candidate pool

## Likelihood Explanation

**Attacker Capabilities:**
The attack requires control of 6.4M ELF tokens and the ability to execute 64 transaction calls to `AnnounceElection` or `AnnounceElectionFor`. No special privileges or insider access are required - these are public methods callable by any address with sufficient balance.

**Attack Complexity:**
The attack has low complexity: a straightforward sequence of 64 identical transactions with deterministic outcome. There are no timing dependencies, race conditions, or complex state manipulations to coordinate.

**Economic Rationality:**
For actors with existing consensus positions or governance interests, the strategic value of preventing new competition may exceed the opportunity cost of locking 6.4M ELF. Since tokens are fully recoverable via `QuitElection`, this represents a reversible capital allocation rather than a permanent loss, reducing the economic risk for the attacker.

**Feasibility Conditions:**
The attack succeeds if fewer than 64 candidates are currently registered and the attacker has sufficient ELF balance. Even partial attacks (e.g., filling 50 of 64 slots) create significant disruption to new candidate onboarding.

## Recommendation

**Short-term Mitigation:**
1. Implement governance-controlled parameters for both `LockTokenForElection` and `MaximumOptionsCount` by converting them from constants to state variables
2. Add setter methods with Parliament/Association authority checks (similar to the pattern used in `SetMaximumMinersCount`)
3. Implement progressive pricing that increases deposit requirements as more slots are filled

**Long-term Solution:**
1. Consider implementing a candidate registration queue with priority based on deposit amount and community support
2. Add rate limiting per address to prevent rapid monopolization
3. Implement a governance mechanism to forcibly remove malicious or inactive candidates
4. Consider increasing the maximum options count beyond 64 if technically feasible

**Example Fix Pattern:**
Convert constants to state variables with governance control, following the pattern used in the Consensus contract: [8](#0-7) 

## Proof of Concept

```csharp
// POC: Monopolize all 64 candidate slots
public async Task MonopolizeCandidateSlots()
{
    // Setup: Attacker with 6.4M ELF + gas
    var attackerKeyPairs = new List<ECKeyPair>();
    for (int i = 0; i < 64; i++)
    {
        attackerKeyPairs.Add(CryptoHelper.GenerateKeyPair());
    }
    
    // Fund attacker address with 6.4M ELF
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        To = attackerAddress,
        Symbol = "ELF",
        Amount = 6_400_000_00000000
    });
    
    // Execute attack: Register 64 candidates
    for (int i = 0; i < 64; i++)
    {
        await ElectionContractStub.AnnounceElectionFor.SendAsync(
            new AnnounceElectionForInput
            {
                Pubkey = attackerKeyPairs[i].PublicKey.ToHex(),
                Admin = attackerAddress
            }
        );
    }
    
    // Verify: Legitimate candidate cannot register
    var legitimateKeyPair = CryptoHelper.GenerateKeyPair();
    var result = await ElectionContractStub.AnnounceElectionFor.SendWithExceptionAsync(
        new AnnounceElectionForInput
        {
            Pubkey = legitimateKeyPair.PublicKey.ToHex(),
            Admin = legitimateCandidateAddress
        }
    );
    
    // Assert: Transaction fails with "The count of options can't greater than 64"
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("can't greater than 64");
}
```

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L87-88)
```csharp
    ///     Actually this method is for adding an option of the Voting Item.
    ///     Thus the limitation of candidates will be limited by the capacity of voting options.
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L177-195)
```csharp
    private void LockCandidateNativeToken()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Lock the token from sender for deposit of announce election
        var lockId = Context.OriginTransactionId;
        var lockVirtualAddress = Context.ConvertVirtualAddressToContractAddress(lockId);
        var sponsorAddress = Context.Sender;
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = sponsorAddress,
            To = lockVirtualAddress,
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Lock for announcing election."
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L197-209)
```csharp
    private void AddCandidateAsOption(string publicKey)
    {
        if (State.VoteContract.Value == null)
            State.VoteContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName);

        // Add this candidate as an option for the the Voting Item.
        State.VoteContract.AddOption.Send(new AddOptionInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            Option = publicKey
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L242-249)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = lockVirtualAddress,
            To = State.CandidateSponsorMap[input.Value] ?? Address.FromPublicKey(pubkeyBytes),
            Symbol = Context.Variables.NativeSymbol,
            Amount = ElectionContractConstants.LockTokenForElection,
            Memo = "Quit election."
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L1-1)
```csharp
using System;
```
