# Audit Report

## Title
Scheme Manager Can DOS Profit Claiming Through Unlimited Empty Period Creation

## Summary
A malicious scheme manager can repeatedly call `DistributeProfits` with empty `AmountsMap`, causing periods to increment indefinitely without distributing any profits. This forces beneficiaries to iterate through potentially millions of empty periods when claiming profits, making profit claiming economically infeasible due to excessive gas costs and transaction requirements.

## Finding Description

The vulnerability exists in the TokenHolder and Profit contracts' period management logic. The scheme manager can abuse the `DistributeProfits` function to create unlimited empty periods that beneficiaries must later traverse during claiming.

**Root Cause**: The TokenHolder contract's `DistributeProfits` function conditionally adds the `AmountsMap` only when it is non-null and non-empty, but unconditionally increments the period counter. [1](#0-0) 

The authorization check allows the scheme manager to call this function. [2](#0-1) 

In the Profit contract, the only protection checks if the period is negative or if `totalShares` is zero. When a scheme has beneficiaries (totalShares > 0), the function proceeds and unconditionally increments `CurrentPeriod` even with empty profits. [3](#0-2) 

When beneficiaries claim profits, the `ProfitAllPeriods` function must iterate from `LastProfitPeriod` to `maxProfitPeriod`. While empty periods are skipped with `continue`, the loop still executes state reads and iterations for each period, consuming gas. [4](#0-3) 

Each claim transaction is limited to processing approximately 100 periods maximum (defined by `DefaultMaximumProfitReceivingPeriodCountOfOneTime`), divided by the number of profitable details being processed. [5](#0-4) 

This limit is enforced through the calculation in `GetMaximumPeriodCountForProfitableDetail`. [6](#0-5) 

## Impact Explanation

**High Severity** - This vulnerability enables an economic denial-of-service attack affecting all beneficiaries of a TokenHolder profit scheme:

1. **Economic DOS**: If an attacker creates 1,000,000 empty periods, users need approximately 10,000 claim transactions (at ~100 periods per transaction). At typical gas costs, this could cost hundreds of dollars per user, making small profit amounts permanently unclaimed as the claiming cost exceeds the profit value.

2. **Availability DOS**: Legitimate users cannot practically claim their profits due to the excessive number of transactions required. Each transaction consumes gas for state reads and loop iterations even though empty periods are skipped.

3. **No Recovery Mechanism**: There is no on-chain mechanism to delete or bulk-skip empty periods once created. The damage is permanent once the attack is executed.

4. **Widespread Impact**: All beneficiaries in the affected scheme become victims simultaneously.

5. **Protocol Reputation**: Such an attack would severely damage the protocol's reputation as users discover their earned profits are inaccessible.

## Likelihood Explanation

**High Likelihood** - The attack is trivially executable:

1. **Minimal Privilege**: The attacker only needs to be a scheme manager, a legitimate role obtained by calling `CreateScheme`. This is not a privilege escalation - it's abuse of existing authority. [7](#0-6) 

2. **Trivial Execution**: The attack requires only repeated calls to `DistributeProfits` with an empty `AmountsMap`: `DistributeProfits({ SchemeManager: <address>, AmountsMap: {} })`

3. **No Preconditions**: The scheme must have at least one beneficiary (totalShares > 0), which is the normal operational case.

4. **No Rate Limiting**: There are no time locks, cooldown periods, or maximum period count validations to prevent rapid empty period creation.

5. **Immediate Detection, Irreversible Damage**: While the attack is visible on-chain (period increments without profit distribution events), the damage is already done once periods are created with no mechanism to reverse them.

## Recommendation

Implement validation to ensure actual profit distribution occurs before incrementing periods:

**Option 1**: Validate that AmountsMap is non-empty in TokenHolder's DistributeProfits:
```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // ADD THIS VALIDATION
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), 
           "Cannot distribute without specifying amounts.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);
    
    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

**Option 2**: In Profit contract, validate that profitsMap has actual amounts before incrementing period:
```csharp
// After building profitsMap, check it's non-empty
Assert(profitsMap.Any() && profitsMap.Values.Any(v => v > 0), 
       "Cannot create period without distributing profits.");
```

**Option 3**: Implement a maximum period gap check to limit the number of consecutive empty periods allowed.

## Proof of Concept

```csharp
[Fact]
public async Task SchemeManager_Can_Create_Empty_Periods_DOS()
{
    // Setup: Create scheme and add beneficiary
    var schemeManager = Accounts[0].Address;
    var beneficiary = Accounts[1].Address;
    
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    await TokenHolderContractStub.RegisterForProfits.SendAsync(new RegisterForProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 1000
    });
    
    // Attack: Create 1000 empty periods by repeatedly calling DistributeProfits with empty AmountsMap
    for (int i = 0; i < 1000; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = schemeManager,
            AmountsMap = { } // Empty map
        });
    }
    
    // Verify: Scheme now has 1000 empty periods
    var scheme = await TokenHolderContractStub.GetScheme.CallAsync(schemeManager);
    scheme.Period.ShouldBe(1000);
    
    // Impact: Beneficiary now needs multiple transactions to claim through all periods
    // With default limit of ~100 periods per claim, needs 10+ transactions
    // Each transaction costs gas even though periods are empty
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-34)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L141-144)
```csharp
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L485-494)
```csharp
        if (input.Period < 0 || totalShares <= 0)
            return BurnProfits(input.Period, profitsMap, scheme, profitsReceivingVirtualAddress);

        Context.LogDebug(() => $"Receiving virtual address: {profitsReceivingVirtualAddress}");

        UpdateDistributedProfits(profitsMap, profitsReceivingVirtualAddress, totalShares);

        PerformDistributeProfits(profitsMap, scheme, totalShares, profitsReceivingVirtualAddress);

        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L822-833)
```csharp
    private int GetMaximumPeriodCountForProfitableDetail(int profitableDetailCount)
    {
        // Get the maximum profit receiving period count
        var maxPeriodCount = GetMaximumProfitReceivingPeriodCount();
        // Check if the maximum period count is greater than the profitable detail count
        // and if the profitable detail count is greater than 0
        return maxPeriodCount > profitableDetailCount && profitableDetailCount > 0
            // Divide the maximum period count by the profitable detail count
            ? maxPeriodCount.Div(profitableDetailCount)
            // If the conditions are not met, return 1 as the maximum period count
            : 1;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
