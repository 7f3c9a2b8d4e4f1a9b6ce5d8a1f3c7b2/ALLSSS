### Title
Governance Degradation via Malicious AuthorityInfo ContractAddress in TokenConverter Controller

### Summary
The `ChangeConnectorController` function validates new controllers using `CheckOrganizationExist`, which blindly calls `ValidateOrganizationExist` on the provided `AuthorityInfo.ContractAddress` without verifying it's a legitimate governance contract. An attacker can deploy a malicious contract that always returns true, then through a single governance vote, permanently convert decentralized connector management into single-address control, bypassing all future governance requirements for critical TokenConverter operations.

### Finding Description

The vulnerability exists in the controller change validation flow: [1](#0-0) 

The `ChangeConnectorController` method calls `CheckOrganizationExist` to validate the new controller, implemented as: [2](#0-1) 

**Root Cause:** The `CheckOrganizationExist` function makes a cross-contract call to `ValidateOrganizationExist` on whatever contract address is provided in `authorityInfo.ContractAddress`, without verifying that this address points to a legitimate governance contract (Parliament, Association, or Referendum).

**Why Protection Fails:** An attacker can deploy a malicious contract that implements a `ValidateOrganizationExist` method that always returns true for any input address. When this malicious contract address is provided as `ContractAddress` in the `AuthorityInfo`, the validation passes regardless of the `OwnerAddress` value.

**Authorization Check Bypass:** The `AssertPerformedByConnectorController` function only validates that the sender matches the `OwnerAddress`: [3](#0-2) 

In legitimate governance, `OwnerAddress` is a virtual address that can only send transactions through the governance contract's `Release` method: [4](#0-3) 

However, if `OwnerAddress` is set to a regular user address (not a virtual organization address) through the malicious validation bypass, that user can directly call protected functions without any governance process.

### Impact Explanation

**Governance Bypass Impact:**
- Converts decentralized governance-controlled operations to single-address unilateral control
- Affected critical functions include `UpdateConnector`, `AddPairConnector`, `SetFeeRate`, and `ChangeConnectorController`
- Attacker gains permanent, irreversible control without recourse

**Concrete Harm:**
1. **Connector Manipulation**: Attacker can arbitrarily modify connector weights and virtual balances, affecting Bancor pricing for all token swaps
2. **Fee Manipulation**: Can set `FeeRate` to maximum (0.999...), extracting value from all Buy/Sell transactions
3. **Reserve Theft**: Can add malicious connectors and enable them with manipulated parameters to drain reserves
4. **Permanent Lock**: Once changed, only the attacker can modify the controller again

**Affected Parties:**
- All users performing token conversions through the TokenConverter
- Protocol treasury (receives half of fees)
- Token holders whose assets depend on fair pricing

**Severity Justification:** HIGH - Violates critical invariant "Authorization & Governance - organization thresholds must be maintained" and enables permanent control over critical token conversion infrastructure.

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Ability to deploy a malicious contract (low barrier - any user can deploy)
2. Ability to propose and get approved a governance proposal (high barrier - requires 2/3 miner consensus)

**Attack Complexity:** Medium
- Technical execution is straightforward
- Social engineering aspect: disguise malicious proposal as routine governance restructuring
- Miners may not understand they're approving permanent governance degradation

**Feasibility Conditions:**
- Default controller is Parliament default organization requiring miner consensus
- Attack succeeds if miners approve proposal without fully understanding implications
- No technical safeguards prevent setting arbitrary `ContractAddress`

**Detection Constraints:**
- Malicious contract appears legitimate (implements expected interface)
- Proposal parameters visible but may not be scrutinized
- Once executed, damage is permanent and immediately exploitable

**Probability Assessment:** MEDIUM-HIGH
- While requiring initial governance approval, the barrier is social rather than technical
- Historical precedent of governance approving complex proposals without full review
- Single successful proposal causes permanent damage
- No time-lock or reversibility mechanism

### Recommendation

**Code-Level Mitigation:**

Add validation in `ChangeConnectorController` and `CheckOrganizationExist` to verify that `ContractAddress` is one of the legitimate governance contracts:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var validGovernanceContracts = new[]
    {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validGovernanceContracts.Contains(authorityInfo.ContractAddress),
        "ContractAddress must be a valid governance contract.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant Checks to Add:**
1. Whitelist check for `AuthorityInfo.ContractAddress` in all controller change methods
2. Add similar validation to `ChangeMethodFeeController` and other authority change functions
3. Consider adding a time-lock mechanism for controller changes

**Test Cases:**
1. Test attempting to set controller with non-governance contract address (should fail)
2. Test attempting to set controller with regular user address as OwnerAddress (should fail)
3. Test legitimate controller changes between valid governance organizations (should succeed)
4. Regression test ensuring existing functionality preserved

### Proof of Concept

**Required Initial State:**
- TokenConverter initialized with default Parliament controller
- Attacker has deployed MaliciousContract with `ValidateOrganizationExist` returning true for any input

**Transaction Steps:**

1. **Deploy Malicious Contract:**
```csharp
public class MaliciousContract
{
    public BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true };
    }
}
```

2. **Create Governance Proposal:**
    - Proposer: Any authorized parliament member
    - ToAddress: TokenConverterContractAddress  
    - ContractMethodName: "ChangeConnectorController"
    - Params: `new AuthorityInfo { ContractAddress = MaliciousContractAddress, OwnerAddress = AttackerAddress }`

3. **Miners Approve Proposal:**
    - 2/3 miners vote to approve (believing it's routine governance restructuring)

4. **Release Proposal:**
    - Proposer calls Parliament.Release(proposalId)
    - Executes from organization virtual address
    - Passes `AssertPerformedByConnectorController` (sender == current OwnerAddress)
    - Calls `CheckOrganizationExist` → calls MaliciousContract → returns true
    - Controller changed to AttackerAddress

5. **Exploit Permanent Control:**
    - Attacker directly calls `UpdateConnector`, `SetFeeRate`, etc.
    - `AssertPerformedByConnectorController` checks sender == AttackerAddress (passes)
    - No governance required for future changes

**Expected vs Actual Result:**
- **Expected**: Controller change should fail if ContractAddress is not a legitimate governance contract
- **Actual**: Controller change succeeds with malicious ContractAddress, granting permanent single-address control

**Success Condition:** Attacker can directly call `SetFeeRate(new StringValue { Value = "0.999" })` without governance approval, transaction succeeds with "Only manager can perform this action" check passing.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L303-309)
```csharp
    public override Empty ChangeConnectorController(AuthorityInfo input)
    {
        AssertPerformedByConnectorController();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.ConnectorController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L397-403)
```csharp
    private void AssertPerformedByConnectorController()
    {
        if (State.ConnectorController.Value == null) State.ConnectorController.Value = GetDefaultConnectorController();

        Assert(Context.Sender == State.ConnectorController.Value.OwnerAddress,
            "Only manager can perform this action.");
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```
