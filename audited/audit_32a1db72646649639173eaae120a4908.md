### Title
Minority Miner Collusion Can Block Term Changes via Strategic Non-Participation in Timestamp Recording

### Summary
The `NeedToChangeTerm` function requires at least `MinersCountOfConsent` (⌊totalMiners × 2/3⌋ + 1) miners to have their last mining timestamp cross the term change threshold. However, colluding miners controlling more than 1/3 of miner positions can prevent term changes indefinitely by strategically refusing to mine, thereby never recording timestamps that would contribute to the 2/3 threshold. This allows incumbent miners to block governance-mandated term rotations and prevent newly elected miners from assuming their positions.

### Finding Description

The vulnerability exists in the term change detection logic: [1](#0-0) 

The `NeedToChangeTerm` method counts miners whose `ActualMiningTimes.Last()` crosses the term change threshold and compares this count against `MinersCountOfConsent`: [2](#0-1) 

**Root Cause:** The threshold calculation uses the total number of miners in the round (denominator), but only counts miners who have actually mined blocks (numerator). The `.Where(m => m.ActualMiningTimes.Any())` filter excludes miners who haven't mined, creating a mismatch where strategic abstention by >1/3 of miners makes it mathematically impossible to reach the 2/3 threshold.

**Why Existing Protections Fail:**

The evil miner detection mechanism exists but provides insufficient protection: [3](#0-2) [4](#0-3) 

Miners are only marked as evil after 4,320 missed time slots (~3 days), providing a significant window for attack. Additionally, colluding miners can strategically mine minimal blocks to avoid detection while still blocking term changes.

**Execution Path:** [5](#0-4) 

When `NeedToChangeTerm` returns false due to insufficient miner participation, the consensus behavior remains `NextRound` instead of `NextTerm`, preventing term rotation. [6](#0-5) 

`ActualMiningTimes` is only populated when miners actively produce blocks using `Context.CurrentBlockTime`.

### Impact Explanation

**Governance Compromise:** Term changes are a fundamental governance mechanism in AEDPoS that enable democratic rotation of mining power based on elections. Blocking term changes allows current miners to retain power indefinitely, disenfranchising newly elected validators and undermining the election system.

**Quantified Impact:**
- **Timeframe:** Minimum 3-day window before evil miner detection (4,320 time slots)
- **Power Retention:** Colluding miners (>1/3) can prevent new term indefinitely within detection window
- **Economic Impact:** Continued exclusive access to mining rewards that should go to elected validators
- **Affected Parties:** All token holders who voted in elections, newly elected miners unable to assume positions

**Severity Justification:** HIGH severity because:
1. Attacks a critical consensus invariant (correct term transitions)
2. Requires only minority collusion (>1/3, not majority)
3. Has concrete operational impact (prevents governance-mandated miner rotation)
4. Undermines fundamental trust in the election and consensus systems

### Likelihood Explanation

**Attacker Capabilities:** Requires control of >1/3 of current miner positions (e.g., 3 out of 7 miners with standard 17-miner configuration would need 6+ colluding miners).

**Economic Rationality:** HIGH - Incumbent miners have strong incentive to maintain positions for continued mining rewards rather than ceding to elected replacements.

**Attack Complexity:** LOW - Attack execution is trivial:
1. Monitor `ActualMiningTimes` approaching term change threshold
2. Coordinate to stop mining once threshold approaches
3. Maintain minimal participation to avoid immediate evil miner marking

**Detection Constraints:** The attack is difficult to distinguish from normal network issues or miner downtime initially. Evil miner detection takes ~3 days, during which term changes remain blocked.

**Feasibility:** PRACTICAL - No sophisticated technical knowledge required beyond coordination among colluding miners. The attack can be sustained cyclically by rotating which miners abstain to avoid all being marked as evil simultaneously.

### Recommendation

**Primary Fix - Adjust Threshold Calculation:**

Modify `NeedToChangeTerm` to use only actively participating miners in the denominator:

```
Count miners who have mined AND whose last timestamp crosses threshold
Compare against: (Count of miners who have mined × 2/3) + 1
```

This ensures the 2/3 threshold applies only to active participants, preventing strategic abstention attacks.

**Secondary Fix - Add Fallback Term Change Mechanism:**

Implement a time-based fallback that forces term change after a maximum term duration (e.g., periodSeconds × 1.5) regardless of miner participation, with adjustments to handle cases where many miners are offline.

**Invariant Checks to Add:**
1. Assert term change occurs within maximum_term_duration from term start
2. Track and alert on sustained low miner participation rates
3. Add emergency governance mechanism to force term changes if blocked beyond threshold

**Test Cases:**
1. Simulate scenario with 7 miners where 3 stop mining before term change threshold
2. Verify term change fails when only 4 miners cross threshold (< MinersCountOfConsent of 5)
3. Test that modified logic allows term change with 2/3 of participating miners
4. Verify fallback mechanism triggers after maximum term duration

### Proof of Concept

**Initial State:**
- 7 total miners in current term (MinersCountOfConsent = 5)
- blockchainStartTimestamp = T₀
- periodSeconds = 604,800 (1 week)
- currentTermNumber = 1
- Current blockchain time: T₀ + 605,000 (just past term change threshold)

**Attack Sequence:**

1. **Honest miners mine normally:**
   - 4 honest miners produce blocks with timestamps > T₀ + 604,800
   - Their `ActualMiningTimes.Last()` all cross the term change threshold
   - Count of miners with timestamps crossing threshold = 4

2. **Colluding miners abstain:**
   - 3 colluding miners stop mining entirely (or maintain timestamps below threshold from previous activity)
   - Their `ActualMiningTimes` either remains empty or last entry stays below threshold
   - They do not contribute to the threshold count

3. **Term change check fails:**
   - `NeedToChangeTerm` counts: 4 miners with timestamps ≥ threshold
   - Compares against: MinersCountOfConsent = 5
   - Since 4 < 5, returns `false`

4. **Result:**
   - `GetConsensusBehaviourToTerminateCurrentRound` returns `NextRound` instead of `NextTerm`
   - Current term continues indefinitely (or until evil miner detection after ~3 days)
   - Newly elected miners cannot assume their positions

**Expected vs Actual:**
- **Expected:** Term changes when sufficient real-world time has elapsed (periodSeconds)
- **Actual:** Term change blocked by minority strategic abstention despite time threshold being met

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```
