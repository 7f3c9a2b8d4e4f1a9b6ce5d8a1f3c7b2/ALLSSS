### Title
Inconsistent Vote Counting Allows Quorum Bypass via Removed Member Votes

### Summary
The `CheckEnoughVoteAndApprovals()` function incorrectly counts all votes (including those from removed organization members) when validating the `MinimalVoteThreshold`, while correctly filtering votes by current membership for approval/rejection/abstention thresholds. This inconsistency allows proposals to pass the quorum requirement with fewer actual current member votes than intended, bypassing governance safeguards.

### Finding Description

**Exact Location:** [1](#0-0) 

**Root Cause:**
The function applies inconsistent filtering logic across different vote threshold checks:

1. **Approval count (line 49):** Correctly filters by `organization.OrganizationMemberList.Contains` [2](#0-1) 

2. **Total vote count (lines 55-57):** Does NOT filter - counts all votes including removed members [3](#0-2) 

This mirrors the pattern in other threshold checks that correctly filter:
- Rejection threshold filters by membership [4](#0-3) 

- Abstention threshold filters by membership [5](#0-4) 

**Why Protection Fails:**
When members vote via `Approve`, `Reject`, or `Abstain`, they are checked for membership: [6](#0-5) [7](#0-6) [8](#0-7) 

However, votes remain in the proposal's address lists even after members are removed: [9](#0-8) 

The organization can remove members via `RemoveMember`: [10](#0-9) 

**Execution Path:**
1. `Release()` is called (publicly accessible by proposer) [11](#0-10) 

2. Calls `IsReleaseThresholdReached()` [12](#0-11) 

3. Which calls the vulnerable `CheckEnoughVoteAndApprovals()` on line 31

### Impact Explanation

**Governance Bypass:**
The vulnerability allows proposals to pass the `MinimalVoteThreshold` (quorum requirement) with insufficient participation from current organization members. This violates the critical invariant that "Organization thresholds must be enforced correctly."

**Concrete Harm Scenario:**
- Organization with 10 members, `MinimalVoteThreshold = 7`, `MinimalApprovalThreshold = 5`
- 5 members approve, 2 members abstain (7 total votes)
- Organization removes the 2 abstaining members (leaving 8 members, still valid per validation rules) [13](#0-12) 

- When checking release threshold:
  - Approval count from current members: 5 ✓ (≥ 5)
  - Abstention count from current members: 0 ✓ (≤ threshold)
  - **Total vote count: 7 ✓ (≥ 7) — includes removed members' votes**
- Proposal passes despite only 5/8 current members (62.5%) voting, when 7/8 (87.5%) participation was intended

**Who is Affected:**
All Association organizations where member removal occurs after voting. This undermines the democratic governance model by allowing artificial quorum inflation.

**Severity Justification:**
Critical - directly violates governance authorization invariants, bypasses quorum protections, and enables unauthorized proposal execution with minority support.

### Likelihood Explanation

**Attacker Capabilities:**
The organization itself (via proposal or direct call) can remove members. No external attacker access required - this is a design flaw exploitable through normal operations.

**Attack Complexity:**
Low. The attack sequence is straightforward:
1. Obtain votes on a proposal
2. Remove voters from organization (via `RemoveMember`)
3. Release proposal with artificially met quorum

**Feasibility Conditions:**
- Proposal must be created and voted on
- Organization must have authority to remove members (always true)
- Removal must maintain minimum member count per validation rules [14](#0-13) 

**Economic Rationality:**
Zero additional cost beyond normal proposal/voting operations. The exploit uses existing contract functionality.

**Probability:**
High - this can occur unintentionally (members removed for legitimate reasons after voting) or deliberately (malicious manipulation of quorum). No special privileges or external attack vectors required.

### Recommendation

**Code-Level Mitigation:**
Modify lines 55-57 in `CheckEnoughVoteAndApprovals()` to filter the total vote count by current organization membership:

```csharp
var isVoteThresholdReached =
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains) +
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) >=
    organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**Invariant Check:**
Ensure all vote threshold calculations consistently use `organization.OrganizationMemberList.Contains` filtering.

**Test Cases:**
1. Create organization with 10 members, thresholds: MinimalVote=7, MinimalApproval=5
2. Proposal receives 5 approvals + 2 abstentions
3. Remove 2 abstaining members
4. Attempt to release proposal
5. **Expected:** Proposal should fail (only 5 current member votes < 7)
6. **Current Behavior:** Proposal passes (counts removed members' votes)

### Proof of Concept

**Initial State:**
- Organization: Address_Org with 10 members [M1, M2, M3, M4, M5, M6, M7, M8, M9, M10]
- Thresholds: MinimalVoteThreshold=7, MinimalApprovalThreshold=5, MaximalAbstentionThreshold=2, MaximalRejectionThreshold=2

**Transaction Sequence:**

1. **Create Proposal:**
   - Caller: M1 (authorized proposer)
   - Method: `CreateProposal()`
   - Result: ProposalId = P1

2. **Cast Votes:**
   - M1, M2, M3, M4, M5 call `Approve(P1)`
   - M6, M7 call `Abstain(P1)`
   - State: Approvals=[M1,M2,M3,M4,M5], Abstentions=[M6,M7], Rejections=[]

3. **Remove Members:**
   - Caller: Address_Org (via proposal or system contract)
   - Method: `RemoveMember(M6)` then `RemoveMember(M7)`
   - Result: Organization now has 8 members [M1,M2,M3,M4,M5,M8,M9,M10]

4. **Release Proposal:**
   - Caller: M1 (proposer)
   - Method: `Release(P1)`
   - Check execution in `CheckEnoughVoteAndApprovals()`:
     - `approvedMemberCount = 5` (line 49 filters by current members)
     - `isApprovalEnough = true` (5 ≥ 5)
     - `isVoteThresholdReached = true` (**BUG:** counts 7 total votes including M6, M7)
   - **Result: Proposal released successfully**

**Expected vs Actual:**
- **Expected:** Release should fail because only 5 current members voted (5 < MinimalVoteThreshold of 7)
- **Actual:** Release succeeds because removed members' votes still count toward MinimalVoteThreshold (5 approvals + 2 abstentions from removed members = 7 ≥ 7)

**Success Condition:**
The exploit succeeds when `Release()` returns without error despite having fewer current member votes than `MinimalVoteThreshold` requires.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-38)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-44)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L61-81)
```csharp
    private bool Validate(Organization organization)
    {
        if (organization.ProposerWhiteList.Empty() ||
            organization.ProposerWhiteList.AnyDuplicate() ||
            organization.OrganizationMemberList.Empty() ||
            organization.OrganizationMemberList.AnyDuplicate())
            return false;
        if (organization.OrganizationAddress == null || organization.OrganizationHash == null)
            return false;
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
        var organizationMemberCount = organization.OrganizationMemberList.Count();
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L128-128)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L148-148)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L168-168)
```csharp
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** protobuf/association_contract.proto (L92-96)
```text
    repeated aelf.Address approvals = 8;
    // Address list of rejected.
    repeated aelf.Address rejections = 9;
    // Address list of abstained.
    repeated aelf.Address abstentions = 10;
```
