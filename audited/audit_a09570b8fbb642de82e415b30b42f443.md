# Audit Report

## Title
Time-of-Check-Time-of-Use Vulnerability: Removed Proposers Can Still Release Approved Proposals

## Summary
The Referendum, Parliament, and Association governance contracts validate proposer whitelist membership only at proposal creation time, not at release time. This TOCTOU vulnerability allows proposers who have been removed from the ProposerWhiteList to still release previously created approved proposals, enabling unauthorized governance execution and bypassing organizational access controls.

## Finding Description

All three ACS3 governance contracts implement a flawed authorization model where proposer whitelist validation occurs at different times:

**Referendum Contract:**
At proposal creation, the contract validates whitelist membership: [1](#0-0) 

The authorization check occurs in `AssertIsAuthorizedProposer()`: [2](#0-1) 

Organizations can update their ProposerWhiteList at any time: [3](#0-2) 

However, at release time, the contract ONLY validates that the caller is the original proposer, without re-checking current whitelist membership: [4](#0-3) 

**Parliament Contract:**
The same pattern exists in Parliament - whitelist check at creation: [5](#0-4) 

With the authorization validation in helper: [6](#0-5) 

But no whitelist re-validation at release: [7](#0-6) 

**Association Contract:**
Association follows the identical flawed pattern - whitelist check at creation: [8](#0-7) 

Authorization validation: [9](#0-8) 

No whitelist re-validation at release: [10](#0-9) 

This breaks the security guarantee that organizations can revoke proposal release rights by removing proposers from the whitelist. Once a proposal is created and approved, the stored `proposal.Proposer` address retains release rights indefinitely, even after whitelist removal.

## Impact Explanation

**Medium-High Severity** due to:

1. **Unauthorized Governance Execution**: Proposers removed from whitelists (for malicious behavior, compromise, or policy changes) retain the ability to execute approved proposals with full organization authority

2. **Governance Bypass**: Organizations cannot revoke proposal release rights from problematic proposers. This undermines the core access control mechanism that whitelists are designed to provide

3. **Potential for Malicious Actions**: Released proposals execute with organization authority and can:
   - Transfer funds from organization-controlled addresses via virtual inline calls
   - Modify critical contract configurations
   - Execute arbitrary contract methods specified in the proposal

4. **Scope of Impact**: Affects ALL organizations using Referendum, Parliament, or Association governance contracts across the entire AElf ecosystem

**Mitigating Factors**:
- Proposals still require threshold approval from voters/organization members
- Organizations can use `ClearProposal()` to remove expired proposals
- The proposer must have been legitimately whitelisted initially

**Severity Justification**: While proposals require approval, the inability to revoke release rights after whitelist removal represents a significant governance security gap. Organizations expect that removing access prevents future actions.

## Likelihood Explanation

**Medium-High Likelihood** because:

1. **Common Operational Pattern**: Organizations regularly update ProposerWhiteLists to:
   - Remove compromised accounts after security incidents
   - Revoke access from departed team members
   - Respond to detected malicious behavior
   - Update governance policies and membership

2. **Low Attack Complexity**: 
   - Single `Release()` transaction with proposal ID
   - No complex state manipulation required
   - Works consistently across all three governance contracts

3. **Realistic Attack Scenario**:
   - Attacker gains legitimate whitelist membership
   - Creates multiple proposals while authorized
   - Proposals receive voter approval
   - Organization detects issue and removes attacker from whitelist
   - Attacker retains ability to release all approved proposals

4. **Economic Rationality**: For a malicious actor anticipating removal, the rational strategy is to create numerous proposals before removal, as each provides persistent execution capability

5. **Detection Difficulty**: Removed proposers still have valid `proposal.Proposer` status stored in state, making it difficult to identify at-risk proposals

## Recommendation

Add whitelist re-validation at release time. For each governance contract, modify the `Release()` method to call `AssertIsAuthorizedProposer()` before execution:

**For Referendum Contract**, modify lines 163-177 to:
```csharp
public override Empty Release(Hash input)
{
    var proposal = GetValidProposal(input);
    Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
    
    // Add re-validation of current whitelist status
    AssertIsAuthorizedProposer(proposal.OrganizationAddress, Context.Sender);
    
    var organization = State.Organizations[proposal.OrganizationAddress];
    Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
    // ... rest of method
}
```

Apply the same pattern to Parliament and Association contracts. This ensures proposers must maintain continuous whitelist membership from creation through release.

**Alternative**: If the intended behavior is to allow release after whitelist removal (once approved), this should be explicitly documented and communicated to organizations using these governance mechanisms.

## Proof of Concept

```csharp
[Fact]
public async Task TOCTOU_RemovedProposerCanStillRelease_Test()
{
    // Setup organization with DefaultSender as whitelisted proposer
    var organizationAddress = await CreateOrganizationAsync(
        minimalApproveThreshold: 5000, 
        minimalVoteThreshold: 5000,
        maximalAbstentionThreshold: 10000, 
        maximalRejectionThreshold: 10000, 
        new[] { DefaultSender });
    
    // Create proposal while whitelisted
    var proposalId = await CreateProposalAsync(DefaultSenderKeyPair, organizationAddress);
    
    // Get approval votes to meet threshold
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, proposalId);
    await ApproveAsync(Accounts[3].KeyPair, proposalId);
    
    // Organization removes proposer from whitelist
    var emptyWhiteList = new ProposerWhiteList { Proposers = { Accounts[4].Address } };
    var changeWhitelistProposal = await CreateReferendumProposalAsync(
        DefaultSenderKeyPair, 
        emptyWhiteList,
        nameof(ReferendumContractStub.ChangeOrganizationProposerWhiteList), 
        organizationAddress,
        ReferendumContractAddress);
    await ApproveAllowanceAsync(Accounts[3].KeyPair, 5000, changeWhitelistProposal);
    await ApproveAsync(Accounts[3].KeyPair, changeWhitelistProposal);
    await ReferendumContractStub.Release.SendAsync(changeWhitelistProposal);
    
    // Verify DefaultSender is no longer in whitelist
    var validationResult = await ReferendumContractStub.ValidateProposerInWhiteList.CallAsync(
        new ValidateProposerInWhiteListInput
        {
            OrganizationAddress = organizationAddress,
            Proposer = DefaultSender
        });
    validationResult.Value.ShouldBeFalse();
    
    // VULNERABILITY: Removed proposer can still release the approved proposal
    await PrepareCreateToken(organizationAddress);
    var result = await ReferendumContractStub.Release.SendAsync(proposalId);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Proposal was executed despite proposer being removed from whitelist
    // This should have failed with "Unauthorized to propose" but succeeded
}
```

This test demonstrates that a proposer removed from the whitelist can still release previously created approved proposals, bypassing the intended access control mechanism.

### Citations

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L53-58)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);

        return proposalId;
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L139-152)
```csharp
    public override Empty ChangeOrganizationProposerWhiteList(ProposerWhiteList input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposerWhiteList = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationWhiteListChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerWhiteList = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum.cs (L163-177)
```csharp
    public override Empty Release(Hash input)
    {
        var proposal = GetValidProposal(input);
        Assert(Context.Sender.Equals(proposal.Proposer), "No permission.");
        var organization = State.Organizations[proposal.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposal, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposal.ToAddress,
            proposal.ContractMethodName, proposal.Params);

        Context.Fire(new ProposalReleased { ProposalId = input });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Referendum/Referendum_Helper.cs (L200-205)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "Organization not found.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L61-66)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L22-34)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        // It is a valid proposer if
        // authority check is disable,
        // or sender is in proposer white list,
        // or sender is one of miners when member proposing allowed.
        Assert(
            !organization.ProposerAuthorityRequired || ValidateAddressInWhiteList(proposer) ||
            (organization.ParliamentMemberProposingAllowed && ValidateParliamentMemberAuthority(proposer)),
            "Unauthorized to propose.");
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L107-112)
```csharp
    public override Hash CreateProposal(CreateProposalInput input)
    {
        AssertIsAuthorizedProposer(input.OrganizationAddress, Context.Sender);
        var proposalId = CreateNewProposal(input);
        return proposalId;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L11-16)
```csharp
    private void AssertIsAuthorizedProposer(Address organizationAddress, Address proposer)
    {
        var organization = State.Organizations[organizationAddress];
        Assert(organization != null, "No registered organization.");
        Assert(organization.ProposerWhiteList.Contains(proposer), "Unauthorized to propose.");
    }
```
