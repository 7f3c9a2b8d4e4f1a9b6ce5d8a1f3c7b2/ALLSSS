# Audit Report

## Title
Unauthorized Round Termination Due to Missing Extra Block Producer Authorization Check

## Summary
The `GetConsensusBehaviour()` function in the AEDPoS consensus system contains a logic error that allows any miner who has reached their maximum block count to prematurely terminate a consensus round while still within their time slot. This bypasses the intended restriction that only the designated extra block producer should terminate rounds during the extra block time slot, enabling unauthorized disruption of the consensus schedule.

## Finding Description

The vulnerability exists in the consensus behavior determination logic where a critical authorization check is missing. [1](#0-0) 

When a miner has already mined blocks (`OutValue != null`), is still within their time slot (`!_isTimeSlotPassed`), and has reached their maximum block count (`ActualMiningTimes.Count >= _maximumBlocksCount`), but is NOT the extra block producer of the previous round (the condition at lines 71-77 fails), the function falls through to line 82 and calls `GetConsensusBehaviourToTerminateCurrentRound()`. This returns `NextRound` or `NextTerm` behavior without verifying:

1. The miner is the designated extra block producer for the current round
2. The current time is within the extra block time slot (which occurs AFTER all regular miners' slots)

The extra block time slot is defined as starting after the last miner's expected mining time plus the mining interval. [2](#0-1) 

Time slot passage is determined by comparing current time against the miner's expected mining time plus the mining interval. [3](#0-2) 

The existing protections fail to prevent this attack:

1. **PreCheck() is insufficient**: It only validates that the miner is in the current or previous round's miner list, not that they have authority to terminate rounds. [4](#0-3) 

2. **TimeSlotValidationProvider is insufficient**: For new rounds (NextRound/NextTerm), it only validates that the new round's time slots are properly distributed, but does NOT check if the current miner is authorized to terminate the round or if it's the correct time. [5](#0-4) 

3. **RoundTerminateValidationProvider is insufficient**: It only validates round number correctness, not authorization. [6](#0-5) 

4. **IsCurrentMiner() has proper checks but is not called**: This method contains comprehensive authorization checks including validation that only the extra block producer can mine during the extra block time slot, but it is never called in the NextRound/NextTerm execution path. [7](#0-6) 

**Execution Path:**

1. Miner calls the public `GetConsensusCommand()` method. [8](#0-7) 

2. The method determines consensus behavior by instantiating a behavior provider and calling `GetConsensusBehaviour()`, which returns `NextRound` or `NextTerm` due to the fallthrough bug.

3. A consensus command with termination behavior is generated. [9](#0-8) 

4. The miner executes the `NextRound()` or `NextTerm()` transaction, which generates the appropriate transaction. [10](#0-9) 

5. `ProcessConsensusInformation()` processes the round termination with only weak `PreCheck()` authorization. [11](#0-10) 

6. The round terminates prematurely, and the attacker is recorded as the extra block producer of the next round. [12](#0-11) 

## Impact Explanation

This vulnerability enables **consensus schedule disruption** with the following specific harms:

1. **Unfair Block Production Distribution**: Miners who haven't had their turn in the current round lose block production opportunities and associated mining rewards, as the round terminates before they can mine.

2. **Extra Block Producer Role Hijacking**: The attacker becomes the extra block producer of the next round, gaining the privilege to terminate that round as well, enabling repeated exploitation.

3. **Consensus Timing Manipulation**: Attackers can manipulate round termination timing for strategic advantage, such as preventing competing miners from producing blocks or manipulating reward distribution timing.

4. **Chain Stability Risk**: If multiple miners coordinate this attack, they could repeatedly skip other miners' time slots, potentially affecting chain liveness and severely degrading the fairness guarantees of the AEDPoS consensus mechanism.

The affected parties include honest miners who lose block production opportunities, the designated extra block producer who never gets to fulfill their role, and the overall network consensus integrity.

## Likelihood Explanation

**HIGH LIKELIHOOD** - This vulnerability is trivially exploitable:

**Attacker Capabilities Required:**
- Must be an active miner in the current round
- Must mine legitimate blocks to reach maximum block count
- No special privileges required beyond being a miner

**Attack Complexity:**
The attacker simply needs to:
1. Mine blocks during their legitimate time slot until reaching `_maximumBlocksCount`
2. While still in their time slot, call `GetConsensusCommand()` 
3. Execute the returned `NextRound` or `NextTerm` transaction

**Feasibility:**
- The entry point `GetConsensusCommand()` is publicly callable
- No exceptional conditions required
- Works in any round after a miner has produced their maximum blocks
- No economic barriers beyond normal mining participation

**Detection Difficulty:**
The attack is difficult to detect as the attacker is legitimately mining blocks; only the premature round termination timing would appear abnormal.

## Recommendation

Add an authorization check in `GetConsensusBehaviour()` before allowing round termination. The function should verify:

1. The current time is within the extra block time slot (after all regular miners' slots)
2. The calling miner is the designated extra block producer for the current round

Specifically, before line 82 in `ConsensusBehaviourProviderBase.cs`, add a condition that checks if the current time is >= `GetExtraBlockMiningTime()` and if the miner is the designated extra block producer. If these conditions are not met, the function should return `AElfConsensusBehaviour.Nothing` instead of falling through to terminate the round.

Alternatively, the existing `IsCurrentMiner()` authorization logic should be invoked during `PreCheck()` in the `ProcessConsensusInformation()` method for NextRound/NextTerm behaviors to ensure only authorized miners can terminate rounds.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up an AEDPoS test environment with multiple miners
2. Having a non-extra-block-producer miner mine blocks until reaching `_maximumBlocksCount`
3. While still within their time slot, calling `GetConsensusCommand()`
4. Verifying that `NextRound` behavior is returned despite the miner not being the extra block producer
5. Executing the `NextRound` transaction and confirming the round terminates prematurely
6. Verifying that subsequent miners in the round never get to produce blocks
7. Confirming the attacker becomes the extra block producer of the next round

The test should demonstrate that the round terminates before all miners have had their allocated time slots, violating the consensus fairness guarantee.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-99)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;

        var actualStartTimes = FirstMiner().ActualMiningTimes;
        if (actualStartTimes.Count == 0) return false;

        var actualStartTime = actualStartTimes.First();
        var runningTime = currentBlockTime - actualStartTime;
        var expectedOrder = runningTime.Seconds.Div(miningInterval.Div(1000)).Add(1);
        return minerInRound.Order < expectedOrder;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L117-122)
```csharp
    public Timestamp GetExtraBlockMiningTime()
    {
        return RealTimeMinersInformation.OrderBy(m => m.Value.Order).Last().Value
            .ExpectedMiningTime
            .AddMilliseconds(GetMiningInterval());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-28)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L10-35)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
        else
        {
            // Is sender respect his time slot?
            // It is maybe failing due to using too much time producing previous tiny blocks.
            if (!CheckMinerTimeSlot(validationContext))
            {
                validationResult.Message =
                    $"Time slot already passed before execution.{validationContext.SenderPubkey}";
                validationResult.IsReTrigger = true;
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L173-178)
```csharp
        if (Context.CurrentBlockTime >= currentRound.GetExtraBlockMiningTime() &&
            supposedExtraBlockProducer == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]EXTRA");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L254-254)
```csharp
        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-179)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L39-44)
```csharp
            case AElfConsensusBehaviour.NextRound:
            case AElfConsensusBehaviour.NextTerm:
                return new ConsensusCommandProvider(
                        new TerminateRoundCommandStrategy(currentRound, pubkey, currentBlockTime,
                            behaviour == AElfConsensusBehaviour.NextTerm))
                    .GetConsensusCommand();
```
