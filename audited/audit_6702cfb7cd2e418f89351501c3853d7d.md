### Title
Unrestricted External Info Callback Injection Allows Malicious Contract Execution During Token Operations

### Summary
The MultiToken contract allows any token creator to set reserved external info keys (`aelf_transfer_callback`, `aelf_lock_callback`, `aelf_unlock_callback`, `aelf_log_event`) without validation, enabling injection of malicious callback contracts. When users interact with these tokens through transfer, lock, or unlock operations, the malicious callbacks are automatically executed via `Context.SendInline` with the MultiToken contract as the sender, allowing attackers to steal funds, perform reentrancy attacks, or cause denial of service.

### Finding Description

**Root Cause:**

The `CreateToken` method accepts user-provided `ExternalInfo` during token creation and stores it directly into the token's metadata without validating against reserved keys. [1](#0-0) 

The reserved external info keys are defined but only exposed as a view function with no enforcement mechanism: [2](#0-1) [3](#0-2) 

**Exploitation Path:**

When tokens with callback keys are transferred, locked, or unlocked, the contract automatically parses the callback information and executes it: [4](#0-3) [5](#0-4) [6](#0-5) 

The callbacks are invoked using `Context.SendInline`, which executes the malicious contract with the MultiToken contract as `Context.Sender`, granting elevated privileges: [7](#0-6) 

**Why Protections Fail:**

Token creation is accessible to anyone with a seed NFT or whitelist membership, with no validation on external info content: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- **Fund Theft**: Malicious callbacks can re-enter the MultiToken contract or call other contracts with MultiToken's authority, bypassing authorization checks to transfer tokens from victims
- **Reentrancy Attacks**: Callbacks execute before the transaction completes, allowing state manipulation through reentrancy
- **Denial of Service**: Callbacks can revert to prevent legitimate transfers, locks, or unlocks of the token
- **Protocol Compromise**: Callbacks impersonate the MultiToken system contract when calling other contracts, potentially bypassing critical security checks throughout the protocol

**Who Is Affected:**
- Any user who transfers, locks, or unlocks tokens with malicious callbacks
- The entire protocol's security model, as MultiToken is a system contract with elevated privileges
- Other system contracts that trust calls from MultiToken contract

**Severity Justification:**
HIGH - Direct fund theft vector with elevated privileges, affecting all users who interact with malicious tokens, compromising core protocol security assumptions.

### Likelihood Explanation

**Attacker Capabilities:**
- Anyone can create tokens using seed NFTs (one-time consumable NFTs)
- Attacker can deploy their own malicious contract to any address
- No special privileges or insider knowledge required

**Attack Complexity:**
- LOW - Straightforward exploit requiring only:
  1. Obtain/purchase a seed NFT
  2. Deploy malicious callback contract
  3. Create token with malicious callback in external info
  4. Distribute token to victims (airdrop, market listing, social engineering)

**Feasibility:**
- Preconditions are easily met - seed NFTs are available to anyone
- Execution is guaranteed - no random factors or race conditions
- Victims unknowingly trigger exploit by normal token operations
- Attack is undetectable until callback executes

**Economic Rationality:**
- Cost: Price of one seed NFT + gas fees for deployment and token creation
- Benefit: Unlimited fund theft from all victims who interact with the token
- Highly profitable attack vector with minimal investment

**Detection Constraints:**
- Callbacks appear as legitimate external info metadata
- No on-chain indication of malicious intent until execution
- Users cannot easily verify callback safety before interacting with tokens

### Recommendation

**Code-Level Mitigation:**

Add validation in the `CreateToken` method to reject any external info that contains reserved keys:

```csharp
private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
{
    AssertValidCreateInput(input, symbolType);
    
    // VALIDATE EXTERNAL INFO BEFORE USE
    if (input.ExternalInfo != null && input.ExternalInfo.Value != null)
    {
        var reservedKeys = new[] 
        {
            TokenContractConstants.TransferCallbackExternalInfoKey,
            TokenContractConstants.LockCallbackExternalInfoKey,
            TokenContractConstants.UnlockCallbackExternalInfoKey,
            TokenContractConstants.LogEventExternalInfoKey
        };
        
        foreach (var reservedKey in reservedKeys)
        {
            Assert(!input.ExternalInfo.Value.ContainsKey(reservedKey),
                $"Cannot set reserved external info key: {reservedKey}");
        }
    }
    
    // ... rest of method
}
```

**Invariant Checks:**
- Only system contracts or governance-approved addresses should be able to set callback external info keys
- Add authorization check requiring Parliament governance approval for callback registration
- Validate callback contract addresses against a whitelist of trusted contracts

**Test Cases:**
1. Test that token creation fails when user provides reserved callback keys
2. Test that only authorized contracts can set callback keys (if feature is preserved)
3. Test that existing tokens without callbacks continue to function normally
4. Test cross-chain token creation also validates external info

### Proof of Concept

**Initial State:**
- Attacker has one seed NFT for creating "SCAM" token
- Attacker has deployed MaliciousContract at address `0x123...` with method `StealFunds(TransferFromInput input)`

**Attack Sequence:**

1. **Attacker creates malicious token:**
   - Call `Create()` with:
     - Symbol: "SCAM"
     - ExternalInfo: `{"aelf_transfer_callback": "{\"contract_address\":\"0x123...\",\"method_name\":\"StealFunds\"}"}`
   - Token created successfully with no validation error

2. **Attacker distributes SCAM tokens:**
   - Issue and transfer SCAM tokens to victim addresses
   - Victims receive tokens in their wallets

3. **Victim triggers exploit:**
   - Victim calls `Transfer()` to send SCAM tokens to another address
   - `DealWithExternalInfoDuringTransfer()` parses callback info
   - `Context.SendInline(0x123..., "StealFunds", transferInput)` executes

4. **Malicious callback executes:**
   - `MaliciousContract.StealFunds()` runs with `Context.Sender = MultiTokenContract`
   - Callback calls `MultiTokenContract.TransferFrom()` to steal victim's other tokens
   - Callback succeeds because MultiToken contract is trusted sender

**Expected Result:**
- Token creation should fail with error: "Cannot set reserved external info key"

**Actual Result:**
- Token created successfully
- Callback executes during transfer
- Victim's funds stolen through malicious callback

**Success Condition:**
- Attacker gains unauthorized access to victim's tokens
- Attack is repeatable for all users interacting with the malicious token
- No authorization checks prevent the callback abuse

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-66)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```
