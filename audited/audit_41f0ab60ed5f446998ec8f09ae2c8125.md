### Title
TokenConverter Deposit Balance Manipulation via IsDepositAccount Asymmetry and EnableConnector Re-enabling

### Summary
The asymmetric IsDepositAccount configuration allows resource token balances to be manipulated via direct transfers, while deposit account balances use protected internal state. This asymmetry enables an attack where an adversary can donate resource tokens to the TokenConverter contract and then call EnableConnector to overwrite the State.DepositBalance with an artificially low value, breaking the Bancor reserve ratio and enabling token purchases at manipulated prices.

### Finding Description

The vulnerability originates from the asymmetric balance tracking design established in `InitializeTokenConverterContract()`: [1](#0-0) 

Resource tokens use `IsDepositAccount = false`, causing their balance to be read from the actual MultiToken contract balance, while native token connectors use `IsDepositAccount = true`, reading from internal `State.DepositBalance` accounting: [2](#0-1) 

The critical vulnerability exists in the `EnableConnector` function, which lacks protection against multiple invocations and uses a SET operation (not ADD) to establish the deposit balance: [3](#0-2) 

The `GetNeededDeposit` calculation queries the real token balance, which can be artificially inflated through direct token transfers: [4](#0-3) 

**Root Cause:** The combination of:
1. Asymmetric balance tracking (real balance for resources vs. internal accounting for deposits)
2. No re-enabling protection in `EnableConnector` (missing `IsPurchaseEnabled` check)
3. Overwrite behavior at line 297 using `=` instead of `+=`
4. Balance calculation based on manipulable real token balance

### Impact Explanation

An attacker can execute the following sequence:
1. Wait for legitimate Buy operations to accumulate significant `State.DepositBalance[ntSymbol]`
2. Donate X resource tokens to the TokenConverter contract, increasing the real balance
3. Call `EnableConnector` with the resource token symbol
4. `GetNeededDeposit` calculates a lower deposit requirement due to the inflated balance
5. Line 297 overwrites the accumulated deposit balance with the manipulated lower value
6. The Bancor formula now operates with severely imbalanced reserves (high resource tokens, low recorded deposits)
7. Resource tokens can be purchased at artificially deflated prices
8. Attacker and others extract value by buying tokens cheaply

**Quantified Impact:**
- If `State.DepositBalance` was 1,000,000 ELF and attacker donates 500,000 resource tokens, the recalculated deposit might drop to 100,000 ELF
- This creates a 90% discount opportunity for subsequent buyers
- The protocol loses the difference between actual deposit value and manipulated recorded value
- All users are affected through distorted pricing

**Severity Justification:** Medium to High - Direct financial impact through reserve manipulation, affecting protocol solvency and price integrity.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires ability to transfer resource tokens to the contract (publicly available)
- Requires calling `EnableConnector` function (public, no authorization required)
- Initial capital needed: Amount of resource tokens for donation (depends on manipulation scale)

**Attack Complexity:** Low
- Two simple operations: token transfer + function call
- No complex timing or state requirements
- No need for governance or special privileges

**Feasibility Conditions:**
- Connector must exist in the system
- Attacker must have resource tokens to donate
- Economics must favor the attack cost vs. profit from manipulated prices

**Detection/Operational Constraints:**
- Direct token transfers are normal operations, hard to distinguish from legitimate activity
- `EnableConnector` calls might appear legitimate for new connector activation
- Price manipulation may be detected only after exploitation

**Probability:** Medium - While the attack is technically simple, it requires significant capital (donated tokens) and the economic benefit must outweigh the donation cost. However, for high-value tokens with substantial accumulated deposits, the attack becomes economically rational.

### Recommendation

**1. Add Re-enabling Protection:**
```csharp
public override Empty EnableConnector(ToBeConnectedTokenInfo input)
{
    var fromConnector = State.Connectors[input.TokenSymbol];
    Assert(fromConnector != null && !fromConnector.IsDepositAccount,
        "[EnableConnector]Can't find from connector.");
    Assert(!fromConnector.IsPurchaseEnabled, 
        "Connector is already enabled.");
    var toConnector = State.Connectors[fromConnector.RelatedSymbol];
    Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
    Assert(!toConnector.IsPurchaseEnabled, 
        "Connector is already enabled.");
    // ... rest of function
}
```

**2. Use ADD Instead of SET for Deposit Balance:**
```csharp
State.DepositBalance[toConnector.Symbol] = 
    State.DepositBalance[toConnector.Symbol].Add(needDeposit.NeedAmount);
```

**3. Consider Symmetric Balance Tracking:**
Either use internal accounting for both sides, or accept that both sides can be manipulated and document this behavior.

**4. Add Authorization to EnableConnector:**
Restrict `EnableConnector` to governance/controller similar to `AddPairConnector`.

**5. Test Cases:**
- Test calling `EnableConnector` twice on same connector (should fail)
- Test enabling connector after direct token transfers (verify balance calculation)
- Test accumulated deposit balance preservation across operations

### Proof of Concept

**Initial State:**
- TokenConverter has resource token connector (CPU) with `IsPurchaseEnabled = true`
- Legitimate users have performed Buy operations, accumulating `State.DepositBalance[NTCPU] = 1,000,000 ELF`
- Resource token total supply = 10,000,000 CPU
- Current TokenConverter balance = 9,000,000 CPU

**Attack Steps:**

1. **Attacker donates 5,000,000 CPU to TokenConverter:**
   ```
   Transfer(from: Attacker, to: TokenConverter, symbol: CPU, amount: 5,000,000)
   ```
   New balance: 14,000,000 CPU

2. **Attacker calls EnableConnector:**
   ```
   EnableConnector(TokenSymbol: CPU, AmountToTokenConvert: 0)
   ```

3. **GetNeededDeposit calculates:**
   ```
   totalSupply = 10,000,000
   balance = 14,000,000
   amountOutOfTokenConvert = 10,000,000 - 14,000,000 - 0 = -4,000,000
   Since amountOutOfTokenConvert <= 0, needDeposit = 0
   ```

4. **State.DepositBalance overwritten:**
   ```
   State.DepositBalance[NTCPU] = 0  // Was 1,000,000 ELF!
   ```

**Expected vs Actual Result:**
- **Expected:** `EnableConnector` should fail or preserve existing deposit balance
- **Actual:** `State.DepositBalance[NTCPU]` reduced from 1,000,000 to 0, breaking reserve ratio

**Success Condition:**
Attacker can now buy CPU tokens at severely discounted prices due to imbalanced Bancor formula (0 deposit balance vs 14,000,000 CPU balance), extracting value equivalent to the lost deposit tracking.

### Citations

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L230-249)
```csharp
            var resourceTokenConnector = new Connector
            {
                Symbol = resourceTokenSymbol,
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.ResourceTokenInitialVirtualBalance,
                RelatedSymbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsDepositAccount = false
            };
            var nativeTokenConnector = new Connector
            {
                Symbol = EconomicContractConstants.NativeTokenPrefix.Append(resourceTokenSymbol),
                IsPurchaseEnabled = true,
                IsVirtualBalanceEnabled = true,
                Weight = "0.005",
                VirtualBalance = EconomicContractConstants.NativeTokenToResourceBalance,
                RelatedSymbol = resourceTokenSymbol,
                IsDepositAccount = true
            };
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-301)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```
