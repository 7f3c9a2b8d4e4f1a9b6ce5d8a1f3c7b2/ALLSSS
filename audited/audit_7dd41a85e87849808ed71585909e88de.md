### Title
Unauthorized Candidate Registration Enables Preemptive DoS Attack on Election System

### Summary
The `AnnounceElectionFor()` function lacks authorization checks to verify that the caller owns or has permission to register a given public key as a candidate. An attacker can force-register arbitrary public keys by paying the lock deposit, permanently preventing legitimate owners from announcing their candidacy and requiring Parliament intervention to recover.

### Finding Description

The vulnerability exists in the `AnnounceElectionFor()` function which accepts any public key string as input without verifying the caller's ownership or authorization. [1](#0-0) 

The function directly calls the internal `AnnounceElection(byte[] pubkeyBytes)` method without any authorization check: [2](#0-1) 

The internal method enforces that a public key can only be registered once as a current candidate through the assertion at lines 156-157. Once registered, any subsequent registration attempt fails, which enables the DoS attack.

In contrast, the legitimate `AnnounceElection(Address input)` method properly verifies ownership by recovering the public key from the transaction signature: [3](#0-2) 

The attacker sets themselves as the admin for the registered public key, and the admin field controls who can subsequently quit the election or modify admin rights: [4](#0-3) 

Recovery mechanisms are blocked because `SetCandidateAdmin()` requires the caller to be either the current admin or Parliament: [5](#0-4) 

### Impact Explanation

**Direct Impact:**
- **Governance Disruption**: Attacker can prevent legitimate validators/candidates from participating in elections, centralizing power to attacker-controlled candidates only
- **Candidate Lockout**: Legitimate public key owners cannot register themselves and lose eligibility for mining rewards and governance participation
- **Requires Governance Intervention**: Only Parliament default address can override admin controls, requiring emergency governance action

**Quantified Damage:**
- Attack cost: 100,000 tokens per public key registered [6](#0-5) 
- For typical blockchain with ~17-21 miners, validation data center count would be 85-105 (5x multiplier) [7](#0-6) 
- Total attack cost: 8.5M - 10.5M tokens for complete DoS
- Attacker can potentially recover tokens later by quitting elections

**Affected Parties:**
- Legitimate validators unable to announce candidacy
- Token holders unable to vote for desired candidates  
- Protocol governance integrity compromised

### Likelihood Explanation

**Attacker Capabilities Required:**
- Sufficient token balance to pay lock deposits (100,000 tokens per target)
- Knowledge of target public keys (publicly available for known validators)
- Ability to execute transactions faster than legitimate candidates (frontrunning)

**Attack Complexity:**
- Low technical complexity: simple contract call with target pubkey
- No special permissions needed beyond token balance
- Can be automated to target multiple candidates simultaneously

**Economic Feasibility:**
- Targeted attack (10-20 key validators): 1M-2M tokens - highly feasible
- Complete DoS (85-105 candidates): 8.5M-10.5M tokens - feasible for well-funded attacker
- Tokens may be recoverable by quitting, reducing net cost
- High-value scenarios (governance takeover, competitor elimination) justify costs

**Detection/Prevention:**
- No on-chain detection mechanism before damage occurs
- Once executed, requires Parliament intervention to fix
- Legitimate candidates may not realize they're locked out until attempting registration

### Recommendation

**Immediate Fix:**
Add authorization check in `AnnounceElectionFor()` to verify caller ownership:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkey = input.Pubkey;
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
    var address = Address.FromPublicKey(pubkeyBytes);
    
    // CRITICAL FIX: Verify caller owns the pubkey or has explicit approval
    Assert(Context.Sender == address || 
           State.CandidateRegistrationApprovals[pubkey][Context.Sender], 
           "No permission to register this public key.");
    
    AnnounceElection(pubkeyBytes);
    // ... rest of function
}
```

**Additional Protections:**
1. Add explicit approval mechanism where pubkey owners can pre-approve specific addresses to register on their behalf
2. Add time-lock or challenge period for third-party registrations
3. Emit event when third-party registration occurs for off-chain monitoring
4. Consider requiring pubkey owner signature in input for verification

**Test Cases:**
1. Verify unauthorized address cannot register arbitrary pubkey
2. Verify only pubkey owner or approved address can register
3. Verify legitimate owner can reclaim control if admin was incorrectly set
4. Test Parliament override still works for emergency situations

### Proof of Concept

**Initial State:**
- Victim has valid public key: `VICTIM_PUBKEY`
- Victim has not yet announced candidacy
- Attacker has 100,000+ tokens

**Attack Sequence:**

**Step 1:** Attacker calls `AnnounceElectionFor`:
```
Input: {
    Pubkey: VICTIM_PUBKEY,
    Admin: ATTACKER_ADDRESS
}
Caller: ATTACKER_ADDRESS
```
Result: Success - VICTIM_PUBKEY registered with attacker as admin

**Step 2:** Victim attempts to announce using `AnnounceElection`:
```
Caller: VICTIM_ADDRESS (signing with victim's private key)
```
Result: **FAILS** - Assertion at line 156-157: "This public key already announced election"

**Step 3:** Victim attempts to recover using `SetCandidateAdmin`:
```
Input: {
    Pubkey: VICTIM_PUBKEY,
    Admin: VICTIM_ADDRESS
}
Caller: VICTIM_ADDRESS
```
Result: **FAILS** - Assertion at line 38: "No permission" (victim is not current admin)

**Expected vs Actual:**
- **Expected**: Only VICTIM_ADDRESS can register VICTIM_PUBKEY
- **Actual**: Anyone can register any pubkey, permanently locking out legitimate owner

**Success Condition:**
Victim is permanently prevented from participating in elections unless Parliament intervenes to transfer admin rights.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L19-40)
```csharp
    public override Empty SetCandidateAdmin(SetCandidateAdminInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.Pubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.Pubkey), "Pubkey is already banned.");

        // Permission check
        var pubkey = State.InitialPubkeyMap[input.Pubkey] ?? input.Pubkey;
        if (Context.Sender != GetParliamentDefaultAddress())
        {
            if (State.CandidateAdmins[pubkey] == null)
            {
                // If admin is not set before (due to old contract code)
                Assert(Context.Sender == Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(input.Pubkey)),
                    "No permission.");
            }
            else
            {
                var oldCandidateAdmin = State.CandidateAdmins[pubkey];
                Assert(Context.Sender == oldCandidateAdmin, "No permission.");
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-119)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);

        var pubkey = recoveredPublicKey.ToHex();
        var address = Address.FromPublicKey(recoveredPublicKey);

        Assert(input.Value.Any(), "Admin is needed while announcing election.");
        Assert(State.ManagedCandidatePubkeysMap[address] == null, "Candidate cannot be others' admin.");
        State.CandidateAdmins[pubkey] = input;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[input] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(recoveredPublicKey));
        State.ManagedCandidatePubkeysMap[input] = managedPubkeys;

        LockCandidateNativeToken();

        AddCandidateAsOption(pubkey);

        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-142)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
        if (State.Candidates.Value.Value.Count <= GetValidationDataCenterCount())
        {
            State.DataCentersRankingList.Value.DataCenters.Add(pubkey, 0);
            RegisterCandidateToSubsidyProfitScheme(pubkey);
        }

        State.CandidateSponsorMap[input.Pubkey] = Context.Sender;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-175)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L229-236)
```csharp
    public override Empty QuitElection(StringValue input)
    {
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Value);
        QuitElection(pubkeyBytes);
        var pubkey = input.Value;

        var initialPubkey = State.InitialPubkeyMap[pubkey] ?? pubkey;
        Assert(Context.Sender == State.CandidateAdmins[initialPubkey], "Only admin can quit election.");
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L406-409)
```csharp
    private int GetValidationDataCenterCount()
    {
        return GetMinersCount(new Empty()).Value.Mul(5);
    }
```
