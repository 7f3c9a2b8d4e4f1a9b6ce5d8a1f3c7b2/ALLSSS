# Audit Report

## Title
Missing Cryptographic Verification of DecryptedPieces in Secret Sharing Mechanism

## Summary
The AEDPoS consensus contract's secret sharing mechanism accepts DecryptedPieces from miners without cryptographic verification, allowing a single malicious miner to permanently corrupt InValues stored on-chain. The reconstructed InValues are used in consensus signature calculations without validating that `Hash(revealedInValue) == previousOutValue`, compromising consensus integrity and violating Byzantine fault tolerance guarantees.

## Finding Description

The vulnerability exists in the secret sharing mechanism that recovers miners' InValues when they fail to self-report. The protocol flow involves two critical unprotected stages:

**Stage 1: Accepting Unverified DecryptedPieces**

When miners submit UpdateValueInput, the `PerformSecretSharing` function stores DecryptedPieces directly into other miners' records without any cryptographic verification. [1](#0-0) 

A malicious miner can submit arbitrary bytes as `DecryptedPieces[VictimPubkey]`, and these corrupt bytes are stored without validation that they are legitimate decryptions of the victim's EncryptedPieces.

**Stage 2: Reconstructing Without Validation**

During NextRound transitions, `RevealSharedInValues` reconstructs InValues using Shamir's Secret Sharing reconstruction. [2](#0-1) 

The function reads DecryptedPieces, passes them to `SecretSharingHelper.DecodeSecret()`, and stores the reconstructed InValue directly as PreviousInValue. Critically, there is **no validation** that `Hash(revealedInValue) == previousOutValue`.

**Why Existing Protections Fail**

The contract does validate self-reported PreviousInValue values. [3](#0-2) 

However, this validation only applies when miners directly report their InValue in UpdateValueInput. For InValues revealed through secret sharing reconstruction, no such validation exists.

**Attack Execution Path:**

1. Round N: Honest Miner A produces block, publishes `OutValue_A = Hash(InValue_A)` and `EncryptedPieces`
2. Round N+1: Malicious Miner B submits `UpdateValueInput` with `DecryptedPieces[A] = arbitrary_garbage`  
3. `PerformSecretSharing` stores the garbage bytes without verification
4. NextRound transition: `RevealSharedInValues` called [4](#0-3) 
5. Shamir's Secret Sharing reconstruction produces corrupted InValue from garbage bytes
6. Corrupted InValue stored as Miner A's PreviousInValue (line 52 in RevealSharedInValues)
7. `SupplyCurrentRoundInformation` retrieves the corrupted PreviousInValue [5](#0-4) 
8. Corrupted signature calculated: `signature = previousRound.CalculateSignature(previousInValue)`
9. Corrupted InValue and signature permanently stored for next round

## Impact Explanation

**Consensus State Corruption:**
The corrupted InValues become permanent on-chain state. When miners who didn't produce blocks need their InValue filled, `SupplyCurrentRoundInformation` uses the corrupted PreviousInValue, perpetuating the corruption indefinitely. [6](#0-5) 

**Signature Chain Corruption:**
Consensus signatures are calculated by XORing InValues with accumulated signatures. [7](#0-6) 

Corrupted InValues produce incorrect signatures, breaking the cryptographic chain that ensures consensus integrity and randomness quality.

**Byzantine Fault Tolerance Breach:**
The secret sharing mechanism is designed to provide 2/3 Byzantine fault tolerance. However, this vulnerability allows a **single malicious miner** to corrupt InValue revelation without meeting the Byzantine threshold. The minimum count requirement at line 36 in RevealSharedInValues provides no protection since the malicious DecryptedPiece is counted as valid input to the reconstruction algorithm.

This represents a critical severity issue as it undermines the fundamental security guarantees of the consensus mechanism, affecting all network participants and the integrity of the blockchain's consensus layer.

## Likelihood Explanation

**Attacker Capabilities:**
Any miner in the active consensus pool can execute this attack. The only requirement is being part of the miner set, which is the intended operational state.

**Attack Complexity: LOW**
The attack requires no sophisticated techniques:
1. Call the public `UpdateValue` method with manipulated DecryptedPieces
2. No timing constraints, race conditions, or multi-step setup required
3. Attack succeeds deterministically

**Feasibility: HIGH**  
The entry point `UpdateValue` processes the `UpdateValueInput` through standard consensus flow. [8](#0-7) 

No special permissions beyond standard miner authorization are required. Shamir's Secret Sharing reconstruction always produces output even from invalid inputsâ€”it has no internal validation mechanism to detect corrupt pieces.

**Detection: IMPOSSIBLE**
The contract has no validation to detect corrupt DecryptedPieces. All nodes process the corrupted data identically through deterministic state transitions, making the attack undetectable at the protocol level.

**Economic Rationality:**
- Attack cost: Transaction fee only (negligible)
- Impact: High (consensus integrity compromise)  
- Risk of detection: Zero (no validation mechanism exists)
- Potential benefit: Disrupting consensus, manipulating randomness, targeting specific miners

## Recommendation

Add cryptographic verification that DecryptedPieces are valid decryptions of EncryptedPieces. After reconstructing InValue in `RevealSharedInValues`, validate that the reconstructed value matches the expected OutValue:

```csharp
var revealedInValue = HashHelper.ComputeFrom(
    SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

// Add validation
var expectedOutValue = anotherMinerInPreviousRound.OutValue;
if (HashHelper.ComputeFrom(revealedInValue) != expectedOutValue)
{
    // Skip this miner or use alternative recovery mechanism
    Context.LogDebug(() => 
        $"Invalid InValue reconstruction for {publicKeyOfAnotherMiner}");
    continue;
}

currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

This ensures that revealed InValues satisfy the same cryptographic invariant (`Hash(InValue) == OutValue`) that is enforced for self-reported values.

## Proof of Concept

The vulnerability can be demonstrated by tracing the code execution path showing that DecryptedPieces are stored and used without validation:

1. Verify `PerformSecretSharing` stores DecryptedPieces without validation (lines 291-293)
2. Verify `RevealSharedInValues` reconstructs and stores InValue without checking Hash(revealedInValue) == OutValue (lines 49-52)  
3. Verify `UpdateValueValidationProvider.ValidatePreviousInValue` only validates self-reported values, not revealed values (lines 42, 46)
4. Verify `SupplyCurrentRoundInformation` uses potentially corrupted PreviousInValue to calculate signatures (lines 191-199)

A complete test would require setting up a multi-miner consensus environment with secret sharing enabled, having one miner submit corrupt DecryptedPieces in UpdateValueInput, then verifying that the reconstructed InValue is stored without validation and used in subsequent signature calculations. However, the code path analysis conclusively demonstrates the vulnerability exists as described.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-256)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L189-189)
```csharp
        RevealSharedInValues(currentRound, pubkey);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L191-199)
```csharp
                previousInValue = currentRound.RealTimeMinersInformation[miner.Pubkey].PreviousInValue;
                if (previousInValue == null)
                    previousInValue = previousRound.RealTimeMinersInformation[miner.Pubkey].InValue;

                // If previousInValue is still null, treat this as abnormal situation.
                if (previousInValue != null)
                {
                    Context.LogDebug(() => $"Previous round: {previousRound.ToString(miner.Pubkey)}");
                    signature = previousRound.CalculateSignature(previousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L213-214)
```csharp
            miner.InValue = previousInValue;
            miner.Signature = signature;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
