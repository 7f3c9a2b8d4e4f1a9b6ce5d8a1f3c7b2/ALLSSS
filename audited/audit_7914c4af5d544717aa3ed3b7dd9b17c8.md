### Title
InitialNFTTypeNameMap Fails to Re-initialize After All NFT Types Are Removed, Causing Permanent DoS of NFT Creation

### Summary
The `InitialNFTTypeNameMap()` function contains a flawed null check that fails to detect when `State.NFTTypes.Value` is an empty collection. If Parliament removes all default NFT types using `RemoveNFTType()`, the initialization logic will return early with an empty collection, preventing the creation of essential mappings and permanently breaking the `Create()` and `CrossChainCreate()` functions until Parliament manually re-adds types.

### Finding Description

The root cause lies in the initialization guard at line 41 of `InitialNFTTypeNameMap()`: [1](#0-0) 

This check only verifies that `State.NFTTypes.Value` is not null, but does not validate whether the collection contains any entries. 

**Exploitation Path:**

1. During initial contract usage, `InitialNFTTypeNameMap()` executes fully, creating 10 default NFT type mappings and setting `State.NFTTypes.Value` to a populated `NFTTypes` object: [2](#0-1) 

2. The foreach loop creates bidirectional mappings in `State.NFTTypeShortNameMap` and `State.NFTTypeFullNameMap`: [3](#0-2) 

3. Parliament calls `RemoveNFTType()` for each default type (protected by authorization check): [4](#0-3) 

Each removal deletes entries from all three state variables: `State.NFTTypeFullNameMap`, `State.NFTTypeShortNameMap`, and `State.NFTTypes.Value`. After removing all 10 types, `State.NFTTypes.Value` is a non-null but empty `NFTTypes` object.

4. When a user attempts to create an NFT via `Create()`, the code calls `GetSymbol()`: [5](#0-4) 

5. Since `State.NFTTypeShortNameMap[nftType]` returns null (map is empty), line 31 calls `InitialNFTTypeNameMap()` to reinitialize.

6. However, the guard at line 41 detects that `State.NFTTypes.Value != null` and returns early with the empty collection, skipping lines 43-60 entirely.

7. Back in `GetSymbol()`, line 32 still gets null for `shortName`, and line 33 throws an `AssertionException`, causing the transaction to fail.

8. The same vulnerability affects `CrossChainCreate()`: [6](#0-5) 

### Impact Explanation

**Operational Impact - Complete DoS:**
- All calls to `Create()` will fail with "Short name of NFT Type {nftType} not found"
- All calls to `CrossChainCreate()` will fail with "Full name of {nftTypeShortName} not found"
- No new NFT protocols can be created until Parliament intervenes

**Affected Parties:**
- All users attempting to create new NFT protocols
- Cross-chain NFT protocol synchronization becomes impossible
- Core NFT contract functionality is completely broken

**Recovery:**
Recovery is possible but requires manual Parliament intervention through multiple `AddNFTType()` transactions to re-add all removed types: [7](#0-6) 

During the recovery period, the contract remains in a DoS state.

**Severity: HIGH** - Complete operational failure of core contract functionality, though recoverable through governance.

### Likelihood Explanation

**Feasible Preconditions:**
- Requires Parliament default address authorization (legitimate governance role)
- Parliament could remove types for valid reasons: deprecation, reorganization, or policy changes
- No malicious intent required - can occur through governance mistakes

**Execution Practicality:**
- Simple execution: Parliament calls `RemoveNFTType()` 10 times (one per default type)
- Each call is protected but authorized for Parliament: [8](#0-7) 

**Likelihood: MEDIUM** - While requiring Parliament action (reducing likelihood), the scenario is realistic through legitimate governance operations, and the consequences are severe and unexpected.

### Recommendation

**Fix the initialization guard to check for empty collections:**

Modify line 41 in `InitialNFTTypeNameMap()` from:
```csharp
if (State.NFTTypes.Value != null) return State.NFTTypes.Value;
```

To:
```csharp
if (State.NFTTypes.Value?.Value.Count > 0) return State.NFTTypes.Value;
```

**Additional Safeguard:**
Consider adding a validation in `RemoveNFTType()` to prevent removal of the last NFT type, or ensure at least one type always remains:

```csharp
Assert(State.NFTTypes.Value.Value.Count > 1, "Cannot remove the last NFT type.");
```

**Test Cases:**
1. Test removing all NFT types and attempting to call `Create()`
2. Test removing all types and attempting to call `CrossChainCreate()`
3. Verify `InitialNFTTypeNameMap()` reinitializes correctly when collection is empty
4. Test recovery scenario using `AddNFTType()` after all types removed

### Proof of Concept

**Initial State:**
- Contract deployed and initialized
- `State.NFTTypes.Value` contains 10 default types
- All mapping states populated

**Attack Sequence:**

1. **Parliament removes all default NFT types:**
   - Call `RemoveNFTType("XX")` - removes Any type
   - Call `RemoveNFTType("AR")` - removes Art type
   - Call `RemoveNFTType("MU")` - removes Music type
   - Call `RemoveNFTType("DN")` - removes DomainNames type
   - Call `RemoveNFTType("VW")` - removes VirtualWorlds type
   - Call `RemoveNFTType("TC")` - removes TradingCards type
   - Call `RemoveNFTType("CO")` - removes Collectables type
   - Call `RemoveNFTType("SP")` - removes Sports type
   - Call `RemoveNFTType("UT")` - removes Utility type
   - Call `RemoveNFTType("BA")` - removes Badges type

   **Result:** `State.NFTTypes.Value` is non-null but empty (Count = 0)

2. **User attempts NFT creation:**
   - Call `Create(nftType: "Art", protocolName: "MyNFT", ...)`
   
   **Expected:** NFT protocol created successfully
   
   **Actual:** Transaction fails with `AssertionException: "Short name of NFT Type Art not found."`

3. **Verification:**
   - `InitialNFTTypeNameMap()` was called but returned early at line 41
   - `State.NFTTypeShortNameMap` remains empty
   - All subsequent `Create()` and `CrossChainCreate()` calls fail

**Success Condition:** 
The exploit succeeds when `Create()` consistently throws exceptions after all types are removed, demonstrating complete DoS of NFT creation functionality.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L41-41)
```csharp
        if (State.NFTTypes.Value != null) return State.NFTTypes.Value;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L43-54)
```csharp
        var nftTypes = new NFTTypes();
        nftTypes.Value.Add("XX", NFTType.Any.ToString());
        nftTypes.Value.Add("AR", NFTType.Art.ToString());
        nftTypes.Value.Add("MU", NFTType.Music.ToString());
        nftTypes.Value.Add("DN", NFTType.DomainNames.ToString());
        nftTypes.Value.Add("VW", NFTType.VirtualWorlds.ToString());
        nftTypes.Value.Add("TC", NFTType.TradingCards.ToString());
        nftTypes.Value.Add("CO", NFTType.Collectables.ToString());
        nftTypes.Value.Add("SP", NFTType.Sports.ToString());
        nftTypes.Value.Add("UT", NFTType.Utility.ToString());
        nftTypes.Value.Add("BA", NFTType.Badges.ToString());
        State.NFTTypes.Value = nftTypes;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L56-60)
```csharp
        foreach (var pair in nftTypes.Value)
        {
            State.NFTTypeShortNameMap[pair.Value] = pair.Key;
            State.NFTTypeFullNameMap[pair.Key] = pair.Value;
        }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L78-93)
```csharp
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L131-149)
```csharp
    public override Empty AddNFTType(AddNFTTypeInput input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        var fullName = input.FullName;
        Assert(input.ShortName.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.ShortName] == null, $"Short name {input.ShortName} already exists.");
        Assert(State.NFTTypeShortNameMap[fullName] == null, $"Full name {fullName} already exists.");
        State.NFTTypeFullNameMap[input.ShortName] = fullName;
        State.NFTTypeShortNameMap[fullName] = input.ShortName;
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Add(input.ShortName, fullName);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeAdded
        {
            ShortName = input.ShortName,
            FullName = input.FullName
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L152-168)
```csharp
    public override Empty RemoveNFTType(StringValue input)
    {
        AssertSenderIsParliamentDefaultAddress();
        InitialNFTTypeNameMap();
        Assert(input.Value.Length == 2, "Incorrect short name.");
        Assert(State.NFTTypeFullNameMap[input.Value] != null, $"Short name {input.Value} does not exist.");
        var fullName = State.NFTTypeFullNameMap[input.Value];
        State.NFTTypeFullNameMap.Remove(input.Value);
        State.NFTTypeShortNameMap.Remove(fullName);
        var nftTypes = State.NFTTypes.Value;
        nftTypes.Value.Remove(input.Value);
        State.NFTTypes.Value = nftTypes;
        Context.Fire(new NFTTypeRemoved
        {
            ShortName = input.Value
        });
        return new Empty();
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L171-182)
```csharp
    private void AssertSenderIsParliamentDefaultAddress()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        if (State.ParliamentDefaultAddress.Value == null)
            State.ParliamentDefaultAddress.Value =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());

        Assert(Context.Sender == State.ParliamentDefaultAddress.Value, "No permission.");
    }
```
