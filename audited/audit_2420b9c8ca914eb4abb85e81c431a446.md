### Title
Partial Transaction Fee Deduction Despite Failed Fee Charging

### Summary
Users are charged partial transaction fees even when the total fee charging fails. When `ChargeTransactionFeesToBill` or `ChargeFromDelegations` partially modify the `bill` and `allowanceBill` objects via ref parameters but ultimately return false, these partial modifications persist. The `ModifyBalance` function is then called unconditionally and deducts these partial amounts, while the main transaction is rejected. This violates the atomic principle that fees should only be charged when transactions can proceed.

### Finding Description

The vulnerability exists in the `TryToChargeTransactionFee` function where `bill` and `allowanceBill` are passed by reference to multiple charging functions: [1](#0-0) 

At line 90, `ChargeTransactionFeesToBill` is called with ref parameters, and at line 94, `ChargeFromDelegations` is called with the same ref parameters. Critically, line 118 calls `ModifyBalance` unconditionally, regardless of whether `chargingResult` is true or false.

**Root Cause**: The ref parameters allow partial modifications that persist even when the functions return false:

1. In `ChargeBaseFee`, when charging fails, partial amounts are still added to the bill: [2](#0-1) 

Even on failure, lines 351-352 add `existingBalance` and `existingAllowance` to the bill.

2. In `ChargeSizeFee`, `GenerateBill` is called before determining success for non-delegation cases: [3](#0-2) 

Line 428-429 calls `GenerateBill` regardless of the `chargeResult` value (for non-delegation paths).

3. `GenerateBill` adds whatever balance is available, even if insufficient: [4](#0-3) 

Lines 541-542 add all available balance and allowance to the bill even when the total is less than required.

4. Finally, `ModifyBalance` processes whatever amounts are in the bill and deducts them from user balances: [5](#0-4) 

**Why Existing Protections Fail**: The code relies on the assumption that bills would only contain valid amounts when charging succeeds. However, the ref parameter mutations bypass this assumption by persisting partial data through failed attempts. When the pre-execution plugin checks the return value, it sees Success = false and stops the main transaction, but the fee deductions have already been committed: [6](#0-5) 

### Impact Explanation

**Direct Fund Loss**: Users lose tokens without their transactions executing. For a transaction requiring 100 ELF base fee + 50 ELF size fee, a user with only 80 ELF would lose their entire 80 ELF balance while having their transaction rejected.

**Affected Parties**: All users attempting transactions with insufficient fee balances are affected. This includes:
- Users miscalculating required fees
- Users whose balance depletes between transaction submission and execution
- Users during high-fee periods

**Quantified Damage**: The loss equals the user's available balance up to the required fee amount. In scenarios with high transaction fees (e.g., 1000 ELF), users could lose substantial funds.

**Severity Justification**: HIGH - This breaks the fundamental atomic property of transaction fee charging. Users expect either: (1) fees are charged and transaction executes, or (2) fees are not charged and transaction fails. The current implementation creates a third unacceptable state where fees are charged but the transaction fails.

### Likelihood Explanation

**Attacker Capabilities**: None required - this occurs naturally through normal transaction submission when users have insufficient balances. No special permissions or setup needed.

**Attack Complexity**: Trivial - simply submit any transaction with insufficient balance for the full fee. The vulnerability triggers automatically through the normal fee charging flow.

**Feasibility Conditions**: 
- User has some balance but less than total required fee (very common)
- No delegation configured, or delegations also insufficient (common default state)
- Any transaction type that incurs fees

**Probability**: Very high - this is not an edge case but a common scenario in blockchain systems where users may have insufficient balances. The condition occurs naturally without any attacker action.

**Detection/Operational Constraints**: The issue is silent from the user's perspective - they only see "Transaction fee not enough" while their balance has been reduced. No alerts or error messages indicate partial fee deduction occurred.

### Recommendation

**Code-Level Mitigation**:

1. **Only call ModifyBalance on success**: Move the ModifyBalance call inside a conditional block:

```csharp
if (chargingResult)
{
    ModifyBalance(fromAddress, bill, allowanceBill);
}
```

2. **Create clean bill objects for each attempt**: In `ChargeFromDelegations`, don't reuse the input bill/allowanceBill. Always create fresh objects and only assign on success:

```csharp
// At start of each charging attempt
var attemptBill = new TransactionFeeBill();
var attemptAllowanceBill = new TransactionFreeFeeAllowanceBill();
// ... perform charging ...
// Only on success:
if (success) {
    bill = attemptBill;
    allowanceBill = attemptAllowanceBill;
}
```

3. **Don't populate bills on failure**: Modify `ChargeBaseFee` to not add partial amounts when returning false. Remove lines 351-352 or wrap them in a success condition.

**Invariant Checks**:
- Add assertion: `Assert(chargingResult, "Cannot modify balance when charging failed")`  before calling ModifyBalance
- Add test: verify balance unchanged when ChargeTransactionFees returns Success = false

**Test Cases**:
- Test: User with 50 ELF attempting transaction requiring 100 ELF base + 50 ELF size fee → balance should remain 50 ELF
- Test: User with 100 ELF attempting transaction requiring 100 ELF base + 50 ELF size fee → balance should remain 100 ELF  
- Test: Partial base fee success, size fee failure → verify no balance deduction

### Proof of Concept

**Initial State**:
- User address: Alice
- Alice's ELF balance: 80 ELF
- Required base fee: 100 ELF
- Required size fee: 50 ELF
- No delegation configured

**Transaction Steps**:

1. Alice submits transaction to contract method requiring above fees
2. Pre-execution plugin calls `ChargeTransactionFees`
3. `TryToChargeTransactionFee` is invoked
4. `ChargeTransactionFeesToBill` is called (line 90)
   - `ChargeBaseFee` executes
   - `ChargeFirstSufficientToken` returns false (80 < 100)
   - Lines 351-352 execute: adds 80 ELF to `bill.FeesMap`
   - Returns false
   - `ChargeSizeFee` executes
   - Calculates availableBalance = 80 - 80 = 0 (already in bill)
   - `GenerateBill` called (line 428) with availableBalance = 0
   - Returns false
5. `ChargeFromDelegations` called (line 94) → returns false (no delegations)
6. Loop at lines 106-114 → returns false (no delegatees)
7. **Line 118 executes**: `ModifyBalance(Alice, bill, allowanceBill)`
   - Bill contains: {"ELF": 80}
   - Line 248 executes: `ModifyBalance(Alice, "ELF", -80)`
   - Alice's balance reduced from 80 to 0
8. Returns `Success = false`
9. Pre-execution plugin stops main transaction

**Expected Result**: Alice's balance remains 80 ELF, transaction rejected with "insufficient fee" message

**Actual Result**: Alice's balance becomes 0 ELF, transaction rejected, Alice loses 80 ELF without transaction execution

**Success Condition**: After the sequence, verify Alice's balance is 0 despite Success = false return value, demonstrating the partial fee deduction vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L84-126)
```csharp
    private ChargeTransactionFeesOutput TryToChargeTransactionFee(ChargeTransactionFeesInput input, Address fromAddress,
        TransactionFeeBill bill, TransactionFreeFeeAllowanceBill allowanceBill, Dictionary<string, long> fee,
        bool isSizeFeeFree)
    {
        Context.LogDebug(() => "TryToChargeTransactionFee Start");
        var chargingResult =
            ChargeTransactionFeesToBill(input, fromAddress, ref bill, ref allowanceBill, fee, isSizeFeeFree);
        if (!chargingResult)
        {
            var delegatorAddress = fromAddress;
            chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                isSizeFeeFree, delegatorAddress);
        }

        if (!chargingResult)
        {
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
                {
                    chargingResult = ChargeFromDelegations(input, ref fromAddress, ref bill, ref allowanceBill, fee,
                        isSizeFeeFree, Address.FromBase58(delegatee));
                    if (chargingResult)
                    {
                        break;
                    }
                }
            }
        }

        ModifyBalance(fromAddress, bill, allowanceBill);
        var chargingOutput = new ChargeTransactionFeesOutput { Success = chargingResult };
        if (!chargingResult)
            chargingOutput.ChargingInformation = "Transaction fee not enough.";
        
        Context.LogDebug(() => "TryToChargeTransactionFee End");
        Context.LogDebug(() => "ChargeTransactionFees End");
        return chargingOutput;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L237-266)
```csharp
    private void ModifyBalance(Address fromAddress, TransactionFeeBill bill,
        TransactionFreeFeeAllowanceBill allowanceBill)
    {
        Assert(!IsInTransferBlackListInternal(fromAddress), "Charge fee address is in transfer blacklist.");
        SetOrRefreshTransactionFeeFreeAllowances(fromAddress);
        var freeAllowancesMap = CalculateTransactionFeeFreeAllowances(fromAddress);

        // Update balances and allowances
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
        }

        if (freeAllowancesMap.Map == null || freeAllowancesMap.Map.Count == 0) return;

        foreach (var (symbol, amount) in allowanceBill.FreeFeeAllowancesMap)
        {
            if (amount > 0)
            {
                ModifyFreeFeeAllowanceAmount(fromAddress, freeAllowancesMap, symbol, -amount);
            }
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L343-356)
```csharp
        if (!ChargeFirstSufficientToken(methodFeeMap, fromAddress, out var symbolToChargeBaseFee,
                out var amountToChargeBaseFee, out var existingBalance, out var existingAllowance,
                transactionFeeFreeAllowancesMap,
                delegations))
        {
            Context.LogDebug(() => "Failed to charge first sufficient token.");
            if (symbolToChargeBaseFee != null)
            {
                bill.FeesMap.Add(symbolToChargeBaseFee, existingBalance);
                allowanceBill.FreeFeeAllowancesMap.Add(symbolToChargeBaseFee, existingAllowance);
            } // If symbol == 

            return false;
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L417-434)
```csharp
        var chargeResult = availableBalance.Add(availableAllowance) >= txSizeFeeAmount;
        if (delegations != null)
        {
            chargeResult = chargeResult && IsDelegationEnough(symbolToPayTxFee, symbolChargedForBaseFee,
                amountChargedForBaseFee.Add(amountChargedForBaseAllowance), txSizeFeeAmount, delegations);
            if (!chargeResult)
            {
                return false;
            }
        }

        GenerateBill(txSizeFeeAmount, symbolToPayTxFee, symbolChargedForBaseFee, availableBalance, availableAllowance,
            ref bill, ref allowanceBill);
        
        Context.LogDebug(() => "ChargeSizeFee End");

        return chargeResult;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L539-543)
```csharp
        else
        {
            chargeAllowanceAmount = availableAllowance;
            chargeAmount = availableBalance;
        }
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForMethodFee/MethodFeeChargedPreExecutionPluginBase.cs (L123-129)
```csharp
    public bool IsStopExecuting(ByteString txReturnValue, out string preExecutionInformation)
    {
        var chargeTransactionFeesOutput = new ChargeTransactionFeesOutput();
        chargeTransactionFeesOutput.MergeFrom(txReturnValue);
        preExecutionInformation = chargeTransactionFeesOutput.ChargingInformation;
        return !chargeTransactionFeesOutput.Success;
    }
```
