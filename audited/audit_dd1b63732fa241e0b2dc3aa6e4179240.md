### Title
Cross-Chain NFT Protocol Creation Bypasses Metadata Validation Allowing Malicious ExternalInfo Injection

### Summary
The `CrossChainCreate()` function copies all `tokenInfo.ExternalInfo` directly into `NFTProtocolInfo.Metadata` without validating that metadata keys don't conflict with NFT-reserved keys. An attacker can create a token on the mainchain via `MultiToken.Create()` with malicious ExternalInfo (including corrupted values for NFT-reserved keys), sync it to a sidechain, and register it as an NFT protocol with unvalidated metadata, bypassing the metadata validation enforced by the legitimate `NFT.Create()` flow.

### Finding Description

The vulnerability exists in the `CrossChainCreate()` function where it copies all token metadata without validation: [1](#0-0) 

This line copies all `tokenInfo.ExternalInfo.Value` into the NFT protocol's metadata field without any validation checks. In contrast, the mainchain `Create()` function validates user-provided metadata to ensure it doesn't use reserved keys: [2](#0-1) 

The `AssertMetadataKeysAreCorrect()` function checks that user metadata doesn't conflict with reserved NFT keys: [3](#0-2) 

These reserved keys include critical NFT metadata fields: [4](#0-3) 

**Root Cause:** The `CrossChainCreate()` function assumes that any token retrieved from the TokenContract was created through the proper `NFT.Create()` flow and thus has properly validated metadata. However, tokens can be created directly via `MultiToken.Create()` on the mainchain, which does not perform NFT-specific metadata validation: [5](#0-4) 

The MultiToken contract only validates token alias settings but does not check for conflicts with NFT-reserved metadata keys: [6](#0-5) 

**Exploitation Path:**
1. Attacker creates a token on mainchain (AELF) via `MultiToken.Create()` with symbol matching NFT naming conventions (e.g., "AR12345678")
2. Attacker includes malicious ExternalInfo with NFT-reserved keys (e.g., `aelf_nft_base_uri` pointing to a phishing site)
3. Token is synced to sidechain via standard cross-chain flow (`CrossChainCreateToken`)
4. Attacker calls `CrossChainCreate()` on sidechain NFT contract
5. Function extracts baseUri directly from unvalidated ExternalInfo: [7](#0-6) 

6. All malicious metadata is copied into NFT protocol without validation

### Impact Explanation

**Concrete Harm:**
- **Malicious baseUri Injection:** The `baseUri` field (line 87) is extracted directly from `ExternalInfo` without validation. An attacker can set this to a phishing URL, causing all NFT metadata queries to direct users to malicious websites for credential harvesting or malware distribution.

- **Metadata Poisoning:** The entire `ExternalInfo` dictionary is copied into `NFTProtocolInfo.Metadata` (line 104), allowing injection of arbitrary key-value pairs that could:
  - Override or corrupt NFT-specific metadata fields
  - Include misleading information about token properties
  - Inject malicious scripts or content into metadata fields consumed by wallets/marketplaces

- **Protocol Integrity Violation:** NFT protocols created via this vulnerability bypass the metadata validation guarantees enforced on the mainchain, creating a trust inconsistency where sidechain NFT protocols don't meet the same security standards as mainchain protocols.

**Affected Parties:**
- End users viewing NFT metadata through frontends/wallets
- NFT marketplaces and applications consuming this metadata
- The overall integrity of the AElf NFT ecosystem

**Severity Justification (Medium):**
- No direct fund theft, but significant operational and trust impact
- Enables phishing attacks and metadata manipulation
- Affects user safety and protocol reputation

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to call public smart contract methods (any user)
- Token creation cost on mainchain (standard SEED NFT consumption or whitelist access)
- Cross-chain transaction fees (minimal)

**Attack Complexity:** LOW
1. Call `MultiToken.Create()` on mainchain with crafted ExternalInfo
2. Use standard cross-chain token sync process
3. Call `CrossChainCreate()` on sidechain (public method with no authorization checks) [8](#0-7) 

**Feasibility Conditions:**
- No special privileges required
- All preconditions are standard operational requirements
- Cross-chain infrastructure is available and functional
- No race conditions or timing dependencies

**Economic Rationality:**
- Attack cost: Standard token creation fee + cross-chain transaction fees
- Potential gain: Phishing victims, reputation damage to legitimate projects
- Cost-benefit ratio favorable for targeted attacks

**Detection Constraints:**
- Malicious metadata appears as legitimate NFT protocol on sidechain
- No on-chain indicators distinguishing bypassed validation
- Requires off-chain monitoring of baseUri endpoints and metadata content

### Recommendation

**Immediate Fix:**
Add metadata validation in `CrossChainCreate()` before copying ExternalInfo:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    // ... existing code up to line 86 ...
    
    // NEW: Validate that user-provided metadata keys don't conflict with reserved keys
    var userMetadataKeys = tokenInfo.ExternalInfo.Value.Keys
        .Where(k => !GetNftMetadataReservedKeys().Contains(k));
    AssertMetadataKeysAreCorrect(userMetadataKeys);
    
    var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
    // ... continue with existing logic ...
}
```

**Additional Invariant Checks:**
1. Verify that `baseUri` format is valid (e.g., proper URI scheme)
2. Ensure `isTokenIdReuse` value matches expected boolean string format
3. Validate that NFT type in ExternalInfo (if present) matches the derived type from symbol

**Test Cases to Add:**
1. Test that `CrossChainCreate()` rejects tokens with user-provided reserved keys in ExternalInfo
2. Test that tokens created via `MultiToken.Create()` with NFT-reserved keys cannot be registered as NFT protocols
3. Verify that only properly validated metadata from mainchain `NFT.Create()` can be synced
4. Add negative test cases for malformed `baseUri` and `isTokenIdReuse` values

### Proof of Concept

**Initial State:**
- Mainchain (AELF) with deployed MultiToken and NFT contracts
- Sidechain with deployed MultiToken and NFT contracts
- Cross-chain infrastructure operational
- "AR" NFT type registered on sidechain

**Attack Sequence:**

**Step 1 - Create Malicious Token on Mainchain:**
```
Transaction to MultiToken.Create() on mainchain:
{
  Symbol: "AR99999999",
  TokenName: "Fake NFT Collection",
  TotalSupply: 1000000,
  Decimals: 0,
  Issuer: <attacker_address>,
  IsBurnable: true,
  IssueChainId: 9992731,
  ExternalInfo: {
    "aelf_nft_base_uri": "https://malicious-phishing-site.com/nft/",
    "aelf_nft_token_id_reuse": "true",
    "aelf_nft_type": "Art",
    "malicious_metadata": "injected_content"
  }
}
```

**Step 2 - Sync to Sidechain:**
```
Call ValidateTokenInfoExists on mainchain with AR99999999
Submit CrossChainCreateToken on sidechain with merkle proof
```

**Step 3 - Create NFT Protocol on Sidechain:**
```
Transaction to NFT.CrossChainCreate() on sidechain:
{
  Symbol: "AR99999999"
}
```

**Expected Result (Without Fix):**
- NFT protocol created on sidechain
- `NFTProtocolInfo.BaseUri` = "https://malicious-phishing-site.com/nft/"
- `NFTProtocolInfo.Metadata` contains all malicious ExternalInfo keys
- No validation error thrown

**Actual Result (With Fix):**
- Transaction should revert with "Metadata key aelf_nft_base_uri is reserved."
- NFT protocol creation fails
- Metadata integrity maintained

**Success Condition:** Attack succeeds when NFT protocol is created with unvalidated metadata that bypasses mainchain validation checks.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L87-88)
```csharp
        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L104-104)
```csharp
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L186-186)
```csharp
        if (input.Metadata != null) AssertMetadataKeysAreCorrect(input.Metadata.Value.Keys);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L118-123)
```csharp
    private void AssertMetadataKeysAreCorrect(IEnumerable<string> metadataKeys)
    {
        var reservedMetadataKey = GetNftMetadataReservedKeys();
        foreach (var metadataKey in metadataKeys)
            Assert(!reservedMetadataKey.Contains(metadataKey), $"Metadata key {metadataKey} is reserved.");
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L7-11)
```csharp
    private const string NftTypeMetadataKey = "aelf_nft_type";
    private const string NftBaseUriMetadataKey = "aelf_nft_base_uri";
    private const string NftTokenIdReuseMetadataKey = "aelf_nft_token_id_reuse";
    private const string AssembledNftsKey = "aelf_assembled_nfts";
    private const string AssembledFtsKey = "aelf_assembled_fts";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L77-79)
```csharp
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L81-85)
```csharp
        if (IsAliasSettingExists(tokenInfo))
        {
            Assert(symbolType == SymbolType.NftCollection, "Token alias can only be set for NFT Item.");
            SetTokenAlias(tokenInfo);
        }
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```
