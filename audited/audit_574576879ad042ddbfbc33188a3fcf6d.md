### Title
Mining Order Manipulation via Unchecked FinalOrderOfNextRound in Consensus Extra Data

### Summary
A malicious miner can arbitrarily manipulate the mining order for the next round by crafting consensus extra data with malicious `FinalOrderOfNextRound` values for other miners. The validation system fails to verify these values, allowing the attacker to reorder the mining schedule through the `TuneOrderInformation` mechanism, compromising consensus integrity and enabling targeted attacks such as censorship or MEV extraction.

### Finding Description

**Location**: The vulnerability spans multiple files in the consensus validation and processing flow.

**Root Cause**: The consensus validation system does not verify that `FinalOrderOfNextRound` values in the block header's consensus extra data match the legitimate values that would be calculated by `ApplyNormalConsensusData`. Instead, these values are blindly accepted and applied to the consensus state. [1](#0-0) 

When `ExtractInformationToUpdateConsensus` executes, it extracts `tuneOrderInformation` from miners whose `FinalOrderOfNextRound != SupposedOrderOfNextRound`. A malicious miner can manipulate this by providing crafted `FinalOrderOfNextRound` values in the consensus header.

**Exploitation Path**:

1. During block production, `GenerateConsensusTransactions` calls `ExtractInformationToUpdateConsensus` with the Round object from the consensus header: [2](#0-1) 

2. The malicious miner crafts a Round object with arbitrary `FinalOrderOfNextRound` values for other miners and includes it in the block header's consensus extra data.

3. When `ValidateBeforeExecution` runs, it calls `RecoverFromUpdateValue` which **blindly copies** the provided `FinalOrderOfNextRound` values from the header to the base round: [3](#0-2) 

4. The validation then proceeds with `UpdateValueValidationProvider`, which only checks `OutValue`, `Signature`, and `PreviousInValue`, but **does NOT validate `FinalOrderOfNextRound`**: [4](#0-3) 

5. The extracted `TuneOrderInformation` (containing the malicious values) is then applied during `ProcessUpdateValue`: [5](#0-4) 

**Why Protections Fail**:

The `NextRoundMiningOrderValidationProvider` that validates `FinalOrderOfNextRound` is only applied for `NextRound` behavior, not `UpdateValue`: [6](#0-5) 

The legitimate calculation in `ApplyNormalConsensusData` uses the miner's signature to deterministically calculate `SupposedOrderOfNextRound` and resolves conflicts: [7](#0-6) 

However, there is no validation that the `FinalOrderOfNextRound` values in the consensus header match this legitimate calculation.

### Impact Explanation

**Consensus Integrity Violation**: A malicious miner can arbitrarily reorder the mining schedule for the next round, fundamentally compromising the fairness and security of the consensus mechanism. This enables:

1. **Targeted Censorship**: The attacker can position themselves or colluding miners strategically to censor specific transactions or blocks from certain miners.

2. **MEV Extraction**: By controlling mining order, the attacker can optimize extraction of maximum extractable value (MEV) across multiple blocks.

3. **Network Disruption**: Reordering can cause specific miners to miss their time slots, potentially marking them as "evil miners" and affecting their reputation/rewards.

4. **Chain Reorganization Setup**: Strategic reordering can be used as a precursor to more sophisticated attacks requiring specific block production sequences.

**Affected Parties**: All network participants are affected as the consensus mechanism's integrity is violated. Honest miners suffer from unfair scheduling, and users experience potential transaction censorship.

**Severity Justification**: HIGH - This directly violates the core consensus invariant "miner schedule integrity" and allows a single malicious miner to manipulate the entire round's mining order without detection.

### Likelihood Explanation

**Attacker Capabilities**: The attacker only needs to be a valid miner in the current round, which is a normal operational role. No additional privileges or compromises are required.

**Attack Complexity**: LOW - The attack simply requires:
1. Obtaining the current round state (publicly available)
2. Crafting a Round object with modified `FinalOrderOfNextRound` values
3. Including it in the block's consensus extra data

The miner's node generates consensus extra data via `GetConsensusExtraData`, but nothing prevents the miner from modifying this data before including it in the block header: [8](#0-7) 

**Feasibility Conditions**: The attack is feasible at any time when:
- The attacker is an active miner in the current round
- Multiple miners exist (single-miner scenarios have different logic)

**Detection/Operational Constraints**: The attack is difficult to detect because:
- The modified values are within valid ranges
- The validation system accepts them as legitimate
- No logs or events specifically track order manipulation

**Probability**: HIGH - Any miner can perform this attack with minimal effort, and the economic incentive exists due to MEV opportunities and competitive advantages.

### Recommendation

**Immediate Fix**: Add validation in `UpdateValueValidationProvider` to verify that `FinalOrderOfNextRound` values are correctly calculated:

1. **Validate Current Miner's Order**: Verify that the current miner's `FinalOrderOfNextRound` equals their `SupposedOrderOfNextRound` (calculated from their signature).

2. **Validate Tuned Orders**: For any miners in `TuneOrderInformation`, verify that:
   - Their tuned order is due to a legitimate conflict resolution
   - The conflict was with the current miner's calculated order
   - The new order follows the conflict resolution algorithm from `ApplyNormalConsensusData`

3. **Prohibit Arbitrary Tuning**: Miners should only be allowed to tune orders that conflict with their own calculated order, not arbitrary miners.

**Code-Level Mitigation**:

Add a new validation provider `TuneOrderValidationProvider` that:
```
- Recalculates SupposedOrderOfNextRound from the miner's signature
- Identifies legitimate conflicts
- Verifies TuneOrderInformation only contains legitimate conflict resolutions
- Rejects any tuning of miners who don't conflict with the current miner
```

Apply this provider for `UpdateValue` behavior in `ValidateBeforeExecution`.

**Invariant Checks**:
- `FinalOrderOfNextRound` can only differ from `SupposedOrderOfNextRound` if there was a legitimate conflict
- Only miners whose `SupposedOrderOfNextRound` conflicts with the current miner can have their `FinalOrderOfNextRound` modified
- The modified order must follow the deterministic conflict resolution algorithm

**Test Cases**:
- Test that a miner attempting to tune non-conflicting miners is rejected
- Test that conflict resolution is correctly validated
- Test that attempting to set arbitrary `FinalOrderOfNextRound` values fails validation

### Proof of Concept

**Initial State**:
- Round N has 5 miners: A, B, C, D, E
- Miners have `SupposedOrderOfNextRound` and `FinalOrderOfNextRound` = 1, 2, 3, 4, 5 respectively
- All have already mined in current round

**Attack Steps**:

1. Malicious miner B prepares to produce block at their time slot
2. B calls contract's `GetConsensusExtraData` to get legitimate consensus data
3. B modifies the returned Round object:
   - Sets C's `FinalOrderOfNextRound` from 3 to 5
   - Sets E's `FinalOrderOfNextRound` from 5 to 3
4. B includes this crafted Round in the block header's consensus extra data
5. B produces the block with normal signature and OutValue

**Validation Flow**:

6. `ValidateBeforeExecution` loads base round from state (has legitimate values 1,2,3,4,5)
7. Calls `RecoverFromUpdateValue` which copies B's crafted values (C=5, E=3) into base round
8. `UpdateValueValidationProvider` validates OutValue/Signature/PreviousInValue only - **PASSES**
9. No validation checks `FinalOrderOfNextRound` values - **PASSES**

**Execution**:

10. `GenerateConsensusTransactions` calls `ExtractInformationToUpdateConsensus` with B's crafted Round
11. Extracts `tuneOrderInformation = {C: 5, E: 3}` (since C's FinalOrderOfNextRound 5 != SupposedOrderOfNextRound 3, same for E)
12. `UpdateValue` transaction executes
13. Line 247: Sets B's `FinalOrderOfNextRound = B's SupposedOrderOfNextRound`  
14. Lines 259-260: Applies tuning - sets state C's `FinalOrderOfNextRound = 5`, E's `FinalOrderOfNextRound = 3`

**Result**:
- **Expected**: Mining order for next round: A(1), B(2), C(3), D(4), E(5)
- **Actual**: Mining order for next round: A(1), B(2), E(3), D(4), C(5)

**Success Condition**: After the block is processed, querying the consensus state shows C and E have swapped positions in the next round's mining order, despite no legitimate conflict occurring. B has successfully manipulated the mining schedule.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-24)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L22-30)
```csharp
        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
