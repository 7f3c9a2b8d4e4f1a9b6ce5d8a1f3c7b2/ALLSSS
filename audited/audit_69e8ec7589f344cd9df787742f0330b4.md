### Title
Governance Deadlock in Side Chain Rental Fee Controller Allows Permanent DOS of Fee Adjustments

### Summary
The side chain rental fee controller requires unanimous approval from both parliament and sideChainCreator for any governance action. Either party can permanently block rental fee adjustments by refusing to approve proposals, with no escape mechanism available since changing the controller itself also requires unanimous approval. This locks side chains into potentially incorrect pricing indefinitely.

### Finding Description

The `GetControllerCreateInputForSideChainRental()` function creates an Association organization controller with unanimous approval requirements: [1](#0-0) 

Lines 258-259 set `MinimalApprovalThreshold = proposers.Count` and `MinimalVoteThreshold = proposers.Count`, where `proposers.Count = 2` (parliament + sideChainCreator). This means BOTH parties must approve any proposal.

This controller governs three critical operations:

1. **UpdateRental()** - Updates rental unit prices: [2](#0-1) 

2. **UpdateRentedResources()** - Updates resource amounts: [3](#0-2) 

3. **ChangeSideChainRentalController()** - Changes the controller itself: [4](#0-3) 

All three operations require the controller's approval via: [5](#0-4) 

**Root Cause**: The controller design creates a mutual veto system with no escape hatch. Since changing the controller also requires unanimous approval from the current controller, there is no mechanism to resolve deadlocks.

**Why Protections Fail**: The only way to set the controller is during initialization or through `ChangeSideChainRentalController()`: [6](#0-5) 

Both paths require the current controller's unanimous approval, creating a circular dependency.

### Impact Explanation

**Direct Economic Impact**: Rental fees directly determine side chain operational costs. The calculation uses `State.Rental[symbol]`: [7](#0-6) 

If rental fees become incorrect due to market changes, tokenomics updates, or initial misconfiguration:
- **Too high**: Side chains become unprofitable, forcing operators to shut down
- **Too low**: Side chains are subsidized unfairly, draining resources from the main chain
- **Market adaptation**: Unable to respond to changing resource costs or economic conditions

**Affected Parties**: All side chain operators and users who depend on them for services.

**Governance Paralysis**: Either parliament OR sideChainCreator can unilaterally block:
- Fee adjustments to correct pricing errors
- Resource allocation updates
- Controller changes to fix the governance structure

**Severity Justification**: Medium severity because:
- Direct operational and economic impact on side chains
- Permanent lock-in with no recovery mechanism
- Affects entire side chain ecosystem
- Requires only one party to refuse approval (not a complex attack)

### Likelihood Explanation

**Attacker Capabilities**: Either legitimate governance party (parliament or sideChainCreator) can cause this by simply refusing to approve proposals. No special privileges or attack sophistication required.

**Attack Complexity**: Minimal - the "attacker" passively refuses to vote or actively votes against proposals.

**Feasible Scenarios**:
1. **Legitimate Disagreement**: Parliament and sideChainCreator have conflicting interests on fee levels
2. **Governance Capture**: One party becomes unresponsive or compromised
3. **Strategic Holdout**: One party demands concessions before approving updates
4. **Technical Failure**: Key holder loss or organizational dissolution

**Execution Practicality**: Trivial - this is not an active exploit but a design flaw that manifests during normal operations when consensus cannot be reached.

**Detection**: The deadlock is immediately apparent when proposals consistently fail to achieve unanimous approval. However, there is no programmatic resolution.

**Probability**: Medium to High - governance disagreements are common in multi-party systems, especially when economic interests diverge.

### Recommendation

**Immediate Fix**: Modify the approval threshold to require supermajority instead of unanimous consent:

```csharp
ProposalReleaseThreshold = new ProposalReleaseThreshold
{
    MinimalApprovalThreshold = (proposers.Count * 2 / 3) + 1, // 2 of 2 = still 2, but scales better
    MinimalVoteThreshold = proposers.Count,
    MaximalRejectionThreshold = proposers.Count / 3, // Allow minority rejection
    MaximalAbstentionThreshold = 0
}
```

**Better Solution**: Implement a tiered governance structure:
1. Normal updates require 2-of-2 approval
2. After X days of deadlock, allow parliament alone to execute (emergency override)
3. Add time-locks for unilateral actions to allow for disputes

**Alternative**: Add an emergency override through a separate high-authority organization (e.g., parliament's emergency response organization).

**Invariant to Add**: Verify that controller changes can always be executed by at least one recovery path that doesn't require unanimous approval from the current controller.

**Test Cases**:
1. Test proposal rejection by one party and verify system behavior
2. Test controller change attempts when one party is uncooperative
3. Test emergency override mechanisms if implemented
4. Test timeout-based fallback governance paths

### Proof of Concept

**Initial State**:
- SideChainRentalController is initialized with parliament and sideChainCreator as members
- Current rental fee: 100 tokens per resource unit
- Market conditions change, requiring fee reduction to 50 tokens

**Attack Sequence**:
1. Parliament creates proposal to call `UpdateRental()` with new fee of 50 tokens
2. Parliament approves the proposal (1 of 2 approvals)
3. SideChainCreator refuses to approve (disagreement or strategic holdout)
4. Proposal cannot be released (requires 2 of 2 approvals)
5. Parliament attempts to change controller via `ChangeSideChainRentalController()`
6. Parliament approves controller change (1 of 2 approvals)
7. SideChainCreator refuses to approve controller change
8. Controller change fails

**Expected Result**: Rental fees should be updatable through some governance mechanism.

**Actual Result**: Rental fees remain at 100 tokens indefinitely. Side chains continue paying incorrect fees. No recovery mechanism exists.

**Success Condition for Exploit**: Any proposal to update rental fees or change the controller fails to achieve unanimous approval, proving permanent DOS of fee adjustment functionality.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L37-42)
```csharp
        if (State.SideChainCreator.Value == null || State.SideChainRentalController.Value != null) return new Empty();
        var sideChainRentalController = GetDefaultSideChainRentalController(defaultParliamentController);
        CreateAssociationControllerForSideChainRental(State.SideChainCreator.Value,
            defaultParliamentController.OwnerAddress);
        State.SideChainRentalController.Value = sideChainRentalController;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L53-59)
```csharp
    public override Empty ChangeSideChainRentalController(AuthorityInfo input)
    {
        AssertControllerForSideChainRental();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SideChainRentalController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L244-269)
```csharp
    private Association.CreateOrganizationBySystemContractInput GetControllerCreateInputForSideChainRental(
        Address sideChainCreator, Address parliamentAddress)
    {
        var proposers = new List<Address> { parliamentAddress, sideChainCreator };
        return new Association.CreateOrganizationBySystemContractInput
        {
            OrganizationCreationInput = new Association.CreateOrganizationInput
            {
                OrganizationMemberList = new OrganizationMemberList
                {
                    OrganizationMembers = { proposers }
                },
                ProposalReleaseThreshold = new ProposalReleaseThreshold
                {
                    MinimalApprovalThreshold = proposers.Count,
                    MinimalVoteThreshold = proposers.Count,
                    MaximalRejectionThreshold = 0,
                    MaximalAbstentionThreshold = 0
                },
                ProposerWhiteList = new ProposerWhiteList
                {
                    Proposers = { proposers }
                }
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L407-413)
```csharp
    private void AssertControllerForSideChainRental()
    {
        Assert(State.SideChainRentalController.Value != null,
            "controller does not initialize, call InitializeAuthorizedController first");
        // ReSharper disable once PossibleNullReferenceException
        Assert(State.SideChainRentalController.Value.OwnerAddress == Context.Sender, "no permission");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1061-1061)
```csharp
            var rental = duration.Mul(State.ResourceAmount[symbol]).Mul(State.Rental[symbol]);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1099-1112)
```csharp
    public override Empty UpdateRental(UpdateRentalInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.Rental)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.Rental[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L1114-1127)
```csharp
    public override Empty UpdateRentedResources(UpdateRentedResourcesInput input)
    {
        AssertControllerForSideChainRental();
        foreach (var pair in input.ResourceAmount)
        {
            Assert(
                Context.Variables.GetStringArray(TokenContractConstants.PayRentalSymbolListName).Contains(pair.Key),
                "Invalid symbol.");
            Assert(pair.Value >= 0, "Invalid amount.");
            State.ResourceAmount[pair.Key] = pair.Value;
        }

        return new Empty();
    }
```
