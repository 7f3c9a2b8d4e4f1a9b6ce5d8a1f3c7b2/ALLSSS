### Title
Unvalidated ActualMiningTime in UpdateValue Allows Timestamp Manipulation and Consensus Disruption

### Summary
The `UpdateValue` transaction does not validate that the `ActualMiningTime` parameter matches `Context.CurrentBlockTime`, allowing malicious miners to store arbitrary timestamps in the consensus state. This enables term change manipulation, timestamp monotonicity violations, and disruption of miner selection logic, all of which undermine consensus integrity.

### Finding Description

**Root Cause:**
The `ActualMiningTime` field extracted at [1](#0-0)  and stored by `ProcessUpdateValue` at [2](#0-1)  lacks validation that it matches the actual block timestamp (`Context.CurrentBlockTime`).

**Why Protections Fail:**

1. **Hash Validation Excludes ActualMiningTimes:** The `GetCheckableRound` method explicitly clears `ActualMiningTimes` before computing the hash [3](#0-2) , meaning `ValidateConsensusAfterExecution` [4](#0-3)  cannot detect timestamp manipulation.

2. **No Explicit Timestamp Validation:** Neither `UpdateValueValidationProvider` [5](#0-4)  nor any other validation provider checks that `ActualMiningTime` equals `Context.CurrentBlockTime`.

3. **System Transactions Are Unsigned:** Consensus transactions generated by [6](#0-5)  are system transactions without signatures, allowing miners to modify parameters before block inclusion.

**Execution Path:**
1. Node generates consensus extra data with `Context.CurrentBlockTime` added to `ActualMiningTimes` [7](#0-6) 
2. Malicious miner modifies `UpdateValueInput.ActualMiningTime` to arbitrary value
3. Block validation passes (timestamps excluded from hash comparison)
4. `ProcessUpdateValue` stores incorrect timestamp in persistent state
5. Manipulated timestamp affects subsequent consensus decisions

### Impact Explanation

**Consensus Integrity Compromise:**

1. **Term Change Manipulation:** The `NeedToChangeTerm` function relies on `ActualMiningTimes.Last()` [8](#0-7)  to determine when 2/3 of miners believe it's time to change terms. A malicious miner can:
   - Provide future timestamps to trigger premature term changes, disrupting election cycles
   - Provide past timestamps to delay term changes, extending their mining privileges

2. **Blockchain Start Timestamp Corruption:** In the first round, `ActualMiningTimes.FirstOrDefault()` sets the blockchain start timestamp [9](#0-8) , which is the foundation for all future term calculations. Corrupting this value affects the entire chain's timeline.

3. **Miner Selection Disruption:** Time slot calculations use `ActualMiningTimes.Last()` [10](#0-9)  to determine which miner should produce the next block, allowing manipulation of block production order.

4. **Timestamp Monotonicity Violation:** Miners can provide timestamps that go backward, violating the fundamental assumption that time progresses monotonically, breaking time-based invariants throughout the system.

**Severity:** Medium-to-High. While it requires miner privileges, the impact on consensus integrity, term management, and blockchain timeline is substantial.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an authorized miner in the current round's miner list
- Attacker controls their own node infrastructure
- Attacker can modify system transaction parameters before block production

**Attack Complexity:**
- Low complexity: Simply modify the `ActualMiningTime` field in the generated `UpdateValueInput` transaction
- No cryptographic bypasses required
- No need to compromise other miners

**Feasibility Conditions:**
- Miner rotation ensures multiple opportunities across different rounds
- System transactions lack signature verification, making modification trivial
- No runtime monitoring or anomaly detection for timestamp deviations

**Detection Constraints:**
- Post-exploitation detection would require analyzing stored `ActualMiningTimes` against block header timestamps
- No automated alerting mechanism exists
- Historical data analysis would reveal inconsistencies but cannot prevent the attack

**Probability:** Medium. Authorized miners have both capability and opportunity, though the attack requires deliberate malicious intent and would be detectable through off-chain analysis.

### Recommendation

**Code-Level Mitigation:**

Add explicit validation in `ProcessUpdateValue` to ensure `ActualMiningTime` matches `Context.CurrentBlockTime`: [11](#0-10) 

Insert before line 243:
```csharp
Assert(updateValueInput.ActualMiningTime == Context.CurrentBlockTime,
    "ActualMiningTime must match current block timestamp.");
```

Similarly for `ProcessTinyBlock`: [12](#0-11) 

Insert before line 304:
```csharp
Assert(tinyBlockInput.ActualMiningTime == Context.CurrentBlockTime,
    "ActualMiningTime must match current block timestamp.");
```

**Invariant Checks:**
- Add monotonicity check: new `ActualMiningTime` must be >= previous `ActualMiningTimes.Last()` if the list is non-empty
- Add bounds check: `ActualMiningTime` must be within expected time slot for the miner

**Test Cases:**
1. Test that `UpdateValue` rejects transactions where `ActualMiningTime != Context.CurrentBlockTime`
2. Test that providing past timestamps (violating monotonicity) is rejected
3. Test that term change logic remains correct with validated timestamps
4. Test that blockchain start timestamp cannot be manipulated in round 1

### Proof of Concept

**Required Initial State:**
- Blockchain initialized with AEDPoS consensus
- Attacker is an authorized miner in current round's miner list
- Attacker controls their block-producing node

**Attack Steps:**

1. **Normal Block Production Setup:**
   - Attacker's node receives mining trigger
   - Node generates consensus extra data with `ActualMiningTime = T_current` (current block time)
   - Node generates `UpdateValueInput` transaction with `ActualMiningTime = T_current`

2. **Transaction Manipulation:**
   - Before block finalization, attacker modifies `UpdateValueInput.ActualMiningTime = T_malicious` where:
     - For term manipulation: `T_malicious` is far in future (trigger early term change)
     - For monotonicity violation: `T_malicious < previous ActualMiningTimes.Last()`
     - For start timestamp corruption (round 1): `T_malicious` set to arbitrary past/future value

3. **Block Submission:**
   - Block header contains `Time = T_current`
   - Block body contains modified `UpdateValue` transaction with `ActualMiningTime = T_malicious`
   - Consensus extra data contains round information with original timestamps

4. **Validation Bypass:**
   - `ValidateBeforeExecution` passes (time slot checks don't validate ActualMiningTime)
   - Block executes: `ProcessUpdateValue` stores `T_malicious` in state
   - `ValidateAfterExecution` passes (hash comparison excludes ActualMiningTimes)

**Expected vs Actual Result:**
- **Expected:** `ActualMiningTime` should equal `Context.CurrentBlockTime` (T_current)
- **Actual:** `ActualMiningTime` is set to `T_malicious`, corrupting consensus state

**Success Condition:**
Query `GetCurrentRoundInformation` for the attacker's miner entry and observe that `ActualMiningTimes.Last() == T_malicious != T_current`, confirming the timestamp manipulation was successfully stored in persistent state.

### Notes

This vulnerability exploits the gap between consensus extra data validation (which uses hash comparison but excludes `ActualMiningTimes`) and transaction parameter validation (which lacks timestamp verification). The design assumption that system transactions faithfully reflect block timestamps is violated when miners can modify unsigned consensus transactions. The clearing of `ActualMiningTimes` in the hash calculation [13](#0-12)  was likely intended to allow flexibility in block production timing, but inadvertently creates an attack surface for timestamp manipulation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L42-42)
```csharp
            ActualMiningTime = minerInRound.ActualMiningTimes.Last(),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L120-123)
```csharp
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-243)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-304)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L218-223)
```csharp
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L216-243)
```csharp
    public async Task<List<Transaction>> GenerateConsensusTransactionsAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus system txs: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var generatedTransactions =
            (await _contractReaderFactory
                .Create(contractReaderContext)
                .GenerateConsensusTransactions
                .CallAsync(_triggerInformationProvider.GetTriggerInformationForConsensusTransactions(
                    chainContext, _consensusCommand.ToBytesValue())))
            .Transactions
            .ToList();

        // Complete these transactions.
        foreach (var generatedTransaction in generatedTransactions)
        {
            generatedTransaction.RefBlockNumber = chainContext.BlockHeight;
            generatedTransaction.RefBlockPrefix =
                BlockHelper.GetRefBlockPrefix(chainContext.BlockHash);
            Logger.LogDebug($"Consensus transaction generated: \n{generatedTransaction.GetHash()}");
        }

        return generatedTransactions;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L202-208)
```csharp
                var latestMinedSlotLastActualMiningTime = latestMinedInfo.ActualMiningTimes.Last();
                var latestMinedOrder = latestMinedInfo.Order;
                var currentMinerOrder =
                    currentRound.RealTimeMinersInformation.Single(i => i.Key == pubkey).Value.Order;
                var passedSlotsCount =
                    (Context.CurrentBlockTime - latestMinedSlotLastActualMiningTime).Milliseconds()
                    .Div(miningInterval);
```
