### Title
Vote Counting Inconsistency Allows Governance Bypass via Strategic Member Removal

### Summary
The `CheckEnoughVoteAndApprovals` function in the Association contract contains a critical inconsistency in vote counting logic. While approval, rejection, and abstention counts correctly filter by current organization membership, the total vote threshold check counts ALL votes including those from removed members. This allows attackers to manipulate vote counting by removing dissenting voters after they vote, enabling malicious proposals to pass that should be rejected.

### Finding Description

The vulnerability exists in the vote counting logic within the `CheckEnoughVoteAndApprovals` helper function. [1](#0-0) 

The function correctly filters votes by current membership for three checks:
- Approval counting filters by membership [2](#0-1) 
- Rejection counting filters by membership [3](#0-2) 
- Abstention counting filters by membership [4](#0-3) 

However, the MinimalVoteThreshold check counts ALL votes without filtering: [5](#0-4) 

This inconsistency is exploitable because organizations can remove members at any time via the `RemoveMember` function, which is callable by the organization itself through proposal execution. [6](#0-5) 

The `IsReleaseThresholdReached` function calls this vulnerable logic to determine if a proposal can be released. [7](#0-6) 

### Impact Explanation

**Governance Integrity Violation:** This vulnerability allows complete bypass of proposal rejection mechanisms. Removed members' votes artificially inflate the participation count while their rejections/abstentions are ignored, enabling proposals that should fail to pass.

**Concrete Attack Impact:**
- **Unauthorized Proposal Execution:** Malicious proposals can be passed despite legitimate rejection by organization members
- **Vote Manipulation:** Attackers can neutralize dissenting votes by strategically removing members post-vote
- **False Participation Metrics:** The system reports higher participation than actually occurred among current members
- **Governance Capture:** Once an attacker achieves initial control (via a single passed proposal to remove dissenters), they can maintain control indefinitely

**Affected Parties:**
- All Association-governed organizations (multi-signature wallets, DAOs, committee-based governance)
- Cross-chain governance if Association contracts are used for critical decisions
- Treasury and fund management controlled by Association organizations
- Configuration changes and system upgrades governed by Association contracts

**Severity:** CRITICAL - This directly undermines the fundamental trust model of multi-signature governance, allowing minority control over majority-disagreed proposals.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of enough members to meet MinimalApprovalThreshold (realistic for coordinated attackers or insiders)
- Ability to create proposals (must be in ProposerWhiteList, but this is common for organization members)
- Ability to execute RemoveMember (requires passing a prior proposal, but once achieved, enables persistent control)

**Attack Complexity:** MEDIUM
1. Initial proposal to remove dissenting members requires meeting approval threshold
2. Once dissenters are removed, subsequent malicious proposals become trivial to pass
3. All steps use standard contract functions with no special permissions required beyond organization membership

**Feasibility Conditions:**
- Organization exists with realistic thresholds (e.g., MinimalApprovalThreshold=5, MinimalVoteThreshold=8 in a 10-member organization)
- Members can be added/removed via proposals (standard functionality, not disabled)
- Attack requires coordination of ~50% of initial members to pass first member removal proposal

**Detection Constraints:**
- Attack uses legitimate contract functions (RemoveMember, voting, Release)
- No on-chain detection mechanisms exist for this pattern
- Appears as normal governance activity until malicious proposal executes

**Economic Rationality:**
- Cost: Gas fees for member removal proposals and voting (minimal)
- Benefit: Complete governance control, access to treasury funds, ability to execute arbitrary contract calls
- Risk/Reward: Extremely favorable for high-value organizations

**Probability Assessment:** HIGH for organizations where:
- Treasury or controlled assets are valuable (>$100K)
- Member collusion is possible (insider threats, coordinated attacks)
- Initial governance capture can occur through social engineering or vote buying

### Recommendation

**Immediate Fix:**
Modify the vote threshold check to filter by current membership, maintaining consistency with other vote counting logic:

```csharp
// In CheckEnoughVoteAndApprovals, replace lines 55-57 with:
var currentMemberVotes = proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections)
    .Count(organization.OrganizationMemberList.Contains);
var isVoteThresholdReached = currentMemberVotes >= organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

This ensures only votes from current members count toward the MinimalVoteThreshold, matching the behavior of approval/rejection/abstention checks.

**Additional Safeguards:**
1. **Snapshot-based Voting:** Record organization membership at proposal creation time and use that snapshot for all threshold checks
2. **Member Removal Cooldown:** Prevent member removal while active proposals exist from those members
3. **Vote Invalidation:** Automatically invalidate votes from removed members and recalculate proposal status
4. **Threshold Recalculation:** When members are removed, recalculate all active proposal thresholds based on new membership count

**Test Cases to Add:**
1. Test: Create proposal → Members vote → Remove voting members → Verify proposal fails release
2. Test: Create proposal → Members approve → Remove abstaining members → Verify vote threshold still requires current member votes only
3. Test: Create proposal → Members reject → Remove rejecting members → Verify their rejections still count
4. Test: Edge case with MinimalVoteThreshold = organization member count

### Proof of Concept

**Initial State:**
- Organization with 10 members: M1, M2, M3, M4, M5, M6, M7, M8, M9, M10
- Thresholds: MinimalApprovalThreshold=5, MinimalVoteThreshold=8, MaximalRejectionThreshold=2, MaximalAbstentionThreshold=2
- M1 is in ProposerWhiteList

**Attack Sequence:**

1. **Create Malicious Proposal:** M1 creates proposal P1 (e.g., transfer all treasury funds to M1)

2. **Initial Voting Round:**
   - M1, M2, M3, M4 call `Approve(P1)` → 4 approvals
   - M5, M6, M7 call `Reject(P1)` → 3 rejections
   - Current state: 4 approvals, 3 rejections, 7 total votes
   - Release check FAILS:
     - Approvals: 4 < 5 (MinimalApprovalThreshold) ❌
     - Rejections: 3 > 2 (MaximalRejectionThreshold) ❌
     - Total votes: 7 < 8 (MinimalVoteThreshold) ❌

3. **Strategic Member Removal:**
   - M1 creates proposal P2: `RemoveMember(M5)`
   - M1, M2, M3, M4, M8 vote Approve on P2 (5 approvals from current 10 members)
   - M1 calls `Release(P2)` → M5 removed successfully
   - Repeat for M6 and M7
   - Organization now has 7 members: M1-M4, M8-M10

4. **Complete Attack:**
   - M8 calls `Approve(P1)` → 5th approval from current members
   - M1 calls `Release(P1)`
   
5. **Expected vs Actual Result:**
   - **Expected:** Release fails (only 5 current members voted, need 8)
   - **Actual:** Release SUCCEEDS with following checks:
     - `IsProposalRejected`: `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` = 0 (M5-M7 not in list) → NOT rejected ✓
     - `IsProposalAbstained`: 0 abstentions → NOT abstained ✓
     - Approval check: 5 current member approvals ≥ 5 → Approved ✓
     - **Vote threshold:** `proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count()` = 0 + 5 + 3 = **8** → Threshold met ✓
     - Result: P1 executes, treasury funds transferred to M1

**Success Condition:** Malicious proposal P1 executes despite only 5 out of 7 current members approving (71% vs required participation of 8 votes), with 3 rejection votes incorrectly counted toward participation but not toward rejection limit.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L43-43)
```csharp
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-280)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```
