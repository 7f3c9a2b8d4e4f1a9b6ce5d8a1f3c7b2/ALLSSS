### Title
Null Reference Exception in GetElectionResult Due to Missing Snapshot Validation

### Summary
The `GetElectionResult` view method in the Election contract directly accesses properties of a `VotingResult` object without validating that it's not null. When querying for a non-existent term number (e.g., a future term), the underlying `GetVotingResult` call returns null, causing a NullReferenceException that makes the view method unusable.

### Finding Description

The vulnerability exists in the interaction between the Election contract's `GetElectionResult` method and the Vote contract's `GetVotingResult` method. [1](#0-0) 

The `GetVotingResult` method computes a hash from the voting item ID and snapshot number, then directly returns the state lookup result, which can be null if the snapshot doesn't exist. [2](#0-1) 

The `GetElectionResult` method calls `GetVotingResult` with the input term number as the snapshot number, then directly accesses `votingResult.Results` on line 114 without any null check. When the term number doesn't exist (hasn't occurred yet or is invalid), `votingResult` will be null, causing a NullReferenceException.

**Snapshot Creation Flow:** [3](#0-2) 

Initial snapshot 1 is created during voting item registration. [4](#0-3) 

Subsequent snapshots are created during term transitions when the consensus contract calls `TakeSnapshot`. [5](#0-4) 

The snapshot number corresponds to the term number. If a user queries for a term that hasn't occurred yet (e.g., current term is 50 but query is for term 100), no snapshot exists and null is returned.

### Impact Explanation

**Operational Impact - DoS of Election Results Query:** [6](#0-5) 

`GetElectionResult` is a public view method (marked with `is_view = true`) that anyone can call. When called with a non-existent term number, it crashes with a NullReferenceException, making it impossible to retrieve election results through normal contract queries.

This affects:
- Any frontend/UI attempting to display election results for validation
- Block explorers and analytics tools querying historical or future election data
- Off-chain systems monitoring election state

While this is a view method and doesn't affect on-chain state, it degrades the usability and reliability of the election system's query interface. Users cannot distinguish between "term hasn't occurred yet" and "query is broken" without examining transaction errors.

### Likelihood Explanation

**High Likelihood - Simple and Unrestricted:**

The attack requires no special permissions or setup:
1. Anyone can call `GetElectionResult` (it's a public view method)
2. The attacker simply provides a term number greater than the current term number
3. No economic cost - view methods don't consume transaction fees in the same way

**Execution Steps:**
1. Query current term number via other view methods
2. Call `GetElectionResult` with `TermNumber = CurrentTerm + 1` (or any higher value)
3. Method crashes with NullReferenceException

The vulnerability is trivially exploitable and can occur through legitimate usage patterns (e.g., a UI with a dropdown allowing users to select any term number without validating against current term).

### Recommendation

**Add null validation in GetElectionResult:**

```csharp
public override ElectionResult GetElectionResult(GetElectionResultInput input)
{
    var votingResult = State.VoteContract.GetVotingResult.Call(new GetVotingResultInput
    {
        VotingItemId = State.MinerElectionVotingItemId.Value,
        SnapshotNumber = input.TermNumber
    });
    
    Assert(votingResult != null, $"Voting result not found for term {input.TermNumber}.");
    
    var result = new ElectionResult
    {
        TermNumber = input.TermNumber,
        IsActive = input.TermNumber == State.CurrentTermNumber.Value,
        Results = { votingResult.Results }
    };
    
    return result;
}
```

**Alternative - Fix at Vote contract level to match other view methods:** [7](#0-6) 

Follow the pattern used in `GetVotingRecord` which validates and throws a descriptive error:

```csharp
public override VotingResult GetVotingResult(GetVotingResultInput input)
{
    var votingResultHash = new VotingResult
    {
        VotingItemId = input.VotingItemId,
        SnapshotNumber = input.SnapshotNumber
    }.GetHash();
    var votingResult = State.VotingResults[votingResultHash];
    Assert(votingResult != null, "Voting result not found for the specified snapshot.");
    return votingResult;
}
```

**Add test cases:**
- Test `GetElectionResult` with term number 0
- Test with term number greater than current term
- Test with term number far in the future (e.g., CurrentTerm + 1000)
- Verify proper error messages are returned

### Proof of Concept

**Initial State:**
- Election contract initialized with term 1
- System has progressed through terms 1, 2, and 3 (current term = 3)
- Snapshots exist for terms 1, 2, and 3

**Exploitation Steps:**

1. Query current term number (returns 3)
2. Call `GetElectionResult` with input:
   ```
   GetElectionResultInput {
       TermNumber = 100
   }
   ```

**Expected Result:**
Should return an error message like "Voting result not found for term 100" or "Invalid term number"

**Actual Result:**
NullReferenceException when trying to access `votingResult.Results` because `votingResult` is null (snapshot 100 doesn't exist). The view method call fails without a descriptive error message.

**Success Condition:**
The exploit succeeds when the contract throws a NullReferenceException instead of returning a proper error message, rendering the `GetElectionResult` view method unusable for non-existent term numbers.

### Citations

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L20-25)
```csharp
    public override VotingRecord GetVotingRecord(Hash input)
    {
        var votingRecord = State.VotingRecords[input];
        Assert(votingRecord != null, "Voting record not found.");
        return votingRecord;
    }
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L34-42)
```csharp
    public override VotingResult GetVotingResult(GetVotingResultInput input)
    {
        var votingResultHash = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = input.SnapshotNumber
        }.GetHash();
        return State.VotingResults[votingResultHash];
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L102-117)
```csharp
    public override ElectionResult GetElectionResult(GetElectionResultInput input)
    {
        var votingResult = State.VoteContract.GetVotingResult.Call(new GetVotingResultInput
        {
            VotingItemId = State.MinerElectionVotingItemId.Value,
            SnapshotNumber = input.TermNumber
        });

        var result = new ElectionResult
        {
            TermNumber = input.TermNumber,
            IsActive = input.TermNumber == State.CurrentTermNumber.Value,
            Results = { votingResult.Results }
        };

        return result;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L54-63)
```csharp
        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L422-426)
```csharp
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** protobuf/election_contract.proto (L137-140)
```text
    // Get the election result according to term id.
    rpc GetElectionResult (GetElectionResultInput) returns (ElectionResult) {
        option (aelf.is_view) = true;
    }
```
