### Title
Association Contract Member List Manipulation Allows Retroactive Vote Invalidation

### Summary
The Association contract's vote counting mechanism uses the current organization member list rather than a snapshot from proposal creation time, allowing votes cast by members to be retroactively invalidated by removing those members before proposal release. This breaks the fundamental governance invariant that votes should be immutable once cast and enables manipulation of proposal outcomes.

### Finding Description

The Association contract stores votes as address lists in the `ProposalInfo` structure but counts votes by filtering against the **current** organization member list at release time, not the member list at voting time.

**Vote Storage During Voting:**
When members vote on a proposal, their addresses are added to `proposal.Approvals`, `proposal.Rejections`, or `proposal.Abstentions` lists. The voting methods check if the voter is a current member at voting time. [1](#0-0) 

**Vote Counting at Release:**
When determining if a proposal can be released, the contract counts votes by filtering stored addresses against the **current** member list: [2](#0-1) 

Specifically:
- Rejection counting: `proposal.Rejections.Count(organization.OrganizationMemberList.Contains)` (line 37)
- Abstention counting: `proposal.Abstentions.Count(organization.OrganizationMemberList.Contains)` (line 43)
- Approval counting: `proposal.Approvals.Count(organization.OrganizationMemberList.Contains)` (line 49)

**Member List Modification:**
The organization can modify its member list through three methods that only the organization address itself can call: [3](#0-2) 

**Root Cause:**
The contract does not snapshot the organization member list at proposal creation time. The proposal only stores a reference to the organization address, and vote counting dynamically queries the current member list. [4](#0-3) 

**No Protection Exists:**
There is no mechanism to preserve member list state at proposal creation time or protect against retroactive vote invalidation.

### Impact Explanation

**Governance Integrity Violation:**
This vulnerability fundamentally breaks the governance system's trustworthiness by allowing retroactive manipulation of vote counts after votes have been cast.

**Concrete Attack Scenarios:**

1. **Denial of Legitimate Proposals:**
   - Organization with members [A, B, C, D] requires 3 approvals
   - Proposal X receives approvals from A, B, C (threshold met)
   - Before release, organization passes another proposal removing members A and B
   - Proposal X now counts only C's approval (1 vote), failing to meet threshold
   - Legitimate proposal blocked despite proper approval

2. **Enabling Rejected Proposals:**
   - Organization with max rejection threshold of 1
   - Proposal Y receives rejection from member A
   - Organization removes member A
   - Proposal Y now has 0 counted rejections, can potentially pass

3. **Strategic Member Manipulation:**
   - Malicious organization controller strategically adds/removes members between voting and release to achieve desired outcomes
   - Can target specific proposals for approval or rejection by manipulating voter eligibility

**Severity Justification:**
- **Critical** because it violates the core governance invariant that votes are immutable
- Affects any association-based governance decisions including contract upgrades, treasury management, and system parameter changes
- Undermines user trust in the governance system
- Can result in unauthorized actions being executed or legitimate actions being blocked

### Likelihood Explanation

**Attacker Capabilities:**
The attacker must control an existing association organization, which requires either:
1. Being the original creator with sufficient member support, or
2. Gaining control through legitimate governance processes

Once in control, the attacker can propose and pass member list modifications.

**Attack Complexity:**
Low to Medium:
1. Create or control an association organization
2. Create a target proposal requiring member votes
3. Wait for voting to occur
4. Create and pass a proposal to modify the member list (removing approvers or adding/removing rejectors)
5. Attempt to release the original proposal with manipulated vote counts

**Feasibility Conditions:**
- The organization must have enough compliant members to pass the member modification proposal
- Time window exists between voting completion and proposal release
- No external monitoring prevents suspicious member list changes

**Operational Constraints:**
- Member list changes fire events (`MemberAdded`, `MemberRemoved`, `MemberChanged`) that may be monitored [5](#0-4) 
- However, events alone do not prevent the attack

**Probability:**
High for organizations with centralized control or insufficient member vigilance. The test suite confirms this behavior is inherent to the design. [6](#0-5) 

### Recommendation

**Immediate Fix:**
Snapshot the organization member list at proposal creation time and store it in the `ProposalInfo` structure:

1. Add a new field to `ProposalInfo` in the protobuf definition:
   ```
   OrganizationMemberList organization_member_list_snapshot = [next_field_number];
   ```

2. Modify `CreateNewProposal` to capture the member list snapshot: [4](#0-3) 
   Add after line 155:
   ```
   OrganizationMemberListSnapshot = organization.OrganizationMemberList
   ```

3. Modify vote counting methods to use the snapshot instead of current member list: [2](#0-1) 
   Change `organization.OrganizationMemberList` to `proposal.OrganizationMemberListSnapshot`

4. Ensure voting authorization still checks current membership (to prevent non-members from voting even if added later): [7](#0-6) 

**Invariant to Enforce:**
- Vote counts for a proposal must be calculated based on the member list at proposal creation time
- Member list modifications must not affect vote counting for existing proposals

**Test Cases:**
1. Create proposal, have members vote, remove voting members, verify votes still count
2. Create proposal, have members vote, add new members, verify new members cannot vote on existing proposal
3. Create proposal, remove members who haven't voted, verify threshold calculations remain valid

### Proof of Concept

**Initial State:**
- Create association organization with members: [Alice, Bob, Carol, Dave]
- Set threshold: MinimalApprovalThreshold = 3, MinimalVoteThreshold = 3

**Attack Sequence:**

1. **Create Target Proposal:**
   ```
   Proposer (Alice) creates Proposal_X to transfer 1000 ELF from organization treasury
   ```

2. **Voting Phase:**
   ```
   Alice calls Approve(Proposal_X) → proposal.Approvals = [Alice]
   Bob calls Approve(Proposal_X) → proposal.Approvals = [Alice, Bob]
   Carol calls Approve(Proposal_X) → proposal.Approvals = [Alice, Bob, Carol]
   ```
   At this point, Proposal_X has 3 approvals and should be releasable.

3. **Member Manipulation:**
   ```
   Create Proposal_Y to RemoveMember(Alice)
   All members approve Proposal_Y
   Release Proposal_Y → Organization members now [Bob, Carol, Dave]
   ```

4. **Attempt Release of Original Proposal:**
   ```
   Try to Release(Proposal_X)
   Vote counting: proposal.Approvals.Count(organization.OrganizationMemberList.Contains)
   Counts: Bob ✓, Carol ✓, Alice ✗ (removed) = 2 approvals
   Result: Release fails with "Not approved" error
   ```

**Expected vs Actual Result:**
- **Expected:** Proposal_X should be releasable since it received 3 valid approvals when all voters were members
- **Actual:** Proposal_X cannot be released because Alice's vote no longer counts after removal

**Success Condition:**
The attack succeeds when a proposal that legitimately met approval thresholds becomes unreleasable due to retroactive member list manipulation, or vice versa (rejected proposals becoming releasable).

### Notes

The vulnerability affects the Association contract specifically. The Parliament contract may have similar issues if miner lists can change between voting and release. This pattern should be audited across all ACS3-compliant governance contracts. The member addition scenario (allowing non-members at creation time to vote) is partially mitigated by the authorization check during voting, but the vote invalidation scenario remains a critical vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association.cs (L123-141)
```csharp
    public override Empty Approve(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Approvals.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Approve),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L233-280)
```csharp
    public override Empty AddMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberAdded
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }

    public override Empty ChangeMember(ChangeMemberInput input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input.OldMember);
        Assert(removeResult, "Remove member failed.");
        organization.OrganizationMemberList.OrganizationMembers.Add(input.NewMember);
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberChanged
        {
            OrganizationAddress = Context.Sender,
            OldMember = input.OldMember,
            NewMember = input.NewMember
        });
        return new Empty();
    }

    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-59)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }

    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L145-173)
```csharp
    private Hash CreateNewProposal(CreateProposalInput input)
    {
        CheckCreateProposalInput(input);
        var proposalId = GenerateProposalId(input);
        var proposal = new ProposalInfo
        {
            ContractMethodName = input.ContractMethodName,
            ExpiredTime = input.ExpiredTime,
            Params = input.Params,
            ToAddress = input.ToAddress,
            OrganizationAddress = input.OrganizationAddress,
            ProposalId = proposalId,
            Proposer = Context.Sender,
            ProposalDescriptionUrl = input.ProposalDescriptionUrl,
            Title = input.Title,
            Description = input.Description
        };
        Assert(Validate(proposal), "Invalid proposal.");
        Assert(State.Proposals[proposalId] == null, "Proposal already exists.");
        State.Proposals[proposalId] = proposal;
        Context.Fire(new ProposalCreated
        {
            ProposalId = proposalId,
            OrganizationAddress = input.OrganizationAddress,
            Title = input.Title,
            Description = input.Description
        });
        return proposalId;
    }
```

**File:** test/AElf.Contracts.Association.Tests/AssociationContractTests.cs (L740-786)
```csharp
    public async Task Change_OrganizationThreshold_Test()
    {
        var minimalApproveThreshold = 1;
        var minimalVoteThreshold = 1;
        var maximalAbstentionThreshold = 1;
        var maximalRejectionThreshold = 1;
        var organizationAddress = await CreateOrganizationAsync(minimalApproveThreshold, minimalVoteThreshold,
            maximalAbstentionThreshold, maximalRejectionThreshold, Reviewer1);
        var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress);
        await ApproveAsync(Reviewer1KeyPair, proposalId);
        var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
        proposal.ToBeReleased.ShouldBeTrue();


        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendWithExceptionAsync(changeProposalId);
            result.TransactionResult.Error.ShouldContain("Invalid organization.");
        }

        {
            var proposalReleaseThresholdInput = new ProposalReleaseThreshold
            {
                MinimalVoteThreshold = 2,
                MinimalApprovalThreshold = minimalApproveThreshold
            };

            var associationContractStub = GetAssociationContractTester(Reviewer1KeyPair);
            var changeProposalId = await CreateAssociationProposalAsync(Reviewer1KeyPair,
                proposalReleaseThresholdInput,
                nameof(associationContractStub.ChangeOrganizationThreshold), organizationAddress);
            await ApproveAsync(Reviewer1KeyPair, changeProposalId);
            var result = await associationContractStub.Release.SendAsync(changeProposalId);
            result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);

            proposal = await associationContractStub.GetProposal.CallAsync(proposalId);
            proposal.ToBeReleased.ShouldBeFalse();
        }
```
