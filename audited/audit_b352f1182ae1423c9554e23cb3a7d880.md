# Audit Report

## Title
Specific Delegation Permanently Shadows General Delegation After Delegatee Removal

## Summary
The transaction fee delegation system fails to properly fall back from specific delegation to general delegation when all delegatees are removed. An empty `TransactionFeeDelegatees` object (not null) is stored in state after removal, preventing the null coalescing operator from triggering the fallback to general delegation. This causes permanent DoS of transaction fee delegation for specific contract methods even when valid general delegations exist.

## Finding Description

The vulnerability exists in the delegation state management and fallback logic within the MultiToken contract's transaction fee delegation system.

**Root Cause - Unconditional Storage of Empty Objects:**

In `SetTransactionFeeDelegateInfos`, when a delegatee is removed due to empty delegations, the code removes the delegatee from the `Delegatees` dictionary but then unconditionally stores the parent `existDelegateeInfoList` object back to state. If this was the last delegatee, an empty `TransactionFeeDelegatees` object with an empty `Delegatees` dictionary is persisted. [1](#0-0) 

The same issue occurs in the removal helper method where the empty `delegateeInfo` is stored back to state after removing the last delegatee: [2](#0-1) 

**Broken Fallback Logic:**

The fee charging logic uses the null coalescing operator with the `?.Delegatees` accessor to fall back from specific to general delegation: [3](#0-2) 

The critical flaw: When `TransactionFeeDelegateInfoMap` returns an empty `TransactionFeeDelegatees` object, `?.Delegatees` returns an empty dictionary (not null). The `??` operator only checks for null, so it returns the empty dictionary instead of falling back to the general delegation map. The subsequent foreach loop finds no entries and returns false without ever consulting the general delegation.

The same broken pattern exists in the second delegation check: [4](#0-3) 

**Execution Flow:**

1. User establishes general delegation via `SetTransactionFeeDelegations`
2. User creates specific delegation for a contract method via `SetTransactionFeeDelegateInfos`
3. User removes all delegatees from specific delegation (via `SetTransactionFeeDelegateInfos` or `RemoveTransactionFeeDelegateeInfos`)
4. Empty `TransactionFeeDelegatees` object stored in `TransactionFeeDelegateInfoMap[delegator][contract][method]`
5. Future transactions fail to charge from delegation because:
   - Specific delegation returns empty object (not null)
   - `?.Delegatees` returns empty dictionary (not null)
   - `??` operator doesn't trigger fallback
   - General delegation never consulted
   - Transaction fee charging fails

## Impact Explanation

**Severity: Medium/High - Permanent DoS of Transaction Fee Delegation**

This vulnerability creates a permanent denial-of-service condition for the transaction fee delegation feature:

1. **Transaction Failure:** Users who rely on delegation to pay transaction fees will be unable to execute transactions for specific contract methods, even when they have valid general delegations with sufficient funds.

2. **Permanent State Corruption:** Once an empty `TransactionFeeDelegatees` object is stored for a specific contract/method combination, that path is permanently "poisoned." The empty object persists in state and blocks all future fallback attempts to general delegation.

3. **No Recovery Path:** Users cannot recover from this state without a contract upgrade. Simply setting up new general or specific delegations won't fix the issue because the empty object will continue to shadow the general delegation.

4. **Protocol Reliability Impact:** This breaks the expected delegation hierarchy where specific delegations should only override general delegations when they contain valid delegatees. Empty specific delegations should allow fallback to general delegation.

**Affected Users:**
- Any user who has established a general delegation via `SetTransactionFeeDelegations`
- Who later creates specific delegations via `SetTransactionFeeDelegateInfos` for certain contract methods
- And then removes all delegatees from those specific delegations

While this doesn't directly lead to fund theft, it creates a permanent availability issue for critical protocol functionality (transaction fee payment).

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability can be triggered through normal, legitimate delegation management operations without any malicious intent:

**Accessible Entry Points:**
- `SetTransactionFeeDelegateInfos` - Public method for creating/updating specific delegations
- `RemoveTransactionFeeDelegateeInfos` - Public method for removing specific delegations
- `RemoveTransactionFeeDelegatorInfos` - Public method for delegatees to remove themselves

**Realistic Scenarios:**
1. A user tests specific delegations for a new dApp and later removes them, expecting fallback to general delegation
2. A delegatee becomes unavailable and the user removes them, intending to rely on general delegation temporarily
3. Users clean up old specific delegations thinking they're optimizing their delegation setup
4. Multiple delegatees are removed one by one until none remain

**No Special Requirements:**
- No privileged access required
- No attack cost
- No complex preconditions
- Purely a consequence of normal state management

**High Probability:** Users naturally create and remove delegations as they:
- Test different delegation configurations
- Manage their delegatee relationships
- Respond to delegatee availability changes
- Clean up unused delegations

The vulnerability is particularly insidious because users expect the system to fall back to general delegation when specific delegations are empty, which is the natural and intuitive behavior.

## Recommendation

**Solution: Check for empty delegatees and delete the entry from state instead of storing an empty object.**

For `SetTransactionFeeDelegateInfos`, after removing the delegatee, check if the entire `Delegatees` dictionary is empty and delete the state entry:

```csharp
if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
    !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
{
    existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
    toCancelTransactionList.Value.Add(new DelegateTransaction
    {
        ContractAddress = delegateInfo.ContractAddress,
        MethodName = delegateInfo.MethodName
    });
}

// NEW: Only store if there are remaining delegatees, otherwise delete the entry
if (existDelegateeInfoList.Delegatees.Count > 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = existDelegateeInfoList;
}
else
{
    // Delete the entry to allow fallback to general delegation
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
        [delegateInfo.MethodName] = null;
}
```

Apply the same fix to `RemoveTransactionFeeDelegateInfo`:

```csharp
var delegateeInfo =
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
        delegateTransaction.MethodName];
if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
delegateeInfo.Delegatees.Remove(delegateeAddress);
toCancelTransactionList.Value.Add(delegateTransaction);

// NEW: Only store if there are remaining delegatees
if (delegateeInfo.Delegatees.Count > 0)
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
        delegateTransaction.MethodName] = delegateeInfo;
}
else
{
    State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
        delegateTransaction.MethodName] = null;
}
```

This ensures that when all delegatees are removed, the state entry becomes null, allowing the `??` operator to properly fall back to general delegation.

## Proof of Concept

```csharp
[Fact]
public async Task SpecificDelegation_BlocksGeneralDelegation_AfterRemoval_Test()
{
    await Initialize();
    
    // Step 1: User1 sets up GENERAL delegation with DefaultAddress as delegatee
    var generalDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 10000
    };
    await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
        new SetTransactionFeeDelegationsInput
        {
            DelegatorAddress = User1Address,
            Delegations = { generalDelegations }
        });
    
    // Verify general delegation exists
    var generalDelegatees = await TokenContractStub.GetTransactionFeeDelegatees.CallAsync(
        new GetTransactionFeeDelegateesInput { DelegatorAddress = User1Address });
    generalDelegatees.DelegateeAddresses.Count.ShouldBe(1);
    
    // Step 2: User1 sets up SPECIFIC delegation for a contract method
    var specificDelegations = new Dictionary<string, long>
    {
        [NativeToken] = 5000
    };
    var delegateInfo = new DelegateInfo
    {
        ContractAddress = BasicFunctionContractAddress,
        MethodName = "TestMethod",
        Delegations = { specificDelegations },
        IsUnlimitedDelegate = false
    };
    await TokenContractStub.SetTransactionFeeDelegateInfos.SendAsync(
        new SetTransactionFeeDelegateInfosInput
        {
            DelegatorAddress = User1Address,
            DelegateInfoList = { delegateInfo }
        });
    
    // Verify specific delegation exists
    var specificDelegatees = await TokenContractStub.GetTransactionFeeDelegateeList.CallAsync(
        new GetTransactionFeeDelegateeListInput
        {
            DelegatorAddress = User1Address,
            ContractAddress = BasicFunctionContractAddress,
            MethodName = "TestMethod"
        });
    specificDelegatees.DelegateeAddresses.Count.ShouldBe(1);
    
    // Step 3: User1 removes the specific delegation (removes last delegatee)
    await TokenContractStub.RemoveTransactionFeeDelegateeInfos.SendAsync(
        new RemoveTransactionFeeDelegateeInfosInput
        {
            DelegateeAddress = DefaultAddress,
            DelegateTransactionList =
            {
                new DelegateTransaction
                {
                    ContractAddress = BasicFunctionContractAddress,
                    MethodName = "TestMethod"
                }
            }
        });
    
    // Verify specific delegation is now empty
    var emptySpecificDelegatees = await TokenContractStub.GetTransactionFeeDelegateeList.CallAsync(
        new GetTransactionFeeDelegateeListInput
        {
            DelegatorAddress = User1Address,
            ContractAddress = BasicFunctionContractAddress,
            MethodName = "TestMethod"
        });
    emptySpecificDelegatees.DelegateeAddresses.Count.ShouldBe(0);
    
    // VULNERABILITY: General delegation should now be used for this method
    // but the empty specific delegation object blocks the fallback
    // When trying to charge transaction fees, it will fail even though
    // general delegation with sufficient funds exists
    
    // The fee charging logic will:
    // 1. Check TransactionFeeDelegateInfoMap[User1][BasicFunctionContract]["TestMethod"]
    // 2. Get an empty TransactionFeeDelegatees object (NOT null)
    // 3. Access .Delegatees which returns empty dictionary (NOT null)
    // 4. The ?? operator won't trigger
    // 5. The foreach loop finds no entries
    // 6. General delegation is never consulted
    // 7. Transaction fee charging fails despite valid general delegation
}
```

This test demonstrates that after removing all delegatees from a specific delegation, the general delegation is no longer accessible for that contract/method combination, creating a permanent DoS condition.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L214-245)
```csharp
            var existDelegateeInfoList =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                    [delegateInfo.MethodName] ?? new TransactionFeeDelegatees();
            var delegateeAddress = Context.Sender.ToBase58();
            var existDelegateeList = existDelegateeInfoList.Delegatees;
            //If the transaction contains delegatee,update delegate info.
            if (existDelegateeList.TryGetValue(delegateeAddress, out var value))
            {
                toUpdateTransactionList.Value.Add(UpdateDelegateInfo(value, delegateInfo));
            } //else,add new delegate info.
            else
            {
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
                existDelegateeList.Add(delegateeAddress, new TransactionFeeDelegations());
                var transactionFeeDelegations = existDelegateeList[delegateeAddress];
                toAddTransactionList.Value.Add(AddDelegateInfo(transactionFeeDelegations, delegateInfo));
            }

            if (existDelegateeInfoList.Delegatees[delegateeAddress].Delegations.Count == 0 &&
                !existDelegateeInfoList.Delegatees[delegateeAddress].IsUnlimitedDelegate)
            {
                existDelegateeInfoList.Delegatees.Remove(delegateeAddress);
                toCancelTransactionList.Value.Add(new DelegateTransaction
                {
                    ContractAddress = delegateInfo.ContractAddress,
                    MethodName = delegateInfo.MethodName
                });
            }

            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateInfo.ContractAddress]
                [delegateInfo.MethodName] = existDelegateeInfoList;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L379-386)
```csharp
            var delegateeInfo =
                State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                    delegateTransaction.MethodName];
            if (delegateeInfo == null || !delegateeInfo.Delegatees.ContainsKey(delegateeAddress)) continue;
            delegateeInfo.Delegatees.Remove(delegateeAddress);
            toCancelTransactionList.Value.Add(delegateTransaction);
            State.TransactionFeeDelegateInfoMap[delegatorAddress][delegateTransaction.ContractAddress][
                delegateTransaction.MethodName] = delegateeInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L100-106)
```csharp
            var transactionFeeDelegatees =
                State.TransactionFeeDelegateInfoMap[fromAddress][input.ContractAddress][input.MethodName] ??
                State.TransactionFeeDelegateesMap[fromAddress];
            if (transactionFeeDelegatees != null)
            {
                var delegateeAddress = transactionFeeDelegatees.Delegatees;
                foreach (var (delegatee, _) in delegateeAddress)
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L174-183)
```csharp
        var delegationInfo =
            State.TransactionFeeDelegateInfoMap[delegatorAddress][input.ContractAddress][input.MethodName]?.Delegatees ?? 
            State.TransactionFeeDelegateesMap[delegatorAddress]?.Delegatees;

        if (delegationInfo == null)
        {
            return false;
        }

        foreach (var (delegatee, delegations) in delegationInfo)
```
