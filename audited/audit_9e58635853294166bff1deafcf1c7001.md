# Audit Report

## Title
Validation Bypass via Data Contamination Enables Last Irreversible Block (LIB) Manipulation

## Summary
The AEDPoS consensus validation logic contaminates trusted state data with untrusted block header data before performing security checks. This causes the `LibInformationValidationProvider` to compare `ImpliedIrreversibleBlockHeight` against itself, creating a tautological validation that always passes. Malicious miners can exploit this to manipulate LIB calculations, causing finality regression or denial of service.

## Finding Description

The vulnerability exists in the `ValidateBeforeExecution` method's handling of `UpdateValue` consensus behavior. The validation flow retrieves trusted round data from blockchain state, but then contaminates this data with untrusted values from the block header before performing validation checks.

**The Attack Flow:**

1. **Data Contamination**: The validation process fetches `baseRound` from trusted blockchain state [1](#0-0) , but then immediately modifies it by calling `RecoverFromUpdateValue` with untrusted data [2](#0-1) 

2. **State Contamination**: The `RecoverFromUpdateValue` method directly overwrites the trusted `baseRound` with values from the untrusted `providedRound` [3](#0-2) , specifically setting `ImpliedIrreversibleBlockHeight` to the attacker-controlled value.

3. **Validation Context Creation**: The validation context is created using the now-contaminated `baseRound` [4](#0-3) , where `BaseRound` contains the malicious value and `ProvidedRound` returns the same untrusted data [5](#0-4) 

4. **Tautological Validation**: The `LibInformationValidationProvider` performs the security check [6](#0-5) , comparing `baseRound.ImpliedIrreversibleBlockHeight > providedRound.ImpliedIrreversibleBlockHeight`. Since both values are now identical due to contamination, this becomes `X > X`, which always evaluates to false and validation passes.

5. **Malicious Value Persists**: After validation passes, `ProcessUpdateValue` persists the malicious `ImpliedIrreversibleBlockHeight` to blockchain state [7](#0-6) 

6. **LIB Calculation Manipulation**: The contaminated values are used in LIB calculation [8](#0-7) , where the algorithm selects the value at position `(count-1)/3` from sorted heights. With control of approximately ⅓ of miners, attackers can manipulate which block height becomes the LIB.

## Impact Explanation

**Critical Severity - Breaks Fundamental Consensus Invariant**

1. **Finality Regression**: Malicious miners can set `ImpliedIrreversibleBlockHeight` to zero or values below the current LIB. With control of ⅓+ miners (the threshold needed for LIB consensus in the sorting algorithm), attackers can force the LIB to regress to arbitrary heights, violating the irreversibility guarantee that is fundamental to blockchain security.

2. **Finality Denial of Service**: By consistently reporting zero or artificially low values, attackers can prevent the LIB from advancing, indefinitely blocking transaction finality. This impacts all network participants who rely on irreversible blocks for settlement.

3. **Cross-Chain Security Impact**: Cross-chain bridges and external systems that rely on LIB for confirmation would be affected, potentially allowing double-spend attacks or transaction reversals after supposed finality.

4. **Consensus Disruption**: The LIB calculation's selection of `(count-1)/3` position means malicious miners controlling this threshold can arbitrarily manipulate consensus finality, undermining the network's security model.

The vulnerability directly breaks the monotonicity invariant that LIB heights must always increase, which is a core security guarantee of the consensus protocol.

## Likelihood Explanation

**High Likelihood**

1. **Low Attacker Requirements**: Any authorized miner in the current miner list can exploit this vulnerability. No special privileges beyond standard miner status are required.

2. **Simple Attack Vector**: The exploit requires only:
   - Producing a block with `UpdateValue` behavior (standard operation)
   - Setting `ImpliedIrreversibleBlockHeight` to a malicious value in consensus extra data
   - No complex state setup or timing requirements

3. **Deterministic Success**: The validation bypass is deterministic - the contaminated comparison will always pass, making the exploit 100% reliable when attempted.

4. **Silent Failure**: The bypassed validation means no error or event is raised. Detection requires external monitoring of LIB progression anomalies, making the attack difficult to detect in real-time.

5. **Production Entry Point**: The vulnerability exists in the standard block production and validation flow, making it reachable through normal consensus operations.

## Recommendation

**Fix: Validate Before Contamination**

The validation logic should check the untrusted `providedRound` against the trusted `baseRound` BEFORE any modifications occur. The corrected flow should be:

1. Retrieve trusted `baseRound` from state
2. Perform ALL validation checks comparing `baseRound` (trusted) against `extraData.Round` (untrusted)
3. Only AFTER validation passes, call recovery methods to update the round data
4. Persist the updated data to state

Specifically, in `ValidateBeforeExecution`:
- Move the validation context creation and all validation provider checks BEFORE the `RecoverFromUpdateValue`/`RecoverFromTinyBlock` calls
- Ensure `BaseRound` in the validation context remains the unmodified trusted state
- Only apply the recovery transformations after successful validation

Additionally, add explicit monotonicity checks:
- Verify that `providedRound.ImpliedIrreversibleBlockHeight >= baseRound.ImpliedIrreversibleBlockHeight`
- Reject any blocks that attempt to regress the implied irreversible block height
- Consider adding a minimum delta requirement to prevent gradual manipulation

## Proof of Concept

A test demonstrating this vulnerability would:

1. Setup a test blockchain with multiple miners
2. Have a malicious miner produce an `UpdateValue` block with `ImpliedIrreversibleBlockHeight` set to 0 (or below current LIB)
3. Observe that `ValidateConsensusBeforeExecution` returns success despite the regressed value
4. Verify that `ProcessUpdateValue` persists the malicious value to state
5. Confirm that subsequent LIB calculations use the contaminated value
6. Demonstrate that with ⅓+ colluding miners, the LIB calculation selects the malicious value, causing finality regression

The vulnerability is exploitable through the standard consensus transaction flow, requiring only miner credentials and manipulation of the `ImpliedIrreversibleBlockHeight` field in consensus extra data.

---

**Notes**: 
- The claim mentions `TinyBlock` behavior, but analysis shows `LibInformationValidationProvider` is only added for `UpdateValue` behavior [9](#0-8) . The vulnerability specifically affects `UpdateValue` consensus blocks.
- The contamination pattern exists in both `RecoverFromUpdateValue` and `RecoverFromTinyBlock`, but only `UpdateValue` triggers the LIB validation check that gets bypassed.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L19-20)
```csharp
        if (!TryToGetCurrentRoundInformation(out var baseRound))
            return new ValidationResult { Success = false, Message = "Failed to get current round information." };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L46-47)
```csharp
        if (extraData.Behaviour == AElfConsensusBehaviour.UpdateValue)
            baseRound.RecoverFromUpdateValue(extraData.Round, extraData.SenderPubkey.ToHex());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-21)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L22-27)
```csharp
    public Round BaseRound { get; set; }

    /// <summary>
    ///     Round information included in the consensus header extra data.
    /// </summary>
    public Round ProvidedRound => ExtraData.Round;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L23-30)
```csharp
        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-249)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_LIB.cs (L20-33)
```csharp
        public void Deconstruct(out long libHeight)
        {
            if (_currentRound.IsEmpty || _previousRound.IsEmpty) libHeight = 0;

            var minedMiners = _currentRound.GetMinedMiners().Select(m => m.Pubkey).ToList();
            var impliedIrreversibleHeights = _previousRound.GetSortedImpliedIrreversibleBlockHeights(minedMiners);
            if (impliedIrreversibleHeights.Count < _currentRound.MinersCountOfConsent)
            {
                libHeight = 0;
                return;
            }

            libHeight = impliedIrreversibleHeights[impliedIrreversibleHeights.Count.Sub(1).Div(3)];
        }
```
