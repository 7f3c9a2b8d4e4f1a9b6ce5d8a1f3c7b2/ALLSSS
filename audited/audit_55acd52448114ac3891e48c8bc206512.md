### Title
Missing LIB Height Validation in NextRound/NextTerm Transitions Allows Consensus Integrity Violation

### Summary
The `NextRoundInput.ToRound()` and `NextTermInput.ToRound()` methods convert inputs to Round objects without validating the `ConfirmedIrreversibleBlockHeight` field. The `LibInformationValidationProvider` that prevents LIB height regression is only applied to `UpdateValue` behavior, not to `NextRound` or `NextTerm` transitions, allowing a malicious miner to reduce the confirmed irreversible block height and violate consensus finality guarantees.

### Finding Description

**Root Cause Location:**

The `ToRound()` method performs a direct field-by-field conversion without any validation: [1](#0-0) 

**Missing Validation:**

The consensus validation logic only adds `LibInformationValidationProvider` for `UpdateValue` behavior, but omits it for `NextRound` and `NextTerm`: [2](#0-1) 

The `LibInformationValidationProvider` specifically checks that LIB height doesn't decrease: [3](#0-2) 

**Vulnerable Execution Path:**

When processing a NextRound transaction, `ToRound()` is called without any LIB validation: [4](#0-3) 

The generated Round is then stored directly: [5](#0-4) 

**Why Existing Protections Fail:**

The `ValidateConsensusAfterExecution` method compares round hashes, but `GetCheckableRound()` does NOT include `ConfirmedIrreversibleBlockHeight` in the hash calculation: [6](#0-5) 

This means a manipulated LIB height will pass hash validation.

### Impact Explanation

**Consensus Integrity Violation:**
A malicious miner can decrease the `ConfirmedIrreversibleBlockHeight`, violating the critical invariant that LIB height must be monotonically increasing. This undermines the fundamental finality guarantee of the consensus system.

**Cross-Chain Security Impact:**
Cross-chain operations rely on LIB height to determine which blocks are safely finalized. A decreased LIB could cause:
- Cross-chain indexing to reference blocks that are not actually irreversible
- Invalid merkle proof acceptance based on incorrect finality assumptions
- Potential double-spend attacks if cross-chain transactions are verified against the manipulated LIB

**Operational Disruption:**
Different nodes may have inconsistent views of blockchain finality, leading to:
- Cross-chain transaction validation failures
- Consensus disagreements between miners
- Potential chain splits if nodes reject blocks based on LIB inconsistencies

The impact is **HIGH** because it directly compromises consensus finality guarantees and cross-chain security.

### Likelihood Explanation

**Attacker Capabilities:**
Any authorized miner can exploit this vulnerability when it's their turn to produce a block that transitions to the next round or term.

**Attack Complexity:**
The attack is straightforward:
1. Miner receives consensus command for NextRound/NextTerm
2. Generates legitimate consensus extra data via the contract's `GetConsensusExtraData` method
3. Modifies the `ConfirmedIrreversibleBlockHeight` value in the Round data to a lower number
4. Includes the manipulated data in the block header

**Feasibility Conditions:**
- Miner must be authorized (in the miner list) - this is a normal operational condition
- Must occur during a round or term transition - happens regularly in normal operation
- No cryptographic barriers since the field is not protected by signatures specific to LIB values

**Detection Constraints:**
The manipulation would not be immediately obvious as:
- The round hash validation passes (LIB height not included in hash)
- No validation error is raised during transaction execution
- Subsequent blocks may continue with the incorrect LIB value

The likelihood is **MEDIUM-HIGH** as any malicious miner can exploit this during regular round transitions without sophisticated techniques.

### Recommendation

**Immediate Fix:**

Add `LibInformationValidationProvider` to the validation pipeline for both `NextRound` and `NextTerm` behaviors in the `ValidateBeforeExecution` method: [7](#0-6) 

Modify this section to include:
```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Additional Defense Layer:**

Add explicit validation in `ToRound()` methods to verify LIB height against current state before conversion, or alternatively include `ConfirmedIrreversibleBlockHeight` in the `GetCheckableRound()` hash calculation.

**Test Cases:**

1. Attempt NextRound with decreased `ConfirmedIrreversibleBlockHeight` - should fail validation
2. Attempt NextRound with decreased `ConfirmedIrreversibleBlockRoundNumber` - should fail validation  
3. Verify legitimate NextRound with unchanged or increased LIB succeeds
4. Verify NextTerm follows same validation rules

### Proof of Concept

**Initial State:**
- Current round has `ConfirmedIrreversibleBlockHeight = 1000` and `ConfirmedIrreversibleBlockRoundNumber = 10`
- Malicious miner M is authorized and scheduled to produce the next round transition block

**Attack Steps:**

1. **Miner M generates legitimate consensus data:**
   - Calls contract's consensus methods to generate NextRoundInput
   - Receives Round data with correct LIB height 1000

2. **Miner M manipulates the data:**
   - Modifies `ConfirmedIrreversibleBlockHeight` to 800 (regression of 200 blocks)
   - Modifies `ConfirmedIrreversibleBlockRoundNumber` to 8
   - Includes this in block's consensus extra data

3. **Block validation occurs:**
   - `ValidateConsensusBeforeExecution` is called
   - For NextRound behavior, only `NextRoundMiningOrderValidationProvider` and `RoundTerminateValidationProvider` are used
   - `LibInformationValidationProvider` is NOT invoked - **validation passes**

4. **Transaction execution:**
   - `ProcessNextRound` is called
   - `input.ToRound()` converts without validation
   - `AddRoundInformation(nextRound)` stores the manipulated Round with LIB=800

5. **Post-execution validation:**
   - `ValidateConsensusAfterExecution` compares round hashes
   - `GetCheckableRound()` excludes `ConfirmedIrreversibleBlockHeight` from hash
   - Hash matches - **validation passes**

**Expected vs Actual Result:**
- **Expected:** Transaction should fail with "Incorrect lib information" error
- **Actual:** Transaction succeeds and stores Round with regressed LIB height

**Success Condition:**
Query the newly stored Round - it will show `ConfirmedIrreversibleBlockHeight = 800`, violating the invariant that LIB must never decrease from 1000.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-110)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-158)
```csharp
        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-206)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
```
