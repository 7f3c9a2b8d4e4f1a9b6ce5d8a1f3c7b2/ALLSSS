### Title
Side Chain Miner Can Front-Run Cross-Chain Updates to Steal Resource Token Distributions Meant for Main Chain Miners

### Summary
A side chain miner can front-run the `UpdateInformationFromCrossChain` transaction by including their `NextTerm` consensus transaction first in their block, corrupting the `State.MainChainCurrentMinerList` with side chain miners before resource token distribution occurs. This allows side chain miners to steal accumulated transaction fees and rental tokens that should be distributed to main chain miners, resulting in direct fund theft.

### Finding Description

**Root Cause:**
The vulnerability stems from conflicting usage of `State.MainChainCurrentMinerList.Value` on side chains without proper synchronization or validation. This single state variable serves two incompatible purposes:

1. **Cross-Chain Distribution Target**: `UpdateInformationFromCrossChain` uses it to distribute accumulated resource tokens to main chain miners [1](#0-0) [2](#0-1) 

2. **Side Chain Miner List Storage**: `NextTerm` overwrites it with side chain's own miner list during term transitions [3](#0-2) 

**Critical Flaw - No IsMainChain Check:**
The `SetMinerList` method unconditionally overwrites `MainChainCurrentMinerList` regardless of whether it's executing on the main chain or side chain: [4](#0-3) 

**Distribution Mechanism:**
The `DistributeResourceTokensToPreviousMiners` function divides all accumulated resource tokens (transaction fees and rental tokens) equally among miners in the corrupted list: [5](#0-4) 

**Execution Path:**
1. `ProcessNextTerm` is called during consensus term transitions on side chains [6](#0-5) 

2. At line 190, it extracts side chain miners from the round input and calls `SetMinerList` [7](#0-6) 

3. This overwrites `MainChainCurrentMinerList` with side chain miners, corrupting the distribution target

**Why Existing Protections Fail:**
- `UpdateInformationFromCrossChain` only validates that the caller is the CrossChain contract and checks round number progression, but does NOT verify the integrity of `MainChainCurrentMinerList` [8](#0-7) 

- No lock or synchronization mechanism protects the shared state variable
- No validation that the miner list contains actual main chain miners before distribution
- Transaction ordering within a block is controlled by the block producer (the attacker)

### Impact Explanation

**Direct Financial Harm:**
Resource tokens (transaction fees collected via `PayTxFeeSymbolListName` and rental fees via `PayRentalSymbolListName`) accumulate in the side chain's consensus contract. These tokens are intended as compensation for main chain miners who secure the main chain and enable cross-chain functionality. The vulnerability allows side chain miners to redirect 100% of these accumulated funds to themselves.

**Affected Parties:**
- **Main Chain Miners**: Lose all resource token rewards they should receive from the side chain
- **Side Chain Miners**: Receive undeserved tokens, benefiting from theft
- **Protocol Economics**: Distribution mechanism is completely subverted, breaking the economic incentive model

**Quantified Impact:**
- Amount stolen: All resource tokens held in `Context.Self` (consensus contract) at time of attack
- Frequency: Can be exploited on every cross-chain consensus update that coincides with a side chain term transition
- Cumulative damage: Repeated exploitation completely eliminates main chain miner rewards from that side chain

**Severity Justification:**
HIGH severity due to:
1. Direct theft of funds with no recovery mechanism
2. 100% loss of intended recipient's distribution
3. Practical exploitability by any side chain miner
4. Breaks core cross-chain economic incentive structure

### Likelihood Explanation

**Attacker Profile:**
Any legitimate side chain miner can execute this attack. The attacker must be in the current or previous round's miner list to call `NextTerm`. [9](#0-8) 

**Attack Complexity:**
LOW - The attack requires only:
1. Being a side chain miner (legitimate role)
2. Producing a block when both `NextTerm` and cross-chain update transactions are pending
3. Ordering transactions in the block: `NextTerm` before cross-chain indexing

**Feasibility Conditions:**
- Side chain must have accumulated resource tokens in consensus contract (happens naturally through normal operation)
- Cross-chain indexing proposal must be pending or in mempool (occurs regularly as part of standard cross-chain synchronization)
- Attacker must be the block producer during a term transition (rotates among miners)

**Detection Difficulty:**
DIFFICULT - The attack uses legitimate consensus operations:
- `NextTerm` is a normal consensus transaction for term transitions
- Cross-chain indexing is standard protocol operation
- Only the transaction ordering is malicious, which appears as normal block production

**Economic Rationality:**
HIGHLY RATIONAL - Zero cost attack (uses legitimate consensus transactions) with potential significant gains (all accumulated resource tokens). Risk/reward ratio strongly favors exploitation.

**Probability Assessment:**
HIGH - Given that:
- Term transitions occur periodically on side chains
- Cross-chain updates occur regularly (indexed parent chain blocks)
- These events will naturally overlap
- Any side chain miner can exploit when they're block producer
- Attack is profitable even for small token amounts

### Recommendation

**Immediate Fix - Separate State Variables:**
On side chains, use distinct state variables for different purposes:
1. `State.MainChainCurrentMinerList` - exclusively for main chain miner list from cross-chain updates
2. `State.CurrentMinerList` or `State.MinerListMap[termNumber]` - for side chain's own miners

**Code-Level Mitigation:**
Modify `SetMinerList` in `AEDPoSContract_NextTerm.cs` to check `IsMainChain` before modifying `MainChainCurrentMinerList`:

```
private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
{
    var minerListFromState = State.MinerListMap[termNumber];
    if (gonnaReplaceSomeone || minerListFromState == null)
    {
        // Only update MainChainCurrentMinerList on main chains
        if (State.IsMainChain.Value)
        {
            State.MainChainCurrentMinerList.Value = minerList;
        }
        State.MinerListMap[termNumber] = minerList;
        return true;
    }
    return false;
}
```

**Additional Validation:**
Add assertion in `UpdateInformationFromCrossChain` to verify the miner list hasn't been corrupted:
```
// After line 46, before line 53
var currentList = State.MainChainCurrentMinerList.Value;
Assert(
    currentList != null && consensusInformation.Round.RoundNumber > State.MainChainRoundNumber.Value,
    "Main chain miner list integrity check failed"
);
```

**Test Cases:**
1. Verify `NextTerm` on side chain does NOT modify `MainChainCurrentMinerList`
2. Verify only `UpdateInformationFromCrossChain` updates `MainChainCurrentMinerList` on side chains
3. Test transaction ordering: `NextTerm` → cross-chain update should distribute to main chain miners, not side chain miners
4. Verify distribution recipients match the main chain miner list from consensus information

### Proof of Concept

**Initial State:**
- Side chain running with miners: [SideMinerA, SideMinerB, SideMinerC]
- Main chain miner list stored in `State.MainChainCurrentMinerList`: [MainMinerX, MainMinerY, MainMinerZ]
- Side chain consensus contract has accumulated 1000 resource tokens from transaction fees
- Cross-chain indexing proposal is pending, will update main chain round from N to N+1

**Attack Sequence:**

**Block Height H (SideMinerA is block producer):**

**Transaction 1: NextTerm (included by SideMinerA)**
- Input: `NextTermInput` with side chain's new term miners [SideMinerA, SideMinerB, SideMinerC]
- Execution: `ProcessNextTerm` → line 190 calls `SetMinerList`
- Result: `State.MainChainCurrentMinerList.Value` = [SideMinerA, SideMinerB, SideMinerC] ✓ (corrupted)

**Transaction 2: ReleaseCrossChainIndexingProposal (cross-chain update)**
- Execution: `IndexParentChainBlockData` → inline call to `UpdateInformationFromCrossChain`
- At line 53: `DistributeResourceTokensToPreviousMiners()` executes
- At line 72: Reads `State.MainChainCurrentMinerList.Value.Pubkeys` = [SideMinerA, SideMinerB, SideMinerC]
- At line 81: Calculates `amount = 1000 / 3 = 333` per miner
- Lines 84-94: Transfers 333 tokens each to SideMinerA, SideMinerB, SideMinerC
- Lines 58-61: Updates `State.MainChainCurrentMinerList.Value` = [MainMinerX, MainMinerY, MainMinerZ] (too late)

**Expected Result:**
- MainMinerX, MainMinerY, MainMinerZ each receive 333 resource tokens

**Actual Result:**
- SideMinerA, SideMinerB, SideMinerC each receive 333 resource tokens
- Main chain miners receive nothing
- 1000 tokens stolen by side chain miners

**Success Condition:**
Verify token balances after block H execution show side chain miners received distributions instead of main chain miners, confirming the theft.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L34-47)
```csharp
        Assert(
            Context.Sender == Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName),
            "Only Cross Chain Contract can call this method.");

        Assert(!State.IsMainChain.Value, "Only side chain can update consensus information.");

        // For now we just extract the miner list from main chain consensus information, then update miners list.
        if (input == null || input.Value.IsEmpty) return new Empty();

        var consensusInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value);

        // check round number of shared consensus, not term number
        if (consensusInformation.Round.RoundNumber <= State.MainChainRoundNumber.Value)
            return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L53-53)
```csharp
        DistributeResourceTokensToPreviousMiners();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS11_CrossChainInformationProvider.cs (L66-96)
```csharp
    private void DistributeResourceTokensToPreviousMiners()
    {
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var minerList = State.MainChainCurrentMinerList.Value.Pubkeys;
        foreach (var symbol in Context.Variables.GetStringArray(AEDPoSContractConstants.PayTxFeeSymbolListName)
                     .Union(Context.Variables.GetStringArray(AEDPoSContractConstants.PayRentalSymbolListName)))
        {
            var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = symbol
            }).Balance;
            var amount = balance.Div(minerList.Count);
            Context.LogDebug(() => $"Consensus Contract {symbol} balance: {balance}. Every miner can get {amount}");
            if (amount <= 0) continue;
            foreach (var pubkey in minerList)
            {
                var address = Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(pubkey.ToHex()));
                Context.LogDebug(() => $"Will send {amount} {symbol}s to {pubkey}");
                State.TokenContract.Transfer.Send(new TransferInput
                {
                    To = address,
                    Amount = amount,
                    Symbol = symbol
                });
            }
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L70-82)
```csharp
    private bool SetMinerList(MinerList minerList, long termNumber, bool gonnaReplaceSomeone = false)
    {
        // Miners for one specific term should only update once.
        var minerListFromState = State.MinerListMap[termNumber];
        if (gonnaReplaceSomeone || minerListFromState == null)
        {
            State.MainChainCurrentMinerList.Value = minerList;
            State.MinerListMap[termNumber] = minerList;
            return true;
        }

        return false;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
