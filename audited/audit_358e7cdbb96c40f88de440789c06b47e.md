### Title
Side Chain ID Spoofing in Cross-Chain Transaction Verification

### Summary
The `VerifyTransaction()` function fails to validate that the provided `VerifiedChainId` matches the actual source chain of a transaction. When multiple side chains are indexed at the same height, an attacker can successfully verify a transaction from Side Chain A by falsely claiming it originated from Side Chain B, because the function computes the same combined merkle root for all side chains indexed together, without filtering by the specific chain ID.

### Finding Description

The vulnerability exists in the cross-chain verification flow across multiple functions:

**Entry Point**: The `VerifyTransaction()` function accepts a `VerifiedChainId` parameter but does not enforce that it matches the actual transaction source chain. [1](#0-0) 

**Root Cause**: The `GetMerkleTreeRoot()` function uses the `chainId` parameter only to decide which merkle root retrieval path to take (parent, side, or cousin chain), but does NOT pass this parameter down to filter the actual merkle root computation. [2](#0-1) 

**Critical Flaw**: For side chain verification, `GetSideChainMerkleTreeRoot()` accepts only a `parentChainHeight` parameter and computes a combined merkle root from ALL side chains indexed at that height, without any chain ID filtering. [3](#0-2) 

**System Design**: Multiple side chains are indexed together at the same local chain height, with their data aggregated into a single `IndexedSideChainBlockData` entry. [4](#0-3) 

**State Structure**: The `IndexedSideChainBlockData` state variable maps local height to combined data from all side chains indexed at that height, enabling the vulnerability. [5](#0-4) 

**Why Protections Fail**: The only validation is checking that `State.SideChainInfo[chainId] != null` (confirming the chain ID is a valid registered side chain), but this does not prevent using the wrong chain ID as long as it's valid.

### Impact Explanation

**Cross-Chain Integrity Violation**: An attacker can falsely claim a transaction originated from a different side chain than it actually did, breaking the fundamental trust assumption of cross-chain verification.

**Dependent Contract Exploitation**: Any contract that relies on `VerifyTransaction` to determine the source chain for authorization decisions (e.g., "only accept token transfers from Side Chain A") can be bypassed. The attacker can execute transactions on Side Chain B but claim they're from Side Chain A.

**Token Theft Scenario**: If a bridge contract accepts deposits only from a privileged side chain with special rules, an attacker can deposit tokens on an unprivileged side chain but verify them as coming from the privileged chain, bypassing security controls.

**Affected Parties**: 
- Users of any side chain with stricter security requirements
- Protocols that implement chain-specific authorization logic
- Cross-chain bridges relying on source chain validation

**Severity Justification**: HIGH severity because:
1. Breaks core cross-chain security invariant
2. Easily exploitable whenever 2+ side chains are indexed at same height (common scenario)
3. No special permissions required
4. Enables downstream attacks on dependent contracts

### Likelihood Explanation

**Reachable Entry Point**: `VerifyTransaction` is a public view method callable by anyone. [6](#0-5) 

**Attacker Capabilities**: 
- Execute transaction on any registered side chain (normal user capability)
- Obtain merkle path from side chain's web API (public information)
- Call `VerifyTransaction` with manipulated `VerifiedChainId` (no restrictions)

**Attack Complexity**: LOW
1. Send transaction on Side Chain A
2. Get merkle path via `GetMerklePathByTransactionIdAsync` 
3. Get bound parent chain height via `GetBoundParentChainHeightAndMerklePathByHeight`
4. Call `VerifyTransaction` with `VerifiedChainId = B` instead of A
5. Verification succeeds with same combined merkle root

**Feasibility Conditions**:
- Multiple side chains indexed at same local height (normal operation)
- No trusted role compromise needed
- No economic cost beyond normal transaction fees

**Detection**: Extremely difficult to detect as the verification succeeds legitimately through standard code paths with no error conditions.

**Probability**: HIGH - The vulnerability is inherent in the design and will always work when preconditions are met.

### Recommendation

**Immediate Fix**: Modify `GetSideChainMerkleTreeRoot()` to accept and use the `chainId` parameter to filter which side chain's merkle root should be returned:

```csharp
private Hash GetSideChainMerkleTreeRoot(int chainId, long parentChainHeight)
{
    var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
    var targetSideChain = indexedSideChainData.SideChainBlockDataList
        .FirstOrDefault(d => d.ChainId == chainId);
    
    Assert(targetSideChain != null, 
        $"Side chain {chainId} not indexed at height {parentChainHeight}");
    
    return targetSideChain.TransactionStatusMerkleTreeRoot;
}
```

**Update Call Site**: Modify `GetMerkleTreeRoot()` to pass the chainId parameter:
```csharp
if (State.SideChainInfo[chainId] != null)
    return GetSideChainMerkleTreeRoot(chainId, parentChainHeight);
```

**Invariant Check**: Add assertion that the chain ID in the merkle path verification matches the claimed chain.

**Test Cases**: Add negative test verifying that using wrong `VerifiedChainId` fails verification when multiple side chains are indexed together.

### Proof of Concept

**Initial State**:
- Main chain has two registered side chains: Side Chain A (ID=1001) and Side Chain B (ID=1002)
- Both side chains indexed at main chain local height 100
- Transaction TxA exists on Side Chain A with valid merkle path PathA

**Attack Steps**:
1. Attacker queries Side Chain A: `GetMerklePathByTransactionIdAsync(TxA)` → get PathA
2. Attacker queries Side Chain A: `GetBoundParentChainHeightAndMerklePathByHeight(blockHeight)` → get bound height 100 and parent merkle path
3. Attacker concatenates merkle paths as per documentation [7](#0-6) 
4. Attacker calls main chain `VerifyTransaction`:
   - `TransactionId = TxA`
   - `VerifiedChainId = 1002` (Side Chain B - WRONG!)
   - `ParentChainHeight = 100`
   - `Path = concatenated_path`

**Expected Result**: Verification should FAIL because TxA is from Chain A, not Chain B

**Actual Result**: Verification SUCCEEDS because:
- `GetMerkleTreeRoot(1002, 100)` checks `State.SideChainInfo[1002] != null` ✓
- Calls `GetSideChainMerkleTreeRoot(100)` which returns combined root of ALL chains
- Combined root matches the computed root from TxA's merkle path
- Returns `true`

**Success Condition**: Attacker successfully verified a Side Chain A transaction while claiming it came from Side Chain B, enabling downstream exploits in contracts that check the verified chain ID for authorization.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L253-264)
```csharp
    private Hash GetMerkleTreeRoot(int chainId, long parentChainHeight)
    {
        if (chainId == State.ParentChainId.Value)
            // it is parent chain
            return GetParentChainMerkleTreeRoot(parentChainHeight);

        if (State.SideChainInfo[chainId] != null)
            // it is child chain
            return GetSideChainMerkleTreeRoot(parentChainHeight);

        return GetCousinChainMerkleTreeRoot(parentChainHeight);
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContractState.cs (L37-37)
```csharp
    public MappedState<long, IndexedSideChainBlockData> IndexedSideChainBlockData { get; set; }
```

**File:** protobuf/acs7.proto (L56-58)
```text
    rpc VerifyTransaction (VerifyTransactionInput) returns (google.protobuf.BoolValue) {
        option (aelf.is_view) = true;
    }
```

**File:** docs-sphinx/architecture/cross-chain/verify.md (L62-68)
```markdown
 With the result returned by above api, you can call **VerifyTransaction** on the target chain with the following input values:
- transaction_id - the ID of the transaction that you want to verify.
- parent_chain_height - use the **bound_parent_chain_height** field of **CrossChainMerkleProofContext** .
- path - the concatenation of 2 merkle paths, in order:
  - the merkle path of the transaction, use the web api method **GetMerklePathByTransactionIdAsync**. 
  - use the **merkle_path_from_parent_chain** field from the **CrossChainMerkleProofContext** object.
- verified_chain_id - the source chainId, here the side chain on which the transaction was mined.
```
