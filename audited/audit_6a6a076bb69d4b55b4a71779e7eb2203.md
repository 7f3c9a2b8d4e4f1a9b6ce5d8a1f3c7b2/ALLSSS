# Audit Report

## Title
Missing Validation of ExtraBlockProducerOfPreviousRound in NextTerm Allows Mining Reward Manipulation

## Summary
The AEDPoS consensus mechanism fails to validate the `ExtraBlockProducerOfPreviousRound` field during NextTerm block processing. A malicious miner producing a NextTerm block can manipulate this field to grant extra mining privileges and rewards to arbitrary miners, directly impacting fund distribution.

## Finding Description

The vulnerability exists due to a validation gap in the consensus extra data verification flow. When a NextTerm block is produced, the `ExtraBlockProducerOfPreviousRound` field in the Round object is not validated by any validation provider, nor is it included in hash-based integrity checks.

**Validation Gap Chain:**

1. **NextTermInput.Create() performs no validation:** The method blindly copies the field from the input Round without verification. [1](#0-0) 

2. **RoundTerminateValidationProvider ignores the field:** The NextTerm validation only checks round number, term number, and InValues - completely omitting `ExtraBlockProducerOfPreviousRound`. [2](#0-1) 

3. **GetCheckableRound() excludes the field from hash:** The hash calculation used for post-execution validation creates a checkable Round that does NOT include `ExtraBlockProducerOfPreviousRound`, making manipulation undetectable. [3](#0-2) 

4. **No validation during block processing:** The ValidateBeforeExecution method for NextTerm only adds `RoundTerminateValidationProvider`, which doesn't check this field. [4](#0-3) 

**Exploitation Mechanism:**

The manipulated field grants privileged mining access:

1. **IsCurrentMiner() grants special privileges:** When current time is before round start AND pubkey matches `ExtraBlockProducerOfPreviousRound`, the miner is allowed to produce blocks. [5](#0-4) 

2. **ProcessTinyBlock increments ProducedBlocks:** Each tiny block produced increments the miner's `ProducedBlocks` counter. [6](#0-5) 

3. **Rewards calculated from ProducedBlocks:** Mining rewards are directly calculated as `minedBlocks * miningRewardPerBlock`, where `minedBlocks` is the sum of all miners' `ProducedBlocks`. [7](#0-6) 

**Attack Flow:**
1. Attacker is selected to produce NextTerm block
2. Attacker calls `GetConsensusExtraData` which generates Round with correct `ExtraBlockProducerOfPreviousRound`
3. Before finalizing the block, attacker modifies this field to a colluding miner's pubkey (or their own if they're in the new term)
4. Block passes validation because no validator checks this field
5. Modified Round is stored in state
6. In subsequent rounds, the beneficiary miner gains extra mining privileges before round start
7. Extra tiny blocks increment their `ProducedBlocks` counter
8. At term end, rewards are calculated giving the beneficiary miner disproportionately high rewards

## Impact Explanation

**Direct Financial Impact:**

This vulnerability enables direct manipulation of mining reward distribution through artificially inflated block production counts. The impact chain is:

- **Extra Mining Window:** The miner matching `ExtraBlockProducerOfPreviousRound` can mine before the round officially starts (when `Context.CurrentBlockTime <= currentRound.GetRoundStartTime()`), a privilege other miners cannot exercise.

- **Increased Block Count:** Each additional tiny block produced during this privileged window increments `ProducedBlocks` by 1. [8](#0-7) 

- **Proportional Reward Increase:** Total mining rewards equal `GetMinedBlocks() * miningRewardPerBlock`, where `GetMinedBlocks()` sums all miners' `ProducedBlocks`. [9](#0-8) 

**Attack Scenarios:**
- **Collusion:** NextTerm producer grants privileges to a colluding miner, both sharing increased rewards
- **Self-enrichment:** If the attacker is also in the new term's miner list, they set themselves as the beneficiary
- **Denial of Service:** Setting a non-existent pubkey prevents anyone from producing blocks during the inter-round period

**Affected Parties:**
- Legitimate extra block producer loses rightful mining privileges and associated rewards
- All other honest miners receive proportionally reduced rewards when a colluding miner inflates their block count
- Protocol integrity is compromised as rewards no longer reflect actual work performed

## Likelihood Explanation

**Attack Feasibility: HIGH**

The attack requires minimal privileges and has straightforward execution:

**Attacker Requirements:**
- Must be selected to produce the NextTerm block during their designated time slot
- This is a regularly occurring event in normal consensus operation, not a rare privilege

**Execution Steps:**
1. Attacker produces NextTerm block during their legitimate time slot
2. Call contract's `GetConsensusExtraData` to generate legitimate consensus data [10](#0-9) 

3. Modify the `ExtraBlockProducerOfPreviousRound` field in the Round object before finalizing the block
4. Block passes all validation checks (validation gap confirmed above)
5. Transaction is generated and executed via `ProcessNextTerm`, storing the manipulated Round [11](#0-10) 

**Detection Constraints:**
- Pre-execution validation uses `RoundTerminateValidationProvider` which doesn't check the field
- Post-execution validation compares hashes using `GetCheckableRound()` which excludes the field
- No baseline comparison against expected values
- Block appears completely valid to all validation layers

**Economic Rationality:**
- Attack cost: Near zero (single field modification)
- Attack benefit: Direct increase in mining rewards
- Risk: Minimal (no detection mechanism exists)
- Frequency: Can be executed at every term transition

## Recommendation

Implement validation of the `ExtraBlockProducerOfPreviousRound` field during NextTerm block processing:

**Option 1: Add field validation in RoundTerminateValidationProvider**
```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Validate term number
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Validate ExtraBlockProducerOfPreviousRound matches sender
    var expectedProducer = extraData.SenderPubkey.ToHex();
    if (extraData.Round.ExtraBlockProducerOfPreviousRound != expectedProducer)
        return new ValidationResult { Message = "Invalid ExtraBlockProducerOfPreviousRound - must match block producer." };

    return new ValidationResult { Success = true };
}
```

**Option 2: Include field in GetCheckableRound() hash calculation**
Modify the `GetCheckableRound()` method to include `ExtraBlockProducerOfPreviousRound` in the checkable Round:
```csharp
var checkableRound = new Round
{
    RoundNumber = RoundNumber,
    TermNumber = TermNumber,
    RealTimeMinersInformation = { minersInformation },
    BlockchainAge = BlockchainAge,
    ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound  // ADD THIS
};
```

**Recommended Approach:** Implement both options for defense in depth. Option 1 provides immediate validation, while Option 2 ensures hash-based integrity checks catch any manipulation.

## Proof of Concept

A malicious NextTerm block producer can execute this attack by:

1. During their legitimate NextTerm time slot, generate consensus extra data
2. Modify the `ExtraBlockProducerOfPreviousRound` field to an arbitrary miner's pubkey
3. Finalize and broadcast the block
4. The block passes all validation checks despite the manipulation
5. In subsequent rounds, the beneficiary miner gains extra mining privileges
6. Extra tiny blocks inflate the beneficiary's `ProducedBlocks` count
7. At term end, inflated block count results in disproportionately high rewards

The vulnerability is confirmed by:
- No validation logic exists for this field in any validation provider
- The field is excluded from hash-based integrity checks
- The field directly controls mining privileges via `IsCurrentMiner()`
- Mining privileges directly affect reward calculations via `ProducedBlocks`

**Note:** A complete proof-of-concept test would require:
1. Setting up a test consensus network with multiple miners
2. Implementing a malicious NextTerm block producer that modifies the field
3. Verifying the modified block passes validation
4. Confirming the beneficiary miner gains extra mining privileges
5. Measuring the reward distribution to show disproportionate allocation

The core vulnerability is architecturally confirmed through code analysis showing the complete absence of validation for this critical consensus field.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L124-127)
```csharp
    public long GetMinedBlocks()
    {
        return RealTimeMinersInformation.Values.Sum(minerInRound => minerInRound.ProducedBlocks);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L150-155)
```csharp
        if (Context.CurrentBlockTime <= currentRound.GetRoundStartTime() &&
            currentRound.ExtraBlockProducerOfPreviousRound == pubkey)
        {
            Context.LogDebug(() => "[CURRENT MINER]PREVIOUS");
            return true;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L299-309)
```csharp
    private void ProcessTinyBlock(TinyBlockInput tinyBlockInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(tinyBlockInput.ActualMiningTime);
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        Assert(TryToUpdateRoundInformation(currentRound), "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L118-121)
```csharp
        var miningRewardPerBlock = GetMiningRewardPerBlock();
        var minedBlocks = previousRound.GetMinedBlocks();
        var amount = minedBlocks.Mul(miningRewardPerBlock);
        State.TreasuryContract.UpdateMiningReward.Send(new Int64Value { Value = miningRewardPerBlock });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```
