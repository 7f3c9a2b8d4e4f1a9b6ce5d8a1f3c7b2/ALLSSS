### Title
Cross-Chain Merkle Root Forgery via Insufficient Contract Validation

### Summary
The `ValidateSideChainBlockData` helper method only validates block height sequencing but fails to validate the authenticity of `transaction_status_merkle_tree_root` and `block_header_hash` fields. This allows a malicious miner to propose side chain blocks with correct sequential heights but completely fabricated merkle roots, which, if approved, become permanently indexed and used for cross-chain transaction verification, enabling the attacker to forge proofs for non-existent transactions.

### Finding Description

The vulnerability exists in the contract-level validation of side chain block data: [1](#0-0) 

This validation method only checks:
1. Chain existence and non-terminated status (lines 700-702)
2. Sequential height progression starting from `CurrentSideChainHeight + 1` (lines 703-714)

**Critical omission**: The method never validates the `transaction_status_merkle_tree_root` or `block_header_hash` fields of the `SideChainBlockData` structure. [2](#0-1) 

The validation is called during proposal creation: [3](#0-2) 

When fake data passes validation and gets approved, it is permanently stored: [4](#0-3) 

The stored fake merkle roots are then used in transaction verification: [5](#0-4) [6](#0-5) 

**Why protections fail:**

While node-side validation exists that checks against cached data: [7](#0-6) 

This protection can be bypassed because:
1. It can be disabled via configuration: [8](#0-7) 

2. It only affects auto-approval; proposals that fail validation still exist on-chain and can be manually approved by the CrossChainIndexingController organization.

**Evidence from tests:**
The existing test suite confirms fake merkle roots are accepted: [9](#0-8) 

### Impact Explanation

**Critical cross-chain security compromise:**

1. **Fake transaction proof acceptance**: Once fake `transaction_status_merkle_tree_root` values are indexed, the attacker can construct merkle paths that validate against these fake roots, making `VerifyTransaction` accept non-existent transactions as valid.

2. **Cross-chain asset theft**: Cross-chain token transfers rely on merkle proof verification. With fake roots, an attacker can "prove" that tokens were locked on a side chain when they were not, enabling unauthorized minting/release of tokens on the parent chain.

3. **Protocol-wide integrity violation**: The indexed data is permanent and affects all subsequent cross-chain verifications for the compromised heights. Multiple blocks can be compromised in a single proposal.

4. **Cascading failures**: Once fake data is indexed, legitimate cross-chain operations relying on correct merkle roots will fail, while fake proofs will succeed, inverting the security model.

**Quantified impact**: An attacker controlling even a single block's merkle root can forge an unlimited number of "valid" transactions for that block height, potentially draining all cross-chain locked assets.

### Likelihood Explanation

**Attacker prerequisites:**
1. Must be a current miner (checked via `AssertAddressIsCurrentMiner`): [10](#0-9) 

2. Must achieve proposal approval through one of two realistic scenarios.

**Exploitation Scenario 1 - Configuration bypass** (HIGH likelihood):
- If `CrossChainDataValidationIgnored = true` in node configuration, no merkle root validation occurs
- The malicious miner proposes fake data with correct heights
- If the CrossChainIndexingController organization approves (possibly unaware of the vulnerability), fake data is indexed
- Configuration changes are operational decisions, not governance-protected

**Exploitation Scenario 2 - Compromised governance** (MEDIUM likelihood):
- Node validation is enabled but detects the fake data
- Proposal fails auto-approval but remains on-chain
- If the CrossChainIndexingController becomes compromised (through key theft, bribery, or social engineering), it can manually approve the invalid proposal
- Given that miners control both proposal creation and often participate in governance, collusion risk is non-trivial

**Attack complexity**: LOW - attacker only needs to:
1. Call `ProposeCrossChainIndexing` with fabricated merkle roots but correct heights (trivial)
2. Wait for approval (automated if validation disabled, or through governance compromise)

**Detection difficulty**: HIGH - fake merkle roots are indistinguishable from legitimate ones at the contract level without external data sources.

**Economic rationality**: HIGHLY FAVORABLE - the cost is minimal (gas for proposal + potential governance influence cost), while the potential gain is complete control over cross-chain asset verification.

### Recommendation

**Immediate mitigation (contract-level):**

Add cryptographic verification to `ValidateSideChainBlockData`:

1. **Store expected block hashes**: When side chains are created, establish a mechanism to cryptographically commit to expected block hashes (e.g., through cross-chain merkle tree roots from the side chain consensus).

2. **Validate merkle roots in contract**: Modify validation to verify that `transaction_status_merkle_tree_root` and `block_header_hash` match expected values from trusted sources, not just accept any values.

3. **Add challenge period**: Implement a time-delay mechanism where proposed data can be challenged before finalization, with cryptographic proof requirements.

**Specific code changes:**

In `ValidateSideChainBlockData`, add:
```
// After height validation at line 713
Assert(blockData.TransactionStatusMerkleTreeRoot != null && 
       blockData.BlockHeaderHash != null, 
       "Missing required merkle tree data.");
       
// Add verification against trusted source
Assert(VerifyBlockDataAuthenticity(blockData), 
       "Invalid block header or merkle root.");
```

**Additional protections:**

1. **Remove configuration bypass**: Make `CrossChainDataValidationIgnored` permanently false or remove the option entirely - validation must always occur.

2. **Strengthen governance**: Require multi-signature approval from both the CrossChainIndexingController AND a separate security council for proposals that fail automatic validation.

3. **Add state consistency checks**: In `IndexSideChainBlockData`, re-validate merkle roots against cached data before final storage.

**Test cases to add:**
1. Test that proposals with mismatched merkle roots are rejected
2. Test that validation cannot be bypassed via configuration
3. Test that governance cannot approve invalid proposals
4. Fuzz testing with random merkle root values

### Proof of Concept

**Initial state:**
1. Side chain created with ID `sideChainId`
2. Current indexed height: 0
3. Attacker is a current miner with proposal rights
4. Node validation is disabled (`CrossChainDataValidationIgnored = true`) OR attacker controls CrossChainIndexingController

**Attack sequence:**

**Step 1**: Attacker creates fake side chain block data
```
fakeMerkleRoot = Hash.FromString("attacker_controlled_fake_root")
fakeBlockHash = Hash.FromString("fake_block_hash")
maliciousBlockData = new SideChainBlockData {
    Height = 1,  // Correct sequential height
    ChainId = sideChainId,
    TransactionStatusMerkleTreeRoot = fakeMerkleRoot,  // FAKE
    BlockHeaderHash = fakeBlockHash  // FAKE
}
```

**Step 2**: Attacker calls `ProposeCrossChainIndexing`
```
CrossChainBlockData data = new CrossChainBlockData {
    SideChainBlockDataList = { maliciousBlockData }
}
result = CrossChainContract.ProposeCrossChainIndexing(data)
```

**Expected result**: Validation should reject fake merkle roots
**Actual result**: Transaction succeeds (Status = Mined), proposal created

**Step 3**: Proposal gets approved (auto-approved if validation disabled, or manually if governance compromised)
```
CrossChainContract.ReleaseCrossChainIndexingProposal({ sideChainId })
```

**Step 4**: Fake data is now permanently indexed
```
indexedData = CrossChainContract.GetIndexedSideChainBlockDataByHeight(currentHeight)
// indexedData contains the fake merkle root
```

**Step 5**: Attacker forges a transaction proof
```
fakeTransactionId = Hash.FromString("non_existent_transaction")
maliciousMerklePath = MerklePath.ComputePathToRoot(fakeTransactionId, fakeMerkleRoot)

verificationResult = CrossChainContract.VerifyTransaction({
    TransactionId = fakeTransactionId,
    Path = maliciousMerklePath,
    ParentChainHeight = currentHeight,
    VerifiedChainId = sideChainId
})
```

**Expected result**: Verification should fail (transaction doesn't exist)
**Actual result**: `verificationResult.Value = true` (fake transaction verified as valid)

**Success condition**: The attacker has successfully stored fake merkle roots that pass `VerifyTransaction`, enabling forgery of cross-chain transaction proofs for non-existent transactions.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L241-246)
```csharp
    private Hash GetSideChainMerkleTreeRoot(long parentChainHeight)
    {
        var indexedSideChainData = State.IndexedSideChainBlockData[parentChainHeight];
        return ComputeRootWithMultiHash(
            indexedSideChainData.SideChainBlockDataList.Select(d => d.TransactionStatusMerkleTreeRoot));
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L309-336)
```csharp
    private void RecordCrossChainData(IEnumerable<int> chainIdList)
    {
        var indexedSideChainBlockData = new IndexedSideChainBlockData();
        foreach (var chainId in chainIdList)
        {
            var pendingProposalExists = TryGetIndexingProposalWithStatus(chainId,
                CrossChainIndexingProposalStatus.Pending,
                out var pendingCrossChainIndexingProposal);
            Assert(pendingProposalExists, "Chain indexing not proposed.");

            if (chainId == State.ParentChainId.Value)
                IndexParentChainBlockData(pendingCrossChainIndexingProposal.ProposedCrossChainBlockData
                    .ParentChainBlockDataList);
            else
                indexedSideChainBlockData.SideChainBlockDataList.Add(IndexSideChainBlockData(
                    pendingCrossChainIndexingProposal.ProposedCrossChainBlockData.SideChainBlockDataList,
                    pendingCrossChainIndexingProposal.Proposer, chainId));

            SetCrossChainIndexingProposalStatus(pendingCrossChainIndexingProposal,
                CrossChainIndexingProposalStatus.Accepted);
        }

        if (indexedSideChainBlockData.SideChainBlockDataList.Count > 0)
        {
            State.IndexedSideChainBlockData.Set(Context.CurrentHeight, indexedSideChainBlockData);
            Context.Fire(new SideChainBlockDataIndexed());
        }
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L465-481)
```csharp
    private CrossChainDataDto ValidateCrossChainDataBeforeIndexing(CrossChainBlockData crossChainBlockData)
    {
        Assert(
            crossChainBlockData.ParentChainBlockDataList.Count > 0 ||
            crossChainBlockData.SideChainBlockDataList.Count > 0,
            "Empty cross chain data proposed.");
        var validatedParentChainBlockData = new Dictionary<int, List<ParentChainBlockData>>();
        var validationResult = ValidateSideChainBlockData(crossChainBlockData.SideChainBlockDataList,
                                   out var validatedSideChainBlockData) &&
                               ValidateParentChainBlockData(crossChainBlockData.ParentChainBlockDataList,
                                   out validatedParentChainBlockData);
        Assert(validationResult, "Invalid cross chain data to be indexed.");
        var crossChainDataDto = new CrossChainDataDto(validatedSideChainBlockData, validatedParentChainBlockData);

        Assert(crossChainDataDto.GetChainIdList().Count > 0, "Empty cross chain data not allowed.");
        return crossChainDataDto;
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L690-718)
```csharp
    private bool ValidateSideChainBlockData(IEnumerable<SideChainBlockData> sideChainBlockData,
        out Dictionary<int, List<SideChainBlockData>> validatedSideChainBlockData)
    {
        var groupResult = sideChainBlockData.GroupBy(data => data.ChainId, data => data);

        validatedSideChainBlockData = new Dictionary<int, List<SideChainBlockData>>();
        foreach (var group in groupResult)
        {
            var chainId = group.Key;
            validatedSideChainBlockData[chainId] = group.ToList();
            var info = State.SideChainInfo[chainId];
            if (info == null || info.SideChainStatus == SideChainStatus.Terminated)
                return false;
            var currentSideChainHeight = State.CurrentSideChainHeight[chainId];
            var target = currentSideChainHeight != 0
                ? currentSideChainHeight + 1
                : AElfConstants.GenesisBlockHeight;

            foreach (var blockData in group)
            {
                var sideChainHeight = blockData.Height;
                if (target != sideChainHeight)
                    return false;
                target++;
            }
        }

        return true;
    }
```

**File:** protobuf/acs7.proto (L91-100)
```text
message SideChainBlockData {
    // The height of side chain block.
    int64 height = 1;
    // The hash of side chain block.
    aelf.Hash block_header_hash = 2;
    // The merkle tree root computing from transactions status in side chain block.
    aelf.Hash transaction_status_merkle_tree_root = 3;
    // The id of side chain.
    int32 chain_id = 4;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L37-46)
```csharp
    public override BoolValue VerifyTransaction(VerifyTransactionInput input)
    {
        var parentChainHeight = input.ParentChainHeight;
        var merkleTreeRoot = GetMerkleTreeRoot(input.VerifiedChainId, parentChainHeight);
        Assert(merkleTreeRoot != null,
            $"Parent chain block at height {parentChainHeight} is not recorded.");
        var rootCalculated = ComputeRootWithTransactionStatusMerklePath(input.TransactionId, input.Path);

        return new BoolValue { Value = merkleTreeRoot == rootCalculated };
    }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataValidationService.cs (L95-109)
```csharp
            var cachedSideChainBlockData =
                _blockCacheEntityConsumer.Take<SideChainBlockData>(sideChainBlockData.ChainId, targetHeight, false);
            if (cachedSideChainBlockData == null)
            {
                Logger.LogDebug(
                    $"Side chain data not found. ChainId: {ChainHelper.ConvertChainIdToBase58(sideChainBlockData.ChainId)}, side chain height: {targetHeight}.");
                return false;
            }

            if (!cachedSideChainBlockData.Equals(sideChainBlockData))
            {
                Logger.LogDebug(
                    $"Incorrect side chain data. ChainId: {ChainHelper.ConvertChainIdToBase58(sideChainBlockData.ChainId)}, side chain height: {targetHeight}.");
                return false;
            }
```

**File:** src/AElf.CrossChain.Core/Indexing/Application/CrossChainIndexingDataProposedLogEventProcessor.cs (L60-64)
```csharp
                if (CrossChainConfigOptions.Value.CrossChainDataValidationIgnored)
                {
                    Logger.LogTrace("Cross chain data validation disabled.");
                    return;
                }
```

**File:** test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs (L61-72)
```csharp
        var fakeSideChainBlockHash = HashHelper.ComputeFrom("sideChainBlockHash");
        var fakeTxMerkleTreeRoot = HashHelper.ComputeFrom("txMerkleTreeRoot");
        var sideChainBlockData =
            CreateSideChainBlockData(fakeSideChainBlockHash, 1, sideChainId, fakeTxMerkleTreeRoot);
        var crossChainBlockData = new CrossChainBlockData
        {
            SideChainBlockDataList = { sideChainBlockData }
        };

        {
            var txRes = await CrossChainContractStub.ProposeCrossChainIndexing.SendAsync(crossChainBlockData);
            Assert.Equal(TransactionResultStatus.Mined, txRes.TransactionResult.Status);
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L282-291)
```csharp
    public override Empty ProposeCrossChainIndexing(CrossChainBlockData input)
    {
        Context.LogDebug(() => "Proposing cross chain data..");
        EnsureTransactionOnlyExecutedOnceInOneBlock();
        AssertAddressIsCurrentMiner(Context.Sender);
        ClearCrossChainIndexingProposalIfExpired();
        var crossChainDataDto = ValidateCrossChainDataBeforeIndexing(input);
        ProposeCrossChainBlockData(crossChainDataDto, Context.Sender);
        return new Empty();
    }
```
