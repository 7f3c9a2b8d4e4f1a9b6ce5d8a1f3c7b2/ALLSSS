### Title
Post-Execution Consensus Validation Always Passes Due to Object Reference Bug

### Summary
The `ValidateConsensusAfterExecution` method contains a critical logic error where recovery methods modify the post-execution state round object in-place, then compare it with itself, rendering the validation check completely ineffective. This allows blocks with inconsistent consensus state to be accepted, violating consensus integrity guarantees.

### Finding Description

In `ValidateConsensusAfterExecution`, the recovery logic creates a fundamental flaw: [1](#0-0) 

The `RecoverFromUpdateValue` and `RecoverFromTinyBlock` methods modify the `this` reference (currentRound) in-place and return it: [2](#0-1) [3](#0-2) 

**Root Cause**: After lines 89-92 or 94-97, `headerInformation.Round` and `currentRound` become the **same object reference** in memory. The hash comparison at lines 100-101 compares an object with itself, which always yields equal hashes regardless of whether the block header actually matches the execution result.

The simplified round data from the block header is lost when the recovery method overwrites `headerInformation.Round` with the modified `currentRound` object. Critical fields like `ProducedBlocks` are included in the header but NOT updated during recovery, meaning the validation never actually checks the original header values. [4](#0-3) 

### Impact Explanation

**Consensus Integrity Violation**: The post-execution validation is the final safety check to ensure block execution results match the consensus claims in the block header. With this check broken:

1. **Invalid blocks accepted**: Blocks where the header Round data doesn't match actual execution results will pass validation
2. **State inconsistency propagation**: Incorrect consensus state can spread across the network without detection  
3. **Critical invariant broken**: The system cannot verify that "execution output matches consensus commitment"
4. **Defense-in-depth failure**: Any bugs in `ProcessUpdateValue` or `ProcessTinyBlock` that cause incorrect state updates will go undetected [5](#0-4) 

Fields like `ProducedBlocks`, `ProducedTinyBlocks`, and others that should match between header and execution result are never actually validated due to this bug. [6](#0-5) 

### Likelihood Explanation

**Automatic and Continuous**: This validation runs on every `UpdateValue` and `TinyBlock` consensus operation across all nodes:

- **Reachable Entry Point**: `ValidateConsensusAfterExecution` is part of the ACS4 consensus interface, automatically invoked during block validation
- **No Preconditions**: Happens during normal block processing for any miner
- **Execution Certainty**: Bug triggers 100% of the time for UpdateValue/TinyBlock behaviors
- **Detection**: The bug is silent - invalid blocks appear valid, making it hard to detect corruption until significant damage occurs

While this doesn't provide a direct attack vector, it removes a critical safety barrier that should catch:
- Implementation bugs in execution logic
- State corruption issues
- Race conditions in consensus processing
- Malicious blocks with fabricated header data

### Recommendation

**Fix the object reference issue** by comparing against the original header data before recovery modifies it:

```csharp
public override ValidationResult ValidateConsensusAfterExecution(BytesValue input)
{
    var headerInformation = new AElfConsensusHeaderInformation();
    headerInformation.MergeFrom(input.Value);
    if (TryToGetCurrentRoundInformation(out var currentRound))
    {
        // Store original header round before recovery
        var originalHeaderRound = headerInformation.Round.Clone();
        
        if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
            headerInformation.Round = 
                currentRound.RecoverFromUpdateValue(headerInformation.Round,
                    headerInformation.SenderPubkey.ToHex());

        if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
            headerInformation.Round = 
                currentRound.RecoverFromTinyBlock(headerInformation.Round,
                    headerInformation.SenderPubkey.ToHex());

        var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
        // Compare recovered header against post-execution state
        if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
            currentRound.GetHash(isContainPreviousInValue))
        {
            // existing validation logic...
        }
    }
    return new ValidationResult { Success = true };
}
```

Alternatively, refactor recovery methods to return a new object instead of modifying `this` in-place.

**Add test cases** that verify validation rejects blocks where header Round data doesn't match execution results for fields like ProducedBlocks, ImpliedIrreversibleBlockHeight, etc.

### Proof of Concept

**Initial State**: Node at height H with current round state ProducedBlocks=50 for miner M

**Attack Sequence**:
1. Miner M creates a block with UpdateValue behavior
2. Block header contains simplified Round with ProducedBlocks=100 (incorrect value)
3. Block contains consensus transaction that will increment from 50→51
4. Node validates block:
   - Pre-execution validation: passes (recovery uses pre-exec state)
   - Execution: ProcessUpdateValue sets ProducedBlocks=51 in state
   - Post-execution validation: 
     - Gets currentRound with ProducedBlocks=51
     - Calls currentRound.RecoverFromUpdateValue(header_round, M)
     - Recovery doesn't update ProducedBlocks field
     - headerInformation.Round now points to currentRound (same object)
     - Hash comparison: currentRound vs currentRound → **EQUAL (validation passes)**

**Expected Result**: Validation should reject the block because header claimed ProducedBlocks=100 but execution produced ProducedBlocks=51

**Actual Result**: Validation passes because it compares currentRound with itself instead of comparing against original header data

**Success Condition**: Invalid block accepted into blockchain, consensus state inconsistency undetected

### Notes

This bug makes post-execution validation a no-op for UpdateValue and TinyBlock behaviors, completely undermining a critical consensus safety check. While not directly exploitable for fund theft, it represents a severe consensus integrity flaw that could mask other bugs or enable sophisticated consensus attacks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L87-101)
```csharp
        if (TryToGetCurrentRoundInformation(out var currentRound))
        {
            if (headerInformation.Behaviour == AElfConsensusBehaviour.UpdateValue)
                headerInformation.Round =
                    currentRound.RecoverFromUpdateValue(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            if (headerInformation.Behaviour == AElfConsensusBehaviour.TinyBlock)
                headerInformation.Round =
                    currentRound.RecoverFromTinyBlock(headerInformation.Round,
                        headerInformation.SenderPubkey.ToHex());

            var isContainPreviousInValue = !currentRound.IsMinerListJustChanged;
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L8-33)
```csharp
    public Round RecoverFromUpdateValue(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.OutValue = providedInformation.OutValue;
        minerInRound.Signature = providedInformation.Signature;
        minerInRound.PreviousInValue = providedInformation.PreviousInValue;
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        foreach (var information in providedRound.RealTimeMinersInformation)
        {
            RealTimeMinersInformation[information.Key].SupposedOrderOfNextRound =
                information.Value.SupposedOrderOfNextRound;
            RealTimeMinersInformation[information.Key].FinalOrderOfNextRound =
                information.Value.FinalOrderOfNextRound;
            RealTimeMinersInformation[information.Key].PreviousInValue =
                information.Value.PreviousInValue;
        }

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L35-47)
```csharp
    public Round RecoverFromTinyBlock(Round providedRound, string pubkey)
    {
        if (!RealTimeMinersInformation.ContainsKey(pubkey) ||
            !providedRound.RealTimeMinersInformation.ContainsKey(pubkey))
            return this;

        var minerInRound = RealTimeMinersInformation[pubkey];
        var providedInformation = providedRound.RealTimeMinersInformation[pubkey];
        minerInRound.ImpliedIrreversibleBlockHeight = providedInformation.ImpliedIrreversibleBlockHeight;
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);

        return this;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L11-56)
```csharp
    public Round GetUpdateValueRound(string pubkey)
    {
        var minerInRound = RealTimeMinersInformation[pubkey];
        var round = new Round
        {
            RoundNumber = RoundNumber,
            RoundIdForValidation = RoundId,
            RealTimeMinersInformation =
            {
                [pubkey] = new MinerInRound
                {
                    Pubkey = pubkey,
                    OutValue = minerInRound.OutValue,
                    Signature = minerInRound.Signature,
                    ProducedBlocks = minerInRound.ProducedBlocks,
                    ProducedTinyBlocks = minerInRound.ProducedTinyBlocks,
                    PreviousInValue = minerInRound.PreviousInValue,
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
                    ImpliedIrreversibleBlockHeight = minerInRound.ImpliedIrreversibleBlockHeight,
                    Order = minerInRound.Order,
                    IsExtraBlockProducer = minerInRound.IsExtraBlockProducer
                }
            }
        };
        foreach (var information in RealTimeMinersInformation)
            if (information.Key == pubkey)
            {
                round.RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound =
                    minerInRound.SupposedOrderOfNextRound;
                round.RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = minerInRound.FinalOrderOfNextRound;
            }
            else
            {
                round.RealTimeMinersInformation.Add(information.Key, new MinerInRound
                {
                    Pubkey = information.Value.Pubkey,
                    SupposedOrderOfNextRound = information.Value.SupposedOrderOfNextRound,
                    FinalOrderOfNextRound = information.Value.FinalOrderOfNextRound,
                    Order = information.Value.Order,
                    IsExtraBlockProducer = information.Value.IsExtraBlockProducer,
                    PreviousInValue = information.Value.PreviousInValue
                });
            }

        return round;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```
