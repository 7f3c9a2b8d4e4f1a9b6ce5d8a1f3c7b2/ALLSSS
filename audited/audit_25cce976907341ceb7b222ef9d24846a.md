### Title
Missing Validation of ActualMiningTimes Against Block Header Time Enables Consensus Timestamp Manipulation

### Summary
The AEDPoS consensus contract lacks validation to ensure that `ActualMiningTimes` values in block extra data match the actual block header timestamp. A malicious miner can modify their node software to manipulate `ActualMiningTimes` independently from `block.Header.Time`, corrupting consensus-critical calculations including term change decisions, blockchain age, and future mining schedules, while still passing all existing validation checks.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:**

During block generation, `GetConsensusExtraDataToPublishOutValue` correctly adds `Context.CurrentBlockTime` (which equals `block.Header.Time`) to the `ActualMiningTimes` collection: [2](#0-1) 

This data is then copied to the simplified round that gets embedded in block extra data: [1](#0-0) 

However, the validation flow has a critical gap. During validation before execution, `RecoverFromUpdateValue` adds the provided `ActualMiningTimes` from the block extra data to the base round without validating them against the block's header time: [3](#0-2) 

The `TimeSlotValidationProvider` only checks if `ActualMiningTimes` fall within expected time slots, not whether they match the block timestamp: [4](#0-3) 

Critically, during validation, `Context.CurrentBlockTime` is set to the current UTC time (not the block header time), making it unavailable for comparison: [5](#0-4) 

During execution, the unchecked `ActualMiningTime` from the input is directly added to state: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Impact:**

1. **Term Change Manipulation:** The `NeedToChangeTerm` method uses `ActualMiningTimes.Last()` to determine when two-thirds of miners have reached the term change threshold. Corrupted timestamps can accelerate or delay term changes: [7](#0-6) 

2. **Blockchain Age Corruption:** When generating the next round, the blockchain age calculation uses `currentBlockTimestamp` which is affected by previous rounds' `ActualMiningTimes`: [8](#0-7) 

3. **Mining Schedule Manipulation:** `ProcessNextRound` uses the first miner's `ActualMiningTime` to set the blockchain start timestamp, directly impacting all future mining schedules: [9](#0-8) 

4. **LIB Calculation Impact:** Corrupted timestamps affect Last Irreversible Block height calculations, potentially delaying finality.

**Severity:** HIGH - Attacks consensus schedule integrity, term transitions, and blockchain time calculations, which are fundamental to the AEDPoS consensus mechanism.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Modify node software to intercept and alter consensus extra data after contract generation but before block signing
- Must be an active miner with a valid time slot
- Technical sophistication to modify blockchain node software

**Feasibility:**
- Attack is technically feasible for a motivated attacker with node software access
- The malicious `ActualMiningTimes` values must still pass `TimeSlotValidationProvider` checks (be within expected time slots), limiting the manipulation range
- Block signature verification provides authenticity but not correctness of timestamp values

**Detection Constraints:**
- Subtle manipulations (small time differences within the allowed slot) may go unnoticed
- Large deviations between `block.Header.Time` and `ActualMiningTimes` would be detectable through off-chain monitoring
- No on-chain mechanism exists to detect or prevent this attack

**Probability:** MEDIUM - Requires node modification but is technically achievable with measurable consensus impact.

### Recommendation

**1. Add Validation During Block Validation:**

Add a validation check in `ValidateBeforeExecution` or create a new validation provider that compares the provided `ActualMiningTimes` against the block header time. The block header time should be passed to the validation context:

```csharp
// In ConsensusValidationContext, add:
public Timestamp BlockHeaderTime { get; set; }

// In new ActualMiningTimeValidationProvider:
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (validationContext.ProvidedRound.RealTimeMinersInformation.TryGetValue(
        validationContext.SenderPubkey, out var minerInRound))
    {
        var latestActualMiningTime = minerInRound.ActualMiningTimes.LastOrDefault();
        if (latestActualMiningTime != null && 
            latestActualMiningTime != validationContext.BlockHeaderTime)
        {
            return new ValidationResult 
            { 
                Message = "ActualMiningTime does not match block header time" 
            };
        }
    }
    return new ValidationResult { Success = true };
}
```

**2. Pass Block Header Time to Validation:**

Modify `ConsensusService.ValidateConsensusBeforeExecutionAsync` to pass the block header time instead of UTC time: [10](#0-9) 

**3. Add Test Cases:**

Create test cases that attempt to provide `ActualMiningTimes` values different from `block.Header.Time` and verify they are rejected.

### Proof of Concept

**Initial State:**
- Chain is running with normal AEDPoS consensus
- Attacker is a valid miner with an assigned time slot from T to T+4000ms

**Attack Steps:**

1. **Attacker's Time Slot Arrives:** Block height H, expected mining time T

2. **Modified Node Behavior:**
   - Attacker's modified node generates block header with `Header.Time = T + 1000ms`
   - Node calls `GetConsensusExtraData` which adds `Context.CurrentBlockTime = T + 1000ms` to `ActualMiningTimes`
   - **Before signing**, attacker's modified node intercepts the extra data and changes `ActualMiningTimes` from `[T + 1000ms]` to `[T + 3500ms]`
   - Node signs the block with modified extra data

3. **Block Validation by Other Nodes:**
   - Block signature verification passes (attacker signed the block with modified data)
   - Block time validation passes (`T + 1000ms` is within allowed future time span)
   - `RecoverFromUpdateValue` adds `T + 3500ms` to baseRound's `ActualMiningTimes`
   - `TimeSlotValidationProvider.CheckMinerTimeSlot` validates: is `T + 3500ms < T + 4000ms`? YES → passes
   - All validations pass ✓

4. **Block Execution:**
   - `ProcessUpdateValue` adds the malicious timestamp `T + 3500ms` to state
   - State now contains incorrect `ActualMiningTimes`

5. **Impact Propagation:**
   - When checking `NeedToChangeTerm`, the system uses the corrupted `T + 3500ms` instead of actual `T + 1000ms`
   - This timestamp is 2500ms ahead of reality, potentially triggering premature term changes
   - Future round calculations inherit the corrupted timing data

**Expected:** Block rejected due to `ActualMiningTimes` mismatch with `block.Header.Time`

**Actual:** Block accepted with corrupted consensus timestamps

**Success Condition:** Attacker successfully injects timestamp `T + 3500ms` into consensus state while actual block time was `T + 1000ms`, manipulating consensus timing calculations.

---

**Notes:**

This vulnerability stems from the architectural decision to use UTC time during validation rather than the block header time, preventing validators from detecting timestamp manipulation in the consensus extra data. The attack requires node software modification but has significant impact on consensus integrity, particularly term change timing and mining schedule calculations.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L28-28)
```csharp
                    ActualMiningTimes = { minerInRound.ActualMiningTimes },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L62-63)
```csharp
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Recover.cs (L20-20)
```csharp
        minerInRound.ActualMiningTimes.Add(providedInformation.ActualMiningTimes);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L37-50)
```csharp
    private bool CheckMinerTimeSlot(ConsensusValidationContext validationContext)
    {
        if (IsFirstRoundOfCurrentTerm(out _, validationContext)) return true;
        var minerInRound = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        var latestActualMiningTime = minerInRound.ActualMiningTimes.OrderBy(t => t).LastOrDefault();
        if (latestActualMiningTime == null) return true;
        var expectedMiningTime = minerInRound.ExpectedMiningTime;
        var endOfExpectedTimeSlot =
            expectedMiningTime.AddMilliseconds(validationContext.BaseRound.GetMiningInterval());
        if (latestActualMiningTime < expectedMiningTime)
            // Which means this miner is producing tiny blocks for previous extra block slot.
            return latestActualMiningTime < validationContext.BaseRound.GetRoundStartTime();

        return latestActualMiningTime < endOfExpectedTimeSlot;
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L119-130)
```csharp
    public async Task<bool> ValidateConsensusBeforeExecutionAsync(ChainContext chainContext,
        byte[] consensusExtraData)
    {
        var now = TimestampHelper.GetUtcNow();
        _blockTimeProvider.SetBlockTime(now, chainContext.BlockHash);

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var validationResult = await _contractReaderFactory
            .Create(contractReaderContext)
            .ValidateConsensusBeforeExecution
            .CallAsync(new BytesValue { Value = ByteString.CopyFrom(consensusExtraData) });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L121-123)
```csharp
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L243-243)
```csharp
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L23-23)
```csharp
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;
```
