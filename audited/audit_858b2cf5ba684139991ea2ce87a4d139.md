# Audit Report

## Title
DOS Attack via Empty Period Creation Permanently Blocks Profit Claiming for Early Beneficiaries

## Summary
A malicious TokenHolder scheme manager can create empty distribution periods by repeatedly calling `DistributeProfits` with null or empty `AmountsMap`. This causes beneficiaries to become permanently unable to claim profits because the claiming logic skips empty periods without advancing their `LastProfitPeriod` marker, creating an insurmountable barrier that prevents access to both past and future profit distributions.

## Finding Description

The vulnerability stems from a critical flaw in how the profit claiming mechanism handles empty distribution periods created through the TokenHolder contract.

**Attack Vector:**

In `TokenHolderContract.DistributeProfits`, the scheme manager is authorized to call the distribution function, but there is no validation preventing empty distributions. [1](#0-0)  When `AmountsMap` is null or empty, the function conditionally adds amounts but always proceeds to call the Profit contract and increment the period counter. [2](#0-1) 

**Empty Period Creation:**

In `ProfitContract.DistributeProfits`, when the input has an empty `AmountsMap` and the scheme has no `ReceivedTokenSymbols` yet (no prior contributions), the `profitsMap` dictionary remains empty. [3](#0-2)  Despite this, `UpdateDistributedProfits` is called and creates a `DistributedProfitsInfo` record with `IsReleased = true`, empty `AmountsMap`, but non-zero `TotalShares`. [4](#0-3)  The scheme's period counter is then incremented. [5](#0-4) 

**DOS Mechanism:**

When beneficiaries attempt to claim profits via `ProfitAllPeriods`, the function initializes `lastProfitPeriod` to the beneficiary's current `LastProfitPeriod`. [6](#0-5)  It then loops through periods, but critically, when it encounters an empty period (where `AmountsMap` is empty), it executes a `continue` statement. [7](#0-6) 

The problem is that the line updating `lastProfitPeriod = period + 1` appears AFTER the `continue` statement within a conditional block. [8](#0-7)  This means for empty periods, the update never executes. After the loop completes processing up to `maxProfitReceivingPeriodCount` periods (default 100), [9](#0-8)  the beneficiary's `LastProfitPeriod` is set to the unchanged `lastProfitPeriod` value. [10](#0-9) 

**Attack Execution:**
1. Attacker creates a TokenHolder scheme (becomes scheme manager)
2. Adds beneficiaries to establish non-zero `TotalShares`
3. Before any contributions, calls `DistributeProfits` 1000 times with null `AmountsMap`
4. Each call creates one empty period (periods 1-1000 are now empty)
5. Later legitimate distributions at period 1001+ become unreachable
6. Beneficiaries attempting to claim process 100 empty periods per transaction without progress
7. Their `LastProfitPeriod` remains stuck at period 1 permanently

## Impact Explanation

This vulnerability creates a **permanent denial of service** for profit claiming with the following consequences:

**Permanent Loss of Rewards:**
- Beneficiaries with `StartPeriod` values within or before the empty period range cannot advance their claiming position
- Each claim transaction processes up to 100 periods but makes zero progress through empty periods
- Even if legitimate distributions occur in future periods, beneficiaries can never reach them

**No Recovery Mechanism:**
- No function exists to "skip" empty periods or reset `LastProfitPeriod`
- Beneficiaries are permanently locked out of the reward system
- Tokens locked by users for profit-sharing become worthless as rewards are inaccessible

**Complete Scheme Dysfunction:**
- The TokenHolder scheme becomes completely non-functional for early participants
- New beneficiaries added after the empty periods may not be affected, but early ones are permanently DOS'd
- The attack affects the core functionality of the staking/reward mechanism

**User Fund Impact:**
Users who locked tokens expecting profit distributions cannot access their earned rewards, representing a functional loss of value equivalent to the profits they should have received.

The severity is **HIGH** because it results in permanent, irreversible denial of earned rewards for all early beneficiaries, with no recovery path.

## Likelihood Explanation

The likelihood of this attack is **HIGH** due to:

**Low Barrier to Entry:**
- Any user can create a TokenHolder scheme and become the scheme manager
- The manager role is not a privileged position requiring special permissions
- Creation and management of schemes is a standard protocol feature

**Trivial Attack Execution:**
- The attack requires only repeated calls to `DistributeProfits` with empty input
- No complex transaction sequences or timing requirements
- Each call costs minimal gas (just the transaction fee)
- Can create thousands of empty periods for negligible cost

**Lack of Protective Measures:**
- No validation prevents `DistributeProfits` calls with empty `AmountsMap`
- No rate limiting on distribution frequency
- No maximum empty period detection or prevention
- The authorization check permits the manager to make these calls

**Realistic Attack Scenarios:**
- **Malicious Scheme Creation:** Attacker creates scheme, attracts users with promises of rewards, then DOS's the claiming
- **Competitive Sabotage:** Competing protocols could DOS each other's reward schemes
- **Griefing Attack:** Low-cost method to permanently disable profit distribution for specific user groups
- **Compromised Manager:** If a scheme manager's keys are compromised, attacker can immediately DOS all beneficiaries

**Detection Difficulty:**
- The attack is silent until users attempt to claim
- Empty periods appear as valid state transitions
- By the time users discover the DOS, it's already permanent

## Recommendation

Implement validation to prevent empty distribution periods:

**In TokenHolderContract.DistributeProfits:**
```csharp
public override Empty DistributeProfits(DistributeProfitsInput input)
{
    var scheme = GetValidScheme(input.SchemeManager, true);
    Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
           Context.Sender == input.SchemeManager, "No permission to distribute profits.");
    
    // ADD THIS VALIDATION
    Assert(input.AmountsMap != null && input.AmountsMap.Any(), 
           "Cannot distribute profits with empty amounts.");
    
    var distributeProfitsInput = new Profit.DistributeProfitsInput
    {
        SchemeId = scheme.SchemeId,
        Period = scheme.Period
    };
    distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

    State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
    scheme.Period = scheme.Period.Add(1);
    State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
    return new Empty();
}
```

**Alternative Fix in ProfitContract.DistributeProfits:**
Add validation before creating distribution records:
```csharp
Assert(profitsMap.Any() || totalShares <= 0, 
       "Cannot create distribution period with no profits and non-zero shares.");
```

**Additional Hardening:**
Consider modifying `ProfitAllPeriods` to advance `LastProfitPeriod` even for skipped periods:
```csharp
if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
    !distributedProfitsInformation.AmountsMap.Any() ||
    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
{
    if (!isView)
        lastProfitPeriod = period + 1; // Still advance for empty periods
    continue;
}
```

## Proof of Concept

```csharp
[Fact]
public async Task EmptyPeriodDOS_Test()
{
    // 1. Create TokenHolder scheme with beneficiaries
    var schemeManager = Accounts[0].Address;
    var beneficiary = Accounts[1].Address;
    
    // Create scheme
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF",
        MinimumLockMinutes = 1
    });
    
    // Add beneficiary with shares
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = beneficiary,
        Shares = 1000
    });
    
    // 2. Attacker creates 200 empty periods
    for (int i = 0; i < 200; i++)
    {
        await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
        {
            SchemeManager = schemeManager,
            AmountsMap = { } // Empty amounts map
        });
    }
    
    // 3. Later, real distribution occurs at period 201
    await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
    {
        SchemeManager = schemeManager,
        Amount = 10000,
        Symbol = "ELF"
    });
    await TokenHolderContractStub.DistributeProfits.SendAsync(new DistributeProfitsInput
    {
        SchemeManager = schemeManager,
        AmountsMap = { { "ELF", 10000 } }
    });
    
    // 4. Beneficiary attempts to claim but is DOS'd
    // First claim processes periods 1-100 (all empty), LastProfitPeriod stays at 1
    var beforeClaim = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    var lastPeriodBefore = beforeClaim.Details[0].LastProfitPeriod;
    
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager,
        Beneficiary = beneficiary
    });
    
    var afterClaim = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    var lastPeriodAfter = afterClaim.Details[0].LastProfitPeriod;
    
    // LastProfitPeriod should have advanced but didn't - it's stuck!
    lastPeriodAfter.ShouldBe(lastPeriodBefore); // Still at period 1
    
    // Second claim processes periods 101-200 (all empty), still no progress
    await TokenHolderContractStub.ClaimProfits.SendAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager,
        Beneficiary = beneficiary
    });
    
    var afterSecondClaim = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        SchemeId = schemeId,
        Beneficiary = beneficiary
    });
    
    // Still stuck at period 1 - beneficiary can NEVER reach period 201 with the real profits
    afterSecondClaim.Details[0].LastProfitPeriod.ShouldBe(1);
    
    // Beneficiary has profits waiting at period 201 but can never claim them
    var profitAmount = await TokenHolderContractStub.GetProfitsMap.CallAsync(new ClaimProfitsInput
    {
        SchemeManager = schemeManager,
        Beneficiary = beneficiary
    });
    profitAmount.Value["ELF"].ShouldBe(0); // Can't access the 10000 ELF at period 201
}
```

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L134-135)
```csharp
        Assert(Context.Sender == Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName) ||
               Context.Sender == input.SchemeManager, "No permission to distribute profits.");
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L141-145)
```csharp
        if (input.AmountsMap != null && input.AmountsMap.Any()) distributeProfitsInput.AmountsMap.Add(input.AmountsMap);

        State.ProfitContract.DistributeProfits.Send(distributeProfitsInput);
        scheme.Period = scheme.Period.Add(1);
        State.TokenHolderProfitSchemes[input.SchemeManager] = scheme;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L432-460)
```csharp
        var profitsMap = new Dictionary<string, long>();
        if (input.AmountsMap.Any())
        {
            foreach (var amount in input.AmountsMap)
            {
                var actualAmount = amount.Value == 0
                    ? State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = amount.Key
                    }).Balance
                    : amount.Value;
                profitsMap.Add(amount.Key, actualAmount);
            }
        }
        else
        {
            if (scheme.IsReleaseAllBalanceEveryTimeByDefault && scheme.ReceivedTokenSymbols.Any())
                // Prepare to distribute all from general ledger.
                foreach (var symbol in scheme.ReceivedTokenSymbols)
                {
                    var balance = State.TokenContract.GetBalance.Call(new GetBalanceInput
                    {
                        Owner = scheme.VirtualAddress,
                        Symbol = symbol
                    }).Balance;
                    profitsMap.Add(symbol, balance);
                }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L494-494)
```csharp
        scheme.CurrentPeriod = input.Period.Add(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-582)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L849-849)
```csharp
        var lastProfitPeriod = profitDetail.LastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L868-871)
```csharp
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L908-908)
```csharp
                    lastProfitPeriod = period + 1;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L917-917)
```csharp
        profitDetail.LastProfitPeriod = lastProfitPeriod;
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
