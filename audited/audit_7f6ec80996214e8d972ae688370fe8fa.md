### Title
NextRoundMiningOrderValidationProvider Fails to Validate Order Uniqueness Due to Incorrect Distinct() Usage

### Summary
The `NextRoundMiningOrderValidationProvider` contains a critical bug where it calls `.Distinct()` on `MinerInRound` objects instead of their `FinalOrderOfNextRound` values, failing to detect duplicate mining orders. This allows a malicious miner to inject a Round with duplicate `FinalOrderOfNextRound` values, corrupting the consensus mechanism by assigning multiple miners to the same time slot in subsequent rounds.

### Finding Description

The vulnerability exists in the validation logic that checks mining order integrity: [1](#0-0) 

The code calls `.Distinct()` on the collection of `MinerInRound` objects, not on their `FinalOrderOfNextRound` integer values. Since each `MinerInRound` object has a unique public key, they are always distinct as objects, even when their `FinalOrderOfNextRound` values are duplicates.

The validator is invoked during `NextRound` behavior validation: [2](#0-1) 

When a NextRound transaction is processed, the provided Round data is stored without proper order uniqueness validation: [3](#0-2) 

The corrupted Round data is then used to generate the following round: [4](#0-3) 

When duplicate `FinalOrderOfNextRound` values exist, multiple miners receive the same `Order` assignment, breaking the mining schedule invariant that each miner must have a unique time slot.

### Impact Explanation

**Consensus/Cross-Chain Integrity Violation**: This vulnerability allows consensus disruption through invalid round transitions.

**Concrete Harm**:
1. **Mining Schedule Corruption**: Multiple miners assigned to Order=N will attempt to mine at the same time, causing conflicts and potential chain halts
2. **Block Validation Failures**: Subsequent blocks may fail validation due to miners producing blocks outside their assigned time slots
3. **Consensus Deadlock**: If critical miners (e.g., extra block producer) are assigned duplicate orders, round progression may stall

**Affected Parties**: All network participants are affected as consensus integrity is compromised chain-wide.

**Severity**: High - violates the critical invariant "Correct round transitions and time-slot validation, miner schedule integrity" and can cause chain-wide consensus disruption.

### Likelihood Explanation

**Attacker Capabilities**: Any miner in the current round can exploit this vulnerability when it's their turn to produce the NextRound block.

**Attack Complexity**: Low
- Miner calls `GenerateConsensusTransactions` to obtain a valid NextRoundInput
- Miner modifies the `RealTimeMinersInformation` field to set duplicate `FinalOrderOfNextRound` values
- Miner broadcasts the modified transaction
- The broken validation logic accepts it

**Feasibility Conditions**:
- Attacker must be a valid miner in the current round (normal operational state)
- Attacker's turn to produce the round-terminating block (happens regularly in rotation)
- No additional privileges required beyond being a miner

**Detection Difficulty**: The attack succeeds silently during validation. The corruption only becomes apparent in the next round when multiple miners attempt to mine at the same time slot.

**Probability**: High - the vulnerability is deterministic and can be reliably exploited whenever a malicious miner produces a NextRound block.

### Recommendation

**Code-Level Mitigation**: Fix the distinct count calculation to check `FinalOrderOfNextRound` values instead of `MinerInRound` objects:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Add this line
    .Distinct()
    .Count();
```

**Invariant Checks to Add**:
1. Verify all `FinalOrderOfNextRound` values in range [1, minerCount] are present exactly once
2. Add assertion that no two miners have the same `FinalOrderOfNextRound` value
3. Validate that occupied orders match the expected sequence

**Test Cases**:
1. Test with Round containing duplicate `FinalOrderOfNextRound` values - should fail validation
2. Test with Round missing an order value in the sequence - should fail validation  
3. Test with Round having orders outside valid range - should fail validation
4. Test normal round progression with unique orders - should pass

### Proof of Concept

**Initial State**:
- 5 miners (A, B, C, D, E) in current round
- All miners have produced blocks with `OutValue != null`
- Current round has miners with valid `FinalOrderOfNextRound`: A=1, B=2, C=3, D=4, E=5

**Attack Steps**:
1. Miner E's turn to produce NextRound block arrives
2. E calls `GenerateConsensusTransactions` to get valid NextRoundInput
3. E modifies the transaction data, changing miner C's `FinalOrderOfNextRound` from 3 to 2 (duplicate of B)
4. E broadcasts the modified NextRound transaction
5. Validation runs:
   - `.Distinct()` on 5 different `MinerInRound` objects returns count=5
   - Count of miners with `OutValue != null` = 5  
   - 5 == 5 â†’ validation **PASSES** (incorrectly)
6. Invalid Round is stored via `AddRoundInformation`

**Expected Result**: Validation should fail with "Invalid FinalOrderOfNextRound" due to duplicate order values.

**Actual Result**: Validation passes and stores Round where miners B and C both have Order=2.

**Success Condition**: In the generated next round, both B and C have `Order=2`, violating the unique-order-per-miner invariant and causing mining time slot conflicts.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-17)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-87)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```
