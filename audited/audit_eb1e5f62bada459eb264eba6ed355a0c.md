### Title
Block Producer MEV Exploitation Through Predictable NFT Symbol Number Generation

### Summary
Block producers can predict and manipulate NFT protocol symbol numbers by exploiting the predictable randomness source in `GenerateSymbolNumber()`. Since the function uses the previous block's random hash (which is public at current block production time) combined with deterministic sender addresses, block producers can calculate outcomes for all pending transactions, reorder them to assign favorable "vanity" symbol numbers to themselves or cronies while censoring or delaying transactions that would generate desirable numbers for regular users.

### Finding Description

The vulnerability exists in the `GenerateSymbolNumber()` function [1](#0-0)  which generates NFT protocol symbols used in the `Create()` method [2](#0-1) .

**Root Cause:**

The function retrieves random bytes from the consensus contract using `Context.CurrentHeight.Sub(1)` (height N-1) as the input [3](#0-2) . These random bytes come from `State.RandomHashes[height]` which is set during consensus block production [4](#0-3) .

When a block producer is creating block N, the random hash for block N-1 is already finalized, public, and retrievable via `GetRandomHash()` [5](#0-4) .

The symbol number is generated by:
1. Concatenating hash of sender with hash of random bytes
2. Converting to int64 using `ConvertHashToInt64()` (deterministic operation) [6](#0-5) 

**Why Protections Fail:**

There are no protections against transaction reordering based on calculated outcomes. The randomness is not truly unpredictable at transaction execution timeâ€”it was committed in the previous block. The VRF-based consensus random number generation [7](#0-6)  only prevents manipulation of the random source itself, but doesn't prevent exploitation once the random value is public.

### Impact Explanation

**Harm Occurring:**
Block producers can extract MEV by:
1. **Selective assignment**: Calculate which pending Create transactions will generate "desirable" symbol numbers (low numbers like AR100000000, round numbers, patterns, palindromes)
2. **Front-running**: Submit their own Create transactions before user transactions that would get valuable symbols
3. **Censorship**: Delay or exclude transactions that would generate desirable numbers
4. **Reordering**: Arrange transactions to maximize their own advantage

**Value Extraction:**
While symbol numbers have no on-chain differential value, NFT markets consistently demonstrate real economic value for vanity features:
- Low serial numbers (e.g., CryptoPunks #1-#100 trade at premiums)
- Memorable patterns
- Protocol symbols are permanent identifiers that could have market desirability

**Who Is Affected:**
- Regular users creating NFT protocols lose fair access to desirable symbols
- The NFT marketplace experiences information asymmetry
- Protocol creators face unpredictable symbol assignment based on block producer decisions

**Severity Justification:**
High severity due to:
- Clear exploitation path with minimal cost
- Block producers have inherent capability (no special attack needed)
- Unfair value extraction from protocol-level resource allocation
- Censorship capability affecting protocol operations

### Likelihood Explanation

**Attacker Capabilities:**
Block producers (miners) have:
- Access to pending transaction pool
- Computational resources to calculate hash outcomes for all pending transactions
- Authority to order transactions within their produced blocks
- Knowledge of previous block's random hash (public information)

**Attack Complexity:**
LOW - The attack requires:
1. Read `State.RandomHashes[currentHeight - 1]` from consensus contract
2. For each pending Create transaction, compute: `Hash(Hash(sender) + Hash(randomBytes))`
3. Evaluate symbol number desirability
4. Reorder transactions or inject own transactions accordingly

**Feasibility Conditions:**
- Block producer is producing a block (normal operation)
- There are pending NFT Create transactions
- No additional preconditions required

**Detection/Operational Constraints:**
- Transaction reordering is normal block producer behavior and difficult to distinguish from legitimate prioritization
- No on-chain mechanism to prove MEV extraction occurred
- Economic incentive exists whenever symbol number scarcity has perceived value

**Probability:**
HIGH - Block producers have continuous opportunity during every block they produce containing NFT Create transactions. The calculation cost is negligible compared to potential value extraction.

### Recommendation

**Immediate Mitigation:**
Implement a commit-reveal scheme for NFT symbol generation:

1. **Commit Phase**: User submits Create transaction with a commitment hash: `Hash(secret || sender || timestamp)`
2. **Reveal Phase**: After N blocks (e.g., 10 blocks), user submits reveal transaction with the secret
3. **Generation Phase**: Combine the reveal secret with FUTURE block randomness: `GetRandomBytes(revealHeight + M)` where M > 0

This ensures:
- Block producers cannot predict outcomes at commit time
- The random source is from a future block not yet produced
- Users must follow through with reveals (or lose commitment deposit)

**Alternative Approach:**
Use multiple block hashes for entropy:
```
var futureBlockHash = GetRandomBytes(Context.CurrentHeight + DelayBlocks);
```
But this requires async/delayed processing.

**Code-Level Changes:**
In `NFTContract_Helpers.cs`, modify `GenerateSymbolNumber()`:
- Replace single-block randomness with multi-block or future-block randomness
- Add commit-reveal logic if immediate symbol assignment is required
- Consider using VDF (Verifiable Delay Function) outputs if available

**Invariant Checks:**
- Assert that randomness source cannot be known at transaction submission time
- Verify symbol generation includes entropy from blocks produced AFTER user's commitment

**Test Cases:**
1. Test that two transactions with same sender in consecutive blocks get different symbols
2. Verify block producer cannot predict symbol at transaction submission
3. Test commit-reveal flow handles edge cases (missed reveals, reverts)

### Proof of Concept

**Initial State:**
- Block N-1 has been produced with RandomHash = `H_{N-1}`
- Alice submits Create transaction to create Art NFT protocol
- Bob (block producer) is producing block N

**Exploitation Steps:**

1. **Bob observes pending transaction**:
   - Alice's transaction: `Create(NftType="Art", ...)`
   - Alice's address: `0xAlice...`

2. **Bob calculates Alice's symbol**:
   ```
   randomBytes = GetRandomBytes(N-1) = H_{N-1}  // Public, already finalized
   senderHash = Hash(0xAlice...)
   combinedHash = Hash(senderHash || Hash(randomBytes))
   symbolNumber = ConvertHashToInt64(combinedHash, 100000000, 1000000000)
   // Result: symbolNumber = 123456789
   aliceSymbol = "AR123456789"
   ```

3. **Bob calculates his own potential symbol**:
   ```
   bobSenderHash = Hash(0xBob...)
   bobCombinedHash = Hash(bobSenderHash || Hash(H_{N-1}))
   bobSymbolNumber = ConvertHashToInt64(bobCombinedHash, 100000000, 1000000000)
   // Result: bobSymbolNumber = 100000001  // Highly desirable low number!
   bobSymbol = "AR100000001"
   ```

4. **Bob front-runs Alice**:
   - Bob inserts his own Create transaction BEFORE Alice's in block N
   - Bob gets symbol "AR100000001"
   - Alice's transaction executes after, gets "AR123456789"
   - Bob can then sell/market his protocol with the premium "low number" symbol

**Expected vs Actual Result:**
- **Expected (fair)**: Random, unpredictable symbol assignment
- **Actual**: Block producer can predict and manipulate symbol distribution

**Success Condition:**
Block producer successfully obtains desirable symbol number by exploiting predictable randomness and transaction ordering control, while regular users receive less desirable symbols.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L65-85)
```csharp
    private long GenerateSymbolNumber()
    {
        var length = GetCurrentNumberLength();
        var from = 1L;
        for (var i = 1; i < length; i++) from = from.Mul(10);

        var randomBytes = State.RandomNumberProviderContract.GetRandomBytes.Call(new Int64Value
        {
            Value = Context.CurrentHeight.Sub(1)
        }.ToBytesValue());
        var randomHash =
            HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(Context.Sender),
                HashHelper.ComputeFrom(randomBytes));
        long randomNumber;
        do
        {
            randomNumber = Context.ConvertHashToInt64(randomHash, from, from.Mul(10));
        } while (State.IsCreatedMap[randomNumber]);

        return randomNumber;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L14-73)
```csharp
    public override StringValue Create(CreateInput input)
    {
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
        MakeSureTokenContractAddressSet();
        MakeSureRandomNumberProviderContractAddressSet();
        var symbol = GetSymbol(input.NftType);
        var tokenExternalInfo = GetTokenExternalInfo(input);
        var creator = input.Creator ?? Context.Sender;
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });

        return new StringValue
        {
            Value = symbol
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L75-81)
```csharp
        var previousRandomHash = State.RandomHashes[Context.CurrentHeight.Sub(1)] ?? Hash.Empty;
        Assert(
            Context.ECVrfVerify(Context.RecoverPublicKey(), previousRandomHash.ToByteArray(),
                randomNumber.ToByteArray(), out var beta), "Failed to verify random number.");
        var randomHash = Hash.LoadFromByteArray(beta);
        State.RandomHashes[Context.CurrentHeight] = randomHash;
        Context.LogDebug(() => $"New random hash generated: {randomHash} - height {Context.CurrentHeight}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L117-122)
```csharp
    public override Hash GetRandomHash(Int64Value input)
    {
        Assert(input.Value > 1, "Invalid block height.");
        Assert(Context.CurrentHeight >= input.Value, "Block height not reached.");
        return State.RandomHashes[input.Value] ?? Hash.Empty;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L169-178)
```csharp
    public long ConvertHashToInt64(Hash hash, long start = 0, long end = long.MaxValue)
    {
        if (start < 0 || start > end) throw new ArgumentException("Incorrect arguments.");

        var range = end.Sub(start);
        var bigInteger = new BigInteger(hash.Value.ToByteArray());
        // This is safe because range is long type.
        var index = Math.Abs((long)(bigInteger % range));
        return index.Add(start);
    }
```
