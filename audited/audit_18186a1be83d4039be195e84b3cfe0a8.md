### Title
Predictable Extra Block Producer Selection via Public Key First Byte Manipulation

### Summary
An attacker can brute-force ECDSA key pairs to find a public key with a high first byte (0xFF) and register it via `AnnounceElectionFor` without validation, guaranteeing they become the extra block producer in the first round of each term. This provides an unfair economic advantage through additional block production rewards compared to equally-voted miners.

### Finding Description

**Root Cause:**
The vulnerability exists in the deterministic sorting mechanism used to assign the extra block producer role: [1](#0-0) 

Miners are sorted by the first byte of their public key in descending order, and the first miner in this sorted list is designated as the extra block producer: [2](#0-1) 

**Entry Point Without Validation:**
The `AnnounceElectionFor` method allows anyone to register an arbitrary public key string without cryptographic validation or ownership verification: [3](#0-2) 

The method only converts the hex string to bytes and creates an address, but does not verify:
- That the pubkey is a valid ECDSA public key
- That the caller controls the private key for this public key
- That the first byte hasn't been deliberately crafted

**Execution Path:**
1. Attacker generates valid ECDSA key pairs until finding one with first byte = 0xFF
2. Calls `AnnounceElectionFor` with this crafted pubkey
3. Pubkey is added to candidates without validation: [4](#0-3) 

4. If elected, attacker's pubkey sorts first and becomes extra block producer in round 1 of each term

### Impact Explanation

**Economic Impact:**
The extra block producer produces one additional block to terminate each round: [5](#0-4) 

This translates to higher rewards through the Basic Miner Reward distribution mechanism: [6](#0-5) 

Rewards are calculated based on `ProducedBlocks`, giving the attacker more shares than equally-voted miners.

**Scope:**
The advantage is limited to round 1 of each term. Subsequent rounds use signature-based randomization: [7](#0-6) 

**Affected Parties:**
- Legitimate miners with equivalent votes receive proportionally less rewards
- Protocol fairness is compromised as consensus role assignment becomes predictable

### Likelihood Explanation

**Attacker Capabilities:**
- Brute-forcing ~256 ECDSA key pairs to find first byte = 0xFF is computationally trivial
- Public key generation can be done offline with standard cryptographic libraries: [8](#0-7) 

**Feasibility Conditions:**
- Attacker must get elected (requires community votes) - this is the main barrier but realistic for well-funded attackers
- No technical barriers once elected
- No detection mechanism exists for crafted public keys

**Execution Practicality:**
- Entry point is a public method accessible to anyone
- No authorization checks beyond economic deposit: [9](#0-8) 

- Attack is repeatable every term (typically 7 days)

### Recommendation

**1. Add Public Key Validation:**
Verify that submitted public keys in `AnnounceElectionFor` are valid ECDSA secp256k1 public keys and reject malformed inputs. Use the existing cryptographic validation from `CryptoHelper.RecoverPublicKey` or `Secp256k1Curve.DeserializePoint`.

**2. Implement Randomized Sorting:**
Replace deterministic first-byte sorting with cryptographically secure randomization using verifiable random functions (VRF) or the existing signature-based mechanism used for subsequent rounds: [10](#0-9) 

**3. Add Ownership Verification:**
Require proof that the caller of `AnnounceElectionFor` controls the private key corresponding to the submitted public key, similar to `AnnounceElection`: [11](#0-10) 

**4. Test Cases:**
- Verify rejection of invalid public key formats
- Test that manipulated first bytes don't provide selection advantages
- Ensure randomization produces uniform distribution across all miners

### Proof of Concept

**Initial State:**
- Election contract initialized
- Multiple candidates with similar vote counts

**Attack Steps:**
1. **Generate Crafted Key Pair:**
   ```
   Loop until public_key[0] == 0xFF:
       key_pair = GenerateKeyPair()
   Save key_pair for block signing
   ```

2. **Register Candidate:**
   ```
   Call AnnounceElectionFor(pubkey=crafted_pubkey, admin=attacker_address)
   Lock required deposit
   ```

3. **Get Elected:**
   ```
   Obtain sufficient votes to be in top N candidates
   Wait for term transition
   ```

4. **Verify Extra Block Producer Status:**
   ```
   In first round of new term, check miner list sorting
   Attacker's pubkey appears first (0xFF > all others)
   IsExtraBlockProducer flag set to true
   ```

5. **Gain Advantage:**
   ```
   Produce extra block in round 1
   ProducedBlocks counter incremented
   Receive higher share in reward distribution
   ```

**Expected vs Actual:**
- **Expected:** Extra block producer selection should be unpredictable/randomized
- **Actual:** Deterministic sorting allows manipulation through crafted public keys
- **Success Condition:** Attacker consistently becomes extra block producer in round 1 of every term with higher reward shares than equally-voted peers

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L15-19)
```csharp
        var sortedMiners =
            (from obj in Pubkeys
                    .ToDictionary<ByteString, string, int>(miner => miner.ToHex(), miner => miner[0])
                orderby obj.Value descending
                select obj.Key).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L27-28)
```csharp
            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L93-96)
```csharp
    public override Empty AnnounceElection(Address input)
    {
        var recoveredPublicKey = Context.RecoverPublicKey();
        AnnounceElection(recoveredPublicKey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L121-126)
```csharp
    public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
    {
        var pubkey = input.Pubkey;
        var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(pubkey);
        var address = Address.FromPublicKey(pubkeyBytes);
        AnnounceElection(pubkeyBytes);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L132-133)
```csharp
        LockCandidateNativeToken();
        AddCandidateAsOption(pubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L144-174)
```csharp
    private void AnnounceElection(byte[] pubkeyBytes)
    {
        var pubkey = pubkeyBytes.ToHex();
        var pubkeyByteString = ByteString.CopyFrom(pubkeyBytes);

        Assert(!State.InitialMiners.Value.Value.Contains(pubkeyByteString),
            "Initial miner cannot announce election.");

        var candidateInformation = State.CandidateInformationMap[pubkey];

        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
        else
        {
            Assert(!IsPubkeyBanned(pubkey), "This candidate already banned before.");
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey,
                AnnouncementTransactionId = Context.OriginTransactionId,
                IsCurrentCandidate = true
            };
        }

        State.Candidates.Value.Value.Add(pubkeyByteString);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-72)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
    /// </summary>
    /// <param name="miningInterval"></param>
    /// <returns></returns>
    public int TotalMilliseconds(int miningInterval = 0)
    {
        if (miningInterval == 0) miningInterval = GetMiningInterval();

        return RealTimeMinersInformation.Count * miningInterval + miningInterval;
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L777-822)
```csharp
    private void UpdateBasicMinerRewardWeights(IReadOnlyCollection<Round> previousTermInformation)
    {
        if (previousTermInformation.First().RealTimeMinersInformation != null)
            State.ProfitContract.RemoveBeneficiaries.Send(new RemoveBeneficiariesInput
            {
                SchemeId = State.BasicRewardHash.Value,
                Beneficiaries =
                {
                    GetAddressesFromCandidatePubkeys(previousTermInformation.First().RealTimeMinersInformation.Keys)
                }
            });

        var averageProducedBlocksCount = CalculateAverage(previousTermInformation.Last().RealTimeMinersInformation
            .Values
            .Select(i => i.ProducedBlocks).ToList());
        // Manage weights of `MinerBasicReward`
        State.ProfitContract.AddBeneficiaries.Send(new AddBeneficiariesInput
        {
            SchemeId = State.BasicRewardHash.Value,
            EndPeriod = previousTermInformation.Last().TermNumber,
            BeneficiaryShares =
            {
                previousTermInformation.Last().RealTimeMinersInformation.Values.Select(i =>
                {
                    long shares;
                    if (State.IsReplacedEvilMiner[i.Pubkey])
                    {
                        // The new miner may have more shares than his actually contributes, but it's ok.
                        shares = i.ProducedBlocks;
                        // Clear the state asap.
                        State.IsReplacedEvilMiner.Remove(i.Pubkey);
                    }
                    else
                    {
                        shares = CalculateShares(i.ProducedBlocks, averageProducedBlocksCount);
                    }

                    return new BeneficiaryShare
                    {
                        Beneficiary = GetProfitsReceiver(i.Pubkey),
                        Shares = shares
                    };
                })
            }
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** src/AElf.Cryptography/CryptoHelper.cs (L61-87)
```csharp
        public static ECKeyPair GenerateKeyPair()
        {
            try
            {
                Lock.EnterWriteLock();
                var privateKey = new byte[32];
                var secp256K1PubKey = new byte[64];

                // Generate a private key.
                var rnd = RandomNumberGenerator.Create();
                do
                {
                    rnd.GetBytes(privateKey);
                } while (!Secp256K1.SecretKeyVerify(privateKey));

                if (!Secp256K1.PublicKeyCreate(secp256K1PubKey, privateKey))
                    throw new InvalidPrivateKeyException("Create public key failed.");
                var pubKey = new byte[Secp256k1.SERIALIZED_UNCOMPRESSED_PUBKEY_LENGTH];
                if (!Secp256K1.PublicKeySerialize(pubKey, secp256K1PubKey))
                    throw new PublicKeyOperationException("Serialize public key failed.");
                return new ECKeyPair(privateKey, pubKey);
            }
            finally
            {
                Lock.ExitWriteLock();
            }
        }
```
