### Title
Unbounded Loop in GetAllProfitsMap() Causes View Call DoS for Users with Many Profit Details

### Summary
The `GetAllProfitsMap()` view method in the Profit contract iterates over all available profit details without applying the 10-detail limit that `ClaimProfits()` uses. Users who accumulate many profit details through repeated participation in TokenHolder, Election, or other profit schemes will experience view call failures when attempting to query their profit amounts, effectively preventing them from checking their balances.

### Finding Description

The vulnerability exists in the `GetAllProfitsMap()` private method that is called by multiple public view methods: [1](#0-0) 

The loop at line 125 iterates over **all** `availableDetails.Count` items without any limit. For each iteration, it calls `ProfitAllPeriods()` at line 130 to calculate profits across all unclaimed periods. The limit calculated at line 120 (`profitableDetailCount`) is only used to control which details receive the claimable profits calculation (lines 132-134), but does NOT limit the outer loop itself. [2](#0-1) 

In contrast, the `ClaimProfits()` method properly applies this limit to its loop bound: [3](#0-2) 

**How profit details accumulate:**
- Each call to `AddBeneficiary()` adds a new `ProfitDetail` to the beneficiary's collection: [4](#0-3) 

- Users naturally accumulate multiple profit details through normal usage in TokenHolder (staking/unstaking) and Election (voting) contracts, as evidenced by tests expecting multiple details: [5](#0-4) 

- Cleanup only removes fully expired details past their due period: [6](#0-5) 

**Computational complexity:**
Each iteration calls `ProfitAllPeriods()` which contains an inner loop over periods with state reads: [7](#0-6) 

If a beneficiary has `n` profit details and the scheme has run for `m` periods, the view call performs up to `n × m` state reads.

### Impact Explanation

**Affected view methods:**
- `GetProfitAmount()` (line 64)
- `GetAllProfitAmount()` (line 74) 
- `GetProfitsMap()` (line 90)
- `GetAllProfitsMap()` (line 98) [8](#0-7) [9](#0-8) [10](#0-9) 

**Concrete harm:**
- Users with 100+ profit details attempting to query their balances will experience gas exhaustion or timeout
- Wallets and UIs cannot display profit information for affected users
- Users cannot determine if they should call `ClaimProfits()` or verify their profit amounts
- Affects availability of critical read-only operations for profit scheme participants

**Who is affected:**
- Active participants in TokenHolder schemes who frequently stake/unstake
- Voters in Election contracts who vote multiple times
- Any beneficiary in long-running profit schemes (1000+ periods)

**Quantified example:**
A user with 100 profit details in a scheme that has run for 1000 periods could trigger 100,000 state reads in a single view call, far exceeding typical gas limits.

### Likelihood Explanation

**Attack complexity: Low**
- No special privileges required beyond normal contract participation
- Natural accumulation through legitimate usage
- Public view methods directly callable by anyone

**Realistic scenarios:**
1. **Natural accumulation:** A user who stakes tokens in TokenHolder 50 times over 1 year accumulates 50+ profit details
2. **Long-running schemes:** Core AElf schemes (consensus rewards, treasury) run for thousands of periods
3. **Malicious amplification:** A compromised scheme manager could call `AddBeneficiary()` repeatedly for target beneficiaries: [11](#0-10) 

**Feasibility conditions:**
- Already occurring in production: TokenHolder and Election contracts regularly create multiple profit details per user
- No mechanism prevents accumulation beyond expired detail cleanup
- View call gas limits are finite and will be exceeded with sufficient details

**Detection constraints:**
- View call failures appear as timeout/out-of-gas errors
- Difficult to distinguish from network issues
- Users may not understand why their queries fail

### Recommendation

Apply the same loop bound limit used in `ClaimProfits()` to the `GetAllProfitsMap()` method:

```csharp
// Line 125 - Change from:
for (var i = 0; i < availableDetails.Count; i++)

// To:
var limitedDetailCount = Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
for (var i = 0; i < limitedDetailCount; i++)
```

For the `allProfitsMap` calculation (line 130), also limit the iteration to avoid DoS while still providing accurate total profit information. Consider:

1. **Option 1:** Return only the claimable profits in view calls, requiring users to claim to see remaining profits
2. **Option 2:** Add a pagination parameter to `GetAllProfitsMapInput` allowing users to query details in batches
3. **Option 3:** Cache calculated profit amounts in state to avoid repeated computation

**Additional mitigations:**
- Add a maximum profit details limit per beneficiary (e.g., 50-100 details)
- Implement aggressive cleanup of old details earlier than current due period logic
- Add monitoring/alerts when beneficiaries exceed threshold detail counts

**Test cases to add:**
- Test view call gas consumption with 100+ profit details
- Verify pagination or batching works correctly
- Test that limit applies uniformly across all calling paths

### Proof of Concept

**Initial state:**
1. Create a profit scheme with `ProfitReceivingDuePeriodCount = 10`
2. Register a target beneficiary address

**Attack steps:**
1. Scheme manager calls `AddBeneficiary()` 200 times for the same beneficiary with different `EndPeriod` values:
```
for i = 1 to 200:
    AddBeneficiary(beneficiary=victim, shares=1, endPeriod=1000+i)
```

2. Distribute profits for 100 periods:
```
for period = 1 to 100:
    DistributeProfits(schemeId, period)
```

3. Victim or any user calls:
```
GetProfitAmount(schemeId, beneficiary=victim, symbol="ELF")
```

**Expected result:** 
View call returns the profit amount for the beneficiary

**Actual result:**
View call exceeds gas limit or times out due to iterating 200 profit details × 100 periods = 20,000 state reads

**Success condition:**
The view call fails with timeout/out-of-gas error, preventing the victim from querying their profit balance. The `ClaimProfits()` method still works (limited to 10 details per call), but users cannot verify their balances before claiming.

### Citations

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L62-70)
```csharp
    public override Int64Value GetProfitAmount(GetProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);

        return new Int64Value
        {
            Value = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var value) ? value : 0
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L72-86)
```csharp
    public override GetAllProfitAmountOutput GetAllProfitAmount(GetAllProfitAmountInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary, input.Symbol);
        return new GetAllProfitAmountOutput
        {
            AllProfitAmount = allProfitsMapResult.AllProfitsMap.TryGetValue(input.Symbol, out var allProfitAmount)
                ? allProfitAmount
                : 0,
            OneTimeClaimableProfitAmount =
                allProfitsMapResult.OneTimeClaimableProfitsMap.TryGetValue(input.Symbol,
                    out var oneTimeClaimableProfitAmount)
                    ? oneTimeClaimableProfitAmount
                    : 0
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L88-96)
```csharp
    public override ReceivedProfitsMap GetProfitsMap(ClaimProfitsInput input)
    {
        var allProfitsMapResult = GetAllProfitsMap(input.SchemeId, input.Beneficiary);

        return new ReceivedProfitsMap
        {
            Value = { allProfitsMapResult.AllProfitsMap }
        };
    }
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L119-121)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, availableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ViewMethods.cs (L125-135)
```csharp
        for (var i = 0; i < availableDetails.Count; i++)
        {
            var profitDetail = availableDetails[i];
            if (profitDetail.LastProfitPeriod == 0) profitDetail.LastProfitPeriod = profitDetail.StartPeriod;
            
            var totalProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, profitDetail.EndPeriod.Sub(profitDetail.LastProfitPeriod),true, symbol);
            AddProfitToDict(allProfitsDict, totalProfitsDictForEachProfitDetail);
            if(i >= profitableDetailCount) continue;
            var claimableProfitsDictForEachProfitDetail = ProfitAllPeriods(scheme, profitDetail, beneficiary, maxProfitReceivingPeriodCount,true, symbol);
            AddProfitToDict(claimableProfitsDict, claimableProfitsDictForEachProfitDetail);
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L194-201)
```csharp
        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L204-207)
```csharp
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-777)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
        // Only can get profit from last profit period to actual last period (profit.CurrentPeriod - 1),
        // because current period not released yet.
        for (var i = 0; i < profitableDetailCount; i++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L860-871)
```csharp
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
            {
                var periodToPrint = period;
                var detailToPrint = profitDetail;
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L192-192)
```csharp
        profitAmount.Details.Count.ShouldBe(2);
```
