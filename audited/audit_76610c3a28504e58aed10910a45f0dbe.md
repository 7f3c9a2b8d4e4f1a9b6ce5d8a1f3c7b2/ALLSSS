### Title
Consensus DoS via Uncaught Exception During Secret Sharing Reconstruction After Miner Replacement

### Summary
The `RevealSharedInValues()` function materializes a LINQ Select query that performs lookups using `First()` without handling the case where referenced miners have been replaced mid-round. When the Election Contract replaces a miner via `RecordCandidateReplacement()`, the old miner's public key is removed from the round's miner list, but existing `DecryptedPieces` entries in other miners' data still reference the old key. This causes `First()` to throw `InvalidOperationException` during the next round transition, preventing consensus progression.

### Finding Description

The vulnerable code is located in the `RevealSharedInValues()` method: [1](#0-0) 

The Select query uses `First()` with a predicate to look up miners by their `Pubkey` field. The `First()` method throws `InvalidOperationException` if no element satisfies the condition.

The root cause is in the miner replacement mechanism: [2](#0-1) 

When `RecordCandidateReplacement()` is called by the Election Contract, it removes the old miner from `RealTimeMinersInformation` and adds the new miner. However, it does NOT update `DecryptedPieces` entries in other miners' information that contain keys referencing the old miner's public key.

The `DecryptedPieces` are populated through these validated paths: [3](#0-2) [4](#0-3) 

Both paths add the sender's public key as a KEY in another miner's `DecryptedPieces` map. These keys remain even after `RecordCandidateReplacement()` removes the miner.

### Impact Explanation

**Operational Impact - Consensus DoS:**
- When `RevealSharedInValues()` is called during the `NextRound` transition, the `InvalidOperationException` causes the entire `GetConsensusExtraDataForNextRound()` method to fail
- This prevents the extra block producer from generating the next round's consensus data
- The blockchain cannot progress to the next round, halting block production
- All validators are affected as consensus cannot advance

**Severity:** This is a critical consensus integrity issue that can completely halt the blockchain. While rated "Low" in the original question, the actual impact is a complete denial-of-service of the consensus mechanism.

### Likelihood Explanation

**Likelihood: Medium to High**

**Entry Point:** The `RecordCandidateReplacement()` method is a legitimate public function: [5](#0-4) 

**Attacker Capabilities:** 
- No direct attacker action is required
- The Election Contract calls this method as part of normal validator replacement operations
- This can occur naturally when evil miners are detected or validators are replaced through governance

**Preconditions:**
1. Secret sharing must be enabled (checked at line 254 of `ProcessUpdateValue` and line 122 of `GetConsensusExtraDataToPublishOutValue`)
2. A miner must be replaced mid-round via `RecordCandidateReplacement()`
3. The replaced miner must have previously submitted `DecryptedPieces` to other miners in that round
4. A `NextRound` transition must occur after the replacement

**Execution Practicality:** All steps are part of normal consensus operations. The AElf election system supports mid-term miner replacements for poorly performing or malicious validators, making this scenario realistic.

**Detection:** The exception would be visible in node logs when the extra block producer attempts to generate the next round header.

### Recommendation

**Code-Level Mitigation:**

1. **Immediate Fix:** In `RevealSharedInValues()`, replace `First()` with `FirstOrDefault()` and handle null cases:

```csharp
var orders = anotherMinerInPreviousRound.DecryptedPieces
    .Select((t, i) => {
        var key = anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i];
        var miner = previousRound.RealTimeMinersInformation.Values
            .FirstOrDefault(m => m.Pubkey == key);
        return miner?.Order ?? -1;
    })
    .Where(order => order != -1)
    .ToList();
```

2. **Root Cause Fix:** Update `RecordCandidateReplacement()` to clean up stale `DecryptedPieces` references:

```csharp
// After line 146, add:
foreach (var minerInfo in currentRound.RealTimeMinersInformation.Values)
{
    if (minerInfo.DecryptedPieces.ContainsKey(input.OldPubkey))
    {
        var piece = minerInfo.DecryptedPieces[input.OldPubkey];
        minerInfo.DecryptedPieces.Remove(input.OldPubkey);
        minerInfo.DecryptedPieces[input.NewPubkey] = piece;
    }
}
```

**Invariant to Add:**
- All keys in `DecryptedPieces` maps must correspond to valid miners in the same round's `RealTimeMinersInformation`

**Test Cases:**
1. Test miner replacement mid-round with active secret sharing
2. Verify `NextRound` transition succeeds after replacement
3. Test with replaced miner having provided multiple `DecryptedPieces`
4. Test edge case where replaced miner is the extra block producer

### Proof of Concept

**Initial State:**
- Round N with miners: `[MinerA, MinerB, MinerC]`
- Secret sharing enabled
- Round N in progress

**Attack Sequence:**

1. **Block X in Round N:** MinerA produces block, submits `UpdateValueInput` with `DecryptedPieces` for MinerB
   - `PerformSecretSharing()` executes
   - MinerB's `DecryptedPieces` now contains: `{"MinerA": <bytes>}`

2. **Block X+1 in Round N:** Election Contract detects MinerA as evil node, calls:
   ```
   RecordCandidateReplacement(OldPubkey: "MinerA", NewPubkey: "MinerD")
   ```
   - MinerA removed from Round N
   - MinerD added to Round N
   - MinerB's `DecryptedPieces` still contains key "MinerA"

3. **Round N Completion:** MinerC (extra block producer) attempts to produce NextRound block
   - Calls `GetConsensusExtraDataForNextRound()`
   - Executes `RevealSharedInValues(currentRound=N, ...)`
   - Retrieves `previousRound` = Round N-1
   - Iterates MinerB from previousRound
   - Executes Select materialization at line 44
   - Attempts: `previousRound.RealTimeMinersInformation.Values.First(m => m.Pubkey == "MinerA")`
   - **Result:** `InvalidOperationException` - "MinerA" not found in Round N
   - Transaction fails, NextRound cannot be created

**Expected vs Actual:**
- **Expected:** Round transition succeeds, consensus continues
- **Actual:** Exception thrown, consensus halted, blockchain stuck at Round N

**Success Condition:** The NextRound transaction fails with an uncaught exception, preventing any further block production until the issue is resolved through manual intervention or chain restart.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-44)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L143-146)
```csharp
        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;
```
