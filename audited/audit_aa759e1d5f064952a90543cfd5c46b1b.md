# Audit Report

## Title
Malicious Miner Can Set Duplicate Mining Orders via TuneOrderInformation, Breaking Next Round Generation

## Summary
A malicious miner can exploit the lack of validation on the `TuneOrderInformation` field in `UpdateValueInput` to set multiple miners' `FinalOrderOfNextRound` to identical values. When `GenerateNextRoundInformation` creates the next round, these duplicate values are directly assigned as `Order` values, causing multiple miners to have identical mining orders and expected mining times, fundamentally breaking the AEDPoS consensus mechanism.

## Finding Description

The AEDPoS consensus contract allows any active miner to arbitrarily modify other miners' `FinalOrderOfNextRound` values through the `TuneOrderInformation` field without proper validation. This breaks the core consensus invariant that each miner must have a unique mining order.

**Attack Execution Path:**

1. A malicious miner produces a block and calls the public `UpdateValue` method with a crafted `UpdateValueInput` containing malicious `TuneOrderInformation`. [1](#0-0) 

2. The `ProcessUpdateValue` method directly applies the malicious tune orders without any validation, setting each specified miner's `FinalOrderOfNextRound` to the attacker's chosen value (e.g., all set to 1). [2](#0-1) 

3. The `UpdateValueValidationProvider` only validates `OutValue`, `Signature`, and `PreviousInValue`, completely ignoring `TuneOrderInformation` contents. [3](#0-2) 

4. When `GenerateNextRoundInformation` is called to transition to the next round, it directly reads each miner's `FinalOrderOfNextRound` from the current round and assigns it as their `Order` in the next round, with no uniqueness validation. [4](#0-3) 

5. The `ExpectedMiningTime` for each miner is calculated based on their `Order`, meaning all miners with `Order = 1` will have identical expected mining times. [5](#0-4) 

6. The `NextRoundMiningOrderValidationProvider`, which should detect duplicate orders, uses `.Distinct()` on `MinerInRound` objects instead of on the `FinalOrderOfNextRound` values themselves. This counts distinct miner objects (which are always distinct by reference), not distinct order values, failing to detect the duplicates. [6](#0-5) 

## Impact Explanation

**Severity: HIGH - Complete Consensus Disruption**

When multiple miners have identical `Order` values in a round:
- All affected miners share the same `ExpectedMiningTime`
- Multiple miners attempt to produce blocks simultaneously at the same time slot
- The consensus mechanism's fundamental assumption of sequential, unique mining orders is violated
- Time slot validation becomes non-deterministic
- The chain may halt if no clear block producer can be determined
- Fork risk if different nodes accept different blocks from miners with the same order

This affects the entire blockchain network:
- All network participants depending on consensus
- All miners unable to produce valid blocks in the corrupted round
- All pending transactions blocked from inclusion
- Potential permanent chain halt requiring manual intervention

## Likelihood Explanation

**Feasibility: HIGH - Easily Exploitable by Any Miner**

**Attacker Requirements:**
- Must be an active miner in the current round (standard consensus participant)
- No special privileges required beyond normal miner status
- Does not require compromising other nodes, keys, or contracts

**Attack Complexity: LOW**
- Deterministic attack requiring no timing dependencies
- Simple payload construction: map all miner pubkeys to the same order value in `TuneOrderInformation`
- Can be executed in any round when the attacker has mining rights
- Impact is immediate and guaranteed upon next round generation

**Detection: DIFFICULT**
- The attack is not detectable until the next round is generated
- No warning signs in current round state
- By the time the issue manifests, the state is already corrupted

## Recommendation

**Fix 1: Validate TuneOrderInformation for uniqueness**

Add validation in `UpdateValueValidationProvider` or a new dedicated validator:
- Check that all `FinalOrderOfNextRound` values across all miners remain unique after applying `TuneOrderInformation`
- Reject the transaction if duplicates would be created

**Fix 2: Fix NextRoundMiningOrderValidationProvider**

Change the validation to check uniqueness of order values, not object distinctness:
```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Project to order values
    .Distinct()
    .Count();
```

**Fix 3: Add defensive check in GenerateNextRoundInformation**

Before assigning orders, verify that all `FinalOrderOfNextRound` values from the current round are unique, and revert if duplicates are detected.

## Proof of Concept

```csharp
// This test demonstrates the vulnerability
// In a test file: AEDPoSContract_DuplicateOrderAttack_Test.cs

[Fact]
public async Task MaliciousMiner_CanSetDuplicateOrders_ViaT uneOrderInformation()
{
    // Setup: Initialize consensus with multiple miners
    const int minersCount = 5;
    var minersKeys = GenerateMinerKeys(minersCount);
    await InitializeConsensusContract(minersKeys);
    
    // Attacker is first miner
    var attackerKey = minersKeys[0];
    var victimKeys = minersKeys.Skip(1).ToList();
    
    // Attacker produces a block with malicious TuneOrderInformation
    var maliciousInput = new UpdateValueInput
    {
        OutValue = GenerateOutValue(),
        Signature = GenerateSignature(),
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = 1,
        TuneOrderInformation = 
        {
            // Set ALL other miners to Order = 1
            { victimKeys[0].ToHex(), 1 },
            { victimKeys[1].ToHex(), 1 },
            { victimKeys[2].ToHex(), 1 },
            { victimKeys[3].ToHex(), 1 }
        }
    };
    
    // Attack succeeds - UpdateValue accepts the malicious input
    var result = await AEDPoSContractStub.UpdateValue.SendAsync(maliciousInput);
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Verify: All victim miners now have FinalOrderOfNextRound = 1
    var currentRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    foreach (var victimKey in victimKeys)
    {
        var minerInfo = currentRound.RealTimeMinersInformation[victimKey.ToHex()];
        minerInfo.FinalOrderOfNextRound.ShouldBe(1); // All have same order!
    }
    
    // Generate next round - multiple miners will have Order = 1
    await ProduceBlocksUntilRoundEnd();
    var nextRound = await AEDPoSContractStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Verify: Multiple miners have identical Order and ExpectedMiningTime
    var minersWithOrder1 = nextRound.RealTimeMinersInformation.Values
        .Where(m => m.Order == 1)
        .ToList();
    
    minersWithOrder1.Count.ShouldBeGreaterThan(1); // Multiple miners with same order!
    
    // All have identical expected mining times - consensus is broken
    var firstTime = minersWithOrder1[0].ExpectedMiningTime;
    minersWithOrder1.All(m => m.ExpectedMiningTime == firstTime).ShouldBeTrue();
}
```

**Notes:**
- The vulnerability exists in production consensus contract code
- No privileged access required - any miner can execute this attack
- The broken `.Distinct()` validation allows the attack to succeed undetected
- This fundamentally breaks the consensus mechanism's ordering guarantees

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```
