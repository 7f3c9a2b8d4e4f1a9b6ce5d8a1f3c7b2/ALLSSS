### Title
Continuous Blocks Validation Bypasses Severe Status Limit Due to Stale IrreversibleBlockHeight-Based Threshold

### Summary
The `ContinuousBlocksValidationProvider` does not directly consider `IrreversibleBlockHeight` (LIB) during validation, instead relying on a stale `LatestPubkeyToTinyBlocksCount` value. When blockchain status transitions from Normal to Severe (due to LIB lagging), miners can produce more consecutive blocks than the Severe status limit of 1, defeating the safety mechanism designed to prevent forks during critical network conditions.

### Finding Description
The vulnerability exists in the interaction between validation and state update logic: [1](#0-0) 

The validation only checks if `LatestPubkeyToTinyBlocksCount.BlocksCount < 0`, without considering current LIB status. [2](#0-1) 

The validation context retrieves the `LatestPubkeyToTinyBlocksCount` from state, which was calculated during the **previous** block's processing. [3](#0-2) 

After block execution, `GetMaximumBlocksCount()` is called, which considers LIB to determine blockchain status (Normal/Abnormal/Severe): [4](#0-3) 

In Severe status (R >= R_LIB + 8), the limit is 1 consecutive block per miner. In Normal status, the limit is 8. [5](#0-4) 

The critical flaw: when the **same miner** produces consecutive blocks (line 352-357), `BlocksCount` is only decremented, not recalculated based on the current `GetMaximumBlocksCount()`. When blockchain status changes from Normal (limit=8) to Severe (limit=1), a miner with remaining quota from Normal status can continue producing blocks beyond the Severe limit.

**Root Cause:** The validation uses a threshold (`BlocksCount`) calculated with outdated LIB information, while the actual safety limit has changed due to LIB updates processed in intervening blocks.

### Impact Explanation
**Concrete Harm:** During Severe blockchain status (when LIB is dangerously far behind), the consensus protocol is designed to force frequent round changes by limiting each miner to 1 consecutive block. This vulnerability allows miners to produce 2+ consecutive blocks during Severe status, violating this critical safety mechanism.

**Quantified Damage:**
- A miner entering Severe status with `BlocksCount > 0` from Normal status can produce up to `BlocksCount + 1` consecutive blocks instead of the intended 1 block
- In worst case: 8 blocks carried over from Normal status → miner produces 9 consecutive blocks total, with 8 occurring after Severe status is triggered
- This defeats the fork-prevention mechanism, potentially worsening network split conditions when consensus is already struggling

**Affected Parties:** All network participants suffer from prolonged consensus instability and increased fork risk during critical network conditions.

**Severity Justification:** Medium severity because this directly violates consensus safety invariants during the most critical network conditions (Severe status), but requires specific timing of status transitions to exploit.

### Likelihood Explanation
**Attacker Capabilities:** No special attacker capabilities needed - this occurs naturally during network stress conditions.

**Attack Complexity:** Low - happens automatically when:
1. Network conditions cause LIB to lag significantly (network partitions, slow block propagation)
2. Blockchain status transitions from Normal to Severe
3. A miner is already producing consecutive blocks when the transition occurs

**Feasibility Conditions:**
- Realistic preconditions: Network issues causing LIB lag are common in distributed consensus systems
- No special permissions or collusion required
- Happens during normal mining operations

**Detection/Operational Constraints:** Difficult to detect as it appears as normal block production. The extra blocks are validly signed and pass all other consensus checks.

**Probability:** High - status transitions occur regularly during network stress, and miners naturally produce consecutive blocks. The vulnerability triggers automatically without intentional exploitation.

### Recommendation
**Code-Level Mitigation:**

Modify `ResetLatestProviderToTinyBlocksCount` to check if `GetMaximumBlocksCount()` has decreased and reset accordingly:

```csharp
private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
{
    LatestPubkeyToTinyBlocksCount currentValue;
    if (State.LatestPubkeyToTinyBlocksCount.Value == null)
    {
        currentValue = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = _processingBlockMinerPubkey,
            BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
        };
        State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
    }
    else
    {
        currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
        if (currentValue.Pubkey == _processingBlockMinerPubkey)
        {
            var newCount = currentValue.BlocksCount.Sub(1);
            // If GetMaximumBlocksCount decreased, clamp to new limit
            if (newCount >= minersCountInTheory)
                newCount = minersCountInTheory.Sub(1);
            
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = newCount
            };
        }
        else
        {
            State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = minersCountInTheory.Sub(1)
            };
        }
    }
}
```

**Invariant Checks:**
- Add assertion: `BlocksCount` should never exceed `GetMaximumBlocksCount() - 1` after any update
- Add test: when status transitions to Severe, same miner should be immediately limited to 1 additional block maximum

**Test Cases:**
1. Miner produces 7 blocks in Normal status
2. Status transitions to Severe during 8th block processing
3. Verify miner can produce at most 1 additional block (8th), not 2+ blocks
4. Test all status transition combinations (Normal→Abnormal→Severe and reverse)

### Proof of Concept

**Initial State:**
- Round 20, LIB Round 18
- Status: Normal (20-18=2 < 8)
- `GetMaximumBlocksCount()` = 8
- Miner A is in the miner list

**Step 1: Miner A produces blocks 100-106 (7 blocks)**
- Block 100: Different miner from previous → `BlocksCount = 7`
- Blocks 101-106: Same miner → `BlocksCount` decrements 7→6→5→4→3→2→1

**Step 2: Miner A produces block 107**
- Validation: `BlocksCount = 1` (not < 0) → **PASSES**
- Processing: LIB doesn't advance, but 7 more rounds pass → Round 27
- Status changes: 27-18 = 9 >= 8 → **Severe status**
- `GetMaximumBlocksCount()` now returns 1
- Same miner decrement: `BlocksCount = 0`

**Step 3: Miner A attempts block 108 (8th consecutive block)**
- **Current Status:** Severe (limit should be 1 consecutive block)
- Validation: `BlocksCount = 0` (not < 0) → **PASSES** ✗ (should fail)
- Processing: `BlocksCount = -1`

**Step 4: Miner A attempts block 109**
- Validation: `BlocksCount = -1` (< 0) → **FAILS** ✓

**Expected Result:** In Severe status, miner should produce maximum 1 consecutive block before NextRound.

**Actual Result:** Miner A produced 8 consecutive blocks total (blocks 100-107 in Normal, block 108 in Severe), violating the Severe status limit of 1 consecutive block.

**Success Condition:** The vulnerability is confirmed - a miner can produce 2+ consecutive blocks during Severe status by carrying over quota from Normal status, bypassing the intended safety limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L8-28)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Is sender produce too many continuous blocks?
        var validationResult = new ValidationResult();

        if (validationContext.ProvidedRound.RoundNumber > 2 && // Skip first two rounds.
            validationContext.BaseRound.RealTimeMinersInformation.Count != 1)
        {
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }

        validationResult.Success = true;
        return validationResult;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L52-60)
```csharp
        var validationContext = new ConsensusValidationContext
        {
            BaseRound = baseRound,
            CurrentTermNumber = State.CurrentTermNumber.Value,
            CurrentRoundNumber = State.CurrentRoundNumber.Value,
            PreviousRound = TryToGetPreviousRoundInformation(out var previousRound) ? previousRound : new Round(),
            LatestPubkeyToTinyBlocksCount = State.LatestPubkeyToTinyBlocksCount.Value,
            ExtraData = extraData
        };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L337-365)
```csharp
    private void ResetLatestProviderToTinyBlocksCount(int minersCountInTheory)
    {
        LatestPubkeyToTinyBlocksCount currentValue;
        if (State.LatestPubkeyToTinyBlocksCount.Value == null)
        {
            currentValue = new LatestPubkeyToTinyBlocksCount
            {
                Pubkey = _processingBlockMinerPubkey,
                BlocksCount = AEDPoSContractConstants.MaximumTinyBlocksCount.Sub(1)
            };
            State.LatestPubkeyToTinyBlocksCount.Value = currentValue;
        }
        else
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L22-79)
```csharp
    private int GetMaximumBlocksCount()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");

        // If R_LIB + 2 < R < R_LIB + CB1, CB goes to Min(T(L2 * (CB1 - (R - R_LIB)) / A), CB0), while CT stays same as before.
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }

        //If R >= R_LIB + CB1, CB goes to 1, and CT goes to 0
        if (blockchainMiningStatus == BlockchainMiningStatus.Severe)
        {
            // Fire an event to notify miner not package normal transaction.
            Context.Fire(new IrreversibleBlockHeightUnacceptable
            {
                DistanceToIrreversibleBlockHeight = currentHeight.Sub(libBlockHeight)
            });
            State.IsPreviousBlockInSevereStatus.Value = true;
            return 1;
        }

        if (!State.IsPreviousBlockInSevereStatus.Value)
            return AEDPoSContractConstants.MaximumTinyBlocksCount;

        Context.Fire(new IrreversibleBlockHeightUnacceptable
        {
            DistanceToIrreversibleBlockHeight = 0
        });
        State.IsPreviousBlockInSevereStatus.Value = false;

        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    }
```
