### Title
Missing LIB Monotonicity Validation in NextRound Allows Consensus State Corruption

### Summary
The `NextRound` consensus behavior does not validate that `ConfirmedIrreversibleBlockHeight` (LIB) maintains its monotonically increasing invariant. A malicious miner can submit a `NextRound` block with a decreased LIB value in the consensus extra data, which will pass validation and corrupt the consensus state, violating a critical finality invariant.

### Finding Description

The vulnerability exists in the consensus validation pipeline. When a miner produces a block with `NextRound` behavior, the block's consensus extra data contains a `Round` object with `ConfirmedIrreversibleBlockHeight`. This value should never decrease across rounds to maintain blockchain finality guarantees.

**Root Cause:**

The `ValidateBeforeExecution` method in [1](#0-0)  conditionally adds validation providers based on consensus behavior:

- For `UpdateValue` (line 79-82): Includes `LibInformationValidationProvider` which validates LIB monotonicity
- For `NextRound` (line 84-88): Does NOT include `LibInformationValidationProvider` - only validates mining order and round termination
- For `NextTerm` (line 89-91): Also does NOT include `LibInformationValidationProvider`

The `LibInformationValidationProvider` at [2](#0-1)  performs the critical check that prevents LIB from decreasing, but this validation is bypassed for `NextRound` behavior.

**Execution Path:**

1. Malicious miner constructs consensus extra data with `NextRound` behavior
2. The miner sets `Round.ConfirmedIrreversibleBlockHeight` to a value lower than the current state's LIB
3. `ValidateConsensusBeforeExecution` calls `ValidateBeforeExecution` [3](#0-2) 
4. Validation passes because `LibInformationValidationProvider` is not in the pipeline for `NextRound`
5. `NextRound` method executes via [4](#0-3) 
6. `ProcessNextRound` converts input via [5](#0-4)  preserving the malicious LIB value at line 34
7. Malicious round is stored without validation via [6](#0-5) 

The `RoundTerminateValidationProvider` used for `NextRound` at [7](#0-6)  only validates round number correctness and InValue nullity - it does not check LIB values.

### Impact Explanation

**Consensus Integrity Violation:**
- Violates the fundamental invariant that `ConfirmedIrreversibleBlockHeight` must be monotonically increasing
- Breaks finality guarantees - blocks that were considered irreversible can become reversible
- Corrupts the consensus state that all nodes rely on for block confirmation

**Cross-Chain Impact:**
- Cross-chain verification depends on LIB height for indexing and proof validation
- Decreased LIB can cause cross-chain transfer verification failures
- Can break parent-chain and side-chain synchronization

**Protocol-Wide Impact:**
- Election contract snapshots use LIB for term boundaries
- Treasury releases and profit distributions may use incorrect round information
- Token holder dividends calculated based on corrupted consensus state
- Can trigger chain reorganization attempts or consensus failures

**Severity:** Critical - This directly compromises a core consensus invariant that ensures blockchain finality and cross-chain integrity.

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being an active miner in the current miner list
- Miners rotate according to the election results, so any miner can eventually get a turn to produce blocks
- No additional privileges beyond standard miner capabilities needed

**Attack Complexity:**
- Low - Attacker only needs to modify the `ConfirmedIrreversibleBlockHeight` field in consensus extra data
- The consensus command generation flow at [8](#0-7)  shows how `NextRound` transactions are created
- Attacker can intercept and modify the `Round` object before block submission

**Feasibility:**
- No special timing requirements beyond having a valid time slot
- No economic barriers - producing a malicious block costs the same as a legitimate one
- Detection is difficult as the validation passes normally

**Probability:** High - Any malicious miner can execute this attack during their time slot, and the validation gap makes it undetectable until state corruption manifests.

### Recommendation

**Immediate Fix:**
Add `LibInformationValidationProvider` to the validation pipeline for both `NextRound` and `NextTerm` behaviors in `ValidateBeforeExecution`:

```csharp
case AElfConsensusBehaviour.NextRound:
    validationProviders.Add(new NextRoundMiningOrderValidationProvider());
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
case AElfConsensusBehaviour.NextTerm:
    validationProviders.Add(new RoundTerminateValidationProvider());
    validationProviders.Add(new LibInformationValidationProvider()); // ADD THIS
    break;
```

**Additional Safeguard:**
Add an explicit check in `ProcessNextRound` at [9](#0-8)  before line 156:

```csharp
// Validate LIB monotonicity
Assert(
    nextRound.ConfirmedIrreversibleBlockHeight >= currentRound.ConfirmedIrreversibleBlockHeight,
    "ConfirmedIrreversibleBlockHeight cannot decrease across rounds."
);
```

**Test Cases:**
- Verify that `NextRound` with decreased `ConfirmedIrreversibleBlockHeight` is rejected
- Verify that `NextRound` with equal LIB is accepted (for cases where no UpdateValue occurred)
- Verify that `NextRound` with increased LIB is accepted
- Test both `NextRound` and `NextTerm` behaviors

### Proof of Concept

**Initial State:**
- Round N = 100, with `ConfirmedIrreversibleBlockHeight = 5000`
- Malicious miner M is scheduled to produce the next block triggering `NextRound`

**Attack Steps:**

1. Miner M's turn arrives to produce a block with `NextRound` behavior
2. M intercepts the consensus command generation after [10](#0-9) 
3. M modifies the generated `Round` object in consensus extra data:
   - Original: `Round.ConfirmedIrreversibleBlockHeight = 5000`
   - Modified: `Round.ConfirmedIrreversibleBlockHeight = 3000` (decreased by 2000 blocks)
4. M submits block with malicious `NextRoundInput` via [11](#0-10)  containing the decreased value at line 16
5. Validation occurs via [12](#0-11)  - passes because `LibInformationValidationProvider` is missing
6. Block executes successfully, storing corrupted state

**Expected Result:**
Block should be rejected with "Incorrect lib information" error

**Actual Result:**
Block is accepted, Round N+1 now has `ConfirmedIrreversibleBlockHeight = 3000`, violating the monotonically increasing invariant

**Success Verification:**
Query `GetCurrentRoundInformation` - it returns a round with LIB lower than the previous round's LIB, confirming the invariant violation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L14-21)
```csharp
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L77-81)
```csharp
    public override ValidationResult ValidateConsensusBeforeExecution(BytesValue input)
    {
        var extraData = AElfConsensusHeaderInformation.Parser.ParseFrom(input.Value.ToByteArray());
        return ValidateBeforeExecution(extraData);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-171)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L7-23)
```csharp
    public static NextRoundInput Create(Round round, ByteString randomNumber)
    {
        return new NextRoundInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```
