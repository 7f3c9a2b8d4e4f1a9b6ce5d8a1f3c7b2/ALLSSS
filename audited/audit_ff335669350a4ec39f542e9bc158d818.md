### Title
Authorization Bypass via Incorrect OriginProposer in User Contract Deployment

### Summary
The `SendUserContractProposal` function incorrectly sets `OriginProposer` to `Context.Self` (Genesis contract) instead of `Context.Sender` (actual user), allowing users to bypass the code check controller's proposer whitelist authorization. This creates an inconsistency with the normal contract deployment flow and enables unauthorized users to deploy contracts by proxying through Genesis contract's system privileges.

### Finding Description

**Root Cause:**

In `SendUserContractProposal`, the `OriginProposer` field is set to `Context.Self` at: [1](#0-0) 

Additionally, the proposer identity is incorrectly set to Genesis: [2](#0-1) 

While the user's identity is preserved only in the `Author` field: [3](#0-2) 

**Why Protections Fail:**

When `CreateProposalBySystemContract` is invoked on the code check controller (Parliament contract), it validates the `OriginProposer`: [4](#0-3) 

This authorization check validates whether **Genesis contract** (not the actual user) is authorized to propose in the code check controller organization. Since Genesis is a system contract, it bypasses the proposer whitelist that should apply to the actual user.

**Execution Path:**

1. User calls `DeployUserSmartContract` [5](#0-4) 

2. Passes `AssertUserDeployContract` check (mainchain: anyone; sidechain: parliament whitelist) [6](#0-5) 

3. Calls `SendUserContractProposal` which creates proposal with Genesis as `OriginProposer` [7](#0-6) 

4. Authorization check validates **Genesis** instead of the user, bypassing code check controller's proposer restrictions

**Inconsistency with Correct Pattern:**

The normal contract deployment flow correctly preserves the original proposer's identity: [8](#0-7) 

This shows `OriginProposer` should be set to the actual proposer (`proposedInfo.Proposer`), not the intermediary system contract.

### Impact Explanation

**Authorization Bypass:**
- Users who lack authorization in the code check controller's proposer whitelist can deploy contracts via the user contract path
- The code check controller's `ProposerAuthorityRequired` setting and whitelist become ineffective for user contracts
- Creates two-tier authorization model where normal contracts enforce strict whitelist but user contracts bypass it

**Affected Parties:**
- Protocol governance: Loses ability to restrict who can propose code for checking
- Code check controller organization: Its proposer whitelist is circumvented
- Legitimate whitelisted users: Their exclusive rights are undermined

**Severity Justification:**
Medium severity because:
- Concrete authorization bypass of governance control
- Still requires miner approval via `AssertCurrentMiner()` in release step [9](#0-8) 
- But undermines the multi-layer authorization model designed into the system

### Likelihood Explanation

**Attacker Capabilities:**
- Any user who can pass `AssertUserDeployContract` (on mainchain: anyone; on sidechain: parliament whitelist member)
- No special privileges required beyond normal user contract deployment access

**Attack Complexity:**
- Low - Direct method call to `DeployUserSmartContract`
- Standard transaction with normal contract deployment input
- No complex transaction sequences or state manipulation required

**Feasibility Conditions:**
- Code check controller must have `ProposerAuthorityRequired = true` with restricted whitelist
- User must not be in code check controller's proposer whitelist
- User must pass `AssertUserDeployContract` authorization check

**Probability:**
High - The vulnerability is inherent in the code path and activates automatically whenever a user deploys via `DeployUserSmartContract` instead of `ProposeNewContract`.

### Recommendation

**Code-Level Fix:**

Change line 336 in `SendUserContractProposal` from:
```
OriginProposer = Context.Self
```
to:
```
OriginProposer = Context.Sender
```

Also change line 318 from:
```
Proposer = Context.Self
```
to:
```
Proposer = Context.Sender
```

And update the validation in `ReleaseApprovedUserSmartContract`: [10](#0-9) 

Change from:
```
contractProposingInput.Proposer == Context.Self
```
to:
```
contractProposingInput.Proposer == contractProposingInput.Author
```

**Invariant Checks:**
- Ensure `OriginProposer` always represents the actual initiating user, not intermediary contracts
- Validate that authorization checks apply to the real user across all deployment paths
- Maintain consistency between normal and user contract deployment authorization models

**Test Cases:**
1. Test user contract deployment when user is NOT in code check controller whitelist (should fail after fix)
2. Test user contract deployment when user IS in code check controller whitelist (should succeed)
3. Verify normal contract deployment maintains existing behavior
4. Test with code check controller `ProposerAuthorityRequired = true` and restricted whitelist

### Proof of Concept

**Initial State:**
- Code check controller organization has `ProposerAuthorityRequired = true`
- Code check controller has restricted proposer whitelist containing only addresses [A, B, C]
- User U is NOT in whitelist [A, B, C]
- User U IS in parliament whitelist (for sidechain) or on mainchain (where anyone can deploy)
- Genesis contract (as system contract) has inherent authorization

**Exploit Steps:**

1. User U calls `DeployUserSmartContract` with valid contract code
   - Input: `UserContractDeploymentInput` with code, category, salt
   
2. `AssertUserDeployContract` passes (User U is in parliament whitelist or on mainchain)

3. `SendUserContractProposal` creates proposal with:
   - `Proposer = Context.Self` (Genesis)
   - `OriginProposer = Context.Self` (Genesis)  
   - `Author = Context.Sender` (User U)

4. Proposal creation in code check controller calls `CreateProposalBySystemContract`
   - Validates `AssertIsAuthorizedProposer(codeCheckController, Context.Self)` 
   - Check passes because Genesis (Context.Self) has system contract privileges
   - **Expected:** Should check User U's authorization
   - **Actual:** Checks Genesis's authorization (bypass)

5. Miners approve the proposal

6. Contract deploys with User U as author despite User U lacking authorization in code check controller

**Success Condition:**
User U successfully deploys contract despite not being in code check controller's proposer whitelist, demonstrating authorization bypass through Genesis proxy.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L72-72)
```csharp
        AssertIsAuthorizedProposer(input.ProposalInput.OrganizationAddress, input.OriginProposer);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L256-256)
```csharp
            OriginProposer = proposedInfo.Proposer
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-427)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L483-483)
```csharp
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L485-485)
```csharp
        AssertCurrentMiner();
```
