# Audit Report

## Title
Denial of Service in TokenHolder AddBeneficiary/RemoveBeneficiary Due to Invalid Single() Assumption on Multiple Profit Details

## Summary
The `AddBeneficiary()` and `RemoveBeneficiary()` functions in TokenHolderContract incorrectly assume beneficiaries have exactly one profit detail by calling `Single()`, but the underlying Profit contract legitimately creates multiple `ProfitDetail` entries after partial removals. This causes permanent transaction failures that lock beneficiaries from share updates, creating a denial of service condition for normal TokenHolder operations.

## Finding Description

The vulnerability exists in two locations within TokenHolderContract where it attempts to access profit details: [1](#0-0) 

At line 55, `AddBeneficiary()` calls `detail.Details.Single().Shares`, which assumes exactly one `ProfitDetail` exists. However, the underlying Profit contract is designed to support and actively creates multiple `ProfitDetail` entries per beneficiary: [2](#0-1) 

The `ProfitDetails` message contains a `repeated` field, explicitly allowing multiple entries per beneficiary.

Multiple details are legitimately created through TokenHolder's partial removal feature: [3](#0-2) 

When `RemoveBeneficiary` is called with a partial amount (lines 85-95), it removes the beneficiary and then re-adds them with reduced shares. This pattern creates two `ProfitDetail` entries, as confirmed by the existing test suite: [4](#0-3) 

Line 192 explicitly asserts that after partial removal, the beneficiary has 2 details: `profitAmount.Details.Count.ShouldBe(2)`.

The same `Single()` assumption also exists in `RemoveBeneficiary`: [5](#0-4) 

Line 78 calls `.Details.Single()`, which will also fail when multiple details exist.

**Execution Flow to Trigger DOS:**

1. **Initial State**: Beneficiary has 1 `ProfitDetail` entry
2. **Partial Removal**: Manager calls `RemoveBeneficiary(amount > 0 && amount < total)`
   - Old detail is marked as ended (EndPeriod set to CurrentPeriod-1)
   - New detail with reduced shares is added
   - Beneficiary now has 2 `ProfitDetail` entries
3. **DOS Triggered**: Any subsequent call to `AddBeneficiary` or `RemoveBeneficiary` for this beneficiary:
   - Line 55 or 78 calls `Single()` on a collection with 2 elements
   - C# `Single()` throws `InvalidOperationException`
   - Transaction reverts completely
   - No shares are duplicated or modified

## Impact Explanation

**Permanent Operational DOS:**
- Once a beneficiary undergoes partial removal, they permanently have 2+ `ProfitDetail` entries
- All subsequent `AddBeneficiary` calls for that beneficiary fail at line 55
- All subsequent `RemoveBeneficiary` calls also fail at line 78
- The scheme manager cannot adjust shares for affected beneficiaries through TokenHolder
- Beneficiaries' shares become frozen in the TokenHolder context
- While managers could theoretically bypass this by calling Profit contract directly, this:
  - Bypasses TokenHolder's intended abstraction layer
  - Requires deep knowledge of internal implementation
  - May create state inconsistencies
  - Indicates a broken design in TokenHolder

**Affected Systems:**
- Any TokenHolder profit scheme using partial removal features
- DApp creators relying on flexible share management
- Election and staking systems requiring dynamic share adjustments
- All schemes where beneficiary participation changes over time

**No Share Duplication:**
The claim correctly identifies that shares are NOT duplicated. The `Single()` method throws `InvalidOperationException` before any share arithmetic occurs, causing complete transaction reversion.

## Likelihood Explanation

**High Likelihood - Normal Operations Trigger Vulnerability:**

**Reachability:** 
- `AddBeneficiary` is a public method callable by scheme managers (line 39 validates sender is manager)
- No special privileges beyond being the scheme manager required

**Feasible Preconditions:**
- Partial removal is an intentionally designed feature (lines 85-95 implement the logic)
- The test suite confirms this is an expected operational pattern
- Any scheme using dynamic share adjustments will likely trigger partial removals

**No Attack Required:**
- This is a logic error in contract design, not an attack vector
- Triggered through normal, legitimate usage of partial removal
- The test case `RemoveBeneficiary_With_Amount_Test` demonstrates this is standard functionality

**Permanent Condition:**
- Once multiple details exist, the condition persists
- No self-healing mechanism in TokenHolder
- Requires external intervention to resolve

## Recommendation

Replace `Single()` calls with logic that handles multiple `ProfitDetail` entries. The fix should aggregate shares across all active details:

```csharp
// In AddBeneficiary (around line 55):
var totalExistingShares = detail.Details.Sum(d => d.Shares);
shares.Add(totalExistingShares);

// In RemoveBeneficiary (around line 78):
var totalShares = detail.Details.Sum(d => d.Shares);
```

Alternatively, ensure TokenHolder maintains exactly one detail by fully removing old details before adding new ones, rather than relying on the Profit contract's `RemoveBeneficiary` which may leave historical entries.

A comprehensive fix should also review whether the partial removal pattern should completely remove old entries from the Profit contract to maintain the single-detail invariant that TokenHolder expects.

## Proof of Concept

```csharp
[Fact]
public async Task DOS_After_Partial_Removal_Test()
{
    // Setup: Create scheme and add beneficiary
    await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
    {
        Symbol = "ELF"
    });
    
    await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Shares = 1000
    });
    
    // Step 1: Perform partial removal (creates 2 ProfitDetails)
    await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
    {
        Beneficiary = UserAddresses.First(),
        Amount = 100 // Partial removal: 100 out of 1000
    });
    
    // Verify beneficiary now has 2 details
    var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
    {
        Manager = Starter
    });
    var profitDetails = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
    {
        Beneficiary = UserAddresses.First(),
        SchemeId = schemeIds.SchemeIds[0]
    });
    profitDetails.Details.Count.ShouldBe(2); // Confirms multiple details exist
    
    // Step 2: Attempt to update shares via AddBeneficiary - THIS WILL FAIL
    var result = await TokenHolderContractStub.AddBeneficiary.SendWithExceptionAsync(
        new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First(),
            Shares = 50
        });
    
    // Transaction fails with InvalidOperationException from Single()
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("Sequence contains more than one element");
    
    // Step 3: Verify RemoveBeneficiary is also blocked
    var removeResult = await TokenHolderContractStub.RemoveBeneficiary.SendWithExceptionAsync(
        new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = UserAddresses.First()
        });
    
    removeResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    removeResult.TransactionResult.Error.ShouldContain("Sequence contains more than one element");
    
    // Beneficiary is now permanently locked from TokenHolder operations
}
```

## Notes

This vulnerability represents a critical design mismatch between TokenHolderContract's assumptions and ProfitContract's actual behavior. The Profit contract is explicitly designed to maintain multiple `ProfitDetail` entries per beneficiary (with periods, removal tracking, etc.), while TokenHolder incorrectly assumes a single-detail invariant. The partial removal feature actively breaks this assumed invariant, creating a permanent DOS condition for affected beneficiaries.

The vulnerability is particularly severe because:
1. It's triggered by intended functionality, not edge cases
2. The test suite confirms multiple details are expected after partial removals
3. Both `AddBeneficiary` and `RemoveBeneficiary` are affected
4. There's no recovery mechanism within TokenHolder
5. It affects the core value proposition of flexible profit-sharing schemes

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L37-68)
```csharp
    public override Empty AddBeneficiary(AddTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);
        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        var shares = input.Shares;
        if (detail.Details.Any())
        {
            // Only keep one detail.

            State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                Beneficiary = input.Beneficiary
            });
            shares.Add(detail.Details.Single().Shares);
        }

        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = input.Beneficiary,
                Shares = shares
            }
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L70-98)
```csharp
    public override Empty RemoveBeneficiary(RemoveTokenHolderBeneficiaryInput input)
    {
        var scheme = GetValidScheme(Context.Sender);

        var detail = State.ProfitContract.GetProfitDetails.Call(new GetProfitDetailsInput
        {
            Beneficiary = input.Beneficiary,
            SchemeId = scheme.SchemeId
        }).Details.Single();
        var lockedAmount = detail.Shares;
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = input.Beneficiary
        });
        if (lockedAmount > input.Amount &&
            input.Amount != 0) // If input.Amount == 0, means just remove this beneficiary.
            State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
            {
                SchemeId = scheme.SchemeId,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = input.Beneficiary,
                    Shares = lockedAmount.Sub(input.Amount)
                }
            });

        return new Empty();
    }
```

**File:** protobuf/profit_contract.proto (L233-236)
```text
message ProfitDetails {
    // The profit information.
    repeated ProfitDetail details = 1;
}
```

**File:** test/AElf.Contracts.TokenHolder.Tests/TokenHolderTests.cs (L156-196)
```csharp
    public async Task RemoveBeneficiary_With_Amount_Test()
    {
        await TokenHolderContractStub.CreateScheme.SendAsync(new CreateTokenHolderProfitSchemeInput
        {
            Symbol = "ELF"
        });
        await TokenHolderContractStub.ContributeProfits.SendAsync(new ContributeProfitsInput
        {
            SchemeManager = Starter,
            Symbol = "ELF",
            Amount = 9999
        });
        await TokenHolderContractStub.AddBeneficiary.SendAsync(new AddTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Shares = 1000
        });
        var schemeIds = await ProfitContractStub.GetManagingSchemeIds.CallAsync(new GetManagingSchemeIdsInput
        {
            Manager = Starter
        });
        var schemeId = schemeIds.SchemeIds[0];
        var beforeRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeId);
        var amount = 10;
        await TokenHolderContractStub.RemoveBeneficiary.SendAsync(new RemoveTokenHolderBeneficiaryInput
        {
            Beneficiary = Starter,
            Amount = amount
        });
        var afterRemoveScheme = await ProfitContractStub.GetScheme.CallAsync(schemeIds.SchemeIds[0]);
        afterRemoveScheme.TotalShares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
        var profitAmount = await ProfitContractStub.GetProfitDetails.CallAsync(new GetProfitDetailsInput
        {
            Beneficiary = Starter,
            SchemeId = schemeId
        });
        profitAmount.Details.Count.ShouldBe(2);
        profitAmount.Details[0].Shares.ShouldBe(beforeRemoveScheme.TotalShares);
        profitAmount.Details[0].EndPeriod.ShouldBe(0);
        profitAmount.Details[1].Shares.ShouldBe(beforeRemoveScheme.TotalShares - amount);
    }
```
