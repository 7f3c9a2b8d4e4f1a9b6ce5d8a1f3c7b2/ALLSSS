# Audit Report

## Title
Non-Deterministic Consensus Fork Due to Dictionary Iteration Order in Next Round Generation

## Summary
The `GenerateNextRoundInformation()` function in the AEDPoS consensus contract contains a critical non-determinism bug that can cause consensus forks. The function iterates over a protobuf map (C# Dictionary) without sorting, and when combined with a validation bug that allows duplicate `FinalOrderOfNextRound` values, causes different nodes to generate incompatible next-round states from identical inputs.

## Finding Description

**Root Cause: Non-Deterministic Dictionary Iteration**

The `GenerateNextRoundInformation()` method obtains miners from `GetMinedMiners()`, which iterates `RealTimeMinersInformation.Values` in non-deterministic Dictionary order. [1](#0-0) 

The `RealTimeMinersInformation` field is defined as a protobuf map, which becomes a C# Dictionary with undefined iteration order. [2](#0-1) 

When generating the next round, the code performs a stable sort on `FinalOrderOfNextRound`: [3](#0-2) 

**Critical Validation Bug: Insufficient Uniqueness Check**

The `NextRoundMiningOrderValidationProvider` performs `.Distinct()` on `MinerInRound` objects (checking reference equality), NOT on their `FinalOrderOfNextRound` values: [4](#0-3) 

This validation bug allows multiple miners to have identical `FinalOrderOfNextRound` values, as it only checks object uniqueness rather than order value uniqueness.

**How Duplicate Orders Occur**

Order collisions can occur naturally when miners calculate `supposedOrderOfNextRound` via modulo arithmetic: [5](#0-4) 

The conflict resolution attempts to reassign colliding orders, but if `TuneOrderInformation` is incomplete or incorrect, duplicate `FinalOrderOfNextRound` values remain in state and pass validation. [6](#0-5) 

**Additional Non-Determinism: BreakContinuousMining**

The `BreakContinuousMining()` function uses `.First()` on non-deterministically ordered dictionary values: [7](#0-6) 

**Evidence of Known Issue**

AElf's codebase demonstrates awareness of dictionary non-determinism by explicitly sorting keys for state hash calculation: [8](#0-7) 

However, this defensive pattern is NOT applied in `GenerateNextRoundInformation()`, making it non-deterministic.

## Impact Explanation

**Consensus Integrity Violation**

This breaks the fundamental requirement that consensus state transitions must be deterministic. When multiple nodes independently generate the next round from identical input state (during network partitions, reorganizations, or miner failover), they produce different `nextRound` outputs due to:

1. Different dictionary iteration orders on different nodes
2. Stable sort preserving the non-deterministic input order when `FinalOrderOfNextRound` values are duplicate

**Concrete Harm**

- **Complete consensus failure**: Different nodes accept incompatible NextRound blocks with different miner orderings
- **Permanent network fork**: The blockchain splits into multiple chains that cannot reconcile
- **Loss of transaction finality**: Transactions on one fork are invalid on others
- **Double-spend opportunities**: Assets can be spent differently on different forks
- **Miner reward inconsistency**: Different miners receive rewards on different forks

This is a **CRITICAL** severity issue because consensus non-determinism is catastrophic - it makes it impossible for the network to agree on canonical state.

## Likelihood Explanation

**Triggering Conditions**

The vulnerability triggers when:
1. Duplicate `FinalOrderOfNextRound` values exist in state (achievable via hash collisions or incomplete `TuneOrderInformation`)
2. Multiple nodes independently generate next-round information (occurs during network partitions, reorganizations, or failover scenarios)

**Collision Probability**

With N miners, the probability of `GetAbsModulus(sigNum, minersCount)` producing identical values is approximately 1/N per miner pair. For 21 miners (typical DPoS), this is ~4.8% per pair. Over many rounds, collisions become statistically likely.

**Attack Complexity: LOW**

- **Passive**: Natural hash collisions occur without attacker action
- **Active**: Any miner can provide incomplete `TuneOrderInformation` to preserve duplicate orders
- **No special privileges required**: The validation bug allows duplicates to pass

**Realistic Scenarios**

- Network partitions (common in distributed systems)
- Chain reorganizations during competing block production  
- Failover when designated extra block producer is unavailable
- Any scenario where multiple miners independently compute next round from the same state

**Detection Difficulty**

The bug is subtle - forks appear as "normal" disagreement rather than obvious invalid blocks. The root cause (dictionary iteration order) is non-obvious, making debugging extremely difficult.

## Recommendation

**Fix 1: Correct Validation Logic**

Change the validation to check uniqueness of `FinalOrderOfNextRound` values, not object references:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)  // Select values first
    .Distinct()
    .Count();
```

**Fix 2: Ensure Deterministic Iteration**

Sort miners by public key before processing in `GetMinedMiners()`:

```csharp
public List<MinerInRound> GetMinedMiners()
{
    return RealTimeMinersInformation
        .OrderBy(kvp => kvp.Key)  // Sort by pubkey for determinism
        .Select(kvp => kvp.Value)
        .Where(m => m.SupposedOrderOfNextRound != 0)
        .ToList();
}
```

Apply the same pattern in `GetNotMinedMiners()` and throughout `BreakContinuousMining()`.

**Fix 3: Add Secondary Sort Key**

In `GenerateNextRoundInformation()`, add a secondary sort by public key to break ties deterministically:

```csharp
foreach (var minerInRound in minersMinedCurrentRound
    .OrderBy(m => m.FinalOrderOfNextRound)
    .ThenBy(m => m.Pubkey))  // Deterministic tie-breaker
{
    // ...
}
```

## Proof of Concept

This vulnerability cannot be demonstrated with a simple unit test because it requires:
1. Multiple independent node instances with different runtime environments
2. Network partition or reorganization scenarios
3. Observable divergence in dictionary iteration order

However, the validation bug can be proven:

```csharp
[Test]
public void ValidationAllowsDuplicateOrders()
{
    var round = new Round();
    
    // Create two miners with duplicate FinalOrderOfNextRound
    round.RealTimeMinersInformation["miner1"] = new MinerInRound 
    { 
        Pubkey = "miner1", 
        OutValue = Hash.FromString("out1"),
        FinalOrderOfNextRound = 5  // Duplicate order
    };
    
    round.RealTimeMinersInformation["miner2"] = new MinerInRound 
    { 
        Pubkey = "miner2", 
        OutValue = Hash.FromString("out2"),
        FinalOrderOfNextRound = 5  // Duplicate order
    };
    
    var validator = new NextRoundMiningOrderValidationProvider();
    var context = new ConsensusValidationContext { ProvidedRound = round };
    
    // This passes validation despite duplicate orders (BUG!)
    var result = validator.ValidateHeaderInformation(context);
    Assert.True(result.Success);  // Incorrectly passes
    
    // Correct check would be:
    var uniqueOrders = round.RealTimeMinersInformation.Values
        .Select(m => m.FinalOrderOfNextRound)
        .Distinct()
        .Count();
    Assert.Equal(1, uniqueOrders);  // Actually only 1 unique order (5), not 2
}
```

The consensus fork itself manifests during real network operation when different nodes' dictionary implementations iterate in different orders, causing `OrderBy` with duplicate keys to produce different orderings.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-37)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L73-108)
```csharp
    private void BreakContinuousMining(ref Round nextRound)
    {
        var minersCount = RealTimeMinersInformation.Count;
        if (minersCount <= 1) return;

        // First miner of next round != Extra block producer of current round
        var firstMinerOfNextRound = nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 1);
        var extraBlockProducerOfCurrentRound = GetExtraBlockProducerInformation();
        if (firstMinerOfNextRound.Pubkey == extraBlockProducerOfCurrentRound.Pubkey)
        {
            var secondMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == 2);
            secondMinerOfNextRound.Order = 1;
            firstMinerOfNextRound.Order = 2;
            var tempTimestamp = secondMinerOfNextRound.ExpectedMiningTime;
            secondMinerOfNextRound.ExpectedMiningTime = firstMinerOfNextRound.ExpectedMiningTime;
            firstMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }

        // Last miner of next round != Extra block producer of next round
        var lastMinerOfNextRound =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(i => i.Order == minersCount);
        if (lastMinerOfNextRound == null) return;

        var extraBlockProducerOfNextRound = nextRound.GetExtraBlockProducerInformation();
        if (lastMinerOfNextRound.Pubkey == extraBlockProducerOfNextRound.Pubkey)
        {
            var lastButOneMinerOfNextRound =
                nextRound.RealTimeMinersInformation.Values.First(i => i.Order == minersCount.Sub(1));
            lastButOneMinerOfNextRound.Order = minersCount;
            lastMinerOfNextRound.Order = minersCount.Sub(1);
            var tempTimestamp = lastButOneMinerOfNextRound.ExpectedMiningTime;
            lastButOneMinerOfNextRound.ExpectedMiningTime = lastMinerOfNextRound.ExpectedMiningTime;
            lastMinerOfNextRound.ExpectedMiningTime = tempTimestamp;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L125-129)
```csharp
    public List<MinerInRound> GetMinedMiners()
    {
        // For now only this implementation can support test cases.
        return RealTimeMinersInformation.Values.Where(m => m.SupposedOrderOfNextRound != 0).ToList();
    }
```

**File:** protobuf/aedpos_contract.proto (L247-247)
```text
    map<string, MinerInRound> real_time_miners_information = 2;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-21)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
        {
            validationResult.Message = "Invalid FinalOrderOfNextRound.";
            return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-44)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;

        // Check the existence of conflicts about OrderOfNextRound.
        // If so, modify others'.
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();

        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }

        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-260)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** src/AElf.Kernel.SmartContractExecution/Application/BlockExecutingService.cs (L165-180)
```csharp
    private IEnumerable<byte[]> GetDeterministicByteArrays(BlockStateSet blockStateSet)
    {
        var keys = blockStateSet.Changes.Keys;
        foreach (var k in new SortedSet<string>(keys))
        {
            yield return Encoding.UTF8.GetBytes(k);
            yield return blockStateSet.Changes[k].ToByteArray();
        }

        keys = blockStateSet.Deletes;
        foreach (var k in new SortedSet<string>(keys))
        {
            yield return Encoding.UTF8.GetBytes(k);
            yield return ByteString.Empty.ToByteArray();
        }
    }
```
