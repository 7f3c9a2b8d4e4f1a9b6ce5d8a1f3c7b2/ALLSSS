### Title
Organization Validation Bypass via Malicious Contract in ChangeMethodFeeController

### Summary
The `ChangeMethodFeeController` function validates organization existence by making an external call to an attacker-controlled contract address without verifying it is a legitimate governance contract (Parliament, Association, or Referendum). An attacker with temporary governance control can deploy a malicious contract that returns `true` for any organization check, bypassing validation to establish permanent unauthorized control over method fees.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` function where organization validation is performed: [1](#0-0) 

At line 29, the function calls `CheckOrganizationExist(input)` which makes an external call to the contract address specified in the `AuthorityInfo` parameter: [2](#0-1) 

**Root Cause**: The `Context.Call` at line 85 invokes `ValidateOrganizationExist` on `authorityInfo.ContractAddress` without any validation that this address corresponds to a legitimate governance contract. The `AuthorityInfo` structure has no built-in constraints: [3](#0-2) 

**Why Protections Fail**: While legitimate governance contracts like Parliament properly implement `ValidateOrganizationExist` to check against their internal organization registry: [4](#0-3) 

There is no mechanism preventing an attacker from providing a malicious contract address that implements a `ValidateOrganizationExist` method returning `true` unconditionally. The validation logic blindly trusts the response from any contract at the provided address.

**Execution Path**:
1. Attacker gains temporary legitimate control (e.g., through approved governance proposal)
2. Satisfies authorization check at line 28: [5](#0-4) 
3. Deploys malicious contract with `ValidateOrganizationExist` always returning `true`
4. Calls `ChangeMethodFeeController` with `input.ContractAddress` = malicious contract, `input.OwnerAddress` = attacker address
5. External call to malicious contract succeeds with `true` response
6. Validation passes at line 30, attacker becomes permanent fee controller

This pattern affects all 16 system contracts using identical validation logic: [6](#0-5) 

### Impact Explanation

**Authorization & Governance Impact**: 
- **Permanent unauthorized control**: Attacker converts temporary legitimate governance access into permanent control over method fee configuration for critical system contracts (Consensus, Token, Treasury, CrossChain, Election, Vote, Profit, TokenConverter, TokenHolder, Economic, Configuration, Parliament, Referendum, Association, Genesis, NFT)
- **Fee manipulation**: Complete control over transaction costs for all methods, enabling economic attacks or denial-of-service by setting prohibitively high fees
- **Governance bypass**: Once established, the attacker's control persists even after their original governance authority is revoked, fundamentally breaking the organizational governance model

**Who is Affected**: All users and contracts relying on the method fee system. The entire AElf ecosystem depends on proper governance control of fees to ensure fair transaction costs and prevent operational disruption.

**Severity Justification**: CRITICAL - This violates the fundamental "Authorization & Governance" invariant requiring correct method-fee provider authority. It enables privilege escalation from temporary to permanent control, completely subverting the organizational governance structure designed to prevent unilateral control.

### Likelihood Explanation

**Attacker Capabilities Required**:
- Deploy a smart contract (standard capability)
- Obtain temporary governance approval for a proposal (achievable through social engineering, insider access, or during legitimate governance participation)

**Attack Complexity**: LOW
- Malicious contract implementation is trivial (single method returning `true`)
- Exploit requires only one transaction after gaining temporary control
- No timing constraints or race conditions
- No economic barriers beyond standard contract deployment costs

**Feasibility Conditions**:
The primary precondition is gaining temporary legitimate control of the method fee controller through governance. This is realistic because:
1. Governance proposals are expected to succeed in normal operations
2. A compromised governance participant or malicious insider with proposal authority can inject this attack
3. During system upgrades or configuration changes, temporary controller changes occur legitimately

**Detection/Operational Constraints**:
- Attack leaves permanent state change (new controller address)
- However, the malicious contract address may not be immediately recognizable as illegitimate
- No events distinguish legitimate controller changes from malicious ones
- Post-attack recovery requires another governance action, but attacker now controls the controller

**Probability Reasoning**: MEDIUM-HIGH
While requiring initial governance access raises the bar, the ease of exploitation once that access is obtained, combined with the permanent nature of the compromise, makes this a realistic threat. The pattern affects 16 system contracts, multiplying the attack surface.

### Recommendation

**Immediate Fix**: Add validation to ensure `authorityInfo.ContractAddress` is one of the legitimate governance contracts before making the external call.

**Code-Level Mitigation**:
```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Validate ContractAddress is a legitimate governance contract
    var systemContracts = Context.GetSystemContractNameToAddressMapping();
    var isParliament = authorityInfo.ContractAddress == systemContracts[SmartContractConstants.ParliamentContractSystemName];
    var isAssociation = authorityInfo.ContractAddress == systemContracts[SmartContractConstants.AssociationContractSystemName];
    var isReferendum = authorityInfo.ContractAddress == systemContracts[SmartContractConstants.ReferendumContractSystemName];
    
    Assert(isParliament || isAssociation || isReferendum, 
        "Invalid governance contract address.");
    
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        authorityInfo.OwnerAddress).Value;
}
```

**Invariant Checks to Add**:
1. Whitelist validation: ContractAddress must be in the set {Parliament, Association, Referendum}
2. Add assertion before external call to verify contract address against known system contracts
3. Emit event with both old and new controller details for monitoring

**Test Cases to Prevent Regression**:
1. Test: Attempt to change controller with non-governance contract address → Should fail with "Invalid governance contract address"
2. Test: Attempt to change controller with arbitrary user-deployed contract → Should fail with "Invalid governance contract address"
3. Test: Verify only Parliament/Association/Referendum addresses are accepted as ContractAddress
4. Test: Ensure legitimate controller changes still work with proper governance contracts

Apply this fix to all 16 affected system contracts implementing ACS1 TransactionFeeProvider pattern.

### Proof of Concept

**Initial State**:
- Current method fee controller: Parliament default organization (set via `RequiredMethodFeeControllerSet`)
- Attacker has ability to create and approve a governance proposal

**Attack Sequence**:

1. **Deploy Malicious Contract**:
```csharp
public class MaliciousOrganizationContract
{
    public BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = true }; // Always returns true
    }
}
```

2. **Gain Temporary Control**: Attacker creates governance proposal to legitimately change some configuration (or uses existing governance authority)

3. **Execute Privilege Escalation**: While having legitimate access as current controller, call:
```
ChangeMethodFeeController(new AuthorityInfo {
    ContractAddress = MaliciousOrganizationContract.Address,
    OwnerAddress = AttackerPersonalAddress
})
```

4. **Validation Bypass Occurs**:
   - Line 28: Authorization check passes (attacker is current controller)
   - Line 29: `CheckOrganizationExist` calls malicious contract
   - Line 85: `Context.Call` to `MaliciousOrganizationContract.ValidateOrganizationExist`
   - Malicious contract returns `BoolValue { Value = true }`
   - Line 30: Assertion passes
   - Line 32: `State.MethodFeeController.Value` set to attacker's authority

**Expected Result**: Transaction should fail with "Invalid authority input" because ContractAddress is not a legitimate governance contract

**Actual Result**: Transaction succeeds. Attacker's personal address is now the permanent method fee controller, bypassing organizational governance.

**Success Condition**: After exploit, `GetMethodFeeController()` returns `AuthorityInfo` with `OwnerAddress = AttackerPersonalAddress` and `ContractAddress = MaliciousOrganizationContract.Address`. Attacker can now call `SetMethodFee` directly without any governance oversight, and legitimate governance cannot reclaim control without attacker cooperation.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L25-34)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L83-88)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** protobuf/authority_info.proto (L1-10)
```text
syntax = "proto3";

import "aelf/core.proto";

message AuthorityInfo {
    // The contract address of the controller.
    aelf.Address contract_address = 1;
    // The address of the owner of the contract.
    aelf.Address owner_address = 2;
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L118-120)
```csharp
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
```
