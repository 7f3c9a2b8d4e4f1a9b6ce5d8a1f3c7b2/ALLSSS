### Title
Consensus Halt Attack via Empty Miner List in NextRound Validation

### Summary
The `ValidationForNextRound()` method in `RoundTerminateValidationProvider` fails to validate that the next round must contain miners. When `RealTimeMinersInformation` is empty, the `Any()` check at line 32 returns false, causing validation to succeed. This allows a malicious miner to transition the blockchain to a round with zero miners, permanently halting consensus as no miner can subsequently produce blocks.

### Finding Description

The vulnerability exists in the round termination validation logic. [1](#0-0) 

The validation only checks that InValues should be null for a fresh round, but when `RealTimeMinersInformation` is an empty collection, `Any(m => m.InValue != null)` returns false (no elements to evaluate), causing the validation to incorrectly succeed.

The validation flow processes NextRound behavior through multiple validators: [2](#0-1) 

Other validators fail to prevent empty miner lists:
- `MiningPermissionValidationProvider` only checks if the sender is in the current (BaseRound) miner list, not the next round
- `NextRoundMiningOrderValidationProvider` compares counts that are both zero when the list is empty (0 == 0 passes validation)

Once validated, the empty round is stored as the new current round: [3](#0-2) 

### Impact Explanation

**Complete Consensus Halt**: After the empty round is stored, all miners are permanently locked out. When any miner attempts to get a consensus command, the check fails: [4](#0-3) 

Since `RealTimeMinersInformation` is empty, `IsInMinerList()` returns false for ALL miners. This causes `GetConsensusCommand` to return `InvalidConsensusCommand`: [5](#0-4) 

**Consequences:**
- No miner can produce blocks (consensus command always invalid)
- No transactions can be processed
- Blockchain operations halt completely
- Recovery requires hard fork or chain restart
- All pending transactions are stuck
- Economic activity ceases entirely

**Severity**: CRITICAL - This violates the fundamental consensus invariant that valid rounds must contain miners.

### Likelihood Explanation

**Attacker Capabilities**: Any current miner who becomes the extra block producer or is within their time slot can execute this attack.

**Attack Complexity**: LOW
- Attacker simply crafts a NextRound block with empty `RealTimeMinersInformation`
- No complex cryptographic manipulation required
- Single transaction execution

**Preconditions**: 
- Attacker must be a legitimate miner in the current round (feasible)
- Attacker must have the opportunity to produce a NextRound block (happens naturally when rounds transition)

**Economic Cost**: Minimal - The attacker only needs to be an existing miner. After the attack, the chain halts, but the attacker has already achieved their objective of denying service.

**Detection**: The attack would be detected immediately upon execution (consensus halt), but by then it's too late - the damage is done and requires hard fork to recover.

**Probability**: MEDIUM-HIGH - Malicious miners periodically get opportunities to produce NextRound blocks during normal operations.

### Recommendation

**Immediate Fix**: Add validation in `RoundTerminateValidationProvider.ValidationForNextRound()` to ensure the next round contains miners:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // NEW: Validate that next round must contain miners
    if (!extraData.Round.RealTimeMinersInformation.Any())
        return new ValidationResult { Message = "Next round must contain miners." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Additional Hardening**: 
1. Add check that miner count matches or is consistent with current round (accounting for replacements)
2. Validate that all expected miners from current round are present (unless legitimately replaced)
3. Add invariant assertion in `ProcessNextRound` that rejects empty rounds

**Test Cases**:
1. Test that NextRound with empty `RealTimeMinersInformation` is rejected
2. Test that NextRound with zero miners but valid structure is rejected
3. Test legitimate round transitions still work correctly
4. Test that validation distinguishes between empty list and list with null InValues

### Proof of Concept

**Initial State**:
- Blockchain is running normally with N miners
- Current round R has miners M1, M2, ..., MN in `RealTimeMinersInformation`
- Attacker is miner M1 and is designated as extra block producer

**Attack Sequence**:

1. **Attacker crafts malicious NextRound block**:
   - Create `AElfConsensusHeaderInformation` with `Behaviour = NextRound`
   - Set `Round.RoundNumber = R + 1`
   - Set `Round.RealTimeMinersInformation = {}` (empty map)
   - Include in block header as consensus extra data

2. **Block validation** (all pass):
   - `MiningPermissionValidationProvider`: Checks M1 in BaseRound.RealTimeMinersInformation → PASS (M1 is in current round)
   - `NextRoundMiningOrderValidationProvider`: Compares 0 == 0 → PASS
   - `RoundTerminateValidationProvider.ValidationForNextRound()`: `Any(m => m.InValue != null)` on empty collection → returns false → PASS

3. **Block execution**:
   - `NextRound` method called
   - `ProcessNextRound` stores empty round: `State.Rounds[R+1] = emptyRound`
   - `State.CurrentRoundNumber = R + 1`

4. **Consensus halt occurs**:
   - Any miner (including M2, M3, ..., MN) calls `GetConsensusCommand`
   - Check fails: `currentRound.IsInMinerList(pubkey)` returns false (empty list)
   - Returns `InvalidConsensusCommand`
   - No blocks can be produced

**Expected Result**: Validation should reject the NextRound with empty miner list

**Actual Result**: Validation passes, empty round is stored, blockchain halts permanently

**Success Condition**: After attacker's block, call `GetConsensusCommand` as any miner returns `InvalidConsensusCommand`, and `GetCurrentMinerList` returns empty list, proving consensus is halted.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-92)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L137-140)
```csharp
    public bool IsInMinerList(string pubkey)
    {
        return RealTimeMinersInformation.Keys.Contains(pubkey);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```
