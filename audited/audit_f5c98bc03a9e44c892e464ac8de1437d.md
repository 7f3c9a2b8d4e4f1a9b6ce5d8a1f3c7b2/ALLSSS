### Title
Side Chain Dividend Pool Accounting Loss: Multiple Symbol Donations at Same Height Erase Previous Symbols

### Summary
The `Donate()` function in the side chain dividends pool contains a critical accounting error where donating a new token symbol at a block height that already has donations of different symbols completely erases the previous symbols' donation records. This occurs because the conditional logic at line 75 requires BOTH conditions to be true (existing dividends AND contains the specific symbol), causing the else block to create a new `Dividends` object that overwrites all previously recorded donations at that height.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** 
The logic retrieves existing dividends at the current height, then checks if both the dividends exist AND contain the input symbol using an AND operator. [2](#0-1) 

When the condition is false (either dividends don't exist OR they exist but don't contain the symbol), the else block creates a completely new `Dividends` object containing only the current symbol. [3](#0-2) 

This new object then overwrites the state, erasing any previously recorded donations at that height. [4](#0-3) 

**Why Protections Fail:**
The `Dividends` message is defined as a map structure that should accumulate multiple symbols. [5](#0-4) 

The state storage `SideChainReceivedDividends` is a mapping from block height to `Dividends`. [6](#0-5) 

However, the implementation fails to properly merge new symbols into existing `Dividends` objects when they don't contain the specific symbol being donated.

### Impact Explanation

**Harm:** 
- Donation accounting records are permanently lost from the state storage
- The `GetDividends` query returns incomplete and incorrect dividend information [7](#0-6) 
- While the actual tokens are still transferred to the contract and contributed to the TokenHolder scheme [8](#0-7) , the tracking state becomes inconsistent with reality
- Creates a permanent discrepancy between actual received donations and recorded state

**Affected Parties:**
- Users querying dividend information receive incorrect data
- Systems relying on donation history for analytics or auditing purposes
- Off-chain monitoring tools tracking donation flows

**Severity Justification:**
CRITICAL - This is a fundamental accounting integrity violation. While funds are not stolen, the protocol loses the ability to accurately track what was donated, violating the critical invariant of dividend distribution and settlement accuracy.

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities required. Any user can call the public `Donate()` function. [9](#0-8) 

**Attack Complexity:**
Trivial - occurs naturally during normal operations when different users donate different token symbols within the same block.

**Feasibility Conditions:**
- Multiple donations at the same block height (common in normal operations)
- Donations of different token symbols (expected functionality)
- No special timing or coordination required

**Probability:**
HIGH - This will occur whenever:
1. User A donates symbol X at block height H
2. User B donates symbol Y (different from X) at the same block height H
3. Both transactions are included in the same block and executed in order

Given that blocks can contain multiple transactions and donations of different symbols are a core feature, this scenario occurs naturally in production.

### Recommendation

**Code-Level Mitigation:**
Replace the faulty logic with proper conditional branching:

```csharp
var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
if (currentReceivedDividends == null)
{
    currentReceivedDividends = new Dividends
    {
        Value = { { input.Symbol, input.Amount } }
    };
}
else if (currentReceivedDividends.Value.ContainsKey(input.Symbol))
{
    currentReceivedDividends.Value[input.Symbol] = 
        currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
}
else
{
    currentReceivedDividends.Value[input.Symbol] = input.Amount;
}
State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
```

**Invariant Checks:**
- After donation, verify that all previously recorded symbols at the height are still present
- Add assertion: existing symbol count should never decrease after a donation

**Test Cases:**
1. Test multiple donations of the same symbol at same height (accumulation)
2. Test multiple donations of different symbols at same height (preservation)
3. Test interleaved donations: Symbol A → Symbol B → Symbol A again at same height
4. Verify `GetDividends` returns all donated symbols with correct amounts

### Proof of Concept

**Initial State:**
- Block height: 1000
- No previous donations at this height
- User A has approved ELF tokens
- User B has approved USDT tokens

**Transaction Sequence:**

**Step 1:** User A calls `Donate(symbol: "ELF", amount: 100)` at height 1000
- Execution reaches line 74: `currentReceivedDividends = null`
- Line 75 condition: `null != null` is FALSE
- Lines 79-87 execute: Creates `new Dividends { Value = { { "ELF", 100 } } }`
- Line 89: `State.SideChainReceivedDividends[1000] = { "ELF": 100 }`
- ✓ Expected: `GetDividends(1000)` returns `{ "ELF": 100 }`

**Step 2:** User B calls `Donate(symbol: "USDT", amount: 50)` at height 1000 (same block)
- Line 74: `currentReceivedDividends = { "ELF": 100 }`
- Line 75 condition: `{ "ELF": 100 } != null` is TRUE, but `ContainsKey("USDT")` is FALSE
- Full AND condition is FALSE
- Lines 79-87 execute: Creates `new Dividends { Value = { { "USDT", 50 } } }` (**ELF lost!**)
- Line 89: `State.SideChainReceivedDividends[1000] = { "USDT": 50 }`
- ✗ Expected: `GetDividends(1000)` returns `{ "ELF": 100, "USDT": 50 }`
- ✗ Actual: `GetDividends(1000)` returns `{ "USDT": 50 }`

**Success Condition:**
The vulnerability is exploited successfully when `GetDividends(1000)` returns only `{ "USDT": 50 }` instead of `{ "ELF": 100, "USDT": 50 }`, demonstrating that the ELF donation record was completely erased despite the actual tokens being transferred to the contract.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L37-37)
```csharp
    public override Empty Donate(DonateInput input)
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L44-64)
```csharp
        State.TokenContract.TransferFrom.Send(new TransferFromInput
        {
            From = Context.Sender,
            Symbol = input.Symbol,
            Amount = input.Amount,
            To = Context.Self
        });

        State.TokenContract.Approve.Send(new ApproveInput
        {
            Symbol = input.Symbol,
            Amount = input.Amount,
            Spender = State.TokenHolderContract.Value
        });

        State.TokenHolderContract.ContributeProfits.Send(new ContributeProfitsInput
        {
            SchemeManager = Context.Self,
            Symbol = input.Symbol,
            Amount = input.Amount
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L74-89)
```csharp
        var currentReceivedDividends = State.SideChainReceivedDividends[Context.CurrentHeight];
        if (currentReceivedDividends != null && currentReceivedDividends.Value.ContainsKey(input.Symbol))
            currentReceivedDividends.Value[input.Symbol] =
                currentReceivedDividends.Value[input.Symbol].Add(input.Amount);
        else
            currentReceivedDividends = new Dividends
            {
                Value =
                {
                    {
                        input.Symbol, input.Amount
                    }
                }
            };

        State.SideChainReceivedDividends[Context.CurrentHeight] = currentReceivedDividends;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SideChainDividendsPool.cs (L130-134)
```csharp
    public override Dividends GetDividends(Int64Value input)
    {
        Assert(Context.CurrentHeight > input.Value, "Cannot query dividends of a future block.");
        return State.SideChainReceivedDividends[input.Value];
    }
```

**File:** protobuf/acs10.proto (L65-68)
```text
message Dividends {
    // The dividends, symbol -> amount.
    map<string, int64> value = 1;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L57-57)
```csharp
    public MappedState<long, Dividends> SideChainReceivedDividends { get; set; }
```
