# Audit Report

## Title
Incorrect Accounting Assertion in Recharge() Causes Denial of Service for Valid Side Chain Recharges

## Summary
The `Recharge()` function contains a critical accounting error in its balance validation assertion. The assertion incorrectly adds `input.Amount` to a balance that already includes `input.Amount`, effectively requiring approximately double the mathematically correct amount. This causes legitimate recharge transactions to be wrongly rejected, preventing side chains in debt status from being reactivated.

## Finding Description

The vulnerability exists in the `Recharge()` method [1](#0-0)  where the balance validation logic is flawed.

**Execution Flow:**

1. The function first transfers the recharge amount to the side chain's virtual address [2](#0-1) 

2. If the side chain is in debt, it loops through arrears and transfers them to proposers [3](#0-2) 

3. After arrears are paid, it retrieves the current balance using `GetSideChainIndexingFeeDeposit()` [4](#0-3) 

4. It then performs an assertion check [5](#0-4) 

**The Bug:**

The `GetSideChainIndexingFeeDeposit()` method retrieves the current token balance of the virtual address [6](#0-5) , which at line 206 is AFTER the recharge and AFTER arrears payments. Therefore:

`originBalance = old_balance + input.Amount - arrearsAmount`

The assertion then checks:
```
input.Amount + originBalance >= arrearsAmount + IndexingPrice
```

Substituting the actual value of `originBalance`:
```
input.Amount + (old_balance + input.Amount - arrearsAmount) >= arrearsAmount + IndexingPrice
old_balance + 2*input.Amount >= 2*arrearsAmount + IndexingPrice
```

This incorrectly requires approximately double the necessary funds because `input.Amount` is counted twice.

**Correct Logic:**

The assertion should verify that after paying arrears, at least `IndexingPrice` remains:
```
old_balance + input.Amount >= arrearsAmount + IndexingPrice
```

Or simply: `originBalance >= IndexingPrice` (since `originBalance` already accounts for recharge minus arrears)

## Impact Explanation

**High Severity - Denial of Service:**

This bug blocks the critical recovery mechanism for side chains in debt. When a side chain falls into `IndexingFeeDebt` status, operators attempting to recharge with the mathematically correct minimum amount will be incorrectly rejected.

**Concrete Example:**
- Existing balance: 75 tokens
- Arrears owed: 100 tokens  
- Required minimum balance: 50 tokens
- User provides: 75 tokens (exactly sufficient)

**Expected:** 75 + 75 - 100 = 50 ≥ 50 ✓ (Should succeed)
**Actual:** 75 + 50 ≥ 100 + 50 → 125 ≥ 150 ✗ (Fails)

**Affected Parties:**
- Side chain creators unable to clear accumulated debt
- Side chain operators unable to maintain service continuity
- Users of side chains stuck in non-operational debt status

The vulnerability completely blocks debt recovery unless users overpay by approximately double the required amount, causing unnecessary capital inefficiency and potential permanent side chain unavailability.

## Likelihood Explanation

**High Likelihood:**

The bug manifests in normal operational scenarios without requiring any adversarial action:

1. **Reachable Entry Point:** The `Recharge()` function is publicly accessible to any user [7](#0-6) 

2. **Common Preconditions:**
   - Side chain naturally enters `IndexingFeeDebt` status when indexing fees deplete the balance [8](#0-7) 
   - Side chain has accumulated arrears to proposers
   - Side chain has non-zero existing balance
   - User has approved token allowance

3. **Economic Incentive:** Users naturally attempt to recharge with minimum required amounts to minimize capital lockup, directly triggering this bug.

4. **No Special Attack Required:** This is a logic error affecting legitimate operations, not an exploit requiring special knowledge or privileges.

## Recommendation

Replace the incorrect assertion at line 207 with the correct balance check:

**Option 1 (Recommended - Clear and Simple):**
```csharp
var originBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(originBalance >= sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

**Option 2 (Alternative - Pre-transfer Validation):**
Before processing arrears transfers, validate:
```csharp
var oldBalance = GetSideChainIndexingFeeDeposit(chainId);
Assert(oldBalance + input.Amount >= arrearsAmount + sideChainInfo.IndexingPrice,
    "Indexing fee recharging not enough.");
```

Option 1 is preferred as it validates the actual post-state, which is the correct invariant to check.

## Proof of Concept

The existing test at lines 337-441 of `test/AElf.Contracts.CrossChain.Tests/CrossChainIndexingActionTest.cs` only passes because `old_balance = 0`. 

To expose the bug, modify the test scenario:
```csharp
// Setup: Create side chain with some existing balance (75 tokens)
// Let it accumulate 100 tokens in arrears
// IndexingPrice = 50 tokens

// Attempt to recharge with exactly 75 tokens (which should be sufficient)
var rechargeInput = new RechargeInput
{
    ChainId = sideChainId,
    Amount = 75
};

// Expected: Should succeed (75 + 75 - 100 = 50 >= 50)
// Actual: Will fail with "Indexing fee recharging not enough"
// Because assertion checks: 75 + 50 >= 100 + 50 → 125 >= 150 ✗
```

The vulnerability is triggered when a side chain with non-zero balance accumulates debt and users attempt to recharge with the exact minimum required amount rather than ~2x the amount.

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L174-215)
```csharp
    public override Empty Recharge(RechargeInput input)
    {
        var chainId = input.ChainId;
        var sideChainInfo = State.SideChainInfo[chainId];
        Assert(sideChainInfo != null && sideChainInfo.SideChainStatus != SideChainStatus.Terminated,
            "Side chain not found or incorrect side chain status.");

        TransferFrom(new TransferFromInput
        {
            From = Context.Sender,
            To = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol,
            Amount = input.Amount,
            Memo = "Indexing fee recharging."
        });

        long arrearsAmount = 0;
        if (sideChainInfo.SideChainStatus == SideChainStatus.IndexingFeeDebt)
        {
            // arrears
            foreach (var arrears in sideChainInfo.ArrearsInfo)
            {
                arrearsAmount += arrears.Value;
                TransferDepositToken(new TransferInput
                {
                    To = Address.Parser.ParseFrom(ByteString.FromBase64(arrears.Key)),
                    Symbol = Context.Variables.NativeSymbol,
                    Amount = arrears.Value,
                    Memo = "Indexing fee recharging."
                }, chainId);
            }

            var originBalance = GetSideChainIndexingFeeDeposit(chainId);
            Assert(input.Amount + originBalance >= arrearsAmount + sideChainInfo.IndexingPrice,
                "Indexing fee recharging not enough.");
        }

        sideChainInfo.ArrearsInfo.Clear();
        sideChainInfo.SideChainStatus = SideChainStatus.Active;
        State.SideChainInfo[chainId] = sideChainInfo;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L88-98)
```csharp
    private long GetSideChainIndexingFeeDeposit(int chainId)
    {
        SetContractStateRequired(State.TokenContract, SmartContractConstants.TokenContractSystemName);
        var balanceOutput = State.TokenContract.GetBalance.Call(new GetBalanceInput
        {
            Owner = Context.ConvertVirtualAddressToContractAddress(ConvertChainIdToHash(chainId)),
            Symbol = Context.Variables.NativeSymbol
        });

        return balanceOutput.Balance;
    }
```
