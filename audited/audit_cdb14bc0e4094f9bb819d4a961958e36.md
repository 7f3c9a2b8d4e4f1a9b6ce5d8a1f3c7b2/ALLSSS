### Title
Missing LIB Validation in NextRound/NextTerm Allows Future Irreversible Block Heights to Persist in Consensus State

### Summary
The `LibInformationValidationProvider` only validates LIB (Last Irreversible Block) fields for `UpdateValue` behavior, but not for `NextRound` or `NextTerm` behaviors. Additionally, the round hash validation excludes LIB fields from the integrity check. A malicious miner can inject future LIB heights when producing NextRound/NextTerm blocks, which permanently corrupts the consensus state and breaks block production throttling logic.

### Finding Description

**Root Cause:**

The `LibInformationValidationProvider` is only added for `UpdateValue` behavior: [1](#0-0) 

For `NextRound` and `NextTerm` behaviors, no LIB validation occurs. These behaviors include full Round information with LIB fields: [2](#0-1) 

**Why Protection Fails:**

1. **Pre-execution validation missing:** The validation switch statement doesn't add `LibInformationValidationProvider` for NextRound/NextTerm cases.

2. **Hash integrity check excludes LIB fields:** The `GetCheckableRound` method creates a round representation for hashing that explicitly excludes `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber`: [3](#0-2) 

The checkable round only includes `RoundNumber`, `TermNumber`, `RealTimeMinersInformation`, and `BlockchainAge` (lines 199-205), allowing miners to modify LIB fields without breaking hash validation: [4](#0-3) 

3. **Direct storage without recalculation:** `ProcessNextRound` stores the provided round directly without recalculating or validating LIB values: [5](#0-4) 

4. **Persistence across rounds:** When generating subsequent rounds, the corrupted LIB values are copied forward: [6](#0-5) 

**Execution Path:**

1. Miner requests consensus extra data for NextRound via standard consensus flow
2. Contract generates Round with legitimate LIB values copied from current round
3. Miner modifies `ConfirmedIrreversibleBlockHeight` and `ConfirmedIrreversibleBlockRoundNumber` to arbitrary future values
4. Modified Round passes `ValidateBeforeExecution` (no LibInformationValidationProvider)
5. Modified Round passes `ValidateAfterExecution` (GetHash excludes LIB fields)
6. `ProcessNextRound` stores corrupted Round via `AddRoundInformation` [7](#0-6) 

### Impact Explanation

**Direct Consensus Integrity Impact:**

1. **Block production throttling failure:** The `GetMaximumBlocksCount` method uses LIB round number to evaluate blockchain mining status and throttle block production when LIB lags: [8](#0-7) 

With a future LIB round number (e.g., `libRoundNumber = 200` when `currentRoundNumber = 101`), the evaluator logic breaks:
- Normal status checks: `libRoundNumber + 2 < currentRoundNumber` evaluates to `202 < 101 = false`
- The mining status remains incorrectly in "Normal" mode even if the real LIB is far behind
- Block production throttling designed to prevent excessive forking is bypassed

2. **Permanent state corruption:** Once injected, the corrupted LIB persists because:
   - Future NextRound blocks copy the corrupted value forward
   - UpdateValue blocks only update LIB if calculated value exceeds stored value: [9](#0-8) 
   - A future LIB (e.g., height 1000000) will never be exceeded by legitimate calculations, preventing correction

3. **Cross-chain indexing compromise:** Cross-chain operations rely on LIB heights to determine finality. Invalid LIB heights could cause cross-chain indexing to reference non-existent blocks or skip valid blocks.

**Severity Justification:**

HIGH severity because it:
- Breaks core consensus invariant (LIB height rules)
- Permanently corrupts consensus state across all future rounds
- Disables critical safety mechanism (block production throttling)
- Requires only miner privileges (not additional compromise)
- Has deterministic, irreversible impact

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being a valid miner in the current round
- Standard miner privileges, no additional permissions needed
- Can execute during normal NextRound/NextTerm block production

**Attack Complexity:**
- Low: Simply modify LIB fields in the Round message before including in block header
- No timing constraints beyond normal miner slot
- Single malicious block sufficient to corrupt state permanently

**Feasibility Conditions:**
- Attacker must be in active miner set
- Must be their turn to produce a NextRound or NextTerm block
- NextRound blocks occur regularly during normal operation
- NextTerm blocks occur at term boundaries (less frequent but predictable)

**Detection/Operational Constraints:**
- Difficult to detect: Modified LIB values appear in state but don't trigger validation failures
- No events or logs indicate LIB manipulation
- Requires inspecting Round state and comparing with actual blockchain height
- Once injected, correction requires manual intervention or protocol upgrade

**Probability:** HIGH
- Any miner in the active set can exploit
- NextRound blocks are common (occur every round)
- No technical barriers to modification
- Low cost (normal block production)

### Recommendation

**Immediate Fix:**

1. **Add LIB validation for all consensus behaviors:**

Modify the validation switch statement to include `LibInformationValidationProvider` for NextRound and NextTerm: [10](#0-9) 

2. **Add upper bound check in LibInformationValidationProvider:**

Extend the validation logic to reject future LIB values: [11](#0-10) 

Add checks:
```csharp
// Reject future LIB heights
if (providedRound.ConfirmedIrreversibleBlockHeight > validationContext.BaseRound.ConfirmedIrreversibleBlockHeight)
{
    validationResult.Message = "LIB height cannot exceed current confirmed height.";
    return validationResult;
}

// Reject future LIB round numbers
if (providedRound.ConfirmedIrreversibleBlockRoundNumber > validationContext.CurrentRoundNumber)
{
    validationResult.Message = "LIB round number cannot exceed current round.";
    return validationResult;
}
```

3. **Include LIB fields in hash validation:**

Modify `GetCheckableRound` to include LIB fields in the round hash to prevent tampering: [12](#0-11) 

**Test Cases:**

1. Test NextRound with LIB height > current blockchain height → should reject
2. Test NextRound with LIB round > current round number → should reject
3. Test NextTerm with modified LIB values → should reject
4. Test that legitimate LIB preservation in NextRound/NextTerm still works
5. Test that GetMaximumBlocksCount behaves correctly after fix

### Proof of Concept

**Initial State:**
- Blockchain at height 1000, current round 100
- Current round has `ConfirmedIrreversibleBlockHeight = 900`, `ConfirmedIrreversibleBlockRoundNumber = 98`
- Attacker is a valid miner in the miner set

**Attack Steps:**

1. Attacker's turn to produce NextRound block arrives
2. Attacker calls `GetConsensusExtraData` to get legitimate consensus data
3. Contract returns `AElfConsensusHeaderInformation` with Round containing:
   - `RoundNumber = 101`
   - `ConfirmedIrreversibleBlockHeight = 900`
   - `ConfirmedIrreversibleBlockRoundNumber = 98`

4. Attacker modifies the Round message before including in block:
   - Changes `ConfirmedIrreversibleBlockHeight` to `999999`
   - Changes `ConfirmedIrreversibleBlockRoundNumber` to `500`

5. Attacker produces block with modified Round

**Expected (Secure) Result:**
- `ValidateBeforeExecution` should reject with "LIB height cannot be in the future"
- Block rejected, state unchanged

**Actual (Vulnerable) Result:**
- `ValidateBeforeExecution` passes (no LibInformationValidationProvider for NextRound)
- `ValidateAfterExecution` passes (GetHash excludes LIB fields)
- Block accepted and executed
- `AddRoundInformation` stores corrupted Round 101 with `ConfirmedIrreversibleBlockHeight = 999999`
- Subsequent rounds copy this value forward
- `GetMaximumBlocksCount` now uses `libRoundNumber = 500` when `currentRoundNumber = 101`, breaking status evaluation
- Corruption persists indefinitely

**Success Condition:**
Query `GetRoundInformation(101)` returns Round with `ConfirmedIrreversibleBlockHeight = 999999`, confirming permanent state corruption.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L79-92)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextRoundInput.cs (L16-17)
```csharp
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L185-207)
```csharp
    private byte[] GetCheckableRound(bool isContainPreviousInValue = true)
    {
        var minersInformation = new Dictionary<string, MinerInRound>();
        foreach (var minerInRound in RealTimeMinersInformation.Clone())
        {
            var checkableMinerInRound = minerInRound.Value.Clone();
            checkableMinerInRound.EncryptedPieces.Clear();
            checkableMinerInRound.DecryptedPieces.Clear();
            checkableMinerInRound.ActualMiningTimes.Clear();
            if (!isContainPreviousInValue) checkableMinerInRound.PreviousInValue = Hash.Empty;

            minersInformation.Add(minerInRound.Key, checkableMinerInRound);
        }

        var checkableRound = new Round
        {
            RoundNumber = RoundNumber,
            TermNumber = TermNumber,
            RealTimeMinersInformation = { minersInformation },
            BlockchainAge = BlockchainAge
        };
        return checkableRound.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L100-101)
```csharp
            if (headerInformation.Round.GetHash(isContainPreviousInValue) !=
                currentRound.GetHash(isContainPreviousInValue))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L108-159)
```csharp
    private void ProcessNextRound(NextRoundInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        TryToGetCurrentRoundInformation(out var currentRound);

        // Do some other stuff during the first time to change round.
        if (currentRound.RoundNumber == 1)
        {
            // Set blockchain start timestamp.
            var actualBlockchainStartTimestamp =
                currentRound.FirstActualMiner()?.ActualMiningTimes.FirstOrDefault() ??
                Context.CurrentBlockTime;
            SetBlockchainStartTimestamp(actualBlockchainStartTimestamp);

            // Initialize current miners' information in Election Contract.
            if (State.IsMainChain.Value)
            {
                var minersCount = GetMinersCount(nextRound);
                if (minersCount != 0 && State.ElectionContract.Value != null)
                {
                    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
                    {
                        MinersCount = minersCount
                    });
                }
            }
        }

        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }

        AddRoundInformation(nextRound);

        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L272-281)
```csharp
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L69-70)
```csharp
        nextRound.ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight;
        nextRound.ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L25-39)
```csharp
        var libRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;
        var libBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        var currentHeight = Context.CurrentHeight;
        var currentRoundNumber = currentRound.RoundNumber;

        Context.LogDebug(() =>
            $"Calculating max blocks count based on:\nR_LIB: {libRoundNumber}\nH_LIB:{libBlockHeight}\nR:{currentRoundNumber}\nH:{currentHeight}");

        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;

        var blockchainMiningStatusEvaluator = new BlockchainMiningStatusEvaluator(libRoundNumber,
            currentRoundNumber, AEDPoSContractConstants.MaximumTinyBlocksCount);
        blockchainMiningStatusEvaluator.Deconstruct(out var blockchainMiningStatus);

        Context.LogDebug(() => $"Current blockchain mining status: {blockchainMiningStatus.ToString()}");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/LibInformationValidationProvider.cs (L8-34)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        var baseRound = validationContext.BaseRound;
        var providedRound = validationContext.ProvidedRound;
        var pubkey = validationContext.SenderPubkey;
        if (providedRound.ConfirmedIrreversibleBlockHeight != 0 &&
            providedRound.ConfirmedIrreversibleBlockRoundNumber != 0 &&
            (baseRound.ConfirmedIrreversibleBlockHeight > providedRound.ConfirmedIrreversibleBlockHeight ||
             baseRound.ConfirmedIrreversibleBlockRoundNumber > providedRound.ConfirmedIrreversibleBlockRoundNumber))
        {
            validationResult.Message = "Incorrect lib information.";
            return validationResult;
        }

        if (providedRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight != 0 &&
            baseRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight >
            providedRound.RealTimeMinersInformation[pubkey].ImpliedIrreversibleBlockHeight)
        {
            validationResult.Message = "Incorrect implied lib height.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
    }
```
