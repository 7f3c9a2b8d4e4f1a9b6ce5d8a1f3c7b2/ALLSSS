# Audit Report

## Title
TOCTOU Vulnerability: Consensus Behaviour Not Re-Validated at Block Execution Allowing Invalid Round/Term Transitions

## Summary
The AEDPoS consensus system determines whether to execute NextRound or NextTerm behaviour when `GetConsensusCommand` is called, but never re-validates this decision during block execution. Between command generation and block production, the blockchain state can change such that the cached behaviour becomes incorrect, allowing term transitions to be improperly skipped or executed, breaking consensus integrity, economic distributions, and governance mechanisms.

## Finding Description

The vulnerability exists in a critical Time-of-Check-Time-of-Use (TOCTOU) gap in the consensus command generation and validation flow.

**Command Generation**: When a miner requests a consensus command, the behaviour (NextRound vs NextTerm) is determined by calling `MainChainConsensusBehaviourProvider.GetConsensusBehaviourToTerminateCurrentRound()`, which evaluates `currentRound.NeedToChangeTerm()`. [1](#0-0) 

The `NeedToChangeTerm()` method checks if at least `MinersCountOfConsent` (2/3 of miners) have their latest `ActualMiningTime` crossing the term boundary threshold: [2](#0-1) 

This behaviour is embedded in the `ConsensusCommand` hint: [3](#0-2) 

The command is then cached in `ConsensusService._consensusCommand` for later use: [4](#0-3) 

**The Critical Gap**: When the block is produced, the cached behaviour is used directly without re-validation. The `GetConsensusBlockExtraData` method extracts and uses `triggerInformation.Behaviour`: [5](#0-4) 

**Validation Failure**: The `ValidateBeforeExecution` method applies validators based on the claimed behaviour but never re-checks whether that behaviour is still correct: [6](#0-5) 

The `RoundTerminateValidationProvider` only validates that numbers increment correctly for the given behaviour, not whether the behaviour itself matches current state: [7](#0-6) 

**State Changes Between Check and Use**: Between command generation and block execution, other miners produce blocks that update their `ActualMiningTimes`: [8](#0-7) 

This can change the result of `NeedToChangeTerm()` from false to true (or vice versa), but the cached behaviour is still used without re-evaluation.

## Impact Explanation

**When NextRound is used instead of NextTerm (most critical scenario):**

The `ProcessNextTerm` method performs critical operations that get entirely skipped: [9](#0-8) 

Specifically:
1. **Consensus Integrity Violation**: Term number fails to increment (line 173), miner list doesn't update (lines 187-190), potentially keeping malicious/inactive miners in the consensus set
2. **Economic System Disruption**: Mining rewards are NOT donated to Treasury via `DonateMiningReward()` (lines 203-211), and `Treasury.Release` is NOT called, completely disrupting the economic reward distribution cycle for that term
3. **Governance Mechanism Failure**: `Election.TakeSnapshot` is NOT called (lines 213-218), meaning the Election contract never receives updated miner statistics, breaking the entire election and voting mechanism that depends on term snapshots
4. **Statistics Corruption**: `MissedTimeSlots` and `ProducedBlocks` counters don't reset (lines 179-183), causing them to accumulate indefinitely and corrupting miner performance tracking

**When NextTerm is used instead of NextRound:**
Premature term changes cause incorrect timing of all term-dependent operations, early statistics resets, and premature miner list updates.

**Affected Parties**: All network participants - miners lose correct rewards, token holders are affected by treasury/profit distribution failures, and governance participants lose election integrity.

## Likelihood Explanation

**Natural Occurrence**: At term boundaries when the count of miners crossing the threshold is exactly at the `MinersCountOfConsent` point, concurrent block production by different miners can easily cause the state to flip between command generation and execution. The `MinersCountOfConsent` is 2/3 + 1 of total miners: [10](#0-9) 

**Malicious Exploitation**: A miner can deliberately:
1. Call `GetConsensusCommand` and receive a NextRound command when `NeedToChangeTerm()` returns false
2. Wait for other miners to produce blocks that update their `ActualMiningTimes`
3. Once enough miners have crossed the threshold (making `NeedToChangeTerm()` return true if re-checked)
4. Produce their block with the stale NextRound behaviour
5. The validation passes because it only checks number increments, not behaviour correctness

**Timing Window**: The gap between command caching and block execution is inherent to the consensus architecture and can be several seconds in distributed systems with network delays.

**Detection Difficulty**: The invalid transition appears legitimate because all validation checks pass - there's no re-evaluation of whether the behaviour matches the current state.

## Recommendation

Re-validate the consensus behaviour decision during `ValidateBeforeExecution` by calling `NeedToChangeTerm()` again with the current blockchain state and comparing it against the claimed behaviour in the header information.

Modify `RoundTerminateValidationProvider.ValidateHeaderInformation()` to include:

```csharp
// After existing validation, add behaviour correctness check
var blockchainStartTimestamp = GetBlockchainStartTimestamp();
var periodSeconds = State.PeriodSeconds.Value;
var shouldChangeTerm = validationContext.BaseRound.NeedToChangeTerm(
    blockchainStartTimestamp, 
    validationContext.CurrentTermNumber, 
    periodSeconds);

if (shouldChangeTerm && extraData.Behaviour != AElfConsensusBehaviour.NextTerm)
{
    return new ValidationResult { 
        Message = "Current state requires NextTerm but NextRound was provided." 
    };
}

if (!shouldChangeTerm && extraData.Behaviour == AElfConsensusBehaviour.NextTerm)
{
    return new ValidationResult { 
        Message = "Current state requires NextRound but NextTerm was provided." 
    };
}
```

This ensures the behaviour decision is re-evaluated with the current state before block execution, closing the TOCTOU gap.

## Proof of Concept

Due to the complexity of the AEDPoS consensus system requiring full blockchain context, miner setup, and precise timing control, a complete PoC would require:

1. Initialize a test chain with multiple miners
2. Configure term period and advance blockchain time to near term boundary
3. Have exactly `MinersCountOfConsent - 1` miners cross the term threshold
4. Miner A calls GetConsensusCommand â†’ receives NextRound
5. Other miners produce blocks, pushing their ActualMiningTimes past threshold
6. Miner A produces block with cached NextRound command
7. Observe: Block validates successfully but ProcessNextTerm is not called
8. Verify: Term number unchanged, Treasury.Release not called, Election.TakeSnapshot not called

The vulnerability is confirmed through code analysis showing no re-validation exists in the execution path, making exploitation feasible at term boundaries.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TerminateRoundCommandStrategy.cs (L23-39)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeExtraBlockMiningTime(CurrentRound, Pubkey, CurrentBlockTime);
            return new ConsensusCommand
            {
                Hint = new AElfConsensusHint
                    {
                        Behaviour = _isNewTerm ? AElfConsensusBehaviour.NextTerm : AElfConsensusBehaviour.NextRound
                    }
                    .ToByteString(),
                ArrangedMiningTime = arrangedMiningTime,
                MiningDueTime = arrangedMiningTime.AddMilliseconds(MiningInterval),
                LimitMillisecondsOfMiningBlock =
                    _isNewTerm ? LastBlockOfCurrentTermMiningLimit : DefaultBlockMiningLimit
            };
        }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L74-87)
```csharp
        _consensusCommand = await _contractReaderFactory
            .Create(contractReaderContext).GetConsensusCommand
            .CallAsync(triggerInformation);

        if (_consensusCommand == null)
        {
            Logger.LogWarning("Consensus command is null.");
            return;
        }

        Logger.LogDebug($"Updated consensus command: {_consensusCommand}");

        // Update next mining time, also block time of both getting consensus extra data and txs.
        _nextMiningTime = _consensusCommand.ArrangedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L26-48)
```csharp
        switch (triggerInformation.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
                if (!isGeneratingTransactions) information.Round = information.Round.GetUpdateValueRound(pubkey);

                break;

            case AElfConsensusBehaviour.TinyBlock:
                information = GetConsensusExtraDataForTinyBlock(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextRound:
                information = GetConsensusExtraDataForNextRound(currentRound, pubkey,
                    triggerInformation);
                break;

            case AElfConsensusBehaviour.NextTerm:
                information = GetConsensusExtraDataForNextTerm(pubkey, triggerInformation);
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L55-64)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataToPublishOutValue(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        currentRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = currentRound
            .RealTimeMinersInformation[pubkey].ProducedTinyBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            currentRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        currentRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-221)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);

        if (!TryToGetPreviousRoundInformation(out var previousRound))
            Assert(false, "Failed to get previous round information.");

        UpdateCurrentMinerInformationToElectionContract(previousRound);

        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }

        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });

        Context.LogDebug(() => $"Changing term number to {nextRound.TermNumber}");
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```
