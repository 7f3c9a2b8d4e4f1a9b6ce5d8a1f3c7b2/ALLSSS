### Title
Time-of-Check-Time-of-Use (TOCTOU) Race Condition Allows Multiple Proposals with Same Salt Leading to Governance Resource Waste

### Summary
The `DeployUserSmartContract` function validates salt availability at proposal creation time but does not recheck at execution time in `PerformDeployUserSmartContract`. This allows multiple proposals with the same salt value to pass initial validation and proceed through full governance approval, even though only the first to execute can succeed, wasting governance resources and validator effort on proposals destined to fail.

### Finding Description

The vulnerability exists in the contract deployment flow across two functions: [1](#0-0) 

At proposal creation time, `AssertContractAddressAvailable` checks if the salt-based address is available. However, the proposal input hash is calculated from the entire input including code: [2](#0-1) 

This means proposals with the same salt but different code or category will have different proposal hashes and can both be registered: [3](#0-2) 

During execution, the salt is passed directly from the stored proposal parameters to `DeploySmartContract` without revalidation: [4](#0-3) 

The only enforcement happens deep in the deployment helper: [5](#0-4) 

This creates a TOCTOU gap where multiple proposals pass the initial check at line 421 but only one can succeed at execution, causing the assertion at line 40 to fail for subsequent proposals.

### Impact Explanation

This vulnerability causes operational impact on governance flows:

1. **Governance Resource Waste**: Multiple proposals with the same salt proceed through full parliamentary voting, consuming validator time and voting power
2. **Code Review Waste**: Validators perform complete code audits on contracts that cannot be deployed
3. **Unpredictable Execution**: When multiple valid proposals exist with the same salt, users cannot predict which will execute first, creating race conditions
4. **Transaction Fee Loss**: Proposal creators and executors pay fees for transactions that will inevitably fail

The issue is particularly severe in side-chain deployments where the test suite confirms this behavior: [6](#0-5) 

### Likelihood Explanation

The vulnerability is highly likely to occur:

**Attacker Capabilities**: Any user authorized to create contract deployment proposals (standard user on side-chains, whitelisted users on main chain) can trigger this. No special privileges required.

**Attack Complexity**: Trivial - simply submit multiple `DeployUserSmartContract` calls with the same salt but different contract code.

**Feasibility Conditions**: 
- User creates Proposal P1 with `{category: 0, code: C1, salt: S}`
- User creates Proposal P2 with `{category: 0, code: C2, salt: S}` 
- Both pass initial validation since contract not yet deployed
- Both proposals get different hashes: `Hash(0, C1, S)` ≠ `Hash(0, C2, S)`
- Both proceed through governance approval and code review
- P1 executes successfully, deploying at `Address(user, S)`
- P2 execution fails with "Contract address exists"

**Economic Rationality**: While intentional attacks seem unlikely, accidental collisions are realistic when users reuse common salts or test values. The cost is just normal proposal fees.

### Recommendation

Add a salt revalidation check in `PerformDeployUserSmartContract` before calling `DeploySmartContract`:

```csharp
public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
{
    RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

    var inputHash = CalculateHashFromInput(input);
    TryClearContractProposingData(inputHash, out var contractProposingInput);

    // Add revalidation before deployment
    if (input.Salt != null)
    {
        AssertContractAddressAvailable(contractProposingInput.Author, input.Salt);
    }

    var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
        contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
    return address;
}
```

This ensures the assertion at line 40 of the helper becomes a proper validation error with clear messaging rather than a cryptic assertion failure.

Additionally, consider implementing a global salt registry to track pending proposals and prevent duplicate salts from being proposed in the first place.

### Proof of Concept

**Initial State**: Side chain with user contract deployment enabled

**Step 1**: User creates first proposal with salt `Hash("test")`
```
DeployUserSmartContract({
    category: 0,
    code: <TokenConverter_bytecode>,
    salt: Hash("test")
})
```
Result: Proposal P1 created with hash `H1 = Hash(0, TokenConverter, Hash("test"))`

**Step 2**: Same user creates second proposal with same salt, different code
```
DeployUserSmartContract({
    category: 0,  
    code: <TokenHolder_bytecode>,
    salt: Hash("test")
})
```
Result: Proposal P2 created with hash `H2 = Hash(0, TokenHolder, Hash("test"))` where `H2 ≠ H1`

**Step 3**: Both proposals pass governance approval and code checks

**Step 4**: P1 executes successfully
```
ReleaseApprovedUserSmartContract(proposalId: P1)
→ PerformDeployUserSmartContract is called
→ Contract deployed at Address(user, Hash("test"))
```

**Step 5**: P2 execution fails
```
ReleaseApprovedUserSmartContract(proposalId: P2)  
→ PerformDeployUserSmartContract is called
→ Fails at line 40: "Contract address exists"
```

**Expected**: P2 should be rejected at proposal creation time  
**Actual**: P2 proceeds through full governance and fails at execution

This demonstrates wasted governance cycles and the TOCTOU vulnerability in salt validation.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L419-422)
```csharp
        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L424-427)
```csharp
        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L502-503)
```csharp
        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L34-40)
```csharp
        else
        {
            serialNumber = 0;
            contractAddress = AddressHelper.ComputeContractAddress(deployer, salt);
        }

        Assert(State.ContractInfos[contractAddress] == null, "Contract address exists.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L314-315)
```csharp
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractTests_Deterministic.cs (L57-75)
```csharp
        code = ByteString.CopyFrom(Codes.Single(kv => kv.Key.Contains("TestContract.BasicSecurity")).Value);
        var result = await DeployWithResultAsync(SideChainTester, SideParliamentAddress, SideBasicContractZeroAddress,
            new ContractDeploymentInput
            {
                Category = KernelConstants.DefaultRunnerCategory, // test the default runner
                Code = code,
                ContractOperation = new ContractOperation
                {
                    ChainId = sideChainId,
                    CodeHash = HashHelper.ComputeFrom(code.ToByteArray()),
                    Deployer = CreatorAddress,
                    Salt = salt,
                    Version = 1,
                    Signature = GenerateContractSignature(CreatorKeyPair.PrivateKey, sideChainId,
                        HashHelper.ComputeFrom(code.ToByteArray()), CreatorAddress, salt, 1)
                }
            });
        result.Error.ShouldContain("Contract address exists");
    }
```
