# Audit Report

## Title
Retroactive Vote Weight Inequality - Early Voters Maintain Inflated Weights After Interest Rate Changes

## Summary
The `SetVoteWeightInterest()` function modifies interest rates that affect vote weight calculations for new votes, but existing votes permanently retain their original weights calculated at creation time. This creates unfair reward distribution where early voters who locked in higher interest rates maintain inflated profit shares indefinitely, while later voters voting with identical parameters receive reduced shares after rate decreases.

## Finding Description

**Root Cause:**

When `SetVoteWeightInterest()` updates interest rates, it only modifies the state variable without recalculating existing vote weights stored in the profit contract: [1](#0-0) 

Vote weights are calculated once at vote creation using the current interest rates and then permanently stored as "shares" in the profit scheme: [2](#0-1) 

The weight calculation uses the current `State.VoteWeightInterestList.Value`: [3](#0-2) 

These shares are then permanently stored in the profit contract: [4](#0-3) [5](#0-4) 

**Why Weights Are Never Updated:**

Even when votes are extended via `ExtendVoterWelfareProfits()`, the existing weight is reused, not recalculated: [6](#0-5) 

The `FixProfitDetail` method clones the profit detail, preserving the original shares value: [7](#0-6) 

**Reward Distribution Impact:**

Profit distribution uses a proportional formula based on shares. The calculation multiplies beneficiary shares by the distributed amount and divides by total shares: [8](#0-7) [9](#0-8) 

Voters with higher shares receive proportionally more rewards, even after rate changes should have equalized their weights.

## Impact Explanation

**Direct Reward Misallocation:**
- Early voters who locked in higher interest rates maintain permanently inflated profit shares
- Later voters with identical voting parameters (amount, duration) receive reduced shares and rewards
- The disparity persists for entire lock periods (up to `MaximumLockTime`, potentially years)

**Quantified Example:**
1. User A votes 100 tokens for 365 days when interest rate produces weight = 200
2. Governance lowers interest rates via `SetVoteWeightInterest`
3. User B votes 100 tokens for 365 days, now receives weight = 150
4. When profits are distributed:
   - User A receives: `(200 / 350) * distributed_profits = 57.1%`
   - User B receives: `(150 / 350) * distributed_profits = 42.9%`
   - **User A gets 33% more rewards despite identical voting parameters**

**Affected Parties:**
- All voters participating in election governance rewards via the CitizenWelfare scheme
- New voters are systematically disadvantaged after rate decreases
- Protocol fairness and economic incentive alignment compromised

**Severity Justification:**
This violates the core invariant that identical voting parameters (amount and duration) should receive identical rewards. The vulnerability creates permanent economic asymmetries in governance participation, undermining the fairness of the reward distribution system.

## Likelihood Explanation

**Highly Practical Occurrence:**
- **Entry Point**: Public voting methods accessible to all users
- **Trigger**: Governance-controlled `SetVoteWeightInterest()` (legitimate governance action)
- **Attacker Capabilities**: None required beyond normal voting rights
- **No Special Preconditions**: Works with any interest rate decrease

**Realistic Scenarios:**

*Scenario 1 - Malicious Governance:*
Malicious governance controllers and allies vote early to lock in high weights, then propose and execute `SetVoteWeightInterest` to lower rates, causing competitors and new voters to receive permanently reduced weights while the coalition maintains disproportionate rewards.

*Scenario 2 - Front-Running:*
When governance proposes a legitimate rate decrease, sophisticated voters can front-run the proposal execution to lock in higher weights before regular users vote after the rate change.

*Scenario 3 - Natural Occurrence:*
Even without malicious intent, when governance legitimately adjusts rates for economic reasons, early voters accidentally maintain advantageous weights while new users unknowingly receive worse terms.

**Detection Difficulty:**
The weight disparity is not easily visible on-chain without comparing historical interest rates to current vote weights, making it unlikely regular users detect the unfairness until they compare their reward distributions.

**Economic Rationality:**
There is zero cost and pure upside for voters who happen to vote before rate decreases, creating a natural incentive to vote before anticipated rate adjustments.

## Recommendation

Implement a mechanism to recalculate and update existing vote weights when interest rates change. Consider one of these approaches:

**Option 1: Batch Recalculation**
When `SetVoteWeightInterest()` is called, iterate through active votes and recalculate their weights based on new interest rates, updating the corresponding profit detail shares.

**Option 2: Lazy Recalculation**
Store the interest rate version with each vote. When claiming profits or extending votes, check if the voter's interest rate version differs from the current version, and recalculate weights if needed.

**Option 3: Time-Weighted Fair Distribution**
Instead of using fixed shares, calculate rewards based on the time-weighted average of applicable interest rates during the lock period, ensuring fairness regardless of when rates changed.

**Option 4: Grace Period for Existing Voters**
When changing interest rates, provide a grace period during which existing voters can choose to either keep their current weights or adopt the new rates, ensuring transparency and choice.

The recommended approach is Option 2 (Lazy Recalculation) as it balances fairness with gas efficiency by only recalculating when necessary.

## Proof of Concept

```csharp
// POC Test: VoteWeightInequalityAfterInterestRateChange
// This test demonstrates that two users voting with identical parameters
// receive different rewards when interest rates change between their votes

[Fact]
public async Task VoteWeightInequalityAfterInterestRateChange()
{
    // Setup: Initialize election contract and welfare scheme
    await InitializeElectionContract();
    
    // User A votes 100 tokens for 365 days with initial high interest rate
    var userAVoteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = CandidatePubkey,
        Amount = 100_00000000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365)
    });
    
    // Get User A's vote weight (calculated with high interest rate)
    var userAWeight = await GetVoteWeight(userAVoteResult.TransactionResult.ReturnValue);
    // Expected: userAWeight = ~200 (example value)
    
    // Governance changes interest rates to lower values
    await ParliamentContractStub.SetVoteWeightInterest.SendAsync(new VoteWeightInterestList
    {
        VoteWeightInterestInfos = {
            new VoteWeightInterest { Day = 365, Interest = 5, Capital = 10000 } // Lower rate
        }
    });
    
    // User B votes 100 tokens for 365 days with new lower interest rate
    var userBVoteResult = await ElectionContractStub.Vote.SendAsync(new VoteMinerInput
    {
        CandidatePubkey = CandidatePubkey,
        Amount = 100_00000000,
        EndTimestamp = TimestampHelper.GetUtcNow().AddDays(365)
    });
    
    // Get User B's vote weight (calculated with low interest rate)
    var userBWeight = await GetVoteWeight(userBVoteResult.TransactionResult.ReturnValue);
    // Expected: userBWeight = ~150 (example value, lower than User A)
    
    // Distribute welfare profits
    await TreasuryContractStub.DistributeWelfareProfits.SendAsync(new Empty());
    
    // Both users claim their profits
    var userAProfits = await GetClaimedProfits(userAVoteResult.TransactionResult.ReturnValue);
    var userBProfits = await GetClaimedProfits(userBVoteResult.TransactionResult.ReturnValue);
    
    // VULNERABILITY: User A receives 33% more rewards than User B
    // despite voting with identical parameters (100 tokens, 365 days)
    Assert.True(userAProfits > userBProfits);
    var profitRatio = (double)userAProfits / userBProfits;
    Assert.True(profitRatio > 1.3); // User A gets >30% more
    
    // This violates the fairness invariant that identical voting parameters
    // should receive identical rewards
}
```

## Notes

This vulnerability represents a fundamental design flaw in the vote weight and reward distribution system. The issue arises from the immutability of vote weights after creation, combined with the ability to change the interest rates that determine those weights. This creates a permanent unfairness where the timing of a vote (relative to interest rate changes) affects lifetime rewards more than the actual voting parameters themselves.

The vulnerability is particularly concerning because:
1. It can occur naturally without any malicious intent
2. It's difficult for regular users to detect
3. It persists for the entire lock period (potentially years)
4. It violates the fundamental expectation of fair governance participation

The recommended fix should ensure that all voters with identical voting parameters receive proportional rewards regardless of when they voted relative to interest rate changes.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L144-155)
```csharp
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L189-208)
```csharp
    public override Empty SetVoteWeightInterest(VoteWeightInterestList input)
    {
        AssertPerformedByVoteWeightInterestController();
        Assert(input.VoteWeightInterestInfos.Count > 0, "invalid input");
        // ReSharper disable once PossibleNullReferenceException
        foreach (var info in input.VoteWeightInterestInfos)
        {
            Assert(info.Capital > 0, "invalid input");
            Assert(info.Day > 0, "invalid input");
            Assert(info.Interest > 0, "invalid input");
        }

        Assert(input.VoteWeightInterestInfos.GroupBy(x => x.Day).Count() == input.VoteWeightInterestInfos.Count,
            "repeat day input");
        var orderList = input.VoteWeightInterestInfos.OrderBy(x => x.Day).ToArray();
        input.VoteWeightInterestInfos.Clear();
        input.VoteWeightInterestInfos.AddRange(orderList);
        State.VoteWeightInterestList.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-383)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
            ProfitDetailId = voteId
        });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L443-443)
```csharp
        AddBeneficiaryToVoter(GetVotesWeight(input.Amount, lockSeconds), lockSeconds, voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L573-592)
```csharp
    private long GetVotesWeight(long votesAmount, long lockTime)
    {
        var lockDays = lockTime.Div(DaySec);
        var timeAndAmountProportion = GetVoteWeightProportion();
        if (State.VoteWeightInterestList.Value == null)
            State.VoteWeightInterestList.Value = GetDefaultVoteWeightInterest();
        foreach (var instMap in State.VoteWeightInterestList.Value.VoteWeightInterestInfos)
        {
            if (lockDays > instMap.Day)
                continue;
            var initBase = 1 + (decimal)instMap.Interest / instMap.Capital;
            return ((long)(Pow(initBase, (uint)lockDays) * votesAmount)).Add(votesAmount
                .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
        }

        var maxInterestInfo = State.VoteWeightInterestList.Value.VoteWeightInterestInfos.Last();
        var maxInterestBase = 1 + (decimal)maxInterestInfo.Interest / maxInterestInfo.Capital;
        return ((long)(Pow(maxInterestBase, (uint)lockDays) * votesAmount)).Add(votesAmount
            .Mul(timeAndAmountProportion.AmountProportion).Div(timeAndAmountProportion.TimeProportion));
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-192)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L296-304)
```csharp
        // Clone the old one to a new one, remove the old, and add the new.
        var newDetail = fixingDetail.Clone();
        // The startPeriod is 0, so use the original one.
        newDetail.StartPeriod = input.StartPeriod == 0 ? fixingDetail.StartPeriod : input.StartPeriod;
        // The endPeriod is set, so use the inputted one.
        newDetail.EndPeriod = input.EndPeriod == 0 ? fixingDetail.EndPeriod : input.EndPeriod;
        profitDetails.Details.Remove(fixingDetail);
        profitDetails.Details.Add(newDetail);
        State.ProfitDetailsMap[input.SchemeId][input.BeneficiaryShare.Beneficiary] = profitDetails;
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L956-962)
```csharp
    private static long SafeCalculateProfits(long totalAmount, long shares, long totalShares)
    {
        var decimalTotalAmount = (decimal)totalAmount;
        var decimalShares = (decimal)shares;
        var decimalTotalShares = (decimal)totalShares;
        return (long)(decimalTotalAmount * decimalShares / decimalTotalShares);
    }
```
