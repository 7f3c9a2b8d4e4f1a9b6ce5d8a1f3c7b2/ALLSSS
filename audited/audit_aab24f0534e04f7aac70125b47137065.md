### Title
Cross-Snapshot Withdrawal Leaves Stale Vote Counts in Subsequent Snapshots

### Summary
The `Withdraw()` function only updates the voting result for the snapshot in which the vote was originally cast, but does not update subsequent snapshots that have carried over `VotesAmount` and `VotersCount` from that original snapshot. This allows withdrawn votes to persist in later snapshots' aggregate metrics, leading to inflated voter participation and vote amount statistics that can affect governance decisions and quorum calculations.

### Finding Description

When a voting snapshot is taken via `TakeSnapshot()`, the new snapshot inherits `VotersCount` and `VotesAmount` from the previous snapshot as carried-over cumulative metrics: [1](#0-0) 

However, when a voter withdraws their vote via `Withdraw()`, the function retrieves the voting result hash using only the snapshot number stored in the original voting record: [2](#0-1) 

This means `Withdraw()` only updates the voting result of the original snapshot (lines 214-222), subtracting the withdrawn vote's amount from `VotesAmount`, `Results`, and potentially `VotersCount`: [3](#0-2) 

**Root Cause**: The withdrawal logic does not iterate through or update any subsequent snapshots that have already carried over the vote counts from the original snapshot. Once `TakeSnapshot()` copies the cumulative counts forward, those copies become immutable with respect to withdrawals from earlier snapshots.

**Why Protections Fail**: There is no mechanism to track which snapshots have inherited counts from previous snapshots, nor is there any logic to propagate withdrawal updates to descendant snapshots.

### Impact Explanation

**Concrete Harm**:
1. **Inflated Governance Metrics**: The Election contract exposes `GetVotersCount()` and `GetVotesAmount()` methods that query the voting results: [4](#0-3) [5](#0-4) 

These methods will return inflated values for any snapshot following withdrawals from earlier snapshots.

2. **Quorum and Participation Manipulation**: If governance decisions, reward distributions, or quorum thresholds rely on `VotesAmount` or `VotersCount`, attackers can artificially inflate these metrics by:
   - Voting with large amounts in early snapshots
   - Waiting for subsequent snapshots to inherit these counts
   - Withdrawing from the original snapshot while leaving later snapshots with the inflated counts

3. **Multi-Round Impact**: With 3 total snapshots as shown in tests, a single vote can be counted in snapshots 2 and 3 even after withdrawal, effectively multiplying its statistical impact. [6](#0-5) 

**Quantified Damage**: For each withdrawn vote of amount X from snapshot N, all subsequent snapshots N+1, N+2, ... retain X in their `VotesAmount` and potentially +1 in their `VotersCount`. With coordinated attackers and multiple snapshots, this can create a multiplier effect where the same tokens are counted multiple times in aggregate statistics.

**Affected Parties**: Any external contract, dApp, or governance mechanism that queries voting statistics to make decisions based on voter participation or total vote amounts.

### Likelihood Explanation

**Attacker Capabilities**: Any voter can execute this attack - no special permissions required beyond the ability to vote and withdraw (standard voter operations).

**Attack Complexity**: Very low:
1. Vote in snapshot N with any amount
2. Wait for sponsor to call `TakeSnapshot()` creating snapshot N+1
3. Call `Withdraw()` with the vote ID from step 1
4. Snapshot N+1 now has inflated counts

**Feasibility**: The attack is always feasible when:
- A voting item has multiple snapshots (`TotalSnapshotNumber > 1`)
- Token locking is enabled (voter can withdraw after snapshot)
- Or token locking is disabled (sponsor can withdraw on behalf)

**Detection**: The discrepancy is not easily detectable without comparing snapshot results and tracing vote histories, as the inflated values appear as normal aggregate statistics.

**Probability**: HIGH - This is not an edge case but a systematic flaw that occurs whenever withdrawals happen after snapshot transitions. The existing test suite demonstrates this scenario without detecting the issue: [7](#0-6) 

The test votes, takes a snapshot, then withdraws, but only verifies snapshot 1's state - it doesn't check snapshot 2's carried-over counts.

### Recommendation

**Immediate Mitigation**:
1. Either prevent withdrawals after snapshots have been taken:
```
In Withdraw(), add:
Assert(votingItem.CurrentSnapshotNumber == votingRecord.SnapshotNumber, 
       "Cannot withdraw from previous snapshots after new snapshot taken.");
```

2. Or implement cascading updates to all subsequent snapshots when withdrawing:
```
In Withdraw(), after updating the original snapshot, iterate:
for (long i = votingRecord.SnapshotNumber + 1; i <= votingItem.CurrentSnapshotNumber; i++) {
    var futureResultHash = GetVotingResultHash(votingRecord.VotingItemId, i);
    var futureResult = State.VotingResults[futureResultHash];
    if (futureResult != null) {
        futureResult.VotesAmount = futureResult.VotesAmount.Sub(votingRecord.Amount);
        if (shouldDecrementVoterCount) {
            futureResult.VotersCount = futureResult.VotersCount.Sub(1);
        }
        State.VotingResults[futureResultHash] = futureResult;
    }
}
```

**Invariant Checks**:
- Add assertion: Sum of all active vote amounts in a snapshot should equal the snapshot's `VotesAmount`
- Add assertion: Count of unique voters with active votes should equal `VotersCount`

**Test Cases**:
- Test voting in snapshot 1, taking snapshot 2, withdrawing, then verifying snapshot 2's `VotesAmount` and `VotersCount` are correctly decremented
- Test multiple withdrawals across multiple snapshot transitions
- Test edge case where all votes from snapshot 1 are withdrawn after snapshot 2 is created

### Proof of Concept

**Initial State**:
- Register a voting item with `TotalSnapshotNumber = 3` and `IsLockToken = true`
- Voter has 1000 tokens

**Attack Sequence**:

1. **Snapshot 1 - Vote**: Voter calls `Vote()` with 1000 tokens for option A
   - Expected: Snapshot 1 has `VotesAmount = 1000`, `VotersCount = 1`, `Results["A"] = 1000`

2. **Create Snapshot 2**: Sponsor calls `TakeSnapshot(votingItemId, 1)`
   - Expected: Snapshot 2 created with `VotesAmount = 1000` (carried over), `VotersCount = 1` (carried over), `Results = {}`

3. **Withdraw from Snapshot 1**: Voter calls `Withdraw(voteId)`
   - Expected behavior: Snapshot 1 should have `VotesAmount = 0`, `VotersCount = 0`, `Results["A"] = 0`
   - **Actual Snapshot 2 state**: Still has `VotesAmount = 1000`, `VotersCount = 1` (INCORRECT - should be 0)

4. **Query Election Contract**: Call `GetVotesAmount()` and `GetVotersCount()` for snapshot 2
   - Expected: Should return 0 for both (no active votes)
   - **Actual**: Returns 1000 and 1 (stale carried-over values)

**Success Condition**: After withdrawal in step 3, `GetVotingResult(votingItemId, 2)` should show `VotesAmount = 0` and `VotersCount = 0`, but actually shows the inflated inherited values. The Election contract's view methods propagate these incorrect values to external consumers.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L207-207)
```csharp
        var votingResultHash = GetVotingResultHash(votingRecord.VotingItemId, votingRecord.SnapshotNumber);
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L214-222)
```csharp
        var votingResult = State.VotingResults[votingResultHash];
        votingResult.Results[votingRecord.Option] =
            votingResult.Results[votingRecord.Option].Sub(votingRecord.Amount);
        if (!votedItems.VotedItemVoteIds[votingRecord.VotingItemId.ToHex()].ActiveVotes.Any())
            votingResult.VotersCount = votingResult.VotersCount.Sub(1);

        votingResult.VotesAmount = votingResult.VotesAmount.Sub(votingRecord.Amount);

        State.VotingResults[votingResultHash] = votingResult;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L264-271)
```csharp
        State.VotingResults[currentVotingGoingHash] = new VotingResult
        {
            VotingItemId = input.VotingItemId,
            SnapshotNumber = nextSnapshotNumber,
            SnapshotStartTimestamp = Context.CurrentBlockTime,
            VotersCount = previousVotingResult.VotersCount,
            VotesAmount = previousVotingResult.VotesAmount
        };
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L224-230)
```csharp
    public override Int64Value GetVotersCount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotersCount
        };
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L232-238)
```csharp
    public override Int64Value GetVotesAmount(Empty input)
    {
        return new Int64Value
        {
            Value = State.VoteContract.GetLatestVotingResult.Call(State.MinerElectionVotingItemId.Value).VotesAmount
        };
    }
```

**File:** test/AElf.Contracts.Vote.Tests/Full/VoteForBestLanguageTests.cs (L93-94)
```csharp
            var votingResult = await GetVotingResult(registerItem.VotingItemId, 2);
            votingResult.VotersCount.ShouldBe(7);
```

**File:** test/AElf.Contracts.Vote.Tests/BVT/BasicTests.cs (L246-263)
```csharp
        await Vote(voteUser, voteItemId, registerItem.Options[1], voteAmount);
        var voteIds = await GetVoteIds(voteUser, voteItemId);
        var currentVoteId = voteIds.ActiveVotes.First();
        var voteRecordBeforeWithdraw = await VoteContractStub.GetVotingRecord.CallAsync(currentVoteId);
        voteRecordBeforeWithdraw.IsWithdrawn.ShouldBe(false);
        var voteItems = await VoteContractStub.GetVotedItems.CallAsync(voteAddress);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].ActiveVotes.Count.ShouldBe(1);
        voteItems.VotedItemVoteIds[voteItemId.ToHex()].WithdrawnVotes.Count.ShouldBe(0);
        var voteResultBeforeWithdraw = await VoteContractStub.GetVotingResult.CallAsync(new GetVotingResultInput
        {
            SnapshotNumber = 1,
            VotingItemId = voteItemId
        });
        await TakeSnapshot(voteItemId, 1);


        var beforeBalance = GetUserBalance(voteAddress);
        var transactionResult = await Withdraw(voteUser, currentVoteId);
```
