### Title
Insufficient Validation in MethodFeeController Change Allows Non-Governance Contracts

### Summary
The `ChangeMethodFeeController` method only validates that an organization exists in the specified contract via `ValidateOrganizationExist`, but does not verify that the contract implements proper ACS3 governance mechanisms. This allows a malicious contract that bypasses authorization checks to be set as the controller, enabling direct method fee manipulation without governance approval once the change is approved.

### Finding Description

**Root Cause:**
The validation in `ChangeMethodFeeController` is insufficient across all ACS1-implementing contracts. The method only calls `CheckOrganizationExist`, which performs a simple contract call to `ValidateOrganizationExist`: [1](#0-0) [2](#0-1) 

This validation only checks if an organization exists in the contract's storage, but does NOT verify:
1. That the contract implements ACS3 (governance standard)
2. That the contract enforces authorization through proposals/approvals
3. That the contract has proper security controls

**Why Existing Protections Fail:**

The `ValidateOrganizationExist` method in governance contracts only checks storage: [3](#0-2) 

A malicious contract can implement this method to always return true for any address, passing validation despite having no governance enforcement.

**Execution Path:**
1. Attacker deploys a malicious contract with a trivial `ValidateOrganizationExist` implementation
2. Through a governance proposal, `ChangeMethodFeeController` is called with the malicious contract address
3. The validation passes because `ValidateOrganizationExist` returns true
4. Once approved, the `MethodFeeController.OwnerAddress` can be set to any address
5. The attacker can directly call `SetMethodFee` without governance: [4](#0-3) 

The authorization check only validates `Context.Sender == OwnerAddress`, with no verification that OwnerAddress is controlled through legitimate governance.

### Impact Explanation

**Direct Harm:**
- **Complete governance bypass** for method fee configuration across all system contracts
- **Arbitrary fee manipulation** allowing attacker to set zero fees (enabling spam attacks) or excessive fees (DoS)
- **Protocol-wide impact** affecting Parliament, Association, Referendum, Token, Election, Treasury, Profit, and all other ACS1-implementing contracts

**Affected Parties:**
- All users paying transaction fees
- Network security (fee-based spam prevention)
- Governance integrity

**Severity Justification:**
This is HIGH severity because it undermines the fundamental governance model for method fee management, allowing unauthorized changes without proper multi-signature approval or threshold requirements.

### Likelihood Explanation

**Attacker Capabilities Required:**
- Ability to deploy contracts to the chain
- Capability to create and present governance proposals

**Attack Complexity:**
MEDIUM - Requires governance approval but achievable through:
1. **Social engineering**: Disguising malicious contract as legitimate governance upgrade
2. **Obscure implementation**: Hiding malicious logic in complex contract code
3. **Supply chain attack**: Presenting as improved governance contract with "enhanced features"

**Feasibility Conditions:**
- Governance must approve the controller change (requires proposal process)
- However, this is realistic as governance reviews may not detect subtle authorization bypasses
- Once approved, exploitation is trivial and immediate

**Detection Constraints:**
- No runtime validation of contract's governance implementation
- Static code analysis during deployment validation checks ACS implementation but not authorization logic correctness
- The malicious behavior only manifests after the controller change is complete

### Recommendation

**Code-Level Mitigation:**

1. **Add contract interface validation** in `CheckOrganizationExist`:
   - Verify the contract implements ACS3 by checking service descriptors
   - Validate that the contract address is one of the known governance contracts (Parliament, Association, Referendum)
   - Maintain a whitelist of approved governance contract addresses

2. **Enhance validation in ChangeMethodFeeController**:
   ```
   Add checks to verify:
   - ContractAddress is a recognized system governance contract
   - OwnerAddress is a valid organization in that governance contract
   - The organization has proper threshold/approval requirements configured
   ```

3. **Add runtime verification**:
   - Before executing SetMethodFee, verify the caller went through proper governance release
   - Check that Context.Origin differs from Context.Sender (indicating governance proxy execution)

**Invariant Checks:** [5](#0-4) 

Add assertion: `Assert(IsValidGovernanceContract(input.ContractAddress), "Controller must be valid governance contract")`

**Test Cases:**
- Attempt to set MethodFeeController to non-governance contract address
- Attempt to set MethodFeeController to user-deployed contract with fake `ValidateOrganizationExist`
- Verify rejection of controllers that don't implement full ACS3 interface

### Proof of Concept

**Required Initial State:**
- Any ACS1-implementing system contract (e.g., Configuration Contract)
- Existing MethodFeeController pointing to Parliament with default organization

**Transaction Steps:**

1. **Deploy malicious contract**:
   ```
   Contract contains:
   - ValidateOrganizationExist(Address) returns BoolValue{true} for any input
   - No authorization enforcement
   - No proposal/approval mechanisms
   ```

2. **Create governance proposal**: [6](#0-5) 
   
   Proposal parameters:
   - Method: ChangeMethodFeeController
   - Parameters: AuthorityInfo{ContractAddress=maliciousContract, OwnerAddress=attackerAddress}

3. **Approve and release proposal** through legitimate governance process

4. **Direct exploitation**:
   - From attackerAddress, call SetMethodFee directly
   - No proposal creation needed
   - No approval threshold required
   - Instant method fee modification

**Expected vs Actual Result:**
- **Expected**: ChangeMethodFeeController should reject non-governance contracts
- **Actual**: Validation passes if ValidateOrganizationExist returns true, regardless of contract's authorization implementation

**Success Condition:**
After step 4, method fees are modified without any governance approval, demonstrating complete bypass of the authorization model.

### Notes

This vulnerability exists identically across all ACS1-implementing contracts in the codebase, as they all use the same validation pattern. The issue is not specific to the Configuration contract but represents a systemic validation gap in the method fee controller change mechanism. While the ACS validator checks interface implementation at deployment time, it does not validate the correctness of authorization logic within those implementations.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L11-21)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L23-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L72-77)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** test/AElf.Contracts.Configuration.Tests/ConfigurationContractTest.cs (L413-427)
```csharp
        const string proposalCreationMethodName =
            nameof(ConfigurationImplContainer.ConfigurationImplStub.SetMethodFee);
        var proposalId = await CreateProposalAsync(Tester, methodFeeController.ContractAddress,
            methodFeeController.OwnerAddress, proposalCreationMethodName,
            new MethodFees
            {
                MethodName = methodName,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = "ELF", BasicFee = 2
                    }
                }
            });
```
