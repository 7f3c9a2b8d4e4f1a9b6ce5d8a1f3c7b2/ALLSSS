### Title
MethodFeeController Can Be Changed to Arbitrary Malicious Contract Enabling Zero-Fee Spam Attacks

### Summary
The `ChangeMethodFeeController` method in the Configuration contract only validates that an organization exists in the provided contract address but does not verify that the contract is one of the three legitimate governance contracts (Parliament, Association, or Referendum). If Parliament approves a malicious proposal to change the MethodFeeController to an attacker-controlled contract, the attacker can subsequently set all method fees to zero, enabling network-wide spam attacks that can cause denial of service.

### Finding Description

The vulnerability exists in the `ChangeMethodFeeController` method implementation: [1](#0-0) 

The only validation performed is calling `CheckOrganizationExist`, which merely invokes `ValidateOrganizationExist` on whatever contract address is provided: [2](#0-1) 

**Root Cause:** There is no validation that the `AuthorityInfo.ContractAddress` is restricted to the three legitimate governance contracts defined in the system: [3](#0-2) [4](#0-3) 

An attacker can deploy a malicious contract that implements a `ValidateOrganizationExist` method returning `true` for any address. If Parliament approves a proposal to change the MethodFeeController to this malicious contract with the attacker's address as the OwnerAddress, the validation passes.

Once the MethodFeeController is changed, the `SetMethodFee` method only checks that the sender matches the OwnerAddress: [5](#0-4) 

The attacker can then directly call `SetMethodFee` to set all method fees to zero, bypassing the intended governance controls.

**Why Existing Protections Fail:** The `ValidateOrganizationExist` check assumes the contract address points to a legitimate governance contract, but this assumption is not enforced. The ACS3 interface can be implemented by any contract, including malicious ones. [6](#0-5) 

The same vulnerable pattern exists across all system contracts implementing ACS1: [7](#0-6) 

### Impact Explanation

**Direct Network DoS:** With zero method fees, attackers can spam the network with expensive operations (contract deployments, cross-chain transactions, token operations) at no cost. This fills blocks with spam transactions, preventing legitimate users from interacting with the system.

**Quantified Damage:**
- All expensive operations (normally costing significant fees) become free
- Block space becomes a free resource for attackers
- Network becomes unusable for legitimate users due to transaction congestion
- No economic barrier to sustained spam attacks

**Who Is Affected:** All network participants:
- Users cannot submit legitimate transactions
- DApps and services become unavailable
- Block producers process only spam transactions
- Economic security model is fundamentally broken

**Severity Justification:** HIGH severity because:
1. Complete DoS of the entire network is possible
2. Recovery requires another Parliament proposal to restore proper controller
3. Damage occurs immediately once exploit executes
4. Fee mechanism is critical to economic security of the blockchain

### Likelihood Explanation

**Attacker Capabilities Required:**
1. Deploy a malicious contract with a compliant `ValidateOrganizationExist` interface
2. Create a Parliament proposal to change MethodFeeController
3. Achieve 2/3 Block Producer approval for the proposal

**Attack Complexity:** Medium-High
- Technical implementation is straightforward (simple smart contract)
- Social/governance engineering is the main barrier
- Requires convincing 2/3 of BPs to approve the proposal

**Feasibility Conditions:**
- Requires Parliament approval (2/3 of Block Producers)
- BPs are economically incentivized to review proposals carefully
- Off-chain governance processes should provide oversight
- However, social engineering, compromised BP keys, or governance attacks remain possible vectors

**Detection Constraints:**
- Proposal would be visible on-chain before execution
- BPs should review the target contract address
- Lack of validation means no technical barrier prevents approval

**Probability Assessment:** LOW-MEDIUM
- While requiring Parliament approval significantly reduces likelihood
- The missing validation represents a defense-in-depth failure
- Compromised governance, social engineering, or accidental misconfiguration could trigger the vulnerability
- Historical blockchain governance attacks demonstrate this is not purely theoretical

### Recommendation

**Code-Level Mitigation:**

Add explicit validation in `ChangeMethodFeeController` to restrict the contract address to only the three legitimate governance contracts:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // Add validation to ensure contract is a legitimate governance contract
    var validGovernanceContracts = new[] {
        Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validGovernanceContracts.Contains(input.ContractAddress), 
        "Controller contract must be Parliament, Association, or Referendum.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");
    
    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Invariant Check:** Enforce that `MethodFeeController.Value.ContractAddress` is always one of the three system governance contracts.

**Apply Same Fix To:**
- All ACS1 implementations across system contracts (Genesis, MultiToken, CrossChain, etc.)
- All controller change methods (ChangeContractDeploymentController, ChangeCodeCheckController, etc.)

**Test Cases:**
1. Verify ChangeMethodFeeController succeeds with valid Parliament/Association/Referendum addresses
2. Verify ChangeMethodFeeController fails with arbitrary contract addresses
3. Verify ChangeMethodFeeController fails with EOA addresses
4. Test that existing legitimate controller changes continue to work

### Proof of Concept

**Required Initial State:**
- Configuration contract deployed and initialized
- MethodFeeController defaults to Parliament's default organization
- Attacker has deployed MaliciousContract with ValidateOrganizationExist returning true

**Transaction Steps:**

1. **Attacker deploys MaliciousContract:**
   - Contract implements: `function ValidateOrganizationExist(Address input) returns (BoolValue { Value = true })`

2. **Attacker creates Parliament proposal:**
   - Call `Parliament.CreateProposal` with:
     - `to_address`: Configuration contract
     - `contract_method_name`: "ChangeMethodFeeController"
     - `params`: AuthorityInfo { ContractAddress: MaliciousContract, OwnerAddress: AttackerAddress }

3. **Parliament approves proposal:**
   - 2/3 of BPs call `Parliament.Approve` on the proposal (social engineering/governance attack)

4. **Proposer releases:**
   - Call `Parliament.Release` with proposal ID
   - Executes: `Configuration.ChangeMethodFeeController(AuthorityInfo { ContractAddress: MaliciousContract, OwnerAddress: AttackerAddress })`
   - Validation passes because MaliciousContract.ValidateOrganizationExist returns true

5. **Attacker sets zero fees:**
   - Call `Configuration.SetMethodFee` from AttackerAddress with:
     - `method_name`: "Transfer" (or any expensive operation)
     - `fees`: empty array (zero fees)
   - Authorization passes because Context.Sender == AttackerAddress == MethodFeeController.OwnerAddress

6. **Execute spam attack:**
   - Attacker submits unlimited transactions with zero fees
   - Network becomes congested with spam
   - Legitimate users cannot transact

**Expected vs Actual Result:**
- Expected: ChangeMethodFeeController should reject non-governance contract addresses
- Actual: ChangeMethodFeeController accepts any contract implementing ValidateOrganizationExist

**Success Condition:** After step 5, attacker can call SetMethodFee from their address and successfully set method fees to zero, confirmed by calling GetMethodFee showing zero fees for the target method.

### Citations

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L11-21)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L23-32)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_ACS1_TransactionFeeProvider.cs (L72-77)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L18-19)
```csharp
    public static readonly Hash ParliamentContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Parliament");
```

**File:** src/AElf.Sdk.CSharp/SmartContractConstants.cs (L32-36)
```csharp
    public static readonly Hash ReferendumContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Referendum");

    public static readonly Hash AssociationContractSystemHashName =
        HashHelper.ComputeFrom("AElf.ContractNames.Association");
```

**File:** protobuf/acs3.proto (L67-70)
```text
    // Check the existence of an organization.
    rpc ValidateOrganizationExist(aelf.Address) returns (google.protobuf.BoolValue){
        option (aelf.is_view) = true;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```
