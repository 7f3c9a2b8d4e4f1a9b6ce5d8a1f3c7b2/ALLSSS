### Title
User Contract Proposal Author Theft via Expiration-Based State Overwrite

### Summary
The `SendUserContractProposal()` function allows an attacker to overwrite expired proposal metadata by submitting identical contract deployment inputs, stealing authorship when the victim's original proposal is subsequently approved by miners. This enables unauthorized control over deployed contracts without proper governance approval.

### Finding Description

The vulnerability exists in the proposal registration logic for user contract deployments. [1](#0-0) 

The root cause is the expiration check on line 315 that permits state overwrites when `Context.CurrentBlockTime >= registered.ExpiredTime`, combined with using the input hash as the sole key for proposal metadata storage. [2](#0-1) 

When a victim's proposal expires before miner approval, an attacker can call `DeployUserSmartContract()` with identical parameters (same code, category, salt), generating the same input hash. [3](#0-2)  The expiration check passes, and line 323 overwrites `State.ContractProposingInputMap[proposingInputHash]` with the attacker's data, replacing the `Author` field from victim to attacker while keeping `Proposer` as `Context.Self` (Genesis contract).

The critical flaw manifests during proposal execution. When miners approve the victim's original proposal, `ReleaseApprovedUserSmartContract()` retrieves the overwritten state via `input.ProposedContractInputHash`. [4](#0-3)  The validation only checks that `Proposer == Context.Self`, which both victim and attacker satisfy, failing to verify the original submitter's identity.

Subsequently, `PerformDeployUserSmartContract()` recalculates the hash from the victim's original input stored in the proposal parameters, retrieves the attacker's metadata from state, and deploys the contract with `contractProposingInput.Author` as the author. [5](#0-4)  The result: victim's code deployed with attacker as both author and deployer.

### Impact Explanation

**Auth/Governance Impact - HIGH**: The attacker gains complete authorship control over the deployed contract without proper authorization. The `author` field grants critical privileges including the exclusive ability to update the contract code and transfer authorship. [6](#0-5) 

**Affected Parties**: Any user deploying contracts on the network is vulnerable. This particularly impacts deployment of valuable contracts (tokens, DAOs, DeFi protocols) where authorship represents significant economic value and control rights.

**Severity Justification**: This constitutes a complete authorization bypass in the contract deployment governance system. The attacker obtains permanent control over contracts they should have no authority over, violating fundamental authorization invariants. Test cases confirm that repeated proposals are blocked with "Already proposed" errors, but no tests validate the expiration overwrite scenario. [7](#0-6) 

### Likelihood Explanation

**Reachable Entry Point**: `DeployUserSmartContract()` is a public method callable by any user. [8](#0-7) 

**Feasible Preconditions**: The attacker only needs to:
1. Monitor `CodeCheckRequired` events to identify pending deployments and extract their parameters
2. Wait for the default expiration period (obtained via `GetCodeCheckProposalExpirationTimePeriod()`) without miner approval
3. Submit identical deployment parameters

**Execution Practicality**: The attack is straightforward. The contract hash depends solely on `category`, `code`, and `salt` - all observable or inferrable parameters. Standard contracts (token templates, common libraries) have predictable inputs. The test suite confirms that proposals can be resubmitted after expiration. [9](#0-8) 

**Economic Rationality**: Attack cost is minimal (one transaction fee). Value extraction is substantial: authorship of potentially valuable contracts. No special permissions or significant capital required.

**Detection Constraints**: The attack is difficult to detect as both proposals appear legitimate to miners. The overwrite happens silently in state storage without events indicating the metadata change.

### Recommendation

**Immediate Fix**: Reject proposal overwrites when an active proposal exists in the authorization contract, regardless of expiration status. Add validation before line 323:

```csharp
if (registered != null && Context.CurrentBlockTime >= registered.ExpiredTime) {
    // Verify no active proposal exists in authorization contract before allowing overwrite
    var proposalExists = CheckActiveProposal(codeCheckController.ContractAddress, 
                                            codeCheckController.OwnerAddress, 
                                            proposingInputHash);
    Assert(!proposalExists, "Active proposal exists, cannot overwrite.");
}
```

**Invariant Check**: Add author verification in `ReleaseApprovedUserSmartContract()` to ensure the proposal parameters' implicit author matches the stored author:
- Extract the original submitter from proposal creation context
- Validate against `contractProposingInput.Author` before releasing

**Alternative Mitigation**: Use compound keys combining input hash with submitter address: `State.ContractProposingInputMap[hash + sender]`, preventing cross-user overwrites while allowing same-user resubmission after expiration.

**Test Cases**: Add regression tests for:
1. User A proposes deployment, expires, User B submits identical input → should fail
2. Expired proposal with active authorization contract entry → overwrite blocked
3. Author field consistency check from proposal creation through execution

### Proof of Concept

**Initial State**:
- Alice wants to deploy a standard ERC20-like token contract
- Default code check expiration period: 86400 seconds (1 day)
- Bob monitors contract deployment events

**Attack Sequence**:

1. **T=0**: Alice calls `DeployUserSmartContract({category: 0, code: <TOKEN_BYTECODE>, salt: null})`
   - Input hash H = ComputeFrom(input)
   - State stores: `ContractProposingInputMap[H] = {Author: Alice, Proposer: Genesis, Status: CodeCheckProposed, ExpiredTime: T+86400}`
   - Proposal P1 created in code check organization with parameters to call `PerformDeployUserSmartContract(AliceInput)`

2. **T=86401**: Proposal P1 expires without miner approval (miners were offline or delayed)
   - `CurrentBlockTime (86401) >= ExpiredTime (86400)` → proposal considered expired
   - Authorization contract proposal P1 still exists and can be voted on

3. **T=86402**: Bob calls `DeployUserSmartContract({category: 0, code: <TOKEN_BYTECODE>, salt: null})` with IDENTICAL parameters
   - Same hash H calculated
   - Expiration check passes: `registered.ExpiredTime (86400) < CurrentBlockTime (86402)`
   - State OVERWRITTEN: `ContractProposingInputMap[H] = {Author: Bob, Proposer: Genesis, Status: CodeCheckProposed, ExpiredTime: T+172802}`
   - New proposal P2 created (unused)

4. **T=86500**: Miners finally approve Alice's original proposal P1
   - Miners call `ReleaseApprovedUserSmartContract({ProposalId: P1, ProposedContractInputHash: H})`
   - Retrieves `ContractProposingInputMap[H]` → gets **Bob's metadata**
   - Validation passes: `Proposer == Context.Self` ✓
   - Status updated to `CodeChecked` in **Bob's data**
   - Proposal P1 released

5. **T=86501**: Proposal P1 executes `PerformDeployUserSmartContract(AliceInput)`
   - Hash H recalculated from AliceInput
   - `TryClearContractProposingData(H)` retrieves **Bob's metadata** (Author: Bob)
   - Contract deployed with Alice's code BUT Bob as author/deployer

**Expected Result**: Contract deployed with Alice as author
**Actual Result**: Contract deployed with **Bob as author** - complete authorship theft

**Success Condition**: Bob can now call `UpdateUserSmartContract()` to modify the contract or `SetContractAuthor()` to transfer ownership, while Alice has no control despite being the original proposer.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-342)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;

        var codeCheckController = State.CodeCheckController.Value;
        var proposalCreationInput = new CreateProposalBySystemContractInput
        {
            ProposalInput = new CreateProposalInput
            {
                ToAddress = Context.Self,
                ContractMethodName = releaseMethodName,
                Params = @params,
                OrganizationAddress = codeCheckController.OwnerAddress,
                ExpiredTime = proposedInfo.ExpiredTime
            },
            OriginProposer = Context.Self
        };

        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState
                .CreateProposalBySystemContract), proposalCreationInput);
    }
```

**File:** protobuf/acs0.proto (L135-154)
```text
message ContractInfo
{
    // The serial number of the contract.
    int64 serial_number = 1;
    // The author of the contract, this is the person who deployed the contract.
    aelf.Address author = 2;
    // The category of contract code(0: C#).
    sint32 category = 3;
    // The hash of the contract code.
    aelf.Hash code_hash = 4;
    // Whether it is a system contract.
    bool is_system_contract = 5;
    // The version of the current contract.
    int32 version = 6;
    string contract_version = 7;
    // Indicates if the contract is the user contract.
    bool is_user_contract = 8;
    // The address for deploying the contract
    aelf.Address deployer = 9;
}
```

**File:** protobuf/acs0.proto (L164-170)
```text
message UserContractDeploymentInput {
    // The category of contract code(0: C#).
    sint32 category = 1;
    // The byte array of the contract code.
    bytes code = 2;
    aelf.Hash salt = 3;
}
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-443)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());

        // Fire event to trigger BPs checking contract code
        Context.Fire(new CodeCheckRequired
        {
            Code = input.Code,
            ProposedContractInputHash = proposedContractInputHash,
            Category = input.Category,
            IsSystemContract = false,
            IsUserContract = true
        });

        return new DeployUserSmartContractOutput
        {
            CodeHash = codeHash
        };
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-493)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
        var codeCheckController = State.CodeCheckController.Value;
        Context.SendInline(codeCheckController.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.Release), input.ProposalId);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-505)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
    }
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L311-313)
```csharp
        var forthProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
            nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput, utcNow.AddSeconds(expirationTimePeriod.Value));
        forthProposingTxResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** test/AElf.Contracts.Genesis.Tests/GenesisContractAuthTest.cs (L987-1000)
```csharp
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }

        {
            // propose contract code
            var repeatedProposingTxResult = await Tester.ExecuteContractWithMiningAsync(BasicContractZeroAddress,
                nameof(BasicContractZero.ProposeNewContract), contractDeploymentInput);
            repeatedProposingTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
            repeatedProposingTxResult.Error.Contains("Already proposed.").ShouldBeTrue();
        }
```
