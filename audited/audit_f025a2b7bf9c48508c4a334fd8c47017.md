### Title
Missing Cross-Chain Verification in NFT Protocol Creation Allows Unauthorized Protocol Registration

### Summary
The `CrossChainCreate()` function in the NFT contract completely lacks cross-chain verification mechanisms, despite its name suggesting cross-chain functionality. Any address can call this function to create NFT protocols for any token that exists in the local TokenContract, bypassing the intended mainchain-only creation flow and proper cross-chain merkle proof verification.

### Finding Description

The vulnerability exists in the `CrossChainCreate()` function at line 75 of `NFTContract_Create.cs`. [1](#0-0) 

**Root Cause:**

The function has NO authorization checks and NO cross-chain verification whatsoever. It simply:
1. Checks if the protocol already exists [2](#0-1) 
2. Reads token info from the local TokenContract [3](#0-2) 
3. Creates the NFT protocol from that local data [4](#0-3) 

**Why Protections Fail:**

The function signature only accepts a `symbol` parameter [5](#0-4) , lacking the required cross-chain verification parameters that the MultiToken contract properly uses: `from_chain_id`, `parent_chain_height`, `transaction_bytes`, and `merkle_path`.

Compare this to the CORRECT implementation in MultiToken's `CrossChainCreateToken()`:
- Validates the source chain's token contract address is registered [6](#0-5) 
- Parses and validates the original cross-chain transaction [7](#0-6) 
- **Performs cryptographic cross-chain verification** using merkle proofs [8](#0-7) 

The NFT contract has NONE of these security checks. The `CrossChainVerify` helper method exists in the codebase [9](#0-8)  but is never called by the NFT contract's `CrossChainCreate()` function.

### Impact Explanation

**Concrete Harm:**
1. **Unauthorized Protocol Creation**: Any attacker can create NFT protocols for any token symbol that exists in the local TokenContract on sidechains, without any authorization
2. **Bypass Mainchain-Only Requirement**: The `Create()` function enforces that NFT protocols can only be created on the AELF mainchain [10](#0-9) , but `CrossChainCreate()` allows bypassing this invariant on sidechains
3. **Front-Running Attack**: Attackers can front-run legitimate cross-chain protocol registrations, causing the legitimate transaction to fail since the protocol already exists
4. **Protocol Integrity Violation**: Tokens not intended to be NFT protocols can be converted into NFT protocols without the token creator's consent or proper cross-chain validation

**Affected Parties:**
- NFT protocol creators who expect secure cross-chain registration
- Users relying on proper NFT protocol creation flows
- The entire sidechain ecosystem's NFT infrastructure integrity

**Severity Justification:** CRITICAL - This completely defeats the security model of cross-chain operations in AElf, violating the fundamental "Cross-Chain Integrity" invariant requiring cross-chain proof verification.

### Likelihood Explanation

**Attacker Capabilities:**
- Minimal: Only requires the ability to send a transaction (any address can do this)
- No special permissions, governance control, or privileged access needed
- Function is publicly accessible as a standard RPC method [11](#0-10) 

**Attack Complexity:**
- Extremely Low: Single function call with one parameter (symbol)
- Precondition: A token with the target symbol must exist in the local TokenContract (common on sidechains where tokens are cross-chain transferred)

**Feasibility:**
- Transaction cost: Standard gas fee only
- Detection: Difficult to prevent or detect before execution
- No special timing or state requirements beyond token existence

**Probability:** HIGH - The attack is trivial to execute and economically rational for griefing, front-running, or exploiting assumptions about NFT protocol creation authority.

### Recommendation

**Code-Level Mitigation:**

1. **Add Cross-Chain Verification Parameters** to `CrossChainCreateInput`:
```protobuf
message CrossChainCreateInput {
    string symbol = 1;
    int32 from_chain_id = 2;
    int64 parent_chain_height = 3;
    bytes transaction_bytes = 4;
    aelf.MerklePath merkle_path = 5;
}
```

2. **Implement Proper Cross-Chain Verification** in the function body:
   - Parse and validate the original transaction
   - Verify the token contract address is registered for the source chain
   - Call `CrossChainVerify()` with the transaction ID, parent chain height, chain ID, and merkle path
   - Extract validated token information from the verified transaction

3. **Follow the MultiToken Pattern**: Model the implementation after `CrossChainCreateToken()` [12](#0-11)  which properly implements all cross-chain verification steps.

**Invariant Checks to Add:**
- Assert cross-chain transaction originates from registered token contract address
- Assert merkle proof verification succeeds before creating protocol
- Assert transaction method name is the expected validation method

**Test Cases:**
- Test successful cross-chain creation with valid merkle proof
- Test rejection of invalid merkle paths
- Test rejection from unregistered chain IDs
- Test rejection of tampered transaction bytes
- Test proper handling of cross-chain indexing heights

### Proof of Concept

**Required Initial State:**
- A token "TESTNFT" exists in the TokenContract on a sidechain (created through legitimate cross-chain token transfer or local creation)
- The NFT protocol for "TESTNFT" does not yet exist in `State.NftProtocolMap`

**Attack Transaction:**
```
Attacker calls: NFTContract.CrossChainCreate({symbol: "TESTNFT"})
```

**Expected vs Actual Result:**
- **Expected**: Transaction should FAIL with "No permission" or "Invalid cross-chain verification"
- **Actual**: Transaction SUCCEEDS, NFT protocol is created with the attacker as the caller, protocol info is set from local TokenContract data

**Success Condition:**
After the transaction, `State.NftProtocolMap["TESTNFT"]` contains a valid NFT protocol entry, despite:
- No cross-chain merkle proof being provided
- No verification that the creation request came from the mainchain
- No authorization check on the caller's address

This demonstrates complete bypass of cross-chain security controls.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-129)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
        MakeSureTokenContractAddressSet();
        InitialNFTTypeNameMap();
        Assert(State.NftProtocolMap[input.Symbol] == null, $"Protocol {input.Symbol} already created.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");

        var baseUri = tokenInfo.ExternalInfo.Value[NftBaseUriMetadataKey];
        var isTokenIdReuse = bool.Parse(tokenInfo.ExternalInfo.Value[NftTokenIdReuseMetadataKey]);
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");

        var nftProtocolInfo = new NFTProtocolInfo
        {
            Symbol = input.Symbol,
            TotalSupply = tokenInfo.TotalSupply,
            BaseUri = baseUri,
            Creator = tokenInfo.Issuer,
            IsBurnable = tokenInfo.IsBurnable,
            IssueChainId = tokenInfo.IssueChainId,
            IsTokenIdReuse = isTokenIdReuse,
            Metadata = new Metadata { Value = { tokenInfo.ExternalInfo.Value } },
            ProtocolName = tokenInfo.TokenName,
            NftType = nftTypeFullName
        };
        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;

        State.MinterListMap[input.Symbol] = new MinterList
        {
            Value = { nftProtocolInfo.Creator }
        };

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = input.Symbol,
            Creator = nftProtocolInfo.Creator,
            IsBurnable = nftProtocolInfo.IsBurnable,
            IssueChainId = nftProtocolInfo.IssueChainId,
            ProtocolName = nftProtocolInfo.ProtocolName,
            TotalSupply = nftProtocolInfo.TotalSupply,
            Metadata = nftProtocolInfo.Metadata,
            BaseUri = nftProtocolInfo.BaseUri,
            IsTokenIdReuse = isTokenIdReuse,
            NftType = nftProtocolInfo.NftType
        });
        return new Empty();
    }
```

**File:** protobuf/nft_contract.proto (L25-26)
```text
    rpc CrossChainCreate (CrossChainCreateInput) returns (google.protobuf.Empty) {
    }
```

**File:** protobuf/nft_contract.proto (L132-134)
```text
message CrossChainCreateInput {
    string symbol = 1;
}
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L478-534)
```csharp
    public override Empty CrossChainCreateToken(CrossChainCreateTokenInput input)
    {
        var tokenContractAddress = State.CrossChainTransferWhiteList[input.FromChainId];
        Assert(tokenContractAddress != null,
            $"Token contract address of chain {ChainHelper.ConvertChainIdToBase58(input.FromChainId)} not registered.");

        var originalTransaction = Transaction.Parser.ParseFrom(input.TransactionBytes);

        AssertCrossChainTransaction(originalTransaction, tokenContractAddress, nameof(ValidateTokenInfoExists));
        var originalTransactionId = originalTransaction.GetHash();
        CrossChainVerify(originalTransactionId, input.ParentChainHeight, input.FromChainId, input.MerklePath);
        var validateTokenInfoExistsInput =
            ValidateTokenInfoExistsInput.Parser.ParseFrom(originalTransaction.Params);
        AssertNftCollectionExist(validateTokenInfoExistsInput.Symbol);
        var tokenInfo = new TokenInfo
        {
            Symbol = validateTokenInfoExistsInput.Symbol,
            TokenName = validateTokenInfoExistsInput.TokenName,
            TotalSupply = validateTokenInfoExistsInput.TotalSupply,
            Decimals = validateTokenInfoExistsInput.Decimals,
            Issuer = validateTokenInfoExistsInput.Issuer,
            IsBurnable = validateTokenInfoExistsInput.IsBurnable,
            IssueChainId = validateTokenInfoExistsInput.IssueChainId,
            ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
            Owner = validateTokenInfoExistsInput.Owner ?? validateTokenInfoExistsInput.Issuer
        };

        var isSymbolAliasSet = SyncSymbolAliasFromTokenInfo(tokenInfo);
        if (State.TokenInfos[tokenInfo.Symbol] == null)
        {
            RegisterTokenInfo(tokenInfo);
            Context.Fire(new TokenCreated
            {
                Symbol = validateTokenInfoExistsInput.Symbol,
                TokenName = validateTokenInfoExistsInput.TokenName,
                TotalSupply = validateTokenInfoExistsInput.TotalSupply,
                Decimals = validateTokenInfoExistsInput.Decimals,
                Issuer = validateTokenInfoExistsInput.Issuer,
                IsBurnable = validateTokenInfoExistsInput.IsBurnable,
                IssueChainId = validateTokenInfoExistsInput.IssueChainId,
                ExternalInfo = new ExternalInfo { Value = { validateTokenInfoExistsInput.ExternalInfo } },
                Owner = tokenInfo.Owner,
            });
        }
        else
        {
            if (isSymbolAliasSet &&
                validateTokenInfoExistsInput.ExternalInfo.TryGetValue(TokenContractConstants.TokenAliasExternalInfoKey,
                    out var tokenAliasSetting))
            {
                State.TokenInfos[tokenInfo.Symbol].ExternalInfo.Value
                    .Add(TokenContractConstants.TokenAliasExternalInfoKey, tokenAliasSetting);
            }
        }

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L236-250)
```csharp
    private void CrossChainVerify(Hash transactionId, long parentChainHeight, int chainId, MerklePath merklePath)
    {
        var verificationInput = new VerifyTransactionInput
        {
            TransactionId = transactionId,
            ParentChainHeight = parentChainHeight,
            VerifiedChainId = chainId,
            Path = merklePath
        };
        var address = Context.GetContractAddressByName(SmartContractConstants.CrossChainContractSystemName);

        var verificationResult = Context.Call<BoolValue>(address,
            nameof(ACS7Container.ACS7ReferenceState.VerifyTransaction), verificationInput);
        Assert(verificationResult.Value, "Cross chain verification failed.");
    }
```
