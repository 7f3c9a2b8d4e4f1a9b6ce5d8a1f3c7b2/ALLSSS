# Audit Report

## Title
Symbol Alias Shadowing via Direct Token Registration

## Summary
The `SetSymbolAlias` function lacks validation to check whether a proposed alias already exists as a direct token symbol in `State.TokenInfos`. This allows an attacker to register a malicious token with a simple symbol before an NFT collection owner sets that same symbol as an alias. Since `GetTokenInfo` prioritizes direct token lookups over alias resolution, users unknowingly interact with the attacker's token instead of the intended NFT.

## Finding Description

The vulnerability stems from an asymmetric validation pattern between token creation and alias setting. 

When setting an alias, `SetSymbolAlias` only validates that the alias doesn't exist in the `SymbolAliasMap`: [1](#0-0) 

This check does not verify whether `State.TokenInfos[input.Alias]` already contains a direct token with the same symbol. However, when tokens are created, `CheckTokenExists` uses `GetTokenInfo` which checks both storage locations: [2](#0-1) [3](#0-2) 

The `GetTokenInfo` function prioritizes direct symbol lookups. If a direct token exists at `State.TokenInfos[symbolOrAlias]`, it returns immediately without checking the alias mapping. This design creates an exploitable race condition where both storage locations can contain entries for the same symbol.

The attack path is feasible because:

1. **Symbol validation permits simple symbols**: The validation pattern allows alphanumeric-only symbols like "ABC": [4](#0-3) 

2. **Symbol type classification**: Symbols without dashes are classified as regular tokens: [5](#0-4) 

3. **Seed NFT creation enables simple symbol tokens**: Attackers can obtain SEED NFTs with `__seed_owned_symbol` matching target aliases: [6](#0-5) 

4. **Alias rules require prefix matching**: The alias must match the NFT collection prefix, making the collision predictable: [7](#0-6) 

**Attack Execution:**
1. NFT collection owner creates "ABC-0" (collection) and "ABC-123" (item)
2. Attacker acquires SEED NFT with `__seed_owned_symbol` = "ABC"
3. Before the NFT owner sets the alias, attacker calls `CreateToken` with symbol "ABC"
4. Token is registered at `State.TokenInfos["ABC"]`
5. NFT owner calls `SetSymbolAlias({Symbol: "ABC-123", Alias: "ABC"})`
   - Line 750 check passes (SymbolAliasMap is empty)
   - Alias is set: `State.SymbolAliasMap["ABC"] = "ABC-123"`
6. Users calling `GetTokenInfo("ABC")` receive the attacker's token due to line 407-408 prioritization

## Impact Explanation

**Direct Financial Impact:**
- Users attempting to interact with NFT "ABC-123" via its intended alias "ABC" will unknowingly transact with the attacker's malicious token
- Transfers sent to the attacker's token result in permanent loss of funds
- Approvals granted to the attacker's token can be exploited to drain user balances through `TransferFrom` operations

**Operational Impact:**
- The NFT collection's alias functionality becomes compromised and unusable
- DApps and marketplaces relying on alias-based token lookups will operate on incorrect tokens
- The NFT collection owner loses the ability to provide user-friendly access to their NFT items
- Brand identity theft and reputation damage

**Affected Parties:**
- End users who transfer funds or grant approvals via the alias
- NFT collection owners who lose their intended alias functionality
- DApp developers whose applications break due to token confusion
- Protocol reputation due to user experience failures

**Severity Justification:**
This is a Medium severity issue. While it requires the attacker to obtain and burn a seed NFT (non-trivial precondition), it results in concrete financial losses and undermines a core protocol feature. The vulnerability has measurable impact on fund security and token system integrity.

## Likelihood Explanation

**Attacker Capabilities Required:**
1. Acquire a SEED NFT with `__seed_owned_symbol` matching the target alias (e.g., "ABC")
2. Execute a token creation transaction consuming the seed NFT
3. Time the attack before the legitimate NFT owner sets their alias

**Attack Complexity:**
The attack is straightforward once seed NFT access is obtained:
- Single transaction executes the malicious token creation
- No special privileges beyond seed NFT ownership
- No complex state manipulation or multi-step coordination

**Feasibility Assessment:**
- SEED NFTs are transferable assets that can be purchased on marketplaces
- The cost is limited to seed NFT acquisition price plus gas fees
- For high-value or popular brand symbols, this investment is economically rational
- Attackers can monitor blockchain events to frontrun alias registration

**Economic Rationality:**
- If the target NFT collection is valuable or widely adopted, victims may mistakenly transfer significant value
- Attack cost (seed NFT + gas) can be recovered from a small number of misdirected transfers
- Additional value from brand impersonation and phishing opportunities

**Detection Constraints:**
- The vulnerability window exists from NFT collection creation until alias setting
- Blockchain monitoring could detect the collision, but users typically won't notice until funds are lost
- No automatic validation or circuit breakers prevent the collision state

**Probability Assessment:**
Medium likelihood - requires active attacker investment and timing coordination, but is economically viable for valuable NFT collections and technically straightforward to execute once seed NFT access is obtained.

## Recommendation

Add a bidirectional collision check in `SetSymbolAlias` to prevent aliases from shadowing existing direct tokens. Before setting the alias, verify that no token already exists with that symbol:

```csharp
public override Empty SetSymbolAlias(SetSymbolAliasInput input)
{
    // ... existing code ...
    
    // For now, token alias can only be set once.
    Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");
    
    // ADD THIS CHECK: Verify no direct token exists with the alias symbol
    var existingToken = State.TokenInfos[input.Alias];
    Assert(existingToken == null || string.IsNullOrEmpty(existingToken.Symbol), 
        $"Cannot set alias {input.Alias}: a token with this symbol already exists.");
    
    CheckTokenAlias(input.Alias, collectionSymbol);
    
    // ... rest of function ...
}
```

This ensures symmetric validation between token creation and alias setting, preventing both storage locations from containing entries for the same symbol.

## Proof of Concept

```csharp
[Fact]
public async Task SymbolAlias_Shadowing_Attack_Test()
{
    // 1. Create NFT collection "ABC-0" and item "ABC-123"
    var nftCollectionSymbol = "ABC-0";
    var nftItemSymbol = "ABC-123";
    await CreateNftCollection(nftCollectionSymbol);
    await CreateNftItem(nftItemSymbol);
    
    // 2. Attacker obtains SEED NFT with __seed_owned_symbol = "ABC"
    var attackerAddress = AttackerAddress;
    await CreateSeedNft("SEED-100", "ABC", attackerAddress);
    
    // 3. Attacker creates malicious token "ABC" BEFORE alias is set
    var attackTokenResult = await TokenContractStub.Create.SendAsync(new CreateInput
    {
        Symbol = "ABC",
        TokenName = "Malicious Token",
        TotalSupply = 1000000,
        Decimals = 8,
        Issuer = attackerAddress,
        Owner = attackerAddress,
        IsBurnable = true
    });
    attackTokenResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 4. NFT owner sets alias "ABC" for item "ABC-123"
    var aliasResult = await TokenContractStub.SetSymbolAlias.SendAsync(new SetSymbolAliasInput
    {
        Symbol = nftItemSymbol,
        Alias = "ABC"
    });
    aliasResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 5. VULNERABILITY: GetTokenInfo("ABC") returns attacker's token, not the NFT
    var tokenInfo = await TokenContractStub.GetTokenInfo.CallAsync(new GetTokenInfoInput
    {
        Symbol = "ABC"
    });
    
    // This should return the NFT "ABC-123" but instead returns attacker's "ABC" token
    tokenInfo.Symbol.ShouldBe(nftItemSymbol); // FAILS - returns "ABC" instead
    tokenInfo.TokenName.ShouldNotBe("Malicious Token"); // FAILS - returns attacker's token
    
    // Demonstrate financial impact: user transfer goes to wrong token
    await TokenContractStub.Issue.SendAsync(new IssueInput
    {
        Symbol = "ABC",
        Amount = 1000,
        To = UserAddress
    });
    
    var balanceBefore = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ABC"
    });
    
    // User intends to transfer NFT but transfers attacker's token instead
    await TokenContractStub.Transfer.SendAsync(new TransferInput
    {
        Symbol = "ABC", // User thinks this is the NFT alias
        Amount = 100,
        To = RecipientAddress
    });
    
    // The transfer affects attacker's token, not the NFT
    var balanceAfter = await TokenContractStub.GetBalance.CallAsync(new GetBalanceInput
    {
        Owner = UserAddress,
        Symbol = "ABC"
    });
    
    (balanceBefore.Balance - balanceAfter.Balance).ShouldBe(100); // Attacker's token was transferred
}
```

## Notes

This vulnerability represents a critical design flaw in the NFT alias system where the lack of bidirectional validation between `State.TokenInfos` and `State.SymbolAliasMap` creates a namespace collision vulnerability. The asymmetry between `CheckTokenExists` (which validates against both storage locations via `GetTokenInfo`) and `SetSymbolAlias` (which only validates against `SymbolAliasMap`) enables the race condition.

The fix requires enforcing mutual exclusivity: a symbol can exist either as a direct token OR as an alias, but never both. The current implementation's prioritization in `GetTokenInfo` (lines 407-408) combined with incomplete validation in `SetSymbolAlias` (line 750) breaks this invariant.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L750-750)
```csharp
        Assert(State.SymbolAliasMap[input.Alias] == null, $"Token alias {input.Alias} already exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L840-852)
```csharp
    private void CheckTokenAlias(string alias, string collectionSymbol)
    {
        if (collectionSymbol == null)
        {
            throw new AssertionException("Token alias can only be set for NFT Item.");
        }

        // Current Rule: Alias must be the seed name.
        var parts = collectionSymbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(parts.Length == 2, $"Incorrect collection symbol: {collectionSymbol}.");
        Assert(parts.Last() == TokenContractConstants.CollectionSymbolSuffix, "Incorrect collection symbol suffix.");
        Assert(alias == parts.First(), $"Alias for an item of {collectionSymbol} cannot be {alias}.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L28-31)
```csharp
    private bool IsValidCreateSymbol(string symbol)
    {
        return Regex.IsMatch(symbol, "^[a-zA-Z0-9]+$");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L295-303)
```csharp
    private void CheckTokenExists(string symbol)
    {
        var empty = new TokenInfo();
        // check old token
        var existing = GetTokenInfo(symbol);
        Assert(existing == null || existing.Equals(empty), "Token already exists.");
        // check new token
        Assert(!State.InsensitiveTokenExisting[symbol.ToUpper()], "Token already exists.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L405-416)
```csharp
    private TokenInfo GetTokenInfo(string symbolOrAlias)
    {
        var tokenInfo = State.TokenInfos[symbolOrAlias];
        if (tokenInfo != null) return tokenInfo;
        var actualTokenSymbol = State.SymbolAliasMap[symbolOrAlias];
        if (!string.IsNullOrEmpty(actualTokenSymbol))
        {
            tokenInfo = State.TokenInfos[actualTokenSymbol];
        }

        return tokenInfo;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFTHelper.cs (L7-14)
```csharp
    private SymbolType GetSymbolType(string symbol)
    {
        var words = symbol.Split(TokenContractConstants.NFTSymbolSeparator);
        Assert(words[0].Length > 0 && IsValidCreateSymbol(words[0]), "Invalid Symbol input");
        if (words.Length == 1) return SymbolType.Token;
        Assert(words.Length == 2 && words[1].Length > 0 && IsValidItemId(words[1]), "Invalid NFT Symbol input");
        return words[1] == TokenContractConstants.CollectionSymbolSuffix ? SymbolType.NftCollection : SymbolType.Nft;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_NFT_Actions.cs (L37-52)
```csharp
        if (nftCollectionInfo.Symbol == TokenContractConstants.SeedCollectionSymbol)
        {
            Assert(input.Decimals == 0 && input.TotalSupply == 1, "SEED must be unique.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedOwnedSymbolExternalInfoKey,
                    out var ownedSymbol), "OwnedSymbol does not exist.");
            Assert(input.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                       out var expirationTime)
                   && long.TryParse(expirationTime, out var expirationTimeLong) &&
                   Context.CurrentBlockTime.Seconds <= expirationTimeLong, "Invalid ownedSymbol.");
            var ownedSymbolType = GetSymbolType(ownedSymbol);
            Assert(ownedSymbolType != SymbolType.Nft, "Invalid OwnedSymbol.");
            CheckSymbolLength(ownedSymbol, ownedSymbolType);
            CheckTokenAndCollectionExists(ownedSymbol);
            CheckSymbolSeed(ownedSymbol);
            State.SymbolSeedMap[ownedSymbol.ToUpper()] = input.Symbol;
        }
```
