### Title
Insufficient Validation of OutValue in NextRound Allows Denial of Service Against Miners

### Summary
The `ValidationForNextRound()` method in `RoundTerminateValidationProvider` only validates that `InValue` is null for all miners in the next round, but fails to validate that `OutValue` is also null or unset. This allows a malicious miner triggering the round transition to inject arbitrary non-null `OutValue` data for other miners, causing those miners to be incorrectly identified as having already mined, preventing them from producing blocks and potentially causing them to be marked as evil nodes.

### Finding Description

The vulnerability exists in the round transition validation logic: [1](#0-0) 

The `ValidationForNextRound()` method only checks that all miners have null `InValue` in the next round data, but does not validate `OutValue`. When a new round is legitimately generated, both fields should be null: [2](#0-1) 

The validation provider is registered during `ValidateBeforeExecution` for NextRound behavior: [3](#0-2) 

When a miner creates NextRound data, they have full control over the `Round` object returned: [4](#0-3) 

The malicious round data is stored directly without additional validation: [5](#0-4) 

The attack succeeds because consensus behavior determination relies on `OutValue` being null to identify miners who haven't mined yet: [6](#0-5) 

If `OutValue` is non-null (due to malicious injection), the miner is incorrectly treated as having already mined, causing them to skip the `UPDATE_VALUE` behavior and potentially miss their mining slot entirely.

### Impact Explanation

**Consensus Integrity Impact:**
- Victim miners are prevented from producing blocks during the affected round because they are incorrectly identified as having already mined
- Each victim miner's `MissedTimeSlots` counter increments, degrading their reputation
- If sustained across multiple rounds, victims could be marked as evil nodes and removed from the consensus set: [7](#0-6) 

**Operational Impact:**
- Reduces the effective number of active miners, weakening consensus security
- Victims lose mining rewards for missed blocks
- Chain liveness may be affected if a significant portion of miners are targeted

**Who is Affected:**
- Any honest miner can be targeted by the attacker
- The entire network suffers from reduced security and potentially slower block production
- Users experience degraded service quality

The severity is **MEDIUM-to-HIGH** because while it doesn't directly steal funds, it severely disrupts consensus operations and can result in honest miners being removed from the validator set.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current consensus miner
- Attacker must be selected to produce the extra block that triggers the round transition (occurs naturally in rotation)
- Attacker must modify their node software to inject malicious `OutValue` data into the `NextRound` transaction

**Attack Complexity:**
- **LOW**: The attack is straightforward - simply set non-null `OutValue` values for target miners when creating NextRound data
- No complex timing requirements or race conditions
- Single transaction executes the attack

**Feasibility Conditions:**
- Entry point is the public `NextRound` method accessible to miners: [8](#0-7) 

- Preconditions are met regularly as miners rotate through being the extra block producer
- No economic cost beyond normal mining operations

**Detection Constraints:**
- The malicious `OutValue` data would be visible in block data, but might not trigger immediate alarms
- Effects (miners missing slots) could be attributed to network issues initially
- Requires blockchain analysis to identify the root cause

**Probability:** **MEDIUM-HIGH** - While requiring a miner to be malicious, the attack is simple to execute, has no additional cost, and would be difficult to detect initially. Miners rotate through the extra block producer role regularly, providing repeated opportunities.

### Recommendation

**Immediate Fix:**
Modify `ValidationForNextRound()` to validate that all `OutValue` fields are null in addition to `InValue`:

```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    // Validate InValue is null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null))
        return new ValidationResult { Message = "Incorrect next round information: InValue should be null." };
    
    // ADD: Validate OutValue is also null
    if (extraData.Round.RealTimeMinersInformation.Values.Any(m => m.OutValue != null))
        return new ValidationResult { Message = "Incorrect next round information: OutValue should be null." };
    
    return new ValidationResult { Success = true };
}
```

**Additional Hardening:**
1. Validate that `Signature` is also null for all miners in the next round
2. Validate that `PreviousInValue` is null for all miners in the next round
3. Add comprehensive validation that the next round data matches what `GenerateNextRoundInformation` would produce

**Test Cases:**
1. Test that NextRound with any miner having non-null `OutValue` is rejected
2. Test that NextRound with any miner having non-null `Signature` is rejected
3. Test that only miners who actually mined have non-null values in the current round
4. Regression test that legitimate round transitions continue to work

### Proof of Concept

**Initial State:**
- Round N in progress with miners A, B, C
- Miner B is selected as extra block producer (will trigger NextRound)
- All miners have mined normally in Round N with valid InValue/OutValue pairs

**Attack Steps:**

1. **Miner B produces extra block triggering NextRound:**
   - Miner B's node calls `GenerateNextRoundInformation()` which creates Round N+1 with all fields null
   - Miner B modifies the Round data before submission:
     ```
     nextRound.RealTimeMinersInformation["MinerA"].OutValue = Hash.FromString("FAKE_HASH")
     nextRound.RealTimeMinersInformation["MinerA"].InValue = null // Kept null to pass validation
     ```
   - Miner B submits block with this modified NextRound transaction

2. **Validation occurs:**
   - `RoundTerminateValidationProvider.ValidationForNextRound()` executes
   - Checks: `extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)` → FALSE (passes)
   - Does NOT check OutValue
   - Validation passes ✓

3. **NextRound executes:**
   - `ProcessNextRound()` stores the malicious round via `AddRoundInformation()`
   - Round N+1 is now active with Miner A having OutValue = "FAKE_HASH"

4. **Miner A attempts to mine in Round N+1:**
   - Miner A calls `GetConsensusCommand()`
   - `ConsensusBehaviourProviderBase.GetConsensusBehaviour()` executes
   - Check: `if (_minerInRound.OutValue == null)` → FALSE (OutValue = "FAKE_HASH")
   - Skips `HandleMinerInNewRound()` which returns `UPDATE_VALUE`
   - Miner A cannot produce blocks normally

**Expected Result:**
Miner A should be able to mine normally in Round N+1

**Actual Result:**
Miner A cannot mine, misses time slot, `MissedTimeSlots` increments, potential marking as evil node

**Success Condition:**
After attack execution, verify:
- Round N+1 contains non-null OutValue for Miner A
- Miner A's consensus command is not `UPDATE_VALUE` 
- Miner A misses mining opportunity
- Miner A's `MissedTimeSlots` counter increases

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-35)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L84-88)
```csharp
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-204)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;

        if (!nextRound.RealTimeMinersInformation.Keys.Contains(pubkey))
            // This miner was replaced by another miner in next round.
            return new AElfConsensusHeaderInformation
            {
                SenderPubkey = ByteStringHelper.FromHexString(pubkey),
                Round = nextRound,
                Behaviour = triggerInformation.Behaviour
            };

        RevealSharedInValues(currentRound, pubkey);

        nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks =
            nextRound.RealTimeMinersInformation[pubkey].ProducedBlocks.Add(1);
        Context.LogDebug(() => $"Mined blocks: {nextRound.GetMinedBlocks()}");
        nextRound.RealTimeMinersInformation[pubkey].ProducedTinyBlocks = 1;
        nextRound.RealTimeMinersInformation[pubkey].ActualMiningTimes
            .Add(Context.CurrentBlockTime);

        return new AElfConsensusHeaderInformation
        {
            SenderPubkey = ByteStringHelper.FromHexString(pubkey),
            Round = nextRound,
            Behaviour = triggerInformation.Behaviour
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L103-105)
```csharp
    private void AddRoundInformation(Round round)
    {
        State.Rounds.Set(round.RoundNumber, round);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
