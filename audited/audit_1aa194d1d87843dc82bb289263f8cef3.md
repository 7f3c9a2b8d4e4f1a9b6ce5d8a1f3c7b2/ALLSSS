### Title
Pricing Discrepancy in GetNeededDeposit Due to TotalSupply vs Actual Balance Mismatch

### Summary
The `GetNeededDeposit()` function calculates required deposits using `tokenInfo.TotalSupply` as the connector balance for Bancor pricing, while actual `Buy`/`Sell` operations use the converter's actual token holdings via `GetSelfBalance()`. When tokens are in circulation (locked, staked, or held by users), this creates a significant pricing mismatch between the initial deposit calculation and subsequent trading operations, resulting in unexpected prices and potentially rendering the converter unusable or causing financial losses.

### Finding Description

The root cause lies in the inconsistent balance calculation between deposit initialization and trading operations: [1](#0-0) 

In `GetNeededDeposit()`, the `toConnectorBalance` parameter for Bancor pricing uses `tokenInfo.TotalSupply` (either directly or added to virtual balance). This calculates the deposit needed assuming the total supply represents the connector's token position. [2](#0-1) 

The function identifies `amountOutOfTokenConvert = TotalSupply - balance - AmountToTokenConvert`, representing tokens in circulation outside the converter. [3](#0-2) 

However, during actual `Buy`/`Sell` operations, `GetSelfBalance()` is used to determine connector balances. For resource tokens (non-deposit accounts), this returns only the actual balance held by the TokenConverter contract, not the total supply. [4](#0-3) 

The `Buy` operation uses these actual balances for pricing, creating a fundamental mismatch.

### Impact Explanation

**Direct Pricing Impact:**
When a token has significant circulation before `EnableConnector` is called (e.g., TotalSupply = 100,000, but only 10,000 deposited into converter), the pricing discrepancy is severe:
- Deposit calculation uses: `VirtualBalance + 100,000`
- Trading operations use: `VirtualBalance + 10,000` (10x difference)

**Consequences:**
1. **Price Manipulation**: Buy prices become significantly higher than calculated during initialization because the Bancor formula `((tb / (tb - amount))^(wt/wf) - 1) * fb` produces larger values when `tb` is smaller
2. **Unusable Converter**: The extreme price deviation may make the converter economically irrational to use
3. **Reserve Miscalculation**: The deposit amount may be insufficient or excessive for the actual price curve
4. **Financial Loss**: Users expecting prices based on initial calculations face unexpected costs

This affects any token where distribution occurs before connector enablement, impacting token holders, liquidity providers, and the protocol's economic stability.

**Severity:** Medium - While not direct theft, this causes significant pricing inaccuracy and potential financial losses through unexpected price curves.

### Likelihood Explanation

**High Likelihood - Common Operational Pattern:** [5](#0-4) 

The vulnerability triggers in the standard token deployment workflow:
1. Token creator issues tokens with a certain total supply
2. Tokens are distributed to users (who may lock/stake them or simply hold)
3. `EnableConnector` is called to activate trading
4. The remaining tokens are deposited into the converter

**Realistic Preconditions:**
- No special attacker capabilities required
- Occurs naturally when tokens are pre-distributed before converter activation
- Common in scenarios where tokens have existing utility (staking, governance) before trading begins
- Particularly relevant for resource tokens (CPU, RAM, etc.) that users acquire and lock

**Example Scenario:**
- Resource token "CPU" issued: 1,000,000 total
- 900,000 distributed to validators (some locked in staking contracts)
- EnableConnector called with AmountToTokenConvert = 100,000
- Deposit calculated based on 1,000,000 supply
- Trading prices based on 100,000 actual balance
- 10x pricing discrepancy emerges immediately

### Recommendation

**Code-Level Fix:**
Modify `GetNeededDeposit()` to use the post-enablement actual balance instead of TotalSupply for consistent pricing:

```csharp
// Line 78-80: Change from TotalSupply to actual balance after deposit
var tb = toConnector.IsVirtualBalanceEnabled
    ? toConnector.VirtualBalance.Add(balance.Add(input.AmountToTokenConvert))
    : balance.Add(input.AmountToTokenConvert);
```

This ensures the deposit calculation uses the same balance that will be used during actual trading operations, making `tb` consistent with what `GetSelfBalance()` will return.

**Additional Validation:**
Add a check to warn or prevent connector enablement when significant circulation exists:
```csharp
var circulationRatio = amountOutOfTokenConvert * 100 / tokenInfo.TotalSupply;
Assert(circulationRatio < 50, "Cannot enable connector with >50% tokens in circulation - pricing discrepancy risk");
```

**Test Cases:**
1. Test EnableConnector with various circulation ratios (0%, 25%, 50%, 90%)
2. Verify Buy/Sell prices match GetNeededDeposit calculations
3. Test edge case where all tokens are pre-distributed (AmountToTokenConvert << TotalSupply)
4. Validate pricing consistency across different virtual balance configurations

### Proof of Concept

**Initial State:**
1. Create token "TEST" with TotalSupply = 1,000,000
2. Issue 900,000 TEST to user accounts (some lock in staking contracts)
3. TokenConverter holds: 0 TEST
4. Creator holds: 100,000 TEST available for deposit

**Exploit Sequence:**
1. Call `GetNeededDeposit(TokenSymbol: "TEST", AmountToTokenConvert: 100,000)`
   - Calculates: amountOutOfTokenConvert = 1,000,000 - 0 - 100,000 = 900,000
   - Uses: tb = VirtualBalance + 1,000,000 (e.g., 10,000 + 1,000,000 = 1,010,000)
   - Returns: needDeposit calculated with tb = 1,010,000

2. Call `EnableConnector(TokenSymbol: "TEST", AmountToTokenConvert: 100,000)`
   - Deposits calculated needDeposit amount
   - Transfers 100,000 TEST to converter
   - Enables trading

3. Call `Buy(Symbol: "TEST", Amount: 1,000)`
   - GetSelfBalance returns: VirtualBalance + 100,000 = 110,000
   - Calculates price using tb = 110,000 (not 1,010,000!)
   - Price is ~9.2x higher than expected

**Expected vs Actual Result:**
- **Expected**: Prices consistent with deposit calculation using tb = 1,010,000
- **Actual**: Prices calculated using tb = 110,000, causing 9.2x price increase
- **Success Condition**: Demonstrable price discrepancy between GetNeededDeposit calculation and actual Buy operation

**Notes**
The vulnerability stems from a fundamental design inconsistency where locked/staked tokens in circulation inflate the TotalSupply used for deposit calculations, but these tokens don't contribute to the converter's actual liquidity pool. The fix requires aligning both calculations to use the same balance metric - specifically, the tokens that will actually be available in the converter for trading.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L73-73)
```csharp
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L78-80)
```csharp
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L120-123)
```csharp
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L269-300)
```csharp
    public override Empty EnableConnector(ToBeConnectedTokenInfo input)
    {
        var fromConnector = State.Connectors[input.TokenSymbol];
        Assert(fromConnector != null && !fromConnector.IsDepositAccount,
            "[EnableConnector]Can't find from connector.");
        var toConnector = State.Connectors[fromConnector.RelatedSymbol];
        Assert(toConnector != null, "[EnableConnector]Can't find to connector.");
        var needDeposit = GetNeededDeposit(input);
        if (needDeposit.NeedAmount > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = State.BaseTokenSymbol.Value,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = needDeposit.NeedAmount
                });

        if (input.AmountToTokenConvert > 0)
            State.TokenContract.TransferFrom.Send(
                new TransferFromInput
                {
                    Symbol = input.TokenSymbol,
                    From = Context.Sender,
                    To = Context.Self,
                    Amount = input.AmountToTokenConvert
                });

        State.DepositBalance[toConnector.Symbol] = needDeposit.NeedAmount;
        toConnector.IsPurchaseEnabled = true;
        fromConnector.IsPurchaseEnabled = true;
        return new Empty();
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L374-390)
```csharp
    private long GetSelfBalance(Connector connector)
    {
        long realBalance;
        if (connector.IsDepositAccount)
            realBalance = State.DepositBalance[connector.Symbol];
        else
            realBalance = State.TokenContract.GetBalance.Call(
                new GetBalanceInput
                {
                    Owner = Context.Self,
                    Symbol = connector.Symbol
                }).Balance;

        if (connector.IsVirtualBalanceEnabled) return connector.VirtualBalance.Add(realBalance);

        return realBalance;
    }
```
