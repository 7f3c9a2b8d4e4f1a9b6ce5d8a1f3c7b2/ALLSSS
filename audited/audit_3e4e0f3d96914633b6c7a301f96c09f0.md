### Title
Ineffective FinalOrderOfNextRound Validation Allows Consensus Schedule Corruption

### Summary
The NextRoundMiningOrderValidationProvider fails to validate FinalOrderOfNextRound values due to checking the wrong round and using incorrect distinct logic. Combined with unvalidated TuneOrderInformation in UpdateValue transactions, a malicious miner can manipulate mining order assignments to create duplicate or invalid schedules, breaking consensus integrity.

### Finding Description

**Location and Root Cause:**

The NextRoundMiningOrderValidationProvider validates the wrong round object. It checks `ProvidedRound` (the proposed next round) instead of `BaseRound` (the current round): [1](#0-0) 

For NextRound behaviour, `ProvidedRound` is a newly generated round where all miners have `FinalOrderOfNextRound = 0` (not yet determined for the round after next). This makes `distinctCount = 0` and `Count(m => m.OutValue != null) = 0`, causing validation to always pass trivially without checking anything meaningful.

Additionally, even if the correct round were checked, the validation incorrectly calls `Distinct()` on miner objects rather than on their `FinalOrderOfNextRound` values: [2](#0-1) 

Since each miner is a distinct object, this check would pass even if multiple miners have the same `FinalOrderOfNextRound` value.

**Attack Vector:**

The vulnerability is exploited through UpdateValue transactions. The ProcessUpdateValue method accepts `TuneOrderInformation` that can modify any miner's `FinalOrderOfNextRound`: [3](#0-2) 

This dictionary is applied directly to state without any validation of whether the resulting `FinalOrderOfNextRound` values are unique or valid. The UpdateValueValidationProvider only checks OutValue and PreviousInValue fields: [4](#0-3) 

When NextRound is triggered, GenerateNextRoundInformation uses these corrupted `FinalOrderOfNextRound` values to determine the Order of miners in the next round: [5](#0-4) 

If multiple miners have the same `FinalOrderOfNextRound`, they will be assigned the same `Order` in the next round, breaking the mining schedule.

### Impact Explanation

**Consensus Integrity Violation:**

An attacker can corrupt the consensus schedule by creating scenarios where:
- Multiple miners are assigned the same Order in a round (e.g., both Order=1)
- Some miners have Order=0 (invalid)
- The sequence of Orders has gaps or duplicates

This violates the critical invariant that each miner must have a unique, sequential Order value for proper round progression.

**Concrete Consequences:**

1. **Mining Schedule Corruption**: Multiple miners believing they should mine at the same time slot leads to block conflicts and chain forking risks
2. **Extra Block Producer Logic Failure**: The CalculateNextExtraBlockProducerOrder and BreakContinuousMining functions rely on unique Order values and may malfunction
3. **Time Slot Validation Bypass**: Miners with duplicate Orders could both pass time slot validation
4. **LIB Calculation Errors**: Last Irreversible Block height calculation depends on proper order sequencing

**Severity:** HIGH - This breaks a fundamental consensus invariant and can be exploited by any miner during their turn to produce blocks, affecting all subsequent round transitions.

### Likelihood Explanation

**Attacker Capabilities:**

Any miner in the active set can execute this attack during their legitimate mining turn. No special permissions beyond being a miner are required.

**Attack Complexity:**

The attack is straightforward:
1. Wait for assigned mining time slot
2. Produce UpdateValue block with malicious TuneOrderInformation containing duplicate FinalOrderOfNextRound values
3. The validation passes because NextRoundMiningOrderValidationProvider is ineffective
4. State is corrupted with invalid mining order assignments

**Feasibility:**

- Entry point is the public UpdateValue method: [6](#0-5) 
- No additional preconditions required beyond being an active miner
- No economic disincentives as the attack costs only a normal block production
- Detection is difficult as the corruption only manifests in the next round

**Probability:** MEDIUM - Requires a malicious miner but exploitation is reliable and undetectable until damage occurs.

### Recommendation

**Immediate Fixes:**

1. **Fix the validation to check BaseRound:**

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    var validationResult = new ValidationResult();
    var baseRound = validationContext.BaseRound; // Use BaseRound, not ProvidedRound
    var distinctCount = baseRound.RealTimeMinersInformation.Values
        .Where(m => m.FinalOrderOfNextRound > 0)
        .Select(m => m.FinalOrderOfNextRound) // Add Select to get the values
        .Distinct()
        .Count();
    if (distinctCount != baseRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
    {
        validationResult.Message = "Invalid FinalOrderOfNextRound.";
        return validationResult;
    }
    
    validationResult.Success = true;
    return validationResult;
}
```

2. **Add validation for TuneOrderInformation in UpdateValueValidationProvider:**

Check that all FinalOrderOfNextRound values in the recovered baseRound are:
- Unique (no duplicates)
- Within valid range [1, minerCount]
- Complete set with no gaps

3. **Add invariant check in ProcessUpdateValue:**

Before line 284 where `TryToUpdateRoundInformation` is called, validate that all FinalOrderOfNextRound values form a valid, unique sequence.

**Test Cases:**

- Test NextRound validation with BaseRound containing duplicate FinalOrderOfNextRound values
- Test UpdateValue with TuneOrderInformation attempting to create duplicates
- Test UpdateValue with TuneOrderInformation setting values outside valid range
- Test that validation correctly rejects when distinctCount != OutValue count

### Proof of Concept

**Initial State:**
- 3 active miners: A, B, C
- Current round in progress with all miners having mined (OutValue set)
- Miner A's turn to produce next UpdateValue block

**Attack Sequence:**

1. Miner A produces UpdateValue block with crafted TuneOrderInformation:
   ```
   TuneOrderInformation = {
     "MinerB_Pubkey": 1,  // Set B's FinalOrderOfNextRound to 1
     "MinerC_Pubkey": 1   // Set C's FinalOrderOfNextRound to 1 (duplicate!)
   }
   ```

2. Validation executes:
   - UpdateValueValidationProvider checks OutValue/Signature only - PASSES
   - NextRoundMiningOrderValidationProvider (for NextRound behaviour) checks ProvidedRound where all FinalOrderOfNextRound=0 - PASSES
   - No validation catches the duplicate FinalOrderOfNextRound values

3. ProcessUpdateValue executes: [3](#0-2) 
   - Applies TuneOrderInformation directly to currentRound
   - State now has: MinerB.FinalOrderOfNextRound=1, MinerC.FinalOrderOfNextRound=1

4. Later, extra block producer triggers NextRound

5. GenerateNextRoundInformation executes: [5](#0-4) 
   - Creates next round with both MinerB and MinerC having Order=1
   - Mining schedule is now corrupted

**Expected Result:** Validation should reject UpdateValue with duplicate FinalOrderOfNextRound assignments

**Actual Result:** Validation passes, state is corrupted, next round has invalid mining order with duplicates

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-17)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-36)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-102)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
        return new Empty();
    }
```
