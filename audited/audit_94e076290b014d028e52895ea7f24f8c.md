### Title
Creator Impersonation Vulnerability in NFT Protocol Creation

### Summary
The `Create()` function accepts an arbitrary address in the `input.Creator` field without verifying that the caller owns or controls that address. This allows any attacker to create NFT protocols falsely attributed to victim addresses, causing reputation damage and unwanted protocol ownership attribution.

### Finding Description
The vulnerability exists in the `Create()` function where the creator address is assigned without proper authorization: [1](#0-0) 

The code uses `var creator = input.Creator ?? Context.Sender;` which accepts any address provided in `input.Creator` without verification. This creator value is then used to:

1. Set the token issuer in the MultiToken contract: [2](#0-1) 

2. Add the creator to the minter list automatically: [3](#0-2) 

3. Store the creator in the NFT protocol info: [4](#0-3) 

The MultiToken contract's `RegisterTokenInfo` only validates that the issuer is not null, but doesn't verify ownership: [5](#0-4) 

Furthermore, only the falsely attributed creator can manage minters: [6](#0-5) [7](#0-6) 

### Impact Explanation
**Reputation Damage**: Attackers can create unlimited NFT protocols falsely attributed to any address, including prominent community members, organizations, or competitors. Victims appear to have created protocols they never authorized.

**Unwanted Protocol Ownership**: Victims are automatically added as minters and become the sole managers of the minter list. This creates administrative burdens and potential legal liability if the NFT content is malicious, illegal, or infringing.

**Protocol Spam**: The blockchain gets polluted with fake protocol creations that cannot be easily distinguished from legitimate ones, degrading trust in the NFT ecosystem.

**False Attribution**: If problematic NFT collections (e.g., containing offensive content, copyright violations, or scams) are created with a victim's address as creator, they bear the reputational and potential legal consequences.

### Likelihood Explanation
**Attack Complexity**: Trivial - requires only a single transaction with a spoofed creator address.

**Attacker Capabilities**: Any user with access to the NFT contract can execute this attack. No special privileges required beyond the ability to submit transactions.

**Preconditions**: None - the Create function is publicly accessible with only a chain ID check: [8](#0-7) 

**Economic Cost**: Minimal - only gas fees for the Create transaction.

**Detection**: Difficult for victims to detect proactively. They would only discover falsely attributed protocols through monitoring events or when users question their association with unknown collections.

### Recommendation
**Immediate Fix**: Remove the ability to specify a custom creator address. Always use `Context.Sender`:

```csharp
var creator = Context.Sender; // Remove: input.Creator ?? Context.Sender
```

**Alternative Fix**: If there's a legitimate use case for proxy creation, add explicit authorization:

```csharp
if (input.Creator != null && input.Creator != Context.Sender)
{
    Assert(false, "Cannot specify a different creator address. Creator must be the transaction sender.");
}
var creator = Context.Sender;
```

**Validation**: Add integration tests that attempt to create NFT protocols with different creator addresses and verify they fail.

### Proof of Concept
**Initial State**: 
- Alice's address: `0xAAA...AAA`
- Bob's address (attacker): `0xBBB...BBB`
- Chain: AELF MainChain

**Attack Steps**:
1. Bob calls `NFTContract.Create()` with:
   - `Creator = 0xAAA...AAA` (Alice's address)
   - `ProtocolName = "Malicious Collection"`
   - `NftType = "ART"`
   - Other required fields

2. Transaction executes successfully

**Expected Result**: Transaction should fail with "Cannot specify a different creator address"

**Actual Result**: 
- NFT protocol created with symbol (e.g., "AR-1234567")
- Alice's address is the creator in `State.NftProtocolMap[symbol]`
- Alice's address is the issuer in MultiToken contract
- Alice is in the minter list
- Bob cannot mint or manage the protocol
- Alice appears as the creator in all events and queries
- Alice now has unwanted administrative responsibility for a protocol she never created

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L16-17)
```csharp
        Assert(Context.ChainId == ChainHelper.ConvertBase58ToChainId("AELF"),
            "NFT Protocol can only be created at aelf mainchain.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L23-34)
```csharp
        var tokenCreateInput = new MultiToken.CreateInput
        {
            Symbol = symbol,
            Decimals = 0, // Fixed
            Issuer = creator,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId,
            TokenName = input.ProtocolName,
            TotalSupply = input.TotalSupply,
            ExternalInfo = tokenExternalInfo
        };
        State.TokenContract.Create.Send(tokenCreateInput);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L335-353)
```csharp
    public override Empty AddMinters(AddMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol] ?? new MinterList();

        foreach (var minter in input.MinterList.Value)
            if (!minterList.Value.Contains(minter))
                minterList.Value.Add(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListAdded
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L355-373)
```csharp
    public override Empty RemoveMinters(RemoveMintersInput input)
    {
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
        var minterList = State.MinterListMap[protocolInfo.Symbol];

        foreach (var minter in input.MinterList.Value)
            if (minterList.Value.Contains(minter))
                minterList.Value.Remove(minter);

        State.MinterListMap[input.Symbol] = minterList;

        Context.Fire(new MinterListRemoved
        {
            Symbol = input.Symbol,
            MinterList = input.MinterList
        });
        return new Empty();
    }
```
