### Title
Missing Validation Allows Zero Virtual Balance in AddPairConnector Leading to Unusable Token Connector

### Summary
The `AddPairConnector()` function does not validate that `NativeVirtualBalance` must be greater than zero, allowing creation of a connector with zero virtual balance. This causes the connector to become permanently unusable if enabled in certain conditions, as all subsequent Buy/Sell operations will fail due to division-by-zero protection in the Bancor calculation functions.

### Finding Description

In `AddPairConnector()`, the `NativeVirtualBalance` parameter is directly assigned to the native connector's `VirtualBalance` field without validation: [1](#0-0) 

At line 99, `VirtualBalance = input.NativeVirtualBalance` is set without any check that the value must be positive. The function only validates connector weights via `AssertValidConnectorWeight()` at line 106, but has no equivalent validation for virtual balance.

When `GetNeededDeposit()` is called (required before enabling the connector), it uses the connector's virtual balance directly in Bancor calculations: [2](#0-1) 

At line 77, `fb = fromConnector.VirtualBalance` is used, which would be 0. If `amountOutOfTokenConvert > 0`, the code calls `BancorHelper.GetAmountToPayFromReturn(fb=0, ...)` at lines 82-83.

The BancorHelper explicitly rejects zero balances: [3](#0-2) 

At lines 70-71, it throws `InvalidValueException` if `fromConnectorBalance <= 0`.

**Critical Path 1 (Blocking EnableConnector):**
If `amountOutOfTokenConvert > 0`, `GetNeededDeposit()` throws an exception, preventing `EnableConnector()` from succeeding. While this prevents permanent damage, it creates a DoS where the connector cannot be enabled until fixed via `UpdateConnector()`.

**Critical Path 2 (Permanent Unusable Connector):**
If `amountOutOfTokenConvert <= 0` (possible when `totalSupply <= balance + input.AmountToTokenConvert`), `GetNeededDeposit()` returns `needDeposit = 0` without calling Bancor. `EnableConnector()` then succeeds with zero deposit balance. However, `UpdateConnector()` cannot be used after enabling: [4](#0-3) 

Line 64 prevents updates once `IsPurchaseEnabled` is true. Now when Buy/Sell operations are attempted, `GetSelfBalance()` returns 0 (virtual balance 0 + deposit balance 0), causing all Bancor operations to fail permanently.

### Impact Explanation

**Operational DoS Impact:**
- If zero virtual balance is set and the connector is enabled under conditions where `amountOutOfTokenConvert <= 0`, the connector becomes permanently unusable
- All Buy/Sell operations will fail with "Connector balance needs to be a positive number" from BancorHelper
- The connector cannot be fixed via `UpdateConnector()` after activation (line 64 blocks updates)
- This violates the critical invariant for "Pricing & Reserves" - specifically "reserve depletion protection"

**Affected Parties:**
- Token holders cannot trade the affected token pair
- The entire Bancor connector pair becomes non-functional
- Requires deploying a new connector to restore functionality

**Severity:** High - While not causing direct fund loss, it creates permanent loss of core functionality for the affected token pair, requiring governance intervention to deploy replacement connectors.

### Likelihood Explanation

**Required Capabilities:**
- Connector controller authority (default: Parliament default organization)
- This is a governance-level configuration action

**Attack Complexity:**
- LOW - Simply requires setting `NativeVirtualBalance = 0` parameter during `AddPairConnector()` call
- No special conditions or complex transaction sequences required

**Feasibility:**
- HIGH - This is a configuration error that could easily occur through:
  - Mistaken parameter value (using 0 instead of intended value like 100_000_00000000)
  - Copy-paste error from template
  - Misunderstanding of parameter requirements
- All production examples use large positive values, but no validation prevents 0 [5](#0-4) 

The constants at lines 5, 16, and 20 show expected positive values, but `AddPairConnector()` lacks validation to enforce this.

**Detection:**
- Error would be discovered during `GetNeededDeposit()` testing if `amountOutOfTokenConvert > 0`
- May NOT be discovered if enabled under special conditions (`amountOutOfTokenConvert <= 0`)
- Once enabled with zero balance, the issue becomes permanent and obvious during first Buy/Sell attempt

**Probability:** MEDIUM - Requires governance action but involves no malicious intent, making it a realistic operational mistake.

### Recommendation

**Add validation in `AddPairConnector()`:**

Add a validation check after line 105 to ensure virtual balance is positive for deposit account connectors:

```csharp
AssertValidConnectorWeight(nativeTokenToResourceConnector);
Assert(nativeTokenToResourceConnector.VirtualBalance > 0, 
    "Native virtual balance must be greater than zero for deposit account connector.");
State.Connectors[resourceConnector.Symbol] = resourceConnector;
```

This mirrors the existing weight validation pattern and aligns with the check in `UpdateConnector()` at line 72.

**Additional safeguards:**

Add similar validation in `UpdateConnector()` to reject attempts to set virtual balance to 0:

```csharp
if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
    targetConnector.VirtualBalance = input.VirtualBalance;
else if (targetConnector.IsDepositAccount && input.VirtualBalance <= 0)
    throw new AssertionException("Virtual balance must be greater than zero.");
```

**Add regression test:**

Add test case to `AddPairConnector_With_Invalid_Input_Test` covering zero virtual balance:

```csharp
[InlineData("TEST", "0.05", "0.05", 0, "Native virtual balance must be greater than zero")]
```

### Proof of Concept

**Initial State:**
- Parliament governance is active
- TokenConverter contract is initialized

**Step 1 - Create connector with zero virtual balance:**
```
Parliament proposes and approves AddPairConnector({
    ResourceConnectorSymbol: "TESTTOKEN",
    ResourceWeight: "0.05",
    NativeWeight: "0.05",
    NativeVirtualBalance: 0  // ZERO VALUE
})
```
Result: Connector created successfully (no validation error)

**Step 2a - Attempt to enable (normal case):**
```
Create token with totalSupply = 1000
Contract balance = 100
Call EnableConnector({
    TokenSymbol: "TESTTOKEN",
    AmountToTokenConvert: 100
})
```
Result: `GetNeededDeposit()` calculates `amountOutOfTokenConvert = 1000 - 100 - 100 = 800 > 0`, calls `BancorHelper.GetAmountToPayFromReturn(fb=0, ...)`, throws `InvalidValueException: "Connector balance needs to be a positive number."` - EnableConnector fails, connector remains disabled but can be fixed with UpdateConnector.

**Step 2b - Enable under special conditions:**
```
Create token with totalSupply = 1000
Issue 900 tokens to TokenConverter (contract balance = 900)
Call EnableConnector({
    TokenSymbol: "TESTTOKEN",
    AmountToTokenConvert: 100
})
```
Result: `amountOutOfTokenConvert = 1000 - 900 - 100 = 0`, Bancor call skipped, `needDeposit = 0`, EnableConnector succeeds with `DepositBalance = 0`.

**Step 3 - Attempt Buy operation:**
```
Call Buy({
    Symbol: "TESTTOKEN",
    Amount: 100
})
```
Result: `GetSelfBalance(fromConnector)` returns `VirtualBalance(0) + DepositBalance(0) = 0`, `BancorHelper.GetAmountToPayFromReturn()` throws `InvalidValueException: "Connector balance needs to be a positive number."` - Buy fails permanently, connector unusable.

**Success Condition:** The connector is permanently unusable for all trading operations, requiring deployment of a new connector to restore functionality.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConvert_Views.cs (L56-91)
```csharp
    public override DepositInfo GetNeededDeposit(ToBeConnectedTokenInfo input)
    {
        var toConnector = State.Connectors[input.TokenSymbol];
        Assert(toConnector != null && !toConnector.IsDepositAccount, "[GetNeededDeposit]Can't find to connector.");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[GetNeededDeposit]Can't find from connector.");
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(
            new GetTokenInfoInput
            {
                Symbol = input.TokenSymbol
            });
        var balance = State.TokenContract.GetBalance.Call(
            new GetBalanceInput
            {
                Owner = Context.Self,
                Symbol = input.TokenSymbol
            }).Balance;
        var amountOutOfTokenConvert = tokenInfo.TotalSupply - balance - input.AmountToTokenConvert;
        long needDeposit = 0;
        if (amountOutOfTokenConvert > 0)
        {
            var fb = fromConnector.VirtualBalance;
            var tb = toConnector.IsVirtualBalanceEnabled
                ? toConnector.VirtualBalance.Add(tokenInfo.TotalSupply)
                : tokenInfo.TotalSupply;
            needDeposit =
                BancorHelper.GetAmountToPayFromReturn(fb, GetWeight(fromConnector),
                    tb, GetWeight(toConnector), amountOutOfTokenConvert);
        }

        return new DepositInfo
        {
            NeedAmount = needDeposit,
            AmountOutOfTokenConvert = amountOutOfTokenConvert
        };
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L67-94)
```csharp
    public static long GetAmountToPayFromReturn(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long amountToReceive)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (amountToReceive <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = amountToReceive;
        if (wf == wt)
            try
            {
                // if both weights are the same, the formula can be reduced
                return (long)(bf / (bt - a) * a);
            }
            catch
            {
                throw new AssertionException("Insufficient account balance to deposit");
            }

        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
    }
```

**File:** contract/AElf.Contracts.Economic/EconomicContractConstants.cs (L1-32)
```csharp
namespace AElf.Contracts.Economic;

public static class EconomicContractConstants
{
    public const long NativeTokenConnectorInitialVirtualBalance = 100_000_00000000;

    // Token Converter Contract related.
    public const string TokenConverterFeeRate = "0.005";

    // Resource token related.
    public const long ResourceTokenTotalSupply = 500_000_000_00000000;

    public const int ResourceTokenDecimals = 8;

    //resource to sell
    public const long ResourceTokenInitialVirtualBalance = 100_000;

    public const string NativeTokenPrefix = "nt";

    public const long NativeTokenToResourceBalance = 10_000_000_00000000;

    // Election related.
    public const string ElectionTokenSymbol = "VOTE";
    public const string ShareTokenSymbol = "SHARE";
    public const long ElectionTokenTotalSupply = 1_000_000_000_00000000;
    public const int ElectionTokenDecimals = 8;

    public const int MemoMaxLength = 64;

    public const string PayTxFeeSymbolListName = "SymbolListToPayTxFee";
    public const string PayRentalSymbolListName = "SymbolListToPayRental";
}
```
