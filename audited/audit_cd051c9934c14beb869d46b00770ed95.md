### Title
NFT Protocol Permanently Locked When Creator Set to Uncontrolled Address

### Summary
The `Create()` function allows specifying an arbitrary `input.Creator` address without validating that the caller controls it. Since only the creator can modify the minter list via `AddMinters` and `RemoveMinters`, if a user accidentally or intentionally sets the creator to an address they don't control (e.g., through UI error or typo), the NFT protocol becomes permanently locked with no recovery mechanism.

### Finding Description

In the `Create()` function, the creator is determined at line 22 with no validation: [1](#0-0) 

This allows `input.Creator` to be any address, including addresses not controlled by `Context.Sender`. The creator is then added to the minter list: [2](#0-1) 

And stored as the protocol creator: [3](#0-2) 

The critical issue is that both `AddMinters` and `RemoveMinters` require the caller to be the protocol creator: [4](#0-3) [5](#0-4) 

Furthermore, minting, burning, and recasting operations all require the sender to be in the minter list: [6](#0-5) [7](#0-6) [8](#0-7) 

There is no parliament governance override or administrative recovery mechanism - the minter list can only be modified by the creator.

### Impact Explanation

When a protocol is created with an uncontrolled creator address:
1. **No new NFTs can be minted** - minting requires being in the minter list
2. **No NFTs can be burned** - burning requires being in the minter list  
3. **No metadata can be recasted** - recasting requires being in the minter list
4. **The minter list cannot be updated** - only the creator can call AddMinters/RemoveMinters
5. **Complete protocol lockup** - the protocol becomes permanently unusable with no recovery path

This affects the protocol creator who loses complete control over their NFT collection, and any users who may have expected to mint or interact with the NFTs. The entire TotalSupply worth of potential NFTs becomes permanently inaccessible.

### Likelihood Explanation

This vulnerability can be triggered through:
1. **User error**: Typo when entering creator address
2. **UI/frontend bug**: Incorrect form field mapping or address validation
3. **Integration error**: Wrong address source in automated creation flows
4. **Intentional griefing**: Malicious user intentionally bricking their own protocol

The likelihood is **LOW to MEDIUM** because:
- The `input.Creator` field is optional and defaults to `Context.Sender` if not provided
- Most users would leave it null or set it to their own address
- Requires explicit provision of an incorrect address
- However, UI bugs or integration errors in frontend applications are realistic scenarios

The attack complexity is LOW - it's a single transaction with a misspecified parameter.

### Recommendation

**Fix 1 (Recommended)**: Add validation to ensure creator equals transaction sender:

```csharp
// In Create() after line 22:
if (input.Creator != null) {
    Assert(input.Creator == Context.Sender, "Creator must be transaction sender.");
}
var creator = Context.Sender;
```

**Fix 2 (Alternative)**: Remove the ability to specify creator entirely and always use Context.Sender:

```csharp
// Replace line 22:
var creator = Context.Sender;
```

**Additional safeguards**:
- Add a parliament-controlled emergency function to update protocol creator in case of lockup
- Implement time-locked creator transfer mechanism for legitimate ownership changes
- Add comprehensive test cases validating creator authorization and edge cases

### Proof of Concept

**Initial State**: User has ELF tokens and wants to create an NFT protocol

**Step 1**: User calls Create() with typo in creator address:
```
CreateInput {
    Creator = Address("InvalidOrTypoAddress"), // Address nobody controls
    ProtocolName = "MyNFT",
    NftType = "Art",
    TotalSupply = 1000,
    // ... other fields
}
```

**Step 2**: Protocol created with:
- protocolInfo.Creator = "InvalidOrTypoAddress"
- MinterListMap[symbol] = ["InvalidOrTypoAddress"]

**Step 3**: User tries to mint - FAILS (not in minter list)

**Step 4**: User tries to AddMinters to add themselves - FAILS with "No permission" (Context.Sender != protocolInfo.Creator)

**Expected**: User should be able to manage their protocol
**Actual**: Protocol permanently locked, all operations fail, no recovery possible

**Success Condition**: No transaction from any real user can successfully mint, burn, recast, or update the minter list for this protocol.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L22-22)
```csharp
        var creator = input.Creator ?? Context.Sender;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L36-38)
```csharp
        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L40-53)
```csharp
        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L89-93)
```csharp
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L259-260)
```csharp
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(minterList.Value.Contains(Context.Sender), "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L337-338)
```csharp
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L357-358)
```csharp
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(Context.Sender == protocolInfo.Creator, "No permission.");
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L398-399)
```csharp
        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
```
