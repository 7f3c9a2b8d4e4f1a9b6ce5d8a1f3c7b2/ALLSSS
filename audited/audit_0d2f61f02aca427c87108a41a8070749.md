# Audit Report

## Title
Missing Cryptographic Signature Verification in AEDPoS Consensus Allows Mining Order Manipulation

## Summary
The AEDPoS consensus system fails to cryptographically verify miner-provided signatures during UpdateValue transactions. Miners can submit arbitrary signature values to manipulate their mining order in the next round, breaking the verifiable randomness property of the consensus mechanism and enabling unfair positioning as extra block producers.

## Finding Description

The vulnerability exists in the consensus validation flow where signature correctness verification is completely absent.

**How Signatures Should Work:**
During honest block production, signatures are calculated cryptographically by XORing PreviousInValue with all previous round signatures: [1](#0-0) 

This calculation occurs when generating consensus block extra data: [2](#0-1) 

**Critical Impact - Signature Determines Mining Order:**
The provided signature directly controls the miner's position in the next round through integer conversion and modulo arithmetic: [3](#0-2) 

The supposed order is then stored without any validation that the signature was correctly calculated: [4](#0-3) 

**Missing Verification:**
The UpdateValueValidationProvider only performs superficial checks - verifying signatures are non-empty but never checking correctness: [5](#0-4) 

The only other validation confirms that PreviousInValue hashes to PreviousOutValue: [6](#0-5) 

**No Signature Verification Exists:**
A comprehensive search confirms no code performs `Assert(providedSignature == previousRound.CalculateSignature(previousInValue))`. The validation providers list for UpdateValue behavior includes only basic checks: [7](#0-6) 

**Direct Storage Without Verification:**
When processing UpdateValue transactions, the provided signature is stored directly into the round state without any correctness check: [8](#0-7) 

**Attack Vector:**
A malicious miner can:
1. Compute multiple candidate signature values
2. For each candidate, calculate `GetAbsModulus(signature.ToInt64(), minersCount) + 1`
3. Select the signature that yields the most favorable position (e.g., becoming the extra block producer)
4. Submit an UpdateValue transaction with this manipulated signature
5. The system accepts it without verification

**Extra Block Producer Exploitation:**
The extra block producer is selected based on the first miner's signature: [9](#0-8) 

This role controls critical NextRound and NextTerm consensus transitions, providing the attacker with privileged control over consensus state progression.

## Impact Explanation

**Consensus Integrity Compromise:**
The entire mining order randomization mechanism becomes attacker-controlled rather than cryptographically secure. The AEDPoS consensus relies on verifiable randomness through signatures to ensure fair miner ordering, but this property is completely broken when signatures can be arbitrary values.

**Unfair Competitive Advantage:**
- Miners can position themselves as extra block producers who earn additional rewards
- Extra block producers control when NextRound/NextTerm transitions occur, giving them privileged timing control
- Coordinated attacks by multiple colluding miners can create persistent favorable orderings

**Protocol Trust Degradation:**
The commit-reveal scheme using InValue/OutValue pairs and signature-based randomness is designed to prevent mining order manipulation. If signatures are never validated, the entire cryptographic security model becomes meaningless - honest miners cannot trust that other participants are following the protocol rules.

## Likelihood Explanation

**Highly Practical Attack:**
- Any active miner can exploit this vulnerability during their designated time slot
- The attack requires only modifying the signature field in UpdateValue transactions
- No special privileges beyond being an authorized miner are needed

**Zero Cost and Detection Risk:**
- Attack execution costs nothing beyond normal mining operations
- The system has no mechanism to detect manipulated signatures
- Since validation never checks signature correctness, the attack appears identical to normal operation
- No penalties or consequences exist for submitting incorrect signatures

**Immediate Exploitability:**
The UpdateValue transaction is part of normal block production flow, called by every miner: [10](#0-9) 

An attacker simply needs to intercept their own UpdateValue generation and replace the correctly-calculated signature with a manipulated value before submission.

## Recommendation

Add signature verification to the UpdateValueValidationProvider:

```csharp
private bool ValidateSignature(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var publicKey = validationContext.SenderPubkey;
    var providedRound = validationContext.ProvidedRound;
    
    if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey))
        return true;
    
    var previousInValue = providedRound.RealTimeMinersInformation[publicKey].PreviousInValue;
    if (previousInValue == null || previousInValue == Hash.Empty)
        return true;
    
    var expectedSignature = validationContext.PreviousRound.CalculateSignature(previousInValue);
    var providedSignature = providedRound.RealTimeMinersInformation[publicKey].Signature;
    
    return expectedSignature == providedSignature;
}
```

Then add this validation to the ValidateHeaderInformation method:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    if (!NewConsensusInformationFilled(validationContext))
        return new ValidationResult { Message = "Incorrect new Out Value." };

    if (!ValidatePreviousInValue(validationContext))
        return new ValidationResult { Message = "Incorrect previous in value." };
    
    if (!ValidateSignature(validationContext))
        return new ValidationResult { Message = "Invalid signature - does not match calculated value." };

    return new ValidationResult { Success = true };
}
```

## Proof of Concept

```csharp
[Fact]
public async Task MinerCanManipulateMiningOrderWithArbitrarySignature()
{
    // Setup: Initialize consensus with multiple miners
    var miners = await InitializeConsensusWithMinersAsync(5);
    var attackerMiner = miners[0];
    
    // Advance to a normal round where attacker wants to manipulate order
    await ProduceBlocksUntilRound(2);
    
    var currentRound = await GetCurrentRoundAsync();
    var previousRound = await GetPreviousRoundAsync();
    
    // Calculate CORRECT signature (what honest miner would provide)
    var previousInValue = GenerateRandomHash();
    var correctSignature = previousRound.CalculateSignature(previousInValue);
    var honestOrder = Math.Abs((int)correctSignature.ToInt64() % 5) + 1;
    
    // Attacker manipulates signature to get favorable order (e.g., position 1 to become extra block producer)
    var manipulatedSignature = Hash.LoadFromByteArray(new byte[32]); // All zeros -> will map to order 1
    var attackOrder = Math.Abs((int)manipulatedSignature.ToInt64() % 5) + 1;
    
    Assert.NotEqual(honestOrder, attackOrder); // Different orders
    Assert.Equal(1, attackOrder); // Attacker positioned as potential extra block producer
    
    // Submit UpdateValue with MANIPULATED signature
    var updateValueInput = new UpdateValueInput
    {
        OutValue = HashHelper.ComputeFrom(previousInValue),
        Signature = manipulatedSignature, // MALICIOUS: arbitrary signature
        PreviousInValue = previousInValue,
        ActualMiningTime = TimestampHelper.GetUtcNow(),
        SupposedOrderOfNextRound = attackOrder
    };
    
    // VULNERABILITY: This transaction succeeds despite incorrect signature
    var result = await attackerMiner.UpdateValue(updateValueInput);
    Assert.True(result.TransactionResult.Status == TransactionResultStatus.Mined);
    
    // Verify attacker achieved manipulated order in next round
    var nextRound = await GetNextRoundAsync();
    var attackerInNextRound = nextRound.RealTimeMinersInformation[attackerMiner.PublicKey];
    
    Assert.Equal(attackOrder, attackerInNextRound.Order);
    Assert.NotEqual(honestOrder, attackerInNextRound.Order);
    
    // Attacker may now be extra block producer
    if (attackOrder == nextRound.CalculateNextExtraBlockProducerOrder())
    {
        Assert.True(attackerInNextRound.IsExtraBlockProducer);
    }
}
```

## Notes

The vulnerability is particularly severe because:

1. **All data for verification is present**: The GetUpdateValueRound method includes PreviousInValue for all miners [11](#0-10)  and [12](#0-11) , so the validation could be performed but simply isn't.

2. **The CalculateSignature method exists and is used correctly elsewhere**: The honest path properly calculates signatures, showing the protocol designers intended cryptographic verification but failed to enforce it during validation.

3. **Extra block producer control is critical**: Being the extra block producer determines who can call NextRound/NextTerm [13](#0-12) , which are consensus-critical state transitions that affect all miners and the entire chain.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L35-49)
```csharp
    private bool ValidatePreviousInValue(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var publicKey = validationContext.SenderPubkey;

        if (!validationContext.PreviousRound.RealTimeMinersInformation.ContainsKey(publicKey)) return true;

        if (extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue == null) return true;

        var previousOutValue = validationContext.PreviousRound.RealTimeMinersInformation[publicKey].OutValue;
        var previousInValue = extraData.Round.RealTimeMinersInformation[publicKey].PreviousInValue;
        if (previousInValue == Hash.Empty) return true;

        return HashHelper.ComputeFrom(previousInValue) == previousOutValue;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-83)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-247)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L110-123)
```csharp
    private int CalculateNextExtraBlockProducerOrder()
    {
        var firstPlaceInfo = RealTimeMinersInformation.Values.OrderBy(m => m.Order)
            .FirstOrDefault(m => m.Signature != null);
        if (firstPlaceInfo == null)
            // If no miner produce block during this round, just appoint the first miner to be the extra block producer of next round.
            return 1;

        var signature = firstPlaceInfo.Signature;
        var sigNum = signature.ToInt64();
        var blockProducerCount = RealTimeMinersInformation.Count;
        var order = GetAbsModulus(sigNum, blockProducerCount) + 1;
        return order;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L98-100)
```csharp
    public override Empty UpdateValue(UpdateValueInput input)
    {
        ProcessConsensusInformation(input);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L27-27)
```csharp
                    PreviousInValue = minerInRound.PreviousInValue,
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Simplify.cs (L51-51)
```csharp
                    PreviousInValue = information.Value.PreviousInValue
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```
