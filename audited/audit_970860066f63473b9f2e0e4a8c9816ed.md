### Title
State Corruption via Reference Mutation in GetNFTInfoByTokenHash View Method

### Summary
The `GetNFTInfoByTokenHash()` view method mutates the cached state object by adding protocol-level fields (ProtocolName, Creator, BaseUri, NftType) to the returned NFTInfo reference. When the `Burn()` and `Recast()` methods call this function and subsequently write the modified object back to state, these protocol-level fields are permanently persisted in the NFTInfo state map, corrupting the intended data model and violating the design principle of keeping protocol and token-level information separate.

### Finding Description

The vulnerability exists in the `GetNFTInfoByTokenHash()` method where protocol-level fields are added to the nftInfo object retrieved from state: [1](#0-0) 

The root cause lies in how AElf's `MappedState<TKey, TEntity>` works. When accessing `State.NftInfoMap[input]`, the getter returns a reference to the cached `valuePair.Value` object, not a copy: [2](#0-1) 

Since protobuf messages (NFTInfo) are reference types deserialized as new instances, modifying the returned reference affects the cached object: [3](#0-2) 

The `Burn()` method calls `GetNFTInfoByTokenHash()` to retrieve NFTInfo, makes modifications, and writes it back to state, persisting the polluted protocol-level fields: [4](#0-3) 

Similarly, the `Recast()` method exhibits the same pattern: [5](#0-4) 

The design intent is confirmed in the `PerformMint()` method where protocol-level fields are explicitly excluded from NFTInfo state with a "No need" comment: [6](#0-5) 

When state changes are captured via `GetChanges()`, the modified cache is compared against the original, and differences (including the newly added protocol fields) are persisted: [7](#0-6) 

### Impact Explanation

**State Corruption**: NFTInfo records are permanently corrupted with protocol-level data (ProtocolName, Creator, BaseUri, NftType) that should only exist in NFTProtocolInfo state. This violates the data model separation.

**Data Inconsistency**: If protocol information is updated via governance or other means, NFTs that have been burned or recast will retain stale protocol-level data in their state, creating inconsistencies across the system.

**Storage Waste**: Every NFT that undergoes burn or recast operations wastes blockchain storage by redundantly storing protocol-level information that should be referenced, not duplicated.

**Design Violation**: The architecture explicitly separates protocol-level metadata (stored once in NFTProtocolInfo) from token-level metadata (stored per-token in NFTInfo). This corruption breaks that separation, affecting all users who burn or recast NFTs.

Severity: **Critical** - This corrupts persistent state for core NFT operations (burn/recast) affecting data integrity across the entire NFT system.

### Likelihood Explanation

**Reachable Entry Points**: Both `Burn()` and `Recast()` are publicly callable contract methods that any authorized minter can execute.

**Feasible Preconditions**: 
- For `Burn()`: User must be a minter with balance of the NFT
- For `Recast()`: User must be a minter with exclusive balance of the NFT

**Execution Practicality**: The vulnerability triggers automatically on every legitimate burn or recast operation - no special conditions or attack sequences required. The corruption occurs through normal contract execution flow.

**Economic Rationality**: No additional cost beyond normal transaction fees. Every burn/recast operation triggers the bug, making this a guaranteed outcome rather than an attack requiring special circumstances.

**Detection**: The corruption is subtle and may go undetected initially since the protocol-level fields match expected values. Only becomes apparent when protocol information is updated or storage costs are analyzed.

Likelihood: **High** - Triggers on every burn/recast operation, which are common NFT lifecycle actions.

### Recommendation

**Immediate Fix**: Clone the NFTInfo object before modifying it in `GetNFTInfoByTokenHash()`:

```csharp
public override NFTInfo GetNFTInfoByTokenHash(Hash input)
{
    var storedNftInfo = State.NftInfoMap[input];
    if (storedNftInfo == null) return new NFTInfo();
    
    // Create a new instance to avoid mutating cached state
    var nftInfo = storedNftInfo.Clone();
    var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
    nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
    nftInfo.Creator = nftProtocolInfo.Creator;
    nftInfo.BaseUri = nftProtocolInfo.BaseUri;
    nftInfo.NftType = nftProtocolInfo.NftType;
    return nftInfo;
}
```

**Alternative Fix**: Update `Burn()` and `Recast()` to read directly from state instead of using the view method:

```csharp
var nftInfo = State.NftInfoMap[tokenHash];
```

**State Migration**: Implement a migration to remove polluted protocol-level fields from existing corrupted NFTInfo records.

**Invariant Checks**: Add assertions in test cases to verify NFTInfo state contains only token-level fields (Symbol, TokenId, Minters, Metadata, Quantity, Uri, Alias, IsBurned) and never contains protocol-level fields (ProtocolName, Creator, BaseUri, NftType).

**Test Cases**: 
1. Verify `GetNFTInfoByTokenHash()` doesn't modify cached state
2. Verify `Burn()` persists only token-level fields
3. Verify `Recast()` persists only token-level fields
4. Verify protocol info updates don't affect previously saved NFTs

### Proof of Concept

**Initial State:**
1. Create an NFT protocol with symbol "TEST" via `Create()`
2. Mint an NFT with tokenId 1 via `Mint()`
3. Query `State.NftInfoMap[tokenHash]` - confirm it contains no ProtocolName/Creator/BaseUri/NftType fields

**Exploitation Steps:**
1. User calls `Burn()` on TEST#1 with amount 1
2. Inside `Burn()`, line 85 calls `GetNFTInfoByTokenHash(tokenHash)`
3. `GetNFTInfoByTokenHash()` retrieves cached NFTInfo and adds protocol fields to it (lines 25-28)
4. `Burn()` modifies the same object (line 96: `nftInfo.Quantity = ...`) 
5. `Burn()` writes modified object back (line 101: `State.NftInfoMap[tokenHash] = nftInfo`)
6. Query `State.NftInfoMap[tokenHash]` - confirm it now contains ProtocolName/Creator/BaseUri/NftType

**Expected vs Actual:**
- **Expected**: NFTInfo state contains only token-level fields (Symbol, TokenId, Metadata, Quantity, etc.)
- **Actual**: NFTInfo state contains protocol-level fields (ProtocolName, Creator, BaseUri, NftType) that should not be persisted

**Success Condition**: Reading the raw state data shows the four protocol-level fields are permanently stored in the NFTInfo state map entry, violating the data model design.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_View.cs (L20-30)
```csharp
    public override NFTInfo GetNFTInfoByTokenHash(Hash input)
    {
        var nftInfo = State.NftInfoMap[input];
        if (nftInfo == null) return new NFTInfo();
        var nftProtocolInfo = State.NftProtocolMap[nftInfo.Symbol];
        nftInfo.ProtocolName = nftProtocolInfo.ProtocolName;
        nftInfo.Creator = nftProtocolInfo.Creator;
        nftInfo.BaseUri = nftProtocolInfo.BaseUri;
        nftInfo.NftType = nftProtocolInfo.NftType;
        return nftInfo;
    }
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L26-36)
```csharp
    public TEntity this[TKey key]
    {
        get
        {
            if (!Cache.TryGetValue(key, out var valuePair))
            {
                valuePair = LoadKey(key);
                Cache[key] = valuePair;
            }

            return valuePair.IsDeleted ? SerializationHelper.Deserialize<TEntity>(null) : valuePair.Value;
```

**File:** src/AElf.Sdk.CSharp/State/MappedState.cs (L78-93)
```csharp
    internal override TransactionExecutingStateSet GetChanges()
    {
        var stateSet = new TransactionExecutingStateSet();
        foreach (var kv in Cache)
        {
            var key = GetSubStatePath(kv.Key.ToString()).ToStateKey(Context.Self);
            if (kv.Value.IsDeleted)
                stateSet.Deletes[key] = true;
            else if (!Equals(kv.Value.OriginalValue, kv.Value.Value))
                stateSet.Writes[key] = ByteString.CopyFrom(SerializationHelper.Serialize(kv.Value.Value));

            stateSet.Reads[key] = true;
        }

        return stateSet;
    }
```

**File:** src/AElf.Types/Helper/SerializationHelper.cs (L106-111)
```csharp
            if (typeof(IMessage).IsAssignableFrom(type))
            {
                var instance = (IMessage)Activator.CreateInstance(type);
                instance.MergeFrom(bytes);
                return (T)instance;
            }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L82-102)
```csharp
    public override Empty Burn(BurnInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        var nftProtocolInfo = State.NftProtocolMap[input.Symbol];
        Assert(nftProtocolInfo.IsBurnable,
            $"NFT Protocol {nftProtocolInfo.ProtocolName} of symbol {nftProtocolInfo.Symbol} is not burnable.");
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(
            State.BalanceMap[tokenHash][Context.Sender] >= input.Amount &&
            minterList.Value.Contains(Context.Sender),
            "No permission.");
        State.BalanceMap[tokenHash][Context.Sender] = State.BalanceMap[tokenHash][Context.Sender].Sub(input.Amount);
        nftProtocolInfo.Supply = nftProtocolInfo.Supply.Sub(input.Amount);
        nftInfo.Quantity = nftInfo.Quantity.Sub(input.Amount);

        State.NftProtocolMap[input.Symbol] = nftProtocolInfo;
        if (nftInfo.Quantity == 0 && !nftProtocolInfo.IsTokenIdReuse) nftInfo.IsBurned = true;

        State.NftInfoMap[tokenHash] = nftInfo;

```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L256-283)
```csharp
    public override Empty Recast(RecastInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        var minterList = State.MinterListMap[input.Symbol] ?? new MinterList();
        Assert(minterList.Value.Contains(Context.Sender), "No permission.");
        var nftInfo = GetNFTInfoByTokenHash(tokenHash);
        Assert(nftInfo.Quantity != 0 && nftInfo.Quantity == State.BalanceMap[tokenHash][Context.Sender],
            "Do not support recast.");
        if (input.Alias != null) nftInfo.Alias = input.Alias;

        if (input.Uri != null) nftInfo.Uri = input.Uri;

        var oldMetadata = nftInfo.Metadata.Clone();
        var metadata = new Metadata();
        // Need to keep reserved metadata key.
        foreach (var reservedKey in GetNftMetadataReservedKeys())
        {
            if (oldMetadata.Value.ContainsKey(reservedKey))
                metadata.Value[reservedKey] = oldMetadata.Value[reservedKey];

            if (input.Metadata.Value.ContainsKey(reservedKey)) input.Metadata.Value.Remove(reservedKey);
        }

        metadata.Value.Add(input.Metadata.Value);
        nftInfo.Metadata = metadata;

        State.NftInfoMap[tokenHash] = nftInfo;
        Context.Fire(new Recasted
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L417-431)
```csharp
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
```
