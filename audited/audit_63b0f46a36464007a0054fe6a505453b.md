### Title
Governance Manipulation via Selective Member Removal Bypasses Proposal Rejection Thresholds

### Summary
The `IsProposalRejected()` function counts only current members' rejections while `CheckEnoughVoteAndApprovals()` counts all votes including removed members toward the participation threshold. This inconsistency allows an organization to retroactively bypass rejection thresholds by removing members who voted against a proposal, enabling execution of proposals that should remain rejected.

### Finding Description

**Code Location and Root Cause:**

In `IsProposalRejected()`, rejection votes are filtered by current membership: [1](#0-0) 

However, in `CheckEnoughVoteAndApprovals()`, total votes are counted without membership filtering: [2](#0-1) 

When `RemoveMember()` is called, it removes the address from `OrganizationMemberList` but does NOT clean up existing votes in active proposals: [3](#0-2) 

**Why Existing Protections Fail:**

The voting methods (`Approve`, `Reject`, `Abstain`) correctly enforce membership checks when votes are cast: [4](#0-3) 

However, there is no mechanism to invalidate or clean up votes when a member is subsequently removed. This creates a time-of-check-time-of-use vulnerability where the membership status at vote-casting time differs from membership status at proposal-release time.

**Execution Path:**

1. Member votes on a proposal (rejection is recorded)
2. Organization passes a separate proposal to call `RemoveMember()` on that member
3. The removed member's rejection vote remains in `proposal.Rejections`
4. When checking `IsProposalRejected()`, the vote is silently ignored (address not in current member list)
5. When checking `CheckEnoughVoteAndApprovals()`, the vote still counts toward `MinimalVoteThreshold`
6. A previously rejected proposal becomes releasable

### Impact Explanation

**Governance Integrity Compromise:**

An organization can manipulate proposal outcomes retroactively by selectively removing members who voted against controversial proposals. This enables:

1. **Rejection Threshold Bypass**: Proposals that exceeded `MaximalRejectionThreshold` can be made passable by removing enough rejecting members to bring the current-member rejection count below the threshold.

2. **Vote Weight Manipulation**: The removed members' votes still count toward `MinimalVoteThreshold`, allowing fewer actual current members to control decisions while meeting participation requirements with "ghost votes."

3. **Democratic Process Subversion**: A minority coalition that controls member removal can force through proposals that the full membership rejected, undermining the purpose of rejection thresholds.

**Concrete Example:**
- Organization with 10 members
- Thresholds: `MinimalVoteThreshold=5`, `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=2`
- Proposal receives 4 approvals, 3 rejections (rejected: 3 > 2)
- Remove 1 rejecting member
- Now: 4 approvals (current members), 2 rejections (current members only), 7 total votes (including removed member)
- Proposal becomes releasable despite having been fairly rejected

**Affected Parties:**
- Organization members who voted to reject malicious proposals
- External parties affected by improperly approved proposals (e.g., fund transfers, permission grants)

### Likelihood Explanation

**Attacker Capabilities Required:**

The attacker must control enough organization members to:
1. Create and pass a proposal to remove dissenting members
2. Re-evaluate the target proposal after removal

**Attack Complexity:** Medium

The attack requires two governance actions:
1. Getting a member removal proposal approved (requires `MinimalApprovalThreshold` support)
2. The target proposal becoming passable after removals

**Feasibility Conditions:**

This attack is practical when:
- A majority coalition wants to force through a controversial proposal
- The organization structure allows member removal (which is a standard feature)
- The timing between proposals allows for this manipulation
- Organization validation constraints are satisfied (member removal must maintain threshold relationships) [5](#0-4) 

**Detection/Operational Constraints:**

The attack is somewhat transparent (member removal is recorded in events), but the connection to proposal manipulation may not be obvious. Organizations may legitimately remove members for other reasons, making this attack blend with normal operations.

**Probability Assessment:** Medium

While requiring governance consensus for member removal, majority coalitions frequently exist in multi-sig organizations, making this attack vector realistic in contentious governance scenarios.

### Recommendation

**Immediate Mitigation:**

1. **Clean Up Votes on Member Removal**: When `RemoveMember()` or `ChangeMember()` is called, iterate through active proposals and remove the affected member's votes:

```csharp
// In RemoveMember() after line 270:
// Clean up votes in active proposals
foreach (var proposalId in State.ActiveProposals[organizationAddress])
{
    var proposal = State.Proposals[proposalId];
    if (proposal != null)
    {
        proposal.Approvals.Remove(input);
        proposal.Rejections.Remove(input);
        proposal.Abstentions.Remove(input);
        State.Proposals[proposalId] = proposal;
    }
}
```

2. **Consistent Vote Counting**: Alternatively, make `CheckEnoughVoteAndApprovals()` count only current-member votes for consistency:

```csharp
var totalVoteCount = 
    proposal.Approvals.Count(organization.OrganizationMemberList.Contains) +
    proposal.Rejections.Count(organization.OrganizationMemberList.Contains) +
    proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
```

3. **Add Invariant Check**: Prevent member removal if it would change any active proposal from rejected to non-rejected state.

**Test Cases to Add:**

1. Create proposal, have members vote to reject it (exceeding threshold)
2. Remove rejecting members
3. Verify proposal remains rejected (current behavior allows release)
4. Test with `ChangeMember()` as well

### Proof of Concept

**Initial State:**
- Organization with members: `[A, B, C, D, E, F, G, H, I, J]` (10 members)
- Thresholds: `MinimalVoteThreshold=5`, `MinimalApprovalThreshold=4`, `MaximalRejectionThreshold=2`

**Step 1: Create Malicious Proposal X**
- Call `CreateProposal()` for a malicious action
- ProposalId: `X`

**Step 2: Voting on Proposal X**
- Members A, B, C, D: Call `Approve(X)`
- Members E, F, G: Call `Reject(X)`
- State: `Approvals=[A,B,C,D]`, `Rejections=[E,F,G]`, total=7 votes

**Step 3: Check Release Status**
- `IsProposalRejected()`: rejectionMemberCount = 3 > 2 → TRUE (rejected)
- `CheckEnoughVoteAndApprovals()`: 4 approvals >= 4, 7 votes >= 5 → TRUE
- **Result: Proposal X CANNOT be released (rejected)**

**Step 4: Remove Rejecting Member**
- Create Proposal Y to call `RemoveMember(E)`
- Get Y approved and call `Release(Y)`
- Organization now: `[A,B,C,D,F,G,H,I,J]` (9 members)

**Step 5: Re-check Proposal X Release Status**
- Proposal X state unchanged: `Approvals=[A,B,C,D]`, `Rejections=[E,F,G]`
- `IsProposalRejected()`: rejectionMemberCount = 2 (E not a member, F and G are) → 2 <= 2 → FALSE (not rejected)
- `CheckEnoughVoteAndApprovals()`: approvalMemberCount = 4, totalVotes = 7 >= 5 → TRUE
- **Result: Proposal X CAN NOW be released despite being fairly rejected**

**Step 6: Execute Attack**
- Call `Release(X)` successfully
- Malicious proposal executes despite exceeding rejection threshold when voted upon

**Success Condition:**
A proposal that was rejected (rejections > MaximalRejectionThreshold) becomes executable after selective member removal, demonstrating governance manipulation vulnerability.

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L36-37)
```csharp
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L56-57)
```csharp
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L72-80)
```csharp
        return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L143-161)
```csharp
    public override Empty Reject(Hash input)
    {
        var proposal = GetValidProposal(input);
        AssertProposalNotYetVotedBySender(proposal, Context.Sender);
        var organization = GetOrganization(proposal.OrganizationAddress);
        AssertIsAuthorizedOrganizationMember(organization, Context.Sender);

        proposal.Rejections.Add(Context.Sender);
        State.Proposals[input] = proposal;
        Context.Fire(new ReceiptCreated
        {
            Address = Context.Sender,
            ProposalId = input,
            Time = Context.CurrentBlockTime,
            ReceiptType = nameof(Reject),
            OrganizationAddress = proposal.OrganizationAddress
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L266-279)
```csharp
    public override Empty RemoveMember(Address input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        var removeResult = organization.OrganizationMemberList.OrganizationMembers.Remove(input);
        Assert(removeResult, "Remove member failed.");
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new MemberRemoved
        {
            OrganizationAddress = Context.Sender,
            Member = input
        });
        return new Empty();
```
