### Title
Unbounded Voting Item Creation Enables Blockchain State Bloat Attack

### Summary
The Vote contract allows any address to create unlimited voting items with only a transaction fee as barrier. Each voting item can store up to 64KB in options alone, and there are no limits on the number of items per address or globally. A well-funded attacker can create thousands of voting items to cause permanent blockchain state bloat, increasing storage requirements and sync times for all nodes.

### Finding Description

The Vote contract defines maximum storage limits per voting item in constants: [1](#0-0) 

The `Register()` method allows anyone to create voting items without any rate limiting or per-address restrictions: [2](#0-1) 

The only validation performed is checking that a voting item with the exact same parameters doesn't already exist: [3](#0-2) 

The voting item ID is calculated based on input parameters (excluding options) and the sender's address: [4](#0-3) 

This means an attacker can create distinct voting items by varying any of these parameters: `start_timestamp`, `end_timestamp`, `accepted_currency`, `is_lock_token`, `total_snapshot_number`, `is_quadratic`, or `ticket_cost`.

The only economic barrier is the default transaction fee of 10 ELF per registration: [5](#0-4) 

Each voting item is permanently stored in state with no expiration or cleanup mechanism: [6](#0-5) 

Option validation only checks length limits per option and maximum count, but doesn't restrict total storage: [7](#0-6) 

### Impact Explanation

**Quantified Storage Impact:**
- Each voting item can store 64 options × 1,024 bytes = 65,536 bytes (64KB) in options alone
- Additional metadata per item: approximately 200+ bytes (addresses, timestamps, flags, voting results)
- Total storage per maximal item: ~64.2 KB
- 1,000 items = 64.2 MB of permanent state
- 10,000 items = 642 MB of permanent state

**Affected Parties:**
- All full nodes must store this data permanently in their state database
- New nodes must download and verify all voting items during initial sync
- Light clients and indexing services must process all this data

**Severity Justification:**
This is a Medium severity issue because:
1. It doesn't directly compromise funds or consensus security
2. It causes operational degradation (increased sync times, storage costs, query performance)
3. The impact scales linearly with attacker investment
4. State bloat is permanent and cannot be reversed without a hard fork

### Likelihood Explanation

**Attacker Capabilities:**
- Requires capital: 10 ELF × number of items to create
- For 10,000 items: 100,000 ELF investment
- No special permissions or contract authority needed
- Can execute attack from any address

**Attack Complexity:**
- Very simple: repeatedly call `Register()` with different parameter combinations
- Can automate with a simple script
- No need to interact with other contracts
- No timing constraints or race conditions

**Feasibility Conditions:**
- Economically feasible if ELF token price is low or attacker has significant holdings
- No technical barriers beyond transaction fee payment
- Attack is undetectable until state bloat becomes noticeable
- No mechanism exists to remove malicious voting items

**Probability Assessment:**
The likelihood is Medium because:
1. The economic barrier (10 ELF per item) provides some deterrence
2. Creating thousands of items requires substantial capital investment
3. However, a motivated attacker (competitor, state-filling attack) could afford this cost
4. The attack has permanent impact, making the cost/benefit ratio potentially favorable

### Recommendation

**Immediate Mitigations:**

1. **Implement per-address voting item limits:**
```csharp
// In VoteContractState.cs, add:
public MappedState<Address, int64> VotingItemCounts { get; set; }

// In VoteContract.cs Register method, add after line 22:
var senderItemCount = State.VotingItemCounts[Context.Sender];
Assert(senderItemCount < MaxVotingItemsPerAddress, 
       $"Address has reached maximum voting item limit of {MaxVotingItemsPerAddress}");
State.VotingItemCounts[Context.Sender] = senderItemCount.Add(1);
```

2. **Add global voting item counter and limit:**
```csharp
// In VoteContractState.cs, add:
public SingletonState<int64> TotalVotingItemCount { get; set; }

// In VoteContract.cs Register method, add validation:
var totalCount = State.TotalVotingItemCount.Value;
Assert(totalCount < MaxTotalVotingItems, 
       "System has reached maximum voting items limit");
State.TotalVotingItemCount.Value = totalCount.Add(1);
```

3. **Implement voting item expiration:**
Add automatic cleanup of expired voting items that have passed their `end_timestamp` by a grace period (e.g., 30 days).

4. **Increase registration fee for large option sets:**
Scale the transaction fee based on the size of options provided to better reflect storage costs.

**Test Cases:**
- Test that addresses cannot exceed per-address limit
- Test that system enforces global limit
- Test that expired items can be cleaned up
- Test fee scaling with option sizes

### Proof of Concept

**Initial State:**
- Attacker has 100,000 ELF tokens
- Token contract has whitelisted "ELF" for voting

**Attack Steps:**

1. **Create 10,000 voting items with varying timestamps:**
```
For i = 0 to 9,999:
  Call VoteContract.Register({
    start_timestamp: current_time + i seconds,
    end_timestamp: current_time + 365 days + i seconds,
    accepted_currency: "ELF",
    is_lock_token: true,
    total_snapshot_number: 1,
    options: [64 options of 1024 bytes each], // 64KB per item
    is_quadratic: false,
    ticket_cost: 0
  })
  
  Cost per call: 10 ELF
```

2. **Total attack cost:** 10,000 × 10 ELF = 100,000 ELF

3. **Storage bloat created:** 10,000 × 64.2 KB ≈ 642 MB of permanent state

**Expected Result:**
All 10,000 voting items are successfully created and stored permanently in blockchain state.

**Actual Result:**
With no limits in place, the attack succeeds completely, causing:
- 642 MB of state bloat
- Increased full node storage requirements
- Slower initial sync for new nodes (must download and verify all items)
- Degraded query performance when listing or searching voting items

**Success Condition:**
An attacker with sufficient capital can arbitrarily inflate blockchain state by creating thousands of voting items, with the only cost being transaction fees that don't adequately reflect the permanent storage burden imposed on all network participants.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-82)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
            IsQuadratic = input.IsQuadratic,
            TicketCost = input.TicketCost
        };

        State.VotingItems[votingItemId] = votingItem;

        // Initialize first voting going information of registered voting event.
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };

        Context.Fire(new VotingItemRegistered
        {
            Sponsor = votingItem.Sponsor,
            VotingItemId = votingItemId,
            AcceptedCurrency = votingItem.AcceptedCurrency,
            IsLockToken = votingItem.IsLockToken,
            TotalSnapshotNumber = votingItem.TotalSnapshotNumber,
            CurrentSnapshotNumber = votingItem.CurrentSnapshotNumber,
            CurrentSnapshotStartTimestamp = votingItem.StartTimestamp,
            StartTimestamp = votingItem.StartTimestamp,
            EndTimestamp = votingItem.EndTimestamp,
            RegisterTimestamp = votingItem.RegisterTimestamp,
            IsQuadratic = votingItem.IsQuadratic,
            TicketCost = votingItem.TicketCost
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteExtensions.cs (L7-12)
```csharp
    public static Hash GetHash(this VotingRegisterInput votingItemInput, Address sponsorAddress)
    {
        var input = votingItemInput.Clone();
        input.Options.Clear();
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(input), HashHelper.ComputeFrom(sponsorAddress));
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
