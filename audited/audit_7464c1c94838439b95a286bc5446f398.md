### Title
First Round Consensus Command Scheduling Overflow - Last Miner Scheduled Beyond Round Boundary

### Summary
The FirstRoundCommandStrategy incorrectly calculates mining time offsets, causing miners (especially the last miner) to be scheduled far beyond their correct time slots. For the last miner, the calculation `(2 * MinersCount - 1) * miningInterval` places them beyond the round boundary of `(MinersCount + 1) * miningInterval`, effectively scheduling them into the next round and breaking first-round consensus timing invariants.

### Finding Description
The vulnerability exists in the offset calculation at line 37 of FirstRoundCommandStrategy.cs: [1](#0-0) 

The formula `Order.Add(MinersCount).Sub(1).Mul(miningInterval)` evaluates to `(Order + MinersCount - 1) * miningInterval`. For a miner with Order == MinersCount (the last miner), this becomes `(2 * MinersCount - 1) * miningInterval`.

However, the correct time slot allocation is defined in the first round generation logic: [2](#0-1) 

This shows that for a miner at index `i` (where Order = i + 1), the expected mining time should be `currentBlockTime + (i * miningInterval + miningInterval)`, which simplifies to `currentBlockTime + Order * miningInterval`. Therefore, the correct offset should be `Order * miningInterval`, not `(Order + MinersCount - 1) * miningInterval`.

The total duration of one round is explicitly defined as: [3](#0-2) 

This is `MinersCount * miningInterval + miningInterval = (MinersCount + 1) * miningInterval`.

**Concrete Example (MinersCount = 5):**
- Last miner's correct offset: `5 * miningInterval`
- Last miner's actual offset: `(5 + 5 - 1) * miningInterval = 9 * miningInterval`
- Round boundary: `(5 + 1) * miningInterval = 6 * miningInterval`
- Result: The last miner is scheduled at `9 * miningInterval`, which is **3 * miningInterval beyond the round boundary**

This is confirmed by test expectations that validate the buggy behavior rather than correct behavior: [4](#0-3) 

The test expects a miner to be scheduled at `7 * miningInterval` when the correct slot should be `3 * miningInterval` based on first round generation logic.

### Impact Explanation
**Consensus Timing Integrity Violation:**
- All miners except Order 1 are scheduled at incorrect times during the first round of every blockchain/term initialization
- The discrepancy increases with miner order: for Order N in a system with N miners, the error is `(N - 1) * miningInterval`
- The last miner(s) are scheduled **beyond the current round boundary**, placing them in the time space intended for the next round

**Concrete Impact:**
1. **Round Transition Corruption**: The last miner's time slot overlaps with the next round, violating the fundamental round structure where each round should have MinersCount regular slots plus one extra block producer slot
2. **Timing Confusion**: Miners wait for incorrect scheduled times, potentially causing:
   - Missed time slots when miners wait for times that should have already passed
   - Block production delays during critical blockchain initialization
   - Improper round progression in the first round
3. **Consensus State Inconsistency**: The mismatch between expected mining times (from round generation) and arranged mining times (from command strategy) creates inconsistent views of when miners should produce blocks

**Who Is Affected:**
- All AELf blockchains at initialization (every first round)
- All miners except the first one (Orders 2 through MinersCount)
- Severity increases for networks with higher miner counts

**Severity Justification:**
While this doesn't directly cause fund loss, it violates the critical invariant of "correct round transitions and time-slot validation" and "miner schedule integrity" for the first round of every blockchain instance, representing a High severity consensus logic flaw.

### Likelihood Explanation
**Certainty: 100%**
- This code path is **automatically triggered** during the first round of every blockchain initialization
- The vulnerability is in production code with no guards or alternative paths
- Entry point is through the standard consensus command generation flow: [5](#0-4) 

**Attack Complexity: None (Automatic)**
- No attacker action required - the bug manifests automatically
- Affects all miners except Order 1 in every first round
- Cannot be avoided without code fix

**Preconditions:**
- Round number == 1 (guaranteed at blockchain start)
- Behavior == UpdateValue (standard block production)
- Order > 1 (affects all non-first miners)

**Operational Detection:**
The bug may manifest as timing anomalies during blockchain initialization but could be attributed to network delays or other factors, making it difficult to detect in production without specific monitoring of the offset calculations.

### Recommendation
**Code-Level Fix:**

Change line 37 in FirstRoundCommandStrategy.cs from:
```csharp
: Order.Add(MinersCount).Sub(1).Mul(miningInterval);
```

To:
```csharp
: Order.Mul(miningInterval);
```

This aligns the offset calculation with the first round generation logic, ensuring miners are scheduled at their correct time slots: `Order * miningInterval`.

**Invariant Check:**
Add validation that the calculated ArrangedMiningTime for any miner in the first round must be within the round boundary:
```csharp
var roundEndTime = CurrentBlockTime.AddMilliseconds((MinersCount + 1).Mul(miningInterval));
Assert(arrangedMiningTime < roundEndTime, "Mining time exceeds round boundary");
```

**Test Cases to Add:**
1. Test that verifies each miner's ArrangedMiningTime matches their ExpectedMiningTime from round generation
2. Test that the last miner's scheduled time is within the round boundary
3. Test that the offset for Order N equals `N * miningInterval` (not `(N + MinersCount - 1) * miningInterval`)
4. Update the existing test at ACS4ImplTest.cs line 135-138 to expect the corrected time rather than the buggy behavior

### Proof of Concept
**Initial State:**
- First round of a new blockchain with MinersCount = 5
- MiningInterval = 4000 milliseconds
- BlockchainStartTimestamp = T

**Round Generation (Correct Behavior):**
From MinerListExtensions.GenerateFirstRoundOfNewTerm:
- Miner Order 1: ExpectedMiningTime = T + 4000 ms (1 * interval)
- Miner Order 2: ExpectedMiningTime = T + 8000 ms (2 * interval)
- Miner Order 3: ExpectedMiningTime = T + 12000 ms (3 * interval)
- Miner Order 4: ExpectedMiningTime = T + 16000 ms (4 * interval)
- Miner Order 5: ExpectedMiningTime = T + 20000 ms (5 * interval)
- Round ends at: T + 24000 ms (6 * interval)

**Consensus Command Scheduling (Buggy Behavior):**
From FirstRoundCommandStrategy.GetAEDPoSConsensusCommand for UpdateValue behavior:
- Miner Order 1: ArrangedMiningTime = T + 4000 ms (special case: just miningInterval) ✓ CORRECT
- Miner Order 2: ArrangedMiningTime = T + 24000 ms ((2+5-1) * 4000 = 6 * interval) ✗ WRONG - should be 8000 ms
- Miner Order 3: ArrangedMiningTime = T + 28000 ms ((3+5-1) * 4000 = 7 * interval) ✗ WRONG - should be 12000 ms
- Miner Order 4: ArrangedMiningTime = T + 32000 ms ((4+5-1) * 4000 = 8 * interval) ✗ WRONG - should be 16000 ms
- Miner Order 5: ArrangedMiningTime = T + 36000 ms ((5+5-1) * 4000 = 9 * interval) ✗ **BEYOND ROUND BOUNDARY** - should be 20000 ms

**Expected vs Actual:**
- Expected: Last miner at 20000 ms, within round boundary of 24000 ms
- Actual: Last miner at 36000 ms, exceeding round boundary by 12000 ms (3 intervals)

**Success Condition for Exploit:**
The vulnerability manifests automatically - no explicit exploit needed. The consensus system itself will attempt to schedule miners at incorrect times during first round initialization.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/FirstRoundCommandStrategy.cs (L34-37)
```csharp
            var offset =
                _consensusBehaviour == AElfConsensusBehaviour.UpdateValue && Order == 1
                    ? miningInterval
                    : Order.Add(MinersCount).Sub(1).Mul(miningInterval);
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Extensions/MinerListExtensions.cs (L31-33)
```csharp
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i * miningInterval + miningInterval).ToTimestamp();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L60-73)
```csharp
    /// <summary>
    ///     In current AElf Consensus design, each miner produce his block in one time slot, then the extra block producer
    ///     produce a block to terminate current round and confirm the mining order of next round.
    ///     So totally, the time of one round is:
    ///     MiningInterval * MinersCount + MiningInterval.
    /// </summary>
    /// <param name="miningInterval"></param>
    /// <returns></returns>
    public int TotalMilliseconds(int miningInterval = 0)
    {
        if (miningInterval == 0) miningInterval = GetMiningInterval();

        return RealTimeMinersInformation.Count * miningInterval + miningInterval;
    }
```

**File:** test/AElf.Contracts.Consensus.AEDPoS.Tests/BVT/ACS4ImplTest.cs (L135-138)
```csharp
        consensusCommand.ArrangedMiningTime.ShouldBe(blockchainStartTimestamp + new Duration
        {
            Seconds = AEDPoSContractTestConstants.MiningInterval.Mul(7).Div(1000)
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusCommand.cs (L28-30)
```csharp
        if (currentRound.RoundNumber == 1 && behaviour == AElfConsensusBehaviour.UpdateValue)
            return new ConsensusCommandProvider(new FirstRoundCommandStrategy(currentRound, pubkey,
                currentBlockTime, behaviour)).GetConsensusCommand();
```
