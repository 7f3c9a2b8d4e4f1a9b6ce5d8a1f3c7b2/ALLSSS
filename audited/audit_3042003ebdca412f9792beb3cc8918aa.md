### Title
Scheme Overwriting Causes Permanent Token Lock Due to Symbol Mismatch

### Summary
When a manager calls `CreateScheme` multiple times, the new scheme overwrites the previous one but existing user lock records persist with the old scheme's token symbol. Users cannot withdraw their locked tokens because the `Withdraw` function queries locked amounts using the new scheme's symbol with the old lock ID, returning zero balance and leaving original tokens permanently locked.

### Finding Description

**Code Locations:** [1](#0-0) [2](#0-1) [3](#0-2) 

**Root Cause:**

The `CreateScheme` method directly overwrites the scheme stored at `State.TokenHolderProfitSchemes[Context.Sender]` without any validation preventing duplicate calls or checking for existing registrations. [4](#0-3) 

The lock ID is generated deterministically based only on the manager address and user address, making it identical across different schemes with the same manager. [5](#0-4) 

During registration, tokens are locked with the scheme's symbol at that time, and the lock ID mapping persists at `State.LockIds[manager][user]`. [6](#0-5) 

**Why Protections Fail:**

The `Withdraw` function retrieves the current scheme (which may be different from when the user registered), then attempts to get the locked amount using the current scheme's symbol with the old lock ID. [7](#0-6) 

Since `GetLockedAmount` queries the balance for a specific symbol at a virtual address, and the tokens were locked under a different symbol, it returns zero. [8](#0-7) 

The unlock operation then unlocks zero tokens with the new symbol, leaving the original tokens locked forever. [9](#0-8) 

### Impact Explanation

**Direct Fund Impact:**
- Users lose access to all their locked tokens permanently
- No recovery mechanism exists as `State.LockIds[manager][user]` persists, blocking re-registration
- The only unlock path (Withdraw method) is broken due to the symbol mismatch

**Affected Parties:**
- All users who registered for the original scheme before it was overwritten
- Each user loses their entire locked token amount (can be substantial for staking schemes)

**Severity Justification:**
This is HIGH severity because:
1. Results in permanent, unrecoverable loss of user funds
2. Can affect multiple users simultaneously if manager updates scheme
3. No administrative recovery path available
4. User has no way to detect or prevent this before funds are locked

### Likelihood Explanation

**Reachable Entry Point:**
The `CreateScheme` method is publicly accessible to any address that wants to become a scheme manager. [10](#0-9) 

**Feasible Preconditions:**
- Manager needs to call `CreateScheme` twice (first time to create, second time to overwrite)
- This can happen accidentally (manager updating scheme parameters) or maliciously
- No special privileges beyond being the scheme creator are required

**Execution Practicality:**
1. Manager calls `CreateScheme` with symbol "ELF", minLockMinutes 1000
2. User calls `RegisterForProfits` and locks 10,000 ELF tokens
3. Manager calls `CreateScheme` again with symbol "USDT", minLockMinutes 10
4. User calls `Withdraw` but receives 0 tokens, original ELF remains locked

**Attack Complexity:**
Low - requires only two standard contract calls by the manager with no complex state manipulation.

**Economic Rationality:**
- Accidental scenario: Manager innocently updates scheme without realizing the impact
- Malicious scenario: Manager locks user funds to prevent withdrawals, gaining time advantage in profit distribution

### Recommendation

**Code-Level Mitigation:**

1. Add validation in `CreateScheme` to prevent overwriting existing schemes:
```
Assert(State.TokenHolderProfitSchemes[Context.Sender] == null, "Scheme already exists for this manager.");
```

2. Alternatively, store the original scheme symbol in `LockIds` state structure: [11](#0-10) 

Change to: `MappedState<Address, Address, TokenLockInfo>` where `TokenLockInfo` contains both lock ID and symbol.

3. In `Withdraw`, use the stored symbol rather than the current scheme's symbol: [12](#0-11) 

**Invariant Checks:**
- Enforce one-scheme-per-manager invariant
- Validate symbol consistency between lock and unlock operations
- Verify lock ID corresponds to expected scheme before unlocking

**Test Cases:**
- Test that `CreateScheme` reverts when called twice by same manager
- Test that registered users can successfully withdraw after manager attempts to overwrite scheme
- Test symbol mismatch scenarios explicitly fail with clear error messages

### Proof of Concept

**Initial State:**
- Manager address: `ManagerA`
- User address: `UserB`
- TokenHolder contract deployed and initialized

**Transaction Sequence:**

1. `ManagerA` calls `CreateScheme({symbol: "ELF", minimum_lock_minutes: 1000, auto_distribute_threshold: {}})`
   - Creates profit scheme in Profit contract
   - Stores scheme with symbol="ELF" at `State.TokenHolderProfitSchemes[ManagerA]`

2. `UserB` calls `RegisterForProfits({scheme_manager: ManagerA, amount: 10000})`
   - Generates lockId from (TokenHolder contract, ManagerA, UserB)
   - Locks 10,000 ELF tokens with lockId
   - Stores `State.LockIds[ManagerA][UserB] = lockId`
   - UserB's ELF balance: 0, Locked: 10,000 ELF

3. `ManagerA` calls `CreateScheme({symbol: "USDT", minimum_lock_minutes: 10, auto_distribute_threshold: {}})`
   - Creates new profit scheme in Profit contract
   - **OVERWRITES** `State.TokenHolderProfitSchemes[ManagerA]` with symbol="USDT"
   - `State.LockIds[ManagerA][UserB]` still contains old lockId

4. `UserB` calls `Withdraw(ManagerA)` after minimum lock time
   - Retrieves scheme: symbol="USDT", minLockMinutes=10
   - Retrieves lockId: original lockId from step 2
   - Calls `GetLockedAmount(UserB, lockId, "USDT")` → Returns 0 (tokens locked as "ELF", not "USDT")
   - Calls `Unlock(UserB, lockId, 0, "USDT")` → Unlocks 0 USDT
   - UserB's ELF balance: 0, Locked: 10,000 ELF (unchanged)

**Expected Result:**
UserB should be able to withdraw 10,000 ELF tokens.

**Actual Result:**
UserB withdraws 0 tokens. The 10,000 ELF tokens remain permanently locked with no recovery mechanism.

**Success Condition:**
- UserB's locked ELF balance remains 10,000 after withdrawal attempt
- UserB cannot re-register due to existing `LockIds` entry
- No method exists to unlock the original ELF tokens

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L14-35)
```csharp
    public override Empty CreateScheme(CreateTokenHolderProfitSchemeInput input)
    {
        if (State.ProfitContract.Value == null)
            State.ProfitContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);

        State.ProfitContract.CreateScheme.Send(new CreateSchemeInput
        {
            Manager = Context.Sender,
            IsReleaseAllBalanceEveryTimeByDefault = true,
            CanRemoveBeneficiaryDirectly = true
        });

        State.TokenHolderProfitSchemes[Context.Sender] = new TokenHolderProfitScheme
        {
            Symbol = input.Symbol,
            MinimumLockMinutes = input.MinimumLockMinutes,
            AutoDistributeThreshold = { input.AutoDistributeThreshold }
        };

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L149-177)
```csharp
    public override Empty RegisterForProfits(RegisterForProfitsInput input)
    {
        Assert(State.LockIds[input.SchemeManager][Context.Sender] == null, "Already registered.");
        var scheme = GetValidScheme(input.SchemeManager);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = Context.GenerateId(Context.Self,
            ByteArrayHelper.ConcatArrays(input.SchemeManager.ToByteArray(), Context.Sender.ToByteArray()));
        State.TokenContract.Lock.Send(new LockInput
        {
            LockId = lockId,
            Symbol = scheme.Symbol,
            Address = Context.Sender,
            Amount = input.Amount
        });
        State.LockIds[input.SchemeManager][Context.Sender] = lockId;
        State.LockTimestamp[lockId] = Context.CurrentBlockTime;
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = input.Amount
            }
        });

```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract.cs (L211-245)
```csharp
    public override Empty Withdraw(Address input)
    {
        var scheme = GetValidScheme(input);
        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        var lockId = State.LockIds[input][Context.Sender];
        Assert(lockId != null, "Sender didn't register for profits.");
        var amount = State.TokenContract.GetLockedAmount.Call(new GetLockedAmountInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Symbol = scheme.Symbol
        }).Amount;

        Assert(State.LockTimestamp[lockId].AddMinutes(scheme.MinimumLockMinutes) < Context.CurrentBlockTime,
            "Cannot withdraw.");

        State.TokenContract.Unlock.Send(new UnlockInput
        {
            Address = Context.Sender,
            LockId = lockId,
            Amount = amount,
            Symbol = scheme.Symbol
        });

        State.LockIds[input].Remove(Context.Sender);
        State.ProfitContract.RemoveBeneficiary.Send(new RemoveBeneficiaryInput
        {
            SchemeId = scheme.SchemeId,
            Beneficiary = Context.Sender
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L101-115)
```csharp
    public override GetLockedAmountOutput GetLockedAmount(GetLockedAmountInput input)
    {
        Assert(input.LockId != null, "Lock id cannot be null.");
        var virtualAddress = GetVirtualAddressForLocking(new GetVirtualAddressForLockingInput
        {
            Address = input.Address,
            LockId = input.LockId
        });
        return new GetLockedAmountOutput
        {
            Symbol = input.Symbol,
            Address = input.Address,
            LockId = input.LockId,
            Amount = GetBalance(virtualAddress, input.Symbol)
        };
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContractState.cs (L12-15)
```csharp
    /// <summary>
    ///     Contract address (Manager address) -> Beneficiary address -> Lock id.
    /// </summary>
    public MappedState<Address, Address, Hash> LockIds { get; set; }
```
