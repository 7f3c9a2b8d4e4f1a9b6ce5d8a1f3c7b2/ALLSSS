# Audit Report

## Title
Duplicate FinalOrderOfNextRound Assignment Causes Consensus Failure Due to Incomplete Conflict Resolution

## Summary
The `ApplyNormalConsensusData` function's conflict resolution mechanism fails when all mining order positions are occupied, allowing duplicate `FinalOrderOfNextRound` values to be assigned to different miners. This violates the critical consensus invariant that each miner must have a unique next-round order, resulting in non-deterministic miner ordering across nodes and consensus failure.

## Finding Description

The vulnerability exists in the conflict resolution logic within the `ApplyNormalConsensusData` method. [1](#0-0)  When a miner produces a block, their `supposedOrderOfNextRound` is calculated from the signature hash.

If this value conflicts with another miner's existing `FinalOrderOfNextRound`, [2](#0-1)  the conflict resolution loop attempts to reassign the conflicted miner to a free position. [3](#0-2) 

**Critical Flaw:** The loop checks if any miner currently occupies each candidate position. [4](#0-3)  When all positions (1 through `minersCount`) are occupied by distinct miners, the loop exhausts all candidates without finding a free position. The conflicted miner retains their original value, and then the current miner is unconditionally assigned the same value, [5](#0-4)  creating duplicates.

**Why Existing Protections Fail:** The validation provider has a critical bug. [6](#0-5)  It calls `.Distinct()` on `MinerInRound` objects rather than on their `FinalOrderOfNextRound` values, checking for duplicate miner objects (impossible) instead of duplicate order values. The validation always passes even when duplicates exist.

## Impact Explanation

**Consensus Integrity Breach:** When generating the next round, miners are ordered by `FinalOrderOfNextRound`. [7](#0-6) 

With duplicate values, the ordering becomes non-deterministic because `RealTimeMinersInformation` is a dictionary whose iteration order is not guaranteed across different nodes. When two miners share the same `FinalOrderOfNextRound`, different nodes may iterate them in different orders, causing `OrderBy` to produce inconsistent results.

Additionally, the logic for assigning orders to miners who didn't produce blocks depends on unique `FinalOrderOfNextRound` values. [8](#0-7)  If duplicates exist, `ableOrders` will have fewer elements than needed, causing an `IndexOutOfBoundsException` when accessed.

**Concrete Harm:**
- **Blockchain Fork Risk**: Nodes disagree on miner ordering for the next round
- **Deterministic Failure**: IndexOutOfBoundsException when generating next round with miners who missed blocks
- **Network Partition**: Nodes cannot reach consensus on block production schedule
- **Complete System Halt**: Blockchain cannot proceed to next round

## Likelihood Explanation

**Trigger Path:** This vulnerability is triggered during normal block production when a miner produces an `UpdateValue` block. [9](#0-8)  The function `GetConsensusExtraDataToPublishOutValue` calls `ApplyNormalConsensusData`. [10](#0-9) 

**Preconditions:**
1. All `minersCount` positions (1 through N) are occupied by distinct miners with set `FinalOrderOfNextRound` values
2. A miner produces a block whose signature hash modulo `minersCount` conflicts with an existing position
3. Occurs naturally after the first round when all miners have produced blocks

**Probability:** With N miners and uniformly distributed signature hashes, collision probability is approximately 1/N per block. For N=21 miners (typical AElf configuration), conflicts occur frequently within a few rounds due to the birthday paradox. No malicious action is requiredâ€”this happens during normal operations.

## Recommendation

**Fix 1: Exclude Conflicted Miner from Position Check**
Modify the conflict resolution loop to exclude the conflicted miner when checking if a position is free:

```csharp
if (RealTimeMinersInformation.Values.All(m => 
    m.Pubkey == orderConflictedMiner.Pubkey || 
    m.FinalOrderOfNextRound != maybeNewOrder))
```

**Fix 2: Correct the Validation Provider**
Fix the validation to check for duplicate `FinalOrderOfNextRound` values:

```csharp
var distinctCount = providedRound.RealTimeMinersInformation.Values
    .Where(m => m.FinalOrderOfNextRound > 0)
    .Select(m => m.FinalOrderOfNextRound)
    .Distinct()
    .Count();
```

**Fix 3: Add Explicit Duplicate Check**
After assigning `FinalOrderOfNextRound`, verify no duplicates exist:

```csharp
var finalOrders = RealTimeMinersInformation.Values
    .Select(m => m.FinalOrderOfNextRound)
    .Where(o => o > 0)
    .ToList();
Assert(finalOrders.Count == finalOrders.Distinct().Count(), 
    "Duplicate FinalOrderOfNextRound detected");
```

## Proof of Concept

```csharp
[Fact]
public void Test_DuplicateFinalOrderOfNextRound_WhenAllPositionsOccupied()
{
    // Setup: Create a round with 3 miners, all positions occupied
    var round = new Round
    {
        RoundNumber = 1,
        RealTimeMinersInformation = new Dictionary<string, MinerInRound>
        {
            ["MinerA"] = new MinerInRound { Pubkey = "MinerA", FinalOrderOfNextRound = 1 },
            ["MinerB"] = new MinerInRound { Pubkey = "MinerB", FinalOrderOfNextRound = 2 },
            ["MinerC"] = new MinerInRound { Pubkey = "MinerC", FinalOrderOfNextRound = 3 }
        }
    };

    // MinerA produces another block with signature that hashes to position 2 (conflicts with MinerB)
    var signature = Hash.FromString("signature_that_produces_order_2");
    var outValue = Hash.FromString("out_value");
    var previousInValue = Hash.FromString("previous_in_value");

    // Apply consensus data
    var updatedRound = round.ApplyNormalConsensusData("MinerA", previousInValue, outValue, signature);

    // Bug: Both MinerA and MinerB now have FinalOrderOfNextRound = 2
    var minerAOrder = updatedRound.RealTimeMinersInformation["MinerA"].FinalOrderOfNextRound;
    var minerBOrder = updatedRound.RealTimeMinersInformation["MinerB"].FinalOrderOfNextRound;
    
    Assert.Equal(2, minerAOrder);
    Assert.Equal(2, minerBOrder); // DUPLICATE - Consensus invariant violated
    
    // Validation provider fails to detect this
    var validationProvider = new NextRoundMiningOrderValidationProvider();
    var context = new ConsensusValidationContext { ProvidedRound = updatedRound };
    var result = validationProvider.ValidateHeaderInformation(context);
    
    Assert.True(result.Success); // Bug: Validation incorrectly passes with duplicates present
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L21-21)
```csharp
        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L25-26)
```csharp
        var conflicts = RealTimeMinersInformation.Values
            .Where(i => i.FinalOrderOfNextRound == supposedOrderOfNextRound).ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L28-40)
```csharp
        foreach (var orderConflictedMiner in conflicts)
            // Multiple conflicts is unlikely.

            for (var i = supposedOrderOfNextRound + 1; i < minersCount * 2; i++)
            {
                var maybeNewOrder = i > minersCount ? i % minersCount : i;
                if (RealTimeMinersInformation.Values.All(m => m.FinalOrderOfNextRound != maybeNewOrder))
                {
                    RealTimeMinersInformation[orderConflictedMiner.Pubkey].FinalOrderOfNextRound =
                        maybeNewOrder;
                    break;
                }
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L15-16)
```csharp
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-28)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L40-44)
```csharp
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L28-30)
```csharp
            case AElfConsensusBehaviour.UpdateValue:
                information = GetConsensusExtraDataToPublishOutValue(currentRound, pubkey,
                    triggerInformation);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```
