# Audit Report

## Title
Incomplete Evil Miner Replacement Due to Insufficient Alternative Candidates

## Summary
The AEDPoS consensus contract's miner replacement mechanism contains a critical logic flaw where the replacement loop only iterates for the count of available alternative candidates, not the count of evil miners requiring replacement. When the Election contract returns fewer alternatives than evil miners (due to depleted candidate pools), unreplaced evil miners remain in the active consensus round, degrading network liveness and block production capacity.

## Finding Description

The vulnerability exists in the interaction between the Election and Consensus contracts during mid-term evil miner replacement.

**Evil Miner Detection**: The system identifies evil miners as those who have missed at least 4320 time slots (3 days at 1 slot/minute). [1](#0-0) 

The detection logic filters miners based on this threshold: [2](#0-1) 

**Replacement Candidate Selection**: The Election contract's `GetMinerReplacementInformation` attempts to find replacements from two sources - election snapshot candidates (excluding initial and current miners) and initial miners as fallback. [3](#0-2) 

The function returns `MinerReplacementInformation` containing two lists: `EvilMinerPubkeys` (all banned miners) and `AlternativeCandidatePubkeys` (available replacements). Critically, these lists can have different counts when candidate pools are exhausted. [4](#0-3) 

**The Vulnerability**: In the consensus contract's `GenerateNextRoundInformation` method, the replacement loop only iterates `AlternativeCandidatePubkeys.Count` times: [5](#0-4) 

If `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, only the first N evil miners (where N equals the alternative count) are removed from `currentRound.RealTimeMinersInformation`. The remaining evil miners persist in the dictionary and are carried forward to the next round via `Round.GenerateNextRoundInformation`. [6](#0-5) 

This breaks the consensus invariant that all scheduled miners must be capable of producing blocks.

## Impact Explanation

**Consensus Integrity Degradation**: Unreplaced evil miners remain in the active miner schedule but cannot produce blocks. In a typical 21-miner AEDPoS network, if 10 miners become evil but only 3 get replaced, 7 unreliable miners occupy consensus slots. This represents a ~33% reduction in effective block production capacity, causing:
- Increased block times (network waits for evil miners who won't respond)
- Potential consensus stalls if too many time slots are wasted
- Degraded transaction throughput affecting all users

**Network Liveness Risk**: With sufficient unreplaced evil miners, the network may fail to meet the 2/3+ threshold needed for block finalization in BFT-style consensus. This creates an operational denial-of-service condition where the blockchain cannot process transactions or advance state.

**Affected Parties**: All network participants including validators, end users, dApps, treasury operations, profit distributions, and cross-chain indexing mechanisms that depend on stable consensus.

**Severity Assessment**: HIGH - This directly compromises the core consensus mechanism's integrity. While no funds are immediately stolen, the network's ability to function is severely impaired, potentially leading to complete service disruption.

## Likelihood Explanation

**Trigger Conditions**: The vulnerability activates under realistic network stress scenarios:
1. Multiple miners simultaneously fail or go offline for 3+ days (infrastructure outages, coordinated attacks, or natural disasters)
2. The election candidate pool becomes depleted because most eligible candidates are already serving as miners or have been previously banned
3. The initial miner fallback list is exhausted

**Feasibility**: MEDIUM-HIGH probability because:
- The condition occurs automatically without requiring attacker privileges
- Mature blockchain networks naturally develop stable miner sets, reducing the available candidate pool over time
- Infrastructure failures affecting multiple data centers can cause simultaneous miner outages
- An adversary could accelerate the condition through sustained DDoS attacks against active miners

**Detection Difficulty**: The degradation is observable through monitoring but may not trigger immediate alarms since the network continues operating at reduced capacity rather than failing completely. This subtle degradation can persist unnoticed until it reaches critical thresholds.

## Recommendation

Modify the replacement loop to handle all evil miners, even when alternatives are insufficient. When `AlternativeCandidatePubkeys.Count < EvilMinerPubkeys.Count`, the system should:

1. **Immediate Fix**: Change the loop to iterate through all evil miners and forcibly remove those without replacements:
```csharp
// Replace available alternatives
for (var i = 0; i < Math.Min(minerReplacementInformation.AlternativeCandidatePubkeys.Count, 
                               minerReplacementInformation.EvilMinerPubkeys.Count); i++)
{
    // existing replacement logic
}

// Remove remaining evil miners without replacements
for (var i = minerReplacementInformation.AlternativeCandidatePubkeys.Count; 
     i < minerReplacementInformation.EvilMinerPubkeys.Count; i++)
{
    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];
    UpdateCandidateInformation(evilMinerPubkey, 
        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
}
```

2. **Long-term Enhancement**: Implement emergency governance mechanisms to quickly inject new candidates when the pool becomes critically low, or trigger a term change to force a fresh election when too many evil miners exist without replacements.

## Proof of Concept

```csharp
[Fact]
public async Task Test_IncompleteEvilMinerReplacement()
{
    // Setup: Initialize network with 21 miners
    var initialMiners = GenerateMiners(21);
    await InitializeConsensusWithMiners(initialMiners);
    
    // Simulate 10 miners becoming evil (missed >= 4320 time slots)
    var evilMiners = initialMiners.Take(10).ToList();
    await SimulateMissedTimeSlots(evilMiners, 4320);
    
    // Setup election contract with only 3 available alternative candidates
    var alternatives = GenerateCandidates(3);
    await RegisterCandidates(alternatives);
    
    // Trigger round generation (which calls GetMinerReplacementInformation)
    var result = await ConsensusContract.GenerateNextRoundInformation(currentRound);
    
    // Verify the vulnerability:
    // 1. Only 3 evil miners were replaced
    var replacedCount = result.ReplacedMiners.Count;
    replacedCount.ShouldBe(3); // Only alternatives.Count, not evilMiners.Count
    
    // 2. 7 evil miners remain in the active miner set
    var remainingEvilMiners = evilMiners.Skip(3)
        .Count(evil => result.CurrentRound.RealTimeMinersInformation.ContainsKey(evil));
    remainingEvilMiners.ShouldBe(7); // Unreplaced evil miners persist
    
    // 3. These 7 evil miners are scheduled but won't produce blocks
    // causing ~33% reduction in consensus capacity (7/21)
    var scheduledButInactiveCount = result.CurrentRound.RealTimeMinersInformation
        .Count(m => evilMiners.Contains(m.Key) && !alternatives.Contains(m.Key));
    scheduledButInactiveCount.ShouldBe(7);
    
    // Impact: Network continues with degraded capacity instead of clean state
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Gradual Degradation**: The network doesn't fail catastrophically but operates at progressively reduced capacity, making the issue harder to detect and diagnose.

2. **Compounding Effect**: As more miners become evil over time without full replacement, the problem accumulates, eventually reaching critical mass where consensus may stall completely.

3. **Term Boundary Reset**: The issue self-corrects at term changes when a fresh election occurs, but within-term rounds perpetuate the problem, potentially lasting weeks depending on term duration.

4. **Economic Disincentives**: The unreplaced evil miners continue occupying consensus slots without producing value, creating economic inefficiency and potentially discouraging new candidates from joining due to perceived network instability.

The core issue is the assumption that `AlternativeCandidatePubkeys.Count` always equals `EvilMinerPubkeys.Count`, which breaks under resource exhaustion scenarios that are increasingly likely in mature blockchain networks.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L11-11)
```csharp
    public const long TolerableMissedTimeSlotsCount = 60 * 24 * 3; // one time slot per minute and last 3 days.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L177-183)
```csharp
    public bool TryToDetectEvilMiners(out List<string> evilMiners)
    {
        evilMiners = RealTimeMinersInformation.Values
            .Where(m => m.MissedTimeSlots >= AEDPoSContractConstants.TolerableMissedTimeSlotsCount)
            .Select(m => m.Pubkey).ToList();
        return evilMiners.Count > 0;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L357-399)
```csharp
    public override MinerReplacementInformation GetMinerReplacementInformation(
        GetMinerReplacementInformationInput input)
    {
        var evilMinersPubKeys = GetEvilMinersPubkeys(input.CurrentMinerList);
        Context.LogDebug(() => $"Got {evilMinersPubKeys.Count} evil miners pubkeys from {input.CurrentMinerList}");
        var alternativeCandidates = new List<string>();
        var latestSnapshot = GetPreviousTermSnapshotWithNewestPubkey();
        // Check out election snapshot.
        if (latestSnapshot != null && latestSnapshot.ElectionResult.Any())
        {
            Context.LogDebug(() => $"Previous term snapshot:\n{latestSnapshot}");
            var maybeNextCandidates = latestSnapshot.ElectionResult
                // Except initial miners.
                .Where(cs =>
                    !State.InitialMiners.Value.Value.Contains(
                        ByteString.CopyFrom(ByteArrayHelper.HexStringToByteArray(cs.Key))))
                // Except current miners.
                .Where(cs => !input.CurrentMinerList.Contains(cs.Key))
                .OrderByDescending(s => s.Value).ToList();
            var take = Math.Min(evilMinersPubKeys.Count, maybeNextCandidates.Count);
            alternativeCandidates.AddRange(maybeNextCandidates.Select(c => c.Key).Take(take));
            Context.LogDebug(() =>
                $"Found alternative miner from candidate list: {alternativeCandidates.Aggregate("\n", (key1, key2) => key1 + "\n" + key2)}");
        }

        // If the count of evil miners is greater than alternative candidates, add some initial miners to alternative candidates.
        var diff = evilMinersPubKeys.Count - alternativeCandidates.Count;
        if (diff > 0)
        {
            var takeAmount = Math.Min(diff, State.InitialMiners.Value.Value.Count);
            var selectedInitialMiners = State.InitialMiners.Value.Value
                .Select(k => k.ToHex())
                .Where(k => !State.BannedPubkeyMap[k])
                .Where(k => !input.CurrentMinerList.Contains(k)).Take(takeAmount);
            alternativeCandidates.AddRange(selectedInitialMiners);
        }

        return new MinerReplacementInformation
        {
            EvilMinerPubkeys = { evilMinersPubKeys },
            AlternativeCandidatePubkeys = { alternativeCandidates }
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L311-339)
```csharp
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);

                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });

                    // Transfer evil node's consensus information to the chosen backup.
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L11-56)
```csharp
    public void GenerateNextRoundInformation(Timestamp currentBlockTimestamp, Timestamp blockchainStartTimestamp,
        out Round nextRound, bool isMinerListChanged = false)
    {
        nextRound = new Round { IsMinerListJustChanged = isMinerListChanged };

        var minersMinedCurrentRound = GetMinedMiners();
        var minersNotMinedCurrentRound = GetNotMinedMiners();
        var minersCount = RealTimeMinersInformation.Count;

        var miningInterval = GetMiningInterval();
        nextRound.RoundNumber = RoundNumber + 1;
        nextRound.TermNumber = TermNumber;
        nextRound.BlockchainAge = RoundNumber == 1 ? 1 : (currentBlockTimestamp - blockchainStartTimestamp).Seconds;

        // Set next round miners' information of miners who successfully mined during this round.
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                MissedTimeSlots = minerInRound.MissedTimeSlots
            };
        }

        // Set miners' information of miners missed their time slot in current round.
        var occupiedOrders = minersMinedCurrentRound.Select(m => m.FinalOrderOfNextRound).ToList();
        var ableOrders = Enumerable.Range(1, minersCount).Where(i => !occupiedOrders.Contains(i)).ToList();
        for (var i = 0; i < minersNotMinedCurrentRound.Count; i++)
        {
            var order = ableOrders[i];
            var minerInRound = minersNotMinedCurrentRound[i];
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minersNotMinedCurrentRound[i].Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp
                    .AddMilliseconds(miningInterval.Mul(order)),
                ProducedBlocks = minerInRound.ProducedBlocks,
                // Update missed time slots count of one miner.
                MissedTimeSlots = minerInRound.MissedTimeSlots.Add(1)
            };
        }
```
