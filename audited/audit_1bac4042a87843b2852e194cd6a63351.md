### Title
CachedDelayTotalShares Arithmetic Underflow in RemoveBeneficiary Causes DoS and Accounting Corruption

### Summary
The `RemoveBeneficiary` function contains a critical arithmetic underflow vulnerability where beneficiaries added between profit distributions can cause the cached delay total shares to become negative when removed, triggering an OverflowException. This prevents legitimate beneficiary removal operations, locks allocated funds, and corrupts the scheme's share accounting for future distributions.

### Finding Description

**Location**: [1](#0-0) 

**Root Cause**: The `CachedDelayTotalShares` dictionary is populated only during `DistributeProfits` operations to cache historical total shares for delayed distributions [2](#0-1) . However, when `AddBeneficiary` is called, it increases `TotalShares` but does NOT update any cached values [3](#0-2) . This creates a state inconsistency where the cache becomes stale.

When `RemoveBeneficiary` is subsequently called, it attempts to subtract the removed shares from cached period totals. The subtraction operation uses the checked `Sub()` method [4](#0-3)  which throws an OverflowException on underflow. If a beneficiary added after the cache was set is removed before that cached period is consumed, the subtraction attempts to remove more shares than the cached value contains, triggering the exception.

**Why Protections Fail**: The code only checks if the key exists in `CachedDelayTotalShares` [5](#0-4)  but does not validate whether the cached value is sufficient to subtract the removed shares. The checked arithmetic protection, while preventing silent corruption, converts the issue into a Denial of Service.

### Impact Explanation

**Concrete Harm**:
1. **Operational DoS**: Any attempt to remove beneficiaries added between distributions will revert with OverflowException, permanently preventing legitimate scheme management operations
2. **Fund Locking**: Funds allocated to beneficiaries that cannot be removed remain locked in the scheme, as the beneficiary cannot be removed and their shares cannot be recovered
3. **Accounting Corruption**: The scheme's `TotalShares` remains inflated even though the beneficiary should be removable, causing incorrect profit calculations in all future distributions
4. **Distribution Inaccuracy**: Future distributions will use incorrect cached total shares, leading to misallocation of profits among remaining beneficiaries

**Severity**: Critical - This vulnerability directly impacts the economics invariant requiring accurate share calculations and dividend distribution. It can be triggered during normal operations without requiring attacker-controlled conditions, affecting any profit scheme using delayed distributions.

### Likelihood Explanation

**Realistic Exploitability**:
- **Entry Point**: Public `RemoveBeneficiary` function callable by scheme manager or TokenHolder contract [6](#0-5) 
- **Preconditions**: Scheme must have `DelayDistributePeriodCount > 0` and `CanRemoveBeneficiaryDirectly = true`, which are valid configuration options
- **Attack Complexity**: LOW - No special attacker capabilities required. Occurs naturally through legitimate operations: distribute profits → add beneficiary → remove beneficiary
- **Probability**: HIGH - This is not an edge case but a fundamental flaw in the update logic that occurs whenever beneficiaries are added between distribution periods

**Normal Operation Scenario** (not attack):
- TokenHolder contract regularly adds/removes staking beneficiaries
- Governance schemes adjust beneficiary allocations
- Economic schemes rebalance rewards

All these can trigger the condition without malicious intent.

### Recommendation

**Code-Level Mitigation**:

1. **Update cache when adding beneficiaries**: In `AddBeneficiary`, iterate through all existing cached periods and add the new shares:
```csharp
// After line 182 in AddBeneficiary
if (scheme.DelayDistributePeriodCount > 0)
{
    foreach (var cachedPeriod in scheme.CachedDelayTotalShares.Keys.ToList())
    {
        scheme.CachedDelayTotalShares[cachedPeriod] = 
            scheme.CachedDelayTotalShares[cachedPeriod].Add(input.BeneficiaryShare.Shares);
    }
}
```

2. **Add defensive validation in RemoveBeneficiary**: Before subtraction, verify sufficient cached shares exist:
```csharp
// Replace lines 253-254
if (scheme.CachedDelayTotalShares[removedPeriod] >= removedShares)
{
    scheme.CachedDelayTotalShares[removedPeriod] = 
        scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
}
else
{
    // Log warning or adjust to zero if cached value insufficient
    scheme.CachedDelayTotalShares[removedPeriod] = 0;
}
```

3. **Add invariant check**: Assert that cached values never go negative and match expected bounds.

**Test Cases**:
- Test adding beneficiary after distribution with delay, then removing before cached period
- Test multiple add/remove cycles with varying delays
- Test boundary conditions where removedShares == cachedShares

### Proof of Concept

**Initial State**:
- Scheme created with `DelayDistributePeriodCount = 3`, `CanRemoveBeneficiaryDirectly = true`
- Existing beneficiary A with 100 shares
- Current period = 0

**Transaction Sequence**:

1. **Period 0 - Distribute**: 
   - Call `DistributeProfits(period=0)` 
   - Result: `CachedDelayTotalShares[3] = 100`, `TotalShares = 100`

2. **Period 1 - Add Beneficiary**:
   - Call `AddBeneficiary(beneficiary=B, shares=200)`
   - Result: `TotalShares = 300`, but `CachedDelayTotalShares[3]` remains `100`

3. **Period 1 - Remove Beneficiary** (trigger vulnerability):
   - Call `RemoveBeneficiary(beneficiary=B)`
   - `RemoveProfitDetails` returns `{1: 200}` [7](#0-6) 
   - Loop executes for periods 1, 2, 3
   - At period 3: attempts `CachedDelayTotalShares[3].Sub(200)` = `100.Sub(200)`
   - **Expected**: Transaction completes, beneficiary removed
   - **Actual**: OverflowException thrown, transaction reverts, beneficiary remains with corrupted state

**Success Condition**: Transaction at step 3 reverts with OverflowException, demonstrating the DoS condition. The scheme is left in an inconsistent state where `TotalShares = 300` but beneficiary B cannot be removed.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L158-215)
```csharp
    public override Empty AddBeneficiary(AddBeneficiaryInput input)
    {
        AssertValidInput(input);
        if (input.EndPeriod == 0)
            // Which means this profit Beneficiary will never expired unless removed.
            input.EndPeriod = long.MaxValue;

        var schemeId = input.SchemeId;
        var scheme = State.SchemeInfos[schemeId];

        Assert(scheme != null, "Scheme not found.");

        // ReSharper disable once PossibleNullReferenceException
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");

        Context.LogDebug(() =>
            $"{input.SchemeId}.\n End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        Assert(input.EndPeriod >= scheme.CurrentPeriod,
            $"Invalid end period. End Period: {input.EndPeriod}, Current Period: {scheme.CurrentPeriod}");

        scheme.TotalShares = scheme.TotalShares.Add(input.BeneficiaryShare.Shares);

        State.SchemeInfos[schemeId] = scheme;

        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);

        // Remove details too old.
        var oldProfitDetails = currentProfitDetails.Details.Where(
            d => d.EndPeriod != long.MaxValue && d.LastProfitPeriod >= d.EndPeriod &&
                 d.EndPeriod.Add(scheme.ProfitReceivingDuePeriodCount) < scheme.CurrentPeriod).ToList();
        foreach (var detail in oldProfitDetails) currentProfitDetails.Details.Remove(detail);

        State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary] = currentProfitDetails;

        Context.LogDebug(() =>
            $"Added {input.BeneficiaryShare.Shares} weights to scheme {input.SchemeId.ToHex()}: {profitDetail}");

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L237-239)
```csharp
        Assert(Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager or token holder contract can add beneficiary.");
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L92-98)
```csharp
    public static long Sub(this long a, long b)
    {
        checked
        {
            return a - b;
        }
    }
```

**File:** contract/AElf.Contracts.Profit/Models/RemovedDetails.cs (L6-19)
```csharp
    public class RemovedDetails : Dictionary<long, long>
    {
        public void TryAdd(long key, long value)
        {
            if (ContainsKey(key))
            {
                this[key] = this[key].Add(value);
            }
            else
            {
                this[key] = value;
            }
        }
    }
```
