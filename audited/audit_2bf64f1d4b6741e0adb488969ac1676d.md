### Title
Invalid MinerInRound Objects Bypass Validation via RoundIdForValidation Manipulation Leading to Consensus Halt

### Summary
A malicious miner can craft a `NextTermInput` with invalid `MinerInRound` objects (Order=0, ExpectedMiningTime=null, Pubkey="") and bypass validation by setting `RoundIdForValidation` to match the current round's RoundId. This causes `TimeSlotValidationProvider` to skip field validation via `CheckRoundTimeSlots()`, allowing corrupt consensus state to be stored, resulting in chain halt when subsequent miners attempt block production.

### Finding Description

The vulnerability exists in the validation flow for `NextTerm` consensus transactions. When a miner produces a block with `NextTerm` behavior, the `NextTermInput.Create()` method copies `RealTimeMinersInformation` directly from a `Round` object without field validation. [1](#0-0) 

The critical flaw is in `TimeSlotValidationProvider.ValidateHeaderInformation()`. It only calls `CheckRoundTimeSlots()` when `ProvidedRound.RoundId != BaseRound.RoundId`: [2](#0-1) 

The `RoundId` property calculation allows manipulation - when `ExpectedMiningTime` is null for any miner, it returns `RoundIdForValidation`: [3](#0-2) 

An attacker can set `RoundIdForValidation` in `NextTermInput` to match the current round's RoundId, causing the validation to skip the critical `CheckRoundTimeSlots()` call that would detect null `ExpectedMiningTime` values: [4](#0-3) 

The `RoundTerminateValidationProvider` only validates round/term number increments and InValue nullity, not MinerInRound field integrity: [5](#0-4) 

Once the invalid round passes validation, `ProcessNextTerm` stores it in state without additional checks: [6](#0-5) 

### Impact Explanation

**Consensus Halt / Complete Chain DoS:**

When the invalid round becomes current state, subsequent miners attempting block production will encounter failures:

1. `GetMiningInterval()` attempts to find miners with Order==1 or Order==2, but with all Order values at 0 (default), it will access invalid array indices or compute incorrect intervals: [7](#0-6) 

2. `FirstMiner()` returns null when no miner has Order==1, causing NullReferenceException when consensus logic accesses `FirstMiner().OutValue`: [8](#0-7) [9](#0-8) 

3. `IsTimeSlotPassed()` depends on valid `ExpectedMiningTime`, causing failures with null values: [10](#0-9) 

**Severity: Critical** - Complete chain halt affecting all users, validators, and dApps. Requires hard fork or manual intervention to recover.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be a valid miner in current or previous round (passes PreCheck): [11](#0-10) 

- Can craft custom consensus extra data and transaction during their time slot
- Controls both block header (consensus extra data) and block body (NextTerm transaction)

**Attack Complexity:** Medium
- Requires understanding of RoundId calculation and validation bypass
- Must coordinate malicious header and transaction data
- Executed during legitimate term transition opportunity

**Feasibility:** High
- NextTermInput is a protobuf message where all fields are attacker-controlled: [12](#0-11) 

- No cryptographic or economic barriers prevent crafting invalid MinerInRound objects
- Attack surface exposed during every term transition (regular occurrence)

**Detection Difficulty:** Low initially (malicious block appears valid), but catastrophic once triggered (chain halts immediately on next mining attempt)

### Recommendation

**1. Add MinerInRound field validation in RoundTerminateValidationProvider:**

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Existing term number check
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // NEW: Validate MinerInRound integrity
    foreach (var miner in extraData.Round.RealTimeMinersInformation.Values)
    {
        if (string.IsNullOrEmpty(miner.Pubkey))
            return new ValidationResult { Message = "Invalid miner pubkey in next term round." };
        if (miner.Order <= 0 || miner.Order > extraData.Round.RealTimeMinersInformation.Count)
            return new ValidationResult { Message = "Invalid miner order in next term round." };
        if (miner.ExpectedMiningTime == null)
            return new ValidationResult { Message = "Invalid miner expected mining time in next term round." };
    }
    
    return new ValidationResult { Success = true };
}
```

**2. Force CheckRoundTimeSlots for NextTerm regardless of RoundId:**

Modify TimeSlotValidationProvider to always validate NextTerm rounds:

```csharp
public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
{
    // Force validation for term transitions
    if (validationContext.ExtraData.Behaviour == AElfConsensusBehaviour.NextTerm ||
        validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
    {
        validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
        if (!validationResult.Success) return validationResult;
    }
    // ... rest of logic
}
```

**3. Add defensive checks in ProcessNextTerm:**

Validate the round before adding to state, ensuring no invalid data persists even if validation is bypassed.

### Proof of Concept

**Initial State:**
- Chain running with valid miners in current term
- Attacker is a valid miner with block production rights during term transition window

**Attack Steps:**

1. **Attacker crafts malicious NextTermInput:**
```
NextTermInput {
  RoundNumber = currentRound.RoundNumber + 1,
  TermNumber = currentRound.TermNumber + 1,
  RealTimeMinersInformation = {
    "miner1_pubkey": MinerInRound { Order=0, ExpectedMiningTime=null, Pubkey="", ... },
    "miner2_pubkey": MinerInRound { Order=0, ExpectedMiningTime=null, Pubkey="", ... },
    ...
  },
  RoundIdForValidation = currentRound.RoundId,  // KEY: Match current round ID
  ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight,
  ... (other fields)
}
```

2. **Create matching consensus extra data in block header with same malicious Round**

3. **Submit block during term transition time slot**

**Expected Result:** Validation should reject block with invalid MinerInRound objects

**Actual Result:**
- TimeSlotValidationProvider sees RoundId match, skips CheckRoundTimeSlots
- RoundTerminateValidationProvider only checks round/term numbers, passes
- ProcessNextTerm stores invalid round in state
- Next miner calls GetConsensusCommand → FirstMiner() returns null → NullReferenceException
- **Chain halts - no more blocks can be produced**

**Success Condition:** Chain unable to produce blocks after attacker's malicious NextTerm block, requiring manual intervention/hard fork to recover.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L7-23)
```csharp
    public static NextTermInput Create(Round round, ByteString randomNumber)
    {
        return new NextTermInput
        {
            RoundNumber = round.RoundNumber,
            RealTimeMinersInformation = { round.RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = round.ExtraBlockProducerOfPreviousRound,
            BlockchainAge = round.BlockchainAge,
            TermNumber = round.TermNumber,
            ConfirmedIrreversibleBlockHeight = round.ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = round.ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = round.IsMinerListJustChanged,
            RoundIdForValidation = round.RoundIdForValidation,
            MainChainMinersRoundNumber = round.MainChainMinersRoundNumber,
            RandomNumber = randomNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/TimeSlotValidationProvider.cs (L13-19)
```csharp
        // If provided round is a new round
        if (validationContext.ProvidedRound.RoundId != validationContext.BaseRound.RoundId)
        {
            // Is new round information fits time slot rule?
            validationResult = validationContext.ProvidedRound.CheckRoundTimeSlots();
            if (!validationResult.Success) return validationResult;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L15-24)
```csharp
    public long RoundId
    {
        get
        {
            if (RealTimeMinersInformation.Values.All(bpInfo => bpInfo.ExpectedMiningTime != null))
                return RealTimeMinersInformation.Values.Select(bpInfo => bpInfo.ExpectedMiningTime.Seconds).Sum();

            return RoundIdForValidation;
        }
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L33-42)
```csharp
    public ValidationResult CheckRoundTimeSlots()
    {
        var miners = RealTimeMinersInformation.Values.OrderBy(m => m.Order).ToList();
        if (miners.Count == 1)
            // No need to check single node.
            return new ValidationResult { Success = true };

        if (miners.Any(m => m.ExpectedMiningTime == null))
            return new ValidationResult { Message = $"Incorrect expected mining time.\n{this}" };

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L70-81)
```csharp
    public int GetMiningInterval()
    {
        if (RealTimeMinersInformation.Count == 1)
            // Just appoint the mining interval for single miner.
            return 4000;

        var firstTwoMiners = RealTimeMinersInformation.Values.Where(m => m.Order == 1 || m.Order == 2)
            .ToList();

        return Math.Abs((int)(firstTwoMiners[1].ExpectedMiningTime - firstTwoMiners[0].ExpectedMiningTime)
            .Milliseconds());
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L83-90)
```csharp
    public bool IsTimeSlotPassed(string publicKey, Timestamp currentBlockTime)
    {
        var miningInterval = GetMiningInterval();
        if (!RealTimeMinersInformation.ContainsKey(publicKey)) return false;
        var minerInRound = RealTimeMinersInformation[publicKey];
        if (RoundNumber != 1)
            return minerInRound.ExpectedMiningTime + new Duration { Seconds = miningInterval.Div(1000) } <
                   currentBlockTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L142-148)
```csharp
    public MinerInRound FirstMiner()
    {
        return RealTimeMinersInformation.Count > 0
            ? RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == 1)
            // Unlikely.
            : new MinerInRound();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L94-102)
```csharp
            if (
                // For first round, the expected mining time is incorrect (due to configuration),
                CurrentRound.RoundNumber == 1 &&
                // so we'd better prevent miners' ain't first order (meanwhile he isn't boot miner) from mining fork blocks
                _minerInRound.Order != 1 &&
                // by postpone their mining time
                CurrentRound.FirstMiner().OutValue == null
            )
                return AElfConsensusBehaviour.NextRound;
```

**File:** protobuf/aedpos_contract.proto (L484-507)
```text
message NextTermInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```
