### Title
Missing Symbol Format Validation in CrossChainCreate() Allows Invalid NFT Protocol Registration

### Summary
The `CrossChainCreate()` function does not validate that the input symbol matches the expected NFT protocol format before processing. This allows symbols with insufficient length to cause DoS via unhandled exceptions, and permits registration of NFT protocols with malformed symbols that violate the established format invariant of 2-character NFT type prefix followed by a 9+ digit numeric suffix.

### Finding Description

In the `CrossChainCreate()` function, the symbol validation is insufficient: [1](#0-0) 

At line 89, `input.Symbol.Substring(0, 2)` is called without first validating that the symbol has a minimum length of 2 characters. This creates two distinct vulnerabilities:

1. **DoS via Unhandled Exception**: If a symbol with length < 2 is provided, the `Substring(0, 2)` call throws an `ArgumentOutOfRangeException`, causing transaction failure.

2. **Format Invariant Violation**: The function only validates that the extracted 2-character prefix exists in `NFTTypeFullNameMap` (lines 90-93), but does not validate that:
   - The symbol has the expected minimum length (11 characters based on 2-char prefix + 9-digit minimum)
   - The characters after position 2 are numeric
   - The overall symbol matches the NFT protocol pattern

The expected NFT protocol symbol format is demonstrated in the test suite: [2](#0-1) 

The `GetSymbol()` function generates symbols with this format: [3](#0-2) 

And the minimum number length is defined: [4](#0-3) 

The vulnerability exists because tokens created via `TokenContract.Create()` can have arbitrary symbols and ExternalInfo: [5](#0-4) 

These tokens can then be synced cross-chain and processed by `CrossChainCreate()` without proper format validation.

### Impact Explanation

**DoS Impact**: An attacker can cause transaction failures by creating tokens with symbols shorter than 2 characters (e.g., "A" or "") on the main chain, syncing them cross-chain, and triggering `CrossChainCreate()`. This results in unhandled `ArgumentOutOfRangeException`, denying service to legitimate cross-chain NFT protocol creation.

**Protocol Integrity Impact**: Malformed NFT protocol symbols (e.g., "AR", "ARxyz", "XX123") can be registered, violating the documented format invariant. This affects:
- Off-chain indexers and tools expecting the standard 11+ character format
- Future contract logic that may assume the format for parsing
- Protocol consistency and user experience

**Scope**: Any NFT protocol created via cross-chain mechanism is affected. While the main chain `Create()` function properly generates valid symbols, side chains are vulnerable to malformed symbols through `CrossChainCreate()`.

### Likelihood Explanation

**Entry Point**: `CrossChainCreate()` is a public function with no access control restrictions. [6](#0-5) 

**Attack Prerequisites**:
1. Create a token on main chain via `TokenContract.Create()` with a malformed symbol and required NFT metadata keys (`aelf_nft_base_uri`, `aelf_nft_token_id_reuse`)
2. Sync the token to side chain via `CrossChainCreateToken()` 
3. Call `CrossChainCreate()` on the side chain with the malformed symbol

**Feasibility**: Medium complexity. The attacker must:
- Understand the required metadata keys (lines 87-88 show they're mandatory)
- Have resources to perform cross-chain operations
- Know the registered NFT type short names

**Detection**: Attack would be visible in blockchain events and state, but may not be immediately detected as malicious.

### Recommendation

Add comprehensive symbol format validation at the beginning of `CrossChainCreate()`:

```csharp
public override Empty CrossChainCreate(CrossChainCreateInput input)
{
    MakeSureTokenContractAddressSet();
    InitialNFTTypeNameMap();
    
    // Add validation here
    Assert(input.Symbol != null && input.Symbol.Length >= 11, 
        "Invalid symbol: must be at least 11 characters");
    Assert(input.Symbol.Length >= 2, 
        "Invalid symbol: insufficient length");
    
    var nftTypeShortName = input.Symbol.Substring(0, 2);
    var numericPart = input.Symbol.Substring(2);
    Assert(long.TryParse(numericPart, out _), 
        "Invalid symbol: characters after position 2 must be numeric");
    
    Assert(State.NftProtocolMap[input.Symbol] == null, 
        $"Protocol {input.Symbol} already created.");
    // ... rest of function
}
```

Additionally, add test cases to verify rejection of:
- Symbols with length < 2 (e.g., "A", "")
- Symbols with valid prefix but non-numeric suffix (e.g., "ARabc")
- Symbols shorter than expected minimum (e.g., "AR", "AR12")

### Proof of Concept

**Initial State**: 
- Main chain with TokenContract and NFTContract deployed
- Side chain with both contracts deployed and cross-chain verification configured
- NFT type "AR" (Art) registered in NFTTypeFullNameMap

**Attack Sequence**:

1. On main chain, create a token with malformed symbol:
```
TokenContract.Create({
    Symbol: "AR",  // Only 2 characters, violates 11+ character format
    TokenName: "Malformed",
    Decimals: 0,
    TotalSupply: 1000,
    Issuer: AttackerAddress,
    ExternalInfo: {
        "aelf_nft_base_uri": "http://example.com/",
        "aelf_nft_token_id_reuse": "false",
        "aelf_nft_type": "Art"
    }
})
```

2. Sync token to side chain via `CrossChainCreateToken()`

3. On side chain, call:
```
NFTContract.CrossChainCreate({
    Symbol: "AR"
})
```

**Expected Result**: Transaction should fail with validation error about invalid symbol format

**Actual Result**: NFT protocol with symbol "AR" (2 characters) is successfully registered, violating the expected format of 2-char prefix + 9+ digit numeric suffix

**DoS Variant**: Use symbol "A" in step 1, which causes `ArgumentOutOfRangeException` at line 89, blocking the transaction entirely.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L75-76)
```csharp
    public override Empty CrossChainCreate(CrossChainCreateInput input)
    {
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L89-93)
```csharp
        var nftTypeShortName = input.Symbol.Substring(0, 2);
        var nftTypeFullName = State.NFTTypeFullNameMap[nftTypeShortName];
        if (nftTypeFullName == null)
            throw new AssertionException(
                $"Full name of {nftTypeShortName} not found. Use AddNFTType to add this new pair.");
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractTests.cs (L48-48)
```csharp
        symbol.Length.ShouldBe(11);
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Helpers.cs (L24-37)
```csharp
    private string GetSymbol(string nftType)
    {
        var randomNumber = GenerateSymbolNumber();
        State.IsCreatedMap[randomNumber] = true;
        var shortName = State.NFTTypeShortNameMap[nftType];
        if (shortName == null)
        {
            InitialNFTTypeNameMap();
            shortName = State.NFTTypeShortNameMap[nftType];
            if (shortName == null) throw new AssertionException($"Short name of NFT Type {nftType} not found.");
        }

        return $"{shortName}{randomNumber}";
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContractConstants.cs (L5-5)
```csharp
    private const int NumberMinLength = 9;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```
