### Title
Missing Options Count Validation in Vote Contract Register Method Allows Bypass of MaximumOptionsCount Limit

### Summary
The `Register` method in the Vote contract fails to validate the number of options provided during voting item creation, allowing attackers to bypass the `MaximumOptionsCount` constant of 64. This enables creation of voting items with arbitrarily large numbers of options (potentially hundreds or thousands), leading to excessive state storage consumption and blockchain bloat through repeated registrations.

### Finding Description

The root cause is a missing validation check in the `Register` method's validation flow. The `MaximumOptionsCount` constant is defined as 64 [1](#0-0) , but this limit is not enforced during initial voting item registration.

The `Register` method directly assigns options from the input without validation [2](#0-1) , and the `AssertValidNewVotingItem` validation method only checks for voting item existence, snapshot number, and timestampsâ€”completely omitting options count validation [3](#0-2) .

In contrast, the `AddOption` method explicitly enforces the limit with a strict less-than check [4](#0-3) , and the `AddOptions` method enforces it with a less-than-or-equal check after adding options [5](#0-4) . This inconsistency demonstrates the limit is intentionally designed but incorrectly implemented.

Additionally, the `AssertOption` method validates individual option length limits [6](#0-5) , but it is never called during registration, allowing bypass of both the count limit (64 options) and the individual option length limit (1024 characters per option).

The only protection is the transaction fee of 10 ELF per registration [7](#0-6) , which is insufficient to prevent a determined attacker from causing significant state bloat.

### Impact Explanation

**Operational Impact - State Bloat and Resource Exhaustion:**
- An attacker can create voting items with far more than 64 options (e.g., 1000+ options each up to 1024 characters)
- Each voting item with excessive options consumes significantly more storage than intended (potentially megabytes per item vs. expected kilobytes)
- The `VotingItems` state mapping stores these permanently [8](#0-7) 
- `VotingResult` initialization also stores the voting item ID and snapshot data [9](#0-8) 
- Repeated registrations compound the problem, degrading node performance, increasing storage costs, and potentially causing DoS through state bloat
- All network nodes must store this excessive data perpetually

**Severity Justification:**
The attack directly violates the protocol's design invariants (MaximumOptionsCount exists for a reason) and can cause operational degradation affecting the entire network. While it requires economic cost (10 ELF per item), a dedicated attacker could feasibly execute this at scale to cause meaningful harm.

### Likelihood Explanation

**High Feasibility:**
- **Reachable Entry Point:** `Register` is a public method callable by anyone [10](#0-9) 
- **Minimal Preconditions:** Attacker only needs ELF tokens for transaction fees and a whitelisted token symbol (which includes common tokens like ELF itself)
- **Simple Execution:** Construct a `VotingRegisterInput` with an arbitrarily large options array and call `Register`
- **No Access Control:** No restrictions on who can register voting items or how many

**Economic Analysis:**
At 10 ELF per registration, creating 100 voting items with 1000 options each (100MB+ of bloat) costs only 1000 ELF. For a determined attacker or during periods of low ELF price, this becomes economically rational to disrupt the network. The permanent nature of the storage makes this particularly damaging.

**Detection Constraints:**
Standard transaction monitoring would only see normal `Register` calls. The excessive options count wouldn't be immediately obvious without inspecting transaction data size, making the attack somewhat stealthy.

### Recommendation

**Immediate Fix:**
Add options count validation to the `AssertValidNewVotingItem` method or directly in the `Register` method before line 49:

```csharp
Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
    $"The count of options can't be greater than {VoteContractConstants.MaximumOptionsCount}");
```

**Additional Validations:**
Also validate individual option lengths during registration by iterating through `input.Options` and checking each against `OptionLengthLimit`:

```csharp
foreach (var option in input.Options)
{
    Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid option length.");
}
```

**Recommended Test Cases:**
1. Test registering with exactly 64 options (should succeed)
2. Test registering with 65 options (should fail with appropriate error)
3. Test registering with options exceeding 1024 characters (should fail)
4. Test registering with 0 options (determine if this should be allowed)

### Proof of Concept

**Initial State:**
- Attacker has sufficient ELF tokens for transaction fees (e.g., 1000 ELF for 100 registrations)
- A whitelisted token symbol is available (e.g., "ELF")

**Attack Steps:**
1. Construct `VotingRegisterInput` with 1000 options, each 1024 characters long:
   ```
   options = ["A" * 1024, "B" * 1024, ..., "ZZZ" * 1024] // 1000 options
   acceptedCurrency = "ELF"
   startTimestamp = currentTime
   endTimestamp = currentTime + 30 days
   ```

2. Call `VoteContract.Register(input)` - transaction succeeds despite exceeding MaximumOptionsCount by 15.6x

3. Repeat steps 1-2 with different start/end timestamps to create additional voting items (voting item ID is computed from input hash + sender, so varying timestamps creates unique items)

4. Each successful registration stores ~1MB of data permanently in state

**Expected vs Actual:**
- **Expected:** Registration should fail with error "The count of options can't be greater than 64"
- **Actual:** Registration succeeds, storing voting items with 1000+ options in violation of MaximumOptionsCount constant

**Success Condition:**
Query `GetVotingItem` for the created voting item ID - observe `Options.Count > 64`, confirming the bypass of the intended limit.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-5)
```csharp
    public const int MaximumOptionsCount = 64;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-20)
```csharp
    public override Empty Register(VotingRegisterInput input)
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L49-49)
```csharp
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L54-54)
```csharp
        State.VotingItems[votingItemId] = votingItem;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L57-63)
```csharp
        var votingResultHash = GetVotingResultHash(votingItemId, 1);
        State.VotingResults[votingResultHash] = new VotingResult
        {
            VotingItemId = votingItemId,
            SnapshotNumber = 1,
            SnapshotStartTimestamp = input.StartTimestamp
        };
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L285-286)
```csharp
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L319-321)
```csharp
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L42-49)
```csharp
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
