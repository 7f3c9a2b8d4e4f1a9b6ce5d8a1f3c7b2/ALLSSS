### Title
Denial of Service in IsCurrentMiner via IsMinerListJustChanged Bypass

### Summary
When the miner list changes and `IsMinerListJustChanged` is true, the `IsCurrentMiner()` function skips the `ContainsKey` check but later directly accesses the dictionary without verification. Removed miners whose pubkeys still exist in the previous round can trigger a `KeyNotFoundException`, causing denial of service on this critical authorization function and dependent contracts like Parliament.

### Finding Description

The vulnerability exists in the `IsCurrentMiner(string pubkey)` private method: [1](#0-0) 

When `IsMinerListJustChanged` is true, the function bypasses the `ContainsKey` check. However, at line 158, it unconditionally accesses `currentRound.RealTimeMinersInformation[pubkey]`: [2](#0-1) 

Similarly, at line 182, the function calls `ArrangeAbnormalMiningTime` which also directly accesses the dictionary: [3](#0-2) 

The root cause is in how miner replacement works. During next round generation, evil miners are replaced in memory: [4](#0-3) [5](#0-4) 

However, these modifications to `currentRound` are NOT persisted to state. Only the new round is saved: [6](#0-5) 

When `ConvertAddressToPubkey` searches for a removed miner's address, it checks both current and previous rounds: [7](#0-6) 

Since the previous round in state still contains the removed miner's pubkey, it returns successfully. But when `IsCurrentMiner` tries to access this pubkey in the current round's `RealTimeMinersInformation`, a `KeyNotFoundException` is thrown.

### Impact Explanation

This vulnerability enables a Denial of Service attack on the `IsCurrentMiner` function, which is a critical authorization primitive used throughout the system.

**Direct Operational Impact:**
- The Parliament contract's `ApproveMultiProposals` method calls `AssertCurrentMiner()`, which internally calls `IsCurrentMiner`: [8](#0-7) [9](#0-8) 

- When a removed evil miner triggers the exception, legitimate current miners cannot approve proposals, blocking all Parliament governance operations
- The attack persists for the entire duration of the round where `IsMinerListJustChanged` is true (typically until the next round transition)
- Affects critical governance decisions including contract upgrades, parameter changes, and emergency responses

**Affected Parties:**
- Current legitimate miners unable to perform governance duties
- All stakeholders depending on timely governance actions
- System reliability and operational continuity

**Severity Justification:** HIGH - Complete denial of critical governance authorization functionality during miner list transitions.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be an evil miner who has been removed from the miner list
- No special privileges required beyond having been a previous miner
- Attack is a simple external view method call

**Attack Complexity:**
- Very low complexity - single transaction to `IsCurrentMiner` with attacker's own address
- No timing requirements or race conditions
- Deterministic outcome when conditions are met

**Feasibility Conditions:**
- Miner replacement must have occurred (evil miner detected and replaced)
- Current round must have `IsMinerListJustChanged = true`
- Attacker must still have their address keypair to sign transactions

**Operational Constraints:**
- Window of opportunity: one full round (typically minutes to hours)
- Easily repeatable by calling the view method multiple times
- No cost to attacker as view methods don't consume gas

**Probability:** MEDIUM - Requires specific precondition (being a removed miner) but trivial to execute once conditions are met. Miner replacements happen periodically in the system when evil miners are detected.

### Recommendation

**Code-Level Mitigation:**

Add a `ContainsKey` check before accessing the dictionary, regardless of `IsMinerListJustChanged` status:

```csharp
if (!currentRound.IsMinerListJustChanged)
    if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
        return false;

// Add this check before line 158
if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
    return false;

var miningInterval = currentRound.GetMiningInterval();
var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
```

**Invariant Check:**
- Ensure all dictionary accesses in `IsCurrentMiner` are guarded by `ContainsKey` checks
- Validate that miners being checked exist in the current round's miner list

**Test Cases:**
1. Test `IsCurrentMiner` with removed evil miner address when `IsMinerListJustChanged` is true
2. Verify function returns false instead of throwing exception
3. Test Parliament operations continue functioning during miner list transitions
4. Verify previous round's extra block producer can still be validated at round start

### Proof of Concept

**Initial State:**
- Round N with miners A, B, C (C is evil miner)
- C has produced blocks and is tracked in consensus state

**Attack Sequence:**

1. **Miner Replacement Occurs:**
   - System detects C as evil miner
   - Next round (N+1) generated with C replaced by alternative miner D
   - Round N+1 has `IsMinerListJustChanged = true`
   - Round N+1 contains miners: A, B, D
   - Round N in state still contains: A, B, C (unmodified)

2. **Evil Miner C Executes Attack:**
   - C calls `IsCurrentMiner(C's address)` on consensus contract
   - View call does not require gas or special permissions

3. **Execution Flow:**
   - `IsCurrentMiner(Address input)` calls `ConvertAddressToPubkey(C's address)`
   - `ConvertAddressToPubkey` checks current round (N+1): C not found
   - `ConvertAddressToPubkey` checks previous round (N): C found, returns C's pubkey
   - `IsCurrentMiner(string pubkey)` called with C's pubkey
   - Line 142: `IsMinerListJustChanged` is true, skip ContainsKey check
   - Line 158: Access `currentRound.RealTimeMinersInformation[C's pubkey]`
   - **Result:** `KeyNotFoundException` thrown

4. **Expected vs Actual:**
   - **Expected:** Function returns `BoolValue { Value = false }`
   - **Actual:** Transaction reverts with `KeyNotFoundException`

5. **DoS Effect:**
   - Legitimate miner A attempts to call `Parliament.ApproveMultiProposals`
   - Parliament calls `IsCurrentMiner(A's address)` for authorization
   - If C has polluted the call stack or state with the exception, subsequent calls may fail
   - More critically, any cross-contract call path involving removed miners will fail

**Success Condition:**
Attack succeeds when `IsCurrentMiner` throws exception instead of returning false, blocking dependent authorization flows in Parliament and other contracts.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L127-133)
```csharp
        if (!TryToGetCurrentRoundInformation(out var currentRound)) return null;
        var possibleKeys = currentRound.RealTimeMinersInformation.Keys.ToList();
        if (TryToGetPreviousRoundInformation(out var previousRound))
            possibleKeys.AddRange(previousRound.RealTimeMinersInformation.Keys);

        return possibleKeys.FirstOrDefault(k =>
            Address.FromPublicKey(ByteArrayHelper.HexStringToByteArray(k)) == address);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L142-144)
```csharp
        if (!currentRound.IsMinerListJustChanged)
            if (!currentRound.RealTimeMinersInformation.ContainsKey(pubkey))
                return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L158-159)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[pubkey];
        var timeSlotStartTime = minerInRound.ExpectedMiningTime;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L337-338)
```csharp
                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L341-346)
```csharp
                isMinerListChanged = true;
            }
        }

        currentRound.GenerateNextRoundInformation(currentBlockTime, blockchainStartTimestamp, out nextRound,
            isMinerListChanged);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ArrangeAbnormalMiningTime.cs (L24-24)
```csharp
        var minerInRound = RealTimeMinersInformation[pubkey];
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L156-156)
```csharp
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L188-190)
```csharp
    public override Empty ApproveMultiProposals(ProposalIdList input)
    {
        AssertCurrentMiner();
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L212-218)
```csharp
    private void AssertCurrentMiner()
    {
        RequireConsensusContractStateSet();
        var isCurrentMiner = State.ConsensusContract.IsCurrentMiner.Call(Context.Sender).Value;
        Context.LogDebug(() => $"Sender is currentMiner : {isCurrentMiner}.");
        Assert(isCurrentMiner, "No permission.");
    }
```
