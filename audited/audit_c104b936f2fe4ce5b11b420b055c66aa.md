# Audit Report

## Title
ProfitDetail ID Collision Causes Transaction Failure in FixProfitDetail and RemoveBeneficiary

## Summary
The Profit contract allows multiple ProfitDetail entries with identical IDs to exist for the same beneficiary. When `FixProfitDetail` or `RemoveBeneficiary` attempts to operate on these duplicate entries using `.SingleOrDefault()` or `.Single()` LINQ methods, they throw `InvalidOperationException`, causing permanent DoS. This occurs in legitimate scenarios where Election candidates quit and rejoin, making profit detail management impossible for affected beneficiaries and voters.

## Finding Description

The vulnerability exists because `AddBeneficiary` does not validate for duplicate ProfitDetail IDs before adding new entries. [1](#0-0) 

When the Election contract manages backup subsidies, it generates deterministic IDs based on candidate pubkey and beneficiary address: [2](#0-1) 

The Subsidy profit scheme is created with `CanRemoveBeneficiaryDirectly = true`: [3](#0-2) 

When a candidate quits election, `RemoveBeneficiary` is called which marks `IsWeightRemoved = true` but does NOT physically delete the ProfitDetail entry from storage: [4](#0-3) 

When the candidate rejoins election (which is allowed per the contract logic), `AddBeneficiary` is called again: [5](#0-4) 

This creates a NEW ProfitDetail with the SAME subsidyId. The test suite explicitly verifies this duplicate ID behavior exists: [6](#0-5) 

Subsequently, when `FixProfitDetail` is called (e.g., when a voter extends their voting period via `ExtendVoterWelfareProfits`), it uses `.SingleOrDefault()` which throws an exception when multiple ProfitDetails have the same ID: [7](#0-6) [8](#0-7) 

Similarly, `RemoveBeneficiary` can fail when duplicate IDs exist and certain removal conditions are met, as it also uses `.Single()`: [9](#0-8) 

The C# LINQ `.SingleOrDefault()` and `.Single()` methods are documented to throw `InvalidOperationException` when the sequence contains more than one matching element. This breaks the security guarantee that profit detail management operations should complete successfully for valid beneficiaries.

## Impact Explanation

**Operational DoS**: Beneficiaries with duplicate ProfitDetail IDs cannot have their profit details fixed or removed. Transactions calling `FixProfitDetail` or `RemoveBeneficiary` will fail with unhandled exceptions.

**Affected Users**:
- Election candidates who quit and rejoin: their subsidy ProfitDetails become permanently unmanageable
- Voters who voted for such candidates: cannot extend voting periods, as `ChangeVotingOption` with `IsResetVotingTime=true` calls `FixProfitDetail` internally
- Any beneficiary in schemes where deterministic ProfitDetailIds are reused

**Severity**: HIGH - This creates permanent DoS for core profit distribution operations. The test suite proves this state exists and is considered valid behavior, yet the contract code uses operations that assume ID uniqueness. This affects legitimate users performing normal protocol operations (quit/rejoin election, extend voting periods).

## Likelihood Explanation

**Likelihood**: HIGH - This occurs through normal, intended user operations:

1. **No Attack Required**: Any candidate who quits and rejoins election triggers this condition through normal protocol flow
2. **Realistic Preconditions**: Election contract is the manager of the subsidy scheme and routinely calls these methods
3. **Execution Certainty**: Once duplicate IDs exist, calling `FixProfitDetail` WILL throw `InvalidOperationException` - this is guaranteed by .NET LINQ behavior
4. **Already Occurring**: Test code explicitly verifies that duplicate IDs exist in the system, proving this is current behavior

The vulnerability is not theoretical - it's a state that the system actively creates and tests validate.

## Recommendation

Add duplicate ID validation in `AddBeneficiary` to prevent adding ProfitDetails with IDs that already exist:

```csharp
public override Empty AddBeneficiary(AddBeneficiaryInput input)
{
    // ... existing validation ...
    
    var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
    
    // Add validation for duplicate IDs
    if (input.ProfitDetailId != null && currentProfitDetails != null)
    {
        Assert(!currentProfitDetails.Details.Any(d => d.Id == input.ProfitDetailId && !d.IsWeightRemoved),
            "ProfitDetail with this ID already exists and is active.");
    }
    
    // ... rest of existing code ...
}
```

Alternatively, modify `RemoveProfitDetails` to physically delete entries when `CanRemoveBeneficiaryDirectly = true` instead of just marking them as removed:

```csharp
if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
{
    // For schemes that can remove directly, physically delete the entry
    profitDetails.Details.Remove(profitDetail);
}
```

## Proof of Concept

The test `SetProfitsReceiver_QuitElection_Check_BackupSubsidy` in BackupSubsidyTests.cs demonstrates this vulnerability: [10](#0-9) 

This test proves:
1. Candidate announces election (creates first ProfitDetail)
2. Sets profit receiver (removes old, adds new with same ID)
3. Quits election (marks IsWeightRemoved=true, doesn't delete)
4. Rejoins election (creates another ProfitDetail with SAME ID)
5. Line 402 explicitly verifies: `profitReceiverBackShare.Details.First().Id.ShouldBe(profitReceiverBackShare.Details.Last().Id)`

After this state is reached, any call to `FixProfitDetail` for this beneficiary will throw an exception, causing DoS.

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L186-201)
```csharp
        var profitDetail = new ProfitDetail
        {
            StartPeriod = scheme.CurrentPeriod.Add(scheme.DelayDistributePeriodCount),
            EndPeriod = input.EndPeriod,
            Shares = input.BeneficiaryShare.Shares,
            Id = input.ProfitDetailId
        };

        var currentProfitDetails = State.ProfitDetailsMap[schemeId][input.BeneficiaryShare.Beneficiary];
        if (currentProfitDetails == null)
            currentProfitDetails = new ProfitDetails
            {
                Details = { profitDetail }
            };
        else
            currentProfitDetails.Details.Add(profitDetail);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L278-281)
```csharp
        if (input.ProfitDetailId != null)
        {
            // In new rules, rofitDetail.Id equals to its vote id.
            fixingDetail = profitDetails.Details.SingleOrDefault(d => d.Id == input.ProfitDetailId);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L334-337)
```csharp
        if (profitDetailId != null && profitDetails.Details.Any(d => d.Id == profitDetailId) &&
            detailsCanBeRemoved.All(d => d.Id != profitDetailId))
        {
            detailsCanBeRemoved.Add(profitDetails.Details.Single(d => d.Id == profitDetailId));
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L344-369)
```csharp
                // set remove sign
                profitDetail.IsWeightRemoved = true;
                if (profitDetail.LastProfitPeriod >= scheme.CurrentPeriod)
                {
                    // remove those profits claimed
                    profitDetails.Details.Remove(profitDetail);
                }
                else if (profitDetail.EndPeriod >= scheme.CurrentPeriod)
                {
                    // No profit can be here, except the scheme is cancellable.
                    // shorten profit.
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
                }

                removedDetails.TryAdd(scheme.CurrentPeriod, profitDetail.Shares);
            }

            Context.LogDebug(() => $"ProfitDetails after removing expired details: {profitDetails}");
        }

        var weightCanBeRemoved = profitDetails.Details
            .Where(d => d.EndPeriod == scheme.CurrentPeriod && !d.IsWeightRemoved).ToList();
        foreach (var profitDetail in weightCanBeRemoved)
        {
            profitDetail.IsWeightRemoved = true;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L144-154)
```csharp
            State.ProfitContract.FixProfitDetail.Send(new FixProfitDetailInput
            {
                SchemeId = State.WelfareHash.Value,
                BeneficiaryShare = new BeneficiaryShare
                {
                    Beneficiary = electionVotingRecord.Voter,
                    Shares = electionVotingRecord.Weight
                },
                EndPeriod = endPeriod,
                ProfitDetailId = voteId
            });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L763-767)
```csharp
    private Hash GenerateSubsidyId(string pubkey, Address beneficiaryAddress)
    {
        return HashHelper.ConcatAndCompute(HashHelper.ComputeFrom(pubkey), HashHelper.ComputeFrom(beneficiaryAddress),
            HashHelper.ComputeFrom(Context.Self));
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L66-66)
```csharp
                CanRemoveBeneficiaryDirectly = new List<int> { 2, 5, 6 }.Contains(i)
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L154-162)
```csharp
        if (candidateInformation != null)
        {
            Assert(!candidateInformation.IsCurrentCandidate,
                $"This public key already announced election. {pubkey}");
            candidateInformation.AnnouncementTransactionId = Context.OriginTransactionId;
            candidateInformation.IsCurrentCandidate = true;
            // In this way we can keep history of current candidate, like terms, missed time slots, etc.
            State.CandidateInformationMap[pubkey] = candidateInformation;
        }
```

**File:** test/AElf.Contracts.Election.Tests/Full/BackupSubsidyTests.cs (L343-405)
```csharp
    public async Task SetProfitsReceiver_QuitElection_Check_BackupSubsidy()
    {
        var announceElectionKeyPair = ValidationDataCenterKeyPairs.First();
        var candidateAdmin = ValidationDataCenterKeyPairs.Last();
        var profitReceiver = ValidationDataCenterKeyPairs.Skip(2).First();

        var candidateAdminAddress = Address.FromPublicKey(candidateAdmin.PublicKey);
        await AnnounceElectionAsync(announceElectionKeyPair, candidateAdminAddress);

        {
            var candidateAdminStub =
                GetTester<TreasuryContractImplContainer.TreasuryContractImplStub>(TreasuryContractAddress,
                    candidateAdmin);
            await candidateAdminStub.SetProfitsReceiver.SendAsync(
                new Treasury.SetProfitsReceiverInput
                {
                    Pubkey = announceElectionKeyPair.PublicKey.ToHex(),
                    ProfitsReceiverAddress = Address.FromPublicKey(profitReceiver.PublicKey)
                });
            var getProfitReceiver = await GetProfitReceiver(announceElectionKeyPair.PublicKey.ToHex());
            getProfitReceiver.ShouldBe(Address.FromPublicKey(profitReceiver.PublicKey));
        }

        await QuitElectionAsync(announceElectionKeyPair, candidateAdmin);

        // Check profit details
        {
            var candidateShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(announceElectionKeyPair.PublicKey));
            candidateShare.Details.Count.ShouldBe(1);
            candidateShare.Details.First().Shares.ShouldBe(1);
            candidateShare.Details.First().IsWeightRemoved.ShouldBeTrue();

            var profitReceiverBackShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(profitReceiver.PublicKey));
            profitReceiverBackShare.Details.Count.ShouldBe(1);
            profitReceiverBackShare.Details.First().Shares.ShouldBe(1);
            profitReceiverBackShare.Details.First().IsWeightRemoved.ShouldBeTrue();
        }
        
        // Announce Election again
        await AnnounceElectionAsync(announceElectionKeyPair, candidateAdminAddress);
        
        // Check profit receiver and profit details
        {
            var getProfitReceiver = await GetProfitReceiver(announceElectionKeyPair.PublicKey.ToHex());
            getProfitReceiver.ShouldBe(Address.FromPublicKey(profitReceiver.PublicKey));
            
            var candidateShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(announceElectionKeyPair.PublicKey));
            candidateShare.Details.Count.ShouldBe(1);
            candidateShare.Details.First().Shares.ShouldBe(1);
            candidateShare.Details.First().IsWeightRemoved.ShouldBeTrue();

            var profitReceiverBackShare =
                await GetBackupSubsidyProfitDetails(Address.FromPublicKey(profitReceiver.PublicKey));
            profitReceiverBackShare.Details.Count.ShouldBe(2);
            profitReceiverBackShare.Details.First().IsWeightRemoved.ShouldBeTrue();
            profitReceiverBackShare.Details.Last().IsWeightRemoved.ShouldBeFalse();
            profitReceiverBackShare.Details.First().Id.ShouldBe(profitReceiverBackShare.Details.Last().Id);
        }

    }
```
