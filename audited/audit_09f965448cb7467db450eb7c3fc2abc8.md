### Title
Missing Validation Allows User-Controlled Callbacks in Token ExternalInfo Leading to DoS and Malicious Execution

### Summary
The MultiToken contract's `Create` method accepts user-provided `ExternalInfo` without validating that reserved callback keys are not used. Attackers can create tokens with malicious callbacks that execute arbitrary contract logic during transfer/lock/unlock operations, causing denial of service or executing malicious code that affects all users interacting with the token.

### Finding Description

The MultiToken contract defines four reserved external info keys for callback mechanisms: [1](#0-0) 

The `GetReservedExternalInfoKeyList` function explicitly returns these reserved keys: [2](#0-1) 

However, the `Create` method accepts a `CreateInput` containing user-provided `ExternalInfo`: [3](#0-2) 

The `CreateToken` method directly assigns this user input without any validation: [4](#0-3) 

The validation function `AssertValidCreateInput` does not check ExternalInfo keys at all: [5](#0-4) 

During token operations, these reserved keys trigger callbacks via `Context.SendInline`: [6](#0-5) [7](#0-6) [8](#0-7) 

The callback values are parsed as JSON containing contract address and method name, then executed: [9](#0-8) 

### Impact Explanation

**Operational Impact - DoS of Token Operations:**
- An attacker creates a token with `ExternalInfo` containing `aelf_transfer_callback`, `aelf_lock_callback`, or `aelf_unlock_callback` pointing to a malicious contract that always reverts
- Any user attempting to transfer, lock, or unlock this token will trigger the callback, causing the operation to fail
- This completely breaks the usability of the token for all holders
- The token becomes effectively frozen as no transfers/locks/unlocks can complete

**Malicious Execution Impact:**
- Attacker sets callback to point to a malicious contract with arbitrary logic
- During legitimate token operations, the malicious contract executes:
  - Potential reentrancy attacks during token operations
  - State manipulation in external contracts
  - Resource exhaustion / griefing attacks
  - Unexpected side effects that users did not consent to
- Users have no visibility into callbacks when receiving or using tokens

**Affected Parties:**
- All users who hold or interact with tokens created with malicious callbacks
- DApp developers integrating token functionality
- The overall token ecosystem's trustworthiness is compromised

### Likelihood Explanation

**Reachable Entry Point:**
The `Create` method is publicly accessible to any user who possesses a valid seed NFT or is whitelisted: [10](#0-9) 

**Feasible Preconditions:**
- Attacker needs a seed NFT to create a token (obtainable through standard mechanisms)
- No special permissions required beyond normal token creation rights
- Attack requires only basic knowledge of the ExternalInfo structure

**Execution Practicality:**
1. Attacker creates a malicious contract with a method that reverts or performs malicious actions
2. Attacker creates a token via `Create` with `ExternalInfo` containing:
   - Key: `"aelf_transfer_callback"` (or other reserved keys)
   - Value: JSON-serialized `CallbackInfo` with malicious contract address and method name
3. Token is successfully created without validation errors
4. Any user performing transfer/lock/unlock operations triggers the malicious callback
5. Operation fails or executes malicious logic

**Economic Rationality:**
- Attack cost: Only the cost of obtaining a seed NFT and creating a token
- Impact: Can affect unlimited users who interact with the token
- No detection mechanism exists to warn users about callback presence
- ROI for griefing/DoS attacks is very high

**Detection Constraints:**
- Users cannot easily detect callback presence without inspecting ExternalInfo
- No warnings or checks during token reception
- GetReservedExternalInfoKeyList exists but is never used for validation

### Recommendation

**Immediate Fix:**
Add validation in `AssertValidCreateInput` to prevent users from setting reserved keys:

```csharp
private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
{
    Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
           && input.Symbol.Length > 0
           && input.Decimals >= 0
           && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");
    
    // Add validation for reserved keys
    if (input.ExternalInfo != null && input.ExternalInfo.Value != null)
    {
        var reservedKeys = new[]
        {
            TokenContractConstants.LockCallbackExternalInfoKey,
            TokenContractConstants.LogEventExternalInfoKey,
            TokenContractConstants.TransferCallbackExternalInfoKey,
            TokenContractConstants.UnlockCallbackExternalInfoKey
        };
        
        foreach (var key in reservedKeys)
        {
            Assert(!input.ExternalInfo.Value.ContainsKey(key),
                $"External info key '{key}' is reserved and cannot be set by users.");
        }
    }

    CheckSymbolLength(input.Symbol, symbolType);
    if (symbolType == SymbolType.Nft) return;
    CheckTokenAndCollectionExists(input.Symbol);
    if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
}
```

**Alternative Approach:**
If callbacks are intended to be user-settable, add explicit authorization checks:
- Only allow token owner/issuer to set callbacks
- Require whitelist of approved callback contracts
- Add explicit user consent mechanism before triggering callbacks

**Test Cases:**
1. Test that token creation fails when ExternalInfo contains reserved keys
2. Test that all four reserved keys are properly blocked
3. Test that non-reserved keys still work correctly
4. Test that existing tokens without callbacks continue functioning

### Proof of Concept

**Initial State:**
- Attacker has a valid seed NFT for creating token "EVIL"
- Attacker deploys malicious contract `MaliciousCallback` with method `OnTransfer` that always reverts

**Attack Sequence:**

1. **Attacker creates malicious token:**
```
Call TokenContract.Create({
    symbol: "EVIL",
    token_name: "Evil Token",
    total_supply: 1000000,
    decimals: 8,
    issuer: <attacker_address>,
    is_burnable: true,
    external_info: {
        "aelf_transfer_callback": '{"contract_address":"<MaliciousCallback>","method_name":"OnTransfer"}'
    }
})
```
Result: Token created successfully (NO VALIDATION ERROR)

2. **Attacker issues and distributes tokens to victims:**
```
Call TokenContract.Issue({symbol: "EVIL", amount: 1000, to: <victim1>})
Call TokenContract.Issue({symbol: "EVIL", amount: 1000, to: <victim2>})
```
Result: Tokens distributed

3. **Victim attempts to transfer token:**
```
Call TokenContract.Transfer({
    to: <victim2>,
    symbol: "EVIL",
    amount: 100
})
```
Expected: Transfer succeeds
Actual: Transfer triggers callback → MaliciousCallback.OnTransfer executes → reverts → entire transfer fails

4. **Victim attempts to lock token:**
```
Call TokenContract.Lock({
    address: <victim1>,
    lock_id: <some_hash>,
    symbol: "EVIL",
    amount: 100
})
```
Expected: Lock succeeds
Actual: Lock triggers callback → MaliciousCallback executes → reverts → entire lock fails

**Success Condition:**
Token operations (transfer/lock/unlock) consistently fail due to malicious callback execution, demonstrating complete DoS of token functionality for all users.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L13-16)
```csharp
    public const string TransferCallbackExternalInfoKey = "aelf_transfer_callback";
    public const string LockCallbackExternalInfoKey = "aelf_lock_callback";
    public const string UnlockCallbackExternalInfoKey = "aelf_unlock_callback";
    public const string LogEventExternalInfoKey = "aelf_log_event";
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Views.cs (L238-250)
```csharp
    public override StringList GetReservedExternalInfoKeyList(Empty input)
    {
        return new StringList
        {
            Value =
            {
                TokenContractConstants.LockCallbackExternalInfoKey,
                TokenContractConstants.LogEventExternalInfoKey,
                TokenContractConstants.TransferCallbackExternalInfoKey,
                TokenContractConstants.UnlockCallbackExternalInfoKey
            }
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L33-46)
```csharp
    public override Empty Create(CreateInput input)
    {
        var inputSymbolType = GetSymbolType(input.Symbol);
        if (input.Owner == null)
        {
            input.Owner = input.Issuer;
        }
        return inputSymbolType switch
        {
            SymbolType.NftCollection => CreateNFTCollection(input),
            SymbolType.Nft => CreateNFTInfo(input),
            _ => CreateToken(input)
        };
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L48-66)
```csharp
    private Empty CreateToken(CreateInput input, SymbolType symbolType = SymbolType.Token)
    {
        AssertValidCreateInput(input, symbolType);
        if (symbolType == SymbolType.Token || symbolType == SymbolType.NftCollection)
        {
            // can not call create on side chain
            Assert(State.SideChainCreator.Value == null,
                "Failed to create token if side chain creator already set.");
            if (!IsAddressInCreateWhiteList(Context.Sender) &&
                input.Symbol != TokenContractConstants.SeedCollectionSymbol)
            {
                var symbolSeed = State.SymbolSeedMap[input.Symbol.ToUpper()];
                CheckSeedNFT(symbolSeed, input.Symbol);
                // seed nft for one-time use only
                long balance = State.Balances[Context.Sender][symbolSeed];
                DoTransferFrom(Context.Sender, Context.Self, Context.Self, symbolSeed, balance, "");
                Burn(Context.Self, symbolSeed, balance);
            }
        }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L68-79)
```csharp
        var tokenInfo = new TokenInfo
        {
            Symbol = input.Symbol,
            TokenName = input.TokenName,
            TotalSupply = input.TotalSupply,
            Decimals = input.Decimals,
            Issuer = input.Issuer,
            IsBurnable = input.IsBurnable,
            IssueChainId = input.IssueChainId == 0 ? Context.ChainId : input.IssueChainId,
            ExternalInfo = input.ExternalInfo ?? new ExternalInfo(),
            Owner = input.Owner
        };
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L272-283)
```csharp
    private void AssertValidCreateInput(CreateInput input, SymbolType symbolType)
    {
        Assert(input.TokenName.Length <= TokenContractConstants.TokenNameLength
               && input.Symbol.Length > 0
               && input.Decimals >= 0
               && input.Decimals <= TokenContractConstants.MaxDecimals, "Invalid input.");

        CheckSymbolLength(input.Symbol, symbolType);
        if (symbolType == SymbolType.Nft) return;
        CheckTokenAndCollectionExists(input.Symbol);
        if (IsAddressInCreateWhiteList(Context.Sender)) CheckSymbolSeed(input.Symbol);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L322-335)
```csharp
    private void DealWithExternalInfoDuringLocking(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.LockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.LockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L337-350)
```csharp
    private void DealWithExternalInfoDuringTransfer(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.TransferCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.TransferCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L352-365)
```csharp
    private void DealWithExternalInfoDuringUnlock(TransferFromInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo.ExternalInfo == null) return;
        if (tokenInfo.ExternalInfo.Value.ContainsKey(TokenContractConstants.UnlockCallbackExternalInfoKey))
        {
            var callbackInfo =
                JsonParser.Default.Parse<CallbackInfo>(
                    tokenInfo.ExternalInfo.Value[TokenContractConstants.UnlockCallbackExternalInfoKey]);
            Context.SendInline(callbackInfo.ContractAddress, callbackInfo.MethodName, input);
        }

        FireExternalLogEvent(tokenInfo, input);
    }
```

**File:** protobuf/token_contract.proto (L530-533)
```text
message CallbackInfo {
    aelf.Address contract_address = 1;
    string method_name = 2;
}
```
