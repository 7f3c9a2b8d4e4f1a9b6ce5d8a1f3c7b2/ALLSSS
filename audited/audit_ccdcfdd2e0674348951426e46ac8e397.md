### Title
Missing Validation on EncryptedPieces Dictionary Size Enables Consensus DoS and State Bloat

### Summary
The `ExtractInformationToUpdateConsensus` function copies `EncryptedPieces` dictionary entries without size validation, allowing a malicious miner to inject thousands of fake entries. This causes either repeated transaction failures that waste block execution resources (with default 128KB state limit) or permanent state bloat affecting all nodes (if state limits are increased via governance).

### Finding Description

The vulnerability exists in the consensus update flow where `EncryptedPieces` dictionary size is never validated:

**Entry Point:** [1](#0-0) 

The `EncryptedPieces` dictionary is copied directly into `UpdateValueInput` without checking its size.

**Root Cause:** The consensus flow accepts `EncryptedPieces` from miner-controlled `AElfConsensusTriggerInformation` and adds all entries without validation: [2](#0-1) 

Normal operation expects one entry per miner (typically 17-100), as generated by: [3](#0-2) 

However, miners populate this off-chain via their node software: [4](#0-3) 

**Missing Validations:**

1. No count validation in UpdateValueValidationProvider: [5](#0-4) 

2. No validation when processing the input: [6](#0-5) 

3. UpdateValue is marked as size-fee-free, making the attack cheap: [7](#0-6) 

**Protection Mechanisms:**

State size limit (128KB default) provides partial protection: [8](#0-7) 

However, this limit is configurable via governance and can be increased: [9](#0-8) 

### Impact Explanation

**Scenario 1 (Default 128KB State Limit):**
- Malicious miner injects ~789 fake `EncryptedPieces` entries (~166 bytes each)
- Transaction executes through validation and consensus logic
- State write fails with `StateOverSizeException`: [10](#0-9) 
- Block execution time is wasted processing and then rejecting the transaction
- Miner can repeat this attack cheaply (no size fees) to DoS consensus
- All nodes waste CPU/memory resources on failing transactions

**Scenario 2 (Increased State Limit via Governance):**
- If Parliament increases state limit to 5MB: [11](#0-10) 
- Malicious miner successfully writes thousands of fake entries to state
- Round object becomes permanently bloated (stored at): [12](#0-11) 
- All nodes must store and process bloated consensus state
- Round retrieval and consensus operations become slower
- Storage costs increase for all network participants

**Affected Parties:** All network nodes, consensus operations, and chain performance.

### Likelihood Explanation

**High Likelihood:**

1. **Attacker Capability:** Any active miner can modify their node software to inject fake `EncryptedPieces` entries into `AElfConsensusTriggerInformation` before block production.

2. **Low Attack Cost:** `UpdateValue` is `IsSizeFeeFree = true`, so transaction costs are minimal regardless of data size.

3. **No Detection:** No validation checks the `EncryptedPieces` count against the expected number of miners in the round.

4. **Easy Exploitation:** The miner controls the trigger information generation process entirely off-chain.

5. **Repeatable:** Attack can be executed repeatedly in every block the malicious miner produces.

**Attack Prerequisites:**
- Must be an active miner in the consensus (realistic for this threat model)
- Requires modifying node software (trivial for a motivated attacker)

### Recommendation

**1. Add Count Validation in UpdateValueValidationProvider:**

Add validation that `EncryptedPieces.Count` equals the number of miners in the current round. This should be enforced before transaction execution.

**2. Add Key Validation:**

Verify that all keys in `EncryptedPieces` are valid miner public keys from the current round's `RealTimeMinersInformation`.

**3. Add Size Check in UpdateLatestSecretPieces:**

Before adding entries in: [13](#0-12) 

Verify that the count of entries being added matches expectations.

**4. Consider Rate Limiting or Size Fees:**

Re-evaluate whether `UpdateValue` should remain completely size-fee-free, or implement rate limiting for excessive data sizes.

**5. Add Test Cases:**

Create regression tests that attempt to submit `UpdateValue` with inflated `EncryptedPieces` dictionaries and verify they are properly rejected.

### Proof of Concept

**Initial State:**
- Chain running with N active miners (e.g., 17)
- Attacker is an active miner with block production rights

**Attack Steps:**

1. Attacker modifies their node's `AEDPoSTriggerInformationProvider` to bypass `SecretSharingService` and inject 1000 fake entries into `trigger.EncryptedPieces`

2. When attacker's turn to produce block arrives, their modified node generates `AElfConsensusTriggerInformation` with 1000 fake encrypted pieces

3. Contract's `UpdateLatestSecretPieces` adds all 1000 entries to `updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces`

4. `GenerateConsensusTransactions` creates `UpdateValueInput` containing all 1000 entries via: [14](#0-13) 

5. `UpdateValue` transaction executes, passing validation (no count check)

6. `PerformSecretSharing` adds all 1000 entries to state

7. **With default limits:** `TryToUpdateRoundInformation` fails with `StateOverSizeException`, wasting execution resources

8. **With increased limits:** Transaction succeeds, permanently bloating the Round state with 1000 fake entries

**Expected Result:** Transaction should be rejected during validation with "Invalid EncryptedPieces count"

**Actual Result:** Transaction either fails at state write (wasting resources) or succeeds (bloating state), with no validation preventing the attack

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L45-45)
```csharp
            EncryptedPieces = { minerInRound.EncryptedPieces },
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-115)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);

        foreach (var pair in secretSharingInformation.PreviousRound.RealTimeMinersInformation
                     .OrderBy(m => m.Value.Order).ToDictionary(m => m.Key, m => m.Value.Order))
        {
            var pubkey = pair.Key;
            var order = pair.Value;

            var plainMessage = secretShares[order - 1];
            var receiverPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);
            var encryptedPiece = await _accountService.EncryptMessageAsync(receiverPublicKey, plainMessage);
            encryptedPieces[pubkey] = encryptedPiece;
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSTriggerInformationProvider.cs (L104-106)
```csharp
            var secretPieces = _secretSharingService.GetEncryptedPieces(hint.RoundId);
            foreach (var secretPiece in secretPieces)
                trigger.EncryptedPieces.Add(secretPiece.Key, ByteString.CopyFrom(secretPiece.Value));
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-32)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }

    /// <summary>
    ///     Check only one Out Value was filled during this updating.
    /// </summary>
    /// <param name="validationContext"></param>
    /// <returns></returns>
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS1_TransactionFeeProvider.cs (L40-49)
```csharp
        if (new List<string>
            {
                nameof(InitialAElfConsensusContract), nameof(FirstRound), nameof(UpdateValue),
                nameof(UpdateTinyBlockInformation), nameof(NextRound), nameof(NextTerm)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** src/AElf.Kernel.SmartContract/Application/IStateSizeLimitProvider.cs (L27-31)
```csharp
    public Task<int> GetStateSizeLimitAsync(IBlockIndex blockIndex)
    {
        var stateSizeLimit = GetBlockExecutedData(blockIndex)?.Value ?? SmartContractConstants.StateSizeLimit;
        return Task.FromResult(stateSizeLimit);
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/others.rst (L65-70)
```text
State size limit
----------------

- The size of data written to ``State`` would be limited every time. AElf's contract patcher is going to patch the code to validate
  your contract. As a result, you cannot write too big thing to contract and the limit is 128k by default. The limit adjustment is
  governed by ``Parliament``. 
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```
