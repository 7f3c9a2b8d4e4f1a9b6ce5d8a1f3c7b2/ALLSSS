### Title
Integer Division Precision Loss in Alternate Token Fee Conversion Causes Cumulative Fee Undercollection

### Summary
The `ChargeSizeFee` function converts transaction size fees from primary token to alternate tokens using integer division, which systematically rounds down the converted fee amount. This causes users to pay slightly less than the intended fee value when using alternate tokens. Over many transactions, this rounding error accumulates, resulting in significant fee undercollection for the protocol.

### Finding Description

**Root Cause:**
The vulnerability exists in the fee conversion logic at [1](#0-0) . When a user opts to pay transaction fees with an alternate token instead of the primary token (ELF), the system converts the fee amount using the formula:

`txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight).Div(availableSymbol.BaseTokenWeight)`

The `.Div()` operation is a standard integer division that truncates (rounds down) any fractional result [2](#0-1) .

**Execution Path:**
1. Transaction enters `ChargeSizeFee` with a size fee specified in primary token (ELF) [3](#0-2) 
2. System checks if user has sufficient balance in alternate tokens using `GetBalanceCalculatedBaseOnPrimaryToken` [4](#0-3) 
3. If alternate token is selected, fee is converted using the problematic integer division [5](#0-4) 
4. Rounded-down fee is charged via `GenerateBill` [6](#0-5) 
5. User's balance is decreased by the rounded amount [7](#0-6) 

**Why Existing Protections Fail:**
The `SetSymbolsToPayTxSizeFee` function only validates that weights are greater than zero and that the primary token has a 1:1 ratio [8](#0-7) , but does not enforce any constraints to prevent value loss through rounding. The token weight structure itself has no special rounding handling [9](#0-8) .

### Impact Explanation

**Concrete Harm:**
When alternate tokens are used for fee payment with non-trivial weight ratios, the protocol systematically collects less value than intended. For example:
- Fee required: 101 ELF (primary token)
- Alternate token ratio: 7:5 (7 TSA = 5 ELF, per the proto definition where added_token_weight=7, base_token_weight=5)
- Converted fee: 101 × 7 ÷ 5 = 707 ÷ 5 = 141 TSA (integer division)
- Actual value collected: 141 × 5 ÷ 7 = 705 ÷ 7 ≈ 100.71 ELF equivalent
- **Loss per transaction: ~0.29 ELF worth**

**Quantified Damage:**
With 10,000 transactions using this specific ratio and fee amount, the protocol loses approximately 2,900 ELF worth of fees. The loss scales linearly with transaction volume and varies with the weight ratio chosen. Ratios that don't divide evenly exacerbate the issue.

**Affected Parties:**
- The protocol/treasury receives less fee revenue than intended
- The token economics are distorted as fee collection mechanisms underperform
- Legitimate users unknowingly benefit from paying slightly less than intended

**Severity Justification:**
Medium severity is appropriate because: (1) the per-transaction loss is typically small but non-negligible, (2) it occurs automatically in normal operations without requiring attacker sophistication, (3) it accumulates indefinitely, and (4) it represents a systematic value leak rather than a catastrophic single-event loss.

### Likelihood Explanation

**Attacker Capabilities:**
No special attacker capabilities are required. Any regular user transacting on the network who chooses to pay fees with an alternate token will trigger this issue. This is not an "attack" per se, but rather an inherent flaw in normal system operation.

**Attack Complexity:**
Trivial. Users simply execute normal transactions and select alternate tokens for fee payment through the standard transaction fee mechanism defined in the `ChargeTransactionFeesInput` structure.

**Feasibility Conditions:**
- Alternate tokens must be configured with weight ratios (standard protocol feature)
- Users must opt to pay with alternate tokens (common behavior)
- Fee amounts must not divide evenly by the weight ratio (very common, as fees are determined by transaction size)

**Probability:**
High. This occurs automatically for every transaction paid with alternate tokens where the fee amount and ratio create a fractional result. Given that transaction sizes vary and ratios are unlikely to always divide evenly, this affects a significant portion of alternate-token-paid transactions.

### Recommendation

**Code-Level Mitigation:**
Add rounding correction to ensure users pay at least the equivalent value of the intended fee. Modify the fee conversion logic in `ChargeSizeFee`:

```csharp
// After line 403-404, add rounding-up correction:
var expectedValue = txSizeFeeAmount.Mul(availableSymbol.BaseTokenWeight).Div(availableSymbol.AddedTokenWeight);
if (expectedValue < input.TransactionSizeFee) {
    txSizeFeeAmount = txSizeFeeAmount.Add(1); // Round up to ensure equivalent value
}
```

Alternatively, use a more sophisticated approach that calculates the minimum alternate token amount needed to meet or exceed the primary token fee value.

**Invariant Checks:**
Add an assertion after fee conversion to validate that the converted fee, when translated back to primary token equivalent, is at least equal to the original fee:

```csharp
Assert(
    txSizeFeeAmount.Mul(availableSymbol.BaseTokenWeight).Div(availableSymbol.AddedTokenWeight) >= input.TransactionSizeFee,
    "Converted fee value is less than intended fee"
);
```

**Test Cases:**
Add unit tests covering:
1. Fee conversions with various ratios (1:2, 2:3, 5:7, 10:3, etc.)
2. Fee amounts that don't divide evenly by ratios
3. Verification that converted fees maintain value equivalence
4. Edge cases with maximum/minimum fee amounts
5. Accumulation tests simulating many transactions to demonstrate cumulative loss

### Proof of Concept

**Initial State:**
- Primary token: ELF
- Alternate token: TSA configured with `added_token_weight=7, base_token_weight=5` (meaning 7 TSA = 5 ELF)
- User has sufficient TSA balance (e.g., 200 TSA)
- Transaction size fee: 101 ELF

**Transaction Sequence:**
1. User initiates transaction with 101 ELF size fee, selecting TSA as payment token
2. System calls `ChargeSizeFee` which converts: 101 × 7 ÷ 5 = 141 TSA (rounded down from 141.4)
3. System calls `GenerateBill` to charge 141 TSA
4. User's balance decreases by 141 TSA
5. Protocol collects 141 TSA

**Expected vs Actual Result:**
- **Expected:** Protocol collects tokens worth 101 ELF
- **Actual:** Protocol collects 141 TSA worth 141 × 5 ÷ 7 = 100.71 ELF equivalent (in integer terms: 100 ELF)
- **Discrepancy:** ~1 ELF worth lost per transaction

**Success Condition:**
Repeat this transaction 10,000 times. The protocol will have undercollected approximately 10,000 ELF worth of fees, demonstrating the cumulative nature of this vulnerability.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L245-254)
```csharp
        foreach (var (symbol, amount) in bill.FeesMap)
        {
            if (amount <= 0) continue;
            ModifyBalance(fromAddress, symbol, -amount);
            Context.Fire(new TransactionFeeCharged
            {
                Symbol = symbol,
                Amount = amount,
                ChargingAddress = fromAddress
            });
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L375-390)
```csharp
    private bool ChargeSizeFee(ChargeTransactionFeesInput input, Address fromAddress, ref TransactionFeeBill bill,
        TransactionFeeFreeAllowancesMap transactionFeeFreeAllowancesMap,
        ref TransactionFreeFeeAllowanceBill allowanceBill,
        TransactionFeeDelegations delegations = null)
    {

        Context.LogDebug(() => "ChargeSizeFee Start");

        //If delegation != null,from address->delegateeAddress
        // Size Fee is charged in primary token, elf.
        var symbolToPayTxFee = State.ChainPrimaryTokenSymbol.Value;
        //Get primary token balance
        GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
            out var symbolChargedForBaseFee, out var amountChargedForBaseFee, out var amountChargedForBaseAllowance,
            out var availableBalance, out var availableAllowance);
        var txSizeFeeAmount = input.TransactionSizeFee;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L400-408)
```csharp
            if (availableSymbol != null && availableSymbol.TokenSymbol != symbolToPayTxFee)
            {
                symbolToPayTxFee = availableSymbol.TokenSymbol;
                txSizeFeeAmount = txSizeFeeAmount.Mul(availableSymbol.AddedTokenWeight)
                    .Div(availableSymbol.BaseTokenWeight);
                GetAvailableBalance(symbolToPayTxFee, fromAddress, bill, transactionFeeFreeAllowancesMap, allowanceBill,
                    out symbolChargedForBaseFee, out amountChargedForBaseFee, out amountChargedForBaseAllowance,
                    out availableBalance, out availableAllowance);
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L428-429)
```csharp
        GenerateBill(txSizeFeeAmount, symbolToPayTxFee, symbolChargedForBaseFee, availableBalance, availableAllowance,
            ref bill, ref allowanceBill);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L485-486)
```csharp
            var balance = GetBalanceCalculatedBaseOnPrimaryToken(fromAddress, symbolToPlayTxSizeFee,
                symbolChargedForBaseFee, amountChargedForBaseFee);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L630-635)
```csharp
                Assert(tokenWeightInfo.AddedTokenWeight == 1 && tokenWeightInfo.BaseTokenWeight == 1,
                    $"symbol:{tokenWeightInfo.TokenSymbol} weight should be 1");
            }

            Assert(tokenWeightInfo.AddedTokenWeight > 0 && tokenWeightInfo.BaseTokenWeight > 0,
                $"symbol:{tokenWeightInfo.TokenSymbol} weight should be greater than 0");
```

**File:** src/AElf.CSharp.Core/SafeMath.cs (L87-89)
```csharp
    public static long Div(this long a, long b)
    {
        return a / b;
```

**File:** protobuf/token_contract.proto (L496-505)
```text
message SymbolToPayTxSizeFee{
    // The symbol of token. 
    string token_symbol = 1;
    // The charge weight of primary token.
    int32 base_token_weight = 2;
    // The new added token charge weight. For example, the charge weight of primary Token is set to 1. 
    // The newly added token charge weight is set to 10. If the transaction requires 1 unit of primary token, 
    // the user can also pay for 10 newly added tokens.
    int32 added_token_weight = 3;
}
```
