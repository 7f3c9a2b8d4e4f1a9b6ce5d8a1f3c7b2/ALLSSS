# Audit Report

## Title
Missing Temporal Validation for Premature Term Transition in AEDPoS Consensus

## Summary
The `NextTerm` method lacks time-based validation to ensure the term period has elapsed before allowing term transitions. Any miner in the current or previous round can trigger premature term transitions, causing early treasury releases, election snapshot manipulation, and consensus schedule disruption.

## Finding Description

The AEDPoS consensus mechanism allows term transitions through the `NextTerm` method, which should only occur after a designated term period (typically 7 days) has elapsed. However, the validation logic fails to enforce this critical timing constraint.

**Vulnerable Flow:**

The `NextTerm` method is publicly accessible and processes term transitions. [1](#0-0) 

Authorization is performed by `PreCheck()` which only verifies the sender is in the current or previous round miner list, without any temporal validation. [2](#0-1) 

The validation pipeline for `NextTerm` behavior only adds `RoundTerminateValidationProvider`. [3](#0-2) 

This validator only checks that term and round numbers increment correctly, without verifying the term period has elapsed. [4](#0-3) 

**The Critical Missing Check:**

The `NeedToChangeTerm` method exists and correctly validates that at least 2/3 of miners have mined past the term time boundary based on the configured period seconds. [5](#0-4) 

However, this check is only used in `MainChainConsensusBehaviourProvider` to decide which behavior to recommend, not to validate whether `NextTerm` execution should be permitted. [6](#0-5) 

A malicious miner can bypass the advisory `GetConsensusCommand` flow and directly invoke `NextTerm` with a properly structured `NextTermInput`, causing premature term transition.

## Impact Explanation

**Economic Impact:**

When `ProcessNextTerm` executes prematurely, it triggers treasury release before the intended term completion. [7](#0-6) 

The treasury funds are distributed based on the shortened term period, potentially causing incorrect reward allocation across the profit schemes (miner rewards, subsidies, citizen welfare).

**Consensus Integrity Impact:**

The premature term transition takes an election snapshot at the wrong time, recording miner statistics and vote tallies prematurely. [8](#0-7) 

This snapshot determines the next term's miner set and influences election outcomes. The `TakeSnapshot` method in the Election contract saves the current election results and updates term numbers. [9](#0-8) 

Additionally, miner performance statistics (ProducedBlocks, MissedTimeSlots) are reset early, erasing evidence of miner behavior before the intended term end. [10](#0-9) 

**Affected Parties:**
- Network participants experience unpredictable consensus timing
- Treasury beneficiaries receive funds on incorrect schedules  
- Election candidates face manipulated voting periods
- Honest miners lose accountability records prematurely

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be a miner in the current or previous round (achievable through the election process or by being an existing miner)
- Ability to construct a valid `NextTermInput` with the first round of the next term

**Attack Complexity:**
Low. The attacker only needs to:
1. Obtain the current miner list from the Election contract
2. Generate a valid first round structure for the next term using public data
3. Submit a `NextTerm` transaction with the crafted input

The comment in `PreCheck` mentions `ConstrainedAEDPoSTransactionValidationProvider` but this is not implemented in the codebase. [11](#0-10) 

**Detection vs Prevention:**
While the premature term transition would be visible on-chain, the damage occurs immediately upon execution. The treasury release and election snapshot cannot be reversed, and miner statistics are permanently reset.

**Overall Probability:** High - any current miner can exploit this at any time with minimal technical barriers and immediate effect.

## Recommendation

Add temporal validation to the `NextTerm` validation flow by:

1. **Enforce `NeedToChangeTerm` check in validation:** Modify `RoundTerminateValidationProvider.ValidationForNextTerm` to verify that at least 2/3 of miners have mined past the term boundary before allowing term transition.

2. **Retrieve blockchain start timestamp and period seconds** in the validation context to enable the time-based check.

3. **Example fix in `RoundTerminateValidationProvider.cs`:**

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;

    // Check term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };

    // NEW: Enforce temporal validation
    // Requires adding blockchain start timestamp and period seconds to ConsensusValidationContext
    if (!validationContext.BaseRound.NeedToChangeTerm(
        validationContext.BlockchainStartTimestamp, 
        validationContext.BaseRound.TermNumber, 
        validationContext.PeriodSeconds))
    {
        return new ValidationResult { Message = "Term period has not elapsed - cannot change term yet." };
    }

    return new ValidationResult { Success = true };
}
```

This ensures that term transitions can only occur when the time-based condition is met, preventing premature treasury releases and election manipulation.

## Proof of Concept

A proof of concept would demonstrate:

1. Deploy the AEDPoS contract with a configured term period (e.g., 7 days)
2. Initialize the first round with a set of miners
3. Before the term period elapses (e.g., after 3 days), have a current miner:
   - Construct a valid `NextTermInput` with the next term's first round data
   - Call `NextTerm` directly
4. Observe that:
   - The transaction succeeds despite insufficient time elapsed
   - `State.CurrentTermNumber` increments prematurely
   - `TreasuryContract.Release` is called early
   - `ElectionContract.TakeSnapshot` records election results at the wrong time
   - Miner statistics are reset before the intended term end

The test would verify that the term transition occurs without the `NeedToChangeTerm` condition being satisfied, proving the missing temporal validation vulnerability.

## Notes

This vulnerability demonstrates a critical gap between the advisory consensus command generation (which correctly checks `NeedToChangeTerm`) and the validation/execution layer (which does not enforce this check). The design appears to assume miners will follow the recommended behavior from `GetConsensusCommand`, but malicious miners can bypass this by directly calling `NextTerm`.

The impact is particularly severe because:
1. Treasury releases are irreversible once executed
2. Election snapshots determine the next term's miner set
3. Miner performance records are permanently reset
4. The attack can be repeated by any miner in subsequent rounds

The fix requires adding the blockchain start timestamp and period seconds to the validation context, which may require refactoring the validation pipeline to access this state information.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L178-183)
```csharp
        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L203-211)
```csharp
        if (DonateMiningReward(previousRound))
        {
            State.TreasuryContract.Release.Send(new ReleaseInput
            {
                PeriodNumber = termNumber
            });

            Context.LogDebug(() => $"Released treasury profit for term {termNumber}");
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L213-218)
```csharp
        State.ElectionContract.TakeSnapshot.Send(new TakeElectionSnapshotInput
        {
            MinedBlocks = previousRound.GetMinedBlocks(),
            TermNumber = termNumber,
            RoundNumber = previousRound.RoundNumber
        });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L89-91)
```csharp
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L402-457)
```csharp
    public override Empty TakeSnapshot(TakeElectionSnapshotInput input)
    {
        if (State.AEDPoSContract.Value == null)
            State.AEDPoSContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ConsensusContractSystemName);

        Assert(State.AEDPoSContract.Value == Context.Sender, "No permission.");

        SavePreviousTermInformation(input);

        if (State.ProfitContract.Value == null)
        {
            var profitContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ProfitContractSystemName);
            // Return if profit contract didn't deployed. (Often in test cases.)
            if (profitContractAddress == null) return new Empty();
            State.ProfitContract.Value = profitContractAddress;
        }

        // Update snapshot of corresponding voting record by the way.
        State.VoteContract.TakeSnapshot.Send(new TakeSnapshotInput
        {
            SnapshotNumber = input.TermNumber,
            VotingItemId = State.MinerElectionVotingItemId.Value
        });

        State.CurrentTermNumber.Value = input.TermNumber.Add(1);

        var previousTermMinerList =
            State.AEDPoSContract.GetPreviousTermMinerPubkeyList.Call(new Empty()).Pubkeys.ToList();

        foreach (var pubkey in previousTermMinerList)
            UpdateCandidateInformation(pubkey, input.TermNumber, previousTermMinerList);

        if (State.DividendPoolContract.Value == null)
            State.DividendPoolContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TreasuryContractSystemName);

        var symbolList = State.DividendPoolContract.GetSymbolList.Call(new Empty());
        var amountsMap = symbolList.Value.ToDictionary(s => s, s => 0L);
        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.SubsidyHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        State.ProfitContract.DistributeProfits.Send(new DistributeProfitsInput
        {
            SchemeId = State.WelfareHash.Value,
            Period = input.TermNumber,
            AmountsMap = { amountsMap }
        });

        return new Empty();
    }
```
