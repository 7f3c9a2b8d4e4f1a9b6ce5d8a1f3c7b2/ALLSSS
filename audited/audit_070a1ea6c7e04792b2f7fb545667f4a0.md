### Title
FinalOrderOfNextRound Manipulation Enables Complete Consensus Monopolization via Unvalidated TuneOrderInformation

### Summary
An attacker-miner can inject arbitrary `FinalOrderOfNextRound` values through the unvalidated `TuneOrderInformation` field in `UpdateValueInput`, setting all legitimate miners' next-round orders to 0 while maintaining their own valid order. When the next round is generated, legitimate miners are assigned `Order = 0`, making them unable to produce valid blocks, allowing the attacker to monopolize consensus.

### Finding Description
The vulnerability exists in the `ProcessUpdateValue` function where `TuneOrderInformation` is blindly applied without validation. [1](#0-0) 

An attacker-miner can craft a malicious `UpdateValueInput` containing `TuneOrderInformation = {"miner1": 0, "miner2": 0, ...}` for all other miners. This bypasses validation because:

1. **No validation on TuneOrderInformation**: The `UpdateValueValidationProvider` only checks `OutValue` and `PreviousInValue`, never inspecting `TuneOrderInformation` values. [2](#0-1) 

2. **Wrong validation target**: `NextRoundMiningOrderValidationProvider` validates the **provided next round** (where `FinalOrderOfNextRound` defaults to 0 for all new miners), not the **current round** where corruption occurred. [3](#0-2) 

3. **Corrupted round generation**: When `GenerateNextRoundInformation` executes, it directly assigns `Order = minerInRound.FinalOrderOfNextRound` from the corrupted current round. [4](#0-3) 

The attacker ensures their own `FinalOrderOfNextRound` remains valid via line 247 in ProcessUpdateValue: [5](#0-4) 

### Impact Explanation
**Consensus Monopolization**: In the next round, all legitimate miners have `Order = 0`, making their `ExpectedMiningTime` identical (round start time) and invalid for block production. Only the attacker with a valid order (e.g., 1-17) can produce blocks. This results in:

- **100% consensus control**: Attacker produces all blocks in the next round
- **Transaction censorship**: Attacker decides which transactions are included
- **Network halt risk**: If attacker stops mining, network freezes
- **Validator rewards theft**: Attacker captures all block rewards meant for 17+ validators
- **Governance manipulation**: Attacker controls consensus needed for proposal execution

The severity is **CRITICAL** because it completely breaks the distributed consensus invariant that multiple independent validators must participate in block production.

### Likelihood Explanation
**Attack Complexity**: LOW - Only requires being an active miner, which attackers can achieve through:
- Becoming elected as a BP candidate (standard network participation)
- Executing one malicious `UpdateValue` transaction with crafted `TuneOrderInformation`

**Attacker Capabilities**: REALISTIC
- Must be a current miner (has mining permission)
- No additional privileges required
- No economic barriers beyond normal mining requirements

**Detection/Constraints**: 
- Attack is stealthy - `TuneOrderInformation` appears in transaction data but no alerts exist
- Victim miners only discover they cannot mine when next round starts
- No automatic recovery mechanism exists

**Economic Rationality**: HIGHLY PROFITABLE
- Attacker gains 100% of next round's block rewards
- Can censor competitor transactions or extract MEV
- Cost is minimal (one transaction gas fee)

**Probability**: HIGH - Any active malicious miner can execute this attack at any time with near-certain success.

### Recommendation
**Immediate Fix**: Add strict validation on `TuneOrderInformation` in `ProcessUpdateValue`:

```csharp
// After line 258 in ProcessUpdateValue
foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
{
    // Validate tuneOrder.Value is in valid range [1, minersCount]
    if (tuneOrder.Value < 1 || tuneOrder.Value > currentRound.RealTimeMinersInformation.Count)
        Assert(false, $"Invalid FinalOrderOfNextRound {tuneOrder.Value} for {tuneOrder.Key}");
    
    // Ensure no duplicate orders
    if (currentRound.RealTimeMinersInformation.Values.Any(m => 
        m.Pubkey != tuneOrder.Key && m.FinalOrderOfNextRound == tuneOrder.Value))
        Assert(false, $"Duplicate FinalOrderOfNextRound {tuneOrder.Value}");
    
    currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
}
```

**Additional Protections**:
1. Fix `NextRoundMiningOrderValidationProvider` to validate `BaseRound` instead of `ProvidedRound`
2. Add invariant check: All miners with `OutValue != null` must have `FinalOrderOfNextRound > 0`
3. Implement rate-limiting on order modifications per miner

**Test Cases**:
- Reject `UpdateValue` with `TuneOrderInformation` containing zero/negative orders
- Reject `UpdateValue` with duplicate `FinalOrderOfNextRound` values
- Verify next round generation fails if any miner has `Order = 0`

### Proof of Concept
**Initial State**:
- 17 active miners in current round (standard BP count)
- Attacker is miner with pubkey "AttackerPubkey"
- Current round number: N

**Attack Steps**:
1. Attacker generates `UpdateValueInput` with:
   - Normal `OutValue`, `Signature`, `SupposedOrderOfNextRound = 5` (valid value)
   - Malicious `TuneOrderInformation`:
     ```
     {
       "LegitMiner1Pubkey": 0,
       "LegitMiner2Pubkey": 0,
       ...
       "LegitMiner16Pubkey": 0
     }
     ```
   (16 entries, excluding attacker)

2. Attacker calls `UpdateValue(input)` - **Transaction succeeds** (no validation rejects it)

3. State after UpdateValue:
   - `currentRound.RealTimeMinersInformation["LegitMiner1Pubkey"].FinalOrderOfNextRound = 0`
   - (same for all 16 legitimate miners)
   - `currentRound.RealTimeMinersInformation["AttackerPubkey"].FinalOrderOfNextRound = 5`

4. Any miner triggers `NextRound` transition:
   - `GenerateNextRoundInformation` reads corrupted `FinalOrderOfNextRound` values
   - Creates next round with: `Order = 0` for 16 miners, `Order = 5` for attacker

5. Round N+1 persisted to state

**Expected Result**: All 17 miners should have valid distinct orders (1-17) in round N+1

**Actual Result**: 
- 16 legitimate miners have `Order = 0` (invalid)
- Attacker has `Order = 5` (valid)
- Legitimate miners cannot produce blocks (time slot validation fails for Order=0)
- Attacker produces 100% of blocks in round N+1

**Success Condition**: Check round N+1 state shows 16 miners with `Order = 0` and attacker monopolizing block production.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L246-247)
```csharp
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/NextRoundMiningOrderValidationProvider.cs (L14-17)
```csharp
        var providedRound = validationContext.ProvidedRound;
        var distinctCount = providedRound.RealTimeMinersInformation.Values.Where(m => m.FinalOrderOfNextRound > 0)
            .Distinct().Count();
        if (distinctCount != providedRound.RealTimeMinersInformation.Values.Count(m => m.OutValue != null))
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-32)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
```
