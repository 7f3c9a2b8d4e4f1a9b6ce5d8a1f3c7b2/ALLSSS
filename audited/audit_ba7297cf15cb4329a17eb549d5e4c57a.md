### Title
Missing Token Existence Validation Causes Total Election System Failure

### Summary
The Election contract hardcodes token symbols "VOTE" and "SHARE" without validating their existence during initialization. If the Economic contract fails to create these tokens or they are deployed with different symbols, all voting operations fail completely, resulting in a permanent denial-of-service of the election system.

### Finding Description

The Election contract uses hardcoded constants for token symbols: [1](#0-0) 

The `TransferTokensToVoter()` function directly uses these hardcoded symbols to transfer tokens to voters: [2](#0-1) 

This function is called during the critical `Vote()` operation: [3](#0-2) 

The tokens should be created by the Economic contract during initialization: [4](#0-3) 

**Root Cause**: The Election contract's `InitialElectionContract()` method performs NO validation that the required tokens exist: [5](#0-4) 

When tokens don't exist, the TokenContract.Transfer call fails with "Token is not found": [6](#0-5) 

**Deployment Order Risk**: On MainChain, Election deploys 3rd while Economic deploys 14th (last): [7](#0-6) 

While normal MainChain genesis deployment is atomic, custom deployments or test environments may deploy contracts independently.

### Impact Explanation

**Operational Impact**: Complete denial-of-service of the election system. All voting operations fail immediately when `TransferTokensToVoter()` attempts to transfer non-existent tokens. This affects:
- All users attempting to vote for candidates
- Election contract becoming permanently unusable for its core purpose
- Consensus mechanism relying on election results

**Affected Scenarios**:
1. Custom blockchain deployments that skip Economic contract initialization
2. Test environments that deploy Election without full economic system
3. Failed Economic contract initialization where other contracts remain deployed
4. Side chains that don't include Economic contract (by design don't have Election)
5. Version mismatches where constants change between Election and Economic contracts

The system provides no recovery mechanism - if tokens aren't created during genesis, they cannot be added later without contract upgrades.

### Likelihood Explanation

**Attacker Capabilities**: Not an active attack - this is a configuration/deployment vulnerability.

**Feasibility Conditions**:
- **MainChain Standard Deployment**: Very Low - Economic initialization is mandatory in genesis [8](#0-7) 

- **Custom Deployments**: Medium-High - Developers may deploy Election contract in test environments or custom chains without realizing the dependency on Economic contract
- **Initialization Failures**: Low-Medium - If `InitialEconomicSystem` transaction fails but subsequent contracts still deploy

**Detection**: Error only surfaces at runtime when first user attempts to vote, not during deployment. No proactive validation exists.

### Recommendation

**Add Token Existence Validation** in `InitialElectionContract()`:

```csharp
public override Empty InitialElectionContract(InitialElectionContractInput input)
{
    Assert(!State.Initialized.Value, "Already initialized.");
    
    // ADDED: Validate required tokens exist
    State.TokenContract.Value = Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);
    
    var voteTokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = ElectionContractConstants.VoteSymbol 
    });
    Assert(voteTokenInfo != null && !string.IsNullOrEmpty(voteTokenInfo.Symbol), 
        $"Required token {ElectionContractConstants.VoteSymbol} does not exist.");
    
    var shareTokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput 
    { 
        Symbol = ElectionContractConstants.ShareSymbol 
    });
    Assert(shareTokenInfo != null && !string.IsNullOrEmpty(shareTokenInfo.Symbol), 
        $"Required token {ElectionContractConstants.ShareSymbol} does not exist.");
    
    // Existing initialization code...
}
```

**Add Pre-Vote Balance Check** in `Vote()` method before token transfers to provide better error messages.

**Add Test Cases**:
- Test Election contract deployment without Economic contract initialization
- Test voting when tokens don't exist
- Test voting when token balance is insufficient

### Proof of Concept

**Required Initial State**:
1. Deploy Election contract independently (test environment)
2. Call `InitialElectionContract` - succeeds without token validation
3. Do NOT deploy or initialize Economic contract
4. VOTE and SHARE tokens do not exist

**Execution Steps**:
1. User announces candidacy via `AnnounceElection()` - succeeds
2. User attempts to vote via `Vote(VoteMinerInput)`:
   - Locks native tokens successfully
   - Calls `TransferTokensToVoter(amount)` 
   - Iterates through symbols: "SHARE", "VOTE"
   - Calls `State.TokenContract.Transfer.Send()` for "SHARE"
   - TokenContract calls `AssertValidToken("SHARE", amount)`
   - `GetTokenInfo("SHARE")` returns null
   - Assertion fails: "Token is not found. SHARE"
   
**Expected Result**: Vote completes successfully with tokens transferred

**Actual Result**: Transaction fails with "Token is not found. SHARE" - ALL voting operations fail permanently

**Success Condition**: Any deployment where VOTE or SHARE tokens don't exist renders the entire election system unusable, validated by transaction failure on first Vote() attempt.

### Notes

This is a **valid Medium severity vulnerability** because while standard MainChain deployment is protected by atomic genesis block execution, the lack of defensive validation creates risk in:
- Custom blockchain deployments
- Test/development environments  
- Contract upgrade scenarios
- Configuration mismatches between contract versions

The impact is severe (total system failure) but likelihood is reduced by standard deployment procedures, resulting in Medium overall severity.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L7-9)
```csharp
    public const string VoteSymbol = "VOTE";

    public const string ShareSymbol = "SHARE";
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L344-355)
```csharp
    private void TransferTokensToVoter(long amount)
    {
        foreach (var symbol in new List<string>
                     { ElectionContractConstants.ShareSymbol, ElectionContractConstants.VoteSymbol })
            State.TokenContract.Transfer.Send(new TransferInput
            {
                Symbol = symbol,
                To = Context.Sender,
                Amount = amount,
                Memo = $"Transfer {symbol}."
            });
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L441-441)
```csharp
        TransferTokensToVoter(input.Amount);
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L106-136)
```csharp
    private void CreateElectionTokens()
    {
        var lockWhiteListBackups = new List<Address>
        {
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
            Context.GetContractAddressByName(SmartContractConstants.VoteContractSystemName)
        };
        var lockWhiteList = lockWhiteListBackups.Where(address => address != null).ToList();
        foreach (var symbol in new List<string>
                     { EconomicContractConstants.ElectionTokenSymbol, EconomicContractConstants.ShareTokenSymbol })
        {
            State.TokenContract.Create.Send(new CreateInput
            {
                Symbol = symbol,
                TokenName = $"{symbol} Token",
                TotalSupply = EconomicContractConstants.ElectionTokenTotalSupply,
                Decimals = EconomicContractConstants.ElectionTokenDecimals,
                Issuer = Context.Self,
                IsBurnable = true,
                LockWhiteList = { lockWhiteList },
                Owner = Context.Self
            });
            State.TokenContract.Issue.Send(new IssueInput
            {
                Symbol = symbol,
                Amount = EconomicContractConstants.ElectionTokenTotalSupply,
                To = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName),
                Memo = "Issue all election tokens to Election Contract."
            });
        }
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L22-52)
```csharp
    public override Empty InitialElectionContract(InitialElectionContractInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");

        State.Candidates.Value = new PubkeyList();

        State.MinimumLockTime.Value = input.MinimumLockTime;
        State.MaximumLockTime.Value = input.MaximumLockTime;

        State.TimeEachTerm.Value = input.TimeEachTerm;

        State.MinersCount.Value = input.MinerList.Count;
        State.InitialMiners.Value = new PubkeyList
        {
            // ReSharper disable once ConvertClosureToMethodGroup
            Value = { input.MinerList.Select(m => ByteStringHelper.FromHexString(m)) }
        };
        foreach (var pubkey in input.MinerList)
            State.CandidateInformationMap[pubkey] = new CandidateInformation
            {
                Pubkey = pubkey
            };

        State.CurrentTermNumber.Value = 1;

        State.DataCentersRankingList.Value = new DataCenterRankingList();

        State.Initialized.Value = true;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L33-39)
```csharp
    private TokenInfo AssertValidToken(string symbol, long amount)
    {
        AssertValidSymbolAndAmount(symbol, amount);
        var tokenInfo = GetTokenInfo(symbol);
        Assert(tokenInfo != null && !string.IsNullOrEmpty(tokenInfo.Symbol), $"Token is not found. {symbol}");
        return tokenInfo;
    }
```

**File:** src/AElf.Blockchains.MainChain/MainChainContractDeploymentListProvider.cs (L18-34)
```csharp
        return new List<Hash>
        {
            VoteSmartContractAddressNameProvider.Name,
            ProfitSmartContractAddressNameProvider.Name,
            ElectionSmartContractAddressNameProvider.Name,
            TreasurySmartContractAddressNameProvider.Name,
            ParliamentSmartContractAddressNameProvider.Name,
            AssociationSmartContractAddressNameProvider.Name,
            ReferendumSmartContractAddressNameProvider.Name,
            TokenSmartContractAddressNameProvider.Name,
            CrossChainSmartContractAddressNameProvider.Name,
            ConfigurationSmartContractAddressNameProvider.Name,
            ConsensusSmartContractAddressNameProvider.Name,
            TokenConverterSmartContractAddressNameProvider.Name,
            TokenHolderSmartContractAddressNameProvider.Name,
            EconomicSmartContractAddressNameProvider.Name
        };
```

**File:** src/AElf.EconomicSystem/EconomicContractInitializationProvider.cs (L31-62)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>
        {
            new()
            {
                MethodName = nameof(EconomicContractContainer.EconomicContractStub.InitialEconomicSystem),
                Params = new InitialEconomicSystemInput
                {
                    NativeTokenDecimals = _economicOptions.Decimals,
                    IsNativeTokenBurnable = _economicOptions.IsBurnable,
                    NativeTokenSymbol = _economicOptions.Symbol,
                    NativeTokenName = _economicOptions.TokenName,
                    NativeTokenTotalSupply = _economicOptions.TotalSupply,
                    MiningRewardTotalAmount =
                        Convert.ToInt64(_economicOptions.TotalSupply * _economicOptions.DividendPoolRatio),
                    TransactionSizeFeeUnitPrice = _economicOptions.TransactionSizeFeeUnitPrice
                }.ToByteString()
            },
            new()
            {
                MethodName = nameof(EconomicContractContainer.EconomicContractStub.IssueNativeToken),
                Params = new IssueNativeTokenInput
                {
                    Amount = Convert.ToInt64(_economicOptions.TotalSupply * (1 - _economicOptions.DividendPoolRatio)),
                    To = Address.FromPublicKey(
                        ByteArrayHelper.HexStringToByteArray(_consensusOptions.InitialMinerList.First())),
                    Memo = "Issue native token"
                }.ToByteString()
            }
        };
    }
```
