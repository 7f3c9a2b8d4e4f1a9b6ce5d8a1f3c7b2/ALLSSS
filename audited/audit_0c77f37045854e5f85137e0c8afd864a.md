### Title
Missing UpdateValue Uniqueness Check Allows Mining Order Manipulation

### Summary
The `UpdateValueValidationProvider.ValidateHeaderInformation()` only verifies that OutValue/Signature fields are non-empty in the provided block header, but fails to check whether these values have already been set in the current round state. This allows a malicious miner to invoke `UpdateValue` multiple times within the same round with different InValues, overwriting their OutValue and Signature to manipulate their mining order in the next round.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The validation only checks that the provided round contains non-empty OutValue/Signature fields, but does not verify against the base round (current state) whether OutValue has already been published for this miner in the current round.

**Missing Check:**
The validation should verify that `validationContext.BaseRound.RealTimeMinersInformation[publicKey].OutValue == null` to ensure UpdateValue is only called once per round. The consensus behavior logic in `ConsensusBehaviourProviderBase` expects OutValue to be null for the first block (UpdateValue) and non-null for subsequent blocks (TinyBlock): [2](#0-1) 

**Processing Without Protection:**
When `ProcessUpdateValue` executes, it unconditionally overwrites the OutValue and Signature: [3](#0-2) 

The only protection is `EnsureTransactionOnlyExecutedOnceInOneBlock` which prevents multiple calls per block, not per round: [4](#0-3) 

**Order Calculation Vulnerability:**
The Signature value directly determines the mining order in the next round through modulo arithmetic: [5](#0-4) 

### Impact Explanation

**Consensus Integrity Compromise:**
- A malicious miner can produce multiple blocks with UpdateValue behavior (instead of TinyBlock) within their time slot in the same round
- Each UpdateValue call with a different InValue generates a different Signature value
- The miner can calculate which InValue produces the most favorable Signature (via `signature.ToInt64() % minersCount + 1`) for optimal mining order in the next round
- This breaks the fairness guarantee of the VRF-based mining order determination

**Concrete Manipulation:**
- With N miners, mining order ranges from 1 to N
- An attacker producing M blocks per round gets M attempts to optimize their order
- Expected improvement: attacker can improve their position from average N/2 to approximately N/M
- With 21 miners and 8 blocks per time slot, attacker could consistently achieve top 3 positions

**Who is Affected:**
- All honest miners suffer reduced mining opportunities and rewards
- Network decentralization is compromised as attackers gain disproportionate block production
- Long-term: consensus security degrades as mining becomes predictably manipulable

### Likelihood Explanation

**Attacker Capabilities:**
- Requires being an authorized miner (realistic for blockchain validators)
- Must control block production during their time slot (inherent miner capability)
- Can craft consensus extra data with arbitrary InValues

**Attack Complexity:**
- Low: Simply call `GetConsensusExtraData` with different InValues for each block
- No need to compromise other miners or protocol parameters
- Attack is fully within normal transaction execution paths

**Detection Constraints:**
- Attack is publicly visible on-chain (multiple UpdateValue transactions from same miner)
- However, current validation accepts this as valid behavior
- No automated detection or prevention mechanism exists

**Economic Rationality:**
- Cost: Standard transaction fees for multiple blocks (minimal)
- Benefit: Improved mining order → more block rewards → higher revenue
- Attack is economically profitable for rational miners

### Recommendation

**Add State-Based Validation:**
Modify `UpdateValueValidationProvider.ValidateHeaderInformation()` to check the base round state:

```csharp
private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
{
    // Check if OutValue is already set in base round (state)
    if (validationContext.BaseRound.RealTimeMinersInformation.ContainsKey(validationContext.SenderPubkey))
    {
        var baseRoundMiner = validationContext.BaseRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        if (baseRoundMiner.OutValue != null && baseRoundMiner.OutValue.Value.Any())
        {
            return false; // OutValue already published this round
        }
    }
    
    // Check provided round has new values
    var minerInRound = validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
    return minerInRound.OutValue != null && minerInRound.Signature != null &&
           minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
}
```

**Add Behavior Verification:**
Implement validation that verifies the consensus behavior matches the expected behavior based on current state, preventing miners from arbitrarily choosing UpdateValue when TinyBlock is expected.

**Test Cases:**
1. Verify UpdateValue succeeds when OutValue is null (first block)
2. Verify UpdateValue fails when OutValue is already set (subsequent blocks)
3. Verify TinyBlock succeeds for subsequent blocks after UpdateValue
4. Test that multiple UpdateValue attempts in same round are rejected

### Proof of Concept

**Initial State:**
- Round 100 active with 21 miners
- Attacker is authorized miner with Order 10, time slot from T to T+80 seconds
- Attacker has not yet mined in round 100 (OutValue is null)

**Attack Steps:**

1. **Block 1 at T+5**: 
   - Call UpdateValue with InValue1 = Hash("secret1")
   - Generates OutValue1 = Hash(InValue1), Signature1 = calculated from InValue1
   - Signature1.ToInt64() % 21 + 1 = 15 (suboptimal order)
   - State updated: OutValue = OutValue1, Signature = Signature1

2. **Block 2 at T+15**:
   - Call UpdateValue again (should be TinyBlock) with InValue2 = Hash("secret2")
   - Generates OutValue2 = Hash(InValue2), Signature2 = calculated from InValue2  
   - Signature2.ToInt64() % 21 + 1 = 3 (optimal order)
   - Validation passes (only checks OutValue2/Signature2 are non-empty)
   - State overwritten: OutValue = OutValue2, Signature = Signature2

3. **Block 3-8 at T+25 to T+75**:
   - Produce as TinyBlock (or more UpdateValue for further optimization)

**Expected vs Actual Result:**
- **Expected**: Second UpdateValue should fail validation, forcing TinyBlock behavior
- **Actual**: Second UpdateValue succeeds, overwrites Signature, achieves Order 3 in next round instead of Order 15

**Success Condition:**
Attacker's order in Round 101 is determined by final Signature2 value (Order 3), demonstrating successful manipulation from original Signature1 outcome (Order 15).

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L27-33)
```csharp
    private bool NewConsensusInformationFilled(ConsensusValidationContext validationContext)
    {
        var minerInRound =
            validationContext.ProvidedRound.RealTimeMinersInformation[validationContext.SenderPubkey];
        return minerInRound.OutValue != null && minerInRound.Signature != null &&
               minerInRound.OutValue.Value.Any() && minerInRound.Signature.Value.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L48-56)
```csharp
            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L23-23)
```csharp
        EnsureTransactionOnlyExecutedOnceInOneBlock();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L242-248)
```csharp
        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
