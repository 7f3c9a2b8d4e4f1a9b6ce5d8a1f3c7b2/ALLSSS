### Title
Authorization Bypass in Contract Update Proposals for Non-Whitelisted Deployments

### Summary
The `AssertAuthorityByContractInfo` function allows any address to propose contract updates when `contractInfo.Author == Context.Self`, which occurs for all contracts deployed by non-whitelisted proposers. This authorization bypass enables attackers to modify contracts they don't own, requiring only governance approval rather than original author permission.

### Finding Description
The vulnerability exists in the authorization logic for contract updates across multiple functions:

**Root Cause - Author Assignment Logic:**
When a non-whitelisted proposer deploys a contract, the `DecideNonSystemContractAuthor` function sets the contract author to `Context.Self` (the Genesis contract address) instead of the actual proposer. [1](#0-0) 

The logic returns `Context.Self` when the proposer is not in the deployment whitelist, bypassing the intended author assignment.

**Vulnerability - Permissive Authorization Check:**
The `AssertAuthorityByContractInfo` function uses an OR condition that passes if EITHER the contract's author equals `Context.Self` OR the provided address equals the contract's author. [2](#0-1) 

**Exploitation Path:**
When `ProposeUpdateContract` is called, it validates authority using this flawed check: [3](#0-2) 

For contracts with `Author = Context.Self`, the first condition `contractInfo.Author == Context.Self` evaluates to TRUE, allowing ANY sender to pass the authorization check regardless of the second condition.

**Contract Deployment Flow:**
The vulnerable deployment path occurs through `DeploySmartContract`: [4](#0-3) 

The author is determined by `DecideNonSystemContractAuthor`, which sets it to `Context.Self` for non-whitelisted proposers.

**Update Execution:**
When the update proposal is approved and `UpdateSmartContract` is executed, the secondary check is bypassed: [5](#0-4) 

The `TryClearContractProposingData` returns true for approved proposals, causing the `Context.Sender == info.Author` check on line 332 to be skipped entirely.

**Existing Protections Fail:**
The internal `UpdateSmartContract` helper contains a permission check, but it's ineffective: [6](#0-5) 

The check on line 102 compares `author` parameter against `info.Author`, but since the caller passes `info.Author` as the author parameter (line 334), this check always passes: `Assert(info.Author == info.Author)`.

### Impact Explanation
**Authorization Bypass:** Any user can propose updates to contracts deployed by non-whitelisted proposers, completely bypassing the intended author-only restriction. This violates the fundamental security invariant that only contract authors should control their contracts.

**Contract Integrity Compromise:** Attackers can inject malicious code into legitimate contracts, potentially:
- Stealing funds held by the contract
- Manipulating contract logic to benefit the attacker
- Breaking integrations with other contracts
- Disrupting protocol operations

**Affected Contracts:** ALL contracts deployed through `ProposeNewContract` by users not in the deployment whitelist are vulnerable. This could include numerous third-party contracts and protocol extensions.

**Severity Justification:** CRITICAL - This is a fundamental authorization bypass that subverts the core security model. While governance approval is still required, attackers with sufficient voting power or social engineering capabilities can exploit this to take control of arbitrary contracts.

### Likelihood Explanation
**Reachable Entry Point:** The `ProposeNewContract` function has no active authorization check (line 124 is commented out): [7](#0-6) 

Any user can propose contract deployments, making vulnerable contracts easily deployable.

**Attacker Capabilities Required:**
1. Ability to create governance proposals (available to all users)
2. Sufficient voting power or social engineering to get proposals approved
3. Basic understanding of the contract system

**Attack Complexity:** MODERATE - The attacker must:
1. Identify contracts with `Author = Context.Self` (observable on-chain)
2. Craft malicious contract code
3. Submit update proposal via `ProposeUpdateContract`
4. Obtain governance approval (either through voting power or convincing legitimate voters)

**Feasibility Conditions:**
- Contracts must be deployed by non-whitelisted proposers (common case)
- Attacker needs governance voting influence (feasible for well-funded attackers or through social engineering)
- No additional runtime protections exist beyond governance voting

**Detection Constraints:** The vulnerability is difficult to detect as:
- Proposals appear legitimate to governance voters
- The authorization check passes without raising errors
- No audit trail indicates the proposer lacks proper authority

### Recommendation
**Primary Fix - Strengthen Authorization Check:**
Modify `AssertAuthorityByContractInfo` to only allow `Context.Self` as the actual sender, not just as the author:

```csharp
private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
{
    Assert(Context.Sender == Context.Self && contractInfo.Author == Context.Self || 
           address == contractInfo.Author, "No permission.");
}
```

This ensures the Genesis contract itself can update contracts (for system operations), but prevents regular users from exploiting the `Author = Context.Self` condition.

**Alternative Fix - Correct Author Assignment:**
Modify `DecideNonSystemContractAuthor` to set a dedicated "system-managed" author address instead of `Context.Self`, or always set the actual proposer as author:

```csharp
private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
{
    if (!State.ContractDeploymentAuthorityRequired.Value)
        return sender;
    
    // Always return the proposer, don't use Context.Self
    return proposer;
}
```

**Invariant Check to Add:**
Add an explicit check in `ProposeUpdateContract` that verifies the sender is either the contract author or the Genesis contract itself:

```csharp
Assert(Context.Sender == info.Author || Context.Sender == Context.Self, "No permission.");
```

**Test Cases:**
1. Test that non-whitelisted proposer contracts cannot be updated by third parties
2. Test that contracts with `Author = Context.Self` can only be updated by Genesis contract
3. Test that author transfers properly update authorization
4. Regression test ensuring legitimate updates still work

### Proof of Concept
**Initial State:**
- Chain has `ContractDeploymentAuthorityRequired = true`
- Attacker (0xAttacker) is NOT in deployment proposer whitelist
- Attacker has sufficient governance voting power or can influence voters

**Attack Sequence:**

1. **Deploy Vulnerable Contract:**
   - Attacker calls `ProposeNewContract` with contract bytecode
   - Governance approves deployment proposal
   - Code check controller approves
   - `DeploySmartContract` executes with `DecideNonSystemContractAuthor(0xAttacker, CodeCheckController)`
   - Function returns `Context.Self` because 0xAttacker not in whitelist
   - Contract deployed at address 0xTarget with `Author = Context.Self`

2. **Verify Vulnerable State:**
   - Call `GetContractInfo(0xTarget)` 
   - Returns: `{ Author: Context.Self, ... }`
   - Contract is now vulnerable to unauthorized updates

3. **Exploit - Propose Malicious Update:**
   - Attacker (or any user) calls `ProposeUpdateContract({ Address: 0xTarget, Code: <malicious bytecode> })`
   - `AssertAuthorityByContractInfo(info, 0xAttacker)` executes
   - Check evaluates: `Context.Self == Context.Self || 0xAttacker == Context.Self`
   - Result: `TRUE || FALSE = TRUE` âœ“ Authorization passes
   - Update proposal created successfully

4. **Get Approval:**
   - Attacker uses voting power to approve deployment proposal
   - Attacker uses voting power to approve code check proposal
   - Proposals pass governance voting

5. **Execute Exploit:**
   - `UpdateSmartContract` is called
   - `TryClearContractProposingData` returns true (proposal exists)
   - Author check on line 332 is skipped
   - Contract at 0xTarget updated with malicious code

**Expected vs Actual Result:**
- **Expected:** Only original deployer (0xAttacker) should be able to propose updates
- **Actual:** ANY address can propose updates because authorization check is bypassed
- **Success Condition:** Attacker successfully updates contract they don't own, confirmed by `CodeUpdated` event with attacker as proposer but contract having different original deployer

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L98-103)
```csharp
    private void UpdateSmartContract(Address contractAddress, byte[] code, Address author, bool isUserContract)
    {
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        Assert(author == info.Author, "No permission.");

```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L241-244)
```csharp
    private void AssertAuthorityByContractInfo(ContractInfo contractInfo, Address address)
    {
        Assert(contractInfo.Author == Context.Self || address == contractInfo.Author, "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L257-266)
```csharp
    private Address DecideNonSystemContractAuthor(Address proposer, Address sender)
    {
        if (!State.ContractDeploymentAuthorityRequired.Value)
            return sender;

        var contractDeploymentController = State.ContractDeploymentController.Value;
        var isProposerInWhiteList = ValidateProposerAuthority(contractDeploymentController.ContractAddress,
            contractDeploymentController.OwnerAddress, proposer);
        return isProposerInWhiteList ? proposer : Context.Self;
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L122-128)
```csharp
    public override Hash ProposeNewContract(ContractDeploymentInput input)
    {
        // AssertDeploymentProposerAuthority(Context.Sender);
        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        AssertContractNotExists(codeHash);
        var proposedContractInputHash = CalculateHashFromInput(input);
        RegisterContractProposingData(proposedContractInputHash);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L180-183)
```csharp
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        Assert(info != null, "Contract not found.");
        AssertAuthorityByContractInfo(info, Context.Sender);
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L309-321)
```csharp
    public override Address DeploySmartContract(ContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        // AssertDeploymentProposerAuthority(Context.Origin);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address =
            DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
                DecideNonSystemContractAuthor(contractProposingInput?.Proposer, Context.Sender), false,
                input.ContractOperation?.Deployer, input.ContractOperation?.Salt);
        return address;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L324-337)
```csharp
    public override Address UpdateSmartContract(ContractUpdateInput input)
    {
        var contractAddress = input.Address;
        var info = State.ContractInfos[contractAddress];
        RequireSenderAuthority(State.CodeCheckController.Value?.OwnerAddress);
        var inputHash = CalculateHashFromInput(input);

        if (!TryClearContractProposingData(inputHash, out _))
            Assert(Context.Sender == info.Author, "No permission.");

        UpdateSmartContract(contractAddress, input.Code.ToByteArray(), info.Author, false);

        return contractAddress;
    }
```
