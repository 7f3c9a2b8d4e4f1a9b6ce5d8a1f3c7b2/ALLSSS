### Title
Unbounded Iteration in Cross-Chain Proposal Status Query Causes Execution Timeout Risk

### Summary
The `GetIndexingProposalStatus()` function iterates through all pending cross-chain indexing proposals without pagination or limits, making a cross-contract call for each proposal. As the number of side chains grows, this unbounded iteration can cause execution timeouts, rendering the view function unusable and potentially blocking the cross-chain indexing mechanism through the cleanup function that shares the same iteration pattern.

### Finding Description

The vulnerability exists in the `GetIndexingProposalStatus()` view function which iterates through all proposals in `ChainIndexingProposalCollections.Values`: [1](#0-0) 

For each proposal, the function makes a cross-contract `Context.Call` to retrieve proposal information from the authorization contract. The number of iterations equals the number of chains with active proposals.

**Root Cause:**
The system allows unlimited side chain creation (only governance-gated, no hard cap), with each chain supporting one indexing proposal at a time: [2](#0-1) 

The proposal collection is defined as a map with chain ID as key: [3](#0-2) 

**Why Protections Fail:**

1. No pagination or batch limits on iteration
2. Proposals expire after 120 seconds, but this doesn't prevent accumulation during active indexing periods: [4](#0-3) 

3. The cleanup function `ClearCrossChainIndexingProposalIfExpired()` that runs before new proposals also has the same unbounded iteration issue: [5](#0-4) 

4. Side chain creation is governed but not capped: [6](#0-5) 

### Impact Explanation

**Operational DOS Impact:**

1. **View Function Unusable**: When hundreds of side chains exist with active proposals, calling `GetIndexingProposalStatus()` will timeout due to AElf's execution time limits, preventing any party from querying proposal status.

2. **Indexing Mechanism Blocked**: The cleanup function is called before proposing new cross-chain indexing data: [7](#0-6) 

If the cleanup times out due to too many proposals, miners cannot create new indexing proposals, effectively halting the cross-chain synchronization mechanism.

**Affected Parties:**
- Indexers and monitoring systems relying on proposal status queries
- Miners attempting to propose cross-chain indexing data
- All cross-chain operations dependent on timely indexing

**Severity Justification:** Medium - while this doesn't directly steal funds or compromise governance, it causes operational DOS of a critical cross-chain functionality as the system naturally scales.

### Likelihood Explanation

**Preconditions:**
- Multiple side chains must exist (requires governance approval for each)
- Each chain has proposed indexing data within the 120-second expiration window

**Feasibility:**
The vulnerability becomes more likely as the ecosystem grows naturally:
- Each side chain creation requires governance approval (slow but intentional growth)
- Once 100+ side chains exist, the risk materializes during normal operations
- No malicious actor needed - normal miner activity creates proposals
- Natural accumulation during periods of high cross-chain activity

**Attack Complexity:** Low (once preconditions met)
- Anyone can call the view function to trigger the timeout
- Miners trigger the cleanup automatically when proposing new data

**Economic Rationality:**
- No direct cost to trigger (view function is free to call)
- Creating side chains is expensive and governance-gated (not economically viable as pure attack)
- But natural system growth creates the vulnerability over time

**Probability:** Medium - requires significant ecosystem growth (100+ chains) but becomes inevitable as the system scales to its intended capacity.

### Recommendation

**1. Implement Pagination:**
Add pagination parameters to `GetIndexingProposalStatus()`:

```csharp
public override GetIndexingProposalStatusOutput GetIndexingProposalStatus(
    GetIndexingProposalStatusInput input) // Add input with skip/take parameters
{
    var res = new GetIndexingProposalStatusOutput();
    var pendingCrossChainIndexingProposal = State.IndexingPendingProposal.Value;
    if (pendingCrossChainIndexingProposal == null)
        return res;

    var skip = input.Skip;
    var take = Math.Min(input.Take, MaxProposalsPerQuery); // e.g., 50
    var proposals = pendingCrossChainIndexingProposal.ChainIndexingProposalCollections
        .Values.Skip(skip).Take(take);
    
    // ... existing iteration logic
}
```

**2. Add Batch Limits to Cleanup:**
Modify `ClearCrossChainIndexingProposalIfExpired()` to process in batches or add early exit conditions:

```csharp
private void ClearCrossChainIndexingProposalIfExpired()
{
    // ... existing code
    var processedCount = 0;
    const int maxProcessPerCall = 50;
    
    foreach (var chainId in crossChainIndexingProposal.ChainIndexingProposalCollections.Keys.ToList())
    {
        if (processedCount >= maxProcessPerCall) break;
        // ... existing cleanup logic
        processedCount++;
    }
}
```

**3. Consider Side Chain Limit:**
Add a governance-configurable maximum number of active side chains to prevent unbounded growth.

**4. Add Monitoring:**
Emit events when proposal count exceeds thresholds (e.g., 50, 100) for operational awareness.

### Proof of Concept

**Initial State:**
1. 150 side chains have been created and are active
2. Within a 2-minute window, miners have proposed indexing data for all 150 chains
3. All proposals are pending (not yet released or expired)

**Execution Steps:**

1. **Trigger View Function DOS:**
   - Any user calls `GetIndexingProposalStatus()`
   - Function iterates through all 150 proposals
   - Each iteration makes a `Context.Call` to authorization contract
   - Total execution time exceeds AElf's transaction execution time limit
   - Transaction times out, function becomes unusable

2. **Trigger Indexing Mechanism DOS:**
   - A miner calls `ProposeCrossChainIndexing()` to propose new indexing data
   - Function first calls `ClearCrossChainIndexingProposalIfExpired()`
   - Cleanup iterates through all 150 proposals, checking expiration via cross-contract calls
   - Cleanup times out before completing
   - `ProposeCrossChainIndexing()` transaction fails
   - No new indexing proposals can be created

**Expected Result:** Functions execute successfully

**Actual Result:** Functions timeout due to unbounded iteration, causing DOS of cross-chain indexing mechanism

**Success Condition:** Transaction execution times out when proposal count exceeds ~100-200 (exact threshold depends on AElf's execution time limits and cross-contract call overhead)

### Citations

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_View.cs (L169-184)
```csharp
        foreach (var chainIndexingProposal in pendingCrossChainIndexingProposal.ChainIndexingProposalCollections.Values)
        {
            var pendingChainIndexingProposalStatus = new PendingChainIndexingProposalStatus();
            var proposalInfo = Context.Call<ProposalOutput>(crossChainIndexingController.ContractAddress,
                nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.GetProposal),
                chainIndexingProposal.ProposalId);
            pendingChainIndexingProposalStatus.Proposer = chainIndexingProposal.Proposer;
            pendingChainIndexingProposalStatus.ProposalId = chainIndexingProposal.ProposalId;
            pendingChainIndexingProposalStatus.ToBeReleased =
                proposalInfo.ToBeReleased &&
                proposalInfo.OrganizationAddress == crossChainIndexingController.OwnerAddress;
            pendingChainIndexingProposalStatus.ExpiredTime = proposalInfo.ExpiredTime;
            pendingChainIndexingProposalStatus.ProposedCrossChainBlockData =
                chainIndexingProposal.ProposedCrossChainBlockData;
            res.ChainIndexingProposalStatus[chainIndexingProposal.ChainId] = pendingChainIndexingProposalStatus;
        }
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L395-395)
```csharp
            Assert(!TryGetIndexingProposal(chainId, out _), "Chain indexing already proposed.");
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Helper.cs (L568-574)
```csharp
        foreach (var chainId in crossChainIndexingProposal.ChainIndexingProposalCollections.Keys.ToList())
        {
            var indexingProposal = crossChainIndexingProposal.ChainIndexingProposalCollections[chainId];
            var isExpired = CheckProposalExpired(GetCrossChainIndexingController(), indexingProposal.ProposalId);
            if (isExpired)
                ResetChainIndexingProposal(chainId);
        }
```

**File:** protobuf/cross_chain_contract.proto (L132-135)
```text
message ProposedCrossChainIndexing{
    // The collection of chain indexing proposal, the key is chain id.
    map<int32, ChainIndexingProposal> chain_indexing_proposal_collections = 1;
}
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract_Constants.cs (L5-5)
```csharp
    private const int CrossChainIndexingProposalExpirationTimePeriod = 120;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L135-136)
```csharp
        State.SideChainSerialNumber.Value = State.SideChainSerialNumber.Value.Add(1);
        var serialNumber = State.SideChainSerialNumber.Value;
```

**File:** contract/AElf.Contracts.CrossChain/CrossChainContract.cs (L287-287)
```csharp
        ClearCrossChainIndexingProposalIfExpired();
```
