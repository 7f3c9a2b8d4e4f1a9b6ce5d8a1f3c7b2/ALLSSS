### Title
Unprotected Initialization Function Enables Manager Control Hijacking During System Deployment

### Summary
The `InitialMiningRewardProfitItem()` function lacks access control, allowing any caller to execute it once before legitimate initialization. If invoked before the Election contract is deployed and registered, the manager transfer for SubsidyHash and WelfareHash schemes fails silently, permanently locking these schemes under Treasury management instead of Election control, breaking the election reward distribution system. [1](#0-0) 

### Finding Description

The vulnerability exists in `InitialMiningRewardProfitItem()` which performs critical one-time initialization to transfer profit scheme management rights. The function has three critical flaws:

**1. Missing Access Control:**
The function is publicly accessible with no sender authorization check, only verifying one-time execution via state flag. [2](#0-1) 

**2. Silent Failure on Null Address:**
When `GetContractAddressByName` returns null (Election contract not yet registered), the conditional check causes manager transfer to be skipped without error, leaving schemes under Treasury control. [3](#0-2) 

**3. Irreversible State Lock:**
Once called, the function cannot execute again. Treasury contract provides no alternative method to transfer manager rights, requiring contract upgrade for remediation.

**Execution Path:**
1. Attacker monitors for `InitialTreasuryContract` transaction (creates 7 schemes with Treasury as manager)
2. Before Election contract deployment/registration, attacker calls `InitialMiningRewardProfitItem`
3. `GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)` returns null
4. Manager transfer skipped, SubsidyHash and WelfareHash remain under Treasury control
5. State flag set, function permanently locked
6. Later Election contract deployment cannot obtain required manager role

**Downstream Impact:**
The Election contract requires manager role to add/remove beneficiaries for voter welfare and candidate subsidies: [4](#0-3) [5](#0-4) 

The Profit contract enforces manager-only access for these operations: [6](#0-5) 

Additionally, the Economic contract initialization expects these schemes under Election management: [7](#0-6) 

When schemes remain under Treasury, this query returns empty/incorrect results, breaking economic system initialization.

### Impact Explanation

**Operational Disruption:**
- Election contract cannot add voters as welfare beneficiaries → voters receive no staking rewards
- Election contract cannot add candidates to subsidy scheme → candidates receive no backup rewards
- Core election incentive mechanism completely broken
- Economic contract initialization fails or uses incorrect scheme IDs

**Affected Parties:**
- All network voters expecting welfare rewards from locked tokens
- All candidate node operators expecting subsidy payments
- Network governance relying on functioning election incentives

**Severity Justification:**
While not direct fund theft, this breaks a critical economic subsystem. The election reward distribution represents a significant portion of network incentives. Though recoverable via contract upgrade, this requires:
- Governance proposal and voting delay
- Contract redeployment and migration
- Service disruption during remediation
- Potential loss of user confidence

This constitutes a HIGH severity operational denial-of-service against the election subsystem.

### Likelihood Explanation

**Attacker Capabilities:**
- No special privileges required
- Single transaction call to public function
- Gas cost negligible (standard function call)

**Attack Complexity:**
LOW - Attacker only needs to:
1. Monitor mempool for `InitialTreasuryContract` transaction
2. Submit `InitialMiningRewardProfitItem` transaction before legitimate caller
3. No complex state manipulation or multi-step coordination required

**Feasibility Conditions:**
Attack succeeds if:
- System initialization uses separate transactions (not atomic genesis block deployment)
- Time window exists between Treasury and Election contract initialization
- Attacker has faster transaction propagation than legitimate initializer

**Probability Assessment:**
MEDIUM - Likelihood depends on deployment process:
- If contracts initialized atomically in genesis block → NOT exploitable
- If contracts deployed via separate transactions → HIGHLY exploitable
- Many blockchain systems use multi-step deployment for complex systems
- Front-running during initialization is a known attack vector

**Economic Rationality:**
Griefing attack with asymmetric cost/damage ratio:
- Attacker cost: Single transaction fee (~0.1 ELF)
- Protocol damage: Complete election subsystem failure requiring upgrade
- Motivation: Competitor sabotage, ransom demands, or network disruption

### Recommendation

**Immediate Fix:**
Add authorization check restricting caller to expected initializer:

```solidity
public override Empty InitialMiningRewardProfitItem(Empty input)
{
    // Add this check before line 82
    Assert(Context.Sender == Context.GetContractAddressByName(
        SmartContractConstants.EconomicContractSystemName) ||
        Context.Sender == Context.GetZeroSmartContractAddress(),
        "Only authorized initializer can call this function.");
    
    Assert(State.TreasuryHash.Value == null, "Already initialized.");
    // ... rest of function
}
```

**Alternative Mitigation:**
Add assertion that Election contract must exist:

```solidity
var electionContractAddress = 
    Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
Assert(electionContractAddress != null, 
    "Election contract must be registered before initialization.");
```

**Defensive Addition:**
Provide emergency recovery function (governance-controlled):

```solidity
public override Empty EmergencyResetSchemeManager(EmergencyResetInput input)
{
    AssertPerformedByTreasuryController();
    State.ProfitContract.ResetManager.Send(new ResetManagerInput
    {
        SchemeId = input.SchemeId,
        NewManager = input.NewManager
    });
    return new Empty();
}
```

**Testing Requirements:**
1. Verify initialization functions only callable by authorized addresses
2. Test initialization order dependencies explicitly
3. Add integration test for complete system initialization sequence
4. Verify Election contract can manage schemes post-initialization

### Proof of Concept

**Initial State:**
- Treasury contract deployed
- Profit contract deployed and referenced
- Election contract NOT yet deployed/registered

**Attack Sequence:**

1. **System calls InitialTreasuryContract:**
   - Creates 7 profit schemes with Treasury as manager
   - Schemes [2] = SubsidyHash, [3] = WelfareHash

2. **Attacker front-runs InitialMiningRewardProfitItem:**
   ```
   TreasuryContract.InitialMiningRewardProfitItem()
   ```

3. **Function executes:**
   - Line 98-99: `GetContractAddressByName(ElectionContract)` returns null
   - Line 100: Conditional check fails
   - Lines 102-111: ResetManager calls NOT executed
   - Line 90-96: State variables set, function locked

4. **System deploys Election contract**

5. **System calls Economic.SetTreasurySchemeIds:**
   - Line 196-200: Queries schemes managed by Election
   - Expected: SubsidyHash, WelfareHash
   - Actual: Empty or wrong schemes (still managed by Treasury)
   - Result: Wrong scheme IDs stored OR index out of bounds error

6. **Voter attempts to vote:**
   - Election.Vote calls AddBeneficiary on WelfareHash
   - Profit contract checks: `Context.Sender == scheme.Manager`
   - Election is NOT manager (Treasury is)
   - Transaction reverts with "Only manager can add beneficiary"

**Expected Result:** 
Election contract successfully manages SubsidyHash and WelfareHash, voters receive rewards.

**Actual Result:** 
Treasury retains management, Election calls fail, election reward system is non-functional.

**Success Condition for Attack:** 
Election contract unable to add beneficiaries, confirmed by transaction revert when attempting voter reward registration.

### Notes

The "malicious address" scenario mentioned in the original question is NOT realistic, as it would require compromising the system contract name resolution mechanism itself (broader infrastructure attack). The actual exploitable vulnerability is the **timing attack during null address state**, where calling the function before Election is ready permanently misconfigures the system. Recovery requires governance-approved contract upgrade, representing significant operational overhead.

### Citations

**File:** contract/AElf.Contracts.Treasury/TreasuryContract.cs (L80-121)
```csharp
    public override Empty InitialMiningRewardProfitItem(Empty input)
    {
        Assert(State.TreasuryHash.Value == null, "Already initialized.");
        var managingSchemeIds = State.ProfitContract.GetManagingSchemeIds.Call(new GetManagingSchemeIdsInput
        {
            Manager = Context.Self
        }).SchemeIds;

        Assert(managingSchemeIds.Count == 7, "Incorrect schemes count.");

        State.TreasuryHash.Value = managingSchemeIds[0];
        State.RewardHash.Value = managingSchemeIds[1];
        State.SubsidyHash.Value = managingSchemeIds[2];
        State.WelfareHash.Value = managingSchemeIds[3];
        State.BasicRewardHash.Value = managingSchemeIds[4];
        State.VotesWeightRewardHash.Value = managingSchemeIds[5];
        State.ReElectionRewardHash.Value = managingSchemeIds[6];

        var electionContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName);
        if (electionContractAddress != null)
        {
            State.ProfitContract.ResetManager.Send(new ResetManagerInput
            {
                SchemeId = managingSchemeIds[2],
                NewManager = electionContractAddress
            });
            State.ProfitContract.ResetManager.Send(new ResetManagerInput
            {
                SchemeId = managingSchemeIds[3],
                NewManager = electionContractAddress
            });
        }

        BuildTreasury();

        var treasuryVirtualAddress = Address.FromPublicKey(State.ProfitContract.Value.Value.Concat(
            managingSchemeIds[0].Value.ToByteArray().ComputeHash()).ToArray());
        State.TreasuryVirtualAddress.Value = treasuryVirtualAddress;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L369-380)
```csharp
    private void AddBeneficiaryToVoter(long votesWeight, long lockSeconds, Hash voteId)
    {
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.WelfareHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = Context.Sender,
                Shares = votesWeight
            },
            EndPeriod = GetEndPeriod(lockSeconds),
            // one vote, one profit detail, so voteId equals to profitDetailId
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L781-795)
```csharp
    private void AddBeneficiary(string candidatePubkey, Address profitsReceiver = null)
    {
        var beneficiaryAddress = GetBeneficiaryAddress(candidatePubkey, profitsReceiver);
        var subsidyId = GenerateSubsidyId(candidatePubkey, beneficiaryAddress);
        State.ProfitContract.AddBeneficiary.Send(new AddBeneficiaryInput
        {
            SchemeId = State.SubsidyHash.Value,
            BeneficiaryShare = new BeneficiaryShare
            {
                Beneficiary = beneficiaryAddress,
                Shares = 1,
            },
            ProfitDetailId = subsidyId
        });
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L171-174)
```csharp
        Assert(
            Context.Sender == scheme.Manager || Context.Sender ==
            Context.GetContractAddressByName(SmartContractConstants.TokenHolderContractSystemName),
            "Only manager can add beneficiary.");
```

**File:** contract/AElf.Contracts.Economic/EconomicContract.cs (L196-208)
```csharp
        var schemeIdsManagingByElectionContract = State.ProfitContract.GetManagingSchemeIds.Call(
            new GetManagingSchemeIdsInput
            {
                Manager = Context.GetContractAddressByName(SmartContractConstants.ElectionContractSystemName)
            }).SchemeIds;
        State.ElectionContract.SetTreasurySchemeIds.Send(new SetTreasurySchemeIdsInput
        {
            TreasuryHash = schemeIdsManagingByTreasuryContract[0],
            WelcomeHash = schemeIdsManagingByTreasuryContract[3],
            FlexibleHash = schemeIdsManagingByTreasuryContract[4],
            SubsidyHash = schemeIdsManagingByElectionContract[0],
            WelfareHash = schemeIdsManagingByElectionContract[1]
        });
```
