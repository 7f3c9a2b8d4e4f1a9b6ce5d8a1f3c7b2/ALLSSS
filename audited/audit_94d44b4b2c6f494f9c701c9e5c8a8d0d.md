# Audit Report

## Title
Decimal Overflow in BancorHelper.Exp() Causes Permanent DoS of Token Conversion with Extreme Connector Weight Ratios

## Summary
The TokenConverter contract's Bancor formula implementation can permanently fail when connector weights have extreme but individually valid ratios (e.g., 0.99/0.01). The `Exp()` function computes high-degree polynomial terms that overflow `decimal.MaxValue`, causing all Buy/Sell transactions to revert with `OverflowException`. Since connector weights cannot be updated after enablement, this results in permanent DoS of the affected trading pair.

## Finding Description

The vulnerability exists in the exponential calculation used by the Bancor pricing formula. The `Exp()` function implements a 20-term Taylor series expansion that computes power terms up to `y^20`. [1](#0-0) 

During binary exponentiation in the `Pow()` function, repeated squaring operations (`A *= A`) can produce intermediate values exceeding `decimal.MaxValue` before division by factorial occurs. [2](#0-1) 

**Execution Path:**

1. When a user calls `Buy()`, the contract invokes `BancorHelper.GetAmountToPayFromReturn()` to calculate the required payment. [3](#0-2) 

2. This function computes the weight ratio `y = wt / wf` and calls `Exp(y * Ln(x))`. [4](#0-3) 

3. Individual connector weights are validated to be strictly between 0 and 1. [5](#0-4) 

4. However, **no validation exists on the weight ratio**. If governance sets `wt = 0.99` and `wf = 0.01`, then `y = 99`.

5. The `Ln()` function constrains its input to the range `(0, 2)`. [6](#0-5) 

6. When a user buys approximately 50% of available supply, `x` approaches `2`, making `Ln(x) ≈ 0.693`. Thus `y * Ln(x) ≈ 99 × 0.693 ≈ 68.6`.

7. Computing `Exp(68.6)` requires calculating `Pow(68.6, 16)`. Since `68.6^16 ≈ 1.7×10^29 > decimal.MaxValue ≈ 7.9×10^28`, the multiplication operation throws `OverflowException` due to checked arithmetic. [7](#0-6) 

8. Once connectors are enabled, they cannot be updated, making the DoS permanent. [8](#0-7) 

## Impact Explanation

**Operational Impact - High Severity:**

- **Complete DoS**: All `Buy()` and `Sell()` operations fail for the affected connector pair
- **Liquidity Locked**: Users cannot trade tokens through this pair, effectively locking liquidity
- **Universal Impact**: Affects all users attempting to trade, not just large transactions
- **Permanence**: The vulnerability cannot be fixed without contract redeployment since `UpdateConnector()` explicitly blocks updates when `IsPurchaseEnabled = true`
- **Protocol Integrity**: Non-functional trading pairs damage protocol reputation and user trust

The severity is high because:
- Token conversion is a core protocol function
- The issue affects availability of a critical service
- No recovery mechanism exists within the contract
- Both Buy and Sell operations are equally affected (they use inverse weight ratios in the same formula)

## Likelihood Explanation

**Likelihood: Medium**

**Preconditions:**
- Connector controller (governance) configures connector weights with extreme ratios
- Both weights individually satisfy validation (0 < weight < 1)
- Connectors are enabled for trading
- User attempts to trade amounts approaching 50% of reserves

**Feasibility Analysis:**
- **Governance Action Required**: The vulnerability requires governance to set extreme weight ratios. While governance typically uses moderate ratios (0.5, 0.6), the lack of ratio-specific validation means extreme configurations are technically permitted.
- **No Malicious Intent Needed**: This can occur through innocent misconfiguration. Governance may review individual weights without considering their ratio.
- **User Trigger**: Any standard user transaction can trigger the overflow once weights are configured.
- **Testing Blind Spot**: The existing test suite only validates moderate weight ratios (0.5, 0.6). [9](#0-8) 

**Economic Context:**
- No special privileges required from users
- Standard transaction fees apply
- No economic disincentive to triggering the bug

The likelihood is medium rather than high because it requires governance misconfiguration, but it remains realistic due to the absence of ratio validation and testing gaps.

## Recommendation

Implement validation on connector weight ratios during configuration:

1. **Add Ratio Bounds Check**: In `AssertValidConnectorWeight()` and related validation logic, add a check that when two connectors form a pair, their ratio should not exceed a safe threshold (e.g., 10:1 or 20:1).

2. **Pre-compute Maximum Safe Exponent**: Before calling `Exp()`, verify that `y * Ln(x)` does not exceed approximately 27 (the safe limit where `Pow(27, 16)` stays below `decimal.MaxValue`).

3. **Add Validation in AddPairConnector**: When creating connector pairs, validate that the ratio `max(nativeWeight, resourceWeight) / min(nativeWeight, resourceWeight)` is within acceptable bounds.

4. **Enhanced Testing**: Add test cases that verify behavior with extreme weight ratios (0.95/0.05, 0.99/0.01) and large trade amounts.

Example validation logic:
```csharp
private void AssertValidConnectorWeightRatio(decimal weight1, decimal weight2)
{
    var ratio = Math.Max(weight1, weight2) / Math.Min(weight1, weight2);
    Assert(ratio <= 20, "Weight ratio exceeds maximum safe threshold of 20:1");
}
```

## Proof of Concept

The following test demonstrates the overflow:

```csharp
[Fact]
public void ExtremeWeightRatio_Causes_Overflow()
{
    // Connector with extreme weight ratio: 0.99 / 0.01 = 99
    var fromConnector = new Connector 
    { 
        Symbol = "ELF", 
        VirtualBalance = 1000000, 
        Weight = "0.01",  // Very low weight
        IsPurchaseEnabled = true 
    };
    
    var toConnector = new Connector 
    { 
        Symbol = "RESOURCE", 
        VirtualBalance = 1000000, 
        Weight = "0.99",  // Very high weight
        IsPurchaseEnabled = true 
    };
    
    // Attempt to buy approximately 50% of supply to maximize price impact
    // This makes x approach 2, where Ln(x) ≈ 0.693
    // y = 0.99 / 0.01 = 99
    // y * Ln(x) ≈ 99 * 0.693 ≈ 68.6
    // Exp(68.6) requires Pow(68.6, 16) which overflows decimal
    
    Should.Throw<OverflowException>(() => 
        BancorHelper.GetAmountToPayFromReturn(
            fromConnector.VirtualBalance, 
            decimal.Parse(fromConnector.Weight),
            toConnector.VirtualBalance, 
            decimal.Parse(toConnector.Weight),
            500000  // Buy 50% of supply
        ));
}
```

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L91-93)
```csharp
        var x = bt / (bt - a);
        var y = wt / wf;
        return (long)(bf * (Exp(y * Ln(x)) - decimal.One));
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L124-143)
```csharp
    private static decimal Ln(decimal a)
    {
        /*
        ln(a) = log(1-x) = - x - x^2/2 - x^3/3 - ...   (where |x| < 1)
            x: a = 1-x    =>   x = 1-a = 1 - 1.004 = -.004
        */
        var x = 1 - a;
        if (Math.Abs(x) >= 1)
            throw new InvalidValueException("must be 0 < a < 2");

        decimal result = 0;
        uint iteration = _LOOPS;
        while (iteration > 0)
        {
            result -= Pow(x, iteration) / iteration;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L58-76)
```csharp
    public override Empty UpdateConnector(Connector input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.Symbol), "input symbol can not be empty'");
        var targetConnector = State.Connectors[input.Symbol];
        Assert(targetConnector != null, "Can not find target connector.");
        Assert(!targetConnector.IsPurchaseEnabled, "connector can not be updated because it has been activated");
        if (!string.IsNullOrEmpty(input.Weight))
        {
            var weight = AssertedDecimal(input.Weight);
            Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
            targetConnector.Weight = input.Weight.ToString(CultureInfo.InvariantCulture);
        }

        if (targetConnector.IsDepositAccount && input.VirtualBalance > 0)
            targetConnector.VirtualBalance = input.VirtualBalance;
        State.Connectors[input.Symbol] = targetConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L112-123)
```csharp
    public override Empty Buy(BuyInput input)
    {
        var toConnector = State.Connectors[input.Symbol];
        Assert(toConnector != null, "[Buy]Can't find to connector.");
        Assert(toConnector.IsPurchaseEnabled, "can't purchase");
        Assert(!string.IsNullOrEmpty(toConnector.RelatedSymbol), "can't find related symbol'");
        var fromConnector = State.Connectors[toConnector.RelatedSymbol];
        Assert(fromConnector != null, "[Buy]Can't find from connector.");
        var amountToPay = BancorHelper.GetAmountToPayFromReturn(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount);
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L418-423)
```csharp
    private void AssertValidConnectorWeight(Connector connector)
    {
        var weight = AssertedDecimal(connector.Weight);
        Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
        connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
    }
```

**File:** contract/AElf.Contracts.TokenConverter/AElf.Contracts.TokenConverter.csproj (L11-16)
```text
    <PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
    <PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
        <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
    </PropertyGroup>
```

**File:** test/AElf.Contracts.TokenConverter.Internal.Tests/BancorHelperTest.cs (L13-32)
```csharp
    public BancorHelperTest()
    {
        _writeConnector = new Connector
        {
            Symbol = "WRITE",
            VirtualBalance = 50_0000,
            Weight = "0.5",
            IsVirtualBalanceEnabled = false,
            IsPurchaseEnabled = true
        };

        _elfConnector = new Connector
        {
            Symbol = "ELF",
            VirtualBalance = 100_0000,
            Weight = "0.6",
            IsPurchaseEnabled = true,
            IsVirtualBalanceEnabled = false
        };
    }
```
