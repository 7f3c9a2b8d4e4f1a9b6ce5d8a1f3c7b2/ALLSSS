# Audit Report

## Title
Miner List Manipulation via Unvalidated NextTerm Input Allows Consensus Takeover

## Summary
The `NextTerm` method in the AEDPoS consensus contract accepts arbitrary miner lists without validating them against election results from `ElectionContract.GetVictories()`. Any current miner can submit a fraudulent `NextTerm` transaction with a manipulated miner list, completely bypassing the election system and enabling indefinite consensus control.

## Finding Description

The vulnerability exists in the term transition flow where the consensus contract fails to validate the legitimacy of the new miner list against election results.

The `NextTerm` method is publicly accessible and processes term transitions: [1](#0-0) 

When processing a term transition, `ProcessNextTerm` extracts the miner list directly from the input parameter and calls `SetMinerList` without any validation against election results: [2](#0-1) 

The **intended** design uses `GenerateFirstRoundOfNextTerm` as a view method to obtain legitimate miners from the election contract: [3](#0-2) 

This view method calls `TryToGetVictories` to retrieve legitimate miners: [4](#0-3) 

However, this entire validation flow occurs **off-chain**. The `NextTermInput` structure is created off-chain and submitted in a transaction: [5](#0-4) 

The on-chain validation system **fails to verify** that the miner list matches election results. The `RoundTerminateValidationProvider` only validates term and round number increments: [6](#0-5) 

Post-execution validation also fails to check election results. The `ValidateConsensusAfterExecution` method only validates within-term miner replacements using `GetNewestPubkey`, not term transitions: [7](#0-6) 

The access control check in `PreCheck` only verifies that the transaction sender is in the current or previous miner list, which the attacker satisfies: [8](#0-7) 

**Attack Sequence:**
1. Attacker (current miner) waits for term transition time
2. Off-chain: Calls `GenerateFirstRoundOfNextTerm` to get proper structure
3. Off-chain: Modifies `RealTimeMinersInformation` to include arbitrary miners
4. On-chain: Submits `NextTerm` transaction with fraudulent miner list
5. Validation passes (only checks term/round numbers, not miner legitimacy)
6. `SetMinerList` accepts the fraudulent miners as the new consensus set
7. Attacker now controls consensus and can repeat indefinitely

## Impact Explanation

**Critical Consensus Integrity Break:** The election system is the fundamental security mechanism in AEDPoS for determining legitimate block producers through token holder voting. This vulnerability renders the entire election process meaningless, allowing attackers to completely bypass democratic validator selection.

**Indefinite Control:** Once an attacker gains control through one fraudulent term transition, they can perpetuate control indefinitely by:
- Including themselves and accomplice nodes in every subsequent term
- Excluding legitimately elected validators
- Maintaining majority/supermajority control over consensus

**Protocol-Wide Damage:**
- **Consensus Security:** The 2/3+ honest miner assumption is violated when the miner set is attacker-controlled
- **Economic Integrity:** Mining rewards are misdirected to fraudulent miners instead of elected validators
- **Governance Nullification:** Token holder voting power becomes worthless
- **Cross-Chain Security:** Side chains relying on main chain miner integrity are compromised
- **Treasury Corruption:** Reward distribution goes to attackers

**Affected Parties:** All network participants lose fundamental security guarantees, legitimate validators lose staked capital and rewards, and token holders lose governance rights.

## Likelihood Explanation

**Easily Reachable Entry Point:** The `NextTerm` method is public with minimal access control - any current miner can call it when term change conditions are met (time-based periodic occurrence).

**Realistic Preconditions:**
1. Attacker must be a current miner (achievable through legitimate election initially or by having one compromised validator)
2. Must wait for term transition point (periodic occurrence based on `PeriodSeconds` configuration)

**Execution Practicality:** The attack requires no complex exploit chains:
1. Monitor blockchain for term transition time
2. Call view method off-chain to get round structure
3. Modify miner list in the structure
4. Submit transaction during attacker's time slot
5. All validations pass automatically

**No Detection Barriers:** The fraudulent transaction appears identical to a legitimate term transition. The validation logic checks only metadata (term/round numbers), not the critical miner list content. Other nodes would accept the block using the same insufficient validation.

**Economic Rationality:** The reward structure heavily incentivizes this attack - mining rewards and consensus control far exceed any transaction costs. The attacker gains ongoing block production rewards while excluding competitors.

## Recommendation

Add on-chain validation in `ProcessNextTerm` to verify the miner list against election results:

```csharp
private void ProcessNextTerm(NextTermInput input)
{
    var nextRound = input.ToRound();
    
    RecordMinedMinerListOfCurrentRound();
    CountMissedTimeSlots();
    
    // VALIDATION: Verify miner list matches election results
    if (State.IsMainChain.Value)
    {
        var expectedMiners = State.ElectionContract.GetVictories.Call(new Empty());
        var inputMinerKeys = nextRound.RealTimeMinersInformation.Keys.OrderBy(k => k).ToList();
        var expectedMinerKeys = expectedMiners.Value.Select(p => p.ToHex()).OrderBy(k => k).ToList();
        
        Assert(inputMinerKeys.Count == expectedMinerKeys.Count && 
               inputMinerKeys.SequenceEqual(expectedMinerKeys),
               "Miner list does not match election results from GetVictories()");
    }
    
    // ... rest of existing code
}
```

Alternatively, add validation to `RoundTerminateValidationProvider`:

```csharp
private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var validationResult = ValidationForNextRound(validationContext);
    if (!validationResult.Success) return validationResult;
    
    // Validate term number increment
    if (validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber)
        return new ValidationResult { Message = "Incorrect term number for next round." };
    
    // VALIDATION: Verify miner list against election results
    if (validationContext.IsMainChain)
    {
        var expectedMiners = GetElectionVictories(); // Call election contract
        var inputMiners = extraData.Round.RealTimeMinersInformation.Keys.OrderBy(k => k);
        var expectedKeys = expectedMiners.Select(p => p.ToHex()).OrderBy(k => k);
        
        if (!inputMiners.SequenceEqual(expectedKeys))
            return new ValidationResult { Message = "Miner list does not match election results." };
    }
    
    return new ValidationResult { Success = true };
}
```

## Proof of Concept

A test demonstrating the vulnerability would:

1. Set up initial miner set through legitimate election
2. Have one miner prepare for term transition
3. Call `GenerateFirstRoundOfNextTerm` off-chain
4. Modify the resulting miner list to exclude legitimate miners and include attacker-controlled nodes
5. Submit `NextTerm` transaction with fraudulent miner list
6. Verify transaction succeeds and fraudulent miners are now active
7. Confirm election results are ignored

The test would show that the consensus contract accepts arbitrary miner lists without validating against `GetVictories()`, proving complete election bypass is possible.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_NextTerm.cs (L13-18)
```csharp
    public override Empty NextTerm(NextTermInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L187-190)
```csharp
        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L326-328)
```csharp
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L223-257)
```csharp
    private Round GenerateFirstRoundOfNextTerm(string senderPubkey, int miningInterval)
    {
        Round newRound;
        TryToGetCurrentRoundInformation(out var currentRound);

        if (TryToGetVictories(out var victories))
        {
            Context.LogDebug(() => "Got victories successfully.");
            newRound = victories.GenerateFirstRoundOfNewTerm(miningInterval, Context.CurrentBlockTime,
                currentRound);
        }
        else
        {
            // Miners of new round are same with current round.
            var miners = new MinerList();
            miners.Pubkeys.AddRange(
                currentRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
            newRound = miners.GenerateFirstRoundOfNewTerm(currentRound.GetMiningInterval(),
                Context.CurrentBlockTime, currentRound);
        }

        newRound.ConfirmedIrreversibleBlockHeight = currentRound.ConfirmedIrreversibleBlockHeight;
        newRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.ConfirmedIrreversibleBlockRoundNumber;

        newRound.BlockchainAge = GetBlockchainAge();

        if (newRound.RealTimeMinersInformation.ContainsKey(senderPubkey))
            newRound.RealTimeMinersInformation[senderPubkey].ProducedBlocks = 1;
        else
            UpdateCandidateInformation(senderPubkey, 1, 0);

        newRound.ExtraBlockProducerOfPreviousRound = senderPubkey;

        return newRound;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L266-283)
```csharp
    private bool TryToGetVictories(out MinerList victories)
    {
        if (!State.IsMainChain.Value)
        {
            victories = null;
            return false;
        }

        var victoriesPublicKeys = State.ElectionContract.GetVictories.Call(new Empty());
        Context.LogDebug(() =>
            "Got victories from Election Contract:\n" +
            $"{string.Join("\n", victoriesPublicKeys.Value.Select(s => s.ToHex().Substring(0, 20)))}");
        victories = new MinerList
        {
            Pubkeys = { victoriesPublicKeys.Value }
        };
        return victories.Pubkeys.Any();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/NextTermInput.cs (L25-40)
```csharp
    public Round ToRound()
    {
        return new Round
        {
            RoundNumber = RoundNumber,
            RealTimeMinersInformation = { RealTimeMinersInformation },
            ExtraBlockProducerOfPreviousRound = ExtraBlockProducerOfPreviousRound,
            BlockchainAge = BlockchainAge,
            TermNumber = TermNumber,
            ConfirmedIrreversibleBlockHeight = ConfirmedIrreversibleBlockHeight,
            ConfirmedIrreversibleBlockRoundNumber = ConfirmedIrreversibleBlockRoundNumber,
            IsMinerListJustChanged = IsMinerListJustChanged,
            RoundIdForValidation = RoundIdForValidation,
            MainChainMinersRoundNumber = MainChainMinersRoundNumber
        };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L115-123)
```csharp
                var newMiners = stateMiners.Except(headerMiners).ToList();
                var officialNewestMiners = replacedMiners.Select(miner =>
                        State.ElectionContract.GetNewestPubkey.Call(new StringValue { Value = miner }).Value)
                    .ToList();

                Assert(
                    newMiners.Count == officialNewestMiners.Count &&
                    newMiners.Union(officialNewestMiners).Count() == newMiners.Count,
                    "Incorrect replacement information.");
```
