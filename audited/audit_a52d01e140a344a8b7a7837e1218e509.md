### Title
Cached TotalShares Not Adjusted After Consumption Leading to Profit Miscalculation in Delayed Distribution

### Summary
When `DelayDistributePeriodCount > 0`, the `DistributeProfits()` method caches `TotalShares` for future periods but immediately removes the cache entry after consumption. If beneficiaries are removed after their shares were cached but before that period's distribution, the removal logic cannot adjust the already-consumed cache entry, causing `DistributeProfits()` to use stale `TotalShares` values that include removed beneficiaries. This results in remaining beneficiaries receiving a smaller proportion of profits than they should, with the unclaimed portion permanently locked.

### Finding Description

The Profit contract implements a delayed distribution mechanism where beneficiaries can only claim profits after a delay period specified by `DelayDistributePeriodCount`. The `DistributeProfits()` method caches the current `TotalShares` for future periods to ensure correct profit calculations: [1](#0-0) 

When the cached period arrives, the cached value is retrieved and **immediately removed** from the cache. The retrieved `totalShares` is then stored in `DistributedProfitsMap`: [2](#0-1) 

When `RemoveBeneficiary` is called, it attempts to adjust the cached values for future periods by iterating through the delay window and subtracting the removed shares: [3](#0-2) 

**Root Cause**: The adjustment logic only modifies cached entries that currently exist (checked by `ContainsKey` at line 251). However, if `DistributeProfits()` has already consumed the cached entry for a period (removed at line 470), subsequent `RemoveBeneficiary` calls cannot adjust that period's cache, even though the period hasn't been distributed yet.

**Why Protections Fail**: The code removes the cached entry immediately after retrieval (line 470), creating a timing window where:
1. Cached shares are set in period P for distribution in period P+N
2. Period P+N arrives and `DistributeProfits()` retrieves and removes the cached entry
3. A beneficiary is removed before `DistributeProfits()` completes
4. The removal logic cannot adjust the already-removed cache entry
5. `DistributeProfits()` stores the stale (inflated) `TotalShares` to `DistributedProfitsMap`

When beneficiaries later claim profits via `ClaimProfits()`, the calculation uses the inflated `TotalShares` from `DistributedProfitsMap`: [4](#0-3) 

The removed beneficiary cannot claim (their `EndPeriod` was set to `CurrentPeriod - 1` by `RemoveProfitDetails`), but their shares remain in the denominator, causing remaining beneficiaries to receive reduced payouts. [5](#0-4) 

### Impact Explanation

**Harm**: Legitimate beneficiaries receive less profit than entitled, with the difference permanently locked in the period's virtual address. The locked funds can never be recovered as no eligible beneficiary has sufficient shares to claim the full distributed amount.

**Quantified Damage**: If a scheme has 200 shares (100 per beneficiary), and one beneficiary is removed during the vulnerable timing window, the remaining beneficiary receives only 50% (100/200) of distributed profits instead of 100% (100/100). For a 1000 token distribution, 500 tokens are permanently locked.

**Affected Parties**: 
- Active beneficiaries of profit schemes with `DelayDistributePeriodCount > 0`
- Economic reward recipients (miners, voters, token holders)
- Treasury and consensus dividend distributions that use delayed schemes

**Severity Justification**: High severity due to direct fund loss, exploitation requiring only normal operational timing (not malicious), and affecting core economic distribution mechanisms. The vulnerability impacts critical invariant #4 (dividend distribution accuracy).

### Likelihood Explanation

**Attacker Capabilities**: The scheme manager (or authorized addresses like TokenHolder contract) can control the timing of `AddBeneficiary`, `RemoveBeneficiary`, and `DistributeProfits` calls. Even without malicious intent, normal operational sequencing can trigger this bug.

**Attack Complexity**: Low. The vulnerable sequence occurs naturally:
1. Period N: Add beneficiaries and distribute (caches shares for period N+Delay)
2. Period N+Delay: Remove a beneficiary then distribute in the same block/transaction set

**Feasibility Conditions**: 
- Scheme must have `DelayDistributePeriodCount > 0`
- Beneficiary removal must occur in the same period as distribution
- Multiple beneficiaries must exist (otherwise 100% goes to remaining beneficiary anyway)

**Detection/Operational Constraints**: The bug manifests silently - beneficiaries simply receive less than expected with no error messages. The locked funds remain in the period's virtual address indefinitely.

**Probability**: High for active schemes with delayed distribution, as beneficiary removal is a standard operation (vote withdrawals, stake unlocks, miner rotation).

### Recommendation

**Code-Level Mitigation**: Modify `DistributeProfits()` to NOT remove the cached entry immediately after retrieval. Instead, mark it as "consumed" and clean up expired entries in a separate maintenance function:

```csharp
// In DistributeProfits, replace lines 467-475 with:
if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
{
    totalShares = scheme.CachedDelayTotalShares[input.Period];
    // Don't remove yet - allow RemoveBeneficiary to still adjust it
    // Mark as consumed instead
}
else
{
    totalShares = 0;
}

// After storing to DistributedProfitsMap (after line 582), remove the cache:
scheme.CachedDelayTotalShares.Remove(input.Period);
```

**Invariant Checks**: Add assertion in `DistributeProfits()` after line 490:
```csharp
// Verify TotalShares accuracy
var expectedShares = CalculateActiveSharesForPeriod(scheme, releasingPeriod);
Assert(totalShares == expectedShares, 
    $"TotalShares mismatch: cached={totalShares}, actual={expectedShares}");
```

**Test Cases**: Add regression test:
```csharp
// Test: Remove beneficiary during distribution period with delay
// 1. Create scheme with DelayDistributePeriodCount = 2
// 2. Period 1: Add 2 beneficiaries (100 shares each)
// 3. Period 3: Remove 1 beneficiary, then distribute
// 4. Verify DistributedProfitsMap[3].TotalShares == 100 (not 200)
// 5. Verify remaining beneficiary claims 100% of profits
```

### Proof of Concept

**Initial State**:
- Scheme created with `DelayDistributePeriodCount = 2`
- 1000 tokens available for distribution each period

**Transaction Sequence**:

1. **Period 1**: 
   - `AddBeneficiary(Alice, 100 shares)` → `scheme.TotalShares = 100`, `Alice.StartPeriod = 3`
   - `AddBeneficiary(Bob, 100 shares)` → `scheme.TotalShares = 200`, `Bob.StartPeriod = 3`
   - `DistributeProfits(period=1)` → Caches `CachedDelayTotalShares[3] = 200`

2. **Period 2**:
   - `DistributeProfits(period=2)` → Caches `CachedDelayTotalShares[4] = 200`

3. **Period 3**:
   - `RemoveBeneficiary(Alice)`:
     - `scheme.TotalShares = 100`
     - Attempts to adjust `CachedDelayTotalShares[3]`, but it was already consumed and removed in Period 1
     - `Alice.EndPeriod = 2` (cannot claim from period 3)
   - `DistributeProfits(period=3, amount=1000)`:
     - Retrieves `CachedDelayTotalShares[3] = 200` (STALE VALUE)
     - Stores `DistributedProfitsMap[3].TotalShares = 200`
     - Transfers 1000 tokens to period 3's virtual address

4. **Claim Phase**:
   - Alice tries to claim: FAILS (EndPeriod=2 < CurrentPeriod=3)
   - Bob claims: `amount = (100 / 200) * 1000 = 500 tokens` ✓
   - Remaining: `1000 - 500 = 500 tokens` PERMANENTLY LOCKED

**Expected Result**: Bob should receive 1000 tokens (100%)

**Actual Result**: Bob receives 500 tokens (50%), 500 tokens locked forever

**Success Condition**: `DistributedProfitsMap[3].TotalShares == 200` (should be 100) AND Bob's claimed amount < total distributed amount

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L243-258)
```csharp
        foreach (var (removedMinPeriod, removedShares) in removedDetails.Where(d => d.Key != 0))
        {
            if (scheme.DelayDistributePeriodCount > 0)
            {
                for (var removedPeriod = removedMinPeriod;
                     removedPeriod < removedMinPeriod.Add(scheme.DelayDistributePeriodCount);
                     removedPeriod++)
                {
                    if (scheme.CachedDelayTotalShares.ContainsKey(removedPeriod))
                    {
                        scheme.CachedDelayTotalShares[removedPeriod] =
                            scheme.CachedDelayTotalShares[removedPeriod].Sub(removedShares);
                    }
                }
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L355-355)
```csharp
                    profitDetail.EndPeriod = scheme.CurrentPeriod.Sub(1);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L464-476)
```csharp
        if (scheme.DelayDistributePeriodCount > 0)
        {
            scheme.CachedDelayTotalShares.Add(input.Period.Add(scheme.DelayDistributePeriodCount), totalShares);
            if (scheme.CachedDelayTotalShares.ContainsKey(input.Period))
            {
                totalShares = scheme.CachedDelayTotalShares[input.Period];
                scheme.CachedDelayTotalShares.Remove(input.Period);
            }
            else
            {
                totalShares = 0;
            }
        }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L560-583)
```csharp
    private void UpdateDistributedProfits(Dictionary<string, long> profitsMap,
        Address profitsReceivingVirtualAddress, long totalShares)
    {
        var distributedProfitsInformation =
            State.DistributedProfitsMap[profitsReceivingVirtualAddress] ??
            new DistributedProfitsInfo();

        distributedProfitsInformation.TotalShares = totalShares;
        distributedProfitsInformation.IsReleased = true;

        foreach (var profits in profitsMap)
        {
            var symbol = profits.Key;
            var amount = profits.Value;
            var balanceOfVirtualAddressForCurrentPeriod = State.TokenContract.GetBalance.Call(new GetBalanceInput
            {
                Owner = profitsReceivingVirtualAddress,
                Symbol = symbol
            }).Balance;
            distributedProfitsInformation.AmountsMap[symbol] = amount.Add(balanceOfVirtualAddressForCurrentPeriod);
        }

        State.DistributedProfitsMap[profitsReceivingVirtualAddress] = distributedProfitsInformation;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L873-874)
```csharp
                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);
```
