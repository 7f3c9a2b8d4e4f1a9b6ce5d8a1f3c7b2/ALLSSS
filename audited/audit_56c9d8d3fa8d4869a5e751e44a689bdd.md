### Title
Unauthorized Round Termination Allows Miners to Steal Extra Block Producer Privileges

### Summary
The `TinyBlockCommandStrategy` can dynamically switch the consensus behavior from `TinyBlock` to `NextRound` without verifying that the miner is the designated extra block producer. This allows any miner to prematurely terminate rounds and gain the `ExtraBlockProducerOfPreviousRound` status, which grants special mining privileges in the next round including extended time slots and additional block production capacity.

### Finding Description

The vulnerability exists in the consensus command generation flow where behavior mismatches can occur between the initially selected behavior and the final behavior encoded in commands.

**Root Cause Location:** [1](#0-0) 

When `TinyBlockCommandStrategy` determines that the arranged mining time exceeds the current time slot, it dynamically creates a `TerminateRoundCommandStrategy` and returns its command with `NextRound` behavior instead of the originally selected `TinyBlock` behavior.

**Behavior Selection Without Authorization:** [2](#0-1) 

The behavior provider's `GetConsensusBehaviour()` method returns `NextRound` or `NextTerm` for any miner whose time slot has passed, without checking if they are the designated extra block producer.

**Privilege Assignment Without Validation:** [3](#0-2) 

When generating NextRound extra data, any miner who produces the NextRound block is automatically assigned as `ExtraBlockProducerOfPreviousRound` without validation of their authorization.

**Extra Privileges Granted:** [4](#0-3) 

Miners with `ExtraBlockProducerOfPreviousRound` status can mine significantly more tiny blocks than normal miners, as they have "two time slots recorded in current round." [5](#0-4) 

They can also produce tiny blocks before the current round officially starts.

**Missing Validation:** [6](#0-5) 

The validation providers for `NextRound` behavior only check data structure integrity (round number increments, mining order validity) but do not verify whether the miner is authorized to terminate the round. [7](#0-6) 

The mining permission validator only checks if the sender is in the miner list, not whether they should be terminating the round.

### Impact Explanation

**Direct Consensus Impact:**
- Any miner can prematurely terminate rounds by exploiting the behavior switch in `TinyBlockCommandStrategy`
- The designated extra block producer (determined during round generation) loses their special privileges
- Attackers can repeatedly gain `ExtraBlockProducerOfPreviousRound` status across multiple rounds

**Mining Privilege Manipulation:**
- Attackers gain ability to mine `(_maximumBlocksCount + blocksBeforeCurrentRound)` blocks instead of just `_maximumBlocksCount`
- Attackers can mine before rounds officially start, giving them timing advantages
- This increases their block production capacity and potential rewards unfairly

**Consensus Integrity Violation:**
The extra block producer role is calculated during round generation to ensure fair rotation: [8](#0-7) 

However, this designation is completely bypassed as any miner can claim the privileges by terminating the round first.

**Severity Justification:**
- Violates core consensus invariant: "Correct round transitions and miner schedule integrity"
- Allows manipulation of block production distribution
- Disrupts intended consensus mechanism fairness
- Exploitable by any miner without special permissions

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker only needs to be any valid miner in the current round
- No special permissions or governance control required
- Attack requires standard block production capabilities

**Attack Execution:**
1. Attacker monitors their consensus commands from `GetConsensusCommand`
2. When receiving a `TinyBlock` command where timing would cause switch to `NextRound`
3. Attacker produces the block, automatically gaining `ExtraBlockProducerOfPreviousRound` status
4. In next round, attacker exploits extra mining privileges

**Feasibility Conditions:**
- The behavior switch occurs automatically in `TinyBlockCommandStrategy` when arranged mining time exceeds time slot
- No manual intervention needed - the strategy logic creates the exploit condition
- Multiple miners could race to terminate rounds, with winner claiming privileges

**Detection Constraints:**
- Behavior appears legitimate as `NextRound` blocks are normal consensus operations
- Validation passes all checks since data structures are correctly formed
- Only deep analysis of who SHOULD terminate rounds would reveal the issue

**Probability Assessment:**
HIGH - The vulnerability is inherent in the design where:
- Any miner can get commands that switch to `NextRound` behavior
- No authorization check prevents unauthorized round termination
- Extra privileges are automatically granted without validation
- Exploit is repeatable across multiple rounds

### Recommendation

**Add Authorization Check in TinyBlockCommandStrategy:**
Before switching to `TerminateRoundCommandStrategy`, verify that the miner is the designated extra block producer: [9](#0-8) 

Add check:
```csharp
var extraBlockProducer = CurrentRound.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.IsExtraBlockProducer);
if (extraBlockProducer?.Pubkey != Pubkey)
    return InvalidConsensusCommand; // Not authorized to terminate round
```

**Add Validation Provider for Round Termination Authorization:**
Create a new `RoundTerminationAuthorizationProvider` that validates the miner producing `NextRound`/`NextTerm` blocks is the designated extra block producer: [6](#0-5) 

Add to validation providers list for `NextRound` and `NextTerm` behaviors.

**Validate in GetConsensusExtraDataForNextRound:** [3](#0-2) 

Before setting `ExtraBlockProducerOfPreviousRound`, verify the miner is authorized:
```csharp
var extraBlockProducer = currentRound.RealTimeMinersInformation.Values
    .FirstOrDefault(m => m.IsExtraBlockProducer);
Assert(extraBlockProducer?.Pubkey == pubkey, 
    "Only designated extra block producer can terminate round");
```

**Test Cases:**
- Test that non-extra-block-producer miners cannot produce NextRound blocks
- Test that TinyBlock commands for unauthorized miners don't switch to NextRound
- Test that validation rejects NextRound blocks from unauthorized miners
- Test that ExtraBlockProducerOfPreviousRound privileges are only granted to authorized miners

### Proof of Concept

**Initial State:**
- 5 miners in current round
- Miner A is designated extra block producer (IsExtraBlockProducer = true)
- Miner B is attacker (normal miner)
- Current round number: 100

**Attack Steps:**

1. **Miner B calls GetConsensusCommand:**
   - Behavior provider determines: `TinyBlock` (B is in their time slot)
   - `TinyBlockCommandStrategy` is instantiated
   - Strategy calculates `arrangedMiningTime` which would exceed `currentTimeSlotEndTime`
   - Strategy switches to `TerminateRoundCommandStrategy` with `isNewTerm=false`
   - Returns command with `NextRound` behavior in hint

2. **Miner B produces NextRound block:**
   - Block contains `AElfConsensusHeaderInformation` with behavior = `NextRound`
   - `GetConsensusExtraDataForNextRound` is called
   - Line 178: Sets `nextRound.ExtraBlockProducerOfPreviousRound = B's pubkey`
   - Validation checks pass (data structure is valid)
   - Block is accepted

3. **Next Round (101) begins:**
   - Miner B now has `ExtraBlockProducerOfPreviousRound` status
   - Lines 71-79: B can mine `(_maximumBlocksCount + blocksBeforeCurrentRound)` blocks
   - Lines 104-112: B can mine before round start time
   - Miner A (original designated extra block producer) loses these privileges

**Expected Result:**
Only Miner A should be able to produce NextRound block and gain ExtraBlockProducerOfPreviousRound status.

**Actual Result:**
Miner B (any miner) can produce NextRound block and steal the extra block producer privileges.

**Success Condition:**
Attacker successfully gains `ExtraBlockProducerOfPreviousRound` status and mines additional blocks beyond normal miner capacity in the subsequent round.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/Strategies/TinyBlockCommandStrategy.cs (L25-52)
```csharp
        public override ConsensusCommand GetAEDPoSConsensusCommand()
        {
            // Provided pubkey can mine a block after TinyBlockMinimumInterval ms.
            var arrangedMiningTime =
                MiningTimeArrangingService.ArrangeMiningTimeWithOffset(CurrentBlockTime,
                    TinyBlockMinimumInterval);

            var roundStartTime = CurrentRound.GetRoundStartTime();
            var currentTimeSlotStartTime = CurrentBlockTime < roundStartTime
                ? roundStartTime.AddMilliseconds(-MiningInterval)
                : CurrentRound.RoundNumber == 1
                    ? MinerInRound.ActualMiningTimes.First()
                    : MinerInRound.ExpectedMiningTime;
            var currentTimeSlotEndTime = currentTimeSlotStartTime.AddMilliseconds(MiningInterval);

            return arrangedMiningTime > currentTimeSlotEndTime
                ? new TerminateRoundCommandStrategy(CurrentRound, Pubkey, CurrentBlockTime, false)
                    .GetAEDPoSConsensusCommand() // The arranged mining time already beyond the time slot.
                : new ConsensusCommand
                {
                    Hint = new AElfConsensusHint { Behaviour = AElfConsensusBehaviour.TinyBlock }.ToByteString(),
                    ArrangedMiningTime = arrangedMiningTime,
                    MiningDueTime = currentTimeSlotEndTime,
                    LimitMillisecondsOfMiningBlock = IsLastTinyBlockOfCurrentSlot()
                        ? LastTinyBlockMiningLimit
                        : DefaultBlockMiningLimit
                };
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L39-83)
```csharp
        public AElfConsensusBehaviour GetConsensusBehaviour()
        {
            // The most simple situation: provided pubkey isn't a miner.
            // Already checked in GetConsensusCommand.
//                if (!CurrentRound.IsInMinerList(_pubkey))
//                {
//                    return AElfConsensusBehaviour.Nothing;
//                }

            // If out value is null, it means provided pubkey hasn't mine any block during current round period.
            if (_minerInRound.OutValue == null)
            {
                var behaviour = HandleMinerInNewRound();

                // It's possible HandleMinerInNewRound can't handle all the situations, if this method returns Nothing,
                // just go ahead. Otherwise, return it's result.
                if (behaviour != AElfConsensusBehaviour.Nothing) return behaviour;
            }
            else if (!_isTimeSlotPassed
                    ) // Provided pubkey mined blocks during current round, and current block time is still in his time slot.
            {
                if (_minerInRound.ActualMiningTimes.Count < _maximumBlocksCount)
                    // Provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;

                var blocksBeforeCurrentRound =
                    _minerInRound.ActualMiningTimes.Count(t => t <= CurrentRound.GetRoundStartTime());

                // If provided pubkey is the one who terminated previous round, he can mine
                // (_maximumBlocksCount + blocksBeforeCurrentRound) blocks
                // because he has two time slots recorded in current round.

                if (CurrentRound.ExtraBlockProducerOfPreviousRound ==
                    _pubkey && // Provided pubkey terminated previous round
                    !CurrentRound.IsMinerListJustChanged && // & Current round isn't the first round of current term
                    _minerInRound.ActualMiningTimes.Count.Add(1) <
                    _maximumBlocksCount.Add(
                        blocksBeforeCurrentRound) // & Provided pubkey hasn't mine enough blocks for current round.
                   )
                    // Then provided pubkey can keep producing tiny blocks.
                    return AElfConsensusBehaviour.TinyBlock;
            }

            return GetConsensusBehaviourToTerminateCurrentRound();
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L104-112)
```csharp
            if (
                // If this miner is extra block producer of previous round,
                CurrentRound.ExtraBlockProducerOfPreviousRound == _pubkey &&
                // and currently the time is ahead of current round,
                _currentBlockTime < CurrentRound.GetRoundStartTime() &&
                // make this miner produce some tiny blocks.
                _minerInRound.ActualMiningTimes.Count < _maximumBlocksCount
            )
                return AElfConsensusBehaviour.TinyBlock;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-178)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);

        nextRound.ExtraBlockProducerOfPreviousRound = pubkey;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_Validation.cs (L77-92)
```csharp
        switch (extraData.Behaviour)
        {
            case AElfConsensusBehaviour.UpdateValue:
                validationProviders.Add(new UpdateValueValidationProvider());
                // Is confirmed lib height and lib round number went down? (Which should not happens.)
                validationProviders.Add(new LibInformationValidationProvider());
                break;
            case AElfConsensusBehaviour.NextRound:
                // Is sender's order of next round correct?
                validationProviders.Add(new NextRoundMiningOrderValidationProvider());
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
            case AElfConsensusBehaviour.NextTerm:
                validationProviders.Add(new RoundTerminateValidationProvider());
                break;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/MiningPermissionValidationProvider.cs (L14-24)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        var validationResult = new ValidationResult();
        if (!validationContext.BaseRound.RealTimeMinersInformation.Keys.Contains(validationContext.SenderPubkey))
        {
            validationResult.Message = $"Sender {validationContext.SenderPubkey} is not a miner.";
            return validationResult;
        }

        validationResult.Success = true;
        return validationResult;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-65)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;
```
