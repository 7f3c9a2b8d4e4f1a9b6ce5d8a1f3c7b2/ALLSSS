### Title
Continuous Block Limit Bypass via Public Key Replacement

### Summary
A miner can bypass the continuous block production limit by replacing their public key. When `RecordCandidateReplacement` is called, it updates the round information but fails to update `State.LatestPubkeyToTinyBlocksCount`, causing a pubkey mismatch that bypasses validation checks and resets the block counter instead of decrementing it. This allows a miner to produce more continuous blocks than the intended limit (typically 8 blocks) by using a series of fresh keypairs.

### Finding Description

The vulnerability exists in the interaction between key replacement and continuous block tracking:

**Core Issue**: The `State.LatestPubkeyToTinyBlocksCount` state variable tracks continuous block production by pubkey to prevent centralization. [1](#0-0) 

When a miner replaces their key, the `RecordCandidateReplacement` method updates the round's `RealTimeMinersInformation` but **does NOT update** `State.LatestPubkeyToTinyBlocksCount`: [2](#0-1) 

**Validation Bypass**: The `ContinuousBlocksValidationProvider` checks if a miner has produced too many blocks by comparing `latestPubkeyToTinyBlocksCount.Pubkey` with `validationContext.SenderPubkey`. After key replacement, these don't match (old key vs new key), so the `BlocksCount < 0` check is skipped: [3](#0-2) 

**Counter Reset**: In `ResetLatestProviderToTinyBlocksCount`, when the stored pubkey doesn't match the current miner's pubkey, the counter is **reset** to `minersCountInTheory.Sub(1)` (typically 7) instead of decrementing: [4](#0-3) 

**Entry Point**: The attack starts from `ReplaceCandidatePubkey` in the Election contract, which any candidate admin can call: [5](#0-4) 

**Why SenderPubkey Matches Block Signer**: The `SenderPubkey` in consensus extra data must match the actual block signer, validated during extraction: [6](#0-5) 

### Impact Explanation

**Consensus Integrity Violation**: The continuous block limit exists to prevent centralization and ensure fair block production among miners. The limit is typically 8 blocks (MaximumTinyBlocksCount): [7](#0-6) 

**Concrete Harm**:
1. **Unfair Mining Advantage**: A malicious miner can produce significantly more continuous blocks than allowed by preparing multiple keypairs and replacing their key just before hitting the limit
2. **Reward Misallocation**: More blocks = more mining rewards, giving the attacker unfair economic advantage
3. **Centralization Risk**: Defeats the purpose of the continuous block limit, allowing single miner dominance
4. **Network Fork Risk**: The limit was designed to reduce fork risk; bypassing it increases this risk

**Quantified Impact**: Each successful key replacement grants ~7 additional continuous blocks. With 10 prepared keypairs, an attacker could produce ~70 continuous blocks instead of the intended 8.

**Affected Parties**: All honest miners suffer reduced mining opportunities and rewards. The entire network's decentralization and security guarantees are weakened.

### Likelihood Explanation

**Reachable Entry Point**: `ReplaceCandidatePubkey` is a public method callable by any candidate admin: [8](#0-7) 

**Attacker Capabilities**: 
- Must control a candidate admin address (standard for any miner)
- Must prepare multiple fresh keypairs (trivial cost)
- Must time replacements during their mining window

**Execution Steps**:
1. Miner starts producing blocks with key_1, counter decrements from 7→6→5...→0
2. Just before counter reaches 0, call `ReplaceCandidatePubkey(key_1, key_2)`
3. Produce next block with key_2; counter resets to 7 instead of hitting limit
4. Repeat with key_3, key_4, etc.

**Detection Constraints**: While key replacements are on-chain events, they're legitimate operations and may not trigger immediate scrutiny: [9](#0-8) 

**Constraint**: Old keys are banned after replacement, preventing reuse, but fresh keys are unlimited: [10](#0-9) 

**Probability**: Medium - requires preparation but is technically straightforward with clear financial incentive (additional mining rewards).

### Recommendation

**Immediate Fix**: Update `RecordCandidateReplacement` to also update `State.LatestPubkeyToTinyBlocksCount` when a miner's key is replaced:

```csharp
public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
{
    Assert(Context.Sender == State.ElectionContract.Value,
        "Only Election Contract can record candidate replacement information.");

    if (!TryToGetCurrentRoundInformation(out var currentRound) ||
        !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

    // Update round information
    var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
    realTimeMinerInformation.Pubkey = input.NewPubkey;
    currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
    currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
    if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
        currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
    State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

    // FIX: Update LatestPubkeyToTinyBlocksCount if the replaced miner is currently tracked
    var latestPubkeyCount = State.LatestPubkeyToTinyBlocksCount.Value;
    if (latestPubkeyCount != null && latestPubkeyCount.Pubkey == input.OldPubkey)
    {
        State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
        {
            Pubkey = input.NewPubkey,
            BlocksCount = latestPubkeyCount.BlocksCount
        };
    }

    // Notify Treasury Contract
    State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
    {
        OldPubkey = input.OldPubkey,
        NewPubkey = input.NewPubkey,
        CurrentTermNumber = State.CurrentTermNumber.Value
    });

    return new Empty();
}
```

**Invariant to Enforce**: After any key replacement, if the replaced miner is tracked in `LatestPubkeyToTinyBlocksCount`, the pubkey must be updated to the new key while preserving the block count.

**Test Cases**:
1. Test key replacement when miner has produced several continuous blocks - verify counter is preserved with new pubkey
2. Test that validation still triggers correctly after replacement when limit is exceeded
3. Test multiple sequential replacements to ensure counter decrements properly across replacements

### Proof of Concept

**Initial State**:
- Miner A controls candidate with key_1, currently mining
- `State.LatestPubkeyToTinyBlocksCount = { Pubkey: "key_1", BlocksCount: 1 }`
- Miner A has produced 7 continuous blocks, one more would trigger NextRound behavior

**Attack Steps**:

1. **Setup**: Miner A prepares fresh key_2 in advance

2. **Just Before Limit**: 
   - Current state: `LatestPubkeyToTinyBlocksCount.BlocksCount = 1`
   - Next block would decrement to 0, then trigger NextRound on subsequent block

3. **Execute Replacement**:
   - Call `ElectionContract.ReplaceCandidatePubkey({ OldPubkey: "key_1", NewPubkey: "key_2" })`
   - `RecordCandidateReplacement` updates round info but NOT `LatestPubkeyToTinyBlocksCount`
   - State after: `LatestPubkeyToTinyBlocksCount = { Pubkey: "key_1", BlocksCount: 1 }` (unchanged)

4. **Produce Next Block with key_2**:
   - Block signed with key_2's private key
   - In validation: `latestPubkeyToTinyBlocksCount.Pubkey` ("key_1") != `validationContext.SenderPubkey` ("key_2")
   - Validation check at line 18 of `ContinuousBlocksValidationProvider` returns FALSE, skips `BlocksCount < 0` check
   - Validation passes ✓

5. **Counter Reset**:
   - `ResetLatestProviderToTinyBlocksCount` executes
   - `currentValue.Pubkey` ("key_1") != `_processingBlockMinerPubkey` ("key_2")
   - Else branch executes: counter **resets to 7** instead of decrementing
   - State after: `LatestPubkeyToTinyBlocksCount = { Pubkey: "key_2", BlocksCount: 7 }`

**Expected Result**: Counter should have decremented to 0, triggering NextRound behavior on next block

**Actual Result**: Counter reset to 7, allowing miner to produce 7 more continuous blocks

**Success Condition**: Miner produces 15+ total continuous blocks (7 + 1 + 7) instead of maximum 8, bypassing the consensus limit.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ConsensusValidationContext.cs (L35-38)
```csharp
    ///     This filed is to prevent one miner produces too many continues blocks
    ///     (which may cause problems to other parts).
    /// </summary>
    public LatestPubkeyToTinyBlocksCount LatestPubkeyToTinyBlocksCount { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L131-157)
```csharp
    public override Empty RecordCandidateReplacement(RecordCandidateReplacementInput input)
    {
        Assert(Context.Sender == State.ElectionContract.Value,
            "Only Election Contract can record candidate replacement information.");

        if (!TryToGetCurrentRoundInformation(out var currentRound) ||
            !currentRound.RealTimeMinersInformation.ContainsKey(input.OldPubkey)) return new Empty();

        // If this candidate is current miner, need to modify current round information.
        var realTimeMinerInformation = currentRound.RealTimeMinersInformation[input.OldPubkey];
        realTimeMinerInformation.Pubkey = input.NewPubkey;
        currentRound.RealTimeMinersInformation.Remove(input.OldPubkey);
        currentRound.RealTimeMinersInformation.Add(input.NewPubkey, realTimeMinerInformation);
        if (currentRound.ExtraBlockProducerOfPreviousRound == input.OldPubkey)
            currentRound.ExtraBlockProducerOfPreviousRound = input.NewPubkey;
        State.Rounds[State.CurrentRoundNumber.Value] = currentRound;

        // Notify Treasury Contract to update replacement information. (Update from old record.)
        State.TreasuryContract.RecordMinerReplacement.Send(new RecordMinerReplacementInput
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey,
            CurrentTermNumber = State.CurrentTermNumber.Value
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/ContinuousBlocksValidationProvider.cs (L16-24)
```csharp
            var latestPubkeyToTinyBlocksCount = validationContext.LatestPubkeyToTinyBlocksCount;
            if (latestPubkeyToTinyBlocksCount != null &&
                latestPubkeyToTinyBlocksCount.Pubkey == validationContext.SenderPubkey &&
                latestPubkeyToTinyBlocksCount.BlocksCount < 0)
            {
                validationResult.Message = "Sender produced too many continuous blocks.";
                return validationResult;
            }
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L350-363)
```csharp
        {
            currentValue = State.LatestPubkeyToTinyBlocksCount.Value;
            if (currentValue.Pubkey == _processingBlockMinerPubkey)
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = currentValue.BlocksCount.Sub(1)
                };
            else
                State.LatestPubkeyToTinyBlocksCount.Value = new LatestPubkeyToTinyBlocksCount
                {
                    Pubkey = _processingBlockMinerPubkey,
                    BlocksCount = minersCountInTheory.Sub(1)
                };
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L173-184)
```csharp
    public override Empty ReplaceCandidatePubkey(ReplaceCandidatePubkeyInput input)
    {
        Assert(IsCurrentCandidateOrInitialMiner(input.OldPubkey),
            "Pubkey is neither a current candidate nor an initial miner.");
        Assert(!IsPubkeyBanned(input.OldPubkey) && !IsPubkeyBanned(input.NewPubkey),
            "Pubkey is in already banned.");

        // Permission check.
        Assert(Context.Sender == GetCandidateAdmin(new StringValue { Value = input.OldPubkey }), "No permission.");

        // Record the replacement.
        PerformReplacement(input.OldPubkey, input.NewPubkey);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L245-246)
```csharp
        //     Ban old pubkey.
        State.BannedPubkeyMap[input.OldPubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L250-254)
```csharp
        Context.Fire(new CandidatePubkeyReplaced
        {
            OldPubkey = input.OldPubkey,
            NewPubkey = input.NewPubkey
        });
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/AEDPoSExtraDataExtractor.cs (L29-32)
```csharp
        var headerInformation = AElfConsensusHeaderInformation.Parser.ParseFrom(consensusExtraData);

        // Validate header information
        return headerInformation.SenderPubkey != header.SignerPubkey ? null : consensusExtraData;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L6-6)
```csharp
    public const int MaximumTinyBlocksCount = 8;
```
