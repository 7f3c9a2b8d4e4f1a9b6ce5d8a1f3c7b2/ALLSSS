# Audit Report

## Title
VRF Manipulation via Invalid PreviousInValue Leading to Mining Order Control

## Summary
A logic error in the AEDPoS consensus contract allows malicious miners to manipulate their mining order in subsequent rounds. When a miner provides an invalid `PreviousInValue` that fails self-check validation, the code correctly sets `previousInValue = Hash.Empty` but incorrectly calculates the signature using the invalid value. This signature directly determines the miner's position in the next round, breaking the VRF (Verifiable Random Function) fairness guarantee.

## Finding Description

The vulnerability exists in the `GetConsensusExtraDataToPublishOutValue()` method where signature calculation occurs outside the validation scope.

**The Critical Bug:**

When a miner produces a block, they should reveal their `PreviousInValue` which must hash to their previously committed `OutValue`. The self-check validation occurs here: [1](#0-0) 

When validation fails, `previousInValue` is correctly set to `Hash.Empty`. However, the signature calculation occurs OUTSIDE this validation block: [2](#0-1) 

This means the signature is always calculated from `triggerInformation.PreviousInValue` regardless of whether it passed validation. The mismatched values (previousInValue=Hash.Empty, signature calculated from invalid value) are then passed to `ApplyNormalConsensusData`: [3](#0-2) 

**Why the Signature Matters:**

In `ApplyNormalConsensusData`, the signature directly determines the miner's position in the next round through these operations: [4](#0-3) [5](#0-4) 

**Why Existing Protections Fail:**

The validation system explicitly allows `PreviousInValue = Hash.Empty` to pass: [6](#0-5) 

This design was intended for legitimate edge cases (first round, new miners), but it also permits the exploited scenario. There is no verification that the signature matches the actual `PreviousInValue` stored after validation.

**Mining Order Assignment:**

When generating the next round, miners are ordered by their `FinalOrderOfNextRound` value: [7](#0-6) 

The order directly determines each miner's `ExpectedMiningTime`, with lower order numbers receiving earlier mining slots.

**Attack Execution:**

1. Attacker (an authorized miner) computes off-chain: for various `candidateValue` inputs, calculate `signature = previousRound.CalculateSignature(candidateValue)` [8](#0-7) 
2. Convert each signature to determine resulting order using modulo arithmetic
3. Select the `candidateValue` that produces the desired order (e.g., order=1 for first position)
4. Submit block with this chosen invalid `PreviousInValue`
5. Self-check fails → `previousInValue` stored as `Hash.Empty` (passes validation)
6. Signature calculated from invalid value → controls next round position

## Impact Explanation

**Consensus Integrity Violation:**
- The AEDPoS consensus mechanism relies on VRF to ensure fair, unpredictable mining order
- Allowing miners to choose arbitrary values instead of revealing committed secrets breaks verifiable randomness
- This violates a core consensus invariant

**Concrete Harms:**
- Malicious miners can consistently position themselves at order 1 (first position) in every round
- Earlier mining positions provide multiple advantages:
  - Higher certainty of successful block production (less network risk)
  - Transaction ordering control and MEV (Miner Extractable Value) opportunities
  - Consistent first-position mining rewards
  
**Affected Parties:**
- Honest miners lose fair chances at early positions
- The entire consensus fairness guarantee is compromised
- Users expecting fair transaction ordering

**Severity Assessment:**
Medium severity because:
1. Breaks a critical consensus invariant (verifiable randomness)
2. Requires attacker to be an authorized miner (limited but realistic attack surface)
3. Does not directly steal funds but provides systemic competitive advantage
4. Exploitable in every round with minimal computational cost

## Likelihood Explanation

**Attacker Prerequisites:**
- Must be an authorized miner in the current round
- Can compute hash operations off-chain (no special cryptographic capabilities required)

**Attack Complexity:**
- LOW: Attacker computes `CalculateSignature(candidateValue)` for various candidate values off-chain
- Selects the value producing desired `FinalOrderOfNextRound` (e.g., order=1)
- Submits block with chosen invalid `PreviousInValue`

**Feasibility Factors:**
- Entry point is the standard block production flow (UpdateValue behavior)
- No additional permissions needed beyond being an active miner
- Computationally trivial (just hash operations)
- Can be repeated every round

**Detection Difficulty:**
- `PreviousInValue = Hash.Empty` is allowed by design for legitimate cases, making malicious use indistinguishable
- No penalty mechanism exists for this behavior in the consensus contract
- No alerts or monitoring beyond debug logging

**Probability:** HIGH for any motivated miner seeking consistent early positions and competitive advantages.

## Recommendation

Fix the logic error by ensuring the signature is calculated from the validated `previousInValue`, not the raw input:

```csharp
// In GetConsensusExtraDataToPublishOutValue, after line 90:
if (triggerInformation.PreviousInValue != null &&
    triggerInformation.PreviousInValue != Hash.Empty)
{
    // Self check
    if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
        HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
        previousRound.RealTimeMinersInformation[pubkey].OutValue)
    {
        Context.LogDebug(() => "Failed to produce block at previous round?");
        previousInValue = Hash.Empty;
    }
    else
    {
        previousInValue = triggerInformation.PreviousInValue;
    }
    
    // FIX: Calculate signature from validated previousInValue, not raw input
    signature = previousRound.CalculateSignature(previousInValue);
}
```

Additionally, consider adding validation that verifies the signature matches the expected calculation from `previousInValue` during consensus information processing.

## Proof of Concept

```csharp
[Fact]
public async Task VRF_Manipulation_Via_Invalid_PreviousInValue()
{
    // Setup: Initialize consensus with multiple miners
    var initialMiners = GenerateMiners(5);
    await InitializeConsensus(initialMiners);
    
    // Round 1: Honest mining to establish baseline
    await ProduceNormalBlocks(initialMiners, roundNumber: 1);
    var round1 = await GetCurrentRound();
    
    // Attacker is miner at index 0
    var attackerPubkey = initialMiners[0];
    var attackerPreviousOutValue = round1.RealTimeMinersInformation[attackerPubkey].OutValue;
    
    // Round 2: Attacker tries different invalid PreviousInValue values
    // to find one that produces order=1 in next round
    Hash chosenInvalidValue = null;
    for (int i = 0; i < 1000; i++)
    {
        var candidateValue = HashHelper.ComputeFrom($"arbitrary_value_{i}");
        var testSignature = round1.CalculateSignature(candidateValue);
        var testOrder = GetAbsModulus(testSignature.ToInt64(), initialMiners.Count) + 1;
        
        // Check if this value doesn't hash to the committed OutValue (invalid)
        // but produces order=1
        if (HashHelper.ComputeFrom(candidateValue) != attackerPreviousOutValue && 
            testOrder == 1)
        {
            chosenInvalidValue = candidateValue;
            break;
        }
    }
    
    chosenInvalidValue.ShouldNotBeNull();
    
    // Attacker produces block with invalid PreviousInValue
    var attackerBlock = await ProduceBlockWithCustomPreviousInValue(
        attackerPubkey, 
        chosenInvalidValue
    );
    
    // Verify block is accepted (validation passes because PreviousInValue=Hash.Empty is allowed)
    attackerBlock.ShouldNotBeNull();
    
    var round2 = await GetCurrentRound();
    var attackerInfo = round2.RealTimeMinersInformation[attackerPubkey];
    
    // Verify: previousInValue is Hash.Empty (validation failed)
    attackerInfo.PreviousInValue.ShouldBe(Hash.Empty);
    
    // But: FinalOrderOfNextRound is 1 (calculated from invalid value)
    attackerInfo.FinalOrderOfNextRound.ShouldBe(1);
    
    // Round 3: Verify attacker gets first position
    await GenerateNextRound();
    var round3 = await GetCurrentRound();
    var firstMiner = round3.RealTimeMinersInformation.Values.First(m => m.Order == 1);
    firstMiner.Pubkey.ShouldBe(attackerPubkey);
    
    // Attacker successfully manipulated mining order
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L80-86)
```csharp
                if (previousRound.RealTimeMinersInformation.ContainsKey(pubkey) &&
                    HashHelper.ComputeFrom(triggerInformation.PreviousInValue) !=
                    previousRound.RealTimeMinersInformation[pubkey].OutValue)
                {
                    Context.LogDebug(() => "Failed to produce block at previous round?");
                    previousInValue = Hash.Empty;
                }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L92-92)
```csharp
                signature = previousRound.CalculateSignature(triggerInformation.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L111-112)
```csharp
        var updatedRound = currentRound.ApplyNormalConsensusData(pubkey, previousInValue,
            outValue, signature);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L19-21)
```csharp
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L42-44)
```csharp
        RealTimeMinersInformation[pubkey].SupposedOrderOfNextRound = supposedOrderOfNextRound;
        // Initialize FinalOrderOfNextRound as the value of SupposedOrderOfNextRound
        RealTimeMinersInformation[pubkey].FinalOrderOfNextRound = supposedOrderOfNextRound;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L46-46)
```csharp
        if (previousInValue == Hash.Empty) return true;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L26-33)
```csharp
        foreach (var minerInRound in minersMinedCurrentRound.OrderBy(m => m.FinalOrderOfNextRound))
        {
            var order = minerInRound.FinalOrderOfNextRound;
            nextRound.RealTimeMinersInformation[minerInRound.Pubkey] = new MinerInRound
            {
                Pubkey = minerInRound.Pubkey,
                Order = order,
                ExpectedMiningTime = currentBlockTimestamp.AddMilliseconds(miningInterval.Mul(order)),
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```
