### Title
Evil Miner Punishment Bypass via View-Context Inline Transaction

### Summary
When evil miners are replaced mid-term through `GetMinerReplacementInformation`, the `UpdateCandidateInformation` call marking them as evil nodes executes only during view method execution in `GenerateNextRoundInformation`. Since view methods' inline transactions are not persisted, replaced evil miners escape all punishment mechanisms (banning, candidate removal, profit termination) while still being removed from the miner list, allowing them to immediately participate in future elections without reputation damage.

### Finding Description

The vulnerability exists in the miner replacement flow within the consensus contract:

**Vulnerable Code Path:**

1. During block production, `GetConsensusExtraDataForNextRound` calls `GenerateNextRoundInformation` to prepare next round data. [1](#0-0) 

2. In `GenerateNextRoundInformation`, when miners need replacement (detected via `GetMinerReplacementInformation.Call`), the code calls `UpdateCandidateInformation` with `isEvilNode=true`: [2](#0-1) 

3. The `UpdateCandidateInformation` method uses `.Send()` which creates an inline transaction: [3](#0-2) 

4. After this call, the evil miner is removed from the round and replaced: [4](#0-3) 

**Root Cause:**

`GetConsensusExtraDataForNextRound` is called from the view method `GetConsensusExtraData`: [5](#0-4) 

View methods are marked as read-only: [6](#0-5) 

During view execution, inline transactions created via `SendInline` are added to the trace but NOT executed: [7](#0-6) 

View methods use read-only execution that doesn't persist state changes: [8](#0-7) 

**Why Existing Protections Fail:**

When the actual state-modifying transaction `NextRound` executes, it calls `ProcessNextRound`: [9](#0-8) 

`ProcessNextRound` only calls `UpdateCandidateInformation` for evil miners detected via `TryToDetectEvilMiners` on the CURRENT round: [10](#0-9) 

However, miners who were REPLACED (via `GetMinerReplacementInformation` in the view context) are NOT in this detection list because they've already been removed from the round data structure. The nextRound input already has them replaced, so `ProcessNextRound` never calls `UpdateCandidateInformation` for them.

### Impact Explanation

When `UpdateCandidateInformation` with `isEvilNode=true` is NOT executed, the following critical punishment mechanisms fail:

1. **No Banning**: Evil miner NOT added to `BannedPubkeyMap` [11](#0-10) 

2. **Candidate Info Retained**: Candidate information NOT removed from Election contract [12](#0-11) 

3. **Profit Distribution Continues**: Beneficiary NOT removed, evil miner continues receiving rewards [13](#0-12) 

4. **No Reputation Damage**: No `EvilMinerDetected` event fired [14](#0-13) 

**Concrete Harm:**
- Evil miners removed from current term but can immediately participate in next election cycle
- Continue receiving subsidy and welfare distributions they shouldn't receive
- No deterrent effect on malicious behavior
- Protocol reputation damage as evil nodes operate unpunished
- Honest miners and token holders subsidize malicious actors

**Affected Parties:**
- All token holders (through diluted rewards)
- Honest miner candidates (competing against unpunished evil nodes)
- Protocol integrity and trustworthiness

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker must be a current miner who engages in evil behavior (e.g., repeated missed blocks, double signing)
- Must be detected by `GetMinerReplacementInformation` logic in Election contract
- No special privileges required beyond being a miner

**Attack Complexity:**
- Vulnerability triggers automatically when replacement mechanism activates
- No active exploitation needed - it's a passive bypass due to code flow issue
- Happens naturally in the protocol's normal operation

**Feasibility Conditions:**
- Main chain only (check at line 299: `if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber)`) [15](#0-14) 

- During same term when `GetMinerReplacementInformation` returns replacements
- Occurs whenever miner replacement is needed mid-term

**Detection:**
- Difficult to detect as logs show `MinerReplaced` event firing correctly [16](#0-15) 

- No error thrown, replacement appears successful
- Only observable by checking Election contract state (candidate not removed, not banned)

**Probability:**
- HIGH - Occurs every time miner replacement happens mid-term
- Not an edge case, but a systematic flaw in the punishment flow

### Recommendation

**Immediate Fix:**
Move the `UpdateCandidateInformation(isEvilNode=true)` call from the view-context method to the state-modifying `ProcessNextRound` method. After adding the next round information, iterate through replaced miners and update their candidate information.

**Code-Level Mitigation:**
In `ProcessNextRound`, after line 156 (`AddRoundInformation(nextRound)`), add:

```csharp
// Punish replaced miners
if (State.IsMainChain.Value && nextRound.IsMinerListJustChanged)
{
    // Get previous round miners
    var previousMiners = currentRound.RealTimeMinersInformation.Keys.ToHashSet();
    var currentMiners = nextRound.RealTimeMinersInformation.Keys.ToHashSet();
    
    // Find replaced miners
    var replacedMiners = previousMiners.Except(currentMiners);
    
    foreach (var replacedMiner in replacedMiners)
    {
        // Update with evil node flag
        State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
        {
            Pubkey = replacedMiner,
            RecentlyProducedBlocks = currentRound.RealTimeMinersInformation[replacedMiner].ProducedBlocks,
            RecentlyMissedTimeSlots = currentRound.RealTimeMinersInformation[replacedMiner].MissedTimeSlots,
            IsEvilNode = true
        });
    }
}
```

Remove the `UpdateCandidateInformation` call from `GenerateNextRoundInformation` (lines 317-319) as it has no effect in view context.

**Invariant Checks:**
- After miner replacement, verify `BannedPubkeyMap[replacedMinerPubkey] == true`
- Verify replaced miner's candidate information is removed from Election contract
- Verify `EvilMinerDetected` event is fired for each replaced miner

**Test Cases:**
1. Test miner replacement mid-term â†’ verify evil miner is banned in Election contract
2. Test replaced miner cannot participate in next election
3. Test replaced miner's beneficiary is removed and stops receiving profits
4. Test `EvilMinerDetected` event is correctly emitted

### Proof of Concept

**Initial State:**
- Main chain consensus running
- Current term with multiple active miners
- One miner (MinerA) repeatedly misses time slots, triggering replacement criteria

**Attack Sequence:**

1. Election contract's `GetMinerReplacementInformation` returns MinerA as evil miner needing replacement
2. Miner produces extra block triggering round transition
3. `GetConsensusExtraData` view call executes:
   - `GenerateNextRoundInformation` runs
   - Lines 317-319 call `UpdateCandidateInformation.Send(MinerA, ..., isEvilNode=true)`
   - Inline transaction added to view trace (not executed)
   - MinerA removed from round, AlternativeCandidate added
4. `NextRound` transaction executes with pre-prepared data:
   - `ProcessNextRound` runs
   - Lines 139-154: `TryToDetectEvilMiners` checks current round (before replacement)
   - MinerA not in detection list (already replaced in data)
   - `AddRoundInformation(nextRound)` persists the new round
5. Query Election contract state for MinerA

**Expected Result (Secure):**
- `State.BannedPubkeyMap[MinerA] == true`
- `State.CandidateInformationMap[MinerA] == null`
- MinerA cannot be elected in future
- MinerA's beneficiary removed from profit distributions

**Actual Result (Vulnerable):**
- `State.BannedPubkeyMap[MinerA] == false` (not set)
- `State.CandidateInformationMap[MinerA]` still exists with full history
- MinerA remains in `State.Candidates.Value` list
- MinerA can participate in next election cycle
- MinerA's beneficiary continues receiving profits

**Success Condition:**
Evil miner successfully removed from current miner list but retains all candidate privileges and reward distributions, ready to re-enter in next term without reputation consequences.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L173-176)
```csharp
    private AElfConsensusHeaderInformation GetConsensusExtraDataForNextRound(Round currentRound,
        string pubkey, AElfConsensusTriggerInformation triggerInformation)
    {
        GenerateNextRoundInformation(currentRound, Context.CurrentBlockTime, out var nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L299-299)
```csharp
        if (IsMainChain && previousRound.TermNumber == currentRound.TermNumber) // In same term.
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L301-319)
```csharp
            var minerReplacementInformation = State.ElectionContract.GetMinerReplacementInformation.Call(
                new GetMinerReplacementInformationInput
                {
                    CurrentMinerList = { currentRound.RealTimeMinersInformation.Keys }
                });

            Context.LogDebug(() => $"Got miner replacement information:\n{minerReplacementInformation}");

            if (minerReplacementInformation.AlternativeCandidatePubkeys.Count > 0)
            {
                for (var i = 0; i < minerReplacementInformation.AlternativeCandidatePubkeys.Count; i++)
                {
                    var alternativeCandidatePubkey = minerReplacementInformation.AlternativeCandidatePubkeys[i];
                    var evilMinerPubkey = minerReplacementInformation.EvilMinerPubkeys[i];

                    // Update history information of evil node.
                    UpdateCandidateInformation(evilMinerPubkey,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].ProducedBlocks,
                        currentRound.RealTimeMinersInformation[evilMinerPubkey].MissedTimeSlots, true);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L321-324)
```csharp
                    Context.Fire(new MinerReplaced
                    {
                        NewMinerPubkey = alternativeCandidatePubkey
                    });
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L327-338)
```csharp
                    var evilMinerInformation = currentRound.RealTimeMinersInformation[evilMinerPubkey];
                    var minerInRound = new MinerInRound
                    {
                        Pubkey = alternativeCandidatePubkey,
                        ExpectedMiningTime = evilMinerInformation.ExpectedMiningTime,
                        Order = evilMinerInformation.Order,
                        PreviousInValue = Hash.Empty,
                        IsExtraBlockProducer = evilMinerInformation.IsExtraBlockProducer
                    };

                    currentRound.RealTimeMinersInformation.Remove(evilMinerPubkey);
                    currentRound.RealTimeMinersInformation.Add(alternativeCandidatePubkey, minerInRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ViewMethods.cs (L367-379)
```csharp
    private void UpdateCandidateInformation(string candidatePublicKey, long recentlyProducedBlocks,
        long recentlyMissedTimeSlots, bool isEvilNode = false)
    {
        if (!State.IsMainChain.Value) return;

        State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
        {
            Pubkey = candidatePublicKey,
            RecentlyProducedBlocks = recentlyProducedBlocks,
            RecentlyMissedTimeSlots = recentlyMissedTimeSlots,
            IsEvilNode = isEvilNode
        });
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** protobuf/acs4.proto (L24-27)
```text
    // Generate consensus extra data when a block is generated. 
    rpc GetConsensusExtraData (google.protobuf.BytesValue) returns (google.protobuf.BytesValue) {
        option (aelf.is_view) = true;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L228-237)
```csharp
    public void SendInline(Address toAddress, string methodName, ByteString args)
    {
        TransactionContext.Trace.InlineTransactions.Add(new Transaction
        {
            From = Self,
            To = toAddress,
            MethodName = methodName,
            Params = args
        });
    }
```

**File:** src/AElf.Kernel.SmartContract/Application/TransactionReadOnlyExecutionService.cs (L22-39)
```csharp
    public async Task<TransactionTrace> ExecuteAsync(IChainContext chainContext, Transaction transaction,
        Timestamp currentBlockTime)
    {
        var transactionContext = _transactionContextFactory.Create(transaction, chainContext, currentBlockTime);
        var executive = await _smartContractExecutiveService.GetExecutiveAsync(
            chainContext, transaction.To);

        try
        {
            await executive.ApplyAsync(transactionContext);
        }
        finally
        {
            await _smartContractExecutiveService.PutExecutiveAsync(chainContext, transaction.To, executive);
        }

        return transactionContext.Trace;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L161-166)
```csharp
    public override Empty NextRound(NextRoundInput input)
    {
        SupplyCurrentRoundInformation();
        ProcessConsensusInformation(input);
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L139-154)
```csharp
        if (State.IsMainChain.Value && // Only detect evil miners in Main Chain.
            currentRound.TryToDetectEvilMiners(out var evilMiners))
        {
            Context.LogDebug(() => "Evil miners detected.");
            foreach (var evilMiner in evilMiners)
            {
                Context.LogDebug(() =>
                    $"Evil miner {evilMiner}, missed time slots: {currentRound.RealTimeMinersInformation[evilMiner].MissedTimeSlots}.");
                // Mark these evil miners.
                State.ElectionContract.UpdateCandidateInformation.Send(new UpdateCandidateInformationInput
                {
                    Pubkey = evilMiner,
                    IsEvilNode = true
                });
            }
        }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L93-96)
```csharp
        if (input.IsEvilNode)
        {
            var publicKeyByte = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
            State.BannedPubkeyMap[input.Pubkey] = true;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L105-106)
```csharp
            Context.LogDebug(() => $"Marked {input.Pubkey.Substring(0, 10)} as an evil node.");
            Context.Fire(new EvilMinerDetected { Pubkey = input.Pubkey });
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L107-110)
```csharp
            State.CandidateInformationMap.Remove(input.Pubkey);
            var candidates = State.Candidates.Value;
            candidates.Value.Remove(ByteString.CopyFrom(publicKeyByte));
            State.Candidates.Value = candidates;
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Maintainence.cs (L111-112)
```csharp
            RemoveBeneficiary(input.Pubkey);
            return new Empty();
```
