### Title
Decimal Overflow in Exponential Calculation Causes DoS in Token Sell Operations with Extreme Connector Weight Ratios

### Summary
The `GetReturnFromPaid()` function in BancorHelper computes `Exp(y * Ln(x))` where `y` is the connector weight ratio and can be arbitrarily large when governance sets extreme weight configurations. When users attempt to sell large amounts of tokens, the exponent `y * Ln(x)` can reach values that cause intermediate calculations in the Taylor series to overflow `decimal.MaxValue`, resulting in an `OverflowException` that prevents legitimate sell operations. [1](#0-0) 

### Finding Description

The vulnerability exists in the exponential calculation at line 53 of `BancorHelper.cs`. The function computes: [2](#0-1) 

Where:
- `x = fromConnectorBalance / (fromConnectorBalance + paidAmount)`, resulting in `0 < x < 1`
- `y = fromConnectorWeight / toConnectorWeight`

Connector weights are validated to be between 0 and 1 (exclusive): [3](#0-2) 

However, there is no constraint preventing extreme weight ratios. For example, if `fromConnectorWeight = 0.99` and `toConnectorWeight = 0.01`, then `y = 99`.

When a user sells a large amount of tokens (making `paidAmount >> fromConnectorBalance`), `x` becomes very small (e.g., `x = 0.001`), causing `Ln(x) ≈ -6.907`. The product `y * Ln(x) = 99 × (-6.907) ≈ -683`.

The `Exp()` function uses a Taylor series with 20 iterations: [4](#0-3) 

For `Exp(-683)`, the Taylor series computes terms like `(-683)^20 / 20!`. Since `(-683)^20 = 683^20 ≈ 10^56`, this exceeds `decimal.MaxValue ≈ 7.9 × 10^28`. The `Pow()` function's intermediate calculations will overflow: [5](#0-4) 

The AElf contract execution model enforces overflow checking, causing an `OverflowException` that aborts the transaction: [6](#0-5) 

This affects the `Sell()` operation which calls `GetReturnFromPaid()`: [7](#0-6) 

### Impact Explanation

**Operational DoS**: Users cannot sell tokens when:
1. Connector weights have ratios greater than approximately 10:1
2. Users attempt to sell amounts that are large relative to the pool balance

**Affected Operations**:
- Direct sell operations via `Sell()` function fail with `OverflowException`
- Token liquidity is severely restricted
- Users holding large token amounts cannot exit positions

**Severity Justification**: While this does not directly cause fund loss, it creates a critical operational failure that locks users into positions. If governance inadvertently configures extreme weight ratios (e.g., 0.9:0.1 or higher), even moderately large sell orders will fail, effectively breaking the token converter's core functionality.

### Likelihood Explanation

**Attack Complexity**: Medium
- **Precondition 1**: Governance must configure connector pairs with extreme weight ratios (e.g., 0.99:0.01 or 0.95:0.05)
  - This is controlled by Parliament via `AddPairConnector()` or `UpdateConnector()`
  - While unlikely in standard configurations, it may occur through governance error or intentional exotic configurations [8](#0-7) 

- **Precondition 2**: Users attempt to sell large amounts
  - This is normal user behavior when exiting positions or providing large liquidity
  - No attacker capabilities required beyond holding tokens

**Exploitability**: High once preconditions are met
- Any user with sufficient token balance can trigger the DoS
- No special permissions or complex sequences required
- The calculation happens deterministically before any state changes

**Detection**: The issue would manifest immediately upon the first large sell attempt after extreme weights are configured, making it discoverable through normal usage.

### Recommendation

**1. Add bounds validation for connector weight ratios**:

Add a maximum weight ratio constraint in `AssertValidConnectorWeight()`:

```csharp
private void AssertValidConnectorWeight(Connector connector)
{
    var weight = AssertedDecimal(connector.Weight);
    Assert(IsBetweenZeroAndOne(weight), "Connector Shares has to be a decimal between 0 and 1.");
    
    // Add validation against related connector if it exists
    if (!string.IsNullOrEmpty(connector.RelatedSymbol))
    {
        var relatedConnector = State.Connectors[connector.RelatedSymbol];
        if (relatedConnector != null && !string.IsNullOrEmpty(relatedConnector.Weight))
        {
            var relatedWeight = AssertedDecimal(relatedConnector.Weight);
            var ratio = Math.Max(weight / relatedWeight, relatedWeight / weight);
            Assert(ratio <= 10m, "Connector weight ratio cannot exceed 10:1 to prevent calculation overflow");
        }
    }
    
    connector.Weight = weight.ToString(CultureInfo.InvariantCulture);
}
```

**2. Add input validation to limit sell amounts**:

In `Sell()` function, validate that the sell amount doesn't exceed a safe threshold relative to pool balance:

```csharp
// Before line 168
var fromBalance = GetSelfBalance(fromConnector);
Assert(input.Amount <= fromBalance * 100, "Sell amount too large relative to pool balance");
```

**3. Improve Exp() accuracy for large exponents**:

Consider using a different algorithm for exponentials outside the efficient Taylor series range (-10 to 10), such as identity `Exp(x) = Exp(x/2)^2` to reduce large exponents before Taylor series application.

**4. Add comprehensive test cases**:

```csharp
[Theory]
[InlineData(0.99, 0.01)]  // Extreme ratio 99:1
[InlineData(0.95, 0.05)]  // High ratio 19:1
public void Sell_LargeAmount_ExtremeWeights_ShouldNotOverflow(decimal weight1, decimal weight2)
{
    // Test selling large amounts with extreme weight ratios
}
```

### Proof of Concept

**Initial State**:
1. Deploy TokenConverter with connectors having extreme weight ratio:
   - Resource connector: weight = "0.01"
   - Native connector: weight = "0.99"
   - This creates `y = 0.99 / 0.01 = 99`

2. Enable the connector pair with minimal liquidity:
   - fromConnectorBalance (resource tokens) = 1,000
   - toConnectorBalance (base tokens) = 100,000

**Exploitation Steps**:
1. User obtains 999,000 resource tokens (through legitimate minting/purchase)
2. User calls `Sell()` with:
   - Symbol = resource token
   - Amount = 999,000
   - ReceiveLimit = 0

**Expected Result** (Bancor formula):
- `x = 1,000 / (1,000 + 999,000) = 0.001`
- `Ln(0.001) ≈ -6.907`
- `y * Ln(x) = 99 × (-6.907) ≈ -683`
- `Exp(-683)` should be calculated
- User receives base tokens proportional to the formula

**Actual Result**:
- During `Exp(-683)` calculation at iteration 20
- `Pow(-683, 20)` attempts to compute `683^20`
- Intermediate multiplication exceeds `decimal.MaxValue`
- `System.OverflowException` thrown
- Transaction reverts
- User cannot sell tokens

**Success Condition**: Transaction fails with overflow exception, preventing any sell operations with large amounts when extreme weight ratios are configured.

### Notes

The query specifically asks whether line 53 produces "inaccurate results that misprice tokens." The actual behavior is that the overflow protection prevents any pricing from occurring—the transaction fails entirely rather than producing incorrect prices. This transforms the concern from a pricing vulnerability into a denial-of-service vulnerability. The issue also affects `GetAmountToPayFromReturn()` at line 93 (used in `Buy()` operations) through a symmetric mechanism where positive exponents can overflow.

### Citations

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L34-54)
```csharp
    public static long GetReturnFromPaid(long fromConnectorBalance, decimal fromConnectorWeight,
        long toConnectorBalance, decimal toConnectorWeight, long paidAmount)
    {
        if (fromConnectorBalance <= 0 || toConnectorBalance <= 0)
            throw new InvalidValueException("Connector balance needs to be a positive number.");

        if (paidAmount <= 0) throw new InvalidValueException("Amount needs to be a positive number.");

        decimal bf = fromConnectorBalance;
        var wf = fromConnectorWeight;
        decimal bt = toConnectorBalance;
        var wt = toConnectorWeight;
        decimal a = paidAmount;
        if (wf == wt)
            // if both weights are the same, the formula can be reduced
            return (long)(bt / (bf + a) * a);

        var x = bf / (bf + a);
        var y = wf / wt;
        return (long)(bt * (decimal.One - Exp(y * Ln(x))));
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L104-120)
```csharp
    public static decimal Pow(decimal x, uint y)
    {
        if (y == 1)
            return x;

        var A = 1m;
        var e = new BitArray(y.ToBytes(false));
        var t = e.Count;

        for (var i = t - 1; i >= 0; --i)
        {
            A *= A;
            if (e[i]) A *= x;
        }

        return A;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/BancorHelper.cs (L148-165)
```csharp
    private static decimal Exp(decimal y)
    {
        /*
        exp(y) = 1 + y + y^2/2 + x^3/3! + y^4/4! + y^5/5! + ...
        */

        var iteration = _LOOPS;
        decimal result = 1;
        while (iteration > 0)
        {
            //uint fatorial = Factorial(iteration);
            var fatorial = Fact[iteration - 1];
            result += Pow(y, (uint)iteration) / fatorial;
            iteration--;
        }

        return result;
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L79-110)
```csharp
    public override Empty AddPairConnector(PairConnectorParam input)
    {
        AssertPerformedByConnectorController();
        Assert(!string.IsNullOrEmpty(input.ResourceConnectorSymbol),
            "resource token symbol should not be empty");
        var nativeConnectorSymbol = NewNtTokenPrefix.Append(input.ResourceConnectorSymbol);
        Assert(State.Connectors[input.ResourceConnectorSymbol] == null,
            "resource token symbol has existed");
        var resourceConnector = new Connector
        {
            Symbol = input.ResourceConnectorSymbol,
            IsPurchaseEnabled = false,
            RelatedSymbol = nativeConnectorSymbol,
            Weight = input.ResourceWeight
        };
        Assert(IsValidSymbol(resourceConnector.Symbol), "Invalid symbol.");
        AssertValidConnectorWeight(resourceConnector);
        var nativeTokenToResourceConnector = new Connector
        {
            Symbol = nativeConnectorSymbol,
            VirtualBalance = input.NativeVirtualBalance,
            IsVirtualBalanceEnabled = true,
            IsPurchaseEnabled = false,
            RelatedSymbol = input.ResourceConnectorSymbol,
            Weight = input.NativeWeight,
            IsDepositAccount = true
        };
        AssertValidConnectorWeight(nativeTokenToResourceConnector);
        State.Connectors[resourceConnector.Symbol] = resourceConnector;
        State.Connectors[nativeTokenToResourceConnector.Symbol] = nativeTokenToResourceConnector;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L168-172)
```csharp
        var amountToReceive = BancorHelper.GetReturnFromPaid(
            GetSelfBalance(fromConnector), GetWeight(fromConnector),
            GetSelfBalance(toConnector), GetWeight(toConnector),
            input.Amount
        );
```

**File:** contract/AElf.Contracts.TokenConverter/TokenConverterContract.cs (L354-357)
```csharp
    private static bool IsBetweenZeroAndOne(decimal number)
    {
        return number > decimal.Zero && number < decimal.One;
    }
```

**File:** docs-sphinx/architecture/smart-contract/restrictions/project.md (L1-100)
```markdown
# Contract Project Requirements

## Project Properties
- It is required to add `ContractCode` property in your contract project, so that the contract's DLL will be post processed by AElf's contract patcher to perform necessary injections that are required by code checks during deployment. Otherwise, deployment will fail.

```xml
<PropertyGroup>
  <TargetFramework>net8.0</TargetFramework>
  <RootNamespace>AElf.Contracts.MyContract</RootNamespace>
  <GeneratePackageOnBuild>true</GeneratePackageOnBuild>
</PropertyGroup>

<PropertyGroup>
	<ContractCode Include="..\..\protobuf\my_contract.proto">
            <Link>Protobuf\Proto\my_contract.proto</Link>
        </ContractCode>
</PropertyGroup>
```

- It is required to enable `CheckForOverflowUnderflow` for both Release and Debug mode so that your contract will use arithmetic operators that will throw `OverflowException` if there is any overflow. This is to ensure that execution will not continue in case of an overflow in your contract and result with unpredictable output.

```xml
<PropertyGroup Condition=" '$(Configuration)' == 'Debug' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>

<PropertyGroup Condition=" '$(Configuration)' == 'Release' ">
  <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
</PropertyGroup>
```

If your contract contains any unchecked arithmetic operators, deployment will fail.
```
