### Title
Governance Bypass via Malicious Organization Contract in ChangeMethodFeeController

### Summary
The `ChangeMethodFeeController()` function validates organization existence by calling `CheckOrganizationExist()`, which invokes `ValidateOrganizationExist` on an arbitrary contract address without verifying it's a legitimate organization contract (Parliament, Association, or Referendum). An attacker can deploy a malicious contract implementing this method to always return true, then use a governance proposal to set it as the method fee controller, permanently bypassing governance controls for all future method fee changes.

### Finding Description

The vulnerability exists in the method fee controller change mechanism: [1](#0-0) 

The function calls `CheckOrganizationExist(input)` at line 25, which is implemented as: [2](#0-1) 

**Root Cause**: `CheckOrganizationExist` performs a cross-contract call to `authorityInfo.ContractAddress` without validating that this address corresponds to a legitimate organization contract. It trusts whatever contract is at that address to honestly implement `ValidateOrganizationExist`.

Legitimate organization contracts (e.g., Parliament) implement this method by checking internal state: [3](#0-2) 

However, the Genesis contract never verifies that `input.ContractAddress` is actually Parliament, Association, or Referendum. It only checks that the contract at that address has a method named `ValidateOrganizationExist` that returns true.

**Why Protections Fail**: 
1. The authority check at line 24 only ensures the sender is the current controller's owner (typically Parliament's organization address)
2. No whitelist or validation exists for allowed organization contract addresses
3. Context.Call does not automatically validate target contracts are system contracts
4. User-deployed contracts can implement any interface including ACS3 methods: [4](#0-3) 

### Impact Explanation

**Governance Impact - Critical**: Once the malicious controller is set, the attacker gains permanent unilateral control over method fees for the Genesis contract, completely bypassing the intended multi-party governance mechanism.

**Specific Harms**:
1. **Governance Bypass**: The attacker can call `SetMethodFee` directly without proposals, voting, or approval: [5](#0-4) 

2. **Economic Manipulation**: The attacker can set arbitrary fees for critical Genesis contract operations including contract deployment, updates, and system configuration changes

3. **Operational DoS**: The attacker could set prohibitively high fees to block legitimate contract deployment or updates, disrupting the entire blockchain's operation

4. **Persistent Control**: The attack is permanent until another governance proposal successfully changes the controller back, which requires the original governance process

**Who Is Affected**: All blockchain users, as Genesis contract controls system-level operations and fees for the entire chain.

### Likelihood Explanation

**Attacker Capabilities Required**:
1. Ability to deploy a user contract (standard capability)
2. Ability to create a governance proposal through Parliament (requires being whitelisted or having proposal rights)
3. Social engineering or voter apathy to get the malicious proposal approved

**Attack Complexity - Medium**: 
- **Technical Steps**: Deploy malicious contract, create proposal, wait for approval
- **Social Engineering**: The proposal would appear as a legitimate governance structure change. Voters might not scrutinize the ContractAddress parameter closely
- **Code Required**: Simple malicious contract:
```csharp
public override BoolValue ValidateOrganizationExist(Address input) {
    return new BoolValue { Value = true };
}
```

**Feasibility Conditions**:
- Governance participants must approve the proposal, but this is realistic given:
  - Complex governance proposals are common
  - Technical details in parameters are often not fully audited by voters
  - A misleading proposal description could mask the attack
  - Historical governance systems show voter apathy is common

**Detection**: The malicious contract would be on-chain and visible, but without specific monitoring for this pattern, it could go unnoticed until exploited.

**Economic Rationality**: The attack cost is minimal (contract deployment + proposal creation fees), while the gained control over system fees is extremely valuable.

### Recommendation

**Immediate Fix**: Add validation that `input.ContractAddress` is one of the three legitimate organization contracts:

```csharp
public override Empty ChangeMethodFeeController(AuthorityInfo input)
{
    RequiredMethodFeeControllerSet();
    AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
    
    // Add this validation
    var parliamentAddress = Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    var associationAddress = Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName);
    var referendumAddress = Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName);
    
    Assert(
        input.ContractAddress == parliamentAddress ||
        input.ContractAddress == associationAddress ||
        input.ContractAddress == referendumAddress,
        "ContractAddress must be a legitimate organization contract.");
    
    var organizationExist = CheckOrganizationExist(input);
    Assert(organizationExist, "Invalid authority input.");

    State.MethodFeeController.Value = input;
    return new Empty();
}
```

**Apply Same Fix To All Similar Functions**:
This pattern appears in multiple contracts: [6](#0-5) [7](#0-6) [8](#0-7) 

**Test Cases**: 
1. Test that ChangeMethodFeeController rejects non-system-contract addresses
2. Test that malicious contracts with ValidateOrganizationExist cannot be set as controllers
3. Test that only Parliament, Association, and Referendum addresses are accepted

### Proof of Concept

**Initial State**: Genesis contract MethodFeeController = {ContractAddress: Parliament, OwnerAddress: DefaultParliamentOrg}

**Step 1 - Deploy Malicious Contract**:
```
Contract: MaliciousOrganization
Method: ValidateOrganizationExist(Address) → BoolValue(true)
```

**Step 2 - Create Proposal**:
```
Call: Parliament.CreateProposal
Target: Genesis.ChangeMethodFeeController  
Params: AuthorityInfo {
    ContractAddress: <MaliciousOrganization>,
    OwnerAddress: <AttackerAddress>
}
```

**Step 3 - Approve and Release**:
```
Parliament members approve proposal
Release proposal → executes ChangeMethodFeeController
```

**Step 4 - Verify Bypass**:
```
Call: Genesis.SetMethodFee (from AttackerAddress)
Expected: Transaction fails (unauthorized)
Actual: Transaction succeeds (attacker is now controller)
```

**Success Condition**: Attacker can set arbitrary method fees without governance approval, confirmed by directly calling SetMethodFee and observing the transaction succeeds with attacker as sender.

### Notes

This vulnerability affects the entire controller change pattern across multiple AElf contracts. All instances where `CheckOrganizationExist` is used to validate a new controller should be reviewed and patched with the same mitigation. The fix must be applied consistently to prevent attackers from exploiting this pattern in any governance-controlled contract.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L9-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);

        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZeroContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L180-185)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** src/AElf.CSharp.CodeOps/Validators/Whitelist/IWhitelistProvider.cs (L50-52)
```csharp
            .Assembly(typeof(CSharpSmartContract).Assembly, Trust.Full) // AElf.Sdk.CSharp
            .Assembly(typeof(Address).Assembly, Trust.Full) // AElf.Types
            .Assembly(typeof(IMethod).Assembly, Trust.Full) // AElf.CSharp.Core
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L366-373)
```csharp
    public override Empty ChangeContractDeploymentController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.ContractDeploymentController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");
        State.ContractDeploymentController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L375-382)
```csharp
    public override Empty ChangeCodeCheckController(AuthorityInfo input)
    {
        AssertSenderAddressWith(State.CodeCheckController.Value.OwnerAddress);
        Assert(CheckOrganizationExist(input),
            "Invalid authority input.");
        State.CodeCheckController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Method_Authorization.cs (L45-51)
```csharp
    public override Empty ChangeSymbolsToPayTXSizeFeeController(AuthorityInfo input)
    {
        AssertControllerForSymbolToPayTxSizeFee();
        Assert(CheckOrganizationExist(input), "new controller does not exist");
        State.SymbolToPayTxFeeController.Value = input;
        return new Empty();
    }
```
