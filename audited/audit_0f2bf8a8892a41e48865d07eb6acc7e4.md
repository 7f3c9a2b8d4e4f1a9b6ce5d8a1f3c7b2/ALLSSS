### Title
Missing Upper Bound Validation on MaximumMinersCount Enables State Size DoS Attack

### Summary
The `SetMaximumMinersCount` function lacks upper bound validation to ensure the configured miner count is compatible with the 128KB state size limit. When MaximumMinersCount exceeds approximately 27-30 miners, the Round state object with accumulated EncryptedPieces from all miners exceeds the state size limit, causing consensus to halt with StateOverSizeException.

### Finding Description

The vulnerability exists in the interaction between multiple components:

**Entry Point**: [1](#0-0) 

The `SetMaximumMinersCount` function only validates that the input value is positive, with no upper bound check to ensure compatibility with AElf's state size limit.

**State Size Growth**: [2](#0-1) 

Each miner's EncryptedPieces dictionary contains N entries (one encrypted secret share per miner) as part of the secret sharing scheme for VRF randomness. [3](#0-2) 

**State Write Enforcement**: [4](#0-3) 

When the Round object is written to state, it triggers validation: [5](#0-4) 

The state size limit is enforced: [6](#0-5) 

**Root Cause**: The Round object size grows as O(N²) where N is the number of miners:
- Each of N miners has N entries in EncryptedPieces (plus DecryptedPieces and other fields)
- Total size ≈ N × N × ~176 bytes per entry (66-byte pubkey + 100-byte encrypted piece + overhead)
- At N≈27-30 miners, this exceeds 128KB

**Unsafe Default**: [7](#0-6) 

MaximumMinersCount is initialized to int.MaxValue during contract initialization, requiring explicit governance action to set a safe value.

### Impact Explanation

**Consensus Halt**: When the miner count approaches 30, the `UpdateValue` transaction fails because the Round state object exceeds 128KB. [8](#0-7) 

The consensus update process becomes impossible, halting block production and rendering the blockchain non-functional.

**Affected Parties**: All blockchain participants are impacted - validators cannot produce blocks, users cannot submit transactions, and the entire network stops progressing until MaximumMinersCount is reduced via emergency governance action.

**Severity Justification**: While documentation recommends 17 miners (below the threshold), nothing prevents governance from setting a higher value. The default initialization to int.MaxValue creates a dangerous misconfiguration risk where increasing miner count beyond the documented recommendation causes catastrophic failure.

### Likelihood Explanation

**Preconditions**:
1. Governance must set MaximumMinersCount above ~27-30 via Parliament proposal
2. Sufficient candidates must be elected to approach that count
3. Secret sharing must be enabled (which is the default configuration)

**Feasibility**: The default initialization to int.MaxValue means the system is vulnerable unless explicitly configured. While documentation recommends 17 miners, governance could legitimately attempt to increase decentralization by adding more miners without awareness of the state size constraint.

**Attack Complexity**: This is more of a misconfiguration vulnerability than an active attack - no malicious actor is required. Legitimate governance actions to increase miner count for greater decentralization could inadvertently trigger the DoS.

**Probability**: Low to Medium - requires governance action but the unsafe default and lack of validation makes this a realistic operational risk, especially during network growth phases.

### Recommendation

**Add Upper Bound Validation**: Modify SetMaximumMinersCount to enforce a safe maximum based on state size limits:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    // Add upper bound check based on state size limit analysis
    Assert(input.Value <= 25, "Max miners count exceeds safe state size limit.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    
    TryToGetCurrentRoundInformation(out var round);
    
    State.MaximumMinersCount.Value = input.Value;
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

**Improve Default Initialization**: Change the default from int.MaxValue to a safe value (e.g., 25) in InitialAElfConsensusContract.

**Add Documentation**: Clearly document the relationship between miner count, EncryptedPieces size, and state size limits.

**Test Coverage**: Add integration tests that verify Round state writes succeed with miner counts up to the maximum allowed value and fail appropriately beyond it.

### Proof of Concept

**Initial State**:
1. AElf blockchain initialized with default MaximumMinersCount = int.MaxValue
2. Secret sharing enabled (default configuration)
3. Currently 17 miners (below threshold)

**Attack Steps**:
1. Governance creates Parliament proposal to set MaximumMinersCount to 35 (believing this increases decentralization)
2. Proposal passes and SetMaximumMinersCount(35) executes successfully (only checks > 0)
3. Over time through elections, miner count grows from 17 → 25 → 30 → 32
4. At approximately 30 miners, when any miner calls UpdateValue:
   - Round object size = 30 miners × 30 EncryptedPieces × ~176 bytes ≈ 158KB
   - TryToUpdateRoundInformation attempts State.Rounds[roundNumber] = round
   - ValidateStateSize check: 158KB > 128KB limit
   - StateOverSizeException thrown
   - Transaction fails, consensus update blocked
5. All subsequent UpdateValue calls fail
6. Blockchain halts - no blocks can be produced

**Expected Result**: SetMaximumMinersCount should reject values that would cause state size violations.

**Actual Result**: SetMaximumMinersCount accepts any positive value, enabling configurations that cause consensus DoS.

**Success Condition**: Consensus halts when Round state object exceeds 128KB limit, demonstrating the vulnerability.

### Notes

The original question mentions "gas griefing" and "block gas limits," but AElf doesn't use traditional gas limits - it uses transaction count limits per block and a 5MB transaction size limit. [9](#0-8) 

The actual vulnerability is related to the state size limit, not gas. The concern about "thousands of entries" is overstated - the issue manifests at just 27-30 miners, not thousands. However, the underlying security concern about unbounded growth is valid and represents a significant operational risk.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L45-45)
```csharp
            EncryptedPieces = { minerInRound.EncryptedPieces },
```

**File:** src/AElf.Kernel.Consensus.AEDPoS/Application/SecretSharingService.cs (L101-115)
```csharp
        var minersCount = secretSharingInformation.PreviousRound.RealTimeMinersInformation.Count;
        var minimumCount = minersCount.Mul(2).Div(3);
        var secretShares =
            SecretSharingHelper.EncodeSecret(newInValue.ToByteArray(), minimumCount, minersCount);

        foreach (var pair in secretSharingInformation.PreviousRound.RealTimeMinersInformation
                     .OrderBy(m => m.Value.Order).ToDictionary(m => m.Key, m => m.Value.Order))
        {
            var pubkey = pair.Key;
            var order = pair.Value;

            var plainMessage = secretShares[order - 1];
            var receiverPublicKey = ByteArrayHelper.HexStringToByteArray(pubkey);
            var encryptedPiece = await _accountService.EncryptMessageAsync(receiverPublicKey, plainMessage);
            encryptedPieces[pubkey] = encryptedPiece;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_HelpMethods.cs (L126-132)
```csharp
    private bool TryToUpdateRoundInformation(Round round)
    {
        var ri = State.Rounds[round.RoundNumber];
        if (ri == null) return false;
        State.Rounds[round.RoundNumber] = round;
        return true;
    }
```

**File:** src/AElf.Kernel.SmartContract/HostSmartContractBridgeContext.cs (L148-160)
```csharp
    public object ValidateStateSize(object obj)
    {
        var stateSizeLimit = AsyncHelper.RunSync(() => _smartContractBridgeService.GetStateSizeLimitAsync(
            new ChainContext
            {
                BlockHash = _transactionContext.PreviousBlockHash,
                BlockHeight = _transactionContext.BlockHeight - 1
            }));
        var size = SerializationHelper.Serialize(obj).Length;
        if (size > stateSizeLimit)
            throw new StateOverSizeException($"State size {size} exceeds limit of {stateSizeLimit}.");
        return obj;
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract.cs (L52-52)
```csharp
        State.MaximumMinersCount.Value = int.MaxValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L238-285)
```csharp
    private void ProcessUpdateValue(UpdateValueInput updateValueInput)
    {
        TryToGetCurrentRoundInformation(out var currentRound);

        var minerInRound = currentRound.RealTimeMinersInformation[_processingBlockMinerPubkey];
        minerInRound.ActualMiningTimes.Add(updateValueInput.ActualMiningTime);
        minerInRound.Signature = updateValueInput.Signature;
        minerInRound.OutValue = updateValueInput.OutValue;
        minerInRound.SupposedOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.FinalOrderOfNextRound = updateValueInput.SupposedOrderOfNextRound;
        minerInRound.ImpliedIrreversibleBlockHeight = updateValueInput.ImpliedIrreversibleBlockHeight;

        // Just add 1 based on previous data, do not use provided values.
        minerInRound.ProducedBlocks = minerInRound.ProducedBlocks.Add(1);
        minerInRound.ProducedTinyBlocks = minerInRound.ProducedTinyBlocks.Add(1);

        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }

        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;

        // It is permissible for miners not publish their in values.
        if (updateValueInput.PreviousInValue != Hash.Empty)
            minerInRound.PreviousInValue = updateValueInput.PreviousInValue;

        if (TryToGetPreviousRoundInformation(out var previousRound))
        {
            new LastIrreversibleBlockHeightCalculator(currentRound, previousRound).Deconstruct(
                out var libHeight);
            Context.LogDebug(() => $"Finished calculation of lib height: {libHeight}");
            // LIB height can't be available if it is lower than last time.
            if (currentRound.ConfirmedIrreversibleBlockHeight < libHeight)
            {
                Context.LogDebug(() => $"New lib height: {libHeight}");
                Context.Fire(new IrreversibleBlockFound
                {
                    IrreversibleBlockHeight = libHeight
                });
                currentRound.ConfirmedIrreversibleBlockHeight = libHeight;
                currentRound.ConfirmedIrreversibleBlockRoundNumber = currentRound.RoundNumber.Sub(1);
            }
        }

        if (!TryToUpdateRoundInformation(currentRound)) Assert(false, "Failed to update round information.");
    }
```

**File:** src/AElf.Kernel.TransactionPool/TransactionPoolConsts.cs (L5-5)
```csharp
    public const int TransactionSizeLimit = 1024 * 1024 * 5; // 5M
```
