### Title
Permanent Method Fee Controller Lock via Malicious Contract Validation Bypass

### Summary
The `ChangeMethodFeeController()` function validates organization existence through an external call to the provided contract address, which only checks if `ValidateOrganizationExist` returns true. A malicious contract can return true without implementing proper ACS3 governance mechanisms, allowing an attacker to permanently capture method fee control with no recovery mechanism.

### Finding Description

The vulnerability exists in `ChangeMethodFeeController()` [1](#0-0) 

The function performs organization validation via `CheckOrganizationExist()` which makes an external call to the provided contract address [2](#0-1) 

The validation only verifies that the external call to `ValidateOrganizationExist` returns true, without verifying:
- The contract implements full ACS3 interface (CreateProposal, Approve, Release) [3](#0-2) 
- The organization has proper structure with OrganizationHash and CreationToken needed for virtual address calculation [4](#0-3) 
- The organization can execute proposals through `SendVirtualInlineBySystemContract` [5](#0-4) 

A legitimate organization validation checks stored organization data [6](#0-5) 

Once the malicious controller is set, future calls to `ChangeMethodFeeController()` require the sender to be the OwnerAddress from the controller [7](#0-6) 

However, proposal execution uses virtual addresses calculated from organization structure, and only the proposer can release proposals [8](#0-7) 

Without proper ACS3 implementation, no one can create or execute proposals as the fake organization, making the controller permanently locked. The initialization function only sets the controller if it's null, providing no reset mechanism [9](#0-8) 

### Impact Explanation

**Complete Governance Failure**: The method fee controller governs all method fees for the Parliament contract [10](#0-9) 

Once captured, the attacker prevents any future changes to method fees, causing:
- Inability to adjust fees as economic conditions change
- Inability to respond to spam attacks requiring fee increases
- Inability to lower fees for user adoption
- Permanent operational gridlock for the contract's fee structure

**Who is Affected**: All users of the Parliament contract and anyone dependent on its governance functions. Since Parliament is used for system-level governance in AElf, this affects the entire blockchain's governance capability.

**Severity Justification**: This is a Critical severity issue because:
1. **Irreversible Damage**: No recovery mechanism exists; the damage is permanent
2. **Governance Breakdown**: Core governance functionality becomes permanently disabled
3. **System-Wide Impact**: Parliament governs other system contracts, amplifying the impact
4. **No Remediation**: Contract upgrade would be required, which itself requires governance that may be compromised

### Likelihood Explanation

**Attacker Capabilities**: The attacker needs to get ONE malicious proposal approved through the current method fee controller (typically Parliament's default organization requiring 2/3 BP approval).

**Attack Complexity**: 
1. Deploy a malicious contract that implements only `ValidateOrganizationExist` to return true
2. Create a proposal to call `ChangeMethodFeeController` with AuthorityInfo pointing to the malicious contract
3. Get the proposal approved through social engineering or compromised governance members
4. Release the proposal to execute the change

**Feasibility Conditions**: 
- Requires temporary compromise of 2/3 of block producers OR
- Legitimate-looking proposal that hides malicious contract behavior until after approval OR
- Gradual governance manipulation over time

**Detection Constraints**: The malicious contract can appear legitimate at proposal time. The permanent lock only becomes apparent after execution when attempts to change the controller fail.

**Probability Assessment**: Medium to High. While getting 2/3 BP approval is difficult, the attack only needs to succeed ONCE for permanent damage. The sophistication required is low (simple contract returning true), and the permanent nature of the damage makes the risk-reward heavily favor the attacker.

### Recommendation

**Immediate Fix**: Add comprehensive validation in `CheckOrganizationExist()`:

```csharp
private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
{
    // Verify the contract implements ACS3
    var contractInfo = Context.GetContractInfo(authorityInfo.ContractAddress);
    Assert(contractInfo != null, "Invalid contract address.");
    
    // Whitelist known governance contracts (Parliament, Association, Referendum)
    var validContracts = new[] {
        Context.Self,
        Context.GetContractAddressByName(SmartContractConstants.AssociationContractSystemName),
        Context.GetContractAddressByName(SmartContractConstants.ReferendumContractSystemName)
    };
    
    Assert(validContracts.Contains(authorityInfo.ContractAddress), 
        "Only registered governance contracts allowed.");
    
    // Then verify organization exists
    return Context.Call<BoolValue>(authorityInfo.ContractAddress,
        nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
}
```

**Additional Safeguards**:
1. Add time-lock mechanism: require proposals to change the controller to wait 7 days, allowing detection
2. Add controller change event logging with clear warnings
3. Implement emergency recovery mechanism accessible by default organization
4. Add validation that the new controller differs from the current one (prevent no-op attacks)

**Test Cases**:
1. Test changing controller to non-ACS3 contract (should fail)
2. Test changing controller to unknown contract address (should fail)
3. Test changing controller to legitimate governance contracts (should succeed)
4. Test recovery mechanism after controller is set to invalid organization
5. Test time-lock bypass attempts

### Proof of Concept

**Initial State**:
- Parliament contract deployed with default organization as method fee controller
- Attacker has deployed MaliciousContract with only `ValidateOrganizationExist(Address) returns (true)`

**Transaction Sequence**:

1. **Attacker creates proposal** via current governance:
   ```
   CreateProposal({
     ToAddress: ParliamentContract,
     MethodName: "ChangeMethodFeeController",
     Params: AuthorityInfo {
       ContractAddress: MaliciousContract,
       OwnerAddress: AttackerControlledAddress
     },
     OrganizationAddress: CurrentDefaultOrg
   })
   ```

2. **Social engineering or compromised BPs approve** the proposal (appears as routine controller change)

3. **Proposer releases** the proposal:
   - Execution reaches line 25-26: `CheckOrganizationExist(input)`
   - External call to `MaliciousContract.ValidateOrganizationExist(AttackerControlledAddress)` returns true
   - Validation passes line 26
   - Line 28: `State.MethodFeeController.Value = input` (malicious AuthorityInfo)

4. **Attempt to recover** by legitimate governance:
   ```
   CreateProposal({
     ToAddress: ParliamentContract,
     MethodName: "ChangeMethodFeeController",
     Params: AuthorityInfo { ... legitimate controller ... }
   })
   ```
   - Line 24 check fails: `Context.Sender != AttackerControlledAddress`
   - Transaction fails with "Unauthorized behavior"

5. **Attempt to execute through MaliciousContract**:
   - MaliciousContract has no `CreateProposal`, `Approve`, or `Release` methods
   - Cannot create valid proposals
   - Cannot calculate correct virtual address for AttackerControlledAddress
   - All attempts fail

**Expected vs Actual Result**:
- Expected: Only legitimate governance contracts with proper ACS3 implementation can be set as controller
- Actual: Any contract returning true for `ValidateOrganizationExist` can be set, causing permanent lock

**Success Condition**: Controller is permanently locked to malicious AuthorityInfo with no recovery path, as verified by failed attempts to call `ChangeMethodFeeController` from any sender.

### Citations

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L10-19)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        RequiredMethodFeeControllerSet();

        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L21-30)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L56-60)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(ValidateOrganizationExist), authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/ParliamentContract_ACS1_TransactionFeeProvider.cs (L62-73)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.DefaultOrganizationAddress.Value,
            ContractAddress = Context.Self
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** protobuf/acs3.proto (L19-76)
```text
service AuthorizationContract {
    // Create a proposal for which organization members can vote. 
    // When the proposal is released, a transaction will be sent to the specified contract.
    // Return id of the newly created proposal.
    rpc CreateProposal (CreateProposalInput) returns (aelf.Hash) {
    }
    
    // Approve a proposal according to the proposal ID.
    rpc Approve (aelf.Hash) returns (google.protobuf.Empty) {
    }
    
    // Reject a proposal according to the proposal ID.
    rpc Reject(aelf.Hash) returns (google.protobuf.Empty) {
    }

    // Abstain a proposal according to the proposal ID.
    rpc Abstain(aelf.Hash) returns (google.protobuf.Empty){
    }

    // Release a proposal according to the proposal ID and send a transaction to the specified contract.
    rpc Release(aelf.Hash) returns (google.protobuf.Empty){
    }
    
    // Change the thresholds associated with proposals.
    // All fields will be overwritten by the input value and this will affect all current proposals of the organization. 
    // Note: only the organization can execute this through a proposal.
    rpc ChangeOrganizationThreshold(ProposalReleaseThreshold)returns(google.protobuf.Empty) {
    }
    
    // Change the white list of organization proposer.
    // This method overrides the list of whitelisted proposers.
    rpc ChangeOrganizationProposerWhiteList(ProposerWhiteList) returns (google.protobuf.Empty){
    }
    
    // Create a proposal by system contracts,
    // and return id of the newly created proposal.
    rpc CreateProposalBySystemContract(CreateProposalBySystemContractInput) returns (aelf.Hash){
    }
    
    // Remove the specified proposal. If the proposal is in effect, the cleanup fails.
    rpc ClearProposal(aelf.Hash) returns (google.protobuf.Empty){
    }
    
    // Get the proposal according to the proposal ID.
    rpc GetProposal(aelf.Hash) returns (ProposalOutput) {
        option (aelf.is_view) = true;
    }
    
    // Check the existence of an organization.
    rpc ValidateOrganizationExist(aelf.Address) returns (google.protobuf.BoolValue){
        option (aelf.is_view) = true;
    }
    
    // Check if the proposer is whitelisted.
    rpc ValidateProposerInWhiteList(ValidateProposerInWhiteListInput) returns (google.protobuf.BoolValue){
        option (aelf.is_view) = true;
    }
}
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L307-312)
```csharp
    private Hash CalculateVirtualHash(Hash organizationHash, Hash creationToken)
    {
        return creationToken == null
            ? organizationHash
            : HashHelper.ConcatAndCompute(organizationHash, creationToken);
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```
