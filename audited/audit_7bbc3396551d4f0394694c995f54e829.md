# Audit Report

## Title
Unbounded State Storage Growth via Delegation Spam Without WRITE Resource Token Charges

## Summary
The MultiToken contract's delegation mechanisms allow unbounded state storage growth without per-write resource token charges. The contract does not implement ACS8, meaning no WRITE tokens are charged for state modifications, only transaction size fees. Attackers can create unlimited delegation entries across arbitrary delegator addresses, causing permanent blockchain state bloat that affects all validators.

## Finding Description

The MultiToken contract implements delegation features that allow any address to create delegation entries for any other address without authorization checks beyond basic address validity. [1](#0-0) 

Two state maps store delegation data:
1. **Simple Delegation**: `TransactionFeeDelegateesMap` as `MappedState<Address, TransactionFeeDelegatees>` [2](#0-1) 

2. **Method-Specific Delegation**: `TransactionFeeDelegateInfoMap` as `MappedState<Address, Address, string, TransactionFeeDelegatees>` mapping delegator → contract → method → delegatees [3](#0-2) 

While per-delegator limits of 24 delegatees exist via `DELEGATEE_MAX_COUNT`, [4](#0-3)  there are no global limits on the number of delegator addresses or (contract, method) combinations that can be created. [5](#0-4) [6](#0-5) 

**Critical Cost Model Gap:**

The AElf fee system has two components:
- **Transaction size fee (STORAGE token)**: Charged based on `Transaction.Size()` [7](#0-6) 
- **Write fee (WRITE token)**: Charged per state write via `Writes.Count` for ACS8-implementing contracts [8](#0-7) 

The MultiToken contract implements only ACS1 and ACS2, NOT ACS8. [9](#0-8)  The resource consumption plugin checks for ACS8 via `HasApplicableAcs(descriptors)` and returns empty transactions if not implemented. [10](#0-9) 

This means the MultiToken contract never pays WRITE resource tokens for state modifications. Each delegation entry can store up to the 128KB `ValidateStateSize` limit, [11](#0-10)  but users only pay transaction size fees, not per-write charges.

**Attack Vector:**

An attacker can:
1. Generate N arbitrary addresses (to be used as "delegator" addresses)
2. Call `SetTransactionFeeDelegations` or `SetTransactionFeeDelegateInfos` N times with different delegator addresses
3. Each call creates permanent state entries under those addresses
4. For method-specific delegations, multiply this by M contracts × K methods
5. Pay only transaction size fees (no WRITE tokens per state write)

The authorization model allows anyone to become a delegatee for any delegator address - there is no check requiring the delegator's approval. [12](#0-11)  The only validation is address format checking. [13](#0-12) 

## Impact Explanation

This vulnerability enables a state bloat attack with the following impacts:

**1. Permanent State Growth:**
- Unlimited delegation entries can be created across arbitrary delegator addresses
- Each entry persists permanently in the blockchain state
- For method-specific delegations: delegator_count × contract_count × method_count entries possible
- Total state can grow unbounded

**2. Infrastructure Burden:**
- All validators must store and maintain the bloated state
- New nodes face extended synchronization times
- Storage requirements increase indefinitely
- Network performance degrades as state size grows

**3. Economic Asymmetry:**
- Attackers pay only transaction size fees (based on input size)
- No per-write WRITE token charges due to missing ACS8 implementation
- Creates economic imbalance where state write costs are not properly internalized

**4. Denial of Service Potential:**
- Sufficient state bloat can degrade blockchain performance
- Affects all network participants equally
- Cannot be easily reversed without explicit cleanup transactions

This represents a HIGH severity issue because it enables high-confidence degradation of blockchain operations through sustained state spam attacks, affecting the entire network's operational integrity.

## Likelihood Explanation

**Attack Complexity: LOW**
- Public methods are accessible to any user
- No special permissions or privileges required
- Simple repeated calls to delegation methods
- No complex transaction ordering needed

**Attacker Requirements:**
- Ability to generate addresses (trivial)
- Transaction fees for each call (minimal compared to impact)
- No insider access or compromised keys needed

**Feasibility: HIGH**
- Entry points are public and unrestricted
- Attack is easily reproducible
- Leaves traceable evidence but distinguishing malicious from legitimate use is difficult
- No rate limiting or circuit breakers exist

**Economic Viability:**
- Cost is limited to transaction size fees (STORAGE tokens)
- No per-write WRITE token costs due to missing ACS8
- Impact (permanent state bloat affecting all validators) exceeds attacker cost
- Economically rational for adversaries seeking to harm network infrastructure

## Recommendation

**1. Implement Global Limits:**
Add global caps on total delegation entries across all delegators:
```csharp
public const int MAX_TOTAL_DELEGATION_ENTRIES = 100000;
internal SingletonState<long> TotalDelegationEntryCount { get; set; }
```

Check and enforce this limit in `SetTransactionFeeDelegations` and `SetTransactionFeeDelegateInfos` before creating new entries.

**2. Implement ACS8 for WRITE Charges:**
Consider implementing ACS8 in the MultiToken contract to charge WRITE resource tokens per state write, ensuring users pay proportionally for state storage consumed.

**3. Add Authorization Checks:**
Require delegator signature or approval before allowing delegation entries:
```csharp
Assert(Context.Sender == input.DelegatorAddress || 
       HasDelegatorApproval(input.DelegatorAddress, Context.Sender),
       "Delegator authorization required");
```

**4. Implement Cleanup Mechanisms:**
Add automated cleanup of old or inactive delegation entries, or require periodic renewal with fees to maintain entries.

**5. Add Rate Limiting:**
Implement per-address rate limits on delegation entry creation to prevent rapid spam attacks.

## Proof of Concept

```csharp
[Fact]
public async Task StateBloa_Attack_Via_Delegation_Spam()
{
    await Initialize();
    
    // Attacker creates many fake delegator addresses
    var attackerDelegateeAddress = DefaultAddress;
    var fakeDelegatorCount = 1000; // In real attack, could be much higher
    
    for (int i = 0; i < fakeDelegatorCount; i++)
    {
        // Generate arbitrary delegator address
        var fakeDelegator = Address.FromPublicKey(GenerateRandomBytes(33));
        
        // Create delegation entry for this fake delegator
        // Attacker only pays transaction size fee, no WRITE fee
        await TokenContractStub.SetTransactionFeeDelegations.SendAsync(
            new SetTransactionFeeDelegationsInput
            {
                DelegatorAddress = fakeDelegator,
                Delegations = {
                    { "ELF", 1000 },
                    { "BASIC", 500 }
                }
            });
    }
    
    // State has grown by fakeDelegatorCount entries
    // All validators must store this bloated state permanently
    // Attacker paid only transaction fees, no per-write WRITE tokens
}
```

This demonstrates how an attacker can create unlimited delegation entries for arbitrary addresses, paying only transaction size fees without per-write resource charges, causing permanent state bloat affecting all network validators.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L12-16)
```csharp
    public override SetTransactionFeeDelegationsOutput SetTransactionFeeDelegations(
        SetTransactionFeeDelegationsInput input)
    {
        AssertValidInputAddress(input.DelegatorAddress);
        Assert(input.Delegations != null, "Delegations cannot be null!");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L22-22)
```csharp
        var delegateeAddress = Context.Sender.ToBase58();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L28-37)
```csharp
        if (!allDelegateesMap.ContainsKey(delegateeAddress))
        {
            // If there has been already DELEGATEE_MAX_COUNT delegatees, and still try to add，fail.
            if (allDelegateesMap.Count() >= TokenContractConstants.DELEGATEE_MAX_COUNT)
            {
                return new SetTransactionFeeDelegationsOutput()
                {
                    Success = false
                };
            }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Delegation.cs (L224-228)
```csharp
            else
            {
                Assert(existDelegateeList.Count < TokenContractConstants.DELEGATEE_MAX_COUNT,
                    "The quantity of delegatee has reached its limit");
                existDelegateeList.Add(delegateeAddress, new TransactionFeeDelegations());
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L64-64)
```csharp
    public MappedState<Address, TransactionFeeDelegatees> TransactionFeeDelegateesMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L66-69)
```csharp
    /// <summary>
    /// delegator address -> contract address -> method name -> delegatee info
    /// </summary>
    public MappedState<Address, Address, string, TransactionFeeDelegatees> TransactionFeeDelegateInfoMap { get; set; }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContractConstants.cs (L18-18)
```csharp
    public const int DELEGATEE_MAX_COUNT = 24;
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/StorageFeeProvider.cs (L15-18)
```csharp
    protected override int GetCalculateCount(ITransactionContext transactionContext)
    {
        return transactionContext.Transaction.Size();
    }
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/WriteFeeProvider.cs (L15-18)
```csharp
    protected override int GetCalculateCount(ITransactionContext transactionContext)
    {
        return transactionContext.Trace.StateSet.Writes.Count;
    }
```

**File:** protobuf/token_contract_impl.proto (L24-26)
```text
    option (aelf.base) = "acs1.proto";
    option (aelf.base) = "acs2.proto";
    option (aelf.base) = "token_contract.proto";
```

**File:** src/AElf.Kernel.SmartContract.ExecutionPluginForResourceFee/ResourceConsumptionPostExecutionPlugin.cs (L39-43)
```csharp
    public async Task<IEnumerable<Transaction>> GetPostTransactionsAsync(
        IReadOnlyList<ServiceDescriptor> descriptors, ITransactionContext transactionContext)
    {
        if (!HasApplicableAcs(descriptors)) return new List<Transaction>();

```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L9-9)
```csharp
    public const int StateSizeLimit = 128 * 1024;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L94-96)
```csharp
    private void AssertValidInputAddress(Address input)
    {
        Assert(input != null && !input.Value.IsNullOrEmpty(), "Invalid input address.");
```
