### Title
Unvalidated Cross-Miner Secret Sharing Pollution in AEDPoS Consensus

### Summary
A malicious miner can inject arbitrary `DecryptedPieces` and `MinersPreviousInValues` for all other miners through the `UpdateValue` transaction without any cryptographic or authorization validation. This corrupts the secret sharing reconstruction process, compromising consensus randomness, mining order determination, and potentially enabling consensus manipulation or denial-of-service attacks on the entire round.

### Finding Description

**Primary Vulnerable Location:**

The `PerformSecretSharing` function directly stores attacker-controlled data into other miners' consensus state without validation: [1](#0-0) 

**Secondary Vulnerable Location:**

The `UpdateLatestSecretPieces` function allows similar pollution during block header generation: [2](#0-1) 

**Root Cause:**

Lines 291-293 blindly add the attacker's provided `DecryptedPieces` to every other miner's secret piece collection, using the attacker's public key as the contributor. There is NO validation that:
- The attacker actually received encrypted pieces from the target miners
- The decrypted values are cryptographically valid
- The attacker should have decryption authority

Lines 295-296 blindly overwrite any miner's `PreviousInValue` based on the attacker's input, without verifying correctness or authority.

**Attack Execution Path:**

1. Malicious miner modifies their node to craft `UpdateValueInput` with fake data
2. Data flows through `ExtractInformationToUpdateConsensus`: [3](#0-2) 

3. Transaction passes validation because `UpdateValueValidationProvider` only checks `OutValue`, `Signature`, and `PreviousInValue` hash: [4](#0-3) 

4. `ProcessUpdateValue` calls `PerformSecretSharing` which persists the corrupted data to contract state: [5](#0-4) 

**Why Protections Fail:**

The consensus validation only verifies the miner's own data, not the cross-miner pollution data. The `DecryptedPieces` and `MinersPreviousInValues` fields are treated as trusted input despite being fully attacker-controlled.

### Impact Explanation

**Consensus Integrity Compromise:**

When `RevealSharedInValues` executes during `NextRound` transitions, it reconstructs other miners' `InValues` using the corrupted `DecryptedPieces`: [6](#0-5) 

The reconstructed `InValue` becomes the `PreviousInValue`, which directly affects signature calculation: [7](#0-6) 

The signature determines mining order for the next round: [8](#0-7) 

**Concrete Harm:**

1. **Mining Order Manipulation**: By controlling other miners' `DecryptedPieces` and `PreviousInValue`, the attacker influences whose signatures determine the next round's mining schedule, potentially favoring themselves or specific miners.

2. **Random Number Corruption**: The secret sharing mechanism is designed to generate unpredictable randomness. Poisoned pieces break this guarantee, enabling the attacker to bias or predict random values used for consensus decisions.

3. **Denial of Service**: Providing invalid decrypted pieces that fail Shamir's Secret Sharing reconstruction can cause the `RevealSharedInValues` function to compute incorrect hashes, breaking the consensus flow for the entire miner set.

4. **Complete Round Pollution**: A single malicious miner can corrupt the consensus state for ALL miners in a single transaction, affecting every subsequent round until the term changes.

**Affected Parties:**
- All honest miners in the current round
- The entire consensus mechanism's integrity
- Any applications relying on consensus randomness

**Severity Justification:**
CRITICAL - This violates the core "Consensus & Cross-Chain" invariant requiring "miner schedule integrity" and "correct round transitions". A single compromised miner can corrupt the entire consensus round with a single transaction.

### Likelihood Explanation

**Attacker Capabilities:**
- Must be an authorized miner in the current round (already on the miner list)
- Must control a mining node to produce blocks during their time slot
- Can modify their local node software to craft malicious `UpdateValueInput`

**Attack Complexity:**
LOW - The attack requires only:
1. Identifying the target miners' public keys (publicly available in round information)
2. Crafting arbitrary byte arrays for `DecryptedPieces` entries
3. Including the fake data in a normal `UpdateValue` transaction

**Feasibility Conditions:**
- Secret sharing must be enabled (checked via configuration): [9](#0-8) 

- Attacker must wait for their scheduled mining time slot
- No special economic cost beyond normal block production

**Detection Constraints:**
DIFFICULT - The poisoned data appears valid until secret sharing reconstruction fails or produces unexpected mining orders. No immediate validation failure occurs at transaction time.

**Probability Assessment:**
HIGH - Any malicious miner (including compromised nodes, insider threats, or nodes running modified software) can execute this attack. The attack is deterministic and requires no special timing or race conditions.

### Recommendation

**Immediate Fix:**

Add cryptographic validation in `PerformSecretSharing`:

```csharp
private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round, string publicKey)
{
    minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
    
    // VALIDATE DecryptedPieces
    foreach (var decryptedPreviousInValue in input.DecryptedPieces)
    {
        // Check 1: Ensure target miner exists and provided encrypted pieces
        Assert(round.RealTimeMinersInformation.ContainsKey(decryptedPreviousInValue.Key),
            "Cannot add decrypted pieces for non-existent miner.");
        Assert(round.RealTimeMinersInformation[decryptedPreviousInValue.Key]
            .EncryptedPieces.ContainsKey(publicKey),
            "Cannot provide decrypted piece without corresponding encrypted piece.");
        
        // Check 2: Verify the piece decrypts correctly (implementation needed)
        // This would require storing encryption metadata or using verifiable encryption
        
        round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
            .Add(publicKey, decryptedPreviousInValue.Value);
    }
    
    // VALIDATE MinersPreviousInValues
    foreach (var previousInValue in input.MinersPreviousInValues)
    {
        // Only allow setting own PreviousInValue or values revealed through proper secret sharing
        if (previousInValue.Key == publicKey)
        {
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
        }
        else
        {
            // For other miners, require proper revelation through DecryptedPieces reconstruction
            Assert(false, "Cannot directly set other miners' PreviousInValue.");
        }
    }
}
```

**Invariant Checks to Add:**

1. Before accepting `DecryptedPieces`: Verify that the source miner's `EncryptedPieces` contains an entry for the current miner
2. Before setting `PreviousInValue`: Verify the value was either self-provided or reconstructed through valid secret sharing
3. Add consensus validation rule: Each miner can only contribute `DecryptedPieces[self]` entries to other miners' collections

**Test Cases:**

1. Test that miner cannot add `DecryptedPieces` for a miner who didn't provide `EncryptedPieces` to them
2. Test that miner cannot overwrite other miners' `PreviousInValue` directly
3. Test that secret sharing reconstruction fails gracefully with invalid pieces
4. Test that the attack is blocked at validation or execution time

### Proof of Concept

**Initial State:**
- Round N with 5 miners: M1 (attacker), M2, M3, M4, M5
- All miners have produced blocks and provided their `EncryptedPieces`
- Secret sharing is enabled

**Attack Steps:**

1. **Malicious Miner M1 modifies their node** to craft fake `UpdateValueInput`:
   - `DecryptedPieces["M2"] = FakeBytes1`
   - `DecryptedPieces["M3"] = FakeBytes2`  
   - `DecryptedPieces["M4"] = FakeBytes3`
   - `DecryptedPieces["M5"] = FakeBytes4`
   - `MinersPreviousInValues["M2"] = FakeHash1`
   - `MinersPreviousInValues["M3"] = FakeHash2`

2. **M1 produces a block during their time slot** with the crafted `UpdateValue` transaction

3. **Transaction executes successfully** because validation only checks M1's `OutValue`, `Signature`, and `PreviousInValue`

4. **Contract state is corrupted**:
   - `Round.RealTimeMinersInformation["M2"].DecryptedPieces["M1"] = FakeBytes1`
   - `Round.RealTimeMinersInformation["M3"].DecryptedPieces["M1"] = FakeBytes2`
   - `Round.RealTimeMinersInformation["M2"].PreviousInValue = FakeHash1`
   - `Round.RealTimeMinersInformation["M3"].PreviousInValue = FakeHash2`

5. **During NextRound transition**, `RevealSharedInValues` attempts to reconstruct M2's and M3's `InValues` using the corrupted `DecryptedPieces`, producing incorrect signatures

6. **Mining order for Round N+1 is manipulated** based on the corrupted signatures

**Expected Result:** Transaction should fail validation or execution should reject cross-miner data pollution

**Actual Result:** Transaction succeeds and permanently corrupts the round's secret sharing state for all affected miners

**Success Condition:** After M1's transaction, query `GetCurrentRoundInformation()` and observe that `RealTimeMinersInformation["M2"].DecryptedPieces["M1"]` contains M1's injected fake data, and `RealTimeMinersInformation["M2"].PreviousInValue` was overwritten with M1's chosen value.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L287-297)
```csharp
    private static void PerformSecretSharing(UpdateValueInput input, MinerInRound minerInRound, Round round,
        string publicKey)
    {
        minerInRound.EncryptedPieces.Add(input.EncryptedPieces);
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L136-153)
```csharp
    private void UpdateLatestSecretPieces(Round updatedRound, string pubkey,
        AElfConsensusTriggerInformation triggerInformation)
    {
        foreach (var encryptedPiece in triggerInformation.EncryptedPieces)
            updatedRound.RealTimeMinersInformation[pubkey].EncryptedPieces
                .Add(encryptedPiece.Key, encryptedPiece.Value);

        foreach (var decryptedPiece in triggerInformation.DecryptedPieces)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(decryptedPiece.Key))
                updatedRound.RealTimeMinersInformation[decryptedPiece.Key].DecryptedPieces[pubkey] =
                    decryptedPiece.Value;

        foreach (var revealedInValue in triggerInformation.RevealedInValues)
            if (updatedRound.RealTimeMinersInformation.ContainsKey(revealedInValue.Key) &&
                (updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == Hash.Empty ||
                 updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue == null))
                updatedRound.RealTimeMinersInformation[revealedInValue.Key].PreviousInValue = revealedInValue.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L26-33)
```csharp
        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/UpdateValueValidationProvider.cs (L10-20)
```csharp
    public ValidationResult ValidateHeaderInformation(ConsensusValidationContext validationContext)
    {
        // Only one Out Value should be filled.
        if (!NewConsensusInformationFilled(validationContext))
            return new ValidationResult { Message = "Incorrect new Out Value." };

        if (!ValidatePreviousInValue(validationContext))
            return new ValidationResult { Message = "Incorrect previous in value." };

        return new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L40-52)
```csharp
            var orders = anotherMinerInPreviousRound.DecryptedPieces.Select((t, i) =>
                    previousRound.RealTimeMinersInformation.Values
                        .First(m => m.Pubkey ==
                                    anotherMinerInPreviousRound.DecryptedPieces.Keys.ToList()[i]).Order)
                .ToList();

            var sharedParts = anotherMinerInPreviousRound.DecryptedPieces.Values.ToList()
                .Select(s => s.ToByteArray()).ToList();

            var revealedInValue =
                HashHelper.ComputeFrom(SecretSharingHelper.DecodeSecret(sharedParts, orders, minimumCount));

            currentRound.RealTimeMinersInformation[publicKeyOfAnotherMiner].PreviousInValue = revealedInValue;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L56-78)
```csharp
    private bool IsSecretSharingEnabled()
    {
        if (State.ConfigurationContract.Value == null)
        {
            var configurationContractAddress =
                Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
            if (configurationContractAddress == null)
            {
                // Which means Configuration Contract hasn't been deployed yet.
                return false;
            }

            State.ConfigurationContract.Value = configurationContractAddress;
        }

        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);

        return secretSharingEnabled.Value;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L110-115)
```csharp
    public Hash CalculateSignature(Hash inValue)
    {
        return HashHelper.XorAndCompute(inValue,
            RealTimeMinersInformation.Values.Aggregate(Hash.Empty,
                (current, minerInRound) => HashHelper.XorAndCompute(current, minerInRound.Signature)));
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ApplyNormalConsensusData.cs (L18-21)
```csharp
        var minersCount = RealTimeMinersInformation.Count;
        var sigNum = signature.ToInt64();

        var supposedOrderOfNextRound = GetAbsModulus(sigNum, minersCount) + 1;
```
