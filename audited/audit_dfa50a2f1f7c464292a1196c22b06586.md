# Audit Report

## Title
Missing Upper Bound Validation on MaximumMinersCount Enables Consensus DoS via ExecutionCallThreshold Exhaustion

## Summary
The `SetMaximumMinersCount` function lacks upper bound validation, allowing governance to configure a miner count that causes the `ExtractInformationToUpdateConsensus` function to exceed AElf's ExecutionCallThreshold of 15,000 method calls during block production, resulting in complete consensus failure.

## Finding Description
The vulnerability exists in the consensus contract's miner count configuration. The `SetMaximumMinersCount` function only validates that the input is positive, with no upper bound: [1](#0-0) 

During block production, the `GenerateConsensusTransactions` view method calls `ExtractInformationToUpdateConsensus` to generate consensus transaction data: [2](#0-1) 

This function performs three LINQ operations that iterate through all miners in `RealTimeMinersInformation.Values`: [3](#0-2) 

Each LINQ operation involves multiple method calls per miner (enumeration, predicate evaluation, dictionary operations). With approximately 4-6 method calls per miner per operation across 3 operations, the total approaches 12N-18N method calls where N is the miner count.

AElf enforces an ExecutionCallThreshold of 15,000 method calls: [4](#0-3) 

View methods are subject to this threshold enforcement: [5](#0-4) 

When the call count reaches the threshold, execution fails: [6](#0-5) 

At approximately 1,000-1,500 miners, the method calls would exceed 15,000, causing `GenerateConsensusTransactions` to fail with `RuntimeCallThresholdExceededException`. This prevents consensus transaction generation, halting block production entirely.

## Impact Explanation
This vulnerability enables a complete denial-of-service of the consensus mechanism:

- **Complete Blockchain Halt**: No blocks can be produced because consensus transactions cannot be generated
- **Network-Wide Impact**: All nodes are affected simultaneously  
- **Persistent Failure**: The network remains halted until governance reduces MaximumMinersCount below the threshold through an emergency intervention
- **No Direct Fund Loss**: While funds are not stolen, the entire blockchain becomes non-operational

The severity is HIGH for availability, representing a complete operational DoS of the consensus system.

## Likelihood Explanation
The likelihood is **LOW** due to the following preconditions:

1. **Governance Action Required**: Parliament must approve a proposal to set MaximumMinersCount to 1,000+ miners
2. **Miner Election**: The Election contract must successfully elect that many miners  
3. **Trusted Actor**: This requires action by trusted governance, not an external attacker

The initial miner count is 17, and natural growth (starting at 17 miners, +2 per year based on auto-increase mechanism) would take centuries to reach the threshold: [7](#0-6) 

However, governance can set any positive value directly: [8](#0-7) 

This could occur due to misconfiguration rather than malicious intent. Detection would be immediate upon the first block production attempt after reaching the high miner count.

## Recommendation
Add an upper bound validation to `SetMaximumMinersCount` to prevent configurations that would exceed the ExecutionCallThreshold:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();
    
    Assert(input.Value > 0, "Invalid max miners count.");
    // Add upper bound check based on ExecutionCallThreshold safety margin
    Assert(input.Value <= 500, "Maximum miners count exceeds safe threshold.");
    
    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");
    
    TryToGetCurrentRoundInformation(out var round);
    
    State.MaximumMinersCount.Value = input.Value;
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });
    
    return new Empty();
}
```

The recommended upper bound of 500 miners provides a safety margin well below the point where ExecutionCallThreshold would be exceeded (estimated at 1,000-1,500 miners).

## Proof of Concept
A test demonstrating this vulnerability would:

1. Deploy the AEDPoS consensus contract
2. Use governance to call `SetMaximumMinersCount` with a value of 1,500
3. Configure the Election contract to elect 1,500 miners  
4. Attempt to call `GenerateConsensusTransactions` 
5. Observe `RuntimeCallThresholdExceededException` when `ExtractInformationToUpdateConsensus` executes
6. Confirm that block production fails

The test would verify that without upper bound validation, governance can configure a miner count that causes consensus failure through ExecutionCallThreshold exhaustion.

## Notes
While this vulnerability requires trusted governance action to trigger, smart contracts should implement defensive validation even for trusted inputs to prevent catastrophic misconfigurations. The contract should enforce safe operational bounds regardless of the caller's trust level, as governance participants may not be aware of technical implementation limits like the ExecutionCallThreshold.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-28)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L144-146)
```csharp
                        GenerateTransaction(nameof(UpdateValue),
                            round.ExtractInformationToUpdateConsensus(pubkey.ToHex(), randomNumber))
                    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-33)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** src/AElf.Runtime.CSharp/Executive.cs (L127-129)
```csharp
        var observer =
            new ExecutionObserver(CurrentTransactionContext.ExecutionObserverThreshold.ExecutionCallThreshold,
                CurrentTransactionContext.ExecutionObserverThreshold.ExecutionBranchThreshold);
```

**File:** src/AElf.Sdk.CSharp/ExecutionObserver.cs (L23-24)
```csharp
        if (_callThreshold != -1 && _callCount == _callThreshold)
            throw new RuntimeCallThresholdExceededException($"Contract call threshold {_callThreshold} exceeded.");
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```
