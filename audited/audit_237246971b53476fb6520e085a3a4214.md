### Title
NFT Contract Spam Prevention Failure - Broken ACS1 Implementation Allows Near-Zero-Cost Minting and Transfer Operations

### Summary
The NFT contract's ACS1 implementation is incomplete, with `SetMethodFee()` and `ChangeMethodFeeController()` being no-op stub functions that never store method fees. This prevents proper fee configuration for minting and transfer operations, leaving only negligible transaction size fees (approximately 0.0000000063 ELF per operation) as the sole cost barrier. After paying the one-time 100 ELF Create fee, an attacker with minter permissions can spam unlimited Mint and Transfer operations, causing state bloat and potential DoS.

### Finding Description

The NFT contract's ACS1 fee provider implementation in `NFTContract_ACS1.cs` contains critical deficiencies: [1](#0-0) 

The `SetMethodFee()` and `ChangeMethodFeeController()` functions are stub implementations that immediately return empty without performing any storage operations, unlike proper implementations in other system contracts. [2](#0-1) 

The `GetMethodFee()` function only returns a hard-coded fee for the `Create` method (100 ELF), while all other methods including `Mint`, `Transfer`, and `TransferFrom` receive empty `MethodFees()`, resulting in no base fee charges.

Compare this with proper implementations that store fees in state: [3](#0-2) [4](#0-3) 

The fee charging mechanism relies on calling `GetMethodFee()` to determine charges: [5](#0-4) 

When empty `MethodFees` are returned, only transaction size fees apply. The transaction size fee formula for typical small transactions (0-1MB) is: [6](#0-5) 

For a 500-byte transaction: `500/800 + 1/10000 ≈ 0.63` base units = approximately 0.0000000063 ELF (with 8 decimals). [7](#0-6) 

### Impact Explanation

**State Bloat and DoS Risk:**
Each NFT mint operation creates multiple state entries that consume blockchain storage permanently: [8](#0-7) 

An attacker who creates an NFT protocol (100 ELF one-time cost) and adds themselves as a minter can execute millions of mint operations for negligible cost:
- 1 million mints × 0.63 base units = 630,000 base units = 0.0063 ELF total
- Each mint creates entries in `NftInfoMap`, `BalanceMap`, and updates protocol supply counters

**Transfer Spam:**
Similar near-zero-cost spam is possible with transfer operations: [9](#0-8) 

**Economic Impact:**
- Blockchain state bloat degrades node performance
- Increased storage costs for all node operators
- Potential chain-level DoS if storage/computation limits are reached
- No economic deterrent after initial 100 ELF investment

### Likelihood Explanation

**Attacker Capabilities:**
An attacker only needs:
1. 100 ELF to create an NFT protocol via `Create()`
2. Self-authorization as minter (automatic for protocol creator) [10](#0-9) 

**Attack Complexity:** Low - straightforward method calls with minimal preconditions.

**Execution Practicality:** Highly practical. The broken `SetMethodFee()` implementation means fees can NEVER be configured for these methods without a contract upgrade, making this a permanent vulnerability.

**Detection Constraints:** The attack generates legitimate-looking transactions that pass all authorization checks. Distinguishing spam from legitimate usage is difficult.

**Economic Rationality:** Extremely favorable for attackers. After 100 ELF initial cost, each subsequent operation costs ~0.0000000063 ELF, making mass spam economically viable.

### Recommendation

**Immediate Fix - Implement Proper ACS1 Fee Storage:**

Replace the stub implementations with proper state storage following the pattern used by other system contracts. The contract should:

1. Add state variable: `MappedState<string, MethodFees> TransactionFees`
2. Implement `SetMethodFee()` to store fees with authorization checks
3. Implement `ChangeMethodFeeController()` to update fee controller
4. Modify `GetMethodFee()` to retrieve stored fees from state

**Set Reasonable Default Fees:**
Configure meaningful fees for spam-prone operations:
- `Mint`: 0.1-1 ELF per operation
- `Transfer`: 0.01-0.1 ELF per operation
- `TransferFrom`: 0.01-0.1 ELF per operation

**Invariant Checks:**
- Validate that `SetMethodFee()` actually stores input to state
- Verify `GetMethodFee()` returns stored values, not just hard-coded ones
- Ensure fee controller authorization is enforced

**Test Cases:**
- Test that fees can be set and retrieved correctly
- Test that fee charging applies the configured amounts
- Test that unauthorized callers cannot modify fees
- Test state bloat scenarios with proper fee deterrents

### Proof of Concept

**Initial State:**
- Attacker has 100 ELF balance
- NFT contract deployed with current broken ACS1 implementation

**Attack Sequence:**

1. **Protocol Creation (100 ELF cost):**
   - Call `Create()` with NFT protocol parameters
   - Attacker is automatically added to minter list
   - Cost: 100 ELF (one-time)

2. **Mass Mint Spam (negligible cost):**
   - Call `Mint()` 1,000,000 times with different tokenIds
   - Each call costs ~0.63 base units (transaction size fee only)
   - Total cost: ~0.0063 ELF for 1 million mints
   - Result: 1 million state entries created in `NftInfoMap` and `BalanceMap`

3. **Transfer Spam (negligible cost):**
   - Call `Transfer()` repeatedly between attacker-controlled addresses
   - Each transfer costs ~0.63 base units
   - Result: Excessive state updates in `BalanceMap`

**Expected Result:** Operations should cost meaningful fees (0.1-1 ELF each) to prevent spam.

**Actual Result:** Operations cost ~0.0000000063 ELF each, allowing unlimited spam for negligible total cost, causing permanent blockchain state bloat.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-16)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-21)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L37-52)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (new List<string>
            {
                nameof(ClaimTransactionFees), nameof(DonateResourceToken), nameof(ChargeTransactionFees),
                nameof(CheckThreshold), nameof(CheckResourceToken), nameof(ChargeResourceToken),
                nameof(CrossChainReceiveToken)
            }.Contains(input.Value))
            return new MethodFees
            {
                MethodName = input.Value,
                IsSizeFeeFree = true
            };
        var fees = State.TransactionFees[input.Value];
        return fees;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L38-52)
```csharp
        var methodFees = Context.Call<MethodFees>(input.ContractAddress, nameof(GetMethodFee),
            new StringValue { Value = input.MethodName });
        var fee = new Dictionary<string, long>();
        var isSizeFeeFree = false;
        if (methodFees != null)
        {
            isSizeFeeFree = methodFees.IsSizeFeeFree;
        }

        if (methodFees != null && methodFees.Fees.Any())
        {
            fee = GetBaseFeeDictionary(methodFees);
        }

        return TryToChargeTransactionFee(input, fromAddress, bill, allowanceBill, fee, isSizeFeeFree);
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fee_Calculate_Coefficient.cs (L281-290)
```csharp
                new CalculateFeePieceCoefficients
                {
                    // Interval [0, 1000000]: x / 800 + 1 / 10000
                    Value =
                    {
                        1000000,
                        1, 1, 800,
                        0, 1, 10000
                    }
                },
```

**File:** src/AElf.Kernel.FeeCalculation/Infrastructure/TxFeeProvider.cs (L13-16)
```csharp
    protected override int GetCalculateCount(ITransactionContext transactionContext)
    {
        return transactionContext.Transaction.Size();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L21-35)
```csharp
    public override Empty Transfer(TransferInput input)
    {
        var tokenHash = CalculateTokenHash(input.Symbol, input.TokenId);
        DoTransfer(tokenHash, Context.Sender, input.To, input.Amount);
        Context.Fire(new Transferred
        {
            From = Context.Sender,
            To = input.To,
            Amount = input.Amount,
            Symbol = input.Symbol,
            TokenId = input.TokenId,
            Memo = input.Memo
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L383-442)
```csharp
    private NFTMinted PerformMint(MintInput input, bool isTokenIdMustBeUnique = false)
    {
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");

        var tokenId = input.TokenId == 0 ? protocolInfo.Issued.Add(1) : input.TokenId;
        var tokenHash = CalculateTokenHash(input.Symbol, tokenId);
        var nftInfo = State.NftInfoMap[tokenHash];
        if (!protocolInfo.IsTokenIdReuse || isTokenIdMustBeUnique)
            Assert(nftInfo == null, $"Token id {tokenId} already exists. Please assign a different token id.");

        var minterList = GetMinterList(tokenInfo);
        Assert(minterList.Value.Contains(Context.Sender), "No permission to mint.");
        Assert(tokenInfo.IssueChainId == Context.ChainId, "Incorrect chain.");

        var quantity = input.Quantity > 0 ? input.Quantity : 1;
        protocolInfo.Supply = protocolInfo.Supply.Add(quantity);
        protocolInfo.Issued = protocolInfo.Issued.Add(quantity);
        Assert(protocolInfo.Issued <= protocolInfo.TotalSupply, "Total supply exceeded.");
        State.NftProtocolMap[input.Symbol] = protocolInfo;

        // Inherit from protocol info.
        var nftMetadata = protocolInfo.Metadata.Clone();
        if (input.Metadata != null)
            foreach (var pair in input.Metadata.Value)
                if (!nftMetadata.Value.ContainsKey(pair.Key))
                    nftMetadata.Value[pair.Key] = pair.Value;

        if (nftInfo == null)
        {
            nftInfo = new NFTInfo
            {
                Symbol = input.Symbol,
                Uri = input.Uri ?? string.Empty,
                TokenId = tokenId,
                Metadata = nftMetadata,
                Minters = { Context.Sender },
                Quantity = quantity,
                Alias = input.Alias

                // No need.
                //BaseUri = protocolInfo.BaseUri,
                //Creator = protocolInfo.Creator,
                //ProtocolName = protocolInfo.ProtocolName
            };
        }
        else
        {
            nftInfo.Quantity = nftInfo.Quantity.Add(quantity);
            if (!nftInfo.Minters.Contains(Context.Sender)) nftInfo.Minters.Add(Context.Sender);
        }

        State.NftInfoMap[tokenHash] = nftInfo;
        var owner = input.Owner ?? Context.Sender;
        State.BalanceMap[tokenHash][owner] = State.BalanceMap[tokenHash][owner].Add(quantity);

```
