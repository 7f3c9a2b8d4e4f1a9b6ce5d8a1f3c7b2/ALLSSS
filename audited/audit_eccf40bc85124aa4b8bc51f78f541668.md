# Audit Report

## Title
Association Contract Threshold Validation Allows Governance Deadlock

## Summary
The `Validate(Organization)` function in the Association contract fails to enforce a critical combined constraint on voting thresholds, allowing creation of organizations where proposals can enter permanent deadlock states. When all members vote but the threshold configuration satisfies `MaximalRejectionThreshold + MaximalAbstentionThreshold + MinimalApprovalThreshold = organizationMemberCount + 1`, proposals cannot be approved, rejected, or abstained, violating the governance determinism invariant.

## Finding Description

The validation logic only checks two independent pairwise constraints [1](#0-0)  but does not validate that the combined sum prevents deadlock scenarios.

The proposal release determination uses asymmetric inequality operators: rejection and abstention checks use strict inequality (>) [2](#0-1)  while approval uses non-strict inequality (>=) [3](#0-2) . This creates a gap where proposals become undecidable.

**Concrete Example:**
- Organization with 10 members
- MinimalApprovalThreshold = 5
- MaximalRejectionThreshold = 3  
- MaximalAbstentionThreshold = 3

This passes validation (3+5=8≤10 for both checks), but when votes distribute as:
- 4 approvals (less than MinimalApprovalThreshold)
- 3 rejections (equal to MaximalRejectionThreshold)
- 3 abstentions (equal to MaximalAbstentionThreshold)

The proposal evaluation yields:
- NOT rejected (3 > 3? false)
- NOT abstained (3 > 3? false)
- NOT approved (4 >= 5? false)

The `IsReleaseThresholdReached` check fails [4](#0-3) , causing the Release method to revert [5](#0-4) .

## Impact Explanation

**HIGH Severity - Governance DoS**

1. **Permanent Proposal Lockup**: Proposals in deadlocked organizations cannot be released or cleared except by expiration [6](#0-5) , blocking time-sensitive governance actions.

2. **Self-Healing Impossible**: Organizations fix thresholds via `ChangeOrganizationThreshold` [7](#0-6) , which requires Context.Sender to be the organization address—meaning it must execute through a proposal. If the fix-threshold proposal deadlocks, the organization is permanently broken.

3. **Protocol Invariant Violation**: The governance system guarantees that with sufficient participation, proposals reach deterministic outcomes. This vulnerability breaks that guarantee.

4. **Widespread Applicability**: Any Association organization (used throughout AElf for multi-sig governance) can be affected, including those controlling critical protocol parameters or treasury funds.

## Likelihood Explanation

**HIGH Likelihood**

1. **Public Entry Point**: `CreateOrganization` is a public method [8](#0-7)  callable by any user without authorization.

2. **No Economic Barrier**: Organization creation requires no stake, deposit, or approval.

3. **Simple Configuration**: The deadlock condition `R + A + M = N + 1` is straightforward to calculate and can occur in legitimate threshold designs (e.g., "require 50% approval, tolerate 30% rejection and 30% abstention").

4. **Detection Difficulty**: The validation passes during creation [9](#0-8) , and deadlock only manifests during voting, making it hard to detect preventatively.

5. **Existing Test Configurations**: The test suite itself uses potentially vulnerable configurations (e.g., 2+1+1=4 with 3 members) without exercising the deadlock scenario, indicating this edge case is not well-understood.

## Recommendation

Add a combined constraint check to the validation logic:

```csharp
private bool Validate(Organization organization)
{
    // ... existing checks ...
    
    var proposalReleaseThreshold = organization.ProposalReleaseThreshold;
    var organizationMemberCount = organization.OrganizationMemberList.Count();
    
    return proposalReleaseThreshold.MinimalVoteThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
           proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
           // NEW: Prevent deadlock by ensuring combined thresholds leave room for decision
           proposalReleaseThreshold.MaximalRejectionThreshold +
           proposalReleaseThreshold.MaximalAbstentionThreshold +
           proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
}
```

This ensures that when all N members vote, at least one outcome condition can be satisfied.

## Proof of Concept

```csharp
[Fact]
public async Task CreateOrganization_DeadlockConfiguration_Test()
{
    // Create organization with deadlock-prone thresholds
    var minimalApprovalThreshold = 5;
    var minimalVoteThreshold = 10;
    var maximalAbstentionThreshold = 3;
    var maximalRejectionThreshold = 3;
    // Sum: 5 + 3 + 3 = 11 = organizationMemberCount + 1
    
    var createOrganizationInput = new CreateOrganizationInput
    {
        OrganizationMemberList = new OrganizationMemberList
        {
            OrganizationMembers = { Reviewer1, Reviewer2, Reviewer3, 
                                   Accounts[3].Address, Accounts[4].Address,
                                   Accounts[5].Address, Accounts[6].Address,
                                   Accounts[7].Address, Accounts[8].Address,
                                   Accounts[9].Address } // 10 members
        },
        ProposalReleaseThreshold = new ProposalReleaseThreshold
        {
            MinimalApprovalThreshold = minimalApprovalThreshold,
            MinimalVoteThreshold = minimalVoteThreshold,
            MaximalAbstentionThreshold = maximalAbstentionThreshold,
            MaximalRejectionThreshold = maximalRejectionThreshold
        },
        ProposerWhiteList = new ProposerWhiteList { Proposers = { Reviewer1 } }
    };
    
    // Organization creation succeeds (current validation passes)
    var organizationAddress = await AssociationContractStub.CreateOrganization.SendAsync(createOrganizationInput);
    organizationAddress.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // Create a proposal
    var proposalId = await CreateProposalAsync(Reviewer1KeyPair, organizationAddress.Output);
    
    // Vote: 4 approvals, 3 rejections, 3 abstentions (all 10 members vote)
    await GetAssociationContractTester(Reviewer1KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Reviewer2KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Reviewer3KeyPair).Approve.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[3].KeyPair).Approve.SendAsync(proposalId);
    
    await GetAssociationContractTester(Accounts[4].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[5].KeyPair).Reject.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[6].KeyPair).Reject.SendAsync(proposalId);
    
    await GetAssociationContractTester(Accounts[7].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[8].KeyPair).Abstain.SendAsync(proposalId);
    await GetAssociationContractTester(Accounts[9].KeyPair).Abstain.SendAsync(proposalId);
    
    // Attempt to release - this should fail due to deadlock
    var releaseResult = await GetAssociationContractTester(Reviewer1KeyPair)
        .Release.SendWithExceptionAsync(proposalId);
    releaseResult.TransactionResult.Error.ShouldContain("Not approved");
    
    // Verify proposal is not releasable
    var proposal = await AssociationContractStub.GetProposal.CallAsync(proposalId);
    proposal.ToBeReleased.ShouldBe(false);
    proposal.ApprovalCount.ShouldBe(4);
    proposal.RejectionCount.ShouldBe(3);
    proposal.AbstentionCount.ShouldBe(3);
}
```

### Citations

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L24-32)
```csharp
    private bool IsReleaseThresholdReached(ProposalInfo proposal, Organization organization)
    {
        var isRejected = IsProposalRejected(proposal, organization);
        if (isRejected)
            return false;

        var isAbstained = IsProposalAbstained(proposal, organization);
        return !isAbstained && CheckEnoughVoteAndApprovals(proposal, organization);
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L34-45)
```csharp
    private bool IsProposalRejected(ProposalInfo proposal, Organization organization)
    {
        var rejectionMemberCount =
            proposal.Rejections.Count(organization.OrganizationMemberList.Contains);
        return rejectionMemberCount > organization.ProposalReleaseThreshold.MaximalRejectionThreshold;
    }

    private bool IsProposalAbstained(ProposalInfo proposal, Organization organization)
    {
        var abstentionMemberCount = proposal.Abstentions.Count(organization.OrganizationMemberList.Contains);
        return abstentionMemberCount > organization.ProposalReleaseThreshold.MaximalAbstentionThreshold;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L47-59)
```csharp
    private bool CheckEnoughVoteAndApprovals(ProposalInfo proposal, Organization organization)
    {
        var approvedMemberCount = proposal.Approvals.Count(organization.OrganizationMemberList.Contains);
        var isApprovalEnough =
            approvedMemberCount >= organization.ProposalReleaseThreshold.MinimalApprovalThreshold;
        if (!isApprovalEnough)
            return false;

        var isVoteThresholdReached =
            proposal.Abstentions.Concat(proposal.Approvals).Concat(proposal.Rejections).Count() >=
            organization.ProposalReleaseThreshold.MinimalVoteThreshold;
        return isVoteThresholdReached;
    }
```

**File:** contract/AElf.Contracts.Association/Association_Helper.cs (L77-80)
```csharp
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= organizationMemberCount;
```

**File:** contract/AElf.Contracts.Association/Association.cs (L69-94)
```csharp
    public override Address CreateOrganization(CreateOrganizationInput input)
    {
        var organizationHashAddressPair = CalculateOrganizationHashAddressPair(input);
        var organizationAddress = organizationHashAddressPair.OrganizationAddress;
        var organizationHash = organizationHashAddressPair.OrganizationHash;
        var organization = new Organization
        {
            ProposalReleaseThreshold = input.ProposalReleaseThreshold,
            OrganizationAddress = organizationAddress,
            ProposerWhiteList = input.ProposerWhiteList,
            OrganizationMemberList = input.OrganizationMemberList,
            OrganizationHash = organizationHash,
            CreationToken = input.CreationToken
        };
        Assert(Validate(organization), "Invalid organization.");
        if (State.Organizations[organizationAddress] == null)
        {
            State.Organizations[organizationAddress] = organization;
            Context.Fire(new OrganizationCreated
            {
                OrganizationAddress = organizationAddress
            });
        }

        return organizationAddress;
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L183-201)
```csharp
    public override Empty Release(Hash input)
    {
        var proposalInfo = GetValidProposal(input);
        Assert(Context.Sender == proposalInfo.Proposer, "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);

        Context.Fire(new ProposalReleased
        {
            ProposalId = input,
            OrganizationAddress = proposalInfo.OrganizationAddress
        });
        State.Proposals.Remove(input);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L203-216)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Association/Association.cs (L282-289)
```csharp
    public override Empty ClearProposal(Hash input)
    {
        // anyone can clear proposal if it is expired
        var proposal = State.Proposals[input];
        Assert(proposal != null && Context.CurrentBlockTime >= proposal.ExpiredTime, "Proposal clear failed");
        State.Proposals.Remove(input);
        return new Empty();
    }
```
