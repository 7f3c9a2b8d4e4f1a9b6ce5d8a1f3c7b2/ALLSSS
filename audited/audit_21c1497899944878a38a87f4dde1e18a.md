# Audit Report

## Title
Contract Ownership Theft via Expired Proposal State Overwrite

## Summary
The user contract deployment system in the Genesis contract allows an attacker to steal ownership of a legitimately approved contract deployment by overwriting expired proposal metadata. After a proposal is approved but before it is released, if the expiration period passes, an attacker can submit an identical deployment request to replace the `Author` field with their own address. When the original approved proposal is subsequently released, the contract deploys with the attacker as owner instead of the legitimate proposer.

## Finding Description

The vulnerability exists in the `SendUserContractProposal` function's expiration check mechanism. When a user calls `DeployUserSmartContract`, the function creates a state entry keyed by the input hash and submits it to governance for approval. [1](#0-0) 

The critical flaw is at line 315, which permits state overwrite when `Context.CurrentBlockTime >= registered.ExpiredTime` without verifying whether an approved governance proposal is still pending execution. The function then completely overwrites the `ContractProposingInputMap` entry at line 323, including the `Author` field set to `Context.Sender`.

**Attack Execution Path:**

1. **User A initiates deployment:** Calls `DeployUserSmartContract` with specific contract code, creating proposal hash H and state entry with `Author = UserA` [2](#0-1) 

2. **Governance approval:** The code check proposal is created and approved by miners through the governance organization, but not yet released before the expiration time passes (default 15 minutes). [3](#0-2) 

3. **State overwrite:** After expiration, the attacker submits an identical `UserContractDeploymentInput` (same code, category, salt), generating the same hash H. The expiration check passes and the state is completely overwritten with `Author = Attacker`.

4. **Approved proposal release:** When miners release the original approved proposal via `ReleaseApprovedUserSmartContract`, it retrieves the overwritten state from `ContractProposingInputMap` [4](#0-3) 

The status validation at line 482 passes because the attacker set the status to `CodeCheckProposed` when overwriting. The proposer check at line 483 also passes because it only verifies `Proposer == Context.Self`, which is always true for user contracts and is not tied to any specific proposal ID.

5. **Malicious deployment:** The proposal release triggers `PerformDeployUserSmartContract`, which deploys the contract using the `Author` field from the corrupted state [5](#0-4) 

At lines 502-503, `contractProposingInput.Author` comes from the overwritten state, not from the original proposal that was approved by governance.

**Why Existing Protections Fail:**

The contract has no mechanism to:
- Prevent state overwrite when an approved governance proposal is still pending execution
- Tie the state map entry to a specific proposal ID rather than just the input hash
- Verify that the state retrieved during release corresponds to the specific proposal being released

The expiration check only validates the state mapping's expiration time, not the status of the associated governance proposal in the code check controller contract.

## Impact Explanation

**Severity: HIGH**

This vulnerability represents complete theft of contract ownership and authorship rights, violating the fundamental governance invariant that approved proposals must execute with the original proposer's parameters.

**Concrete Damage:**

1. **Complete ownership takeover:** The attacker gains full control as the contract author, enabling them to:
   - Update the contract via `UpdateUserSmartContract`, which validates `Context.Sender == info.Author` [6](#0-5) 
   
   - Transfer authorship to any address via `SetContractAuthor` [7](#0-6) 

2. **Legitimate proposer loses all rights:** Despite their proposal being legitimately approved through governance, the original proposer loses all authorship rights and cannot perform any author-restricted operations.

3. **Governance subversion:** The attacker effectively hijacks an approved governance decision to gain unauthorized privileges. This undermines trust in the governance process and breaks the security guarantee that only approved proposals execute.

**Affected Parties:**
- Any user who deploys contracts via `DeployUserSmartContract`
- Any user who updates contracts via `UpdateUserSmartContract` (same vulnerability pattern)
- All scenarios where the approval-to-release window exceeds the expiration period

## Likelihood Explanation

**Probability: MEDIUM-HIGH**

**Attacker Capabilities:**
Any user can call `DeployUserSmartContract` with arbitrary inputs. The only permission check is `AssertUserDeployContract()`: [8](#0-7) 

On main chains (where native symbol equals primary token symbol), this check passes for all users. On side chains, it requires Parliament proposer whitelist membership, but whitelisted users can attack each other.

**Attack Complexity: LOW**
1. Monitor for user contract deployment proposals via `CodeCheckRequired` events
2. Wait for the expiration period to elapse (can be queried via `GetCodeCheckProposalExpirationTimePeriod`)
3. Submit identical input to overwrite the state
4. Wait for miners to release the original approved proposal

No need to compromise miners, manipulate governance, or exploit cryptographic weaknesses.

**Feasibility Conditions:**

The attack succeeds when the window between proposal approval and release exceeds the configured expiration period. While the system includes automated proposal release via `CodeCheckProposalReleaseTransactionGenerator`: [9](#0-8) 

The timing window remains realistic due to:
- Default expiration period of only 15 minutes (900 seconds)
- Block production delays during network congestion
- Transaction generator execution cycles not being instantaneous
- Operational delays in miner infrastructure
- Possibility of deliberately short expiration periods via configuration

**Detection Constraints:**

The attack leaves minimal on-chain evidence:
- The attacker's call to `DeployUserSmartContract` appears as a legitimate re-proposal
- The `CodeCheckRequired` event fires normally
- The final `ContractDeployed` event shows the attacker as author, which appears valid
- No clear indicator distinguishes this from a normal proposal

## Recommendation

**Primary Fix:** Tie the proposal state to the specific governance proposal ID rather than just the input hash:

```csharp
private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
{
    var registered = State.ContractProposingInputMap[proposingInputHash];
    
    // Only allow overwrite if expired AND no approved proposal exists
    if (registered != null)
    {
        Assert(Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        Assert(registered.Status != ContractProposingInputStatus.CodeCheckProposed || 
               !IsProposalApproved(registered.ProposalId), 
               "Cannot overwrite while approved proposal is pending.");
    }
    
    var proposedInfo = new ContractProposingInput
    {
        Proposer = Context.Self,
        Status = ContractProposingInputStatus.CodeCheckProposed,
        ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
        Author = Context.Sender,
        ProposalId = /* store the governance proposal ID here */
    };
    State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
    // ... rest of function
}
```

**Alternative Fixes:**

1. **Remove expiration-based overwrite:** Once a proposal is submitted, do not allow any overwrites until it is fully processed or explicitly cancelled through governance.

2. **Add proposal ID verification:** In `ReleaseApprovedUserSmartContract`, verify that the proposal ID being released matches the proposal ID stored in the state map.

3. **Increase default expiration period:** Make the default `CodeCheckProposalExpirationTimePeriod` significantly longer than the expected approval-to-release window.

## Proof of Concept

The vulnerability can be demonstrated with the following test sequence in the AElf test framework:

```csharp
// 1. UserA deploys contract
var deployInput = new UserContractDeploymentInput { Code = contractCode, Category = 0 };
await ExecuteDeployUserSmartContract(UserA, deployInput);
var proposalId1 = GetProposalIdFromLogs();
var proposedHash = CalculateHashFromInput(deployInput);

// 2. Miners approve proposal
await ApproveProposalWithMiners(proposalId1);

// 3. Wait for expiration (15 minutes + 1 second)
await AdvanceTime(901);

// 4. Attacker overwrites with identical input
await ExecuteDeployUserSmartContract(Attacker, deployInput);

// 5. Release original approved proposal
await ReleaseApprovedUserSmartContract(proposalId1, proposedHash);

// 6. Verify contract deployed with Attacker as author (VULNERABILITY)
var contractAddress = GetDeployedContractAddress();
var contractInfo = await GetContractInfo(contractAddress);
Assert.Equal(Attacker, contractInfo.Author); // Should be UserA but is Attacker!
```

This single test function demonstrates that an approved proposal from UserA results in contract deployment with Attacker as the owner.

### Citations

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L312-323)
```csharp
    private void SendUserContractProposal(Hash proposingInputHash, string releaseMethodName, ByteString @params)
    {
        var registered = State.ContractProposingInputMap[proposingInputHash];
        Assert(registered == null || Context.CurrentBlockTime >= registered.ExpiredTime, "Already proposed.");
        var proposedInfo = new ContractProposingInput
        {
            Proposer = Context.Self,
            Status = ContractProposingInputStatus.CodeCheckProposed,
            ExpiredTime = Context.CurrentBlockTime.AddSeconds(GetCodeCheckProposalExpirationTimePeriod()),
            Author = Context.Sender
        };
        State.ContractProposingInputMap[proposingInputHash] = proposedInfo;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Helper.cs (L344-357)
```csharp
    private void AssertUserDeployContract()
    {
        // Only the symbol of main chain or public side chain is native symbol.
        RequireTokenContractContractAddressSet();
        var primaryTokenSymbol = State.TokenContract.GetPrimaryTokenSymbol.Call(new Empty()).Value;
        if (Context.Variables.NativeSymbol == primaryTokenSymbol)
        {
            return;
        }

        RequireParliamentContractAddressSet();
        var whitelist = State.ParliamentContract.GetProposerWhiteList.Call(new Empty());
        Assert(whitelist.Proposers.Contains(Context.Sender), "No permission.");
    }
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L409-427)
```csharp
    public override DeployUserSmartContractOutput DeployUserSmartContract(UserContractDeploymentInput input)
    {
        AssertInlineDeployOrUpdateUserContract();
        AssertUserDeployContract();

        var codeHash = HashHelper.ComputeFrom(input.Code.ToByteArray());
        Context.LogDebug(() => "BasicContractZero - Deployment user contract hash: " + codeHash.ToHex());

        AssertContractNotExists(codeHash);

        if (input.Salt != null)
        {
            AssertContractAddressAvailable(Context.Sender, input.Salt);
        }

        var proposedContractInputHash = CalculateHashFromInput(input);
        SendUserContractProposal(proposedContractInputHash,
            nameof(BasicContractZeroImplContainer.BasicContractZeroImplBase.PerformDeployUserSmartContract),
            input.ToByteString());
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L445-451)
```csharp
    public override Empty UpdateUserSmartContract(UserContractUpdateInput input)
    {
        AssertInlineDeployOrUpdateUserContract();

        var info = State.ContractInfos[input.Address];
        Assert(info != null, "Contract not found.");
        Assert(Context.Sender == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L476-488)
```csharp
    public override Empty ReleaseApprovedUserSmartContract(ReleaseContractInput input)
    {
        var contractProposingInput = State.ContractProposingInputMap[input.ProposedContractInputHash];

        Assert(
            contractProposingInput != null &&
            contractProposingInput.Status == ContractProposingInputStatus.CodeCheckProposed &&
            contractProposingInput.Proposer == Context.Self, "Invalid contract proposing status.");

        AssertCurrentMiner();

        contractProposingInput.Status = ContractProposingInputStatus.CodeChecked;
        State.ContractProposingInputMap[input.ProposedContractInputHash] = contractProposingInput;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L495-504)
```csharp
    public override Address PerformDeployUserSmartContract(UserContractDeploymentInput input)
    {
        RequireSenderAuthority(State.CodeCheckController.Value.OwnerAddress);

        var inputHash = CalculateHashFromInput(input);
        TryClearContractProposingData(inputHash, out var contractProposingInput);

        var address = DeploySmartContract(null, input.Category, input.Code.ToByteArray(), false,
            contractProposingInput.Author, true, contractProposingInput.Author, input.Salt);
        return address;
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero.cs (L519-524)
```csharp
    public override Empty SetContractAuthor(SetContractAuthorInput input)
    {
        var info = State.ContractInfos[input.ContractAddress];
        Assert(info != null, "Contract not found.");
        var oldAuthor = info.Author;
        Assert(Context.Sender == info.Author, "No permission.");
```

**File:** contract/AElf.Contracts.Genesis/BasicContractZero_Constants.cs (L6-6)
```csharp
    public const int DefaultCodeCheckProposalExpirationTimePeriod = 900; // 60 * 15
```

**File:** src/AElf.Kernel.CodeCheck/Application/CodeCheckProposalReleaseTransactionGenerator.cs (L60-72)
```csharp
        var releaseContractTransactions = releaseRequired.Select(proposal => new Transaction
        {
            From = from,
            MethodName = nameof(ACS0Container.ACS0Stub.ReleaseApprovedUserSmartContract),
            To = zeroContractAddress,
            RefBlockNumber = preBlockHeight,
            RefBlockPrefix = BlockHelper.GetRefBlockPrefix(preBlockHash),
            Params = new ReleaseContractInput
            {
                ProposalId = proposal.ProposalId,
                ProposedContractInputHash = proposal.ProposedContractInputHash
            }.ToByteString()
        }).ToList();
```
