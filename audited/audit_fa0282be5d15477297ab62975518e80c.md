### Title
Missing Upper Bound Validation in SetMaximumProfitReceivingPeriodCount Enables Gas Exhaustion DoS in ClaimProfits

### Summary
The `SetMaximumProfitReceivingPeriodCount` function lacks an upper bound check, allowing Parliament governance to set `MaximumProfitReceivingPeriodCount` to extreme values like `int.MaxValue`. This configuration error causes the `ClaimProfits` function to attempt billions of loop iterations, resulting in gas exhaustion and permanent DoS for all users attempting to claim profits.

### Finding Description

The vulnerability stems from insufficient input validation in the governance parameter setter combined with its usage in unbounded loops.

**Root Cause - Missing Upper Bound Check:**
The `SetMaximumProfitReceivingPeriodCount` function only validates that the input value is greater than zero, with no maximum limit check. [1](#0-0) 

**Exploitation Path:**
When `MaximumProfitReceivingPeriodCount` is set to an extreme value (e.g., `int.MaxValue` = 2,147,483,647), the value flows through the following execution path:

1. The `ClaimProfits` function retrieves the maximum period count per profitable detail through `GetMaximumPeriodCountForProfitableDetail`. [2](#0-1) 

2. The `GetMaximumPeriodCountForProfitableDetail` function divides the configured maximum by the number of profitable details (capped at 10), returning up to 214,748,364 iterations per detail. [3](#0-2) 

3. The `ProfitAllPeriods` function executes a loop from `LastProfitPeriod` to `LastProfitPeriod + maxProfitReceivingPeriodCount`, potentially iterating hundreds of millions of times per profitable detail and token symbol. [4](#0-3) 

4. Each iteration performs state reads, calculations, and potentially token transfers, consuming substantial gas. [5](#0-4) 

5. With up to 10 profitable details and multiple token symbols, the total iteration count can reach billions, far exceeding any reasonable gas limit.

The default value is only 100, demonstrating the intended reasonable range. [6](#0-5) 

### Impact Explanation

**Operational Impact - Complete DoS:**
- All users are permanently unable to execute `ClaimProfits` due to gas exhaustion
- Accumulated profits across all schemes become inaccessible until Parliament corrects the configuration
- The DoS persists until governance recognizes the issue and submits a corrective proposal, which requires proposal creation, voting period, and execution - potentially days of downtime

**Affected Parties:**
- All profit scheme beneficiaries across the entire AElf ecosystem
- TokenHolder contract participants relying on dividend distributions
- Election participants expecting reward claims
- Any contract or user with registered profit details

**Severity Justification:**
This is a **High severity** vulnerability because it causes complete operational failure of a critical economic function affecting all ecosystem participants. While it requires governance action, the missing input validation represents a design flaw that enables accidental system breakage.

### Likelihood Explanation

**Governance Misconfiguration Scenario:**
This vulnerability does not require a malicious Parliament. Realistic exploitation scenarios include:

1. **Well-Intentioned Error:** Governance might believe a larger value provides more flexibility, setting it to `int.MaxValue` or another extreme value without understanding the gas implications
2. **Copy-Paste Error:** Using `int.MaxValue` from another context where it represents "unlimited" 
3. **Lack of Documentation:** No clear guidance on safe value ranges in the contract or governance interface

**Execution Practicality:**
- Parliament creates a proposal to set the parameter via `SetMaximumProfitReceivingPeriodCount` [1](#0-0) 
- Proposal passes standard governance approval process
- Once executed, `ClaimProfits` immediately becomes unusable for all users
- Detection may be delayed until users report claim failures

**Feasibility Conditions:**
- Requires Parliament governance approval (standard operational procedure)
- No malicious intent required, only configuration error
- No external resources or complex setup needed

### Recommendation

**Immediate Fix - Add Upper Bound Validation:**

Add a reasonable maximum limit check in `SetMaximumProfitReceivingPeriodCount`:

```csharp
public override Empty SetMaximumProfitReceivingPeriodCount(Int32Value input)
{
    ValidateContractState(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
    Assert(Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
        "No permission.");
    Assert(input.Value > 0, "Invalid maximum profit receiving period count.");
    
    // Add upper bound check
    const int MaximumAllowedPeriodCount = 10000; // Reasonable limit considering gas costs
    Assert(input.Value <= MaximumAllowedPeriodCount, 
        $"Maximum profit receiving period count cannot exceed {MaximumAllowedPeriodCount}.");
    
    State.MaximumProfitReceivingPeriodCount.Value = input.Value;
    return new Empty();
}
```

**Invariant to Enforce:**
`0 < MaximumProfitReceivingPeriodCount <= MaximumAllowedPeriodCount` where `MaximumAllowedPeriodCount` is determined based on gas limit analysis and typical profit distribution patterns.

**Additional Protections:**
1. Add a constant to `ProfitContractConstants.cs`: `MaximumAllowedPeriodCount = 10000`
2. Document the parameter's gas implications in governance interfaces
3. Add regression tests covering extreme values

**Test Cases:**
- Verify that setting to `MaximumAllowedPeriodCount + 1` fails with appropriate error
- Verify that setting to `int.MaxValue` fails with appropriate error
- Verify that valid values within range succeed and ClaimProfits remains functional

### Proof of Concept

**Initial State:**
- Profit scheme exists with active beneficiaries
- Beneficiaries have multiple unclaimed periods of profits
- Default `MaximumProfitReceivingPeriodCount` = 100 (normal operation)

**Attack Sequence:**

1. **Governance Misconfiguration:**
   - Parliament creates proposal: `SetMaximumProfitReceivingPeriodCount(int.MaxValue)`
   - Miners approve and release proposal
   - `State.MaximumProfitReceivingPeriodCount.Value` = 2,147,483,647

2. **User Attempts Claim:**
   - User calls `ClaimProfits(schemeId, beneficiary)`
   - `profitableDetailCount` = 10 (maximum per constants)
   - `maxProfitReceivingPeriodCount` = 2,147,483,647 / 10 = 214,748,364
   - `ProfitAllPeriods` executes loop: `for (period = lastPeriod; period <= lastPeriod + 214,748,364; period++)`

3. **Result:**
   - Transaction attempts billions of state reads across loop iterations
   - Gas limit exhausted before completion
   - Transaction reverts with "Out of gas" error
   - User's profits remain unclaimed and inaccessible

**Success Condition:**
All `ClaimProfits` transactions fail with gas exhaustion until Parliament corrects the parameter to a reasonable value (e.g., â‰¤ 10,000).

**Notes:**
- This vulnerability affects the entire profit distribution system, not individual schemes
- Recovery requires governance action to reset to reasonable value
- The design flaw enables accidental system breakage through missing input validation
- Even though Parliament is a trusted role, good contract design should prevent invalid system states through proper bounds checking

### Citations

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L772-774)
```csharp
        var profitableDetailCount =
            Math.Min(ProfitContractConstants.ProfitReceivingLimitForEachTime, profitableDetails.Count);
        var maxProfitReceivingPeriodCount = GetMaximumPeriodCountForProfitableDetail(profitableDetailCount);
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L822-833)
```csharp
    private int GetMaximumPeriodCountForProfitableDetail(int profitableDetailCount)
    {
        // Get the maximum profit receiving period count
        var maxPeriodCount = GetMaximumProfitReceivingPeriodCount();
        // Check if the maximum period count is greater than the profitable detail count
        // and if the profitable detail count is greater than 0
        return maxPeriodCount > profitableDetailCount && profitableDetailCount > 0
            // Divide the maximum period count by the profitable detail count
            ? maxPeriodCount.Div(profitableDetailCount)
            // If the conditions are not met, return 1 as the maximum period count
            : 1;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L835-843)
```csharp
    public override Empty SetMaximumProfitReceivingPeriodCount(Int32Value input)
    {
        ValidateContractState(State.ParliamentContract, SmartContractConstants.ParliamentContractSystemName);
        Assert(Context.Sender == State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            "No permission.");
        Assert(input.Value > 0, "Invalid maximum profit receiving period count.");
        State.MaximumProfitReceivingPeriodCount.Value = input.Value;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L857-860)
```csharp
            var maxProfitPeriod = profitDetail.EndPeriod == long.MaxValue
                ? Math.Min(scheme.CurrentPeriod - 1, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount))
                : Math.Min(targetPeriod, profitDetail.LastProfitPeriod.Add(maxProfitReceivingPeriodCount));
            for (var period = profitDetail.LastProfitPeriod; period <= maxProfitPeriod; period++)
```

**File:** contract/AElf.Contracts.Profit/ProfitContract.cs (L864-895)
```csharp
                var distributedPeriodProfitsVirtualAddress =
                    GetDistributedPeriodProfitsVirtualAddress(scheme.SchemeId, period);
                var distributedProfitsInformation =
                    State.DistributedProfitsMap[distributedPeriodProfitsVirtualAddress];
                if (distributedProfitsInformation == null || distributedProfitsInformation.TotalShares == 0 ||
                    !distributedProfitsInformation.AmountsMap.Any() ||
                    !distributedProfitsInformation.AmountsMap.ContainsKey(symbol))
                    continue;

                var amount = SafeCalculateProfits(profitDetail.Shares,
                    distributedProfitsInformation.AmountsMap[symbol], distributedProfitsInformation.TotalShares);

                if (!isView)
                {
                    Context.LogDebug(() =>
                        $"{beneficiary} is profiting {amount} {symbol} tokens from {scheme.SchemeId.ToHex()} in period {periodToPrint}." +
                        $"Sender's Shares: {detailToPrint.Shares}, total Shares: {distributedProfitsInformation.TotalShares}");
                    if (distributedProfitsInformation.IsReleased && amount > 0)
                    {
                        if (State.TokenContract.Value == null)
                            State.TokenContract.Value =
                                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

                        Context.SendVirtualInline(
                            GeneratePeriodVirtualAddressFromHash(scheme.SchemeId, period),
                            State.TokenContract.Value,
                            nameof(State.TokenContract.Transfer), new TransferInput
                            {
                                To = beneficiary,
                                Symbol = symbol,
                                Amount = amount
                            }.ToByteString());
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L9-9)
```csharp
    public const int DefaultMaximumProfitReceivingPeriodCountOfOneTime = 100;
```
