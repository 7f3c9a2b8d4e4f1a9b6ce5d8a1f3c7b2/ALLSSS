### Title
Missing Token Creation Verification Allows NFT Protocol Existence Without Underlying Token

### Summary
The `Create()` function in NFTContract does not verify that the underlying token was actually created by TokenContract after calling `TokenContract.Create.Send()`. If the TokenContract is compromised and returns success without creating the token, the NFT protocol will be saved with all metadata but remain completely non-functional, as all subsequent operations (mint/transfer/burn) will fail due to the missing underlying token.

### Finding Description

**Location:** [1](#0-0) 

**Root Cause:** The `Create()` function calls `State.TokenContract.Create.Send(tokenCreateInput)` but immediately proceeds to save NFT protocol state without verifying the token was actually created. [2](#0-1) 

**Why Protections Fail:** In AElf's contract execution model, the `.Send()` method propagates exceptions from the called contract to the caller. However, if TokenContract is malicious, it could:
1. Execute without throwing exceptions (appear successful)
2. Skip calling `RegisterTokenInfo()` which saves token data [3](#0-2) 
3. Return `Empty()` successfully, allowing NFTContract to continue

**Execution Path:**
1. User calls `NFTContract.Create()` with valid input
2. NFTContract calls `TokenContract.Create.Send()` at line 34
3. Malicious TokenContract returns success without saving `State.TokenInfos[symbol]`
4. NFTContract saves `MinterListMap`, `NftProtocolMap`, and fires `NFTProtocolCreated` event [4](#0-3) 
5. NFT protocol appears to exist, but underlying token does not

**Insufficient Protections:** Unlike `CrossChainCreate()` which explicitly verifies token existence using `GetTokenInfo.Call()` and throws an exception if the token doesn't exist [5](#0-4) , the `Create()` function has no such verification.

### Impact Explanation

**Operational Denial of Service:**
- The NFT protocol exists in NFTContract state but the underlying token does not exist in TokenContract state
- All subsequent operations fail because `PerformMint()` calls `GetTokenInfo` which returns empty/null TokenInfo [6](#0-5) 
- The `GetMinterList()` function uses `tokenInfo.Symbol` to look up minters, but receives empty string instead of the actual symbol [7](#0-6) 
- Permission checks and chain ID validation fail, making the protocol completely non-functional

**Who Is Affected:**
- Protocol creators who believe they successfully created an NFT protocol
- Users attempting to mint/transfer NFTs who face persistent failures
- The blockchain state is polluted with non-functional protocol entries

**Severity Justification:**
This is a **Critical** severity issue because:
1. Complete denial of service for the NFT protocol
2. Irreversible state corruption (protocol saved but non-functional)
3. User deception (protocol appears created via event emission)
4. Resource waste (state storage consumed for unusable data)

### Likelihood Explanation

**Attacker Capabilities Required:**
The premise explicitly assumes TokenContract (a system contract) is compromised. This requires either:
- Malicious initial deployment through governance failure
- Malicious upgrade through governance compromise

**Attack Complexity:**
Once TokenContract is compromised, the attack is trivial:
1. Modify `CreateToken()` to skip `RegisterTokenInfo()` call
2. Still return `Empty()` success response
3. NFTContract automatically creates non-functional protocols

**Feasibility Conditions:**
While system contract compromise is a high-bar threat model, this finding is valid because:
1. The question explicitly asks to evaluate this scenario
2. Defense-in-depth principles apply even to trusted system contracts
3. The codebase already demonstrates this pattern - `CrossChainCreate()` verifies token existence
4. The verification protects against both malicious behavior AND implementation bugs in TokenContract

**Detection Constraints:**
The attack is difficult to detect because:
- Transaction succeeds without errors
- `NFTProtocolCreated` event fires normally
- Failure only manifests during subsequent operations (mint/transfer)

### Recommendation

**Code-Level Mitigation:**
Add token existence verification after the `Create.Send()` call, following the same pattern used in `CrossChainCreate()`:

```csharp
State.TokenContract.Create.Send(tokenCreateInput);

// Verify token was actually created
var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
{
    Symbol = symbol
});
Assert(!string.IsNullOrEmpty(tokenInfo.Symbol), 
    $"Token {symbol} was not created successfully by TokenContract.");
```

**Invariant Checks:**
- NFT protocol creation must be atomic: either both NFT protocol AND underlying token exist, or neither exists
- Token symbol verification must match between NFTContract and TokenContract state

**Test Cases:**
1. Mock TokenContract that returns success but doesn't create token
2. Verify NFTContract.Create() fails with assertion error
3. Verify no NFTProtocolInfo is saved in failure case
4. Verify no NFTProtocolCreated event is emitted in failure case

### Proof of Concept

**Initial State:**
- TokenContract is compromised with modified `CreateToken()` that skips `RegisterTokenInfo()` but returns `Empty()` 
- User has valid CreateInput with symbol "TEST-0", total supply 10000

**Transaction Steps:**

1. User calls `NFTContract.Create(createInput)`
2. NFTContract calls `State.TokenContract.Create.Send()` at line 34
3. Malicious TokenContract:
   - Validates input (passes)
   - Does NOT call `RegisterTokenInfo()` 
   - Returns `Empty()` (success)
4. NFTContract continues execution:
   - Saves `State.MinterListMap["TEST-0"]` 
   - Saves `State.NftProtocolMap["TEST-0"]` with full protocol info
   - Fires `NFTProtocolCreated` event
   - Returns symbol "TEST-0"

**Expected Result:**
Transaction should fail with "Token TEST-0 was not created successfully"

**Actual Result:**
Transaction succeeds, but:
- `State.TokenInfos["TEST-0"]` does not exist in TokenContract
- `State.NftProtocolMap["TEST-0"]` DOES exist in NFTContract
- Any subsequent `Mint()` call retrieves empty TokenInfo and fails permission/validation checks
- Protocol appears to exist but is permanently non-functional

**Success Condition:**
After adding the recommended verification, the `Create()` transaction should fail and revert all state changes when TokenContract doesn't actually create the token.

### Notes

This finding emphasizes the importance of defense-in-depth even when interacting with trusted system contracts. The fact that `CrossChainCreate()` already implements token existence verification demonstrates that the development team recognizes the value of this check. Applying the same pattern to `Create()` would maintain consistency and protect against both malicious behavior and implementation bugs in TokenContract.

### Citations

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L34-67)
```csharp
        State.TokenContract.Create.Send(tokenCreateInput);

        var minterList = input.MinterList ?? new MinterList();
        if (!minterList.Value.Contains(creator)) minterList.Value.Add(creator);
        State.MinterListMap[symbol] = minterList;

        var protocolInfo = new NFTProtocolInfo
        {
            Symbol = symbol,
            BaseUri = input.BaseUri,
            TotalSupply = tokenCreateInput.TotalSupply,
            Creator = tokenCreateInput.Issuer,
            Metadata = new Metadata { Value = { tokenExternalInfo.Value } },
            ProtocolName = tokenCreateInput.TokenName,
            IsTokenIdReuse = input.IsTokenIdReuse,
            IssueChainId = tokenCreateInput.IssueChainId,
            IsBurnable = tokenCreateInput.IsBurnable,
            NftType = input.NftType
        };
        State.NftProtocolMap[symbol] = protocolInfo;

        Context.Fire(new NFTProtocolCreated
        {
            Symbol = tokenCreateInput.Symbol,
            Creator = tokenCreateInput.Issuer,
            IsBurnable = tokenCreateInput.IsBurnable,
            IssueChainId = tokenCreateInput.IssueChainId,
            ProtocolName = tokenCreateInput.TokenName,
            TotalSupply = tokenCreateInput.TotalSupply,
            Metadata = protocolInfo.Metadata,
            BaseUri = protocolInfo.BaseUri,
            IsTokenIdReuse = protocolInfo.IsTokenIdReuse,
            NftType = protocolInfo.NftType
        });
```

**File:** contract/AElf.Contracts.NFT/NFTContract_Create.cs (L80-85)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        if (string.IsNullOrEmpty(tokenInfo.Symbol))
            throw new AssertionException($"Token info {input.Symbol} not exists.");
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L224-234)
```csharp
    private void RegisterTokenInfo(TokenInfo tokenInfo)
    {
        Assert(!string.IsNullOrEmpty(tokenInfo.Symbol) && IsValidSymbol(tokenInfo.Symbol),
            "Invalid symbol.");
        Assert(!string.IsNullOrEmpty(tokenInfo.TokenName), "Token name can neither be null nor empty.");
        Assert(tokenInfo.TotalSupply > 0, "Invalid total supply.");
        Assert(tokenInfo.Issuer != null, "Invalid issuer address.");
        Assert(tokenInfo.Owner != null, "Invalid owner address.");
        State.TokenInfos[tokenInfo.Symbol] = tokenInfo;
        State.InsensitiveTokenExisting[tokenInfo.Symbol.ToUpper()] = true;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L375-381)
```csharp
    private MinterList GetMinterList(TokenInfo tokenInfo)
    {
        var minterList = State.MinterListMap[tokenInfo.Symbol] ?? new MinterList();
        if (!minterList.Value.Contains(tokenInfo.Issuer)) minterList.Value.Add(tokenInfo.Issuer);

        return minterList;
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_UseChain.cs (L385-390)
```csharp
        var tokenInfo = State.TokenContract.GetTokenInfo.Call(new GetTokenInfoInput
        {
            Symbol = input.Symbol
        });
        var protocolInfo = State.NftProtocolMap[input.Symbol];
        if (protocolInfo == null) throw new AssertionException($"Invalid NFT Token symbol: {input.Symbol}");
```
