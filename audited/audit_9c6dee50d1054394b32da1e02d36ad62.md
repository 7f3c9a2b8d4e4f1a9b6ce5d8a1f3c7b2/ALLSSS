### Title
Unbounded Fee Symbol List in MultiToken SetMethodFee() Enables DOS on Transfer Operations via O(n²) Complexity in GetResourceInfo()

### Summary
The MultiToken contract's `SetMethodFee()` function lacks a limit on the number of fee symbols that can be configured, unlike the Profit contract which enforces a limit of 5 symbols. When governance sets an excessive number of fee symbols (e.g., 100+), the `GetTransactionFeeSymbols()` function exhibits O(n²) complexity due to repeated `List.Contains()` checks. This function is invoked via `GetResourceInfo()` for every Transfer and TransferFrom transaction to support parallel execution, causing severe performance degradation and DOS on the most frequently used token operations.

### Finding Description

The root cause exists in the MultiToken contract's implementation of the ACS1 transaction fee standard: [1](#0-0) 

The `SetMethodFee()` function only validates individual token symbols but performs no check on the total count of fees in `input.Fees`. It stores the entire `MethodFees` object without bounds checking. In contrast, the Profit contract implements proper protection: [2](#0-1) [3](#0-2) 

The vulnerability manifests when `GetTransactionFeeSymbols()` is called, which has O(n²) complexity: [4](#0-3) 

The O(n²) complexity arises from the `symbols.Contains(methodFee.Symbol)` check at line 71, where `Contains()` is O(n) and is executed for each of n fee symbols. For 1000 symbols, this results in approximately 1,000,000 operations.

This function is called from the ACS2 implementation's `AddPathForTransactionFee()`: [5](#0-4) 

Which is invoked by `GetResourceInfo()` for Transfer and TransferFrom operations: [6](#0-5) 

The `GetResourceInfo()` method is called by the parallel execution infrastructure before every transaction to determine state path dependencies for parallelization: [7](#0-6) 

Additionally, fee collection also iterates through all fees: [8](#0-7) 

### Impact Explanation

**Concrete Harm:**
- **DOS on Token Operations**: Transfer and TransferFrom are the most frequently used token operations. Every such transaction would experience significant gas cost increases and execution delays proportional to n² where n is the number of configured fee symbols.
- **Network-Wide Performance Degradation**: Since parallel execution path calculation occurs before transaction execution for all transactions, the entire network's transaction processing capacity is reduced.
- **Disproportionate Impact**: With 100 fee symbols configured, GetTransactionFeeSymbols() performs ~10,000 Contains() operations per transaction. With 1000 symbols, this becomes ~1,000,000 operations.

**Affected Parties:**
- All users performing token transfers (most common blockchain operation)
- Network validators processing transactions
- Applications relying on token transfer functionality

**Severity Justification:**
Medium severity because:
1. Requires governance action (MethodFeeController authority), not directly exploitable by untrusted attackers
2. However, governance lacks safeguards to prevent accidental misconfiguration
3. Impact is severe (DOS on critical operations) once triggered
4. Unlike other contracts (Profit), MultiToken has no protection despite being the most frequently used contract

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of the MethodFeeController (defaults to Parliament default organization)
- Ability to create and pass a governance proposal to call SetMethodFee() [9](#0-8) [10](#0-9) 

**Attack Complexity:**
- Low: A single governance proposal with a MethodFees object containing many fee symbols
- No multi-step attack required
- No timing dependencies

**Feasibility Conditions:**
- Governance could accidentally set excessive fee symbols when trying to support multiple payment tokens
- Malicious governance participant could intentionally exploit this
- No validation exists to prevent the misconfiguration

**Detection/Operational Constraints:**
- Effect is immediate and network-wide once SetMethodFee() executes
- Difficult to reverse quickly as requires another governance proposal
- No monitoring alerts for excessive fee symbol counts

**Probability Assessment:**
Medium likelihood because while governance control is required (not direct public exploit), the lack of bounds checking combined with legitimate use cases for multiple fee tokens creates realistic scenarios where this could occur either accidentally or maliciously.

### Recommendation

**Code-Level Mitigation:**

Add a count limit check in MultiToken's SetMethodFee() similar to the Profit contract:

1. Define a constant in TokenContractConstants or a new constants file:
```csharp
public const int MaxMethodFeeSymbolCount = 5;
```

2. Add validation in SetMethodFee() before line 15:
```csharp
Assert(input.Fees.Count <= TokenContractConstants.MaxMethodFeeSymbolCount, 
    "Method fee symbol count exceeds maximum allowed.");
```

3. Optimize GetTransactionFeeSymbols() to use HashSet for O(1) lookups instead of List.Contains():
```csharp
private List<string> GetTransactionFeeSymbols(string methodName)
{
    var symbolSet = new HashSet<string>();
    // ... rest of logic using symbolSet.Add() and symbolSet.Contains()
    return symbolSet.ToList();
}
```

**Invariant Checks:**
- Assert `input.Fees.Count <= MaxMethodFeeSymbolCount` in SetMethodFee()
- Add unit test verifying SetMethodFee() rejects inputs with > 5 symbols
- Add integration test confirming GetResourceInfo() completes within gas limits even with maximum allowed symbols

**Test Cases:**
- Test SetMethodFee() with 6 symbols (should fail)
- Test GetResourceInfo() performance with 5 symbols (should pass efficiently)
- Test that existing functionality works after adding the limit

### Proof of Concept

**Initial State:**
- MultiToken contract deployed with default configuration
- Parliament governance operational
- Transfer method has no specific fee configuration (or default configuration with 1-2 symbols)

**Exploitation Steps:**

1. Governance creates proposal to call TokenContract.SetMethodFee() with:
```
MethodFees {
  method_name: "Transfer",
  fees: [
    {symbol: "ELF", basic_fee: 1000000},
    {symbol: "USDT", basic_fee: 1000000},
    {symbol: "TOKEN1", basic_fee: 1000000},
    ... (repeat for 100 different token symbols)
  ]
}
```

2. Governance approves and executes the proposal

3. Attacker (or any user) attempts a Transfer transaction

**Expected vs Actual Result:**

**Expected:** Transfer transaction executes normally with reasonable gas cost

**Actual:** 
- GetResourceInfo() called before execution performs ~10,000 operations (100² for Contains() checks)
- Transaction execution time increases dramatically
- Gas cost increases proportionally
- Network-wide impact on all Transfer/TransferFrom transactions
- Parallel execution framework becomes bottleneck

**Success Condition:**
Monitor transaction execution time for Transfer operations before and after SetMethodFee() with 100 symbols. Execution time should increase by orders of magnitude, demonstrating the DOS condition. Transaction success rate may decrease if gas limits are exceeded during the GetResourceInfo() phase.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L64-88)
```csharp
    private List<string> GetTransactionFeeSymbols(string methodName)
    {
        var symbols = new List<string>();
        if (State.TransactionFees[methodName] != null)
        {
            foreach (var methodFee in State.TransactionFees[methodName].Fees)
            {
                if (!symbols.Contains(methodFee.Symbol) && methodFee.BasicFee > 0)
                    symbols.Add(methodFee.Symbol);
            }
            if (State.TransactionFees[methodName].IsSizeFeeFree)
            {
                return symbols;
            }
        }
        
        if (State.SymbolListToPayTxSizeFee.Value == null) return symbols;
        
        foreach (var sizeFee in State.SymbolListToPayTxSizeFee.Value.SymbolsToPayTxSizeFee)
        {
            if (!symbols.Contains(sizeFee.TokenSymbol))
                symbols.Add(sizeFee.TokenSymbol);
        }
        return symbols;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContract_ACS1_TransactionFeeProvider.cs (L11-20)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var methodFee in input.Fees) AssertValidToken(methodFee.Symbol, methodFee.BasicFee);
        Assert(input.Fees.Count <= ProfitContractConstants.TokenAmountLimit, "Invalid input.");
        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
        State.TransactionFees[input.MethodName] = input;

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Profit/ProfitContractConstants.cs (L8-8)
```csharp
    public const int TokenAmountLimit = 5;
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L11-69)
```csharp
    public override ResourceInfo GetResourceInfo(Transaction txn)
    {
        switch (txn.MethodName)
        {
            case nameof(Transfer):
            {
                var args = TransferInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), txn.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol)
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };

                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }

            case nameof(TransferFrom):
            {
                var args = TransferFromInput.Parser.ParseFrom(txn.Params);
                var resourceInfo = new ResourceInfo
                {
                    WritePaths =
                    {
                        GetPath(nameof(TokenContractState.Balances), args.From.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.Balances), args.To.ToString(), args.Symbol),
                        GetPath(nameof(TokenContractState.LockWhiteLists), args.Symbol, txn.From.ToString())
                    },
                    ReadPaths =
                    {
                        GetPath(nameof(TokenContractState.TokenInfos), args.Symbol),
                        GetPath(nameof(TokenContractState.ChainPrimaryTokenSymbol)),
                        GetPath(nameof(TokenContractState.TransactionFeeFreeAllowancesSymbolList))
                    }
                };
                AddPathForAllowance(resourceInfo, args.From.ToString(), txn.From.ToString(), args.Symbol);
                AddPathForTransactionFee(resourceInfo, txn.From.ToString(), txn.MethodName);
                AddPathForDelegatees(resourceInfo, txn.From, txn.To, txn.MethodName);
                AddPathForTransactionFeeFreeAllowance(resourceInfo, txn.From);

                return resourceInfo;
            }

            default:
                return new ResourceInfo { NonParallelizable = true };
        }
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS2_StatePathsProvider.cs (L84-96)
```csharp
    private void AddPathForTransactionFee(ResourceInfo resourceInfo, string from, string methodName)
    {
        var symbols = GetTransactionFeeSymbols(methodName);
        var primaryTokenSymbol = GetPrimaryTokenSymbol(new Empty()).Value;
        if (_primaryTokenSymbol != string.Empty && !symbols.Contains(primaryTokenSymbol))
            symbols.Add(primaryTokenSymbol);
        var paths = symbols.Select(symbol => GetPath(nameof(TokenContractState.Balances), from, symbol));
        foreach (var path in paths)
        {
            if (resourceInfo.WritePaths.Contains(path)) continue;
            resourceInfo.WritePaths.Add(path);
        }
    }
```

**File:** src/AElf.Kernel.SmartContract.Parallel/Domain/ResourceExtractionService.cs (L193-207)
```csharp
    private ITransactionContext GetTransactionContext(IChainContext chainContext, Address contractAddress,
        ByteString param)
    {
        var generatedTxn = new Transaction
        {
            From = contractAddress,
            To = contractAddress,
            MethodName = nameof(ACS2BaseContainer.ACS2BaseStub.GetResourceInfo),
            Params = param,
            Signature = ByteString.CopyFromUtf8(KernelConstants.SignaturePlaceholder)
        };

        var txContext = _transactionContextFactory.Create(generatedTxn, chainContext);
        return txContext;
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Fees.cs (L322-327)
```csharp
    private Dictionary<string, long> GetBaseFeeDictionary(MethodFees methodFees)
    {
        return methodFees.Fees.Where(f => !string.IsNullOrEmpty(f.Symbol))
            .GroupBy(f => f.Symbol, f => f.BasicFee)
            .ToDictionary(g => g.Key, g => g.Sum());
    }
```
