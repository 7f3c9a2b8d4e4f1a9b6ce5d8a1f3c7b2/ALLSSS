### Title
Missing Option Validation in Register Method Enables State Bloat Attack

### Summary
The `Register` method in the Vote contract fails to validate the number and length of options provided in `VotingRegisterInput`, allowing attackers to bypass the intended limits of 64 options and 1024 bytes per option. This enables state bloat attacks where each voting item can store up to 64KB of data for only 10 ELF, creating permanent on-chain storage burden.

### Finding Description

The Vote contract defines two critical constants for option validation: [1](#0-0) 

However, the `Register` method directly copies input options without any validation: [2](#0-1) 

The `AssertValidNewVotingItem` validation function only checks timestamps and duplicate voting items, but completely ignores option validation: [3](#0-2) 

In contrast, the `AddOption` method properly enforces the option count limit: [4](#0-3) 

And the `AssertOption` helper validates individual option lengths: [5](#0-4) 

The `AddOptions` method also enforces the count limit after adding multiple options: [6](#0-5) 

**Root Cause:** Inconsistent validation enforcement - option limits are checked when modifying existing voting items but are completely bypassed during initial registration.

**Why Protections Fail:** The validation logic exists in `AssertOption` and is used by `AddOption`/`AddOptions`, but the `Register` method never calls these validation functions on `input.Options` before storing them.

### Impact Explanation

**Harm:** An attacker can create voting items with 64 options of 1024 bytes each, storing 64KB per voting item permanently on-chain. This data is stored in the contract state and must be maintained by all full nodes.

**Quantified Damage:** 
- Storage per attack: 64KB per voting item
- Attack cost: 10 ELF per voting item (as defined in the method fee) [7](#0-6) 

- Scale: With 1,000 ELF, an attacker could create approximately 100 voting items = 6.4 MB of bloat
- No cleanup mechanism exists - voting items persist indefinitely

**Who is Affected:** All full nodes must store and serve this bloated state, degrading network performance and increasing storage requirements. This affects the entire blockchain's scalability and operational costs.

**Severity Justification:** HIGH - Low-cost attack (10 ELF per 64KB) with permanent impact on blockchain state and no recovery mechanism. The attack can be repeated indefinitely to compound the damage.

### Likelihood Explanation

**Attacker Capabilities:** Any user with 10 ELF can execute this attack. No special privileges or governance approval required.

**Attack Complexity:** Trivial - construct a `VotingRegisterInput` with 64 strings of 1024 bytes each and call the public `Register` method.

**Feasibility Conditions:**
- Attacker needs sufficient balance to cover 10 ELF transaction fee
- Accepted currency must be in the token whitelist (standard tokens like ELF qualify)
- No other preconditions required

**Detection Constraints:** The attack is indistinguishable from legitimate voting item creation. Each transaction appears valid with proper fee payment.

**Probability:** HIGH - The attack is economically rational if the attacker's goal is to degrade network performance or increase operational costs for node operators. The per-byte cost (10 ELF / 64KB â‰ˆ 0.00015 ELF per byte) is extremely cheap for permanent on-chain storage.

### Recommendation

**Code-level Mitigation:**

Add option validation in the `Register` method immediately after `AssertValidNewVotingItem`:

```csharp
public override Empty Register(VotingRegisterInput input)
{
    var votingItemId = AssertValidNewVotingItem(input);
    
    // Validate options count and length
    Assert(input.Options.Count <= VoteContractConstants.MaximumOptionsCount,
        $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
    
    foreach (var option in input.Options)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
    }
    
    // ... rest of the method
}
```

**Invariant Checks:**
1. `input.Options.Count <= MaximumOptionsCount` before creating voting item
2. All options must satisfy `option.Length <= OptionLengthLimit`
3. Consider checking for duplicate options in input array

**Test Cases:**
1. Test registering with 65 options - should fail
2. Test registering with 64 options of 1025 bytes each - should fail  
3. Test registering with 64 options of 1024 bytes each - should succeed
4. Test registering with duplicate options - should fail (optional enhancement)

### Proof of Concept

**Required Initial State:**
- Attacker address with at least 10 ELF balance
- Token (e.g., "ELF") in the Vote contract's whitelist

**Transaction Steps:**
1. Construct malicious input:
```
VotingRegisterInput {
    StartTimestamp = CurrentTime,
    EndTimestamp = CurrentTime + 30 days,
    AcceptedCurrency = "ELF",
    IsLockToken = true,
    TotalSnapshotNumber = 1,
    Options = [64 strings of 1024 bytes each]  // 64KB total
}
```

2. Call `VoteContract.Register(input)`

3. Transaction succeeds with 10 ELF fee deduction

4. Query `GetVotingItem` to verify the voting item was created with all 64 large options stored on-chain

**Expected vs Actual:**
- Expected: Transaction should fail with "The count of options can't greater than 64" or "Invalid input" for oversized options
- Actual: Transaction succeeds, storing 64KB of attacker-controlled data permanently on-chain

**Success Condition:** The returned `VotingItem` contains all 64 options of 1024 bytes each, confirming 64KB was stored for only 10 ELF.

### Citations

**File:** contract/AElf.Contracts.Vote/VoteContractConstants.cs (L5-6)
```csharp
    public const int MaximumOptionsCount = 64;
    public const int OptionLengthLimit = 1024;
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L20-49)
```csharp
    public override Empty Register(VotingRegisterInput input)
    {
        var votingItemId = AssertValidNewVotingItem(input);

        if (State.TokenContract.Value == null)
            State.TokenContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.TokenContractSystemName);

        // Accepted currency is in white list means this token symbol supports voting.
        var isInWhiteList = State.TokenContract.IsInWhiteList.Call(new IsInWhiteListInput
        {
            Symbol = input.AcceptedCurrency,
            Address = Context.Self
        }).Value;
        Assert(isInWhiteList, "Claimed accepted token is not available for voting.");

        // Initialize voting event.
        var votingItem = new VotingItem
        {
            Sponsor = Context.Sender,
            VotingItemId = votingItemId,
            AcceptedCurrency = input.AcceptedCurrency,
            IsLockToken = input.IsLockToken,
            TotalSnapshotNumber = input.TotalSnapshotNumber,
            CurrentSnapshotNumber = 1,
            CurrentSnapshotStartTimestamp = input.StartTimestamp,
            StartTimestamp = input.StartTimestamp,
            EndTimestamp = input.EndTimestamp,
            RegisterTimestamp = Context.CurrentBlockTime,
            Options = { input.Options },
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L280-289)
```csharp
    public override Empty AddOption(AddOptionInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        AssertOption(votingItem, input.Option);
        Assert(votingItem.Options.Count < VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        votingItem.Options.Add(input.Option);
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L292-296)
```csharp
    private void AssertOption(VotingItem votingItem, string option)
    {
        Assert(option.Length <= VoteContractConstants.OptionLengthLimit, "Invalid input.");
        Assert(!votingItem.Options.Contains(option), "Option already exists.");
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L314-323)
```csharp
    public override Empty AddOptions(AddOptionsInput input)
    {
        var votingItem = AssertVotingItem(input.VotingItemId);
        Assert(votingItem.Sponsor == Context.Sender, "Only sponsor can update options.");
        foreach (var option in input.Options) AssertOption(votingItem, option);
        votingItem.Options.AddRange(input.Options);
        Assert(votingItem.Options.Count <= VoteContractConstants.MaximumOptionsCount,
            $"The count of options can't greater than {VoteContractConstants.MaximumOptionsCount}");
        State.VotingItems[votingItem.VotingItemId] = votingItem;
        return new Empty();
```

**File:** contract/AElf.Contracts.Vote/VoteContract.cs (L351-366)
```csharp
    private Hash AssertValidNewVotingItem(VotingRegisterInput input)
    {
        // Use input without options and sender's address to calculate voting item id.
        var votingItemId = input.GetHash(Context.Sender);

        Assert(State.VotingItems[votingItemId] == null, "Voting item already exists.");

        // total snapshot number can't be 0. At least one epoch is required.
        if (input.TotalSnapshotNumber == 0) input.TotalSnapshotNumber = 1;

        Assert(input.EndTimestamp > input.StartTimestamp, "Invalid active time.");

        Context.LogDebug(() => $"Voting item created by {Context.Sender}: {votingItemId.ToHex()}");

        return votingItemId;
    }
```

**File:** contract/AElf.Contracts.Vote/VoteContract_ACS1_TransactionFeeProvider.cs (L40-49)
```csharp
        switch (input.Value)
        {
            case nameof(Register):
                return new MethodFees
                {
                    Fees =
                    {
                        new MethodFee { Symbol = Context.Variables.NativeSymbol, BasicFee = 10_00000000 }
                    }
                };
```
