### Title
Original SEED Creator Can Sabotage Transferred SEEDs by Setting Expiration to Past

### Summary
The `ExtendSeedExpirationTime()` function authorizes callers based on `tokenInfo.Owner`, which is never updated when SEED NFTs are transferred. This allows the original creator of a SEED to set its expiration time to the past even after selling or transferring it, rendering the SEED unusable for the new owner and causing direct financial loss.

### Finding Description
The vulnerability exists in the authorization logic of `ExtendSeedExpirationTime()`: [1](#0-0) 

The function checks `tokenInfo.Owner == Context.Sender` for authorization, but `tokenInfo.Owner` represents the token-level owner metadata, not the current balance holder. When SEED NFTs are transferred via the `Transfer()` function: [2](#0-1) 

Only balances are modified - the `tokenInfo.Owner` field remains unchanged. This creates a critical disconnect where:
1. Balance ownership transfers to the new holder
2. But `tokenInfo.Owner` remains with the original creator
3. The original creator retains the ability to modify expiration time

When a SEED's expiration is checked during token creation: [3](#0-2) 

The validation at line 130 checks `Context.CurrentBlockTime.Seconds <= expirationTimeLong`. If the expiration is set to the past, this check fails and the SEED becomes unusable.

The function imposes no validation that `input.ExpirationTime` is:
- Greater than the current block time
- Greater than the existing expiration time
- A reasonable future timestamp

### Impact Explanation
**Direct Fund Impact**: Buyers of SEED NFTs on secondary markets lose the full value of their purchase. SEED NFTs grant exclusive rights to create specific token symbols and are valuable assets. Setting expiration to the past (e.g., timestamp 1) permanently destroys the SEED's utility.

**Who is Affected**: Any user who acquires a SEED NFT through transfer, purchase, or trade from its original creator. This includes marketplace transactions, OTC trades, and any legitimate SEED NFT transfers.

**Severity Justification**: HIGH - This enables theft-equivalent damage where the original creator can destroy the value of assets they no longer possess, with zero cost to execute and no technical barriers. The attack is undetectable until the victim attempts to use the SEED.

### Likelihood Explanation
**Reachable Entry Point**: `ExtendSeedExpirationTime()` is a public method accessible to any address that was the original creator of a SEED NFT.

**Attacker Capabilities**: The attacker must have originally created a SEED NFT (or been set as its `tokenInfo.Owner`), then transferred it to another party. This is a common scenario in NFT marketplaces and secondary sales.

**Attack Complexity**: Trivial - single transaction calling `ExtendSeedExpirationTime()` with `ExpirationTime = 1` (or any past timestamp).

**Economic Rationality**: 
- **Griefing attacks**: Malicious sellers can sabotage buyers post-sale
- **Marketplace manipulation**: Devalue competitor SEEDs or manipulate secondary market prices
- **Front-running**: Seller lists SEED, sees incoming purchase, front-runs with expiration modification
- **Exit scams**: Large-scale SEED creator dumps inventory then destroys all sold SEEDs

**Detection Constraints**: Attack is invisible until victim attempts to use the SEED. No on-chain warnings or protections exist.

### Recommendation
**Authorization Fix**: The authorization check should verify the caller has balance of the SEED, not that they are the original `tokenInfo.Owner`:

```csharp
public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
{
    var tokenInfo = GetTokenInfo(input.Symbol);
    if (tokenInfo == null)
    {
        throw new AssertionException("Seed NFT does not exist.");
    }
    
    // FIX: Check balance ownership, not tokenInfo.Owner
    Assert(State.Balances[Context.Sender][input.Symbol] > 0, 
        "Sender must own the Seed NFT.");
    
    var oldExpireTimeLong = 0L;
    if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
            out var oldExpireTime))
    {
        long.TryParse(oldExpireTime, out oldExpireTimeLong);
    }
    
    // ADD: Validate new expiration is in the future
    Assert(input.ExpirationTime > Context.CurrentBlockTime.Seconds,
        "New expiration time must be in the future.");
    
    // ADD: Validate new expiration extends (doesn't reduce) the time
    Assert(input.ExpirationTime > oldExpireTimeLong,
        "New expiration time must be greater than current expiration.");
    
    tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
        input.ExpirationTime.ToString();
    State.TokenInfos[input.Symbol] = tokenInfo;
    Context.Fire(new SeedExpirationTimeUpdated
    {
        ChainId = tokenInfo.IssueChainId,
        Symbol = input.Symbol,
        OldExpirationTime = oldExpireTimeLong,
        NewExpirationTime = input.ExpirationTime
    });
    return new Empty();
}
```

**Test Cases**:
1. Original creator transfers SEED to new owner, attempts to call `ExtendSeedExpirationTime` → should FAIL
2. New owner calls `ExtendSeedExpirationTime` with future timestamp → should SUCCEED
3. Owner attempts to set expiration to past timestamp → should FAIL
4. Owner attempts to reduce expiration time → should FAIL

### Proof of Concept
**Initial State**:
- Alice creates SEED-1 with expiration time 2000000000 (year 2033)
- `tokenInfo.Owner["SEED-1"] = Alice`
- `State.Balances[Alice]["SEED-1"] = 1`

**Attack Steps**:
1. **Alice transfers SEED-1 to Bob**:
   - Call `Transfer({To: Bob, Symbol: "SEED-1", Amount: 1})`
   - Result: `State.Balances[Alice]["SEED-1"] = 0`, `State.Balances[Bob]["SEED-1"] = 1`
   - **BUT**: `tokenInfo.Owner["SEED-1"]` still equals Alice

2. **Alice sabotages the SEED**:
   - Call `ExtendSeedExpirationTime({Symbol: "SEED-1", ExpirationTime: 1})`
   - Authorization check passes: `tokenInfo.Owner["SEED-1"] == Alice ✓`
   - SEED expiration updated to timestamp 1 (year 1970)

3. **Bob attempts to use SEED-1**:
   - Call `Create({Symbol: "MYTOKEN", ...})` (attempting to use SEED-1)
   - `CheckSeedNFT()` executes at line 130
   - Assertion fails: `Context.CurrentBlockTime.Seconds <= 1` is FALSE
   - Transaction reverts with "OwnedSymbol is expired"

**Expected Result**: Bob should be able to extend or use his SEED.

**Actual Result**: Alice retains control over expiration despite no longer owning the SEED. Bob's SEED is permanently bricked with no recourse.

**Success Condition**: Alice successfully destroys the value of a SEED NFT she no longer possesses, causing direct financial loss to Bob.

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L118-131)
```csharp
    private void CheckSeedNFT(string symbolSeed, String symbol)
    {
        Assert(!string.IsNullOrEmpty(symbolSeed), "Seed NFT does not exist.");
        var tokenInfo = GetTokenInfo(symbolSeed);
        Assert(tokenInfo != null, "Seed NFT does not exist.");
        Assert(State.Balances[Context.Sender][symbolSeed] > 0, "Seed NFT balance is not enough.");
        Assert(tokenInfo.ExternalInfo != null && tokenInfo.ExternalInfo.Value.TryGetValue(
                TokenContractConstants.SeedOwnedSymbolExternalInfoKey, out var ownedSymbol) && ownedSymbol == symbol,
            "Invalid OwnedSymbol.");
        Assert(tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                   out var expirationTime)
               && long.TryParse(expirationTime, out var expirationTimeLong) &&
               Context.CurrentBlockTime.Seconds <= expirationTimeLong, "OwnedSymbol is expired.");
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Actions.cs (L695-722)
```csharp
    public override Empty ExtendSeedExpirationTime(ExtendSeedExpirationTimeInput input)
    {
        var tokenInfo = GetTokenInfo(input.Symbol);
        if (tokenInfo == null)
        {
            throw new AssertionException("Seed NFT does not exist.");
        }

        Assert(tokenInfo.Owner == Context.Sender, "Sender is not Seed NFT owner.");
        var oldExpireTimeLong = 0L;
        if (tokenInfo.ExternalInfo.Value.TryGetValue(TokenContractConstants.SeedExpireTimeExternalInfoKey,
                out var oldExpireTime))
        {
            long.TryParse(oldExpireTime, out oldExpireTimeLong);
        }

        tokenInfo.ExternalInfo.Value[TokenContractConstants.SeedExpireTimeExternalInfoKey] =
            input.ExpirationTime.ToString();
        State.TokenInfos[input.Symbol] = tokenInfo;
        Context.Fire(new SeedExpirationTimeUpdated
        {
            ChainId = tokenInfo.IssueChainId,
            Symbol = input.Symbol,
            OldExpirationTime = oldExpireTimeLong,
            NewExpirationTime = input.ExpirationTime
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_Helper.cs (L99-114)
```csharp
    private void DoTransfer(Address from, Address to, string symbol, long amount, string memo = null)
    {
        Assert(!IsInTransferBlackListInternal(from), "From address is in transfer blacklist.");
        Assert(from != to, "Can't do transfer to sender itself.");
        AssertValidMemo(memo);
        ModifyBalance(from, symbol, -amount);
        ModifyBalance(to, symbol, amount);
        Context.Fire(new Transferred
        {
            From = from,
            To = to,
            Symbol = symbol,
            Amount = amount,
            Memo = memo ?? string.Empty
        });
    }
```
