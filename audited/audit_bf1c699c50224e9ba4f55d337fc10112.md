### Title
Permanent Governance Lock via Dysfunctional Parliament Organization Without Validation in RequiredMethodFeeControllerSet

### Summary
The `RequiredMethodFeeControllerSet` function in TokenHolder (and other ACS1 contracts) blindly trusts the address returned by Parliament's `GetDefaultOrganizationAddress` without validating that the organization exists or has reachable voting parameters. Parliament's default organization can be modified via `ChangeOrganizationThreshold` to have impossible-to-reach thresholds (100% approval, 0% rejection/abstention) that pass validation but render the organization dysfunctional. This permanently locks all contracts using this organization as their MethodFeeController, with no recovery mechanism.

### Finding Description

The vulnerability exists in the initial setup of the MethodFeeController across multiple system contracts. In TokenHolder's `RequiredMethodFeeControllerSet`, the function retrieves Parliament's default organization address and sets it as the controller without any validation: [1](#0-0) 

The function calls `State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())` and immediately trusts the returned address, creating an `AuthorityInfo` without checking:
1. Whether the organization actually exists in `State.Organizations`
2. Whether the organization has functional/reachable voting parameters

In contrast, the `ChangeMethodFeeController` function DOES perform an existence check: [2](#0-1) 

However, this only checks existence via `CheckOrganizationExist`, not functionality: [3](#0-2) 

Parliament's `ValidateOrganizationExist` only verifies the organization exists in storage: [4](#0-3) 

**Root Cause - Modifiable Organization Thresholds:**

Parliament's default organization can modify its own thresholds through the `ChangeOrganizationThreshold` function: [5](#0-4) 

The validation function allows extreme threshold values: [6](#0-5) 

With `AbstractVoteTotal = 10000` (representing 100%): [7](#0-6) 

The validation permits thresholds of:
- `MinimalApprovalThreshold = 10000` (100% approval required)
- `MinimalVoteThreshold = 10000` (100% participation required)
- `MaximalAbstentionThreshold = 0` (no abstentions allowed)
- `MaximalRejectionThreshold = 0` (no rejections allowed)

This is proven functional in tests: [8](#0-7) 

**Exploitation Path:**

1. Parliament's default organization is initialized with reasonable thresholds (66.67% approval): [9](#0-8) 

2. Miners create a proposal to call `ChangeOrganizationThreshold` on the default organization with impossible thresholds (100% approval, 0% rejection/abstention)

3. The proposal is approved under the CURRENT (reachable) thresholds and released via: [10](#0-9) 

4. The organization now has dysfunctional thresholds that pass validation but cannot reach consensus if any miner is offline or disagrees

5. TokenHolder and other contracts now have a permanently locked controller because `ChangeMethodFeeController` requires approval from the current controller: [11](#0-10) 

The sender must BE the organization address (via virtual inline call), making recovery impossible.

**Affected Contracts:**

This pattern affects ALL ACS1 implementations including TokenHolder, Treasury, Association, Referendum, Election, Consensus, CrossChain, Profit, Configuration, and TokenConverter - all use the same vulnerable pattern: [12](#0-11) [13](#0-12) 

### Impact Explanation

**Concrete Harm:**
- All system contracts using Parliament's default organization as MethodFeeController become permanently unable to:
  - Update method fees via `SetMethodFee`
  - Change the controller via `ChangeMethodFeeController`
- This creates a permanent DoS on critical governance functions across TokenHolder, Treasury, Association, Referendum, Election, Consensus, CrossChain, Profit, Configuration, and TokenConverter contracts

**Affected Parties:**
- Chain operators cannot adjust transaction fees
- Protocol cannot adapt to economic conditions
- Users face fixed fees regardless of market conditions
- Entire governance layer becomes ossified

**Severity Justification:**
HIGH severity because:
1. **Operational Impact**: Complete governance lock on fee management across all major system contracts
2. **Permanence**: No recovery mechanism exists once triggered
3. **Scope**: Affects 10+ critical system contracts simultaneously
4. **Chain Viability**: Inability to adjust fees threatens long-term chain economics and adaptability

### Likelihood Explanation

**Attacker Capabilities Required:**
- Control of >66.67% of current miners (to approve the threshold change proposal under current thresholds)
- Ability to create and release proposals in Parliament

**Attack Complexity:**
- LOW - requires only creating one proposal with extreme threshold values
- No sophisticated exploit or timing requirements
- Standard governance workflow

**Feasibility Conditions:**
- Requires miner consensus (>66.67%) to approve the self-destructive threshold change
- Could occur through:
  1. **Malicious Intent**: Byzantine adversary controlling >66.67% of miners
  2. **Governance Mistake**: Well-intentioned proposal to "increase security" that miners don't fully understand
  3. **Social Engineering**: Convincing miners that extreme thresholds are necessary

**Probability Assessment:**
MODERATE likelihood because:
- Byzantine scenario (>66.67% malicious miners) is theoretically possible
- Governance mistakes are common in blockchain systems when changes appear to enhance security
- Once any contract calls `RequiredMethodFeeControllerSet`, it becomes vulnerable to future threshold changes
- No warning or safety mechanism exists to prevent extreme thresholds

**Economic Rationality:**
- For malicious actors: Permanently disrupting governance is rational for competitors or adversaries
- For mistaken governance: Perceived as "improving security" by requiring unanimous consensus
- Cost is only the transaction fees for creating/approving one proposal

### Recommendation

**Immediate Mitigations:**

1. **Add Organization Functionality Validation** in `RequiredMethodFeeControllerSet`:
```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value =
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

    var defaultOrgAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
    
    // NEW: Validate organization exists
    var organizationExists = Context.Call<BoolValue>(
        State.ParliamentContract.Value,
        nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
        defaultOrgAddress).Value;
    Assert(organizationExists, "Default organization does not exist.");
    
    // NEW: Validate organization has reasonable thresholds
    var organization = Context.Call<Organization>(
        State.ParliamentContract.Value,
        "GetOrganization",
        defaultOrgAddress);
    ValidateOrganizationThresholds(organization);

    var defaultAuthority = new AuthorityInfo
    {
        OwnerAddress = defaultOrgAddress,
        ContractAddress = State.ParliamentContract.Value
    };

    State.MethodFeeController.Value = defaultAuthority;
}

private void ValidateOrganizationThresholds(Organization org)
{
    var threshold = org.ProposalReleaseThreshold;
    // Ensure thresholds are reachable (e.g., not 100%)
    Assert(threshold.MinimalApprovalThreshold < 10000, "Unreachable approval threshold.");
    Assert(threshold.MinimalVoteThreshold < 10000, "Unreachable vote threshold.");
    // Ensure some margin for disagreement/offline nodes
    Assert(threshold.MinimalApprovalThreshold <= 9000, "Approval threshold too high for resilience.");
}
```

2. **Add Threshold Bounds Check** in Parliament's `ChangeOrganizationThreshold`:
```csharp
public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
{
    var organization = State.Organizations[Context.Sender];
    Assert(organization != null, "Organization not found.");
    organization.ProposalReleaseThreshold = input;
    
    // NEW: Enforce maximum threshold bounds for resilience
    Assert(input.MinimalApprovalThreshold <= 9000, "Approval threshold cannot exceed 90%.");
    Assert(input.MinimalVoteThreshold <= 9500, "Vote threshold cannot exceed 95%.");
    
    Assert(Validate(organization), "Invalid organization.");
    State.Organizations[Context.Sender] = organization;
    Context.Fire(new OrganizationThresholdChanged
    {
        OrganizationAddress = Context.Sender,
        ProposerReleaseThreshold = input
    });
    return new Empty();
}
```

3. **Add Emergency Recovery Mechanism**:
Implement a time-locked emergency override that allows contract deployment controller (Genesis contract) to reset a dysfunctional MethodFeeController after a grace period (e.g., 30 days) with community notification.

**Test Cases:**
1. Test that `RequiredMethodFeeControllerSet` reverts if organization doesn't exist
2. Test that `RequiredMethodFeeControllerSet` reverts if organization has extreme thresholds (>90%)
3. Test that `ChangeOrganizationThreshold` reverts when attempting to set thresholds â‰¥90%
4. Test recovery mechanism can reset controller after grace period
5. Test that existing tests with reasonable thresholds still pass

### Proof of Concept

**Initial State:**
- Parliament contract initialized with default organization (66.67% approval threshold)
- TokenHolder contract deployed, calls `RequiredMethodFeeControllerSet` on first fee-related operation
- MethodFeeController set to Parliament's default organization address (no validation)

**Attack Steps:**

1. **Create Malicious Proposal** (as a miner):
```
CreateProposal(
    OrganizationAddress: <Parliament Default Org>,
    ToAddress: <Parliament Contract>,
    ContractMethodName: "ChangeOrganizationThreshold",
    Params: {
        MinimalApprovalThreshold: 10000,
        MinimalVoteThreshold: 10000,
        MaximalAbstentionThreshold: 0,
        MaximalRejectionThreshold: 0
    }
)
```

2. **Approve Proposal** (67% of miners):
    - Under CURRENT thresholds (66.67%), proposal can be approved
    - Miners may approve thinking it "enhances security"

3. **Release Proposal** (proposer):
```
Parliament.Release(<ProposalId>)
```
    - Executes `ChangeOrganizationThreshold` via virtual inline call
    - Default organization now has impossible thresholds

4. **Attempt Fee Change** (any authorized party):
```
CreateProposal(
    OrganizationAddress: <Parliament Default Org (now dysfunctional)>,
    ToAddress: <TokenHolder Contract>,
    ContractMethodName: "SetMethodFee",
    Params: { ... }
)
```
    - Even with 99% miner approval, proposal CANNOT reach 100% threshold
    - If ANY miner is offline/disagrees, proposal permanently blocked

5. **Attempt Controller Change** (to recover):
```
TokenHolder.ChangeMethodFeeController(newController)
```
    - **FAILS**: Requires approval from dysfunctional organization
    - Sender must be organization address (line 24), but organization cannot approve anything
    - **PERMANENT DEADLOCK**

**Expected vs Actual Result:**
- Expected: Organization thresholds should have upper bounds (e.g., 90%) to ensure resilience
- Expected: Initial controller setup should validate organization functionality
- Actual: Extreme thresholds (100%) pass validation and permanently lock governance
- Actual: No validation in `RequiredMethodFeeControllerSet` allows trusting dysfunctional organizations

**Success Condition:**
Attack succeeds when:
1. `ChangeOrganizationThreshold` transaction mines successfully with extreme values
2. `SetMethodFee` proposals fail to reach threshold despite high approval
3. `ChangeMethodFeeController` transactions revert due to insufficient authority
4. No recovery mechanism exists to restore functionality

### Notes

**Additional Context:**

1. **Systemic Pattern**: This vulnerability affects ALL ACS1 implementations in the codebase (10+ contracts), making it a systemic design flaw rather than isolated bug.

2. **Time-of-Check-to-Time-of-Use (TOCTOU)**: Even if `RequiredMethodFeeControllerSet` validated at initialization, the organization could become dysfunctional later via `ChangeOrganizationThreshold`. A periodic health check or threshold change notification mechanism would be beneficial.

3. **Governance Philosophy**: The current design allows organizations to have 100% consensus requirements, which may be intentional for certain high-stakes decisions. However, using such organizations as MethodFeeControllers creates operational risk.

4. **Real-World Precedent**: Similar governance lock scenarios have occurred in blockchain systems (e.g., organizations setting impossible quorums, multi-sigs losing signers). The lack of emergency recovery mechanisms makes this particularly severe.

5. **Defense in Depth**: Multiple mitigations should be implemented:
   - Validation at initialization (prevents using already-dysfunctional orgs)
   - Bounds on threshold changes (prevents creating dysfunctional orgs)
   - Emergency recovery mechanism (recovers from dysfunctional orgs)

### Citations

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L21-31)
```csharp

    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        RequiredMethodFeeControllerSet();
        AssertSenderAddressWith(State.MethodFeeController.Value.OwnerAddress);
        var organizationExist = CheckOrganizationExist(input);
        Assert(organizationExist, "Invalid authority input.");

        State.MethodFeeController.Value = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.TokenHolder/TokenHolderContract_ACS1_TransactionFeeProvider.cs (L71-76)
```csharp
    private bool CheckOrganizationExist(AuthorityInfo authorityInfo)
    {
        return Context.Call<BoolValue>(authorityInfo.ContractAddress,
            nameof(AuthorizationContractContainer.AuthorizationContractReferenceState.ValidateOrganizationExist),
            authorityInfo.OwnerAddress).Value;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L11-36)
```csharp
    public override Empty Initialize(InitializeInput input)
    {
        Assert(!State.Initialized.Value, "Already initialized.");
        State.Initialized.Value = true;

        var proposerWhiteList = new ProposerWhiteList();

        if (input.PrivilegedProposer != null)
            proposerWhiteList.Proposers.Add(input.PrivilegedProposer);

        State.ProposerWhiteList.Value = proposerWhiteList;
        var organizationInput = new CreateOrganizationInput
        {
            ProposalReleaseThreshold = new ProposalReleaseThreshold
            {
                MinimalApprovalThreshold = DefaultOrganizationMinimalApprovalThreshold,
                MinimalVoteThreshold = DefaultOrganizationMinimalVoteThresholdThreshold,
                MaximalAbstentionThreshold = DefaultOrganizationMaximalAbstentionThreshold,
                MaximalRejectionThreshold = DefaultOrganizationMaximalRejectionThreshold
            },
            ProposerAuthorityRequired = input.ProposerAuthorityRequired,
            ParliamentMemberProposingAllowed = true
        };
        var defaultOrganizationAddress = CreateNewOrganization(organizationInput);
        State.DefaultOrganizationAddress.Value = defaultOrganizationAddress;
        return new Empty();
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L132-145)
```csharp
    public override Empty Release(Hash proposalId)
    {
        var proposalInfo = GetValidProposal(proposalId);
        Assert(Context.Sender.Equals(proposalInfo.Proposer), "No permission.");
        var organization = State.Organizations[proposalInfo.OrganizationAddress];
        Assert(IsReleaseThresholdReached(proposalInfo, organization), "Not approved.");
        Context.SendVirtualInlineBySystemContract(
            CalculateVirtualHash(organization.OrganizationHash, organization.CreationToken), proposalInfo.ToAddress,
            proposalInfo.ContractMethodName, proposalInfo.Params);
        Context.Fire(new ProposalReleased { ProposalId = proposalId });
        State.Proposals.Remove(proposalId);

        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L147-160)
```csharp
    public override Empty ChangeOrganizationThreshold(ProposalReleaseThreshold input)
    {
        var organization = State.Organizations[Context.Sender];
        Assert(organization != null, "Organization not found.");
        organization.ProposalReleaseThreshold = input;
        Assert(Validate(organization), "Invalid organization.");
        State.Organizations[Context.Sender] = organization;
        Context.Fire(new OrganizationThresholdChanged
        {
            OrganizationAddress = Context.Sender,
            ProposerReleaseThreshold = input
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament.cs (L281-284)
```csharp
    public override BoolValue ValidateOrganizationExist(Address input)
    {
        return new BoolValue { Value = State.Organizations[input] != null };
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L142-155)
```csharp
    private bool Validate(Organization organization)
    {
        var proposalReleaseThreshold = organization.ProposalReleaseThreshold;

        return proposalReleaseThreshold.MinimalVoteThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MinimalApprovalThreshold <= proposalReleaseThreshold.MinimalVoteThreshold &&
               proposalReleaseThreshold.MinimalApprovalThreshold > 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalRejectionThreshold >= 0 &&
               proposalReleaseThreshold.MaximalAbstentionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal &&
               proposalReleaseThreshold.MaximalRejectionThreshold +
               proposalReleaseThreshold.MinimalApprovalThreshold <= AbstractVoteTotal;
    }
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Constants.cs (L9-9)
```csharp
    private const int AbstractVoteTotal = 10000;
```

**File:** test/AElf.Contracts.Parliament.Tests/ParliamentContractTest.cs (L189-195)
```csharp
            createOrganizationInput.ProposalReleaseThreshold.MinimalApprovalThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MinimalVoteThreshold = 10000;
            createOrganizationInput.ProposalReleaseThreshold.MaximalAbstentionThreshold = 0;
            createOrganizationInput.ProposalReleaseThreshold.MaximalRejectionThreshold = 0;
            var transactionResult =
                await minerParliamentContractStub.CreateOrganization.SendAsync(createOrganizationInput);
            transactionResult.TransactionResult.Status.ShouldBe(TransactionResultStatus.Mined);
```

**File:** contract/AElf.Contracts.Association/AssociationContract_ACS1_TransactionFeeProvider.cs (L49-63)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** contract/AElf.Contracts.Treasury/TreasuryContract_ACS1_TransactionFeeProvider.cs (L50-64)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo
        {
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty()),
            ContractAddress = State.ParliamentContract.Value
        };

        State.MethodFeeController.Value = defaultAuthority;
    }
```
