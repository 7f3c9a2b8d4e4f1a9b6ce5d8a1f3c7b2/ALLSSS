### Title
Unbounded Response Dataset in GetCandidateVoteWithAllRecords Enables Denial of Service

### Summary
The `GetCandidateVoteWithAllRecords()` function retrieves all active and withdrawn voting records for a candidate without any pagination or size limiting, potentially loading thousands of records in a single call. For popular candidates with extensive voting history, this creates massive response datasets that can exhaust node memory, cause response timeouts, and enable denial of service attacks.

### Finding Description

The vulnerability exists in the `GetCandidateVoteWithAllRecords()` function [1](#0-0)  which performs two unbounded data retrievals:

1. First, it calls `GetCandidateVoteWithRecords()` [2](#0-1)  to load ALL active voting records from `ObtainedActiveVotingRecordIds`

2. Then it loads ALL withdrawn voting records from `ObtainedWithdrawnVotingRecordIds` [3](#0-2) 

The root cause is that withdrawn vote IDs accumulate indefinitely. When votes are withdrawn, the vote ID is moved from the active list to the withdrawn list [4](#0-3)  but is never removed from storage. As candidates receive votes over time [5](#0-4) , these lists grow unbounded.

The underlying Vote contract's `GetVotingRecords()` function [6](#0-5)  has no size restrictions and processes all requested IDs. The protobuf definitions [7](#0-6)  use repeated fields without maximum size constraints.

This contrasts sharply with `GetPageableCandidateInformation()` which enforces a hardcoded limit of 20 records per query [8](#0-7) , demonstrating the developers understood pagination requirements elsewhere but failed to apply them here.

### Impact Explanation

**Operational DOS Impact:**
- Node memory exhaustion when processing queries for popular candidates with thousands of historical votes
- Response timeouts preventing legitimate queries from completing
- Network congestion from transmitting massive response payloads
- Potential node crashes requiring restart and recovery

**Affected Parties:**
- Node operators face service disruption and resource exhaustion
- Users unable to query candidate voting information during attacks
- dApps and explorers dependent on election data experience failures

**Severity Justification (Medium):**
While this is a serious availability issue, it does not directly compromise funds, governance integrity, or consensus. However, it can persistently disrupt critical election information queries and force node operators to implement external rate limiting or filtering.

### Likelihood Explanation

**High Exploitability:**
- The function is a public view method [9](#0-8)  callable by anyone without authentication or payment
- No preconditions required beyond knowing a candidate's public key
- Attack cost is negligible (read-only operation)
- Popular candidates naturally accumulate large vote counts over multiple terms

**Attack Complexity:**
- Trivial - single function call with candidate pubkey parameter
- No need to manipulate contract state beforehand
- Can be automated to repeatedly target multiple popular candidates
- Difficult to distinguish from legitimate queries

**Realistic Scenario:**
In a production AElf network with active elections over months or years, leading candidates could easily accumulate 1,000+ votes with many withdrawn after lock periods expire. A single query for such a candidate would attempt to load and serialize 1,000+ `ElectionVotingRecord` objects [10](#0-9) , each containing multiple fields including timestamps, addresses, and amounts.

### Recommendation

**Implement Pagination:**
Add pagination parameters (start index and page size) to `GetCandidateVoteWithAllRecords()` and `GetElectorVoteWithAllRecords()`, following the pattern used in `GetPageableCandidateInformation()`:

```
// Add to input
int32 start_index = 2;
int32 page_size = 3;

// In implementation
var maxPageSize = 20;
var pageSize = Math.Min(input.PageSize, maxPageSize);
```

**Add Response Size Limits:**
Cap the maximum number of records returned per query at 20-50 records and require callers to make multiple paginated requests for larger datasets.

**Consider Record Archival:**
Implement a mechanism to archive or prune very old withdrawn voting records (e.g., after N terms) to prevent unbounded storage growth.

**Add Test Coverage:**
Create test cases that verify pagination behavior with 100+ voting records to ensure the fix prevents excessive response sizes.

### Proof of Concept

**Initial State:**
- Popular candidate "CandidateA" has been elected for 10 terms
- Over this period, 2,000 users voted for CandidateA  
- 1,500 of those votes have been withdrawn after lock periods expired
- CandidateA's `ObtainedActiveVotingRecordIds` contains 500 vote IDs
- CandidateA's `ObtainedWithdrawnVotingRecordIds` contains 1,500 vote IDs

**Attack Steps:**
1. Attacker calls `GetCandidateVoteWithAllRecords(CandidateA_pubkey)`
2. Function retrieves all 500 active records via `GetVotingRecords()`
3. Function retrieves all 1,500 withdrawn records via `GetVotingRecords()`
4. System attempts to construct response with 2,000 `ElectionVotingRecord` objects
5. Response payload size: ~400KB-1MB depending on field sizes

**Expected vs Actual:**
- Expected: Query should be limited to reasonable page size (e.g., 20 records)
- Actual: Query returns all 2,000 records without limit, causing memory spike and potential timeout

**Success Condition:**
Attacker can repeatedly call this function, forcing nodes to process megabytes of data per query, degrading service availability for all users querying election data.

### Citations

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L248-248)
```csharp
        var length = Math.Min(Math.Min(input.Length, 20), candidates.Value.Count.Sub(input.Start));
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L268-286)
```csharp
    public override CandidateVote GetCandidateVoteWithRecords(StringValue input)
    {
        var votes = State.CandidateVotes[input.Value];
        if (votes == null)
            return new CandidateVote();

        var obtainedRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedActiveVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedRecords)
        {
            var voteId = votes.ObtainedActiveVotingRecordIds[index++];
            votes.ObtainedActiveVotingRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L288-305)
```csharp
    public override CandidateVote GetCandidateVoteWithAllRecords(StringValue input)
    {
        var votes = GetCandidateVoteWithRecords(input);

        //get withdrawn records
        var obtainedWithdrawnRecords = State.VoteContract.GetVotingRecords.Call(new GetVotingRecordsInput
        {
            Ids = { votes.ObtainedWithdrawnVotingRecordIds }
        }).Records;
        var index = 0;
        foreach (var record in obtainedWithdrawnRecords)
        {
            var voteId = votes.ObtainedWithdrawnVotingRecordIds[index++];
            votes.ObtainedWithdrawnVotesRecords.Add(TransferVotingRecordToElectionVotingRecord(record, voteId));
        }

        return votes;
    }
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L554-561)
```csharp
                ObtainedActiveVotingRecordIds = { voteId },
                ObtainedActiveVotedVotesAmount = amount,
                AllObtainedVotedVotesAmount = amount
            };
        }
        else
        {
            candidateVotes.ObtainedActiveVotingRecordIds.Add(voteId);
```

**File:** contract/AElf.Contracts.Election/ElectionContract_Elector.cs (L656-657)
```csharp
        candidateVotes.ObtainedActiveVotingRecordIds.Remove(input);
        candidateVotes.ObtainedWithdrawnVotingRecordIds.Add(input);
```

**File:** contract/AElf.Contracts.Vote/ViewMethods.cs (L8-13)
```csharp
    public override VotingRecords GetVotingRecords(GetVotingRecordsInput input)
    {
        var votingRecords = new VotingRecords();
        votingRecords.Records.AddRange(input.Ids.Select(id => State.VotingRecords[id]));
        return votingRecords;
    }
```

**File:** protobuf/vote_contract.proto (L259-262)
```text
message GetVotingRecordsInput {
    // The vote ids.
    repeated aelf.Hash ids = 1;
}
```

**File:** protobuf/election_contract.proto (L167-171)
```text
    // Get voting information for candidate according to the public key of the candidate 
    // (including the active and withdrawn voting records).
    rpc GetCandidateVoteWithAllRecords (google.protobuf.StringValue) returns (CandidateVote) {
        option (aelf.is_view) = true;
    }
```

**File:** protobuf/election_contract.proto (L389-414)
```text
message ElectionVotingRecord {
    // The address of voter.
    aelf.Address voter = 1;
    // The public key of candidate.
    string candidate = 2;
    // Amount of voting.
    int64 amount = 3;
    // The term number of voting.
    int64 term_number = 4;
    // The vote id.
    aelf.Hash vote_id = 5;
    // Vote lock time.
    int64 lock_time = 6;
    // The unlock timestamp.
    google.protobuf.Timestamp unlock_timestamp = 7;
    // The withdraw timestamp.
    google.protobuf.Timestamp withdraw_timestamp = 8;
    // The vote timestamp.
    google.protobuf.Timestamp vote_timestamp = 9;
    // Indicates if the vote has been withdrawn.
    bool is_withdrawn = 10;
    // Vote weight for sharing bonus.
    int64 weight = 11;
    // Whether vote others.
    bool is_change_target = 12;
}
```
