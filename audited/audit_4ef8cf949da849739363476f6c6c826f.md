### Title
Consensus Fork Vulnerability Due to Unvalidated NextRound vs NextTerm Decision

### Summary
The `GetConsensusBehaviourToTerminateCurrentRound()` method allows miners to independently decide between `NextRound` and `NextTerm` behaviors based on their view of blockchain state, but the validation logic does not verify the correctness of this decision. When miners have divergent views of state (due to network partitions, forks, or timing differences), they can make incompatible decisions that both pass validation, creating permanent consensus forks.

### Finding Description

**Root Cause Location:** [1](#0-0) 

The decision logic calls `NeedToChangeTerm()` to determine whether to return `NextRound` or `NextTerm`: [2](#0-1) 

This decision depends on counting how many miners have `ActualMiningTimes` that indicate a term change is needed (threshold is 2/3 of miners): [3](#0-2) 

**Critical Validation Gap:**
The validation logic in `RoundTerminateValidationProvider` only checks structural correctness (round/term number increments) but does NOT re-evaluate whether the term change decision was correct: [4](#0-3) 

For `NextRound`: validates only that `RoundNumber` increments by 1 (lines 29-34)
For `NextTerm`: validates only that both `RoundNumber` and `TermNumber` increment by 1 (lines 40-46)

**Why Protections Fail:**
1. There is no validation that calls `NeedToChangeTerm()` during block validation to verify the decision was objectively correct
2. Both `NextRound` (TermNumber unchanged) and `NextTerm` (TermNumber+1) blocks can pass validation when evaluated against the same base state
3. No validation enforces that only the designated extra block producer can submit termination transactions
4. The method `NeedToChangeTerm` appears ONLY in the decision logic, not in any validation code

**Execution Path:** [5](#0-4) 

Miners call `GetConsensusCommand()` → creates behavior provider (lines 39-46) → calls `GetConsensusBehaviour()`: [6](#0-5) 

Which then generates either `NextRound` or `NextTerm` transactions: [7](#0-6) 

### Impact Explanation

**Consensus Fork Creation:**
When miners make divergent NextRound vs NextTerm decisions, two incompatible chain branches are created:
- Branch A: Round N+1, Term T (NextRound)
- Branch B: Round N+1, Term T+1 (NextTerm)

These branches have different term numbers and cannot reconcile. Each branch considers itself valid, permanently splitting the network.

**Affected Parties:**
- All network participants experience consensus failure
- Transaction finality becomes uncertain across the split
- Economic activities (token transfers, staking, governance) diverge between branches
- Cross-chain operations fail due to inconsistent state

**Severity Justification:**
CRITICAL - Consensus forks violate the fundamental blockchain invariant of single canonical chain state. The network cannot automatically recover because both forks pass all validation checks. This requires manual intervention (social consensus) to resolve, potentially affecting all chain participants and assets.

### Likelihood Explanation

**Attack Preconditions:**
1. Network partition or fork exists where miners see different chain states
2. The divergent states have different counts of miners meeting the `IsTimeToChangeTerm` criterion
3. Multiple miners attempt to terminate the round simultaneously (Byzantine behavior or timing issues)

**Attack Complexity:**
MEDIUM - The vulnerability can be triggered by:
- Natural network partitions (temporary connectivity loss between miner groups)
- Blockchain reorganizations where different miners build on different fork tips
- Byzantine miners deliberately producing competing termination blocks
- Race conditions during round boundary times when state is rapidly changing

**Execution Practicality:**
HIGH - Once miners have divergent state views:
1. Each miner independently evaluates `NeedToChangeTerm()` based on their state
2. Miners on partition A see fewer qualifying `ActualMiningTimes` → decide `NextRound`
3. Miners on partition B see more qualifying `ActualMiningTimes` → decide `NextTerm`
4. Both transactions pass validation (validated independently against their respective base states)
5. Fork persists because validation cannot determine which decision was "correct"

**Detection Constraints:**
The vulnerability is difficult to prevent because:
- No validation code checks whether the term change decision matches `NeedToChangeTerm`
- Both fork branches appear valid to their respective validators
- The system lacks a deterministic tie-breaker for conflicting termination decisions

**Probability Assessment:**
MEDIUM-HIGH - While normal operation with good network connectivity should prevent this, the complete lack of decision validation means any state divergence (network partitions, competing forks, timing issues) can trigger permanent consensus splits. The vulnerability's severity is amplified because recovery requires off-chain coordination.

### Recommendation

**Code-Level Mitigation:**

Add validation in `RoundTerminateValidationProvider` to verify the NextRound vs NextTerm decision:

```csharp
private ValidationResult ValidationForTerminateRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    var baseRound = validationContext.BaseRound;
    
    // Re-evaluate the term change decision during validation
    bool shouldChangeTerm = baseRound.NeedToChangeTerm(
        validationContext.BlockchainStartTimestamp,
        validationContext.CurrentTermNumber,
        validationContext.PeriodSeconds
    );
    
    if (extraData.Behaviour == AElfConsensusBehaviour.NextTerm && !shouldChangeTerm)
    {
        return new ValidationResult 
        { 
            Message = "NextTerm not required - term change criterion not met" 
        };
    }
    
    if (extraData.Behaviour == AElfConsensusBehaviour.NextRound && shouldChangeTerm)
    {
        return new ValidationResult 
        { 
            Message = "NextRound invalid - term change criterion met, must use NextTerm" 
        };
    }
    
    // Continue with existing validations...
}
```

**Additional Protections:**

1. **Validate Extra Block Producer Role**: Add check that only the designated extra block producer can submit termination transactions: [8](#0-7) 

2. **Deterministic Timestamp**: Use deterministic block timestamp rather than miner-provided timestamp for `IsTimeToChangeTerm` calculation

3. **Consensus Parameter Access**: Ensure validation context includes all required parameters (`BlockchainStartTimestamp`, `PeriodSeconds`) to re-evaluate `NeedToChangeTerm`

**Test Cases:**
1. Test that `NextTerm` transaction is rejected when `NeedToChangeTerm` returns false
2. Test that `NextRound` transaction is rejected when `NeedToChangeTerm` returns true
3. Test concurrent termination attempts with divergent state views are handled consistently
4. Test that only extra block producer can submit termination transactions

### Proof of Concept

**Initial State:**
- Current Round: 100, Term: 5
- PeriodSeconds: 604800 (1 week)
- 7 miners total, MinersCountOfConsent = 5 (2/3 + 1)
- 4 miners have ActualMiningTimes indicating term change needed
- Round termination time approaching

**Step 1: Network Partition**
- Network splits into Group A (3 miners) and Group B (4 miners)
- Miner X produces a block with their `ActualMiningTime` at timestamp indicating term change
- Block propagates only to Group B, not Group A

**Step 2: Divergent State**
- Group A state: 4 miners meet term change criterion (< 5) → `NeedToChangeTerm()` = false
- Group B state: 5 miners meet term change criterion (≥ 5) → `NeedToChangeTerm()` = true

**Step 3: Competing Termination Blocks**
- Miner in Group A produces Block A with `NextRound` transaction (Round 101, Term 5)
- Miner in Group B produces Block B with `NextTerm` transaction (Round 101, Term 6)

**Step 4: Validation Passes for Both**
- Block A validates: `baseRound.RoundNumber (100) + 1 == 101` ✓, TermNumber unchanged ✓
- Block B validates: `baseRound.RoundNumber (100) + 1 == 101` ✓, `baseRound.TermNumber (5) + 1 == 6` ✓

**Expected Result:**
Only one block should be valid based on objective evaluation of `NeedToChangeTerm` at the base state.

**Actual Result:**
Both blocks pass validation. Network forks into:
- Chain A: Round 101, Term 5
- Chain B: Round 101, Term 6

Chains cannot reconcile because they have different term numbers, creating permanent consensus fork requiring manual resolution.

**Success Condition:**
Fork persists beyond next round, with both chains continuing to produce blocks with incompatible term numbers, confirming the consensus split.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/MainChainConsensusBehaviourProvider.cs (L28-36)
```csharp
        protected override AElfConsensusBehaviour GetConsensusBehaviourToTerminateCurrentRound()
        {
            return CurrentRound.RoundNumber == 1 || // Return NEXT_ROUND in first round.
                   !CurrentRound.NeedToChangeTerm(_blockchainStartTimestamp,
                       CurrentRound.TermNumber, _periodSeconds) ||
                   CurrentRound.RealTimeMinersInformation.Keys.Count == 1 // Return NEXT_ROUND for single node.
                ? AElfConsensusBehaviour.NextRound
                : AElfConsensusBehaviour.NextTerm;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round.cs (L216-224)
```csharp
    public bool NeedToChangeTerm(Timestamp blockchainStartTimestamp, long currentTermNumber, long periodSeconds)
    {
        return RealTimeMinersInformation.Values
                   .Where(m => m.ActualMiningTimes.Any())
                   .Select(m => m.ActualMiningTimes.Last())
                   .Count(t => IsTimeToChangeTerm(blockchainStartTimestamp,
                       t, currentTermNumber, periodSeconds))
               >= MinersCountOfConsent;
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ImpliedIrreversibleBlockHeight.cs (L10-10)
```csharp
    public int MinersCountOfConsent => RealTimeMinersInformation.Count.Mul(2).Div(3).Add(1);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L22-47)
```csharp
    private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
    {
        // Is next round information correct?
        // Currently two aspects:
        //   Round Number
        //   In Values Should Be Null
        var extraData = validationContext.ExtraData;
        if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
            return new ValidationResult { Message = "Incorrect round number for next round." };

        return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
            ? new ValidationResult { Message = "Incorrect next round information." }
            : new ValidationResult { Success = true };
    }

    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L17-54)
```csharp
    public override ConsensusCommand GetConsensusCommand(BytesValue input)
    {
        _processingBlockMinerPubkey = input.Value.ToHex();

        if (Context.CurrentHeight < 2) return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!TryToGetCurrentRoundInformation(out var currentRound))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey))
            return ConsensusCommandProvider.InvalidConsensusCommand;

        if (currentRound.RealTimeMinersInformation.Count != 1 &&
            currentRound.RoundNumber > 2 &&
            State.LatestPubkeyToTinyBlocksCount.Value != null &&
            State.LatestPubkeyToTinyBlocksCount.Value.Pubkey == _processingBlockMinerPubkey &&
            State.LatestPubkeyToTinyBlocksCount.Value.BlocksCount < 0)
            return GetConsensusCommand(AElfConsensusBehaviour.NextRound, currentRound, _processingBlockMinerPubkey,
                Context.CurrentBlockTime);

        var blockchainStartTimestamp = GetBlockchainStartTimestamp();

        var behaviour = IsMainChain
            ? new MainChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                    GetMaximumBlocksCount(),
                    Context.CurrentBlockTime, blockchainStartTimestamp, State.PeriodSeconds.Value)
                .GetConsensusBehaviour()
            : new SideChainConsensusBehaviourProvider(currentRound, _processingBlockMinerPubkey,
                GetMaximumBlocksCount(),
                Context.CurrentBlockTime).GetConsensusBehaviour();

        Context.LogDebug(() =>
            $"{currentRound.ToString(_processingBlockMinerPubkey)}\nArranged behaviour: {behaviour.ToString()}");

        return behaviour == AElfConsensusBehaviour.Nothing
            ? ConsensusCommandProvider.InvalidConsensusCommand
            : GetConsensusCommand(behaviour, currentRound, _processingBlockMinerPubkey, Context.CurrentBlockTime);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L164-179)
```csharp
            case AElfConsensusBehaviour.NextRound:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextRound), NextRoundInput.Create(round,randomNumber))
                    }
                };
            case AElfConsensusBehaviour.NextTerm:
                return new TransactionList
                {
                    Transactions =
                    {
                        GenerateTransaction(nameof(NextTerm), NextTermInput.Create(round,randomNumber))
                    }
                };
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusCommandGeneration/ConsensusBehaviourProviderBase.cs (L82-82)
```csharp
            return GetConsensusBehaviourToTerminateCurrentRound();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_Generation.cs (L58-66)
```csharp
        // Calculate extra block producer order and set the producer.
        var extraBlockProducerOrder = CalculateNextExtraBlockProducerOrder();
        var expectedExtraBlockProducer =
            nextRound.RealTimeMinersInformation.Values.FirstOrDefault(m => m.Order == extraBlockProducerOrder);
        if (expectedExtraBlockProducer == null)
            nextRound.RealTimeMinersInformation.Values.First().IsExtraBlockProducer = true;
        else
            expectedExtraBlockProducer.IsExtraBlockProducer = true;

```
