# Audit Report

## Title
Missing Upper Bound Validation on MaximumMinersCount Enables Consensus DoS via Execution Limit Exhaustion

## Summary
The `SetMaximumMinersCount` function lacks upper bound validation, allowing governance to set arbitrarily large values. If set to approximately 2,000+ miners with sufficient candidates elected, the `ProcessUpdateValue` method exceeds AElf's 15,000 method call limit during on-chain execution, causing all `UpdateValue` transactions to fail and halting consensus permanently.

## Finding Description

**Root Cause:**
The `SetMaximumMinersCount` method only validates that the input value is positive, with no upper bound check: [1](#0-0) 

AElf enforces a 15,000 method call limit per transaction execution: [2](#0-1) 

**Vulnerable Execution Path:**

1. **Governance sets excessive MaximumMinersCount** via Parliament approval [3](#0-2) 

2. **Election contract returns miners up to this count** when sufficient candidates exist [4](#0-3) 

3. **Round generation populates RealTimeMinersInformation** with all elected miners [5](#0-4) 

4. **UpdateValue transaction generation calls ExtractInformationToUpdateConsensus** creating dictionaries with entries for each miner [6](#0-5) 

5. **On-chain execution in ProcessUpdateValue iterates over these dictionaries:**
   - TuneOrderInformation iteration: [7](#0-6) 
   
   - PerformSecretSharing iterations (if enabled): [8](#0-7) 

**Computational Complexity Analysis:**

With n = 2,000 miners and secret sharing enabled:
- TuneOrderInformation iteration: ~2,000 entries × 3 method calls = 6,000 calls
- DecryptedPieces iteration: ~2,000 entries × 3 method calls = 6,000 calls  
- MinersPreviousInValues iteration: ~2,000 entries × 3 method calls = 6,000 calls
- Base operations: ~20 calls
- **Total: ~18,020 method calls**

This exceeds the 15,000 limit, causing transaction failure.

## Impact Explanation

**Critical Consensus DoS:**
- All miners' `UpdateValue` transactions fail during execution due to exceeding method call limits
- No new blocks can be produced across the entire network
- Blockchain becomes completely frozen
- All network participants are affected: miners lose rewards, users cannot transact, dApps experience complete service disruption

**Permanent Lock:**
The DoS is self-reinforcing because reversing the MaximumMinersCount setting requires executing a governance proposal, which requires block production. This creates a deadlock requiring emergency intervention beyond normal protocol operations.

## Likelihood Explanation

**Attack Requirements:**
1. Register 2,000+ candidates (cost: 100,000 ELF × 2,000 = 200,000,000 ELF locked as deposits) [9](#0-8) 

2. Obtain votes for all 2,000+ candidates to make them valid [10](#0-9) 

3. Convince governance (Parliament) to approve MaximumMinersCount = 2,000+

**Likelihood Assessment:**
- **Low-Medium**: Requires massive economic resources (200M ELF) plus governance approval
- Current miners would need to vote to destabilize their own system
- Default configuration uses 17 miners, indicating this scenario was not considered [11](#0-10) 

- Test coverage only validates small values (3-7), no upper bound testing [12](#0-11) 

While economically expensive, the complete absence of validation combined with critical impact warrants addressing.

## Recommendation

Add an upper bound validation to `SetMaximumMinersCount` based on the execution limit threshold. A safe maximum would be approximately 1,500 miners to stay well below the 15,000 method call limit with margin for secret sharing operations:

```csharp
public override Empty SetMaximumMinersCount(Int32Value input)
{
    EnsureElectionContractAddressSet();

    const int MaxSafeMinersCount = 1500; // Conservative limit based on execution constraints
    Assert(input.Value > 0 && input.Value <= MaxSafeMinersCount, 
        $"Invalid max miners count. Must be between 1 and {MaxSafeMinersCount}.");

    RequiredMaximumMinersCountControllerSet();
    Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
        "No permission to set max miners count.");

    TryToGetCurrentRoundInformation(out var round);

    State.MaximumMinersCount.Value = input.Value;
    State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
    {
        MinersCount = GetMinersCount(round)
    });

    return new Empty();
}
```

Alternatively, add a governance-configurable maximum with a hardcoded absolute ceiling to prevent accidental misconfiguration while allowing flexibility.

## Proof of Concept

```csharp
[Fact]
public async Task SetMaximumMinersCount_ExcessiveValue_CausesUpdateValueFailure()
{
    // Setup: Initialize contracts and create 2000+ candidates
    const int excessiveMinerCount = 2000;
    
    // Step 1: Governance sets MaximumMinersCount to 2000 (no validation prevents this)
    await ParliamentReachAnAgreementAsync(new CreateProposalInput
    {
        ToAddress = ConsensusContractAddress,
        ContractMethodName = nameof(ConsensusStub.SetMaximumMinersCount),
        Params = new Int32Value { Value = excessiveMinerCount }.ToByteString()
    });
    
    // Step 2: Verify MaximumMinersCount was set
    var maxMinersCount = await ConsensusStub.GetMaximumMinersCount.CallAsync(new Empty());
    maxMinersCount.Value.ShouldBe(excessiveMinerCount);
    
    // Step 3: Trigger term change to generate round with 2000 miners
    await BlockMiningService.MineBlockToNextTermAsync();
    var currentRound = await ConsensusStub.GetCurrentRoundInformation.CallAsync(new Empty());
    
    // Step 4: Attempt UpdateValue transaction - should fail due to execution limit
    var miner = currentRound.RealTimeMinersInformation.First();
    var updateValueInput = currentRound.ExtractInformationToUpdateConsensus(
        miner.Key, ByteString.CopyFrom(new byte[32]));
    
    var result = await ConsensusStub.UpdateValue.SendAsync(updateValueInput);
    
    // Assertion: Transaction fails due to exceeding 15000 method call limit
    result.TransactionResult.Status.ShouldBe(TransactionResultStatus.Failed);
    result.TransactionResult.Error.ShouldContain("execution call threshold");
}
```

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_MaximumMinersCount.cs (L10-29)
```csharp
    public override Empty SetMaximumMinersCount(Int32Value input)
    {
        EnsureElectionContractAddressSet();

        Assert(input.Value > 0, "Invalid max miners count.");

        RequiredMaximumMinersCountControllerSet();
        Assert(Context.Sender == State.MaximumMinersCountController.Value.OwnerAddress,
            "No permission to set max miners count.");

        TryToGetCurrentRoundInformation(out var round);

        State.MaximumMinersCount.Value = input.Value;
        State.ElectionContract.UpdateMinersCount.Send(new UpdateMinersCountInput
        {
            MinersCount = GetMinersCount(round)
        });

        return new Empty();
    }
```

**File:** src/AElf.Kernel.SmartContract/SmartContractConstants.cs (L5-5)
```csharp
    public const int ExecutionCallThreshold = 15000;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L79-83)
```csharp
        victories = validCandidates.Select(k => State.CandidateVotes[k])
            .OrderByDescending(v => v.ObtainedActiveVotedVotesAmount).Select(v => v.Pubkey)
            .Take(State.MinersCount.Value).ToList();
        Context.LogDebug(() => string.Join("\n", victories.Select(v => v.ToHex().Substring(0, 10)).ToList()));
        return victories;
```

**File:** contract/AElf.Contracts.Election/ViewMethods.cs (L90-94)
```csharp
        return State.Candidates.Value.Value
            .Where(c => State.CandidateVotes[c.ToHex()] != null &&
                        State.CandidateVotes[c.ToHex()].ObtainedActiveVotedVotesAmount > 0)
            .Select(p => p.ToHex())
            .ToList();
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/MinerList.cs (L23-38)
```csharp
        for (var i = 0; i < sortedMiners.Count; i++)
        {
            var minerInRound = new MinerInRound();

            // The first miner will be the extra block producer of first round of each term.
            if (i == 0) minerInRound.IsExtraBlockProducer = true;

            minerInRound.Pubkey = sortedMiners[i];
            minerInRound.Order = i + 1;
            minerInRound.ExpectedMiningTime =
                currentBlockTime.AddMilliseconds(i.Mul(miningInterval).Add(miningInterval));
            // Should be careful during validation.
            minerInRound.PreviousInValue = Hash.Empty;

            round.RealTimeMinersInformation.Add(sortedMiners[i], minerInRound);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/Types/Round_ExtractInformationToUpdateConsensus.cs (L22-33)
```csharp
        var tuneOrderInformation = RealTimeMinersInformation.Values
            .Where(m => m.FinalOrderOfNextRound != m.SupposedOrderOfNextRound)
            .ToDictionary(m => m.Pubkey, m => m.FinalOrderOfNextRound);

        var decryptedPreviousInValues = RealTimeMinersInformation.Values.Where(v =>
                v.Pubkey != pubkey && v.DecryptedPieces.ContainsKey(pubkey))
            .ToDictionary(info => info.Pubkey, info => info.DecryptedPieces[pubkey]);

        var minersPreviousInValues =
            RealTimeMinersInformation.Values.Where(info => info.PreviousInValue != null).ToDictionary(
                info => info.Pubkey,
                info => info.PreviousInValue);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L259-260)
```csharp
        foreach (var tuneOrder in updateValueInput.TuneOrderInformation)
            currentRound.RealTimeMinersInformation[tuneOrder.Key].FinalOrderOfNextRound = tuneOrder.Value;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L291-296)
```csharp
        foreach (var decryptedPreviousInValue in input.DecryptedPieces)
            round.RealTimeMinersInformation[decryptedPreviousInValue.Key].DecryptedPieces
                .Add(publicKey, decryptedPreviousInValue.Value);

        foreach (var previousInValue in input.MinersPreviousInValues)
            round.RealTimeMinersInformation[previousInValue.Key].PreviousInValue = previousInValue.Value;
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContractConstants.cs (L9-9)
```csharp
    public const int SupposedMinersCount = 17;
```

**File:** test/AElf.Contracts.AEDPoSExtension.Demo.Tests/MaximumMinersCountTests.cs (L27-28)
```csharp
    [InlineData(7)]
    [InlineData(3)]
```
