### Title
Division by Zero in GetMaximumBlocksCount() When Round Has Zero Miners

### Summary
A malicious miner can submit a `NextTerm` or `NextRound` consensus transaction with an empty miner list (`real_time_miners_information` count of 0), which passes all validation checks. When `GetMaximumBlocksCount()` is subsequently called during blockchain "Abnormal" mining status, it triggers a division by zero error in the `Ceiling` function, causing the transaction to fail and potentially halting all block production.

### Finding Description

**Root Cause**: The `Ceiling` function performs modulo and division operations without checking for zero divisor. [1](#0-0) 

When `GetMaximumBlocksCount()` executes during "Abnormal" blockchain mining status, it calculates the maximum block count by calling `Ceiling(factor, currentRound.RealTimeMinersInformation.Count)`. [2](#0-1) 

If `currentRound.RealTimeMinersInformation.Count` is 0, both the modulo operation (`num1 % num2`) and division (`num1.Div(num2)`) in the `Ceiling` function will throw a division by zero exception.

**Entry Points**: An attacker can create a round with zero miners through two public methods:
1. `NextTerm(NextTermInput input)` - where `input.real_time_miners_information` map is empty [3](#0-2) 

2. `NextRound(NextRoundInput input)` - where `input.real_time_miners_information` map is empty [4](#0-3) 

**Validation Bypass**: The `RoundTerminateValidationProvider` only validates round number increment, term number increment, and null InValues - it does NOT check if the new round has at least one miner. [5](#0-4) 

**Execution Path**:
1. Malicious miner submits `NextTerm` with empty `real_time_miners_information`
2. `ProcessConsensusInformation` is invoked [6](#0-5) 

3. `ProcessNextTerm` stores the empty round via `AddRoundInformation` and updates the current round number [7](#0-6) 

4. Control returns to `ProcessConsensusInformation`, which calls `GetMaximumBlocksCount()` [8](#0-7) 

5. If `libRoundNumber` is non-zero (from previous blocks) and blockchain status is "Abnormal", division by zero occurs.

**Why Protection Fails**: The early return check only handles the case where `libRoundNumber == 0`, which occurs only at chain initialization. [9](#0-8) 

Once the blockchain has established a non-zero LIB round number through normal operation, this protection no longer applies.

### Impact Explanation

**Immediate Impact**: The division by zero exception causes the `NextTerm` or `NextRound` transaction to fail completely, preventing the consensus operation from completing.

**Blockchain Halt**: Since `GetMaximumBlocksCount()` is called for ALL consensus behaviors in `ProcessConsensusInformation`, any subsequent consensus operation (UpdateValue, TinyBlock, NextRound, NextTerm) will also fail with division by zero as long as the current round has zero miners. This effectively halts block production. [8](#0-7) 

**Recovery Difficulty**: Recovery requires miners from the previous round to produce blocks (permitted by `PreCheck`), but they also trigger the same `GetMaximumBlocksCount()` call, creating a deadlock scenario. [10](#0-9) 

**Affected Parties**: All network participants are affected - validators cannot produce blocks, users cannot transact, and the entire blockchain becomes unresponsive.

**Severity Justification**: CRITICAL - This is a complete denial of service that halts consensus and requires manual intervention or hard fork to recover.

### Likelihood Explanation

**Attacker Capabilities**: Any current miner can execute this attack. They only need the ability to submit consensus transactions, which is their normal operational privilege.

**Attack Complexity**: LOW - The attacker simply submits a valid `NextTermInput` or `NextRoundInput` protobuf message with an empty `real_time_miners_information` map. No complex manipulation or timing requirements.

**Preconditions**: 
1. Blockchain must be operational (non-zero `libRoundNumber`) - always true after initialization
2. Mining status must reach "Abnormal" (current round 2-7 rounds ahead of LIB) - this naturally occurs during network delays or can be deliberately induced by coordinating miners to advance rounds [11](#0-10) 

3. Attacker must be in current miner list to pass `PreCheck` - true by definition for any malicious miner

**Detection Constraints**: The attack succeeds immediately on the first malicious transaction. There is no gradual degradation or warning period.

**Economic Rationality**: A malicious miner could execute this to:
- Extort the network for payment before restoring service
- Sabotage competitors
- Manipulate markets during the downtime
- No cost to the attacker beyond transaction fees

**Probability**: HIGH - All preconditions are realistic, and the attack is trivially executable by any miner.

### Recommendation

**Immediate Fix**: Add validation to check minimum miner count before storing new rounds.

In `RoundTerminateValidationProvider.cs`, add miner count validation:
```csharp
private ValidationResult ValidationForNextRound(ConsensusValidationContext validationContext)
{
    var extraData = validationContext.ExtraData;
    
    // ADD THIS CHECK
    if (extraData.Round.RealTimeMinersInformation.Count == 0)
        return new ValidationResult { Message = "Round must have at least one miner." };
    
    if (validationContext.BaseRound.RoundNumber.Add(1) != extraData.Round.RoundNumber)
        return new ValidationResult { Message = "Incorrect round number for next round." };

    return extraData.Round.RealTimeMinersInformation.Values.Any(m => m.InValue != null)
        ? new ValidationResult { Message = "Incorrect next round information." }
        : new ValidationResult { Success = true };
}
```

**Defense in Depth**: Add a safety check in `GetMaximumBlocksCount()` before calling `Ceiling`:
```csharp
if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
{
    // ... existing code ...
    
    // ADD THIS CHECK
    if (currentRound.RealTimeMinersInformation.Count == 0)
        return AEDPoSContractConstants.MaximumTinyBlocksCount;
    
    var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
        Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
    // ...
}
```

**Invariant to Enforce**: `Round.RealTimeMinersInformation.Count > 0` for all stored rounds after initialization.

**Test Cases**:
1. Attempt `NextTerm` with empty miner list - should reject
2. Attempt `NextRound` with empty miner list - should reject  
3. Call `GetMaximumBlocksCount()` with artificially created zero-miner round - should not crash
4. Verify all consensus paths (UpdateValue, TinyBlock, NextRound, NextTerm) handle zero-miner gracefully

### Proof of Concept

**Initial State**:
- Blockchain is operational with N miners (N ≥ 1)
- Current round number: R
- LIB round number: R - 4 (blockchain in "Abnormal" status)
- Current term: T

**Attack Sequence**:
1. Malicious miner crafts `NextTermInput`:
   - `round_number = R + 1`
   - `term_number = T + 1`
   - `real_time_miners_information = {}` (empty map)
   - All other fields set to valid values

2. Miner calls `NextTerm(NextTermInput)` with crafted input

3. **Expected Result**: Validation should reject empty miner list
   **Actual Result**: Validation passes, transaction proceeds to execution

4. During `ProcessConsensusInformation()`:
   - `ProcessNextTerm()` stores round with 0 miners at line 196
   - `GetMaximumBlocksCount()` called at line 68
   - `TryToGetCurrentRoundInformation()` retrieves round with 0 miners
   - `libRoundNumber != 0` so no early return
   - Status evaluated as "Abnormal" 
   - Line 52: `Ceiling(factor, 0)` executes
   - Line 83: `num1 % 0` throws DivideByZeroException

5. **Success Condition**: Transaction fails with division by zero, blockchain halts as all subsequent consensus operations also fail when calling `GetMaximumBlocksCount()`.

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L33-33)
```csharp
        if (libRoundNumber == 0) return AEDPoSContractConstants.MaximumTinyBlocksCount;
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L42-55)
```csharp
        if (blockchainMiningStatus == BlockchainMiningStatus.Abnormal)
        {
            var previousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(1)].Pubkeys;
            var previousPreviousRoundMinedMinerList = State.MinedMinerListMap[currentRoundNumber.Sub(2)].Pubkeys;
            var minersOfLastTwoRounds = previousRoundMinedMinerList
                .Intersect(previousPreviousRoundMinedMinerList).Count();
            var factor = minersOfLastTwoRounds.Mul(
                blockchainMiningStatusEvaluator.SevereStatusRoundsThreshold.Sub(
                    (int)currentRoundNumber.Sub(libRoundNumber)));
            var count = Math.Min(AEDPoSContractConstants.MaximumTinyBlocksCount,
                Ceiling(factor, currentRound.RealTimeMinersInformation.Count));
            Context.LogDebug(() => $"Maximum blocks count tune to {count}");
            return count;
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L81-85)
```csharp
    private static int Ceiling(int num1, int num2)
    {
        var flag = num1 % num2;
        return flag == 0 ? num1.Div(num2) : num1.Div(num2).Add(1);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetMaximumBlocksCount.cs (L87-130)
```csharp
    private class BlockchainMiningStatusEvaluator
    {
        private const int AbnormalThresholdRoundsCount = 2;

        /// <summary>
        ///     Stands for R
        /// </summary>
        private readonly long _currentRoundNumber;

        /// <summary>
        ///     Stands for R_LIB
        /// </summary>
        private readonly long _libRoundNumber;

        /// <summary>
        ///     Stands for CB0
        /// </summary>
        private readonly int _maximumTinyBlocksCount;

        public BlockchainMiningStatusEvaluator(long currentConfirmedIrreversibleBlockRoundNumber,
            long currentRoundNumber, int maximumTinyBlocksCount)
        {
            _libRoundNumber = currentConfirmedIrreversibleBlockRoundNumber;
            _currentRoundNumber = currentRoundNumber;
            _maximumTinyBlocksCount = maximumTinyBlocksCount;
        }

        /// <summary>
        ///     Stands for CB1
        /// </summary>
        public int SevereStatusRoundsThreshold => Math.Max(8, _maximumTinyBlocksCount);

        public void Deconstruct(out BlockchainMiningStatus status)
        {
            status = BlockchainMiningStatus.Normal;

            if (_libRoundNumber.Add(AbnormalThresholdRoundsCount) < _currentRoundNumber &&
                _currentRoundNumber < _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Abnormal;

            if (_currentRoundNumber >= _libRoundNumber.Add(SevereStatusRoundsThreshold))
                status = BlockchainMiningStatus.Severe;
        }
    }
```

**File:** protobuf/aedpos_contract.proto (L458-481)
```text
message NextRoundInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** protobuf/aedpos_contract.proto (L484-507)
```text
message NextTermInput {
    // The round number.
    int64 round_number = 1;
    // Current miner information, miner public key -> miner information.
    map<string, MinerInRound> real_time_miners_information = 2;
    // The round number on the main chain
    int64 main_chain_miners_round_number = 3;
    // The time from chain start to current round (seconds).
    int64 blockchain_age = 4;
    // The miner public key that produced the extra block in the previous round.
    string extra_block_producer_of_previous_round = 5;
    // The current term number.
    int64 term_number = 6;
    // The height of the confirmed irreversible block.
    int64 confirmed_irreversible_block_height = 7;
    // The round number of the confirmed irreversible block.
    int64 confirmed_irreversible_block_round_number = 8;
    // Is miner list different from the the miner list in the previous round.
    bool is_miner_list_just_changed = 9;
    // The round id, calculated by summing block producers’ expecting time (second).
    int64 round_id_for_validation = 10;
    // The random number.
    bytes random_number = 11;
}
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/ConsensusHeaderInfoValidationProviders/RoundTerminateValidationProvider.cs (L37-47)
```csharp
    private ValidationResult ValidationForNextTerm(ConsensusValidationContext validationContext)
    {
        var extraData = validationContext.ExtraData;
        var validationResult = ValidationForNextRound(validationContext);
        if (!validationResult.Success) return validationResult;

        // Is next term number correct?
        return validationContext.BaseRound.TermNumber.Add(1) != extraData.Round.TermNumber
            ? new ValidationResult { Message = "Incorrect term number for next round." }
            : new ValidationResult { Success = true };
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L21-54)
```csharp
    private void ProcessConsensusInformation(dynamic input, [CallerMemberName] string callerMethodName = null)
    {
        EnsureTransactionOnlyExecutedOnceInOneBlock();

        Context.LogDebug(() => $"Processing {callerMethodName}");

        /* Privilege check. */
        if (!PreCheck()) Assert(false, "No permission.");

        State.RoundBeforeLatestExecution.Value = GetCurrentRoundInformation(new Empty());

        ByteString randomNumber = null;

        // The only difference.
        switch (input)
        {
            case NextRoundInput nextRoundInput:
                randomNumber = nextRoundInput.RandomNumber;
                ProcessNextRound(nextRoundInput);
                break;
            case NextTermInput nextTermInput:
                randomNumber = nextTermInput.RandomNumber;
                ProcessNextTerm(nextTermInput);
                break;
            case UpdateValueInput updateValueInput:
                randomNumber = updateValueInput.RandomNumber;
                ProcessUpdateValue(updateValueInput);
                break;
            case TinyBlockInput tinyBlockInput:
                randomNumber = tinyBlockInput.RandomNumber;
                ProcessTinyBlock(tinyBlockInput);
                break;
        }

```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L67-69)
```csharp
        // Make sure the method GetMaximumBlocksCount executed no matter what consensus behaviour is.
        var minersCountInTheory = GetMaximumBlocksCount();
        ResetLatestProviderToTinyBlocksCount(minersCountInTheory);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L161-196)
```csharp
    private void ProcessNextTerm(NextTermInput input)
    {
        var nextRound = input.ToRound();
        
        RecordMinedMinerListOfCurrentRound();

        // Count missed time slot of current round.
        CountMissedTimeSlots();

        Assert(TryToGetTermNumber(out var termNumber), "Term number not found.");

        // Update current term number and current round number.
        Assert(TryToUpdateTermNumber(nextRound.TermNumber), "Failed to update term number.");
        Assert(TryToUpdateRoundNumber(nextRound.RoundNumber), "Failed to update round number.");

        UpdateMinersCountToElectionContract(nextRound);

        // Reset some fields of first two rounds of next term.
        foreach (var minerInRound in nextRound.RealTimeMinersInformation.Values)
        {
            minerInRound.MissedTimeSlots = 0;
            minerInRound.ProducedBlocks = 0;
        }

        UpdateProducedBlocksNumberOfSender(nextRound);

        // Update miners list.
        var miners = new MinerList();
        miners.Pubkeys.AddRange(nextRound.RealTimeMinersInformation.Keys.Select(k => ByteStringHelper.FromHexString(k)));
        if (!SetMinerList(miners, nextRound.TermNumber)) Assert(false, "Failed to update miner list.");

        // Update term number lookup. (Using term number to get first round number of related term.)
        State.FirstRoundNumberOfEachTerm[nextRound.TermNumber] = nextRound.RoundNumber;

        // Update rounds information of next two rounds.
        AddRoundInformation(nextRound);
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L316-331)
```csharp
    private bool PreCheck()
    {
        TryToGetCurrentRoundInformation(out var currentRound);
        TryToGetPreviousRoundInformation(out var previousRound);

        _processingBlockMinerPubkey = Context.RecoverPublicKey().ToHex();

        // Though we've already prevented related transactions from inserting to the transaction pool
        // via ConstrainedAEDPoSTransactionValidationProvider,
        // this kind of permission check is still useful.
        if (!currentRound.IsInMinerList(_processingBlockMinerPubkey) &&
            !previousRound.IsInMinerList(_processingBlockMinerPubkey)) // Case a failed miner performing NextTerm
            return false;

        return true;
    }
```
