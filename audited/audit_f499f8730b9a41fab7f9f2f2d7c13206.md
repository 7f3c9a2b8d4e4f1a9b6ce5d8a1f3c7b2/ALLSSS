# Audit Report

## Title
ConfigurationContract Invalid Data Causes Chain Halt via Unhandled Protobuf Deserialization Exception in Consensus

## Summary
The AEDPoS consensus contract's `IsSecretSharingEnabled()` method deserializes configuration data without exception handling. If the ConfigurationContract stores invalid bytes for the `SecretSharingEnabled` configuration key, the protobuf `MergeFrom()` operation will throw an exception, causing all consensus block production to fail and permanently halting the blockchain.

## Finding Description

The vulnerability exists in the `IsSecretSharingEnabled()` method which unconditionally deserializes configuration data using `MergeFrom()` without any try-catch block: [1](#0-0) 

The Configuration contract's `SetConfiguration` method accepts arbitrary bytes with only minimal validation - it checks that the key is non-empty and value is not empty, but does NOT validate the byte format or protobuf message type compatibility: [2](#0-1) 

This method is invoked during critical consensus operations:

**1. Block Extra Data Generation** - When producing blocks with UpdateValue behavior, `IsSecretSharingEnabled()` is called: [3](#0-2) 

**2. Consensus Transaction Processing** - When processing UpdateValue consensus transactions: [4](#0-3) 

These methods are invoked through the ACS4 interface methods `GetConsensusExtraData` and `GenerateConsensusTransactions`, which are called by the consensus system during block production: [5](#0-4) [6](#0-5) 

The ConsensusService calls these ACS4 methods without exception handling: [7](#0-6) 

**Root Cause:** Protobuf's `MergeFrom()` method throws `InvalidProtocolBufferException` when deserializing malformed or type-incompatible byte data. Since there is no try-catch block in the call chain, the exception will propagate and cause block production to fail.

**Attack Scenario:**
1. Parliament creates a proposal to set the `SecretSharingEnabled` configuration key with invalid bytes (e.g., bytes that don't represent a valid BoolValue protobuf message - could be random bytes, wrong message type, or corrupted data)
2. Parliament members approve the proposal (requires majority approval)
3. The proposal is executed, storing the invalid bytes in ConfigurationContract
4. During the next consensus round, when any miner attempts to produce a block with UpdateValue behavior, `IsSecretSharingEnabled()` is called
5. The `MergeFrom()` operation throws an exception on the invalid bytes
6. The exception propagates through the consensus system, causing block production to fail
7. ALL miners encounter the same exception when they attempt to produce blocks
8. The blockchain halts completely with no automatic recovery mechanism

## Impact Explanation

**Severity: Critical**

This vulnerability results in complete denial of service of the entire blockchain:

- **Complete Chain Halt:** All block production stops indefinitely. Every miner that attempts to produce a block with UpdateValue behavior will encounter the same exception and fail to generate consensus extra data or transactions.

- **Transaction Processing Failure:** All pending transactions become unprocessable. Users cannot execute any transactions, affecting all applications and services built on the chain.

- **Consensus Deadlock:** The blockchain cannot progress past the point where the invalid configuration was set. Unlike a normal transaction failure (which only affects that specific transaction), this failure occurs in the consensus mechanism itself, which is required for all block production.

- **No Automatic Recovery:** There is no built-in mechanism to recover from this state. Recovery requires emergency manual intervention, likely requiring a hard fork or coordinated effort by all validators to fix the configuration data directly in state.

**Affected Parties:**
- All network miners cannot produce blocks
- All users cannot execute transactions  
- All dApps and services become unavailable
- The entire blockchain ecosystem is frozen

The impact is maximized because this occurs in the consensus layer, not in user transactions. Every miner will hit the exact same failure point, making the chain completely non-functional.

## Likelihood Explanation

**Likelihood: Medium**

**Prerequisites:**
1. Create a Parliament proposal to set invalid bytes for the `SecretSharingEnabled` configuration key
2. Obtain Parliament majority approval
3. Execute the approved proposal

**Feasibility Analysis:**

The Configuration contract is controlled by Parliament's default organization: [8](#0-7) 

While this requires governance approval, several realistic scenarios could lead to this vulnerability being triggered:

1. **Human Error:** Parliament members reviewing the proposal may not carefully validate the binary protobuf format of configuration bytes. The test suite only validates empty values, not malformed protobuf data: [9](#0-8) 

2. **Tooling Bugs:** Automated tools or scripts that generate proposals could have bugs that produce malformed protobuf bytes.

3. **Malicious Coalition:** A coalition of malicious Parliament members could deliberately create and approve such a proposal.

**Attack Complexity:** Low once governance approval is obtained. The exploit triggers automatically during the next consensus round when any miner attempts UpdateValue behavior - no additional actions needed.

**Detection:** The attack would be immediately obvious (complete chain halt), but by that point the damage is done and recovery is extremely difficult.

## Recommendation

**Immediate Fix:** Add exception handling around the `MergeFrom()` call in `IsSecretSharingEnabled()`:

```csharp
private bool IsSecretSharingEnabled()
{
    if (State.ConfigurationContract.Value == null)
    {
        var configurationContractAddress =
            Context.GetContractAddressByName(SmartContractConstants.ConfigurationContractSystemName);
        if (configurationContractAddress == null)
        {
            return false;
        }
        State.ConfigurationContract.Value = configurationContractAddress;
    }

    try
    {
        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);
        return secretSharingEnabled.Value;
    }
    catch
    {
        // If deserialization fails, default to false (secret sharing disabled)
        return false;
    }
}
```

**Additional Recommendations:**

1. **Add Validation in SetConfiguration:** The Configuration contract should validate that stored bytes can be successfully deserialized as the expected protobuf message type before storing them.

2. **Type Registry:** Maintain a registry of expected protobuf message types for known configuration keys and validate against this registry.

3. **Defensive Deserialization:** Apply similar exception handling to all other places in the codebase where configuration data is deserialized.

4. **Testing:** Add test cases that verify proper handling of malformed protobuf bytes, not just empty values.

## Proof of Concept

```csharp
[Fact]
public async Task ChainHalt_InvalidSecretSharingEnabledConfiguration()
{
    // 1. Set invalid bytes for SecretSharingEnabled configuration through Parliament
    var organizationAddress = await GetParliamentDefaultOrganizationAddressAsync();
    
    // Create invalid bytes that don't represent a valid BoolValue protobuf message
    var invalidBytes = ByteString.CopyFrom(new byte[] { 0xFF, 0xFF, 0xFF, 0xFF });
    
    var proposalId = await CreateProposalAsync(organizationAddress, 
        new SetConfigurationInput
        {
            Key = "SecretSharingEnabled",
            Value = invalidBytes
        },
        nameof(ConfigurationImplContainer.ConfigurationImplStub.SetConfiguration));
    
    await ApproveWithMinersAsync(proposalId);
    var setConfigResult = await ReleaseProposalAsync(proposalId);
    setConfigResult.Status.ShouldBe(TransactionResultStatus.Mined);
    
    // 2. Attempt to generate consensus extra data with UpdateValue behavior
    // This should throw an exception and fail
    var triggerInfo = new AElfConsensusTriggerInformation
    {
        Pubkey = ByteString.CopyFrom(MinerKeyPairs[0].PublicKey),
        Behaviour = AElfConsensusBehaviour.UpdateValue,
        InValue = HashHelper.ComputeFrom("test")
    };
    
    // This call will throw InvalidProtocolBufferException because 
    // IsSecretSharingEnabled() cannot deserialize the invalid bytes
    var exception = await Should.ThrowAsync<Exception>(async () =>
    {
        await ConsensusContractStub.GetConsensusExtraData.CallAsync(
            new BytesValue { Value = triggerInfo.ToByteString() });
    });
    
    // Verify chain halt: no miner can produce blocks with UpdateValue behavior
    exception.ShouldNotBeNull();
}
```

**Notes:**
- This is a critical consensus-layer vulnerability that affects blockchain availability
- The vulnerability is triggered through governance (Parliament approval required), but governance members may not have visibility into the binary protobuf format validation
- Recovery from this state requires emergency intervention and potentially a hard fork
- The lack of exception handling in critical consensus paths creates a systemic risk

### Citations

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_SecretSharing.cs (L71-75)
```csharp
        var secretSharingEnabled = new BoolValue();
        secretSharingEnabled.MergeFrom(State.ConfigurationContract.GetConfiguration.Call(new StringValue
        {
            Value = AEDPoSContractConstants.SecretSharingEnabledConfigurationKey
        }).Value);
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract.cs (L10-21)
```csharp
    public override Empty SetConfiguration(SetConfigurationInput input)
    {
        AssertPerformedByConfigurationControllerOrZeroContract();
        Assert(input.Key.Any() && input.Value != ByteString.Empty, "Invalid set config input.");
        State.Configurations[input.Key] = new BytesValue { Value = input.Value };
        Context.Fire(new ConfigurationSet
        {
            Key = input.Key,
            Value = input.Value
        });
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_GetConsensusBlockExtraData.cs (L122-125)
```csharp
        if (IsSecretSharingEnabled())
        {
            UpdateLatestSecretPieces(updatedRound, pubkey, triggerInformation);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ProcessConsensusInformation.cs (L254-257)
```csharp
        if (IsSecretSharingEnabled())
        {
            PerformSecretSharing(updateValueInput, minerInRound, currentRound, _processingBlockMinerPubkey);
        }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L56-59)
```csharp
    public override BytesValue GetConsensusExtraData(BytesValue input)
    {
        return GetConsensusBlockExtraData(input);
    }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AEDPoSContract_ACS4_ConsensusInformationProvider.cs (L61-75)
```csharp
    public override TransactionList GenerateConsensusTransactions(BytesValue input)
    {
        var triggerInformation = new AElfConsensusTriggerInformation();
        triggerInformation.MergeFrom(input.Value);
        // Some basic checks.
        Assert(triggerInformation.Pubkey.Any(),
            "Data to request consensus information should contain pubkey.");

        var pubkey = triggerInformation.Pubkey;
        var randomNumber = triggerInformation.RandomNumber;
        var consensusInformation = new AElfConsensusHeaderInformation();
        consensusInformation.MergeFrom(GetConsensusBlockExtraData(input, true).Value);
        var transactionList = GenerateTransactionListByExtraData(consensusInformation, pubkey, randomNumber);
        return transactionList;
    }
```

**File:** src/AElf.Kernel.Consensus.Core/Application/ConsensusService.cs (L195-209)
```csharp
    public async Task<byte[]> GetConsensusExtraDataAsync(ChainContext chainContext)
    {
        _blockTimeProvider.SetBlockTime(_nextMiningTime, chainContext.BlockHash);

        Logger.LogDebug(
            $"Block time of getting consensus extra data: {_nextMiningTime.ToDateTime():hh:mm:ss.ffffff}.");

        var contractReaderContext =
            await _consensusReaderContextService.GetContractReaderContextAsync(chainContext);
        var input = _triggerInformationProvider.GetTriggerInformationForBlockHeaderExtraData(
            _consensusCommand.ToBytesValue());
        var consensusContractStub = _contractReaderFactory.Create(contractReaderContext);
        var output = await consensusContractStub.GetConsensusExtraData.CallAsync(input);
        return output.Value.ToByteArray();
    }
```

**File:** contract/AElf.Contracts.Configuration/ConfigurationContract_Helper.cs (L8-19)
```csharp
    private AuthorityInfo GetDefaultConfigurationController()
    {
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        return new AuthorityInfo
        {
            ContractAddress = State.ParliamentContract.Value,
            OwnerAddress = State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty())
        };
    }
```

**File:** test/AElf.Contracts.Configuration.Tests/ConfigurationContractTest.cs (L176-206)
```csharp
    public async Task SetConfiguration_With_Invalid_Input_Test()
    {
        var organizationAddress = await GetParliamentDefaultOrganizationAddressAsync();
        var parameter = new Int32Value
        {
            Value = 1
        }.ToByteString();
        var inputWithInvalidKey = new SetConfigurationInput
        {
            Value = parameter
        };
        var proposalId = await CreateProposalAsync(organizationAddress, inputWithInvalidKey,
            nameof(ConfigurationImplContainer.ConfigurationImplStub.SetConfiguration));
        proposalId.ShouldNotBeNull();
        await ApproveWithMinersAsync(proposalId);
        var releaseTxResult = await ReleaseProposalAsync(proposalId);
        releaseTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        releaseTxResult.Error.ShouldContain("Invalid set config input");

        var inputWithInvalidValue = new SetConfigurationInput
        {
            Key = "key1"
        };
        proposalId = await CreateProposalAsync(organizationAddress, inputWithInvalidValue,
            nameof(ConfigurationImplContainer.ConfigurationImplStub.SetConfiguration));
        proposalId.ShouldNotBeNull();
        await ApproveWithMinersAsync(proposalId);
        releaseTxResult = await ReleaseProposalAsync(proposalId);
        releaseTxResult.Status.ShouldBe(TransactionResultStatus.Failed);
        releaseTxResult.Error.ShouldContain("Invalid set config input");
    }
```
