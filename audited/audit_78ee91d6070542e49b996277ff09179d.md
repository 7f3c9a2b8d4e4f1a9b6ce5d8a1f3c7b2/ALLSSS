### Title
NFT Contract Method Fee Governance Permanently Broken Due to Missing MethodFeeController Initialization

### Summary
The NFT contract's ACS1 (method fee standard) implementation is completely non-functional, with all governance methods returning empty results without performing any operations. The contract lacks the required `MethodFeeController` state variable and initialization logic, resulting in permanently broken fee governance with no recovery path after deployment.

### Finding Description

The NFT contract implements ACS1 but violates the standard in multiple critical ways:

**1. Missing State Variables**

All AElf contracts implementing ACS1 define `SingletonState<AuthorityInfo> MethodFeeController` in their state class. [1](#0-0) [2](#0-1) 

However, the NFT contract state classes contain no such definition. [3](#0-2) [4](#0-3) 

Similarly, the required `MappedState<string, MethodFees> TransactionFees` state variable is also absent.

**2. Broken ACS1 Implementation**

The NFT contract's ACS1 methods are empty stubs that perform no operations:

- `SetMethodFee` returns `Empty` without storing fees or checking permissions [5](#0-4) 
- `ChangeMethodFeeController` returns `Empty` without updating any controller [6](#0-5) 
- `GetMethodFeeController` returns an empty `AuthorityInfo` with no owner address or contract address [7](#0-6) 
- `GetMethodFee` returns hardcoded fees (100 ELF for Create method only) [8](#0-7) 

**3. Standard Implementation Pattern Violated**

All other AElf contracts follow the ACS1 standard pattern documented in the codebase. [9](#0-8) 

For example, the MultiToken contract properly implements `RequiredMethodFeeControllerSet()` that initializes the controller with Parliament's default organization: [10](#0-9) 

The proper implementation checks permissions before allowing fee modifications: [11](#0-10) 

**4. No Initialization Path**

The NFT contract has no Initialize method and the initialization provider returns an empty list: [12](#0-11) 

### Impact Explanation

**Governance Authority Completely Lost:**
- `GetMethodFeeController` returns an empty `AuthorityInfo` with no `OwnerAddress`, meaning there is no governance authority that can claim control
- Even if someone attempts to call `SetMethodFee` or `ChangeMethodFeeController`, these methods do nothing - they simply return empty without modifying any state
- There is no way to establish proper governance after contract deployment

**Hardcoded Fees Cannot Be Changed:**
- The Create method has a hardcoded fee of 100 ELF (10 billion base units) that can never be adjusted
- All other methods have no fees configured and cannot have fees set
- Protocol economics become permanently inflexible

**Violation of AElf Standards:**
- The contract violates the ACS1 standard that all system contracts must follow
- Integration with AElf's governance framework (Parliament requiring 2/3 block producer approval for fee changes) is broken
- This creates inconsistency across the AElf ecosystem where all other contracts support proper fee governance

**Permanent and Irreversible:**
- Since the contract lacks the state variables and initialization logic, there is no code path that could ever establish proper governance
- This is not a bug that can be worked around - it requires contract redeployment

**Severity: HIGH** - This completely breaks a critical governance mechanism with no recovery path, affecting all NFT protocol creators and users who will be unable to adjust transaction fees in response to changing network conditions or token valuations.

### Likelihood Explanation

**Certainty: 100%**

This is not a potential vulnerability - it is a definite implementation flaw that exists in the deployed code:

- The missing state variables are easily verifiable by inspection
- The empty method implementations are present in the codebase
- No initialization occurs as confirmed by the initialization provider
- The issue manifests immediately upon any attempt to use fee governance

**No Attack Required:**
- This is not an exploitable vulnerability requiring an attacker
- It is a fundamental design/implementation flaw that affects normal operations
- Anyone attempting to query `GetMethodFeeController` will receive an empty result
- Anyone attempting to call `SetMethodFee` will see no effect

**Affects All Users:**
- Every NFT protocol created through this contract is affected
- The governance limitation cannot be bypassed by any user action
- Even protocol creators with legitimate authority cannot modify fees

### Recommendation

**Immediate Actions:**

1. **Add Required State Variables** to `NFTContractState.cs`:
```csharp
public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
public MappedState<string, MethodFees> TransactionFees { get; set; }
```

2. **Implement RequiredMethodFeeControllerSet Helper Method**:
```csharp
private void RequiredMethodFeeControllerSet()
{
    if (State.MethodFeeController.Value != null) return;
    if (State.ParliamentContract.Value == null)
        State.ParliamentContract.Value = 
            Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
    
    var defaultAuthority = new AuthorityInfo();
    if (State.ParliamentContract.Value != null)
    {
        defaultAuthority.OwnerAddress = 
            State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
        defaultAuthority.ContractAddress = State.ParliamentContract.Value;
    }
    State.MethodFeeController.Value = defaultAuthority;
}
```

3. **Fix SetMethodFee Method** following the standard pattern from MultiToken contract

4. **Fix ChangeMethodFeeController Method** with proper permission checks

5. **Fix GetMethodFeeController Method** to return the initialized controller

6. **Fix GetMethodFee Method** to read from `State.TransactionFees[input.Value]` instead of hardcoded values

7. **Add Contract Redeployment Plan** as this cannot be fixed via upgrade without state migration

**Testing Requirements:**

- Test that `GetMethodFeeController` returns Parliament's default organization after first call
- Test that only the controller owner can call `SetMethodFee`
- Test that fee changes persist in state and are retrievable via `GetMethodFee`
- Test that `ChangeMethodFeeController` requires current controller permission
- Add integration tests verifying Parliament governance flow for fee changes

### Proof of Concept

**Initial State:**
- NFT contract deployed without Initialize method being called (as initialization provider returns empty list)

**Step 1 - Query Controller (Anyone can call):**
```
Call: GetMethodFeeController(Empty)
Expected (standard): Returns AuthorityInfo with OwnerAddress = Parliament default organization
Actual: Returns empty AuthorityInfo { OwnerAddress: null, ContractAddress: null }
Result: ✗ FAIL - No governance authority exists
```

**Step 2 - Attempt to Set Fee (Parliament tries via proposal):**
```
Call: SetMethodFee(MethodFees { MethodName: "Mint", Fees: [...] })
Expected (standard): Checks sender == MethodFeeController.Value.OwnerAddress, then updates State.TransactionFees
Actual: Returns Empty without checking anything or updating state
Result: ✗ FAIL - Method does nothing, fees unchanged
```

**Step 3 - Verify Fee Not Changed:**
```
Call: GetMethodFee("Mint")
Expected: Returns the fees set in Step 2
Actual: Returns empty MethodFees (hardcoded logic only returns fees for "Create")
Result: ✗ FAIL - Fee governance completely non-functional
```

**Step 4 - Attempt to Change Controller (Anyone tries):**
```
Call: ChangeMethodFeeController(AuthorityInfo { OwnerAddress: AttackerAddress, ContractAddress: X })
Expected (standard): Assert sender == current controller owner, then update
Actual: Returns Empty without checking anything or updating state
Result: ✗ FAIL - No permission check, but also no effect - controller remains permanently broken
```

**Success Condition:**
The vulnerability is confirmed when `GetMethodFeeController` returns an empty `AuthorityInfo` and both `SetMethodFee` and `ChangeMethodFeeController` have no effect on contract state, leaving fee governance permanently inoperable.

### Notes

This vulnerability is particularly severe because:

1. It affects a deployed system contract that should follow AElf standards
2. The NFT contract claims ACS1 compliance by inheriting from `acs1.proto` [13](#0-12)  but fails to implement it correctly
3. Unlike a runtime exploit, this is a permanent architectural flaw requiring contract redeployment
4. The hardcoded 100 ELF fee for Create may become economically unreasonable as token values change, with no mechanism to adjust it

### Citations

**File:** contract/AElf.Contracts.MultiToken/TokenContractState.cs (L52-52)
```csharp
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.Consensus.AEDPoS/AElfConsensusContractState.cs (L50-50)
```csharp
    public SingletonState<AuthorityInfo> MethodFeeController { get; set; }
```

**File:** contract/AElf.Contracts.NFT/NFTContractState.cs (L1-46)
```csharp
﻿using AElf.Sdk.CSharp.State;
using AElf.Types;

namespace AElf.Contracts.NFT;

public partial class NFTContractState : ContractState
{
    public Int64State NftProtocolNumberFlag { get; set; }
    public Int32State CurrentSymbolNumberLength { get; set; }
    public MappedState<long, bool> IsCreatedMap { get; set; }

    /// <summary>
    ///     Symbol -> Addresses have permission to mint this token
    /// </summary>
    public MappedState<string, MinterList> MinterListMap { get; set; }

    public MappedState<Hash, NFTInfo> NftInfoMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Balance
    /// </summary>
    public MappedState<Hash, Address, long> BalanceMap { get; set; }

    public MappedState<string, NFTProtocolInfo> NftProtocolMap { get; set; }

    /// <summary>
    ///     Token Hash -> Owner Address -> Spender Address -> Approved Amount
    ///     Need to record approved by whom.
    /// </summary>
    public MappedState<Hash, Address, Address, long> AllowanceMap { get; set; }

    public MappedState<Hash, AssembledNfts> AssembledNftsMap { get; set; }
    public MappedState<Hash, AssembledFts> AssembledFtsMap { get; set; }

    public MappedState<string, string> NFTTypeShortNameMap { get; set; }
    public MappedState<string, string> NFTTypeFullNameMap { get; set; }

    public SingletonState<Address> ParliamentDefaultAddress { get; set; }

    public SingletonState<NFTTypes> NFTTypes { get; set; }

    /// <summary>
    ///     Symbol (Protocol) -> Owner Address -> Operator Address List
    /// </summary>
    public MappedState<string, Address, AddressList> OperatorMap { get; set; }
}
```

**File:** contract/AElf.Contracts.NFT/NFTContractReferenceState.cs (L1-15)
```csharp
using AElf.Contracts.MultiToken;
using AElf.Contracts.Parliament;
using AElf.Standards.ACS6;

namespace AElf.Contracts.NFT;

public partial class NFTContractState
{
    internal TokenContractContainer.TokenContractReferenceState TokenContract { get; set; }

    internal RandomNumberProviderContractContainer.RandomNumberProviderContractReferenceState
        RandomNumberProviderContract { get; set; }

    internal ParliamentContractContainer.ParliamentContractReferenceState ParliamentContract { get; set; }
}
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L8-11)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L13-16)
```csharp
    public override Empty ChangeMethodFeeController(AuthorityInfo input)
    {
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L20-37)
```csharp
    public override MethodFees GetMethodFee(StringValue input)
    {
        if (input.Value == nameof(Create))
            return new MethodFees
            {
                MethodName = input.Value,
                Fees =
                {
                    new MethodFee
                    {
                        Symbol = Context.Variables.NativeSymbol,
                        BasicFee = 100_00000000
                    }
                }
            };

        return new MethodFees();
    }
```

**File:** contract/AElf.Contracts.NFT/NFTContract_ACS1.cs (L39-42)
```csharp
    public override AuthorityInfo GetMethodFeeController(Empty input)
    {
        return new AuthorityInfo();
    }
```

**File:** docs-sphinx/reference/acs/acs1.rst (L300-350)
```text
others.

Referring to the ``MultiToken contract``, it can be implemented as
follows:

Firstly, define a ``SingletonState`` with type ``AuthorityInfo``\ (in
authority_info.proto)

.. code:: c#

   public SingletonState<AuthorityInfo> MethodFeeController { get; set; }

Then, check the sender’s right by comparing its address with owner.

.. code:: c#

   public override Empty SetMethodFee(MethodFees input)
   {
     foreach (var symbolToAmount in input.Fees)
     {
        AssertValidToken(symbolToAmount.Symbol, symbolToAmount.BasicFee); 
     }
     RequiredMethodFeeControllerSet();
     Assert(Context.Sender ==             State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");
       State.TransactionFees[input.MethodName] = input;
       return new Empty();
   }

AssertValidToken checks if the token symbol exists, and the ``BasicFee``
is reasonable.

The permission check code is in the lines 8 and 9, and
``RequiredMethodFeeControllerSet`` prevents the permission is not set
before.

If permissions are not set, the ``SetMethodFee`` method can only be
called by the default address of the Parliament organization. If a
method is sent through this organization, it means that two-thirds of
the block producers have agreed to the proposal.

.. code:: c#

   private void RequiredMethodFeeControllerSet()
   {
      if (State.MethodFeeController.Value != null) return;
      if (State.ParliamentContract.Value == null)
      {
        State.ParliamentContract.Value =         Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);
      }
      var defaultAuthority = new AuthorityInfo();
      // Parliament Auth Contract maybe not deployed.
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L13-22)
```csharp
    public override Empty SetMethodFee(MethodFees input)
    {
        foreach (var symbolToAmount in input.Fees) AssertValidFeeToken(symbolToAmount.Symbol, symbolToAmount.BasicFee);

        RequiredMethodFeeControllerSet();
        Assert(Context.Sender == State.MethodFeeController.Value.OwnerAddress, "Unauthorized to set method fee.");

        State.TransactionFees[input.MethodName] = input;
        return new Empty();
    }
```

**File:** contract/AElf.Contracts.MultiToken/TokenContract_ACS1_MethodFeeProvider.cs (L91-109)
```csharp
    private void RequiredMethodFeeControllerSet()
    {
        if (State.MethodFeeController.Value != null) return;
        if (State.ParliamentContract.Value == null)
            State.ParliamentContract.Value =
                Context.GetContractAddressByName(SmartContractConstants.ParliamentContractSystemName);

        var defaultAuthority = new AuthorityInfo();

        // Parliament Auth Contract maybe not deployed.
        if (State.ParliamentContract.Value != null)
        {
            defaultAuthority.OwnerAddress =
                State.ParliamentContract.GetDefaultOrganizationAddress.Call(new Empty());
            defaultAuthority.ContractAddress = State.ParliamentContract.Value;
        }

        State.MethodFeeController.Value = defaultAuthority;
    }
```

**File:** test/AElf.Contracts.NFT.Tests/NFTContractInitializationProvider.cs (L13-16)
```csharp
    public List<ContractInitializationMethodCall> GetInitializeMethodList(byte[] contractCode)
    {
        return new List<ContractInitializationMethodCall>();
    }
```

**File:** protobuf/nft_contract.proto (L18-20)
```text
service NFTContract {
    option (aelf.csharp_state) = "AElf.Contracts.NFT.NFTContractState";
    option (aelf.base) = "acs1.proto";
```
