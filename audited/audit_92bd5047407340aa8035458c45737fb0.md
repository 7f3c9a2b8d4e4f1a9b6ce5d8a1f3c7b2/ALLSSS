### Title
Parliament Governance DoS via Forced Managed Pubkey Accumulation

### Summary
The `AnnounceElectionFor` method allows any caller to specify an arbitrary admin address without permission checks, enabling attackers to force accumulation of managed pubkeys in any address's `ManagedCandidatePubkeysMap`. Since Parliament contract explicitly rejects admins with multiple managed pubkeys from voting on proposals, an attacker can permanently lock out current Parliament members from governance participation by forcing them to manage multiple candidates.

### Finding Description

**Root Cause:**

The `AnnounceElectionFor` method accepts an admin address as input and directly assigns it without validating that the caller has authorization to designate that address as admin. [1](#0-0) 

The admin parameter can be any address, and the method unconditionally adds the new pubkey to that admin's `ManagedCandidatePubkeysMap`: [2](#0-1) 

**Why Protections Fail:**

There is no permission check preventing an attacker from specifying a victim's address as the admin. The only requirement is that the attacker pays the lock fee (100,000 tokens per candidate). [3](#0-2) 

**Exploitation Path:**

Once a Parliament member has accumulated multiple managed pubkeys, the Parliament contract's `GetAndCheckActualParliamentMemberAddress` method explicitly rejects them: [4](#0-3) 

This check is invoked during all Parliament voting operations, effectively locking the victim out of governance. [5](#0-4) 

### Impact Explanation

**Harm:**
- Current Parliament members (miners) can be permanently denied the ability to vote on proposals, create proposals, or participate in any Parliament governance actions
- This breaks the governance invariant that authorized Parliament members should be able to participate in decision-making
- Multiple Parliament members can be targeted simultaneously, potentially compromising the entire governance process

**Quantified Damage:**
- Per victim cost: 200,000 tokens (2 candidates × 100,000 tokens)
- To DoS majority of Parliament: N/2 × 200,000 tokens where N is number of miners

**Who is Affected:**
- Current and future Parliament members (miners) whose addresses are publicly known
- The entire AElf governance system if multiple members are targeted
- Any address that could legitimately become a Parliament member in the future

**Severity: High**
This is a governance DoS vulnerability that can completely disable Parliament decision-making capabilities with economically feasible attack costs.

### Likelihood Explanation

**Attacker Capabilities:**
- Attacker needs sufficient tokens to pay lock fees (100,000 tokens per candidate)
- Attacker needs to generate or control multiple public keys
- Attacker needs to know target Parliament member addresses (publicly available on-chain)

**Attack Complexity:**
- Low complexity: Two simple transactions per victim
  1. Call `AnnounceElectionFor(pubkey1, victimAddress)`
  2. Call `AnnounceElectionFor(pubkey2, victimAddress)`
- No timing constraints or race conditions
- No need to compromise any existing accounts

**Feasibility Conditions:**
- Attack is immediately executable on current contract
- No special state requirements
- Persists until candidates quit election (which they may never do)

**Detection Constraints:**
- No event emissions that clearly indicate malicious intent
- Appears as normal candidate announcements
- Victim only discovers when attempting to vote

**Probability: High**
The attack cost (200,000 tokens per victim) is economically rational for an attacker seeking to:
- Prevent specific governance decisions
- Destabilize the network
- Gain competitive advantage in mining/consensus

### Recommendation

**Code-Level Mitigation:**

Add permission validation in `AnnounceElectionFor` to ensure only authorized parties can set an admin address:

```csharp
public override Empty AnnounceElectionFor(AnnounceElectionForInput input)
{
    var pubkeyBytes = ByteArrayHelper.HexStringToByteArray(input.Pubkey);
    var candidateAddress = Address.FromPublicKey(pubkeyBytes);
    var admin = input.Admin ?? Context.Sender;
    
    // NEW: Verify caller authorization
    Assert(Context.Sender == admin || 
           Context.Sender == candidateAddress ||
           Context.Sender == GetParliamentDefaultAddress(),
           "No permission to set this admin.");
    
    AnnounceElection(pubkeyBytes);
    // ... rest of method
}
```

**Invariant Checks:**

Add a limit to the number of managed pubkeys per admin:

```csharp
var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
Assert(managedPubkeys.Value.Count < MAX_MANAGED_PUBKEYS, 
       "Admin already manages maximum number of candidates.");
managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
```

**Test Cases:**

1. Test that non-admin cannot call `AnnounceElectionFor` specifying another address as admin
2. Test that admin limit is enforced
3. Test that Parliament members with single managed pubkey can still vote
4. Test that attempting to exceed limit reverts transaction

### Proof of Concept

**Initial State:**
- Victim is a current Parliament member (miner) at address V
- Attacker has 200,000+ tokens
- Attacker controls two fresh pubkeys: PK1 and PK2

**Attack Sequence:**

1. **Transaction 1:** Attacker calls `AnnounceElectionFor`
   - Input: `{pubkey: PK1, admin: V}`
   - Result: V's `ManagedCandidatePubkeysMap` contains [PK1]
   - Cost: 100,000 tokens locked

2. **Transaction 2:** Attacker calls `AnnounceElectionFor` again
   - Input: `{pubkey: PK2, admin: V}`
   - Result: V's `ManagedCandidatePubkeysMap` contains [PK1, PK2]
   - Cost: 100,000 tokens locked

3. **Verification:** Victim V attempts to vote on Parliament proposal
   - Calls Parliament contract voting method
   - Method invokes `GetAndCheckActualParliamentMemberAddress()`
   - Retrieves `managedPubkey.Value.Count` = 2
   - Assertion fails: "Admin with multiple managed pubkeys cannot handle proposal."
   - Transaction reverts

**Expected vs Actual:**
- Expected: Victim V can vote as legitimate Parliament member
- Actual: Victim V is permanently locked out of all Parliament governance functions

**Success Condition:**
Victim cannot vote, approve, or reject any Parliament proposals despite being a legitimate current miner with proper authority.

### Citations

**File:** contract/AElf.Contracts.Election/ElectionContract_Candidate.cs (L127-131)
```csharp
        var admin = input.Admin ?? Context.Sender;
        State.CandidateAdmins[pubkey] = admin;
        var managedPubkeys = State.ManagedCandidatePubkeysMap[admin] ?? new PubkeyList();
        managedPubkeys.Value.Add(ByteString.CopyFrom(pubkeyBytes));
        State.ManagedCandidatePubkeysMap[admin] = managedPubkeys;
```

**File:** protobuf/election_contract.proto (L519-522)
```text
message AnnounceElectionForInput {
    string pubkey = 1;
    aelf.Address admin = 2;
}
```

**File:** contract/AElf.Contracts.Election/ElectionContractConstants.cs (L5-5)
```csharp
    public const long LockTokenForElection = 100_000_00000000;
```

**File:** contract/AElf.Contracts.Parliament/Parliament_Helper.cs (L129-139)
```csharp
        var managedPubkey = State.ElectionContract.GetManagedPubkeys.Call(Context.Sender);
        if (!managedPubkey.Value.Any()) throw new AssertionException("Unauthorized sender.");

        if (managedPubkey.Value.Count > 1)
            throw new AssertionException("Admin with multiple managed pubkeys cannot handle proposal.");

        var actualMemberAddress = Address.FromPublicKey(managedPubkey.Value.Single().ToByteArray());
        if (!currentParliament.Any(r => r.Equals(actualMemberAddress)))
            throw new AssertionException("Unauthorized sender.");

        return actualMemberAddress;
```
